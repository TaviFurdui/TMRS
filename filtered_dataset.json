[
    {
        "func": "  Parser_state()\n    : m_yacc()\n  {}",
        "target": 0
    },
    {
        "func": "LEX::sp_variable_declarations_table_rowtype_finalize(THD *thd, int nvars,\n                                                     const LEX_CSTRING &db,\n                                                     const LEX_CSTRING &table,\n                                                     Item *def)\n{\n  Table_ident *table_ref;\n  if (unlikely(!(table_ref=\n                 new (thd->mem_root) Table_ident(thd, &db, &table, false))))\n    return true;\n  // Loop through all variables in the same declaration\n  for (uint i= 0 ; i < (uint) nvars; i++)\n  {\n    sp_variable *spvar= spcont->get_last_context_variable((uint) nvars - 1 - i);\n    spvar->field_def.set_table_rowtype_ref(table_ref);\n    sphead->fill_spvar_definition(thd, &spvar->field_def, &spvar->name);\n  }\n  if (sp_variable_declarations_set_default(thd, nvars, def))\n    return true;\n  // Make sure sp_rcontext is created using the invoker security context:\n  sphead->m_flags|= sp_head::HAS_COLUMN_TYPE_REFS;\n  spcont->declare_var_boundary(0);\n  return sphead->restore_lex(thd);\n}",
        "target": 0
    },
    {
        "func": "  const char *get_cpp_buf()\n  {\n    return m_cpp_buf;\n  }",
        "target": 0
    },
    {
        "func": "  Lex_ident_cli(const char *s, size_t len)\n  {\n    set_ident(s, len, false);\n  }",
        "target": 0
    },
    {
        "func": "  bool add_create_index_prepare(Table_ident *table)\n  {\n    sql_command= SQLCOM_CREATE_INDEX;\n    if (!current_select->add_table_to_list(thd, table, NULL,\n                                           TL_OPTION_UPDATING,\n                                           TL_READ_NO_INSERT,\n                                           MDL_SHARED_UPGRADABLE))\n      return true;\n    alter_info.reset();\n    alter_info.flags= ALTER_ADD_INDEX;\n    option_list= NULL;\n    return false;\n  }",
        "target": 0
    },
    {
        "func": "  inline bool is_subquery_function() { return master_unit()->item != 0; }",
        "target": 0
    },
    {
        "func": "int Lex_input_stream::scan_ident_middle(THD *thd, Lex_ident_cli_st *str,\n                                        CHARSET_INFO **introducer,\n                                        my_lex_states *st)\n{\n  CHARSET_INFO *const cs= thd->charset();\n  const uchar *const ident_map= cs->ident_map;\n  const uchar *const state_map= cs->state_map;\n  const char *start;\n  uint length;\n  uchar c;\n  bool is_8bit;\n  bool resolve_introducer= true;\n  DBUG_ASSERT(m_ptr == m_tok_start + 1); // m_ptr points to the second byte\n\n  if (use_mb(cs))\n  {\n    is_8bit= true;\n    int char_length= my_charlen(cs, get_ptr() - 1, get_end_of_query());\n    if (char_length <= 0)\n    {\n      *st= MY_LEX_CHAR;\n      return 0;\n    }\n    skip_binary(char_length - 1);\n\n    while (ident_map[c= yyGet()])\n    {\n      char_length= my_charlen(cs, get_ptr() - 1, get_end_of_query());\n      if (char_length <= 0)\n        break;\n      if (char_length > 1 || (c & 0x80))\n        resolve_introducer= false;\n      skip_binary(char_length - 1);\n    }\n  }\n  else\n  {\n    is_8bit= get_7bit_or_8bit_ident(thd, &c) || (m_tok_start[0] & 0x80);\n    resolve_introducer= !is_8bit;\n  }\n  length= yyLength();\n  start= get_ptr();\n  if (ignore_space)\n  {\n    /*\n      If we find a space then this can't be an identifier. We notice this\n      below by checking start != lex->ptr.\n    */\n    for (; state_map[(uchar) c] == MY_LEX_SKIP ; c= yyGet())\n    {\n      if (c == '\\n')\n        yylineno++;\n    }\n  }\n  if (start == get_ptr() && c == '.' && ident_map[(uchar) yyPeek()])\n    next_state= MY_LEX_IDENT_SEP;\n  else\n  {                                    // '(' must follow directly if function\n    int tokval;\n    yyUnget();\n    if ((tokval= find_keyword(str, length, c == '(')))\n    {\n      next_state= MY_LEX_START;        // Allow signed numbers\n      return(tokval);                  // Was keyword\n    }\n    yySkip();                  // next state does a unget\n  }\n\n  yyUnget();                       // ptr points now after last token char\n  str->set_ident(m_tok_start, length, is_8bit);\n  m_cpp_text_start= m_cpp_tok_start;\n  m_cpp_text_end= m_cpp_text_start + length;\n\n  /*\n     Note: \"SELECT _bla AS 'alias'\"\n     _bla should be considered as a IDENT if charset haven't been found.\n     So we don't use MYF(MY_WME) with get_charset_by_csname to avoid\n     producing an error.\n  */\n  DBUG_ASSERT(length > 0);\n  if (resolve_introducer && m_tok_start[0] == '_')\n  {\n    ErrConvString csname(str->str + 1, str->length - 1, &my_charset_bin);\n    CHARSET_INFO *cs= get_charset_by_csname(csname.ptr(),\n                                            MY_CS_PRIMARY, MYF(0));\n    if (cs)\n    {\n      body_utf8_append(m_cpp_text_start, m_cpp_tok_start + length);\n      *introducer= cs;\n      return UNDERSCORE_CHARSET;\n    }\n  }\n\n  body_utf8_append(m_cpp_text_start);\n  body_utf8_append_ident(thd, str, m_cpp_text_end);\n  return is_8bit ? IDENT_QUOTED : IDENT;\n}",
        "target": 0
    },
    {
        "func": "bool LEX::create_or_alter_view_finalize(THD *thd, Table_ident *table_ident)\n{\n  sql_command= SQLCOM_CREATE_VIEW;\n  /* first table in list is target VIEW name */\n  if (!first_select_lex()->add_table_to_list(thd, table_ident, NULL,\n                                             TL_OPTION_UPDATING,\n                                             TL_IGNORE,\n                                             MDL_EXCLUSIVE))\n    return true;\n  query_tables->open_strategy= TABLE_LIST::OPEN_STUB;\n  return false;\n}",
        "target": 0
    },
    {
        "func": "check_access(THD *thd, ulong want_access, const char *db, ulong *save_priv,\n             GRANT_INTERNAL_INFO *grant_internal_info,\n             bool dont_check_global_grants, bool no_errors)\n{\n#ifdef NO_EMBEDDED_ACCESS_CHECKS\n  if (save_priv)\n    *save_priv= GLOBAL_ACLS;\n  return false;\n#else\n  Security_context *sctx= thd->security_ctx;\n  ulong db_access;\n\n  /*\n    GRANT command:\n    In case of database level grant the database name may be a pattern,\n    in case of table|column level grant the database name can not be a pattern.\n    We use 'dont_check_global_grants' as a flag to determine\n    if it's database level grant command\n    (see SQLCOM_GRANT case, mysql_execute_command() function) and\n    set db_is_pattern according to 'dont_check_global_grants' value.\n  */\n  bool  db_is_pattern= ((want_access & GRANT_ACL) && dont_check_global_grants);\n  ulong dummy;\n  DBUG_ENTER(\"check_access\");\n  DBUG_PRINT(\"enter\",(\"db: %s  want_access: %lu  master_access: %lu\",\n                      db ? db : \"\", want_access, sctx->master_access));\n\n  if (save_priv)\n    *save_priv=0;\n  else\n  {\n    save_priv= &dummy;\n    dummy= 0;\n  }\n\n  /* check access may be called twice in a row. Don't change to same stage */\n  if (thd->proc_info != stage_checking_permissions.m_name)\n    THD_STAGE_INFO(thd, stage_checking_permissions);\n  if (unlikely((!db || !db[0]) && !thd->db.str && !dont_check_global_grants))\n  {\n    DBUG_RETURN(FALSE); // CTE reference or an error later\n  }\n\n  if (likely((db != NULL) && (db != any_db)))\n  {\n    /*\n      Check if this is reserved database, like information schema or\n      performance schema\n    */\n    const ACL_internal_schema_access *access;\n    access= get_cached_schema_access(grant_internal_info, db);\n    if (access)\n    {\n      switch (access->check(want_access, save_priv))\n      {\n      case ACL_INTERNAL_ACCESS_GRANTED:\n        /*\n          All the privileges requested have been granted internally.\n          [out] *save_privileges= Internal privileges.\n        */\n        DBUG_RETURN(FALSE);\n      case ACL_INTERNAL_ACCESS_DENIED:\n        if (! no_errors)\n        {\n          status_var_increment(thd->status_var.access_denied_errors);\n          my_error(ER_DBACCESS_DENIED_ERROR, MYF(0),\n                   sctx->priv_user, sctx->priv_host, db);\n        }\n        DBUG_RETURN(TRUE);\n      case ACL_INTERNAL_ACCESS_CHECK_GRANT:\n        /*\n          Only some of the privilege requested have been granted internally,\n          proceed with the remaining bits of the request (want_access).\n        */\n        want_access&= ~(*save_priv);\n        break;\n      }\n    }\n  }\n\n  if ((sctx->master_access & want_access) == want_access)\n  {\n    /*\n      1. If we don't have a global SELECT privilege, we have to get the\n      database specific access rights to be able to handle queries of type\n      UPDATE t1 SET a=1 WHERE b > 0\n      2. Change db access if it isn't current db which is being addressed\n    */\n    if (!(sctx->master_access & SELECT_ACL))\n    {\n      if (db && (!thd->db.str || db_is_pattern || strcmp(db, thd->db.str)))\n      {\n        db_access= acl_get(sctx->host, sctx->ip, sctx->priv_user, db,\n                           db_is_pattern);\n        if (sctx->priv_role[0])\n          db_access|= acl_get(\"\", \"\", sctx->priv_role, db, db_is_pattern);\n      }\n      else\n      {\n        /* get access for current db */\n        db_access= sctx->db_access;\n      }\n      /*\n        The effective privileges are the union of the global privileges\n        and the intersection of db- and host-privileges,\n        plus the internal privileges.\n      */\n      *save_priv|= sctx->master_access | db_access;\n    }\n    else\n      *save_priv|= sctx->master_access;\n    DBUG_RETURN(FALSE);\n  }\n  if (unlikely(((want_access & ~sctx->master_access) & ~DB_ACLS) ||\n               (! db && dont_check_global_grants)))\n  {\t\t\t\t\t\t// We can never grant this\n    DBUG_PRINT(\"error\",(\"No possible access\"));\n    if (!no_errors)\n    {\n      status_var_increment(thd->status_var.access_denied_errors);\n      my_error(access_denied_error_code(thd->password), MYF(0),\n               sctx->priv_user,\n               sctx->priv_host,\n               (thd->password ?\n                ER_THD(thd, ER_YES) :\n                ER_THD(thd, ER_NO)));                    /* purecov: tested */\n    }\n    DBUG_RETURN(TRUE);\t\t\t\t/* purecov: tested */\n  }\n\n  if (unlikely(db == any_db))\n  {\n    /*\n      Access granted; Allow select on *any* db.\n      [out] *save_privileges= 0\n    */\n    DBUG_RETURN(FALSE);\n  }\n\n  if (db && (!thd->db.str || db_is_pattern || strcmp(db, thd->db.str)))\n  {\n    db_access= acl_get(sctx->host, sctx->ip, sctx->priv_user, db,\n                       db_is_pattern);\n    if (sctx->priv_role[0])\n    {\n      db_access|= acl_get(\"\", \"\", sctx->priv_role, db, db_is_pattern);\n    }\n  }\n  else\n    db_access= sctx->db_access;\n  DBUG_PRINT(\"info\",(\"db_access: %lu  want_access: %lu\",\n                     db_access, want_access));\n\n  /*\n    Save the union of User-table and the intersection between Db-table and\n    Host-table privileges, with the already saved internal privileges.\n  */\n  db_access= (db_access | sctx->master_access);\n  *save_priv|= db_access;\n\n  /*\n    We need to investigate column- and table access if all requested privileges\n    belongs to the bit set of .\n  */\n  bool need_table_or_column_check=\n    (want_access & (TABLE_ACLS | PROC_ACLS | db_access)) == want_access;\n\n  /*\n    Grant access if the requested access is in the intersection of\n    host- and db-privileges (as retrieved from the acl cache),\n    also grant access if all the requested privileges are in the union of\n    TABLES_ACLS and PROC_ACLS; see check_grant.\n  */\n  if ( (db_access & want_access) == want_access ||\n      (!dont_check_global_grants &&\n       need_table_or_column_check))\n  {\n    /*\n       Ok; but need to check table- and column privileges.\n       [out] *save_privileges is (User-priv | (Db-priv & Host-priv) | Internal-priv)\n    */\n    DBUG_RETURN(FALSE);\n  }\n\n  /*\n    Access is denied;\n    [out] *save_privileges is (User-priv | (Db-priv & Host-priv) | Internal-priv)\n  */\n  DBUG_PRINT(\"error\",(\"Access denied\"));\n  if (!no_errors)\n  {\n    status_var_increment(thd->status_var.access_denied_errors);\n    my_error(ER_DBACCESS_DENIED_ERROR, MYF(0),\n             sctx->priv_user, sctx->priv_host,\n             (db ? db : (thd->db.str ?\n                         thd->db.str :\n                         \"unknown\")));\n  }\n  DBUG_RETURN(TRUE);\n#endif // NO_EMBEDDED_ACCESS_CHECKS\n}",
        "target": 0
    },
    {
        "func": "Item *LEX::make_item_func_call_generic(THD *thd,\n                                       Lex_ident_cli_st *cdb,\n                                       Lex_ident_cli_st *cpkg,\n                                       Lex_ident_cli_st *cfunc,\n                                       List<Item> *args)\n{\n  static Lex_cstring dot(\".\", 1);\n  Lex_ident_sys db(thd, cdb), pkg(thd, cpkg), func(thd, cfunc);\n  Database_qualified_name q_db_pkg(db, pkg);\n  Database_qualified_name q_pkg_func(pkg, func);\n  sp_name *qname;\n\n  if (db.is_null() || pkg.is_null() || func.is_null())\n    return NULL; // EOM\n\n  if (check_db_name((LEX_STRING*) static_cast<LEX_CSTRING*>(&db)))\n  {\n    my_error(ER_WRONG_DB_NAME, MYF(0), db.str);\n    return NULL;\n  }\n  if (check_routine_name(&pkg) ||\n      check_routine_name(&func))\n    return NULL;\n\n  // Concat `pkg` and `name` to `pkg.name`\n  LEX_CSTRING pkg_dot_func;\n  if (q_pkg_func.make_qname(thd->mem_root, &pkg_dot_func) ||\n      check_ident_length(&pkg_dot_func) ||\n      !(qname= new (thd->mem_root) sp_name(&db, &pkg_dot_func, true)))\n    return NULL;\n\n  sp_handler_package_function.add_used_routine(thd->lex, thd, qname);\n  sp_handler_package_body.add_used_routine(thd->lex, thd, &q_db_pkg);\n\n  thd->lex->safe_to_cache_query= 0;\n\n  if (args && args->elements > 0)\n    return new (thd->mem_root) Item_func_sp(thd, thd->lex->current_context(),\n                                            qname, &sp_handler_package_function,\n                                            *args);\n  return new (thd->mem_root) Item_func_sp(thd, thd->lex->current_context(),\n                                          qname, &sp_handler_package_function);\n}",
        "target": 0
    },
    {
        "func": "size_t Lex_input_stream::get_body_utf8_maximum_length(THD *thd)\n{\n  /*\n    String literals can grow during escaping:\n    1a. Character string '<TAB>' can grow to '\\t', 3 bytes to 4 bytes growth.\n    1b. Character string '1000 times <TAB>' grows from\n        1002 to 2002 bytes (including quotes), which gives a little bit\n        less than 2 times growth.\n    \"2\" should be a reasonable multiplier that safely covers escaping needs.\n  */\n  return (m_buf_length / thd->variables.character_set_client->mbminlen) *\n          my_charset_utf8_bin.mbmaxlen * 2/*for escaping*/;\n}",
        "target": 0
    },
    {
        "func": "bool st_select_lex::setup_ref_array(THD *thd, uint order_group_num)\n{\n\n  if (!((options & SELECT_DISTINCT) && !group_list.elements))\n    hidden_bit_fields= 0;\n\n  // find_order_in_list() may need some extra space, so multiply by two.\n  order_group_num*= 2;\n\n  /*\n    We have to create array in prepared statement memory if it is a\n    prepared statement\n  */\n  Query_arena *arena= thd->stmt_arena;\n  const size_t n_elems= (n_sum_items +\n                       n_child_sum_items +\n                       item_list.elements +\n                       select_n_reserved +\n                       select_n_having_items +\n                       select_n_where_fields +\n                       order_group_num +\n                       hidden_bit_fields +\n                       fields_in_window_functions) * (size_t) 5;\n  DBUG_ASSERT(n_elems % 5 == 0);\n  if (!ref_pointer_array.is_null())\n  {\n    /*\n      We need to take 'n_sum_items' into account when allocating the array,\n      and this may actually increase during the optimization phase due to\n      MIN/MAX rewrite in Item_in_subselect::single_value_transformer.\n      In the usual case we can reuse the array from the prepare phase.\n      If we need a bigger array, we must allocate a new one.\n     */\n    if (ref_pointer_array.size() >= n_elems)\n      return false;\n   }\n  Item **array= static_cast<Item**>(arena->alloc(sizeof(Item*) * n_elems));\n  if (likely(array != NULL))\n    ref_pointer_array= Ref_ptr_array(array, n_elems);\n\n  return array == NULL;\n}",
        "target": 0
    },
    {
        "func": "SELECT_LEX *LEX::exclude_last_select()\n{\n  return exclude_not_first_select(current_select);\n}",
        "target": 0
    },
    {
        "func": "void st_select_lex::collect_grouping_fields_for_derived(THD *thd,\n                                                        ORDER *grouping_list)\n{\n  grouping_tmp_fields.empty();\n  List_iterator<Item> li(join->fields_list);\n  Item *item= li++;\n  for (uint i= 0; i < master_unit()->derived->table->s->fields;\n       i++, (item=li++))\n  {\n    for (ORDER *ord= grouping_list; ord; ord= ord->next)\n    {\n      if ((*ord->item)->eq((Item*)item, 0))\n      {\n        Field_pair *grouping_tmp_field=\n          new Field_pair(master_unit()->derived->table->field[i], item);\n        grouping_tmp_fields.push_back(grouping_tmp_field);\n      }\n    }\n  }\n}",
        "target": 0
    },
    {
        "func": "bool LEX::sp_proc_stmt_statement_finalize(THD *thd, bool no_lookahead)\n{\n  // Extract the query statement from the tokenizer\n  Lex_input_stream *lip= &thd->m_parser_state->m_lip;\n  Lex_cstring qbuf(sphead->m_tmp_query, no_lookahead ? lip->get_ptr() :\n                                                       lip->get_tok_start());\n  return LEX::sp_proc_stmt_statement_finalize_buf(thd, qbuf);\n}",
        "target": 0
    },
    {
        "func": "  bool cond_pushdown_is_allowed() const\n  { return !olap && !explicit_limit && !tvc; }",
        "target": 0
    },
    {
        "func": "ha_rows st_select_lex::get_offset()\n{\n  ulonglong val= 0;\n\n  if (offset_limit)\n  {\n    // see comment for st_select_lex::get_limit()\n    bool err= offset_limit->fix_fields_if_needed(master_unit()->thd, NULL);\n    DBUG_ASSERT(!err);\n    val= err ? HA_POS_ERROR : offset_limit->val_uint();\n  }\n\n  return (ha_rows)val;\n}",
        "target": 0
    },
    {
        "func": "bool LEX::add_resignal_statement(THD *thd, const sp_condition_value *v)\n{\n  Yacc_state *state= &thd->m_parser_state->m_yacc;\n  sql_command= SQLCOM_RESIGNAL;\n  m_sql_cmd= new (thd->mem_root) Sql_cmd_resignal(v, state->m_set_signal_info);\n  return m_sql_cmd == NULL;\n}",
        "target": 0
    },
    {
        "func": "void LEX::fix_first_select_number()\n{\n  SELECT_LEX *first= first_select_lex();\n  if (first && first->select_number != 1)\n  {\n    uint num= first->select_number;\n    for (SELECT_LEX *sel= all_selects_list;\n         sel;\n         sel= sel->next_select_in_list())\n    {\n      if (sel->select_number < num)\n        sel->select_number++;\n    }\n    first->select_number= 1;\n  }\n}",
        "target": 0
    },
    {
        "func": "Item *LEX::make_item_plsql_cursor_attr(THD *thd, const LEX_CSTRING *name,\n                                       plsql_cursor_attr_t attr)\n{\n  uint offset;\n  if (unlikely(!spcont || !spcont->find_cursor(name, &offset, false)))\n  {\n    my_error(ER_SP_CURSOR_MISMATCH, MYF(0), name->str);\n    return NULL;\n  }\n  switch (attr) {\n  case PLSQL_CURSOR_ATTR_ISOPEN:\n    return new (thd->mem_root) Item_func_cursor_isopen(thd, name, offset);\n  case PLSQL_CURSOR_ATTR_FOUND:\n    return new (thd->mem_root) Item_func_cursor_found(thd, name, offset);\n  case PLSQL_CURSOR_ATTR_NOTFOUND:\n    return new (thd->mem_root) Item_func_cursor_notfound(thd, name, offset);\n  case PLSQL_CURSOR_ATTR_ROWCOUNT:\n    return new (thd->mem_root) Item_func_cursor_rowcount(thd, name, offset);\n  }\n  DBUG_ASSERT(0);\n  return NULL;\n}",
        "target": 0
    },
    {
        "func": "Item *Lex_trim_st::make_item_func_trim_oracle(THD *thd) const\n{\n  if (m_remove)\n  {\n    switch (m_spec) {\n    case TRIM_BOTH:\n      return new (thd->mem_root) Item_func_trim_oracle(thd, m_source, m_remove);\n    case TRIM_LEADING:\n      return new (thd->mem_root) Item_func_ltrim_oracle(thd, m_source, m_remove);\n    case TRIM_TRAILING:\n     return new (thd->mem_root) Item_func_rtrim_oracle(thd, m_source, m_remove);\n    }\n  }\n\n  switch (m_spec) {\n  case TRIM_BOTH:\n    return new (thd->mem_root) Item_func_trim_oracle(thd, m_source);\n  case TRIM_LEADING:\n    return new (thd->mem_root) Item_func_ltrim_oracle(thd, m_source);\n  case TRIM_TRAILING:\n   return new (thd->mem_root) Item_func_rtrim_oracle(thd, m_source);\n  }\n  DBUG_ASSERT(0);\n  return NULL;\n}",
        "target": 0
    },
    {
        "func": "bool st_select_lex::optimize_unflattened_subqueries(bool const_only)\n{\n  SELECT_LEX_UNIT *next_unit= NULL;\n  for (SELECT_LEX_UNIT *un= first_inner_unit();\n       un;\n       un= next_unit ? next_unit : un->next_unit())\n  {\n    Item_subselect *subquery_predicate= un->item;\n    next_unit= NULL;\n\n    if (subquery_predicate)\n    {\n      if (!subquery_predicate->fixed)\n      {\n        /*\n         This subquery was excluded as part of some expression so it is\n         invisible from all prepared expression.\n       */\n        next_unit= un->next_unit();\n        un->exclude_level();\n        if (next_unit)\n          continue;\n        break;\n      }\n      if (subquery_predicate->substype() == Item_subselect::IN_SUBS)\n      {\n        Item_in_subselect *in_subs= (Item_in_subselect*) subquery_predicate;\n        if (in_subs->is_jtbm_merged)\n          continue;\n      }\n\n      if (const_only && !subquery_predicate->const_item())\n      {\n        /* Skip non-constant subqueries if the caller asked so. */\n        continue;\n      }\n\n      bool empty_union_result= true;\n      bool is_correlated_unit= false;\n      bool first= true;\n      bool union_plan_saved= false;\n      /*\n        If the subquery is a UNION, optimize all the subqueries in the UNION. If\n        there is no UNION, then the loop will execute once for the subquery.\n      */\n      for (SELECT_LEX *sl= un->first_select(); sl; sl= sl->next_select())\n      {\n        JOIN *inner_join= sl->join;\n        if (first)\n          first= false;\n        else\n        {\n          if (!union_plan_saved)\n          {\n            union_plan_saved= true;\n            if (un->save_union_explain(un->thd->lex->explain))\n              return true; /* Failure */\n          }\n        }\n        if (!inner_join)\n          continue;\n        SELECT_LEX *save_select= un->thd->lex->current_select;\n        ulonglong save_options;\n        int res;\n        /* We need only 1 row to determine existence */\n        un->set_limit(un->global_parameters());\n        un->thd->lex->current_select= sl;\n        save_options= inner_join->select_options;\n        if (options & SELECT_DESCRIBE)\n        {\n          /* Optimize the subquery in the context of EXPLAIN. */\n          sl->set_explain_type(FALSE);\n          sl->options|= SELECT_DESCRIBE;\n          inner_join->select_options|= SELECT_DESCRIBE;\n        }\n        if ((res= inner_join->optimize()))\n          return TRUE;\n        if (!inner_join->cleaned)\n          sl->update_used_tables();\n        sl->update_correlated_cache();\n        is_correlated_unit|= sl->is_correlated;\n        inner_join->select_options= save_options;\n        un->thd->lex->current_select= save_select;\n\n        Explain_query *eq;\n        if ((eq= inner_join->thd->lex->explain))\n        {\n          Explain_select *expl_sel;\n          if ((expl_sel= eq->get_select(inner_join->select_lex->select_number)))\n          {\n            sl->set_explain_type(TRUE);\n            expl_sel->select_type= sl->type;\n          }\n        }\n\n        if (empty_union_result)\n        {\n          /*\n            If at least one subquery in a union is non-empty, the UNION result\n            is non-empty. If there is no UNION, the only subquery is non-empy.\n          */\n          empty_union_result= inner_join->empty_result();\n        }\n        if (res)\n          return TRUE;\n      }\n      if (empty_union_result)\n        subquery_predicate->no_rows_in_result();\n\n      if (is_correlated_unit)\n      {\n        /*\n          Some parts of UNION are not correlated. This means we will need to\n          re-execute the whole UNION every time. Mark all parts of the UNION\n          as correlated so that they are prepared to be executed multiple\n          times (if we don't do that, some part of the UNION may free its\n          execution data at the end of first execution and crash on the second\n          execution)\n        */\n        for (SELECT_LEX *sl= un->first_select(); sl; sl= sl->next_select())\n          sl->uncacheable |= UNCACHEABLE_DEPENDENT;\n      }\n      else\n        un->uncacheable&= ~UNCACHEABLE_DEPENDENT;\n      subquery_predicate->is_correlated= is_correlated_unit;\n    }\n  }\n  return FALSE;\n}",
        "target": 0
    },
    {
        "func": "unit_common_op st_select_lex_unit::common_op()\n{\n  SELECT_LEX *first= first_select();\n  bool first_op= TRUE;\n  unit_common_op operation= OP_MIX; // if no op\n  for (SELECT_LEX *sl= first; sl; sl= sl->next_select())\n  {\n    if (sl != first)\n    {\n      unit_common_op op;\n      switch (sl->linkage)\n      {\n      case INTERSECT_TYPE:\n        op= OP_INTERSECT;\n        break;\n      case EXCEPT_TYPE:\n        op= OP_EXCEPT;\n        break;\n      default:\n        op= OP_UNION;\n        break;\n      }\n      if (first_op)\n      {\n        operation= op;\n        first_op= FALSE;\n      }\n      else\n      {\n        if (operation != op)\n          operation= OP_MIX;\n      }\n    }\n  }\n  return operation;\n}",
        "target": 0
    },
    {
        "func": "bool LEX::is_trigger_new_or_old_reference(const LEX_CSTRING *name) const\n{\n  // \"name\" is not necessarily NULL-terminated!\n  return sphead && sphead->m_handler->type() == TYPE_ENUM_TRIGGER &&\n         name->length == 3 && (is_new(name->str) || is_old(name->str));\n}",
        "target": 0
    },
    {
        "func": "bool Lex_ident_sys_st::copy_keyword(THD *thd, const Lex_ident_cli_st *str)\n{\n  return thd->make_lex_string(static_cast<LEX_CSTRING*>(this),\n                              str->str, str->length) == NULL;\n}",
        "target": 0
    },
    {
        "func": "  void inc_select_stack_outer_barrier()\n  {\n    select_stack_outer_barrier++;\n  }",
        "target": 0
    },
    {
        "func": "  bool check_simple_select(const LEX_CSTRING *option)\n  {\n    if (current_select != &builtin_select)\n    {\n      char command[80];\n      strmake(command, option->str, MY_MIN(option->length, sizeof(command)-1));\n      my_error(ER_CANT_USE_OPTION_HERE, MYF(0), command);\n      return true;\n    }\n    return false;\n  }",
        "target": 0
    },
    {
        "func": "bool LEX::sp_variable_declarations_finalize(THD *thd, int nvars,\n                                            const Column_definition *cdef,\n                                            Item *dflt_value_item)\n{\n  DBUG_ASSERT(cdef);\n  Column_definition tmp(*cdef);\n  if (sphead->fill_spvar_definition(thd, &tmp))\n    return true;\n  return sp_variable_declarations_copy_type_finalize(thd, nvars, tmp, NULL,\n                                                     dflt_value_item);\n}",
        "target": 0
    },
    {
        "func": "  Item *get_item() const\n  {\n    return m_item;\n  }",
        "target": 0
    },
    {
        "func": "  inline bool is_ps_or_view_context_analysis()\n  {\n    return (context_analysis_only &\n            (CONTEXT_ANALYSIS_ONLY_PREPARE |\n             CONTEXT_ANALYSIS_ONLY_VCOL_EXPR |\n             CONTEXT_ANALYSIS_ONLY_VIEW));\n  }",
        "target": 0
    },
    {
        "func": "  inline void uncacheable(uint8 cause)\n  {\n    safe_to_cache_query= 0;\n\n    if (current_select) // initialisation SP variables has no SELECT\n    {\n      /*\n        There are no sense to mark select_lex and union fields of LEX,\n        but we should merk all subselects as uncacheable from current till\n        most upper\n      */\n      SELECT_LEX *sl;\n      SELECT_LEX_UNIT *un;\n      for (sl= current_select, un= sl->master_unit();\n           un && un != &unit;\n           sl= sl->outer_select(), un= (sl ? sl->master_unit() : NULL))\n      {\n       sl->uncacheable|= cause;\n       un->uncacheable|= cause;\n      }\n      if (sl)\n        sl->uncacheable|= cause;\n    }\n    if (first_select_lex())\n      first_select_lex()->uncacheable|= cause;\n  }",
        "target": 0
    },
    {
        "func": "  Item *create_item_qualified_asterisk(THD *thd, const Lex_ident_cli_st *cname)\n  {\n    Lex_ident_sys name(thd, cname);\n    if (name.is_null())\n      return NULL; // EOM\n    return create_item_qualified_asterisk(thd, &name);\n  }",
        "target": 0
    },
    {
        "func": "  void stmt_create_routine_finalize()\n  {\n    pop_select(); // main select\n  }",
        "target": 0
    },
    {
        "func": "  Index_hint (enum index_hint_type type_arg, index_clause_map clause_arg,\n              const char *str, size_t length) :\n    type(type_arg), clause(clause_arg)\n  {\n    key_name.str= str;\n    key_name.length= length;\n  }",
        "target": 0
    },
    {
        "func": "Item *negate_expression(THD *thd, Item *expr)\n{\n  Item *negated;\n  if (expr->type() == Item::FUNC_ITEM &&\n      ((Item_func *) expr)->functype() == Item_func::NOT_FUNC)\n  {\n    /* it is NOT(NOT( ... )) */\n    Item *arg= ((Item_func *) expr)->arguments()[0];\n    const Type_handler *fh= arg->fixed_type_handler();\n    enum_parsing_place place= thd->lex->current_select->parsing_place;\n    if ((fh && fh->is_bool_type()) || place == IN_WHERE || place == IN_HAVING)\n      return arg;\n    /*\n      if it is not boolean function then we have to emulate value of\n      not(not(a)), it will be a != 0\n    */\n    return new (thd->mem_root) Item_func_ne(thd, arg, new (thd->mem_root) Item_int(thd, (char*) \"0\", 0, 1));\n  }\n\n  if ((negated= expr->neg_transformer(thd)) != 0)\n    return negated;\n  return new (thd->mem_root) Item_func_not(thd, expr);\n}",
        "target": 0
    },
    {
        "func": "  Vers_parse_info &vers_get_info()\n  {\n    return create_info.vers_info;\n  }",
        "target": 0
    },
    {
        "func": "bool LEX::sp_variable_declarations_row_finalize(THD *thd, int nvars,\n                                                Row_definition_list *row,\n                                                Item *dflt_value_item)\n{\n  DBUG_ASSERT(row);\n  /*\n    Prepare all row fields.\n    Note, we do it only one time outside of the below loop.\n    The converted list in \"row\" is further reused by all variable\n    declarations processed by the current call.\n    Example:\n      DECLARE\n        a, b, c ROW(x VARCHAR(10) CHARACTER SET utf8);\n      BEGIN\n        ...\n      END;\n  */\n  if (sphead->row_fill_field_definitions(thd, row))\n    return true;\n\n  for (uint i= 0 ; i < (uint) nvars ; i++)\n  {\n    sp_variable *spvar= spcont->get_last_context_variable((uint) nvars - 1 - i);\n    spvar->field_def.set_row_field_definitions(row);\n    if (sphead->fill_spvar_definition(thd, &spvar->field_def, &spvar->name))\n      return true;\n  }\n\n  if (sp_variable_declarations_set_default(thd, nvars, dflt_value_item))\n    return true;\n  spcont->declare_var_boundary(0);\n  return sphead->restore_lex(thd);\n}",
        "target": 0
    },
    {
        "func": "bool LEX::set_system_variable(THD *thd, enum_var_type var_type,\n                              const LEX_CSTRING *name1,\n                              const LEX_CSTRING *name2,\n                              Item *val)\n{\n  sys_var *tmp;\n  if (unlikely(check_reserved_words(name1)) ||\n      unlikely(!(tmp= find_sys_var(thd, name2->str, name2->length, true))))\n  {\n    my_error(ER_UNKNOWN_STRUCTURED_VARIABLE, MYF(0),\n             (int) name1->length, name1->str);\n    return true;\n  }\n  if (unlikely(!tmp->is_struct()))\n  {\n    my_error(ER_VARIABLE_IS_NOT_STRUCT, MYF(0), name2->str);\n    return true;\n  }\n  return set_system_variable(var_type, tmp, name1, val);\n}",
        "target": 0
    },
    {
        "func": "bool LEX::sp_handler_declaration_finalize(THD *thd, int type)\n{\n  sp_label *hlab= spcont->pop_label(); /* After this hdlr */\n  sp_instr_hreturn *i;\n\n  if (type == sp_handler::CONTINUE)\n  {\n    i= new (thd->mem_root) sp_instr_hreturn(sphead->instructions(), spcont);\n    if (unlikely(i == NULL) ||\n        unlikely(sphead->add_instr(i)))\n      return true;\n  }\n  else\n  {  /* EXIT or UNDO handler, just jump to the end of the block */\n    i= new (thd->mem_root) sp_instr_hreturn(sphead->instructions(), spcont);\n    if (unlikely(i == NULL) ||\n        unlikely(sphead->add_instr(i)) ||\n        unlikely(sphead->push_backpatch(thd, i, spcont->last_label()))) /* Block end */\n      return true;\n  }\n  sphead->backpatch(hlab);\n  spcont= spcont->pop_context();\n  return false;\n}",
        "target": 0
    },
    {
        "func": "  bool check_create_options(DDL_options_st options)\n  {\n    if (options.or_replace() && options.if_not_exists())\n    {\n      my_error(ER_WRONG_USAGE, MYF(0), \"OR REPLACE\", \"IF NOT EXISTS\");\n      return true;\n    }\n    return false;\n  }",
        "target": 0
    },
    {
        "func": "bool check_stack_overrun(THD *thd, long margin,\n\t\t\t uchar *buf __attribute__((unused)))\n{\n  long stack_used;\n  DBUG_ASSERT(thd == current_thd);\n  if ((stack_used= available_stack_size(thd->thread_stack, &stack_used)) >=\n      (long) (my_thread_stack_size - margin))\n  {\n    thd->is_fatal_error= 1;\n    /*\n      Do not use stack for the message buffer to ensure correct\n      behaviour in cases we have close to no stack left.\n    */\n    char* ebuff= new char[MYSQL_ERRMSG_SIZE];\n    if (ebuff) {\n      my_snprintf(ebuff, MYSQL_ERRMSG_SIZE, ER_THD(thd, ER_STACK_OVERRUN_NEED_MORE),\n                  stack_used, my_thread_stack_size, margin);\n      my_message(ER_STACK_OVERRUN_NEED_MORE, ebuff, MYF(ME_FATAL));\n      delete [] ebuff;\n    }\n    return 1;\n  }\n#ifndef DBUG_OFF\n  max_stack_used= MY_MAX(max_stack_used, stack_used);\n#endif\n  return 0;\n}",
        "target": 0
    },
    {
        "func": "bool LEX::sp_push_goto_label(THD *thd, const LEX_CSTRING *label_name)\n{\n  sp_label *lab= spcont->find_goto_label(label_name, false);\n  if (lab)\n  {\n    if (unlikely(lab->ip != 0))\n    {\n      my_error(ER_SP_LABEL_REDEFINE, MYF(0), label_name->str);\n      return true;\n    }\n    lab->ip= sphead->instructions();\n\n    sp_label *beginblocklabel= spcont->find_label(&empty_clex_str);\n    sphead->backpatch_goto(thd, lab, beginblocklabel);\n  }\n  else\n  {\n    spcont->push_goto_label(thd, label_name, sphead->instructions());\n  }\n  return false;\n}",
        "target": 0
    },
    {
        "func": "Item_splocal *LEX::create_item_spvar_row_field(THD *thd,\n                                               const Sp_rcontext_handler *rh,\n                                               const Lex_ident_sys *a,\n                                               const Lex_ident_sys *b,\n                                               sp_variable *spv,\n                                               const char *start,\n                                               const char *end)\n{\n  if (unlikely(!parsing_options.allows_variable))\n  {\n    my_error(ER_VIEW_SELECT_VARIABLE, MYF(0));\n    return NULL;\n  }\n\n  Query_fragment pos(thd, sphead, start, end);\n  Item_splocal *item;\n  if (spv->field_def.is_table_rowtype_ref() ||\n      spv->field_def.is_cursor_rowtype_ref())\n  {\n    if (unlikely(!(item= new (thd->mem_root)\n                   Item_splocal_row_field_by_name(thd, rh, a, b, spv->offset,\n                                                  &type_handler_null,\n                                                  pos.pos(), pos.length()))))\n      return NULL;\n  }\n  else\n  {\n    uint row_field_offset;\n    const Spvar_definition *def;\n    if (unlikely(!(def= spv->find_row_field(a, b, &row_field_offset))))\n      return NULL;\n\n    if (unlikely(!(item= new (thd->mem_root)\n                   Item_splocal_row_field(thd, rh, a, b,\n                                          spv->offset, row_field_offset,\n                                          def->type_handler(),\n                                          pos.pos(), pos.length()))))\n      return NULL;\n  }\n#ifdef DBUG_ASSERT_EXISTS\n  item->m_sp= sphead;\n#endif\n  safe_to_cache_query=0;\n  return item;\n}",
        "target": 0
    },
    {
        "func": "  void add_to_query_tables(TABLE_LIST *table)\n  {\n    *(table->prev_global= query_tables_last)= table;\n    query_tables_last= &table->next_global;\n  }",
        "target": 0
    },
    {
        "func": "Item *st_select_lex::build_cond_for_grouping_fields(THD *thd, Item *cond,\n                                                    bool no_top_clones)\n{\n  if (cond->get_extraction_flag() == FULL_EXTRACTION_FL)\n  {\n    if (no_top_clones)\n      return cond;\n    cond->clear_extraction_flag();\n    return cond->build_clone(thd);\n  }\n  if (cond->type() == Item::COND_ITEM)\n  {\n    bool cond_and= false;\n    Item_cond *new_cond;\n    if (((Item_cond*) cond)->functype() == Item_func::COND_AND_FUNC)\n    {\n      cond_and= true;\n      new_cond=  new (thd->mem_root) Item_cond_and(thd);\n    }\n    else\n      new_cond= new (thd->mem_root) Item_cond_or(thd);\n    if (unlikely(!new_cond))\n      return 0;\n    List_iterator<Item> li(*((Item_cond*) cond)->argument_list());\n    Item *item;\n    while ((item=li++))\n    {\n      if (item->get_extraction_flag() == NO_EXTRACTION_FL)\n      {\n        DBUG_ASSERT(cond_and);\n        item->clear_extraction_flag();\n        continue;\n      }\n      Item *fix= build_cond_for_grouping_fields(thd, item,\n                                                no_top_clones & cond_and);\n      if (unlikely(!fix))\n      {\n        if (cond_and)\n          continue;\n        break;\n      }\n      new_cond->argument_list()->push_back(fix, thd->mem_root);\n    }\n    \n    if (!cond_and && item)\n    {\n      while((item= li++))\n        item->clear_extraction_flag();\n      return 0;\n    }\n    switch (new_cond->argument_list()->elements) \n    {\n    case 0:\n      return 0;\n    case 1:\n      return new_cond->argument_list()->head();\n    default:\n      return new_cond;\n    }\n  }\n  return 0;\n}",
        "target": 0
    },
    {
        "func": "void st_select_lex_unit::reset_distinct()\n{\n  union_distinct= NULL;\n  for(SELECT_LEX *sl= first_select()->next_select();\n      sl;\n      sl= sl->next_select())\n  {\n    if (sl->distinct)\n    {\n      union_distinct= sl;\n    }\n  }\n}",
        "target": 0
    },
    {
        "func": "Lex_input_stream::reset(char *buffer, size_t length)\n{\n  yylineno= 1;\n  lookahead_token= -1;\n  lookahead_yylval= NULL;\n  m_ptr= buffer;\n  m_tok_start= NULL;\n  m_tok_end= NULL;\n  m_end_of_query= buffer + length;\n  m_tok_start_prev= NULL;\n  m_buf= buffer;\n  m_buf_length= length;\n  m_echo= TRUE;\n  m_cpp_tok_start= NULL;\n  m_cpp_tok_start_prev= NULL;\n  m_cpp_tok_end= NULL;\n  m_body_utf8= NULL;\n  m_cpp_utf8_processed_ptr= NULL;\n  next_state= MY_LEX_START;\n  found_semicolon= NULL;\n  ignore_space= MY_TEST(m_thd->variables.sql_mode & MODE_IGNORE_SPACE);\n  stmt_prepare_mode= FALSE;\n  multi_statements= TRUE;\n  in_comment=NO_COMMENT;\n  m_underscore_cs= NULL;\n  m_cpp_ptr= m_cpp_buf;\n}",
        "target": 0
    },
    {
        "func": "bool Lex_ident_sys_st::to_size_number(ulonglong *to) const\n{\n  ulonglong number;\n  uint text_shift_number= 0;\n  longlong prefix_number;\n  const char *start_ptr= str;\n  size_t str_len= length;\n  const char *end_ptr= start_ptr + str_len;\n  int error;\n  prefix_number= my_strtoll10(start_ptr, (char**) &end_ptr, &error);\n  if (likely((start_ptr + str_len - 1) == end_ptr))\n  {\n    switch (end_ptr[0])\n    {\n      case 'g':\n      case 'G': text_shift_number+=30; break;\n      case 'm':\n      case 'M': text_shift_number+=20; break;\n      case 'k':\n      case 'K': text_shift_number+=10; break;\n      default:\n        my_error(ER_WRONG_SIZE_NUMBER, MYF(0));\n        return true;\n    }\n    if (unlikely(prefix_number >> 31))\n    {\n      my_error(ER_SIZE_OVERFLOW_ERROR, MYF(0));\n      return true;\n    }\n    number= prefix_number << text_shift_number;\n  }\n  else\n  {\n    my_error(ER_WRONG_SIZE_NUMBER, MYF(0));\n    return true;\n  }\n  *to= number;\n  return false;\n}",
        "target": 0
    },
    {
        "func": "SELECT_LEX *LEX::parsed_TVC_end()\n{\n  SELECT_LEX *res= pop_select(); // above TVC select\n  if (!(res->tvc=\n        new (thd->mem_root) table_value_constr(many_values,\n          res,\n          res->options)))\n    return NULL;\n  restore_values_list_state();\n  return res;\n}",
        "target": 0
    },
    {
        "func": "bool LEX::last_field_generated_always_as_row_start()\n{\n  Vers_parse_info &info= vers_get_info();\n  Lex_ident *p= &info.as_row.start;\n  return last_field_generated_always_as_row_start_or_end(p, \"START\",\n                                                         VERS_ROW_START);\n}",
        "target": 0
    },
    {
        "func": "SELECT_LEX *LEX::create_priority_nest(SELECT_LEX *first_in_nest)\n{\n  DBUG_ENTER(\"LEX::create_priority_nest\");\n  DBUG_ASSERT(first_in_nest->first_nested);\n  enum sub_select_type wr_unit_type= first_in_nest->get_linkage();\n  bool wr_distinct= first_in_nest->distinct;\n  SELECT_LEX *attach_to= first_in_nest->first_nested;\n  attach_to->cut_next();\n  SELECT_LEX *wrapper= wrap_select_chain_into_derived(first_in_nest);\n  if (wrapper)\n  {\n    first_in_nest->first_nested= NULL;\n    wrapper->set_linkage_and_distinct(wr_unit_type, wr_distinct);\n    wrapper->first_nested= attach_to->first_nested;\n    wrapper->set_master_unit(attach_to->master_unit());\n    attach_to->link_neighbour(wrapper);\n  }\n  DBUG_RETURN(wrapper);\n}",
        "target": 0
    },
    {
        "func": "bool LEX::sp_add_cfetch(THD *thd, const LEX_CSTRING *name)\n{\n  uint offset;\n  sp_instr_cfetch *i;\n\n  if (!spcont->find_cursor(name, &offset, false))\n  {\n    my_error(ER_SP_CURSOR_MISMATCH, MYF(0), name->str);\n    return true;\n  }\n  i= new (thd->mem_root)\n    sp_instr_cfetch(sphead->instructions(), spcont, offset,\n                    !(thd->variables.sql_mode & MODE_ORACLE));\n  if (unlikely(i == NULL) || unlikely(sphead->add_instr(i)))\n    return true;\n  return false;\n}",
        "target": 0
    },
    {
        "func": "Item *LEX::make_item_func_call_generic(THD *thd, Lex_ident_cli_st *cdb,\n                                       Lex_ident_cli_st *cname, List<Item> *args)\n{\n  Lex_ident_sys db(thd, cdb), name(thd, cname);\n  if (db.is_null() || name.is_null())\n    return NULL; // EOM\n  /*\n    The following in practice calls:\n    <code>Create_sp_func::create()</code>\n    and builds a stored function.\n\n    However, it's important to maintain the interface between the\n    parser and the implementation in item_create.cc clean,\n    since this will change with WL#2128 (SQL PATH):\n    - INFORMATION_SCHEMA.version() is the SQL 99 syntax for the native\n    function version(),\n    - MySQL.version() is the SQL 2003 syntax for the native function\n    version() (a vendor can specify any schema).\n  */\n\n  if (!name.str || check_db_name((LEX_STRING*) static_cast<LEX_CSTRING*>(&db)))\n  {\n    my_error(ER_WRONG_DB_NAME, MYF(0), db.str);\n    return NULL;\n  }\n  if (check_routine_name(&name))\n    return NULL;\n\n  Create_qfunc *builder= find_qualified_function_builder(thd);\n  DBUG_ASSERT(builder);\n  return builder->create_with_db(thd, &db, &name, true, args);\n}",
        "target": 0
    },
    {
        "func": "  st_select_lex* next_select() { return (st_select_lex*) next; }",
        "target": 0
    },
    {
        "func": "  inline bool is_mergeable()\n  {\n    return (next_select() == 0 && group_list.elements == 0 &&\n            having == 0 && with_sum_func == 0 &&\n            table_list.elements >= 1 && !(options & SELECT_DISTINCT) &&\n            select_limit == 0);\n  }",
        "target": 0
    },
    {
        "func": "bool is_native_function_with_warn(THD *thd, const LEX_CSTRING *name)\n{\n  if (!is_native_function(thd, name))\n    return false;\n  /*\n    This warning will be printed when\n    [1] A client query is parsed,\n    [2] A stored function is loaded by db_load_routine.\n    Printing the warning for [2] is intentional, to cover the\n    following scenario:\n    - A user define a SF 'foo' using MySQL 5.N\n    - An application uses select foo(), and works.\n    - MySQL 5.{N+1} defines a new native function 'foo', as\n    part of a new feature.\n    - MySQL 5.{N+1} documentation is updated, and should mention\n    that there is a potential incompatible change in case of\n    existing stored function named 'foo'.\n    - The user deploys 5.{N+1}. At this point, 'select foo()'\n    means something different, and the user code is most likely\n    broken (it's only safe if the code is 'select db.foo()').\n    With a warning printed when the SF is loaded (which has to\n    occur before the call), the warning will provide a hint\n    explaining the root cause of a later failure of 'select foo()'.\n    With no warning printed, the user code will fail with no\n    apparent reason.\n    Printing a warning each time db_load_routine is executed for\n    an ambiguous function is annoying, since that can happen a lot,\n    but in practice should not happen unless there *are* name\n    collisions.\n    If a collision exists, it should not be silenced but fixed.\n  */\n  push_warning_printf(thd,\n                      Sql_condition::WARN_LEVEL_NOTE,\n                      ER_NATIVE_FCT_NAME_COLLISION,\n                      ER_THD(thd, ER_NATIVE_FCT_NAME_COLLISION),\n                      name->str);\n  return true;\n}",
        "target": 0
    },
    {
        "func": "bool LEX::parsed_multi_operand_query_expression_body(SELECT_LEX_UNIT *unit)\n{\n  SELECT_LEX *first_in_nest=\n    unit->pre_last_parse->next_select()->first_nested;\n  if (first_in_nest->first_nested != first_in_nest)\n  {\n    /* There is a priority jump starting from first_in_nest */\n    if (create_priority_nest(first_in_nest) == NULL)\n      return true;\n    unit->fix_distinct();\n  }\n  return false;\n}",
        "target": 0
    },
    {
        "func": "bool LEX::stmt_prepare_validate(const char *stmt_type)\n{\n  if (unlikely(table_or_sp_used()))\n  {\n    my_error(ER_SUBQUERIES_NOT_SUPPORTED, MYF(0), stmt_type);\n    return true;\n  }\n  return check_main_unit_semantics();\n}",
        "target": 0
    },
    {
        "func": "  void cut_subtree() { slave= 0; }",
        "target": 0
    },
    {
        "func": "  bool fields_are_impossible()\n  {\n    // no select or it is last select with no tables (service select)\n    return !select_stack_head() ||\n           (select_stack_top == 1 &&\n            select_stack[0]->is_service_select);\n  }",
        "target": 0
    },
    {
        "func": "static bool is_old(const char *str)\n{\n  return (str[0] == 'o' || str[0] == 'O') &&\n         (str[1] == 'l' || str[1] == 'L') &&\n         (str[2] == 'd' || str[2] == 'D');\n}",
        "target": 0
    },
    {
        "func": "bool LEX::sp_block_finalize(THD *thd, const Lex_spblock_st spblock,\n                            const LEX_CSTRING *end_label)\n{\n  sp_label *splabel;\n  if (unlikely(sp_block_finalize(thd, spblock, &splabel)))\n    return true;\n  if (unlikely(end_label->str &&\n               lex_string_cmp(system_charset_info,\n                              end_label, &splabel->name) != 0))\n  {\n    my_error(ER_SP_LABEL_MISMATCH, MYF(0), end_label->str);\n    return true;\n  }\n  return false;\n}",
        "target": 0
    },
    {
        "func": "TABLE_LIST *st_select_lex::nest_last_join(THD *thd)\n{\n  TABLE_LIST *ptr;\n  NESTED_JOIN *nested_join;\n  List<TABLE_LIST> *embedded_list;\n  DBUG_ENTER(\"nest_last_join\");\n\n  TABLE_LIST *head= join_list->head();\n  if (head->nested_join && (head->nested_join->nest_type & REBALANCED_NEST))\n  {\n    head= join_list->pop();\n    DBUG_RETURN(head);\n  }\n\n  if (unlikely(!(ptr= (TABLE_LIST*) thd->calloc(ALIGN_SIZE(sizeof(TABLE_LIST))+\n                                                sizeof(NESTED_JOIN)))))\n    DBUG_RETURN(0);\n  nested_join= ptr->nested_join=\n    ((NESTED_JOIN*) ((uchar*) ptr + ALIGN_SIZE(sizeof(TABLE_LIST))));\n\n  ptr->embedding= embedding;\n  ptr->join_list= join_list;\n  ptr->alias.str= \"(nest_last_join)\";\n  ptr->alias.length= sizeof(\"(nest_last_join)\")-1;\n  embedded_list= &nested_join->join_list;\n  embedded_list->empty();\n  nested_join->nest_type= JOIN_OP_NEST;\n\n  for (uint i=0; i < 2; i++)\n  {\n    TABLE_LIST *table= join_list->pop();\n    if (unlikely(!table))\n      DBUG_RETURN(NULL);\n    table->join_list= embedded_list;\n    table->embedding= ptr;\n    embedded_list->push_back(table);\n    if (table->natural_join)\n    {\n      ptr->is_natural_join= TRUE;\n      /*\n        If this is a JOIN ... USING, move the list of joined fields to the\n        table reference that describes the join.\n      */\n      if (prev_join_using)\n        ptr->join_using_fields= prev_join_using;\n    }\n  }\n  nested_join->used_tables= nested_join->not_null_tables= (table_map) 0;\n  DBUG_RETURN(ptr);\n}",
        "target": 0
    },
    {
        "func": "  st_select_lex() : group_list_ptrs(NULL), braces(0), automatic_brackets(0),\n  n_sum_items(0), n_child_sum_items(0)\n  {}",
        "target": 0
    },
    {
        "func": "  const char *get_cpp_ptr()\n  {\n    return m_cpp_ptr;\n  }",
        "target": 0
    },
    {
        "func": "bool LEX::add_signal_statement(THD *thd, const sp_condition_value *v)\n{\n  Yacc_state *state= &thd->m_parser_state->m_yacc;\n  sql_command= SQLCOM_SIGNAL;\n  m_sql_cmd= new (thd->mem_root) Sql_cmd_signal(v, state->m_set_signal_info);\n  return m_sql_cmd == NULL;\n}",
        "target": 0
    },
    {
        "func": "  st_select_lex* next_select_in_list() \n  {\n    return (st_select_lex*) link_next;\n  }",
        "target": 0
    },
    {
        "func": "bool LEX::sp_for_loop_cursor_declarations(THD *thd,\n                                          Lex_for_loop_st *loop,\n                                          const LEX_CSTRING *index,\n                                          const Lex_for_loop_bounds_st &bounds)\n{\n  Item *item= bounds.m_index->get_item();\n  Item_splocal *item_splocal;\n  Item_field *item_field;\n  Item_func_sp *item_func_sp= NULL;\n  LEX_CSTRING name;\n  uint coffs, param_count= 0;\n  const sp_pcursor *pcursor;\n  DBUG_ENTER(\"LEX::sp_for_loop_cursor_declarations\");\n\n  if ((item_splocal= item->get_item_splocal()))\n    name= item_splocal->m_name;\n  else if ((item_field= item->type() == Item::FIELD_ITEM ?\n                        static_cast<Item_field *>(item) : NULL) &&\n           item_field->table_name == NULL)\n    name= item_field->field_name;\n  else if (item->type() == Item::FUNC_ITEM &&\n           static_cast<Item_func*>(item)->functype() == Item_func::FUNC_SP &&\n           !static_cast<Item_func_sp*>(item)->get_sp_name()->m_explicit_name)\n  {\n    /*\n      When a FOR LOOP for a cursor with parameters is parsed:\n        FOR index IN cursor(1,2,3) LOOP\n          statements;\n        END LOOP;\n      the parser scans \"cursor(1,2,3)\" using the \"expr\" rule,\n      so it thinks that cursor(1,2,3) is a stored function call.\n      It's not easy to implement this without using \"expr\" because\n      of grammar conflicts.\n      As a side effect, the Item_func_sp and its arguments in the parentheses\n      belong to the same LEX. This is different from an explicit\n      \"OPEN cursor(1,2,3)\" where every expression belongs to a separate LEX.\n    */\n    item_func_sp= static_cast<Item_func_sp*>(item);\n    name= item_func_sp->get_sp_name()->m_name;\n    param_count= item_func_sp->argument_count();\n  }\n  else\n  {\n    thd->parse_error();\n    DBUG_RETURN(true);\n  }\n  if (unlikely(!(pcursor= spcont->find_cursor_with_error(&name, &coffs,\n                                                         false)) ||\n               pcursor->check_param_count_with_error(param_count)))\n    DBUG_RETURN(true);\n\n  if (!(loop->m_index= sp_add_for_loop_cursor_variable(thd, index,\n                                                       pcursor, coffs,\n                                                       bounds.m_index,\n                                                       item_func_sp)))\n    DBUG_RETURN(true);\n  loop->m_target_bound= NULL;\n  loop->m_direction= bounds.m_direction;\n  loop->m_cursor_offset= coffs;\n  loop->m_implicit_cursor= bounds.m_implicit_cursor;\n  DBUG_RETURN(false);\n}",
        "target": 0
    },
    {
        "func": "init_lex_with_single_table(THD *thd, TABLE *table, LEX *lex)\n{\n  TABLE_LIST *table_list;\n  Table_ident *table_ident;\n  SELECT_LEX *select_lex= lex->first_select_lex();\n  Name_resolution_context *context= &select_lex->context;\n  /*\n    We will call the parser to create a part_info struct based on the\n    partition string stored in the frm file.\n    We will use a local lex object for this purpose. However we also\n    need to set the Name_resolution_object for this lex object. We\n    do this by using add_table_to_list where we add the table that\n    we're working with to the Name_resolution_context.\n  */\n  thd->lex= lex;\n  lex_start(thd);\n  context->init();\n  if (unlikely((!(table_ident= new Table_ident(thd,\n                                               &table->s->db,\n                                               &table->s->table_name,\n                                               TRUE)))) ||\n      (unlikely(!(table_list= select_lex->add_table_to_list(thd,\n                                                            table_ident,\n                                                            NULL,\n                                                            0)))))\n    return TRUE;\n  context->resolve_in_table_list_only(table_list);\n  lex->use_only_table_context= TRUE;\n  lex->context_analysis_only|= CONTEXT_ANALYSIS_ONLY_VCOL_EXPR;\n  select_lex->cur_pos_in_select_list= UNDEF_POS;\n  table->map= 1; //To ensure correct calculation of const item\n  table_list->table= table;\n  table_list->cacheable_table= false;\n  lex->create_last_non_select_table= table_list;\n  return FALSE;\n}",
        "target": 0
    },
    {
        "func": "Item_param *LEX::add_placeholder(THD *thd, const LEX_CSTRING *name,\n                                 const char *start, const char *end)\n{\n  if (unlikely(!thd->m_parser_state->m_lip.stmt_prepare_mode))\n  {\n    thd->parse_error(ER_SYNTAX_ERROR, start);\n    return NULL;\n  }\n  if (unlikely(!parsing_options.allows_variable))\n  {\n    my_error(ER_VIEW_SELECT_VARIABLE, MYF(0));\n    return NULL;\n  }\n  Query_fragment pos(thd, sphead, start, end);\n  Item_param *item= new (thd->mem_root) Item_param(thd, name,\n                                                   pos.pos(), pos.length());\n  if (unlikely(!item) || unlikely(param_push_or_clone(thd, this, item)))\n  {\n    my_error(ER_OUT_OF_RESOURCES, MYF(0));\n    return NULL;\n  }\n  return item;\n}",
        "target": 0
    },
    {
        "func": "bool st_select_lex_unit::set_nest_level(int new_nest_level)\n{\n  DBUG_ENTER(\"st_select_lex_unit::set_nest_level\");\n  for(SELECT_LEX *sl= first_select(); sl; sl= sl->next_select())\n  {\n    if (sl->set_nest_level(new_nest_level))\n      DBUG_RETURN(TRUE);\n  }\n  if (fake_select_lex &&\n      fake_select_lex->set_nest_level(new_nest_level))\n    DBUG_RETURN(TRUE);\n  DBUG_RETURN(FALSE);\n}",
        "target": 0
    },
    {
        "func": "  void set_ident_quoted(const char *s, size_t len, bool is_8bit, char quote)\n  {\n    set(s, len, is_8bit, quote);\n  }",
        "target": 0
    },
    {
        "func": "void LEX::sp_block_init(THD *thd, const LEX_CSTRING *label)\n{\n  spcont->push_label(thd, label, sphead->instructions(), sp_label::BEGIN);\n  spcont= spcont->push_context(thd, sp_pcontext::REGULAR_SCOPE);\n}",
        "target": 0
    },
    {
        "func": "  sp_variable *sp_add_for_loop_target_bound(THD *thd, Item *value)\n  {\n    LEX_CSTRING name= { STRING_WITH_LEN(\"[target_bound]\") };\n    return sp_add_for_loop_variable(thd, &name, value);\n  }",
        "target": 0
    },
    {
        "func": "SELECT_LEX::attach_selects_chain(SELECT_LEX *first_sel,\n                                 Name_resolution_context *context)\n{\n  SELECT_LEX_UNIT *unit;\n  DBUG_ENTER(\"SELECT_LEX::attach_select_chain\");\n\n  if (!(unit= parent_lex->alloc_unit()))\n    DBUG_RETURN(NULL);\n\n  unit->register_select_chain(first_sel);\n  register_unit(unit, context);\n  if (first_sel->next_select())\n  {\n    unit->reset_distinct();\n    DBUG_ASSERT(!unit->fake_select_lex);\n    if (unit->add_fake_select_lex(parent_lex->thd))\n      DBUG_RETURN(NULL);\n  }\n\n  DBUG_RETURN(unit);\n}",
        "target": 0
    },
    {
        "func": "Item *LEX::create_item_ident_sp(THD *thd, Lex_ident_sys_st *name,\n                                const char *start,\n                                const char *end)\n{\n  DBUG_ASSERT(thd->m_parser_state->m_lip.get_buf() <= start);\n  DBUG_ASSERT(start <= end);\n  DBUG_ASSERT(end <= thd->m_parser_state->m_lip.get_end_of_query());\n\n  const Sp_rcontext_handler *rh;\n  sp_variable *spv;\n  uint unused_off;\n  DBUG_ASSERT(spcont);\n  DBUG_ASSERT(sphead);\n  if ((spv= find_variable(name, &rh)))\n  {\n    /* We're compiling a stored procedure and found a variable */\n    if (!parsing_options.allows_variable)\n    {\n      my_error(ER_VIEW_SELECT_VARIABLE, MYF(0));\n      return NULL;\n    }\n\n    Query_fragment pos(thd, sphead, start, end);\n    uint f_pos= clone_spec_offset ? 0 : pos.pos();\n    uint f_length= clone_spec_offset ? 0 : pos.length();\n    Item_splocal *splocal= spv->field_def.is_column_type_ref() ?\n      new (thd->mem_root) Item_splocal_with_delayed_data_type(thd, rh, name,\n                                                              spv->offset,\n                                                              f_pos, f_length) :\n      new (thd->mem_root) Item_splocal(thd, rh, name,\n                                       spv->offset, spv->type_handler(),\n                                       f_pos, f_length);\n    if (unlikely(splocal == NULL))\n      return NULL;\n#ifdef DBUG_ASSERT_EXISTS\n    splocal->m_sp= sphead;\n#endif\n    safe_to_cache_query= 0;\n    return splocal;\n  }\n\n  if (thd->variables.sql_mode & MODE_ORACLE)\n  {\n    if (lex_string_eq(name, STRING_WITH_LEN(\"SQLCODE\")))\n      return new (thd->mem_root) Item_func_sqlcode(thd);\n    if (lex_string_eq(name, STRING_WITH_LEN(\"SQLERRM\")))\n      return new (thd->mem_root) Item_func_sqlerrm(thd);\n  }\n\n  if (fields_are_impossible() &&\n      (current_select->parsing_place != FOR_LOOP_BOUND ||\n       spcont->find_cursor(name, &unused_off, false) == NULL))\n  {\n    // we are out of SELECT or FOR so it is syntax error\n    my_error(ER_SP_UNDECLARED_VAR, MYF(0), name->str);\n    return NULL;\n  }\n\n  if (current_select->parsing_place == FOR_LOOP_BOUND)\n    return create_item_for_loop_bound(thd, &null_clex_str, &null_clex_str,\n                                      name);\n\n  return create_item_ident_nosp(thd, name);\n}",
        "target": 0
    },
    {
        "func": "  void set_cpp_tok_start(const char *pos)\n  {\n    m_cpp_tok_start= pos;\n  }",
        "target": 0
    },
    {
        "func": "  void set_command(enum_sql_command command,\n                   DDL_options_st options)\n  {\n    sql_command= command;\n    create_info.set(options);\n  }",
        "target": 0
    },
    {
        "func": "static bool slow_filter_masked(THD *thd, ulonglong mask)\n{\n  return thd->variables.log_slow_filter && !(thd->variables.log_slow_filter & mask);\n}",
        "target": 0
    },
    {
        "func": "bool update_precheck(THD *thd, TABLE_LIST *tables)\n{\n  DBUG_ENTER(\"update_precheck\");\n  if (thd->lex->first_select_lex()->item_list.elements !=\n      thd->lex->value_list.elements)\n  {\n    my_message(ER_WRONG_VALUE_COUNT, ER_THD(thd, ER_WRONG_VALUE_COUNT), MYF(0));\n    DBUG_RETURN(TRUE);\n  }\n  DBUG_RETURN(check_one_table_access(thd, UPDATE_ACL, tables));\n}",
        "target": 0
    },
    {
        "func": "void st_select_lex::fix_prepare_information(THD *thd, Item **conds, \n                                            Item **having_conds)\n{\n  DBUG_ENTER(\"st_select_lex::fix_prepare_information\");\n  if (!thd->stmt_arena->is_conventional() &&\n      !(changed_elements & TOUCHED_SEL_COND))\n  {\n    Query_arena_stmt on_stmt_arena(thd);\n    changed_elements|= TOUCHED_SEL_COND;\n    if (group_list.first)\n    {\n      if (!group_list_ptrs)\n      {\n        void *mem= thd->stmt_arena->alloc(sizeof(Group_list_ptrs));\n        group_list_ptrs= new (mem) Group_list_ptrs(thd->stmt_arena->mem_root);\n      }\n      group_list_ptrs->reserve(group_list.elements);\n      for (ORDER *order= group_list.first; order; order= order->next)\n      {\n        group_list_ptrs->push_back(order);\n      }\n    }\n    if (*conds)\n    {\n      thd->check_and_register_item_tree(&prep_where, conds);\n      *conds= where= prep_where->copy_andor_structure(thd);\n    }\n    if (*having_conds)\n    {\n      thd->check_and_register_item_tree(&prep_having, having_conds);\n      *having_conds= having= prep_having->copy_andor_structure(thd);\n    }\n    fix_prepare_info_in_table_list(thd, table_list.first);\n  }\n  DBUG_VOID_RETURN;\n}",
        "target": 0
    },
    {
        "func": "  bool custom_agg_func_used() const { return m_custom_agg_func_used; }",
        "target": 0
    },
    {
        "func": "void sql_kill(THD *thd, longlong id, killed_state state, killed_type type)\n{\n  uint error;\n#ifdef WITH_WSREP\n  if (WSREP(thd))\n  {\n    WSREP_DEBUG(\"sql_kill called\");\n    if (thd->wsrep_applier)\n    {\n      WSREP_DEBUG(\"KILL in applying, bailing out here\");\n      return;\n    }\n    WSREP_TO_ISOLATION_BEGIN(WSREP_MYSQL_DB, NULL, NULL)\n  }\n#endif /* WITH_WSREP */\n  if (likely(!(error= kill_one_thread(thd, id, state, type))))\n  {\n    if (!thd->killed)\n      my_ok(thd);\n    else\n      thd->send_kill_message();\n  }\n  else\n    my_error(error, MYF(0), id);\n#ifdef WITH_WSREP\n  return;\n wsrep_error_label:\n  error= (type == KILL_TYPE_QUERY ? ER_KILL_QUERY_DENIED_ERROR :\n                                    ER_KILL_DENIED_ERROR);\n  my_error(error, MYF(0), id);\n#endif /* WITH_WSREP */\n}",
        "target": 0
    },
    {
        "func": "  bool if_exists() const { return create_info.if_exists(); }",
        "target": 0
    },
    {
        "func": "bool LEX::sp_for_loop_implicit_cursor_statement(THD *thd,\n                                                Lex_for_loop_bounds_st *bounds,\n                                                sp_lex_cursor *cur)\n{\n  Item *item;\n  DBUG_ASSERT(sphead);\n  LEX_CSTRING name= {STRING_WITH_LEN(\"[implicit_cursor]\") };\n  if (sp_declare_cursor(thd, &name, cur, NULL, true))\n    return true;\n  DBUG_ASSERT(thd->lex == this);\n  if (unlikely(!(bounds->m_index=\n                 new (thd->mem_root) sp_assignment_lex(thd, this))))\n    return true;\n  bounds->m_index->sp_lex_in_use= true;\n  sphead->reset_lex(thd, bounds->m_index);\n  DBUG_ASSERT(thd->lex != this);\n  /*\n    We pass NULL as Name_resolution_context here.\n    It's OK, fix_fields() will not be called for this Item_field created.\n    Item_field is only needed for LEX::sp_for_loop_cursor_declarations()\n    and is used to transfer the loop index variable name, \"rec\" in this example:\n      FOR rec IN (SELECT * FROM t1)\n      DO\n        SELECT rec.a, rec.b;\n      END FOR;\n  */\n  if (!(item= new (thd->mem_root) Item_field(thd, NULL, NullS, NullS, &name)))\n    return true;\n  bounds->m_index->set_item_and_free_list(item, NULL);\n  if (thd->lex->sphead->restore_lex(thd))\n    return true;\n  DBUG_ASSERT(thd->lex == this);\n  bounds->m_direction= 1;\n  bounds->m_target_bound= NULL;\n  bounds->m_implicit_cursor= true;\n  return false;\n}",
        "target": 0
    },
    {
        "func": "SELECT_LEX_UNIT *LEX::alloc_unit()\n{\n  SELECT_LEX_UNIT *unit;\n  DBUG_ENTER(\"LEX::alloc_unit\");\n  if (!(unit= new (thd->mem_root) SELECT_LEX_UNIT()))\n    DBUG_RETURN(NULL);\n\n  unit->init_query();\n  /* TODO: reentrant problem */\n  unit->thd= thd;\n  unit->link_next= 0;\n  unit->link_prev= 0;\n  /* TODO: remove return_to */\n  unit->return_to= NULL;\n  DBUG_RETURN(unit);\n}",
        "target": 0
    },
    {
        "func": "bool LEX::sp_leave_statement(THD *thd, const LEX_CSTRING *label_name)\n{\n  sp_label *lab= spcont->find_label(label_name);\n  if (unlikely(!lab))\n  {\n    my_error(ER_SP_LILABEL_MISMATCH, MYF(0), \"LEAVE\", label_name->str);\n    return true;\n  }\n  return sp_exit_block(thd, lab, NULL);\n}",
        "target": 0
    },
    {
        "func": "  void exclude_from_global()\n  {\n    if (!link_prev)\n      return;\n    if (((*link_prev)= link_next))\n      link_next->link_prev= link_prev;\n    link_next= NULL;\n    link_prev= NULL;\n  }",
        "target": 0
    },
    {
        "func": "  int add_period(Lex_ident name, Lex_ident_sys_st start, Lex_ident_sys_st end)\n  {\n    if (lex_string_cmp(system_charset_info, &start, &end) == 0)\n    {\n      my_error(ER_FIELD_SPECIFIED_TWICE, MYF(0), start.str);\n      return 1;\n    }\n\n    Table_period_info &info= create_info.period_info;\n\n    if (check_exists && info.name.streq(name))\n      return 0;\n\n    if (info.is_set())\n    {\n       my_error(ER_MORE_THAN_ONE_PERIOD, MYF(0));\n       return 1;\n    }\n    info.set_period(start, end);\n    info.name= name;\n\n    info.constr= new Virtual_column_info();\n    info.constr->expr= lt_creator.create(thd,\n                                         create_item_ident_nosp(thd, &start),\n                                         create_item_ident_nosp(thd, &end));\n    add_constraint(null_clex_str, info.constr, false);\n    return 0;\n  }",
        "target": 0
    },
    {
        "func": "bool LEX::set_variable(const LEX_CSTRING *name, Item *item)\n{\n  sp_pcontext *ctx;\n  const Sp_rcontext_handler *rh;\n  sp_variable *spv= find_variable(name, &ctx, &rh);\n  return spv ? sphead->set_local_variable(thd, ctx, rh, spv, item, this, true) :\n               set_system_variable(option_type, name, item);\n}",
        "target": 0
    },
    {
        "func": "LEX::add_primary_to_query_expression_body_ext_parens(\n                                                 SELECT_LEX_UNIT *unit,\n                                                 SELECT_LEX *sel,\n                                                 enum sub_select_type unit_type,\n                                                 bool distinct)\n{\n  SELECT_LEX *sel1= unit->first_select();\n  if (unit->first_select()->next_select())\n  {\n    sel1= wrap_unit_into_derived(unit);\n    if (!sel1)\n      return NULL;\n    if (!create_unit(sel1))\n      return NULL;\n  }\n  SELECT_LEX *sel2= sel;\n  if (sel->master_unit() && sel->master_unit()->first_select()->next_select())\n  {\n    sel2= wrap_unit_into_derived(sel->master_unit());\n    if (!sel2)\n      return NULL;\n  }\n  unit= parsed_select_expr_start(sel1, sel2, unit_type, distinct);\n  return unit;\n}",
        "target": 0
    },
    {
        "func": "bool LEX::sp_handler_declaration_init(THD *thd, int type)\n{\n  sp_handler *h= spcont->add_handler(thd, (sp_handler::enum_type) type);\n\n  spcont= spcont->push_context(thd, sp_pcontext::HANDLER_SCOPE);\n\n  sp_instr_hpush_jump *i=\n    new (thd->mem_root) sp_instr_hpush_jump(sphead->instructions(), spcont, h);\n\n  if (unlikely(i == NULL) || unlikely(sphead->add_instr(i)))\n    return true;\n\n  /* For continue handlers, mark end of handler scope. */\n  if (type == sp_handler::CONTINUE &&\n      unlikely(sphead->push_backpatch(thd, i, spcont->last_label())))\n    return true;\n\n  if (unlikely(sphead->push_backpatch(thd, i,\n                                      spcont->push_label(thd, &empty_clex_str,\n                                                         0))))\n    return true;\n\n  return false;\n}",
        "target": 0
    },
    {
        "func": "  unsigned char yyPeek()\n  {\n    return m_ptr[0];\n  }",
        "target": 0
    },
    {
        "func": "bool dispatch_command(enum enum_server_command command, THD *thd,\n\t\t      char* packet, uint packet_length, bool is_com_multi,\n                      bool is_next_command)\n{\n  NET *net= &thd->net;\n  bool error= 0;\n  bool do_end_of_statement= true;\n  DBUG_ENTER(\"dispatch_command\");\n  DBUG_PRINT(\"info\", (\"command: %d %s\", command,\n                      (command_name[command].str != 0 ?\n                       command_name[command].str :\n                       \"<?>\")));\n  bool drop_more_results= 0;\n\n  /* keep it withing 1 byte */\n  compile_time_assert(COM_END == 255);\n\n#if defined(ENABLED_PROFILING)\n  thd->profiling.start_new_query();\n#endif\n  MYSQL_COMMAND_START(thd->thread_id, command,\n                      &thd->security_ctx->priv_user[0],\n                      (char *) thd->security_ctx->host_or_ip);\n  \n  DBUG_EXECUTE_IF(\"crash_dispatch_command_before\",\n                  { DBUG_PRINT(\"crash_dispatch_command_before\", (\"now\"));\n                    DBUG_SUICIDE(); });\n\n  /* Performance Schema Interface instrumentation, begin */\n  thd->m_statement_psi= MYSQL_REFINE_STATEMENT(thd->m_statement_psi,\n                                               com_statement_info[command].\n                                               m_key);\n  /*\n    We should always call reset_for_next_command() before a query.\n    mysql_parse() will do this for queries. Ensure it's also done\n    for other commands.\n  */\n  if (command != COM_QUERY)\n    thd->reset_for_next_command();\n  thd->set_command(command);\n\n  thd->enable_slow_log= true;\n  thd->query_plan_flags= QPLAN_INIT;\n  thd->lex->sql_command= SQLCOM_END; /* to avoid confusing VIEW detectors */\n  thd->reset_kill_query();\n\n  DEBUG_SYNC(thd,\"dispatch_command_before_set_time\");\n\n  thd->set_time();\n  if (!(server_command_flags[command] & CF_SKIP_QUERY_ID))\n    thd->set_query_id(next_query_id());\n  else\n  {\n    /*\n      ping, get statistics or similar stateless command.\n      No reason to increase query id here.\n    */\n    thd->set_query_id(get_query_id());\n  }\n#ifdef WITH_WSREP\n  if (WSREP(thd) && thd->wsrep_next_trx_id() == WSREP_UNDEFINED_TRX_ID)\n  {\n    thd->set_wsrep_next_trx_id(thd->query_id);\n    WSREP_DEBUG(\"assigned new next trx id: %\" PRIu64, thd->wsrep_next_trx_id());\n  }\n#endif /* WITH_WSREP */\n\n  if (!(server_command_flags[command] & CF_SKIP_QUESTIONS))\n    statistic_increment(thd->status_var.questions, &LOCK_status);\n\n  /* Copy data for user stats */\n  if ((thd->userstat_running= opt_userstat_running))\n  {\n    thd->start_cpu_time= my_getcputime();\n    memcpy(&thd->org_status_var, &thd->status_var, sizeof(thd->status_var));\n    thd->select_commands= thd->update_commands= thd->other_commands= 0;\n  }\n\n  /**\n    Clear the set of flags that are expected to be cleared at the\n    beginning of each command.\n  */\n  thd->server_status&= ~SERVER_STATUS_CLEAR_SET;\n  if (is_next_command)\n  {\n    drop_more_results= !MY_TEST(thd->server_status &\n                                SERVER_MORE_RESULTS_EXISTS);\n    thd->server_status|= SERVER_MORE_RESULTS_EXISTS;\n    if (is_com_multi)\n      thd->get_stmt_da()->set_skip_flush();\n  }\n\n  if (unlikely(thd->security_ctx->password_expired &&\n               command != COM_QUERY &&\n               command != COM_PING &&\n               command != COM_QUIT &&\n               command != COM_STMT_PREPARE &&\n               command != COM_STMT_EXECUTE))\n  {\n    my_error(ER_MUST_CHANGE_PASSWORD, MYF(0));\n    goto dispatch_end;\n  }\n\n  switch (command) {\n  case COM_INIT_DB:\n  {\n    LEX_CSTRING tmp;\n    status_var_increment(thd->status_var.com_stat[SQLCOM_CHANGE_DB]);\n    if (unlikely(thd->copy_with_error(system_charset_info, (LEX_STRING*) &tmp,\n                                      thd->charset(), packet, packet_length)))\n      break;\n    if (!mysql_change_db(thd, &tmp, FALSE))\n    {\n      general_log_write(thd, command, thd->db.str, thd->db.length);\n      my_ok(thd);\n    }\n    break;\n  }\n#ifdef HAVE_REPLICATION\n  case COM_REGISTER_SLAVE:\n  {\n    status_var_increment(thd->status_var.com_register_slave);\n    if (!thd->register_slave((uchar*) packet, packet_length))\n      my_ok(thd);\n    break;\n  }\n#endif\n  case COM_RESET_CONNECTION:\n  {\n    thd->status_var.com_other++;\n#ifdef WITH_WSREP\n    wsrep_after_command_ignore_result(thd);\n    wsrep_close(thd);\n#endif /* WITH_WSREP */\n    thd->change_user();\n    thd->clear_error();                         // if errors from rollback\n#ifdef WITH_WSREP\n    wsrep_open(thd);\n    wsrep_before_command(thd);\n#endif /* WITH_WSREP */\n    /* Restore original charset from client authentication packet.*/\n    if(thd->org_charset)\n      thd->update_charset(thd->org_charset,thd->org_charset,thd->org_charset);\n    my_ok(thd, 0, 0, 0);\n    break;\n  }\n  case COM_CHANGE_USER:\n  {\n    int auth_rc;\n    status_var_increment(thd->status_var.com_other);\n\n#ifdef WITH_WSREP\n    wsrep_after_command_ignore_result(thd);\n    wsrep_close(thd);\n#endif /* WITH_WSREP */\n    thd->change_user();\n#ifdef WITH_WSREP\n    wsrep_open(thd);\n    wsrep_before_command(thd);\n#endif /* WITH_WSREP */\n    thd->clear_error();                         // if errors from rollback\n\n    /* acl_authenticate() takes the data from net->read_pos */\n    net->read_pos= (uchar*)packet;\n\n    LEX_CSTRING save_db= thd->db;\n    USER_CONN *save_user_connect= thd->user_connect;\n    Security_context save_security_ctx= *thd->security_ctx;\n    CHARSET_INFO *save_character_set_client=\n      thd->variables.character_set_client;\n    CHARSET_INFO *save_collation_connection=\n      thd->variables.collation_connection;\n    CHARSET_INFO *save_character_set_results=\n      thd->variables.character_set_results;\n\n    /* Ensure we don't free security_ctx->user in case we have to revert */\n    thd->security_ctx->user= 0;\n    thd->user_connect= 0;\n\n    /*\n      to limit COM_CHANGE_USER ability to brute-force passwords,\n      we only allow three unsuccessful COM_CHANGE_USER per connection.\n    */\n    if (thd->failed_com_change_user >= 3)\n    {\n      my_message(ER_UNKNOWN_COM_ERROR, ER_THD(thd,ER_UNKNOWN_COM_ERROR),\n                 MYF(0));\n      auth_rc= 1;\n    }\n    else\n      auth_rc= acl_authenticate(thd, packet_length);\n\n    mysql_audit_notify_connection_change_user(thd);\n    if (auth_rc)\n    {\n      /* Free user if allocated by acl_authenticate */\n      my_free(const_cast<char*>(thd->security_ctx->user));\n      *thd->security_ctx= save_security_ctx;\n      if (thd->user_connect)\n\tdecrease_user_connections(thd->user_connect);\n      thd->user_connect= save_user_connect;\n      thd->reset_db(&save_db);\n      thd->update_charset(save_character_set_client, save_collation_connection,\n                          save_character_set_results);\n      thd->failed_com_change_user++;\n      my_sleep(1000000);\n    }\n    else\n    {\n#ifndef NO_EMBEDDED_ACCESS_CHECKS\n      /* we've authenticated new user */\n      if (save_user_connect)\n\tdecrease_user_connections(save_user_connect);\n#endif /* NO_EMBEDDED_ACCESS_CHECKS */\n      my_free((char*) save_db.str);\n      my_free(const_cast<char*>(save_security_ctx.user));\n    }\n    break;\n  }\n  case COM_STMT_BULK_EXECUTE:\n  {\n    mysqld_stmt_bulk_execute(thd, packet, packet_length);\n#ifdef WITH_WSREP\n    if (WSREP(thd))\n    {\n        (void)wsrep_after_statement(thd);\n    }\n#endif /* WITH_WSREP */\n    break;\n  }\n  case COM_STMT_EXECUTE:\n  {\n    mysqld_stmt_execute(thd, packet, packet_length);\n#ifdef WITH_WSREP\n    if (WSREP(thd))\n    {\n        (void)wsrep_after_statement(thd);\n    }\n#endif /* WITH_WSREP */\n    break;\n  }\n  case COM_STMT_FETCH:\n  {\n    mysqld_stmt_fetch(thd, packet, packet_length);\n    break;\n  }\n  case COM_STMT_SEND_LONG_DATA:\n  {\n    mysql_stmt_get_longdata(thd, packet, packet_length);\n    break;\n  }\n  case COM_STMT_PREPARE:\n  {\n    mysqld_stmt_prepare(thd, packet, packet_length);\n    break;\n  }\n  case COM_STMT_CLOSE:\n  {\n    mysqld_stmt_close(thd, packet);\n    break;\n  }\n  case COM_STMT_RESET:\n  {\n    mysqld_stmt_reset(thd, packet);\n    break;\n  }\n  case COM_QUERY:\n  {\n    DBUG_ASSERT(thd->m_digest == NULL);\n    thd->m_digest= & thd->m_digest_state;\n    thd->m_digest->reset(thd->m_token_array, max_digest_length);\n\n    if (unlikely(alloc_query(thd, packet, packet_length)))\n      break;\t\t\t\t\t// fatal error is set\n    MYSQL_QUERY_START(thd->query(), thd->thread_id,\n                      thd->get_db(),\n                      &thd->security_ctx->priv_user[0],\n                      (char *) thd->security_ctx->host_or_ip);\n    char *packet_end= thd->query() + thd->query_length();\n    general_log_write(thd, command, thd->query(), thd->query_length());\n    DBUG_PRINT(\"query\",(\"%-.4096s\",thd->query()));\n#if defined(ENABLED_PROFILING)\n    thd->profiling.set_query_source(thd->query(), thd->query_length());\n#endif\n    MYSQL_SET_STATEMENT_TEXT(thd->m_statement_psi, thd->query(),\n                             thd->query_length());\n\n    Parser_state parser_state;\n    if (unlikely(parser_state.init(thd, thd->query(), thd->query_length())))\n      break;\n\n#ifdef WITH_WSREP\n    if (WSREP(thd))\n    {\n      if (wsrep_mysql_parse(thd, thd->query(), thd->query_length(),\n                            &parser_state,\n                            is_com_multi, is_next_command))\n      {\n        WSREP_DEBUG(\"Deadlock error for: %s\", thd->query());\n        mysql_mutex_lock(&thd->LOCK_thd_data);\n        thd->reset_kill_query();\n        thd->wsrep_retry_counter  = 0;\n        mysql_mutex_unlock(&thd->LOCK_thd_data);\n        goto dispatch_end;\n      }\n    }\n    else\n#endif /* WITH_WSREP */\n      mysql_parse(thd, thd->query(), thd->query_length(), &parser_state,\n                  is_com_multi, is_next_command);\n\n    while (!thd->killed && (parser_state.m_lip.found_semicolon != NULL) &&\n           ! thd->is_error())\n    {\n      /*\n        Multiple queries exist, execute them individually\n      */\n      char *beginning_of_next_stmt= (char*) parser_state.m_lip.found_semicolon;\n\n      ha_maria_implicit_commit(thd, FALSE);\n\n      /* Finalize server status flags after executing a statement. */\n      thd->update_server_status();\n      thd->protocol->end_statement();\n      query_cache_end_of_result(thd);\n\n      mysql_audit_general(thd, MYSQL_AUDIT_GENERAL_STATUS,\n                          thd->get_stmt_da()->is_error()\n                            ? thd->get_stmt_da()->sql_errno()\n                            : 0,\n                          command_name[command].str);\n\n      ulong length= (ulong)(packet_end - beginning_of_next_stmt);\n\n      log_slow_statement(thd);\n      DBUG_ASSERT(!thd->apc_target.is_enabled());\n\n      /* Remove garbage at start of query */\n      while (length > 0 && my_isspace(thd->charset(), *beginning_of_next_stmt))\n      {\n        beginning_of_next_stmt++;\n        length--;\n      }\n\n      /* PSI end */\n      MYSQL_END_STATEMENT(thd->m_statement_psi, thd->get_stmt_da());\n      thd->m_statement_psi= NULL;\n      thd->m_digest= NULL;\n\n      /* DTRACE end */\n      if (MYSQL_QUERY_DONE_ENABLED())\n      {\n        MYSQL_QUERY_DONE(thd->is_error());\n      }\n\n#if defined(ENABLED_PROFILING)\n      thd->profiling.finish_current_query();\n      thd->profiling.start_new_query(\"continuing\");\n      thd->profiling.set_query_source(beginning_of_next_stmt, length);\n#endif\n\n      /* DTRACE begin */\n      MYSQL_QUERY_START(beginning_of_next_stmt, thd->thread_id,\n                        thd->get_db(),\n                        &thd->security_ctx->priv_user[0],\n                        (char *) thd->security_ctx->host_or_ip);\n\n      /* PSI begin */\n      thd->m_digest= & thd->m_digest_state;\n\n      thd->m_statement_psi= MYSQL_START_STATEMENT(&thd->m_statement_state,\n                                                  com_statement_info[command].m_key,\n                                                  thd->db.str, thd->db.length,\n                                                  thd->charset());\n      THD_STAGE_INFO(thd, stage_init);\n      MYSQL_SET_STATEMENT_TEXT(thd->m_statement_psi, beginning_of_next_stmt,\n                               length);\n\n      thd->set_query_and_id(beginning_of_next_stmt, length,\n                            thd->charset(), next_query_id());\n\n      /*\n        Count each statement from the client.\n      */\n      statistic_increment(thd->status_var.questions, &LOCK_status);\n\n      if (!WSREP(thd))\n        thd->set_time(); /* Reset the query start time. */\n\n      parser_state.reset(beginning_of_next_stmt, length);\n\n#ifdef WITH_WSREP\n      if (WSREP(thd))\n      {\n        if (wsrep_mysql_parse(thd, beginning_of_next_stmt,\n                              length, &parser_state,\n                              is_com_multi, is_next_command))\n        {\n          WSREP_DEBUG(\"Deadlock error for: %s\", thd->query());\n          mysql_mutex_lock(&thd->LOCK_thd_data);\n          thd->reset_kill_query();\n          thd->wsrep_retry_counter  = 0;\n          mysql_mutex_unlock(&thd->LOCK_thd_data);\n\n          goto dispatch_end;\n        }\n      }\n      else\n#endif /* WITH_WSREP */\n      mysql_parse(thd, beginning_of_next_stmt, length, &parser_state,\n                  is_com_multi, is_next_command);\n\n    }\n\n    DBUG_PRINT(\"info\",(\"query ready\"));\n    break;\n  }\n  case COM_FIELD_LIST:\t\t\t\t// This isn't actually needed\n#ifdef DONT_ALLOW_SHOW_COMMANDS\n    my_message(ER_NOT_ALLOWED_COMMAND, ER_THD(thd, ER_NOT_ALLOWED_COMMAND),\n               MYF(0));\t/* purecov: inspected */\n    break;\n#else\n  {\n    char *fields, *packet_end= packet + packet_length, *arg_end;\n    /* Locked closure of all tables */\n    TABLE_LIST table_list;\n    LEX_STRING table_name;\n    LEX_CSTRING db;\n    /*\n      SHOW statements should not add the used tables to the list of tables\n      used in a transaction.\n    */\n    MDL_savepoint mdl_savepoint= thd->mdl_context.mdl_savepoint();\n\n    status_var_increment(thd->status_var.com_stat[SQLCOM_SHOW_FIELDS]);\n    if (thd->copy_db_to(&db))\n      break;\n    /*\n      We have name + wildcard in packet, separated by endzero\n      (The packet is guaranteed to end with an end zero)\n    */\n    arg_end= strend(packet);\n    uint arg_length= (uint)(arg_end - packet);\n\n    /* Check given table name length. */\n    if (packet_length - arg_length > NAME_LEN + 1 || arg_length > SAFE_NAME_LEN)\n    {\n      my_message(ER_UNKNOWN_COM_ERROR, ER_THD(thd, ER_UNKNOWN_COM_ERROR),\n                 MYF(0));\n      break;\n    }\n    thd->convert_string(&table_name, system_charset_info,\n\t\t\tpacket, arg_length, thd->charset());\n    if (check_table_name(table_name.str, table_name.length, FALSE))\n    {\n      /* this is OK due to convert_string() null-terminating the string */\n      my_error(ER_WRONG_TABLE_NAME, MYF(0), table_name.str);\n      break;\n    }\n    packet= arg_end + 1;\n    // thd->reset_for_next_command reset state => restore it\n    if (is_next_command)\n    {\n      thd->server_status|= SERVER_MORE_RESULTS_EXISTS;\n      if (is_com_multi)\n        thd->get_stmt_da()->set_skip_flush();\n    }\n\n    lex_start(thd);\n    /* Must be before we init the table list. */\n    if (lower_case_table_names)\n    {\n      table_name.length= my_casedn_str(files_charset_info, table_name.str);\n      db.length= my_casedn_str(files_charset_info, (char*) db.str);\n    }\n    table_list.init_one_table(&db, (LEX_CSTRING*) &table_name, 0, TL_READ);\n    /*\n      Init TABLE_LIST members necessary when the undelrying\n      table is view.\n    */\n    table_list.select_lex= thd->lex->first_select_lex();\n    thd->lex->\n      first_select_lex()->table_list.link_in_list(&table_list,\n                                                  &table_list.next_local);\n    thd->lex->add_to_query_tables(&table_list);\n\n    if (is_infoschema_db(&table_list.db))\n    {\n      ST_SCHEMA_TABLE *schema_table= find_schema_table(thd, &table_list.alias);\n      if (schema_table)\n        table_list.schema_table= schema_table;\n    }\n\n    uint query_length= (uint) (packet_end - packet); // Don't count end \\0\n    if (!(fields= (char *) thd->memdup(packet, query_length + 1)))\n      break;\n    thd->set_query(fields, query_length);\n    general_log_print(thd, command, \"%s %s\", table_list.table_name.str,\n                      fields);\n\n    if (thd->open_temporary_tables(&table_list))\n      break;\n\n    if (check_table_access(thd, SELECT_ACL, &table_list,\n                           TRUE, UINT_MAX, FALSE))\n      break;\n    /*\n      Turn on an optimization relevant if the underlying table\n      is a view: do not fill derived tables.\n    */\n    thd->lex->sql_command= SQLCOM_SHOW_FIELDS;\n\n    mysqld_list_fields(thd,&table_list,fields);\n    thd->lex->unit.cleanup();\n    /* No need to rollback statement transaction, it's not started. */\n    DBUG_ASSERT(thd->transaction.stmt.is_empty());\n    close_thread_tables(thd);\n    thd->mdl_context.rollback_to_savepoint(mdl_savepoint);\n\n    if (thd->transaction_rollback_request)\n    {\n      /*\n        Transaction rollback was requested since MDL deadlock was\n        discovered while trying to open tables. Rollback transaction\n        in all storage engines including binary log and release all\n        locks.\n      */\n      trans_rollback_implicit(thd);\n      thd->release_transactional_locks();\n    }\n\n    thd->cleanup_after_query();\n    break;\n  }\n#endif\n  case COM_QUIT:\n    /* Note: We don't calculate statistics for this command */\n\n    /* Ensure that quit works even if max_mem_used is set */\n    thd->variables.max_mem_used= LONGLONG_MAX;\n    general_log_print(thd, command, NullS);\n    net->error=0;\t\t\t\t// Don't give 'abort' message\n    thd->get_stmt_da()->disable_status();       // Don't send anything back\n    error=TRUE;\t\t\t\t\t// End server\n    break;\n#ifndef EMBEDDED_LIBRARY\n  case COM_BINLOG_DUMP:\n    {\n      ulong pos;\n      ushort flags;\n      uint32 slave_server_id;\n\n      status_var_increment(thd->status_var.com_other);\n\n      thd->query_plan_flags|= QPLAN_ADMIN;\n      if (check_global_access(thd, REPL_SLAVE_ACL))\n\tbreak;\n\n      /* TODO: The following has to be changed to an 8 byte integer */\n      pos = uint4korr(packet);\n      flags = uint2korr(packet + 4);\n      thd->variables.server_id=0; /* avoid suicide */\n      if ((slave_server_id= uint4korr(packet+6))) // mysqlbinlog.server_id==0\n\tkill_zombie_dump_threads(slave_server_id);\n      thd->variables.server_id = slave_server_id;\n\n      const char *name= packet + 10;\n      size_t nlen= strlen(name);\n\n      general_log_print(thd, command, \"Log: '%s'  Pos: %lu\", name, pos);\n      if (nlen < FN_REFLEN)\n        mysql_binlog_send(thd, thd->strmake(name, nlen), (my_off_t)pos, flags);\n      thd->unregister_slave(); // todo: can be extraneous\n      /*  fake COM_QUIT -- if we get here, the thread needs to terminate */\n      error = TRUE;\n      break;\n    }\n#endif\n  case COM_REFRESH:\n  {\n    int not_used;\n\n    /*\n      Initialize thd->lex since it's used in many base functions, such as\n      open_tables(). Otherwise, it remains unitialized and may cause crash\n      during execution of COM_REFRESH.\n    */\n    lex_start(thd);\n    \n    status_var_increment(thd->status_var.com_stat[SQLCOM_FLUSH]);\n    ulonglong options= (ulonglong) (uchar) packet[0];\n    if (trans_commit_implicit(thd))\n      break;\n    thd->release_transactional_locks();\n    if (check_global_access(thd,RELOAD_ACL))\n      break;\n    general_log_print(thd, command, NullS);\n#ifndef DBUG_OFF\n    bool debug_simulate= FALSE;\n    DBUG_EXECUTE_IF(\"simulate_detached_thread_refresh\", debug_simulate= TRUE;);\n    if (debug_simulate)\n    {\n      /* This code doesn't work under FTWRL */\n      DBUG_ASSERT(! (options & REFRESH_READ_LOCK));\n      /*\n        Simulate a reload without a attached thread session.\n        Provides a environment similar to that of when the\n        server receives a SIGHUP signal and reloads caches\n        and flushes tables.\n      */\n      bool res;\n      set_current_thd(0);\n      res= reload_acl_and_cache(NULL, options | REFRESH_FAST,\n                                NULL, &not_used);\n      set_current_thd(thd);\n      if (res)\n        break;\n    }\n    else\n#endif\n    {\n      thd->lex->relay_log_connection_name= empty_clex_str;\n      if (reload_acl_and_cache(thd, options, (TABLE_LIST*) 0, &not_used))\n        break;\n    }\n    if (trans_commit_implicit(thd))\n      break;\n    close_thread_tables(thd);\n    thd->release_transactional_locks();\n    my_ok(thd);\n    break;\n  }\n#ifndef EMBEDDED_LIBRARY\n  case COM_SHUTDOWN:\n  {\n    status_var_increment(thd->status_var.com_other);\n    if (check_global_access(thd,SHUTDOWN_ACL))\n      break; /* purecov: inspected */\n    /*\n      If the client is < 4.1.3, it is going to send us no argument; then\n      packet_length is 0, packet[0] is the end 0 of the packet. Note that\n      SHUTDOWN_DEFAULT is 0. If client is >= 4.1.3, the shutdown level is in\n      packet[0].\n    */\n    enum mysql_enum_shutdown_level level;\n    level= (enum mysql_enum_shutdown_level) (uchar) packet[0];\n    thd->lex->is_shutdown_wait_for_slaves= false;  // \"deferred\" cleanup\n    if (level == SHUTDOWN_DEFAULT)\n      level= SHUTDOWN_WAIT_ALL_BUFFERS; // soon default will be configurable\n    else if (level != SHUTDOWN_WAIT_ALL_BUFFERS)\n    {\n      my_error(ER_NOT_SUPPORTED_YET, MYF(0), \"this shutdown level\");\n      break;\n    }\n    DBUG_PRINT(\"quit\",(\"Got shutdown command for level %u\", level));\n    general_log_print(thd, command, NullS);\n    my_eof(thd);\n    kill_mysql(thd);\n    error=TRUE;\n    break;\n  }\n#endif\n  case COM_STATISTICS:\n  {\n    STATUS_VAR *current_global_status_var;      // Big; Don't allocate on stack\n    ulong uptime;\n    ulonglong queries_per_second1000;\n    char buff[250];\n    uint buff_len= sizeof(buff);\n\n    if (!(current_global_status_var= (STATUS_VAR*)\n          thd->alloc(sizeof(STATUS_VAR))))\n      break;\n    general_log_print(thd, command, NullS);\n    status_var_increment(thd->status_var.com_stat[SQLCOM_SHOW_STATUS]);\n    *current_global_status_var= global_status_var;\n    calc_sum_of_all_status(current_global_status_var);\n    if (!(uptime= (ulong) (thd->start_time - server_start_time)))\n      queries_per_second1000= 0;\n    else\n      queries_per_second1000= thd->query_id * 1000 / uptime;\n#ifndef EMBEDDED_LIBRARY\n    size_t length=\n#endif\n    my_snprintf(buff, buff_len - 1,\n                        \"Uptime: %lu  Threads: %u  Questions: %lu  \"\n                        \"Slow queries: %lu  Opens: %lu  Flush tables: %lld  \"\n                        \"Open tables: %u  Queries per second avg: %u.%03u\",\n                        uptime, THD_count::value(), (ulong) thd->query_id,\n                        current_global_status_var->long_query_count,\n                        current_global_status_var->opened_tables,\n                        tdc_refresh_version(), tc_records(),\n                        (uint) (queries_per_second1000 / 1000),\n                        (uint) (queries_per_second1000 % 1000));\n#ifdef EMBEDDED_LIBRARY\n    /* Store the buffer in permanent memory */\n    my_ok(thd, 0, 0, buff);\n#else\n    (void) my_net_write(net, (uchar*) buff, length);\n    (void) net_flush(net);\n    thd->get_stmt_da()->disable_status();\n#endif\n    break;\n  }\n  case COM_PING:\n    status_var_increment(thd->status_var.com_other);\n    my_ok(thd);\t\t\t\t// Tell client we are alive\n    break;\n  case COM_PROCESS_INFO:\n    status_var_increment(thd->status_var.com_stat[SQLCOM_SHOW_PROCESSLIST]);\n    if (!thd->security_ctx->priv_user[0] &&\n        check_global_access(thd, PROCESS_ACL))\n      break;\n    general_log_print(thd, command, NullS);\n    mysqld_list_processes(thd,\n\t\t\t  thd->security_ctx->master_access & PROCESS_ACL ? \n\t\t\t  NullS : thd->security_ctx->priv_user, 0);\n    break;\n  case COM_PROCESS_KILL:\n  {\n    status_var_increment(thd->status_var.com_stat[SQLCOM_KILL]);\n    ulong id=(ulong) uint4korr(packet);\n    sql_kill(thd, id, KILL_CONNECTION_HARD, KILL_TYPE_ID);\n    break;\n  }\n  case COM_SET_OPTION:\n  {\n    status_var_increment(thd->status_var.com_stat[SQLCOM_SET_OPTION]);\n    uint opt_command= uint2korr(packet);\n\n    switch (opt_command) {\n    case (int) MYSQL_OPTION_MULTI_STATEMENTS_ON:\n      thd->client_capabilities|= CLIENT_MULTI_STATEMENTS;\n      my_eof(thd);\n      break;\n    case (int) MYSQL_OPTION_MULTI_STATEMENTS_OFF:\n      thd->client_capabilities&= ~CLIENT_MULTI_STATEMENTS;\n      my_eof(thd);\n      break;\n    default:\n      my_message(ER_UNKNOWN_COM_ERROR, ER_THD(thd, ER_UNKNOWN_COM_ERROR),\n                 MYF(0));\n      break;\n    }\n    break;\n  }\n  case COM_DEBUG:\n    status_var_increment(thd->status_var.com_other);\n    if (check_global_access(thd, SUPER_ACL))\n      break;\t\t\t\t\t/* purecov: inspected */\n    mysql_print_status();\n    general_log_print(thd, command, NullS);\n    my_eof(thd);\n    break;\n  case COM_MULTI:\n  {\n    uint counter;\n    uint current_com= 0;\n    DBUG_ASSERT(!is_com_multi);\n    if (!(thd->client_capabilities & CLIENT_MULTI_RESULTS))\n    {\n      /* The client does not support multiple result sets being sent back */\n      my_error(ER_COMMULTI_BADCONTEXT, MYF(0));\n      break;\n    }\n\n    if (!(counter= maria_multi_check(thd, packet, packet_length)))\n      break;\n\n    {\n      char *packet_start= packet;\n      /* We have to store next length because it will be destroyed by '\\0' */\n      size_t next_subpacket_length= net_field_length((uchar **)&packet_start);\n      size_t next_length_length= packet_start - packet;\n      unsigned char *readbuff= net->buff;\n\n      if (net_allocate_new_packet(net, thd, MYF(0)))\n        break;\n\n      PSI_statement_locker *save_locker= thd->m_statement_psi;\n      sql_digest_state *save_digest= thd->m_digest;\n      thd->m_statement_psi= NULL;\n      thd->m_digest= NULL;\n\n      while (packet_length)\n      {\n        current_com++;\n        size_t subpacket_length= next_subpacket_length + next_length_length;\n        size_t length_length= next_length_length;\n        if (subpacket_length < packet_length)\n        {\n          packet_start= packet + subpacket_length;\n          next_subpacket_length= net_field_length((uchar**)&packet_start);\n          next_length_length= packet_start - (packet + subpacket_length);\n        }\n        /* safety like in do_command() */\n        packet[subpacket_length]= '\\0';\n\n        enum enum_server_command subcommand=\n          fetch_command(thd, (packet + length_length));\n\n        if (server_command_flags[subcommand] & CF_NO_COM_MULTI)\n        {\n          my_error(ER_BAD_COMMAND_IN_MULTI, MYF(0),\n                   command_name[subcommand].str);\n          goto com_multi_end;\n        }\n\n        if (dispatch_command(subcommand, thd, packet + (1 + length_length),\n                             (uint)(subpacket_length - (1 + length_length)), TRUE,\n                             (current_com != counter)))\n        {\n          DBUG_ASSERT(thd->is_error());\n          goto com_multi_end;\n        }\n\n        DBUG_ASSERT(subpacket_length <= packet_length);\n        packet+= subpacket_length;\n        packet_length-= (uint)subpacket_length;\n      }\n\ncom_multi_end:\n      thd->m_statement_psi= save_locker;\n      thd->m_digest= save_digest;\n\n      /* release old buffer */\n      net_flush(net);\n      DBUG_ASSERT(net->buff == net->write_pos); // nothing to send\n      my_free(readbuff);\n    }\n    break;\n  }\n  case COM_SLEEP:\n  case COM_CONNECT:\t\t\t\t// Impossible here\n  case COM_TIME:\t\t\t\t// Impossible from client\n  case COM_DELAYED_INSERT:\n  case COM_END:\n  case COM_UNIMPLEMENTED:\n  default:\n    my_message(ER_UNKNOWN_COM_ERROR, ER_THD(thd, ER_UNKNOWN_COM_ERROR),\n               MYF(0));\n    break;\n  }\n\ndispatch_end:\n#ifdef WITH_WSREP\n  /*\n    BF aborted before sending response back to client\n  */\n  if (thd->killed == KILL_QUERY)\n  {\n    WSREP_DEBUG(\"THD is killed at dispatch_end\");\n  }\n  wsrep_after_command_before_result(thd);\n  if (wsrep_current_error(thd) && !wsrep_command_no_result(command))\n  {\n    /* todo: Pass wsrep client state current error to override */\n    wsrep_override_error(thd, wsrep_current_error(thd),\n                         wsrep_current_error_status(thd));\n    WSREP_LOG_THD(thd, \"leave\");\n  }\n  if (WSREP(thd))\n  {\n    /*\n      MDEV-10812\n      In the case of COM_QUIT/COM_STMT_CLOSE thread status should be disabled.\n    */\n    DBUG_ASSERT((command != COM_QUIT && command != COM_STMT_CLOSE)\n                  || thd->get_stmt_da()->is_disabled());\n    DBUG_ASSERT(thd->wsrep_trx().state() != wsrep::transaction::s_replaying);\n    /* wsrep BF abort in query exec phase */\n    mysql_mutex_lock(&thd->LOCK_thd_kill);\n    do_end_of_statement= thd_is_connection_alive(thd);\n    mysql_mutex_unlock(&thd->LOCK_thd_kill);\n  }\n  else\n    do_end_of_statement= true;\n\n#endif /* WITH_WSREP */\n\n  if (do_end_of_statement)\n  {\n    DBUG_ASSERT(thd->derived_tables == NULL &&\n               (thd->open_tables == NULL ||\n               (thd->locked_tables_mode == LTM_LOCK_TABLES)));\n\n    thd_proc_info(thd, \"Updating status\");\n    /* Finalize server status flags after executing a command. */\n    thd->update_server_status();\n    if (command != COM_MULTI)\n    {\n      thd->protocol->end_statement();\n      query_cache_end_of_result(thd);\n    }\n  }\n  if (drop_more_results)\n    thd->server_status&= ~SERVER_MORE_RESULTS_EXISTS;\n\n  if (likely(!thd->is_error() && !thd->killed_errno()))\n    mysql_audit_general(thd, MYSQL_AUDIT_GENERAL_RESULT, 0, 0);\n\n  mysql_audit_general(thd, MYSQL_AUDIT_GENERAL_STATUS,\n                      thd->get_stmt_da()->is_error() ?\n                      thd->get_stmt_da()->sql_errno() : 0,\n                      command_name[command].str);\n\n  thd->update_all_stats();\n\n  log_slow_statement(thd);\n\n  THD_STAGE_INFO(thd, stage_cleaning_up);\n  thd->reset_query();\n\n  /* Performance Schema Interface instrumentation, end */\n  MYSQL_END_STATEMENT(thd->m_statement_psi, thd->get_stmt_da());\n  thd->set_examined_row_count(0);                   // For processlist\n  thd->set_command(COM_SLEEP);\n\n  thd->m_statement_psi= NULL;\n  thd->m_digest= NULL;\n\n  if (!is_com_multi)\n    thd->packet.shrink(thd->variables.net_buffer_length); // Reclaim some memory\n\n  thd->reset_kill_query();  /* Ensure that killed_errmsg is released */\n  /*\n    LEX::m_sql_cmd can point to Sql_cmd allocated on thd->mem_root.\n    Unlink it now, before freeing the root.\n  */\n  thd->lex->m_sql_cmd= NULL;\n  free_root(thd->mem_root,MYF(MY_KEEP_PREALLOC));\n\n#if defined(ENABLED_PROFILING)\n  thd->profiling.finish_current_query();\n#endif\n  if (MYSQL_QUERY_DONE_ENABLED() || MYSQL_COMMAND_DONE_ENABLED())\n  {\n    int res __attribute__((unused));\n    res= (int) thd->is_error();\n    if (command == COM_QUERY)\n    {\n      MYSQL_QUERY_DONE(res);\n    }\n    MYSQL_COMMAND_DONE(res);\n  }\n  DEBUG_SYNC(thd,\"dispatch_command_end\");\n\n  /* Check that some variables are reset properly */\n  DBUG_ASSERT(thd->abort_on_warning == 0);\n  thd->lex->restore_set_statement_var();\n  DBUG_RETURN(error);\n}",
        "target": 0
    },
    {
        "func": "bool LEX::stmt_create_udf_function(const DDL_options_st &options,\n                                   enum_sp_aggregate_type agg_type,\n                                   const Lex_ident_sys_st &name,\n                                   Item_result return_type,\n                                   const LEX_CSTRING &soname)\n{\n  if (stmt_create_function_start(options))\n    return true;\n\n   if (unlikely(is_native_function(thd, &name)))\n   {\n     my_error(ER_NATIVE_FCT_NAME_COLLISION, MYF(0), name.str);\n     return true;\n   }\n   sql_command= SQLCOM_CREATE_FUNCTION;\n   udf.name= name;\n   udf.returns= return_type;\n   udf.dl= soname.str;\n   udf.type= agg_type == GROUP_AGGREGATE ? UDFTYPE_AGGREGATE :\n                                           UDFTYPE_FUNCTION;\n   stmt_create_routine_finalize();\n   return false;\n}",
        "target": 0
    },
    {
        "func": "  Lex_ident_sys(THD *thd, const Lex_ident_cli_st *str)\n  {\n    if (copy_ident_cli(thd, str))\n      ((LEX_CSTRING &) *this)= null_clex_str;\n  }",
        "target": 0
    },
    {
        "func": "  inline bool is_arena_for_set_stmt() {return arena_for_set_stmt != 0;}",
        "target": 0
    },
    {
        "func": "Item *Lex_trim_st::make_item_func_trim(THD *thd) const\n{\n  return (thd->variables.sql_mode & MODE_ORACLE) ?\n         make_item_func_trim_oracle(thd) :\n         make_item_func_trim_std(thd);\n}",
        "target": 0
    },
    {
        "func": "bool LEX::sp_for_loop_condition(THD *thd, const Lex_for_loop_st &loop)\n{\n  Item_splocal *args[2];\n  for (uint i= 0 ; i < 2; i++)\n  {\n    sp_variable *src= i == 0 ? loop.m_index : loop.m_target_bound;\n    args[i]= new (thd->mem_root)\n              Item_splocal(thd, &sp_rcontext_handler_local,\n                           &src->name, src->offset, src->type_handler());\n    if (unlikely(args[i] == NULL))\n      return true;\n#ifdef DBUG_ASSERT_EXISTS\n    args[i]->m_sp= sphead;\n#endif\n  }\n\n  Item *expr= loop.m_direction > 0 ?\n    (Item *) new (thd->mem_root) Item_func_le(thd, args[0], args[1]) :\n    (Item *) new (thd->mem_root) Item_func_ge(thd, args[0], args[1]);\n  return unlikely(!expr) || unlikely(sp_while_loop_expression(thd, expr));\n}",
        "target": 0
    },
    {
        "func": "st_parsing_options::reset()\n{\n  allows_variable= TRUE;\n  lookup_keywords_after_qualifier= false;\n}",
        "target": 0
    },
    {
        "func": "  Lex_ident_sys & operator=(const Lex_ident_sys_st &name)\n  {\n    Lex_ident_sys_st::operator=(name);\n    return *this;\n  }",
        "target": 0
    },
    {
        "func": "bool SELECT_LEX::merge_subquery(THD *thd, TABLE_LIST *derived,\n                                SELECT_LEX *subq_select,\n                                uint table_no, table_map map)\n{\n  derived->wrap_into_nested_join(subq_select->top_join_list);\n\n  ftfunc_list->append(subq_select->ftfunc_list);\n  if (join ||\n      thd->lex->sql_command == SQLCOM_UPDATE_MULTI ||\n      thd->lex->sql_command == SQLCOM_DELETE_MULTI)\n  {\n    List_iterator_fast<Item_in_subselect> li(subq_select->sj_subselects);\n    Item_in_subselect *in_subq;\n    while ((in_subq= li++))\n    {\n      sj_subselects.push_back(in_subq, thd->mem_root);\n      if (in_subq->emb_on_expr_nest == NO_JOIN_NEST)\n         in_subq->emb_on_expr_nest= derived;\n    }\n\n    uint cnt= sizeof(expr_cache_may_be_used)/sizeof(bool);\n    for (uint i= 0; i < cnt; i++)\n    {\n      if (subq_select->expr_cache_may_be_used[i])\n        expr_cache_may_be_used[i]= true;\n    }\n\n    List_iterator_fast<Item_func_in> it(subq_select->in_funcs);\n    Item_func_in *in_func;\n    while ((in_func= it++))\n    {\n      in_funcs.push_back(in_func, thd->mem_root);\n      if (in_func->emb_on_expr_nest == NO_JOIN_NEST)\n        in_func->emb_on_expr_nest= derived;\n    }\n  }\n\n  /* Walk through child's tables and adjust table map, tablenr,\n   * parent_lex */\n  subq_select->remap_tables(derived, map, table_no, this);\n  subq_select->merged_into= this;\n\n  replace_leaf_table(derived, subq_select->leaf_tables);\n\n  return FALSE;\n}",
        "target": 0
    },
    {
        "func": "  void set_non_agg_field_used(bool val) { m_non_agg_field_used= val; }",
        "target": 0
    },
    {
        "func": "bool st_select_lex::add_cross_joined_table(TABLE_LIST *left_op,\n                                           TABLE_LIST *right_op,\n                                           bool straight_fl)\n{\n  DBUG_ENTER(\"add_cross_joined_table\");\n  THD *thd= parent_lex->thd;\n  if (!(right_op->nested_join &&\n\t(right_op->nested_join->nest_type & JOIN_OP_NEST)))\n  {\n    /*\n      This handles the cases when the right operand is not a nested join.\n      like in queries\n        SELECT * FROM t1 JOIN t2;\n        SELECT * FROM t1 LEFT JOIN t2 ON t1.a=t2.a JOIN t3\n    */\n    add_joined_table(left_op);\n    add_joined_table(right_op);\n    right_op->straight= straight_fl;\n    DBUG_RETURN(false);\n  }\n\n  TABLE_LIST *tbl;\n  List<TABLE_LIST> *right_op_jl= right_op->join_list;\n  TABLE_LIST *cj_nest;\n\n  /*\n    Create the node NJ for a new nested join for the future inclusion\n    of left_op in it. Initially the nest is empty.\n  */\n  if (unlikely(!(cj_nest=\n                 (TABLE_LIST*) thd->calloc(ALIGN_SIZE(sizeof(TABLE_LIST))+\n                                           sizeof(NESTED_JOIN)))))\n    DBUG_RETURN(true);\n  cj_nest->nested_join=\n    ((NESTED_JOIN*) ((uchar*) cj_nest + ALIGN_SIZE(sizeof(TABLE_LIST))));\n  cj_nest->nested_join->nest_type= JOIN_OP_NEST;\n  List<TABLE_LIST> *cjl=  &cj_nest->nested_join->join_list;\n  cjl->empty();\n\n  List<TABLE_LIST> *jl= &right_op->nested_join->join_list;\n  DBUG_ASSERT(jl->elements == 2);\n  /* Look for the left most node tbl of the right_op tree */\n  for ( ; ; )\n  {\n    TABLE_LIST *pair_tbl= 0;  /* useful only for operands of natural joins */\n\n    List_iterator<TABLE_LIST> li(*jl);\n    tbl= li++;\n\n    /* Expand name resolution context */\n    Name_resolution_context *on_context;\n    if ((on_context= tbl->on_context))\n    {\n      on_context->first_name_resolution_table=\n        left_op->first_leaf_for_name_resolution();\n    }\n\n    if (!(tbl->outer_join & JOIN_TYPE_RIGHT))\n    {\n      pair_tbl= tbl;\n      tbl= li++;\n    }\n    if (tbl->nested_join &&\n        tbl->nested_join->nest_type & JOIN_OP_NEST)\n    {\n      jl= &tbl->nested_join->join_list;\n      continue;\n    }\n\n    /* Replace the tbl node in the tree for the newly created NJ node */\n    cj_nest->outer_join= tbl->outer_join;\n    cj_nest->on_expr= tbl->on_expr;\n    cj_nest->embedding= tbl->embedding;\n    cj_nest->join_list= jl;\n    cj_nest->alias.str= \"(nest_last_join)\";\n    cj_nest->alias.length= sizeof(\"(nest_last_join)\")-1;\n    li.replace(cj_nest);\n\n    /*\n      If tbl is an operand of a natural join set properly the references\n      in the fields natural_join for both operands of the operation.\n    */\n    if(tbl->embedding && tbl->embedding->is_natural_join)\n    {\n      if (!pair_tbl)\n        pair_tbl= li++;\n      pair_tbl->natural_join= cj_nest;\n      cj_nest->natural_join= pair_tbl;\n    }\n    break;\n  }\n\n  /* Attach tbl as the right operand of NJ */\n  if (unlikely(cjl->push_back(tbl, thd->mem_root)))\n    DBUG_RETURN(true);\n  tbl->outer_join= 0;\n  tbl->on_expr= 0;\n  tbl->straight= straight_fl;\n  tbl->natural_join= 0;\n  tbl->embedding= cj_nest;\n  tbl->join_list= cjl;\n\n  /* Add left_op as the left operand of NJ */\n  if (unlikely(cjl->push_back(left_op, thd->mem_root)))\n    DBUG_RETURN(true);\n  left_op->embedding= cj_nest;\n  left_op->join_list= cjl;\n\n  /*\n    Mark right_op as a rebalanced nested join in order not to\n    create a new top level nested join node.\n  */\n  right_op->nested_join->nest_type|= REBALANCED_NEST;\n  if (unlikely(right_op_jl->push_front(right_op)))\n    DBUG_RETURN(true);\n  DBUG_RETURN(false);\n}",
        "target": 0
    },
    {
        "func": "  bool params_fix_fields(THD *thd)\n  {\n    // Fix Items in the EXECUTE..USING list\n    List_iterator_fast<Item> param_it(m_params);\n    while (Item *param= param_it++)\n    {\n      if (param->fix_fields_if_needed_for_scalar(thd, 0))\n        return true;\n    }\n    return false;\n  }",
        "target": 0
    },
    {
        "func": "LEX_USER *create_default_definer(THD *thd, bool role)\n{\n  LEX_USER *definer;\n\n  if (unlikely(! (definer= (LEX_USER*) thd->alloc(sizeof(LEX_USER)))))\n    return 0;\n\n  thd->get_definer(definer, role);\n\n  if (role && definer->user.length == 0)\n  {\n    my_error(ER_MALFORMED_DEFINER, MYF(0));\n    return 0;\n  }\n  else\n    return definer;\n}",
        "target": 0
    },
    {
        "func": "Item *LEX::create_item_ident(THD *thd,\n                             const Lex_ident_sys_st *a,\n                             const Lex_ident_sys_st *b,\n                             const Lex_ident_sys_st *c)\n{\n  const char *schema= (thd->client_capabilities & CLIENT_NO_SCHEMA ?\n                       NullS : a->str);\n\n  if ((thd->variables.sql_mode & MODE_ORACLE) && c->length == 7)\n  {\n    if (!my_strnncoll(system_charset_info,\n                      (const uchar *) c->str, 7,\n                      (const uchar *) \"NEXTVAL\", 7))\n      return create_item_func_nextval(thd, a, b);\n    else if (!my_strnncoll(system_charset_info,\n                          (const uchar *) c->str, 7,\n                          (const uchar *) \"CURRVAL\", 7))\n      return create_item_func_lastval(thd, a, b);\n  }\n\n  if (current_select->no_table_names_allowed)\n  {\n    my_error(ER_TABLENAME_NOT_ALLOWED_HERE, MYF(0), b->str, thd->where);\n    return NULL;\n  }\n\n  if (current_select->parsing_place == FOR_LOOP_BOUND)\n    return create_item_for_loop_bound(thd, &null_clex_str, b, c);\n\n  return create_item_ident_field(thd, schema, b->str, c);\n}",
        "target": 0
    },
    {
        "func": "bool LEX::sp_block_with_exceptions_add_empty(THD *thd)\n{\n  uint ip= sphead->instructions();\n  return sp_block_with_exceptions_finalize_executable_section(thd, ip) ||\n         sp_block_with_exceptions_finalize_exceptions(thd, ip, 0);\n}",
        "target": 0
    },
    {
        "func": "void LEX::sp_variable_declarations_init(THD *thd, int nvars)\n{\n  sp_variable *spvar= spcont->get_last_context_variable();\n\n  sphead->reset_lex(thd);\n  spcont->declare_var_boundary(nvars);\n  thd->lex->init_last_field(&spvar->field_def, &spvar->name,\n                            thd->variables.collation_database);\n}",
        "target": 0
    },
    {
        "func": "  inline void set_limit_rows_examined()\n  {\n    if (limit_rows_examined)\n      limit_rows_examined_cnt= limit_rows_examined->val_uint();\n    else\n      limit_rows_examined_cnt= ULONGLONG_MAX;\n  }",
        "target": 0
    },
    {
        "func": "bool LEX::only_view_structure()\n{\n  switch (sql_command) {\n  case SQLCOM_SHOW_CREATE:\n  case SQLCOM_CHECKSUM:\n  case SQLCOM_SHOW_TABLES:\n  case SQLCOM_SHOW_FIELDS:\n  case SQLCOM_REVOKE_ALL:\n  case SQLCOM_REVOKE:\n  case SQLCOM_GRANT:\n  case SQLCOM_CREATE_VIEW:\n    return TRUE;\n  case SQLCOM_CREATE_TABLE:\n    return create_info.like();\n  default:\n    return FALSE;\n  }\n}",
        "target": 0
    },
    {
        "func": "void st_select_lex::init_select()\n{\n  sj_nests.empty();\n  sj_subselects.empty();\n  group_list.empty();\n  if (group_list_ptrs)\n    group_list_ptrs->clear();\n  type= 0;\n  db= null_clex_str;\n  having= 0;\n  table_join_options= 0;\n  in_sum_expr= with_wild= 0;\n  options= 0;\n  ftfunc_list_alloc.empty();\n  inner_sum_func_list= 0;\n  ftfunc_list= &ftfunc_list_alloc;\n  order_list.empty();\n  /* Set limit and offset to default values */\n  select_limit= 0;      /* denotes the default limit = HA_POS_ERROR */\n  offset_limit= 0;      /* denotes the default offset = 0 */\n  is_set_query_expr_tail= false;\n  with_sum_func= 0;\n  with_all_modifier= 0;\n  is_correlated= 0;\n  cur_pos_in_select_list= UNDEF_POS;\n  cond_value= having_value= Item::COND_UNDEF;\n  inner_refs_list.empty();\n  insert_tables= 0;\n  merged_into= 0;\n  m_non_agg_field_used= false;\n  m_agg_func_used= false;\n  m_custom_agg_func_used= false;\n  name_visibility_map.clear_all();\n  with_dep= 0;\n  join= 0;\n  lock_type= TL_READ_DEFAULT;\n  save_many_values.empty();\n  save_insert_list= 0;\n  tvc= 0;\n  in_funcs.empty();\n  curr_tvc_name= 0;\n  in_tvc= false;\n  versioned_tables= 0;\n}",
        "target": 0
    },
    {
        "func": "bool LEX::sp_block_finalize(THD *thd, const Lex_spblock_st spblock,\n                                      class sp_label **splabel)\n{\n  sp_head *sp= sphead;\n  sp_pcontext *ctx= spcont;\n  sp_instr *i;\n\n  sp->backpatch(ctx->last_label()); /* We always have a label */\n  if (spblock.hndlrs)\n  {\n    i= new (thd->mem_root)\n      sp_instr_hpop(sp->instructions(), ctx, spblock.hndlrs);\n    if (unlikely(i == NULL) ||\n        unlikely(sp->add_instr(i)))\n      return true;\n  }\n  if (spblock.curs)\n  {\n    i= new (thd->mem_root)\n      sp_instr_cpop(sp->instructions(), ctx, spblock.curs);\n    if (unlikely(i == NULL) ||\n        unlikely(sp->add_instr(i)))\n      return true;\n  }\n  spcont= ctx->pop_context();\n  *splabel= spcont->pop_label();\n  return false;\n}",
        "target": 0
    },
    {
        "func": "  bool is_quoted() const { return m_quote != '\\0'; }",
        "target": 0
    },
    {
        "func": "  void cancel_delete_all_rows()\n  {\n    deleting_all_rows= false;\n  }",
        "target": 0
    },
    {
        "func": "inline bool all_tables_not_ok(THD *thd, TABLE_LIST *tables)\n{\n  Rpl_filter *rpl_filter= thd->system_thread_info.rpl_sql_info->rpl_filter;\n  return rpl_filter->is_on() && tables && !thd->spcont &&\n         !rpl_filter->tables_ok(thd->db.str, tables);\n}",
        "target": 0
    },
    {
        "func": "  bool sp_for_loop_declarations(THD *thd, Lex_for_loop_st *loop,\n                                const LEX_CSTRING *index,\n                                const Lex_for_loop_bounds_st &bounds)\n  {\n    return bounds.is_for_loop_cursor() ?\n           sp_for_loop_cursor_declarations(thd, loop, index, bounds) :\n           sp_for_loop_intrange_declarations(thd, loop, index, bounds);\n  }",
        "target": 0
    },
    {
        "func": "bool LEX::sp_goto_statement(THD *thd, const LEX_CSTRING *label_name)\n{\n  sp_label *lab= spcont->find_goto_label(label_name);\n  if (!lab || lab->ip == 0)\n  {\n    sp_label *delayedlabel;\n    if (!lab)\n    {\n      // Label not found --> add forward jump to an unknown label\n      spcont->push_goto_label(thd, label_name, 0, sp_label::GOTO);\n      delayedlabel= spcont->last_goto_label();\n    }\n    else\n    {\n      delayedlabel= lab;\n    }\n    return sphead->push_backpatch_goto(thd, spcont, delayedlabel);\n  }\n  else\n  {\n    // Label found (backward goto)\n    return sp_change_context(thd, lab->ctx, false) ||\n           sphead->add_instr_jump(thd, spcont, lab->ip); /* Jump back */\n  }\n  return false;\n}",
        "target": 0
    },
    {
        "func": "  bool handle_list_of_derived(TABLE_LIST *table_list, uint phases)\n  {\n    for (TABLE_LIST *tl= table_list; tl; tl= tl->next_local)\n    {\n      if (tl->is_view_or_derived() && tl->handle_derived(this, phases))\n        return true;\n    }\n    return false;\n  }",
        "target": 0
    },
    {
        "func": "bool create_table_precheck(THD *thd, TABLE_LIST *tables,\n                           TABLE_LIST *create_table)\n{\n  LEX *lex= thd->lex;\n  SELECT_LEX *select_lex= lex->first_select_lex();\n  ulong want_priv;\n  bool error= TRUE;                                 // Error message is given\n  DBUG_ENTER(\"create_table_precheck\");\n\n  /*\n    Require CREATE [TEMPORARY] privilege on new table; for\n    CREATE TABLE ... SELECT, also require INSERT.\n  */\n\n  want_priv= lex->tmp_table() ?  CREATE_TMP_ACL :\n             (CREATE_ACL | (select_lex->item_list.elements ? INSERT_ACL : 0));\n\n  /* CREATE OR REPLACE on not temporary tables require DROP_ACL */\n  if (lex->create_info.or_replace() && !lex->tmp_table())\n    want_priv|= DROP_ACL;\n                          \n  if (check_access(thd, want_priv, create_table->db.str,\n                   &create_table->grant.privilege,\n                   &create_table->grant.m_internal,\n                   0, 0))\n    goto err;\n\n  /* If it is a merge table, check privileges for merge children. */\n  if (lex->create_info.merge_list)\n  {\n    /*\n      The user must have (SELECT_ACL | UPDATE_ACL | DELETE_ACL) on the\n      underlying base tables, even if there are temporary tables with the same\n      names.\n\n      From user's point of view, it might look as if the user must have these\n      privileges on temporary tables to create a merge table over them. This is\n      one of two cases when a set of privileges is required for operations on\n      temporary tables (see also CREATE TABLE).\n\n      The reason for this behavior stems from the following facts:\n\n        - For merge tables, the underlying table privileges are checked only\n          at CREATE TABLE / ALTER TABLE time.\n\n          In other words, once a merge table is created, the privileges of\n          the underlying tables can be revoked, but the user will still have\n          access to the merge table (provided that the user has privileges on\n          the merge table itself). \n\n        - Temporary tables shadow base tables.\n\n          I.e. there might be temporary and base tables with the same name, and\n          the temporary table takes the precedence in all operations.\n\n        - For temporary MERGE tables we do not track if their child tables are\n          base or temporary. As result we can't guarantee that privilege check\n          which was done in presence of temporary child will stay relevant\n          later as this temporary table might be removed.\n\n      If SELECT_ACL | UPDATE_ACL | DELETE_ACL privileges were not checked for\n      the underlying *base* tables, it would create a security breach as in\n      Bug#12771903.\n    */\n\n    if (check_table_access(thd, SELECT_ACL | UPDATE_ACL | DELETE_ACL,\n                           lex->create_info.merge_list, FALSE, UINT_MAX, FALSE))\n      goto err;\n  }\n\n  if (want_priv != CREATE_TMP_ACL &&\n      check_grant(thd, want_priv, create_table, FALSE, 1, FALSE))\n    goto err;\n\n  if (select_lex->item_list.elements)\n  {\n    /* Check permissions for used tables in CREATE TABLE ... SELECT */\n    if (tables && check_table_access(thd, SELECT_ACL, tables, FALSE,\n                                     UINT_MAX, FALSE))\n      goto err;\n  }\n  else if (lex->create_info.like())\n  {\n    if (check_table_access(thd, SELECT_ACL, tables, FALSE, UINT_MAX, FALSE))\n      goto err;\n  }\n\n  if (check_fk_parent_table_access(thd, &lex->create_info, &lex->alter_info,\n                                   create_table->db.str))\n    goto err;\n\n  error= FALSE;\n\nerr:\n  DBUG_RETURN(error);\n}",
        "target": 0
    },
    {
        "func": "  Lex_ident_sys()\n  {\n    ((LEX_CSTRING &) *this)= null_clex_str;\n  }",
        "target": 0
    },
    {
        "func": "  static void *operator new(size_t size, MEM_ROOT *mem_root) throw ()\n  { return (void*) alloc_root(mem_root, (uint) size); }",
        "target": 0
    },
    {
        "func": "bool LEX::add_create_view(THD *thd, DDL_options_st ddl,\n                          uint16 algorithm, enum_view_suid suid,\n                          Table_ident *table_ident)\n{\n  if (unlikely(set_create_options_with_check(ddl)))\n    return true;\n  if (unlikely(!(create_view= new (thd->mem_root)\n                 Create_view_info(ddl.or_replace() ?\n                                  VIEW_CREATE_OR_REPLACE :\n                                  VIEW_CREATE_NEW,\n                                  algorithm, suid))))\n    return true;\n  return create_or_alter_view_finalize(thd, table_ident);\n}",
        "target": 0
    },
    {
        "func": "Item *LEX::make_item_colon_ident_ident(THD *thd,\n                                       const Lex_ident_cli_st *ca,\n                                       const Lex_ident_cli_st *cb)\n{\n  Lex_ident_sys a(thd, ca), b(thd, cb);\n  if (a.is_null() || b.is_null())\n    return NULL; // OEM\n  if (!is_trigger_new_or_old_reference(&a))\n  {\n    thd->parse_error();\n    return NULL;\n  }\n  bool new_row= (a.str[0] == 'N' || a.str[0] == 'n');\n  return create_and_link_Item_trigger_field(thd, &b, new_row);\n}",
        "target": 0
    },
    {
        "func": "void LEX::sp_pop_loop_empty_label(THD *thd)\n{\n  sp_label *lab= spcont->pop_label();\n  sphead->backpatch(lab);\n  DBUG_ASSERT(lab->name.length == 0);\n}",
        "target": 0
    },
    {
        "func": "  void set_item_and_free_list(Item *item, Item *free_list)\n  {\n    m_item= item;\n    m_free_list= free_list;\n  }",
        "target": 0
    },
    {
        "func": "static char *fgets_fn(char *buffer, size_t size, fgets_input_t input, int *error)\n{\n  MYSQL_FILE *in= static_cast<MYSQL_FILE*> (input);\n  char *line= mysql_file_fgets(buffer, (int)size, in);\n  if (unlikely(error))\n    *error= (line == NULL) ? ferror(in->m_file) : 0;\n  return line;\n}",
        "target": 0
    },
    {
        "func": "static my_bool kill_threads_callback(THD *thd, kill_threads_callback_arg *arg)\n{\n  if (thd->security_ctx->user)\n  {\n    /*\n      Check that hostname (if given) and user name matches.\n\n      host.str[0] == '%' means that host name was not given. See sql_yacc.yy\n    */\n    if (((arg->user->host.str[0] == '%' && !arg->user->host.str[1]) ||\n         !strcmp(thd->security_ctx->host_or_ip, arg->user->host.str)) &&\n        !strcmp(thd->security_ctx->user, arg->user->user.str))\n    {\n      if (!(arg->thd->security_ctx->master_access & SUPER_ACL) &&\n          !arg->thd->security_ctx->user_matches(thd->security_ctx))\n        return 1;\n      if (!arg->threads_to_kill.push_back(thd, arg->thd->mem_root))\n      {\n        mysql_mutex_lock(&thd->LOCK_thd_kill); // Lock from delete\n        mysql_mutex_lock(&thd->LOCK_thd_data);\n      }\n    }\n  }\n  return 0;\n}",
        "target": 0
    },
    {
        "func": "  const char *get_cpp_tok_end_rtrim()\n  {\n    const char *p;\n    for (p= m_cpp_tok_end;\n         p > m_cpp_buf && my_isspace(system_charset_info, p[-1]);\n         p--)\n    { }\n    return p;\n  }",
        "target": 0
    },
    {
        "func": "  uint param_count() const\n  {\n    return m_params.elements;\n  }",
        "target": 0
    },
    {
        "func": "bool LEX::stmt_uninstall_plugin_by_name(const DDL_options_st &opt,\n                                        const Lex_ident_sys_st &name)\n{\n  check_opt.init();\n  if (add_create_options_with_check(opt))\n    return true;\n  sql_command= SQLCOM_UNINSTALL_PLUGIN;\n  comment= name;\n  ident= null_clex_str;\n  return false;\n}",
        "target": 0
    },
    {
        "func": "bool LEX::sp_for_loop_increment(THD *thd, const Lex_for_loop_st &loop)\n{\n  Item_splocal *splocal= new (thd->mem_root)\n    Item_splocal(thd, &sp_rcontext_handler_local,\n                      &loop.m_index->name, loop.m_index->offset,\n                      loop.m_index->type_handler());\n  if (unlikely(splocal == NULL))\n    return true;\n#ifdef DBUG_ASSERT_EXISTS\n  splocal->m_sp= sphead;\n#endif\n  Item_int *inc= new (thd->mem_root) Item_int(thd, loop.m_direction);\n  if (unlikely(!inc))\n    return true;\n  Item *expr= new (thd->mem_root) Item_func_plus(thd, splocal, inc);\n  if (unlikely(!expr) ||\n      unlikely(sphead->set_local_variable(thd, spcont,\n                                          &sp_rcontext_handler_local,\n                                          loop.m_index, expr, this, true)))\n    return true;\n  return false;\n}",
        "target": 0
    },
    {
        "func": "  bool is_8bit() const { return m_is_8bit; }",
        "target": 0
    },
    {
        "func": "bool multi_update_precheck(THD *thd, TABLE_LIST *tables)\n{\n  TABLE_LIST *table;\n  LEX *lex= thd->lex;\n  SELECT_LEX *select_lex= lex->first_select_lex();\n  DBUG_ENTER(\"multi_update_precheck\");\n\n  if (select_lex->item_list.elements != lex->value_list.elements)\n  {\n    my_message(ER_WRONG_VALUE_COUNT, ER_THD(thd, ER_WRONG_VALUE_COUNT), MYF(0));\n    DBUG_RETURN(TRUE);\n  }\n  /*\n    Ensure that we have UPDATE or SELECT privilege for each table\n    The exact privilege is checked in mysql_multi_update()\n  */\n  for (table= tables; table; table= table->next_local)\n  {\n    if (table->is_jtbm())\n      continue;\n    if (table->derived)\n      table->grant.privilege= SELECT_ACL;\n    else if ((check_access(thd, UPDATE_ACL, table->db.str,\n                           &table->grant.privilege,\n                           &table->grant.m_internal,\n                           0, 1) ||\n              check_grant(thd, UPDATE_ACL, table, FALSE, 1, TRUE)) &&\n             (check_access(thd, SELECT_ACL, table->db.str,\n                           &table->grant.privilege,\n                           &table->grant.m_internal,\n                           0, 0) ||\n              check_grant(thd, SELECT_ACL, table, FALSE, 1, FALSE)))\n      DBUG_RETURN(TRUE);\n\n    table->grant.orig_want_privilege= 0;\n    table->table_in_first_from_clause= 1;\n  }\n  /*\n    Is there tables of subqueries?\n  */\n  if (lex->first_select_lex() != lex->all_selects_list)\n  {\n    DBUG_PRINT(\"info\",(\"Checking sub query list\"));\n    for (table= tables; table; table= table->next_global)\n    {\n      if (!table->table_in_first_from_clause)\n      {\n\tif (check_access(thd, SELECT_ACL, table->db.str,\n                         &table->grant.privilege,\n                         &table->grant.m_internal,\n                         0, 0) ||\n\t    check_grant(thd, SELECT_ACL, table, FALSE, 1, FALSE))\n\t  DBUG_RETURN(TRUE);\n      }\n    }\n  }\n\n  DBUG_RETURN(FALSE);\n}",
        "target": 0
    },
    {
        "func": "void create_table_set_open_action_and_adjust_tables(LEX *lex)\n{\n  TABLE_LIST *create_table= lex->query_tables;\n\n  if (lex->tmp_table())\n    create_table->open_type= OT_TEMPORARY_ONLY;\n  else\n    create_table->open_type= OT_BASE_ONLY;\n\n  if (!lex->first_select_lex()->item_list.elements)\n  {\n    /*\n      Avoid opening and locking target table for ordinary CREATE TABLE\n      or CREATE TABLE LIKE for write (unlike in CREATE ... SELECT we\n      won't do any insertions in it anyway). Not doing this causes\n      problems when running CREATE TABLE IF NOT EXISTS for already\n      existing log table.\n    */\n    create_table->lock_type= TL_READ;\n  }\n}",
        "target": 0
    },
    {
        "func": "void THD::reset_for_next_command(bool do_clear_error)\n{\n  DBUG_ENTER(\"THD::reset_for_next_command\");\n  DBUG_ASSERT(!spcont); /* not for substatements of routines */\n  DBUG_ASSERT(!in_sub_stmt);\n\n  if (likely(do_clear_error))\n  {\n    clear_error(1);\n    /*\n      The following variable can't be reset in clear_error() as\n      clear_error() is called during auto_repair of table\n    */\n    error_printed_to_log= 0;\n  }\n  free_list= 0;\n  /*\n    We also assign stmt_lex in lex_start(), but during bootstrap this\n    code is executed first.\n  */\n  DBUG_ASSERT(lex == &main_lex);\n  main_lex.stmt_lex= &main_lex; main_lex.current_select_number= 0;\n  /*\n    Those two lines below are theoretically unneeded as\n    THD::cleanup_after_query() should take care of this already.\n  */\n  auto_inc_intervals_in_cur_stmt_for_binlog.empty();\n  stmt_depends_on_first_successful_insert_id_in_prev_stmt= 0;\n\n#ifdef WITH_WSREP\n  /*\n    Autoinc variables should be adjusted only for locally executed\n    transactions. Appliers and replayers are either processing ROW\n    events or get autoinc variable values from Query_log_event and\n    mysql slave may be processing STATEMENT format events, but he should\n    use autoinc values passed in binlog events, not the values forced by\n    the cluster.\n  */\n  if (WSREP_NNULL(this) && wsrep_thd_is_local(this) &&\n      !slave_thread && wsrep_auto_increment_control)\n  {\n    variables.auto_increment_offset=\n      global_system_variables.auto_increment_offset;\n    variables.auto_increment_increment=\n      global_system_variables.auto_increment_increment;\n  }\n#endif /* WITH_WSREP */\n  query_start_sec_part_used= 0;\n  is_fatal_error= time_zone_used= 0;\n  log_current_statement= 0;\n\n  /*\n    Clear the status flag that are expected to be cleared at the\n    beginning of each SQL statement.\n  */\n  server_status&= ~SERVER_STATUS_CLEAR_SET;\n  /*\n    If in autocommit mode and not in a transaction, reset\n    OPTION_STATUS_NO_TRANS_UPDATE | OPTION_KEEP_LOG to not get warnings\n    in ha_rollback_trans() about some tables couldn't be rolled back.\n  */\n  if (!in_multi_stmt_transaction_mode())\n  {\n    variables.option_bits&= ~OPTION_KEEP_LOG;\n    transaction.all.reset();\n  }\n  DBUG_ASSERT(security_ctx== &main_security_ctx);\n  thread_specific_used= FALSE;\n\n  if (opt_bin_log)\n    reset_dynamic(&user_var_events);\n  DBUG_ASSERT(user_var_events_alloc == &main_mem_root);\n  enable_slow_log= true;\n  get_stmt_da()->reset_for_next_command();\n  rand_used= 0;\n  m_sent_row_count= m_examined_row_count= 0;\n  accessed_rows_and_keys= 0;\n\n  reset_slow_query_state();\n\n  reset_current_stmt_binlog_format_row();\n  binlog_unsafe_warning_flags= 0;\n\n  save_prep_leaf_list= false;\n\n#ifdef WITH_WSREP\n#if !defined(DBUG_OFF)\n  if (mysql_bin_log.is_open())\n#endif\n#endif\n    DBUG_PRINT(\"debug\",\n               (\"is_current_stmt_binlog_format_row(): %d\",\n                 is_current_stmt_binlog_format_row()));\n\n  DBUG_VOID_RETURN;\n}",
        "target": 0
    },
    {
        "func": "void st_select_lex::print_order(String *str,\n                                ORDER *order,\n                                enum_query_type query_type)\n{\n  for (; order; order= order->next)\n  {\n    if (order->counter_used)\n    {\n      char buffer[20];\n      size_t length= my_snprintf(buffer, 20, \"%d\", order->counter);\n      str->append(buffer, (uint) length);\n    }\n    else\n    {\n      /* replace numeric reference with equivalent for ORDER constant */\n      if (order->item[0]->is_order_clause_position())\n      {\n        /* make it expression instead of integer constant */\n        str->append(STRING_WITH_LEN(\"''\"));\n      }\n      else\n        (*order->item)->print(str, query_type);\n    }\n    if (order->direction == ORDER::ORDER_DESC)\n       str->append(STRING_WITH_LEN(\" desc\"));\n    if (order->next)\n      str->append(',');\n  }\n}",
        "target": 0
    },
    {
        "func": "  inline void set_stmt_row_injection() {\n    DBUG_ENTER(\"set_stmt_row_injection\");\n    binlog_stmt_flags|=\n      (1U << (BINLOG_STMT_UNSAFE_COUNT + BINLOG_STMT_TYPE_ROW_INJECTION));\n    DBUG_VOID_RETURN;\n  }",
        "target": 0
    },
    {
        "func": "  ~Parser_state()\n  {}",
        "target": 0
    },
    {
        "func": "bool LEX::sp_pop_loop_label(THD *thd, const LEX_CSTRING *label_name)\n{\n  sp_label *lab= spcont->pop_label();\n  sphead->backpatch(lab);\n  if (label_name->str &&\n      lex_string_cmp(system_charset_info, label_name,\n                     &lab->name) != 0)\n  {\n    my_error(ER_SP_LABEL_MISMATCH, MYF(0), label_name->str);\n    return true;\n  }\n  return false;\n}",
        "target": 0
    },
    {
        "func": "  select_unit *get_union_result() { return union_result; }",
        "target": 0
    },
    {
        "func": "static int mysql_create_routine(THD *thd, LEX *lex)\n{\n  DBUG_ASSERT(lex->sphead != 0);\n  DBUG_ASSERT(lex->sphead->m_db.str); /* Must be initialized in the parser */\n  /*\n    Verify that the database name is allowed, optionally\n    lowercase it.\n  */\n  if (check_db_name((LEX_STRING*) &lex->sphead->m_db))\n  {\n    my_error(ER_WRONG_DB_NAME, MYF(0), lex->sphead->m_db.str);\n    return true;\n  }\n\n  if (check_access(thd, CREATE_PROC_ACL, lex->sphead->m_db.str,\n                   NULL, NULL, 0, 0))\n    return true;\n\n  /* Checking the drop permissions if CREATE OR REPLACE is used */\n  if (lex->create_info.or_replace())\n  {\n    if (check_routine_access(thd, ALTER_PROC_ACL, &lex->sphead->m_db,\n                             &lex->sphead->m_name,\n                             Sp_handler::handler(lex->sql_command), 0))\n      return true;\n  }\n\n  const LEX_CSTRING *name= lex->sphead->name();\n#ifdef HAVE_DLOPEN\n  if (lex->sphead->m_handler->type() == TYPE_ENUM_FUNCTION)\n  {\n    udf_func *udf = find_udf(name->str, name->length);\n\n    if (udf)\n    {\n      my_error(ER_UDF_EXISTS, MYF(0), name->str);\n      return true;\n    }\n  }\n#endif\n\n  if (sp_process_definer(thd))\n    return true;\n\n  WSREP_TO_ISOLATION_BEGIN(WSREP_MYSQL_DB, NULL, NULL);\n  if (!lex->sphead->m_handler->sp_create_routine(thd, lex->sphead))\n  {\n#ifndef NO_EMBEDDED_ACCESS_CHECKS\n    /* only add privileges if really neccessary */\n\n    Security_context security_context;\n    bool restore_backup_context= false;\n    Security_context *backup= NULL;\n    LEX_USER *definer= thd->lex->definer;\n    /*\n      We're going to issue an implicit GRANT statement so we close all\n      open tables. We have to keep metadata locks as this ensures that\n      this statement is atomic against concurent FLUSH TABLES WITH READ\n      LOCK. Deadlocks which can arise due to fact that this implicit\n      statement takes metadata locks should be detected by a deadlock\n      detector in MDL subsystem and reported as errors.\n\n      No need to commit/rollback statement transaction, it's not started.\n\n      TODO: Long-term we should either ensure that implicit GRANT statement\n            is written into binary log as a separate statement or make both\n            creation of routine and implicit GRANT parts of one fully atomic\n            statement.\n      */\n    DBUG_ASSERT(thd->transaction.stmt.is_empty());\n    close_thread_tables(thd);\n    /*\n      Check if the definer exists on slave,\n      then use definer privilege to insert routine privileges to mysql.procs_priv.\n\n      For current user of SQL thread has GLOBAL_ACL privilege,\n      which doesn't any check routine privileges,\n      so no routine privilege record  will insert into mysql.procs_priv.\n    */\n    if (thd->slave_thread && is_acl_user(definer->host.str, definer->user.str))\n    {\n      security_context.change_security_context(thd,\n                                               &thd->lex->definer->user,\n                                               &thd->lex->definer->host,\n                                               &thd->lex->sphead->m_db,\n                                               &backup);\n      restore_backup_context= true;\n    }\n\n    if (sp_automatic_privileges && !opt_noacl &&\n        check_routine_access(thd, DEFAULT_CREATE_PROC_ACLS,\n                             &lex->sphead->m_db, name,\n                             Sp_handler::handler(lex->sql_command), 1))\n    {\n      if (sp_grant_privileges(thd, lex->sphead->m_db.str, name->str,\n                              Sp_handler::handler(lex->sql_command)))\n        push_warning(thd, Sql_condition::WARN_LEVEL_WARN,\n                     ER_PROC_AUTO_GRANT_FAIL, ER_THD(thd, ER_PROC_AUTO_GRANT_FAIL));\n      thd->clear_error();\n    }\n\n    /*\n      Restore current user with GLOBAL_ACL privilege of SQL thread\n    */\n    if (restore_backup_context)\n    {\n      DBUG_ASSERT(thd->slave_thread == 1);\n      thd->security_ctx->restore_security_context(thd, backup);\n    }\n\n#endif\n    return false;\n  }\n#ifdef WITH_WSREP\nwsrep_error_label:\n#endif\n  return true;\n}",
        "target": 0
    },
    {
        "func": "static bool check_rename_table(THD *thd, TABLE_LIST *first_table,\n                               TABLE_LIST *all_tables)\n{\n  DBUG_ASSERT(first_table == all_tables && first_table != 0);\n  TABLE_LIST *table;\n  for (table= first_table; table; table= table->next_local->next_local)\n  {\n    if (check_access(thd, ALTER_ACL | DROP_ACL, table->db.str,\n                     &table->grant.privilege,\n                     &table->grant.m_internal,\n                     0, 0) ||\n        check_access(thd, INSERT_ACL | CREATE_ACL, table->next_local->db.str,\n                     &table->next_local->grant.privilege,\n                     &table->next_local->grant.m_internal,\n                     0, 0))\n      return 1;\n\n    /* check if these are referring to temporary tables */\n    table->table= find_temporary_table_for_rename(thd, first_table, table);\n    table->next_local->table= table->table;\n\n    TABLE_LIST old_list, new_list;\n    /*\n      we do not need initialize old_list and new_list because we will\n      copy table[0] and table->next[0] there\n    */\n    old_list= table[0];\n    new_list= table->next_local[0];\n\n    if (check_grant(thd, ALTER_ACL | DROP_ACL, &old_list, FALSE, 1, FALSE) ||\n       (!test_all_bits(table->next_local->grant.privilege,\n                       INSERT_ACL | CREATE_ACL) &&\n        check_grant(thd, INSERT_ACL | CREATE_ACL, &new_list, FALSE, 1,\n                    FALSE)))\n      return 1;\n  }\n\n  return 0;\n}",
        "target": 0
    },
    {
        "func": "bool LEX::call_statement_start(THD *thd, const LEX_CSTRING *name)\n{\n  sp_name *spname= make_sp_name(thd, name);\n  return unlikely(!spname) || call_statement_start(thd, spname);\n}",
        "target": 0
    },
    {
        "func": "LEX::add_primary_to_query_expression_body(SELECT_LEX_UNIT *unit,\n                                          SELECT_LEX *sel,\n                                          enum sub_select_type unit_type,\n                                          bool distinct,\n                                          bool oracle)\n{\n  SELECT_LEX *sel2= sel;\n  if (sel->master_unit() && sel->master_unit()->first_select()->next_select())\n  {\n    sel2= wrap_unit_into_derived(sel->master_unit());\n    if (!sel2)\n      return NULL;\n  }\n  SELECT_LEX *sel1= unit->first_select();\n  if (!sel1->next_select())\n    unit= parsed_select_expr_start(sel1, sel2, unit_type, distinct);\n  else\n    unit= parsed_select_expr_cont(unit, sel2, unit_type, distinct, oracle);\n  return unit;\n}",
        "target": 0
    },
    {
        "func": "add_proc_to_list(THD* thd, Item *item)\n{\n  ORDER *order;\n  Item\t**item_ptr;\n\n  if (unlikely(!(order = (ORDER *) thd->alloc(sizeof(ORDER)+sizeof(Item*)))))\n    return 1;\n  item_ptr = (Item**) (order+1);\n  *item_ptr= item;\n  order->item=item_ptr;\n  thd->lex->proc_list.link_in_list(order, &order->next);\n  return 0;\n}",
        "target": 0
    },
    {
        "func": "uint maria_multi_check(THD *thd, char *packet, size_t packet_length)\n{\n  uint counter= 0;\n  DBUG_ENTER(\"maria_multi_check\");\n  while (packet_length)\n  {\n    char *packet_start= packet;\n    size_t subpacket_length= net_field_length((uchar **)&packet_start);\n    size_t length_length= packet_start - packet;\n    // length of command + 3 bytes where that length was stored\n    DBUG_PRINT(\"info\", (\"sub-packet length: %zu + %zu  command: %x\",\n                        subpacket_length, length_length,\n                        packet_start[3]));\n\n    if (subpacket_length == 0 ||\n        (subpacket_length + length_length) > packet_length)\n    {\n      my_message(ER_UNKNOWN_COM_ERROR, ER_THD(thd, ER_UNKNOWN_COM_ERROR),\n                 MYF(0));\n      DBUG_RETURN(0);\n    }\n\n    counter++;\n    packet= packet_start + subpacket_length;\n    packet_length-= (subpacket_length + length_length);\n  }\n  DBUG_RETURN(counter);\n}",
        "target": 0
    },
    {
        "func": "bool Lex_input_stream::init(THD *thd,\n                            char* buff,\n                            size_t length)\n{\n  DBUG_EXECUTE_IF(\"bug42064_simulate_oom\",\n                  DBUG_SET(\"+d,simulate_out_of_memory\"););\n\n  m_cpp_buf= (char*) thd->alloc(length + 1);\n\n  DBUG_EXECUTE_IF(\"bug42064_simulate_oom\",\n                  DBUG_SET(\"-d,bug42064_simulate_oom\");); \n\n  if (m_cpp_buf == NULL)\n    return true;\n\n  m_thd= thd;\n  reset(buff, length);\n\n  return false;\n}",
        "target": 0
    },
    {
        "func": "bool Lex_order_limit_lock::set_to(SELECT_LEX *sel)\n{\n  /*TODO: lock */\n  //if (lock.defined_lock && sel == sel->master_unit()->fake_select_lex)\n  //  return TRUE;\n  if (lock.defined_timeout)\n  {\n    THD *thd= sel->parent_lex->thd;\n     if (set_statement_var_if_exists(thd,\n                                     C_STRING_WITH_LEN(\"lock_wait_timeout\"),\n                                     lock.timeout) ||\n         set_statement_var_if_exists(thd,\n                                     C_STRING_WITH_LEN(\"innodb_lock_wait_timeout\"),\n                                     lock.timeout))\n       return TRUE;\n  }\n  lock.set_to(sel);\n  sel->explicit_limit= limit.explicit_limit;\n  sel->select_limit= limit.select_limit;\n  sel->offset_limit= limit.offset_limit;\n  if (order_list)\n  {\n    if (sel->get_linkage() != GLOBAL_OPTIONS_TYPE &&\n        sel->olap != UNSPECIFIED_OLAP_TYPE &&\n        (sel->get_linkage() != UNION_TYPE || sel->braces))\n    {\n      my_error(ER_WRONG_USAGE, MYF(0),\n          \"CUBE/ROLLUP\", \"ORDER BY\");\n      return TRUE;\n    }\n    sel->order_list= *(order_list);\n  }\n  sel->is_set_query_expr_tail= true;\n  return FALSE;\n}",
        "target": 0
    },
    {
        "func": "Item *LEX::create_item_qualified_asterisk(THD *thd,\n                                          const Lex_ident_sys_st *name)\n{\n  Item *item;\n  if (!(item= new (thd->mem_root) Item_field(thd, current_context(),\n                                             NullS, name->str,\n                                             &star_clex_str)))\n    return NULL;\n  current_select->with_wild++;\n  return item;\n}",
        "target": 0
    },
    {
        "func": "static inline uint int_token(const char *str,uint length)\n{\n  if (length < long_len)                        // quick normal case\n    return NUM;\n  bool neg=0;\n\n  if (*str == '+')                              // Remove sign and pre-zeros\n  {\n    str++; length--;\n  }\n  else if (*str == '-')\n  {\n    str++; length--;\n    neg=1;\n  }\n  while (*str == '0' && length)\n  {\n    str++; length --;\n  }\n  if (length < long_len)\n    return NUM;\n\n  uint smaller,bigger;\n  const char *cmp;\n  if (neg)\n  {\n    if (length == long_len)\n    {\n      cmp= signed_long_str + 1;\n      smaller= NUM;                                   // If <= signed_long_str\n      bigger= LONG_NUM;                               // If >= signed_long_str\n    }\n    else if (length < signed_longlong_len)\n      return LONG_NUM;\n    else if (length > signed_longlong_len)\n      return DECIMAL_NUM;\n    else\n    {\n      cmp= signed_longlong_str + 1;\n      smaller= LONG_NUM;                              // If <= signed_longlong_str\n      bigger=DECIMAL_NUM;\n    }\n  }\n  else\n  {\n    if (length == long_len)\n    {\n      cmp= long_str;\n      smaller=NUM;\n      bigger=LONG_NUM;\n    }\n    else if (length < longlong_len)\n      return LONG_NUM;\n    else if (length > longlong_len)\n    {\n      if (length > unsigned_longlong_len)\n        return DECIMAL_NUM;\n      cmp=unsigned_longlong_str;\n      smaller=ULONGLONG_NUM;\n      bigger=DECIMAL_NUM;\n    }\n    else\n    {\n      cmp=longlong_str;\n      smaller=LONG_NUM;\n      bigger= ULONGLONG_NUM;\n    }\n  }\n  while (*cmp && *cmp++ == *str++) ;\n  return ((uchar) str[-1] <= (uchar) cmp[-1]) ? smaller : bigger;\n}",
        "target": 0
    },
    {
        "func": "int Lex_input_stream::lex_token(YYSTYPE *yylval, THD *thd)\n{\n  int token;\n  const int left_paren= (int) '(';\n\n  if (lookahead_token >= 0)\n  {\n    /*\n      The next token was already parsed in advance,\n      return it.\n    */\n    token= lookahead_token;\n    lookahead_token= -1;\n    *yylval= *(lookahead_yylval);\n    lookahead_yylval= NULL;\n    return token;\n  }\n\n  token= lex_one_token(yylval, thd);\n  add_digest_token(token, yylval);\n\n  SELECT_LEX *curr_sel= thd->lex->current_select;\n\n  switch(token) {\n  case WITH:\n    /*\n      Parsing 'WITH' 'ROLLUP' or 'WITH' 'CUBE' requires 2 look ups,\n      which makes the grammar LALR(2).\n      Replace by a single 'WITH_ROLLUP' or 'WITH_CUBE' token,\n      to transform the grammar into a LALR(1) grammar,\n      which sql_yacc.yy can process.\n    */\n    token= lex_one_token(yylval, thd);\n    add_digest_token(token, yylval);\n    switch(token) {\n    case CUBE_SYM:\n      return WITH_CUBE_SYM;\n    case ROLLUP_SYM:\n      return WITH_ROLLUP_SYM;\n    case SYSTEM:\n      return WITH_SYSTEM_SYM;\n    default:\n      /*\n        Save the token following 'WITH'\n      */\n      lookahead_yylval= yylval;\n      lookahead_token= token;\n      return WITH;\n    }\n    break;\n  case FOR_SYM:\n    /*\n     * Additional look-ahead to resolve doubtful cases like:\n     * SELECT ... FOR UPDATE\n     * SELECT ... FOR SYSTEM_TIME ... .\n     */\n    token= lex_one_token(yylval, thd);\n    add_digest_token(token, yylval);\n    switch(token) {\n    case SYSTEM_TIME_SYM:\n      return FOR_SYSTEM_TIME_SYM;\n    default:\n      /*\n        Save the token following 'FOR_SYM'\n      */\n      lookahead_yylval= yylval;\n      lookahead_token= token;\n      return FOR_SYM;\n    }\n    break;\n  case VALUES:\n    if (curr_sel &&\n        (curr_sel->parsing_place == BEFORE_OPT_LIST ||\n         curr_sel->parsing_place == AFTER_LIST))\n    {\n      curr_sel->parsing_place= NO_MATTER;\n      break;\n    }\n    if (curr_sel &&\n        (curr_sel->parsing_place == IN_UPDATE_ON_DUP_KEY ||\n         curr_sel->parsing_place == IN_PART_FUNC))\n      return VALUE_SYM;\n    token= lex_one_token(yylval, thd);\n    add_digest_token(token, yylval);\n    switch(token) {\n    case LESS_SYM:\n      return VALUES_LESS_SYM;\n    case IN_SYM:\n      return VALUES_IN_SYM;\n    default:\n      lookahead_yylval= yylval;\n      lookahead_token= token;\n      return VALUES;\n    }\n  case VALUE_SYM:\n    if (curr_sel &&\n        (curr_sel->parsing_place == BEFORE_OPT_LIST ||\n         curr_sel->parsing_place == AFTER_LIST))\n    {\n      curr_sel->parsing_place= NO_MATTER;\n      return VALUES;\n    }\n    break;\n  case PARTITION_SYM:\n  case SELECT_SYM:\n  case UNION_SYM:\n    if (curr_sel &&\n        (curr_sel->parsing_place == BEFORE_OPT_LIST ||\n         curr_sel->parsing_place == AFTER_LIST))\n    {\n      curr_sel->parsing_place= NO_MATTER;\n    }\n    break;\n  case left_paren:\n    if (!curr_sel ||\n        curr_sel->parsing_place != BEFORE_OPT_LIST)\n      return token;\n    token= lex_one_token(yylval, thd);\n    add_digest_token(token, yylval);\n    lookahead_yylval= yylval;\n    yylval= NULL;\n    lookahead_token= token;\n    curr_sel->parsing_place= NO_MATTER;\n    if (token == LIKE)\n      return LEFT_PAREN_LIKE;\n    if (token == WITH)\n      return LEFT_PAREN_WITH;\n    if (token != left_paren && token != SELECT_SYM && token != VALUES)\n      return LEFT_PAREN_ALT;\n    else\n      return left_paren;\n    break;\n  default:\n    break;\n  }\n  return token;\n}",
        "target": 0
    },
    {
        "func": "  SELECT_LEX *first_select_lex() { return unit.first_select(); }",
        "target": 0
    },
    {
        "func": "bool is_lex_native_function(const LEX_CSTRING *name)\n{\n  DBUG_ASSERT(name != NULL);\n  return (get_hash_symbol(name->str, (uint) name->length, 1) != 0);\n}",
        "target": 0
    },
    {
        "func": "  void sp_block_init(THD *thd)\n  {\n    // Unlabeled blocks get an empty label\n    sp_block_init(thd, &empty_clex_str);\n  }",
        "target": 0
    },
    {
        "func": "  inline void add_where_field(st_select_lex *sel)\n  {\n    DBUG_ASSERT(this != sel);\n    select_n_where_fields+= sel->select_n_where_fields;\n  }",
        "target": 0
    },
    {
        "func": "  const char *get_cpp_ptr_rtrim()\n  {\n    const char *p;\n    for (p= m_cpp_ptr;\n         p > m_cpp_buf && my_isspace(system_charset_info, p[-1]);\n         p--)\n    { }\n    return p;\n  }",
        "target": 0
    },
    {
        "func": "  st_parsing_options() { reset(); }",
        "target": 0
    },
    {
        "func": "void create_select_for_variable(THD *thd, LEX_CSTRING *var_name)\n{\n  LEX *lex;\n  Item *var;\n  char buff[MAX_SYS_VAR_LENGTH*2+4+8], *end;\n  DBUG_ENTER(\"create_select_for_variable\");\n\n  lex= thd->lex;\n  mysql_init_select(lex);\n  lex->sql_command= SQLCOM_SELECT;\n  /*\n    We set the name of Item to @@session.var_name because that then is used\n    as the column name in the output.\n  */\n  if ((var= get_system_var(thd, OPT_SESSION, var_name, &null_clex_str)))\n  {\n    end= strxmov(buff, \"@@session.\", var_name->str, NullS);\n    var->set_name(thd, buff, (uint)(end-buff), system_charset_info);\n    add_item_to_list(thd, var);\n  }\n  DBUG_VOID_RETURN;\n}",
        "target": 0
    },
    {
        "func": "push_new_name_resolution_context(THD *thd,\n                                 TABLE_LIST *left_op, TABLE_LIST *right_op)\n{\n  Name_resolution_context *on_context;\n  if (!(on_context= new (thd->mem_root) Name_resolution_context))\n    return TRUE;\n  on_context->init();\n  on_context->first_name_resolution_table=\n    left_op->first_leaf_for_name_resolution();\n  on_context->last_name_resolution_table=\n    right_op->last_leaf_for_name_resolution();\n  LEX *lex= thd->lex;\n  on_context->select_lex = lex->current_select;\n  st_select_lex *outer_sel= lex->parser_current_outer_select();\n  on_context->outer_context = outer_sel ? &outer_sel->context : 0;\n  return lex->push_context(on_context);\n}",
        "target": 0
    },
    {
        "func": "SELECT_LEX *LEX::exclude_not_first_select(SELECT_LEX *exclude)\n{\n  DBUG_ENTER(\"LEX::exclude_not_first_select\");\n  DBUG_PRINT(\"enter\", (\"exclude %p #%u\", exclude, exclude->select_number));\n  SELECT_LEX_UNIT *unit= exclude->master_unit();\n  SELECT_LEX *sl;\n  DBUG_ASSERT(unit->first_select() != exclude);\n  /* we should go through the list to correctly set current_select */\n  for(sl= unit->first_select();\n      sl->next_select() && sl->next_select() != exclude;\n      sl= sl->next_select());\n  DBUG_PRINT(\"info\", (\"excl: %p  unit: %p  prev: %p\", exclude, unit, sl));\n  if (!sl)\n    DBUG_RETURN(NULL);\n  DBUG_ASSERT(&sl->next == exclude->prev);\n\n  exclude->prev= NULL;\n\n  current_select= sl;\n  DBUG_RETURN(exclude);\n}",
        "target": 0
    },
    {
        "func": "  const char *get_buf()\n  {\n    return m_buf;\n  }",
        "target": 0
    },
    {
        "func": "  inline void set_master_unit(st_select_lex_unit *master_unit)\n  {\n    master= (st_select_lex_node *)master_unit;\n  }",
        "target": 0
    },
    {
        "func": "SELECT_LEX *LEX::wrap_select_chain_into_derived(SELECT_LEX *sel)\n{\n  SELECT_LEX *dummy_select;\n  SELECT_LEX_UNIT *unit;\n  Table_ident *ti;\n  DBUG_ENTER(\"LEX::wrap_select_chain_into_derived\");\n\n  if (!(dummy_select= alloc_select(TRUE)))\n     DBUG_RETURN(NULL);\n  Name_resolution_context *context= &dummy_select->context;\n  dummy_select->automatic_brackets= FALSE;\n  sel->distinct= TRUE; // First select has not this attribute (safety)\n\n  if (!(unit= dummy_select->attach_selects_chain(sel, context)))\n    DBUG_RETURN(NULL);\n\n  /* stuff dummy SELECT * FROM (...) */\n\n  if (push_select(dummy_select)) // for Items & TABLE_LIST\n    DBUG_RETURN(NULL);\n\n  /* add SELECT list*/\n  {\n    Item *item= new (thd->mem_root)\n      Item_field(thd, context, NULL, NULL, &star_clex_str);\n    if (item == NULL)\n      goto err;\n    if (add_item_to_list(thd, item))\n      goto err;\n    (dummy_select->with_wild)++;\n  }\n\n  sel->set_linkage(DERIVED_TABLE_TYPE);\n\n  ti= new (thd->mem_root) Table_ident(unit);\n  if (ti == NULL)\n    goto err;\n  {\n    TABLE_LIST *table_list;\n    LEX_CSTRING alias;\n    if (dummy_select->make_unique_derived_name(thd, &alias))\n      goto err;\n\n    if (!(table_list= dummy_select->add_table_to_list(thd, ti, &alias,\n                                                      0, TL_READ,\n                                                      MDL_SHARED_READ)))\n      goto err;\n\n    context->resolve_in_table_list_only(table_list);\n    dummy_select->add_joined_table(table_list);\n  }\n\n  pop_select();\n\n  derived_tables|= DERIVED_SUBQUERY;\n\n  DBUG_RETURN(dummy_select);\n\nerr:\n  pop_select();\n  DBUG_RETURN(NULL);\n}",
        "target": 0
    },
    {
        "func": "  uint repertoire() const\n  {\n    return !m_is_8bit ? MY_REPERTOIRE_ASCII : MY_REPERTOIRE_UNICODE30;\n  }",
        "target": 0
    },
    {
        "func": "bool LEX::sp_variable_declarations_set_default(THD *thd, int nvars,\n                                               Item *dflt_value_item)\n{\n  bool has_default_clause= dflt_value_item != NULL;\n  if (!has_default_clause &&\n      unlikely(!(dflt_value_item= new (thd->mem_root) Item_null(thd))))\n    return true;\n\n  sp_variable *first_spvar = NULL;\n\n  for (uint i= 0 ; i < (uint) nvars ; i++)\n  {\n    sp_variable *spvar= spcont->get_last_context_variable((uint) nvars - 1 - i);\n\n    if (i == 0) {\n      first_spvar = spvar;\n    } else if (has_default_clause) {\n      Item_splocal *item =\n              new (thd->mem_root)\n                      Item_splocal(thd, &sp_rcontext_handler_local,\n                                   &first_spvar->name, first_spvar->offset,\n                                   first_spvar->type_handler(), 0, 0);\n      if (item == NULL)\n        return true; // OOM\n#ifndef DBUG_OFF\n      item->m_sp = sphead;\n#endif\n      dflt_value_item = item;\n    }\n\n    bool last= i + 1 == (uint) nvars;\n    spvar->default_value= dflt_value_item;\n    /* The last instruction is responsible for freeing LEX. */\n    sp_instr_set *is= new (this->thd->mem_root)\n                      sp_instr_set(sphead->instructions(),\n                                   spcont, &sp_rcontext_handler_local,\n                                   spvar->offset, dflt_value_item,\n                                   this, last);\n    if (unlikely(is == NULL || sphead->add_instr(is)))\n      return true;\n  }\n  return false;\n}",
        "target": 0
    },
    {
        "func": "bool check_some_routine_access(THD *thd, const char *db, const char *name,\n                               const Sp_handler *sph)\n{\n  ulong save_priv;\n  /*\n    The following test is just a shortcut for check_access() (to avoid\n    calculating db_access)\n    Note that this effectively bypasses the ACL_internal_schema_access checks\n    that are implemented for the INFORMATION_SCHEMA and PERFORMANCE_SCHEMA,\n    which are located in check_access().\n    Since the I_S and P_S do not contain routines, this bypass is ok,\n    as it only opens SHOW_PROC_ACLS.\n  */\n  if (thd->security_ctx->master_access & SHOW_PROC_ACLS)\n    return FALSE;\n  if (!check_access(thd, SHOW_PROC_ACLS, db, &save_priv, NULL, 0, 1) ||\n      (save_priv & SHOW_PROC_ACLS))\n    return FALSE;\n  return check_routine_level_acl(thd, db, name, sph);\n}",
        "target": 0
    },
    {
        "func": "Name_resolution_context *LEX::pop_context()\n{\n  DBUG_ENTER(\"LEX::pop_context\");\n  Name_resolution_context *context= context_stack.pop();\n  DBUG_PRINT(\"info\", (\"Context: %p Select: %p (%d)\",\n                       context, context->select_lex,\n                       (context->select_lex ?\n                        context->select_lex->select_number:\n                        0)));\n  DBUG_RETURN(context);\n}",
        "target": 0
    },
    {
        "func": "static bool param_push_or_clone(THD *thd, LEX *lex, Item_param *item)\n{\n  return !lex->clone_spec_offset ?\n         lex->param_list.push_back(item, thd->mem_root) :\n         item->add_as_clone(thd);\n}",
        "target": 0
    },
    {
        "func": "  st_select_lex_unit* first_inner_unit() \n  { \n    return (st_select_lex_unit*) slave; \n  }",
        "target": 0
    },
    {
        "func": "bool LEX::part_values_history(THD *thd)\n{\n  partition_element *elem= part_info->curr_part_elem;\n  if (!is_partition_management())\n  {\n    if (unlikely(part_info->part_type != VERSIONING_PARTITION))\n    {\n      my_error(ER_PARTITION_WRONG_TYPE, MYF(0), \"SYSTEM_TIME\");\n      return true;\n    }\n  }\n  else\n  {\n    part_info->vers_init_info(thd);\n    elem->id= UINT_MAX32;\n  }\n  DBUG_ASSERT(part_info->vers_info);\n  if (unlikely(part_info->vers_info->now_part))\n  {\n    DBUG_ASSERT(create_last_non_select_table);\n    DBUG_ASSERT(create_last_non_select_table->table_name.str);\n    my_error(ER_VERS_WRONG_PARTS, MYF(0),\n             create_last_non_select_table->table_name.str);\n    return true;\n  }\n  elem->type= partition_element::HISTORY;\n  return false;\n}",
        "target": 0
    },
    {
        "func": "bool append_file_to_dir(THD *thd, const char **filename_ptr,\n                        const LEX_CSTRING *table_name)\n{\n  char buff[FN_REFLEN],*ptr, *end;\n  if (!*filename_ptr)\n    return 0;\t\t\t\t\t// nothing to do\n\n  /* Check that the filename is not too long and it's a hard path */\n  if (strlen(*filename_ptr)+table_name->length >= FN_REFLEN-1 ||\n      !test_if_hard_path(*filename_ptr))\n  {\n    my_error(ER_WRONG_TABLE_NAME, MYF(0), *filename_ptr);\n    return 1;\n  }\n  /* Fix is using unix filename format on dos */\n  strmov(buff,*filename_ptr);\n  end=convert_dirname(buff, *filename_ptr, NullS);\n  if (unlikely(!(ptr= (char*) thd->alloc((size_t) (end-buff) +\n                                         table_name->length + 1))))\n    return 1;\t\t\t\t\t// End of memory\n  *filename_ptr=ptr;\n  strxmov(ptr,buff,table_name->str,NullS);\n  return 0;\n}",
        "target": 0
    },
    {
        "func": "LEX::wrap_unit_into_derived(SELECT_LEX_UNIT *unit)\n{\n  SELECT_LEX *wrapping_sel;\n  Table_ident *ti;\n  DBUG_ENTER(\"LEX::wrap_unit_into_derived\");\n\n  if (!(wrapping_sel= alloc_select(TRUE)))\n    DBUG_RETURN(NULL);\n  Name_resolution_context *context= &wrapping_sel->context;\n  context->init();\n  wrapping_sel->automatic_brackets= FALSE;\n\n  wrapping_sel->register_unit(unit, context);\n\n  /* stuff dummy SELECT * FROM (...) */\n\n  if (push_select(wrapping_sel)) // for Items & TABLE_LIST\n    DBUG_RETURN(NULL);\n\n  /* add SELECT list*/\n  {\n    Item *item= new (thd->mem_root)\n      Item_field(thd, context, NULL, NULL, &star_clex_str);\n    if (item == NULL)\n      goto err;\n    if (add_item_to_list(thd, item))\n      goto err;\n    (wrapping_sel->with_wild)++;\n  }\n\n  unit->first_select()->set_linkage(DERIVED_TABLE_TYPE);\n\n  ti= new (thd->mem_root) Table_ident(unit);\n  if (ti == NULL)\n    goto err;\n  {\n    TABLE_LIST *table_list;\n    LEX_CSTRING alias;\n    if (wrapping_sel->make_unique_derived_name(thd, &alias))\n      goto err;\n\n    if (!(table_list= wrapping_sel->add_table_to_list(thd, ti, &alias,\n                                                      0, TL_READ,\n                                                      MDL_SHARED_READ)))\n      goto err;\n\n    context->resolve_in_table_list_only(table_list);\n    wrapping_sel->add_joined_table(table_list);\n  }\n\n  pop_select();\n\n  derived_tables|= DERIVED_SUBQUERY;\n\n  DBUG_RETURN(wrapping_sel);\n\nerr:\n  pop_select();\n  DBUG_RETURN(NULL);\n}",
        "target": 0
    },
    {
        "func": "bool LEX::call_statement_start(THD *thd, sp_name *name)\n{\n  Database_qualified_name pkgname(&null_clex_str, &null_clex_str);\n  const Sp_handler *sph= &sp_handler_procedure;\n  sql_command= SQLCOM_CALL;\n  value_list.empty();\n  if (unlikely(sph->sp_resolve_package_routine(thd, thd->lex->sphead,\n                                               name, &sph, &pkgname)))\n    return true;\n  if (unlikely(!(m_sql_cmd= new (thd->mem_root) Sql_cmd_call(name, sph))))\n    return true;\n  sph->add_used_routine(this, thd, name);\n  if (pkgname.m_name.length)\n    sp_handler_package_body.add_used_routine(this, thd, &pkgname);\n  return false;\n}",
        "target": 0
    },
    {
        "func": "  void lex_start()\n  {\n    m_params.empty();\n  }",
        "target": 0
    },
    {
        "func": "  const char *get_body_utf8_str()\n  {\n    return m_body_utf8;\n  }",
        "target": 0
    },
    {
        "func": "my_var *LEX::create_outvar(THD *thd, const LEX_CSTRING *name)\n{\n  const Sp_rcontext_handler *rh;\n  sp_variable *spv;\n  if (likely((spv= find_variable(name, &rh))))\n    return result ? new (thd->mem_root)\n                    my_var_sp(rh, name, spv->offset,\n                              spv->type_handler(), sphead) :\n                    NULL /* EXPLAIN */;\n  my_error(ER_SP_UNDECLARED_VAR, MYF(0), name->str);\n  return NULL;\n}",
        "target": 0
    },
    {
        "func": "bool LEX::parsed_insert_select(SELECT_LEX *first_select)\n{\n  if (sql_command == SQLCOM_INSERT ||\n      sql_command == SQLCOM_REPLACE)\n  {\n    if (sql_command == SQLCOM_INSERT)\n      sql_command= SQLCOM_INSERT_SELECT;\n    else\n      sql_command= SQLCOM_REPLACE_SELECT;\n  }\n  insert_select_hack(first_select);\n  if (check_main_unit_semantics())\n    return true;\n\n  // fix \"main\" select\n  SELECT_LEX *blt __attribute__((unused))= pop_select();\n  DBUG_ASSERT(blt == &builtin_select);\n  push_select(first_select);\n  return false;\n}",
        "target": 0
    },
    {
        "func": "Item *LEX::create_item_func_nextval(THD *thd,\n                                    const LEX_CSTRING *db,\n                                    const LEX_CSTRING *name)\n{\n  Table_ident *table_ident;\n  if (unlikely(!(table_ident=\n                 new (thd->mem_root) Table_ident(thd, db, name, false))))\n    return NULL;\n  return create_item_func_nextval(thd, table_ident);\n}",
        "target": 0
    },
    {
        "func": "static bool is_new(const char *str)\n{\n  return (str[0] == 'n' || str[0] == 'N') &&\n         (str[1] == 'e' || str[1] == 'E') &&\n         (str[2] == 'w' || str[2] == 'W');\n}",
        "target": 0
    },
    {
        "func": "mysql_execute_command(THD *thd)\n{\n  int res= 0;\n  int  up_result= 0;\n  LEX  *lex= thd->lex;\n  /* first SELECT_LEX (have special meaning for many of non-SELECTcommands) */\n  SELECT_LEX *select_lex= lex->first_select_lex();\n  /* first table of first SELECT_LEX */\n  TABLE_LIST *first_table= select_lex->table_list.first;\n  /* list of all tables in query */\n  TABLE_LIST *all_tables;\n  /* most outer SELECT_LEX_UNIT of query */\n  SELECT_LEX_UNIT *unit= &lex->unit;\n#ifdef HAVE_REPLICATION\n  /* have table map for update for multi-update statement (BUG#37051) */\n  bool have_table_map_for_update= FALSE;\n  /* */\n  Rpl_filter *rpl_filter;\n#endif\n  DBUG_ENTER(\"mysql_execute_command\");\n\n  // check that we correctly marked first table for data insertion\n  DBUG_ASSERT(!(sql_command_flags[lex->sql_command] & CF_INSERTS_DATA) ||\n              first_table->for_insert_data);\n\n  if (thd->security_ctx->password_expired &&\n      lex->sql_command != SQLCOM_SET_OPTION &&\n      lex->sql_command != SQLCOM_PREPARE &&\n      lex->sql_command != SQLCOM_EXECUTE &&\n      lex->sql_command != SQLCOM_DEALLOCATE_PREPARE)\n  {\n    my_error(ER_MUST_CHANGE_PASSWORD, MYF(0));\n    DBUG_RETURN(1);\n  }\n\n  DBUG_ASSERT(thd->transaction.stmt.is_empty() || thd->in_sub_stmt);\n  /*\n    Each statement or replication event which might produce deadlock\n    should handle transaction rollback on its own. So by the start of\n    the next statement transaction rollback request should be fulfilled\n    already.\n  */\n  DBUG_ASSERT(! thd->transaction_rollback_request || thd->in_sub_stmt);\n  /*\n    In many cases first table of main SELECT_LEX have special meaning =>\n    check that it is first table in global list and relink it first in \n    queries_tables list if it is necessary (we need such relinking only\n    for queries with subqueries in select list, in this case tables of\n    subqueries will go to global list first)\n\n    all_tables will differ from first_table only if most upper SELECT_LEX\n    do not contain tables.\n\n    Because of above in place where should be at least one table in most\n    outer SELECT_LEX we have following check:\n    DBUG_ASSERT(first_table == all_tables);\n    DBUG_ASSERT(first_table == all_tables && first_table != 0);\n  */\n  lex->first_lists_tables_same();\n  lex->fix_first_select_number();\n  /* should be assigned after making first tables same */\n  all_tables= lex->query_tables;\n  /* set context for commands which do not use setup_tables */\n  select_lex->\n    context.resolve_in_table_list_only(select_lex->\n                                       table_list.first);\n\n  /*\n    Remember last commmand executed, so that we can use it in functions called by\n    dispatch_command()\n  */\n  thd->last_sql_command= lex->sql_command;\n\n  /*\n    Reset warning count for each query that uses tables\n    A better approach would be to reset this for any commands\n    that is not a SHOW command or a select that only access local\n    variables, but for now this is probably good enough.\n  */\n  if ((sql_command_flags[lex->sql_command] & CF_DIAGNOSTIC_STMT) != 0)\n    thd->get_stmt_da()->set_warning_info_read_only(TRUE);\n  else\n  {\n    thd->get_stmt_da()->set_warning_info_read_only(FALSE);\n    if (all_tables)\n      thd->get_stmt_da()->opt_clear_warning_info(thd->query_id);\n  }\n\n#ifdef HAVE_REPLICATION\n  if (unlikely(thd->slave_thread))\n  {\n    if (lex->sql_command == SQLCOM_DROP_TRIGGER)\n    {\n      /*\n        When dropping a trigger, we need to load its table name\n        before checking slave filter rules.\n      */\n      add_table_for_trigger(thd, thd->lex->spname, 1, &all_tables);\n      \n      if (!all_tables)\n      {\n        /*\n          If table name cannot be loaded,\n          it means the trigger does not exists possibly because\n          CREATE TRIGGER was previously skipped for this trigger\n          according to slave filtering rules.\n          Returning success without producing any errors in this case.\n        */\n        if (!thd->lex->create_info.if_exists())\n          DBUG_RETURN(0);\n        /*\n          DROP TRIGGER IF NOT EXISTS will return without an error later\n          after possibly writing the query to a binlog\n        */\n      }\n      else // force searching in slave.cc:tables_ok()\n        all_tables->updating= 1;\n    }\n\n    /*\n      For fix of BUG#37051, the master stores the table map for update\n      in the Query_log_event, and the value is assigned to\n      thd->variables.table_map_for_update before executing the update\n      query.\n\n      If thd->variables.table_map_for_update is set, then we are\n      replicating from a new master, we can use this value to apply\n      filter rules without opening all the tables. However If\n      thd->variables.table_map_for_update is not set, then we are\n      replicating from an old master, so we just skip this and\n      continue with the old method. And of course, the bug would still\n      exist for old masters.\n    */\n    if (lex->sql_command == SQLCOM_UPDATE_MULTI &&\n        thd->table_map_for_update)\n    {\n      have_table_map_for_update= TRUE;\n      table_map table_map_for_update= thd->table_map_for_update;\n      uint nr= 0;\n      TABLE_LIST *table;\n      for (table=all_tables; table; table=table->next_global, nr++)\n      {\n        if (table_map_for_update & ((table_map)1 << nr))\n          table->updating= TRUE;\n        else\n          table->updating= FALSE;\n      }\n\n      if (all_tables_not_ok(thd, all_tables))\n      {\n        /* we warn the slave SQL thread */\n        my_message(ER_SLAVE_IGNORED_TABLE, ER_THD(thd, ER_SLAVE_IGNORED_TABLE),\n                   MYF(0));\n      }\n    }\n    \n    /*\n      Check if statment should be skipped because of slave filtering\n      rules\n\n      Exceptions are:\n      - UPDATE MULTI: For this statement, we want to check the filtering\n        rules later in the code\n      - SET: we always execute it (Not that many SET commands exists in\n        the binary log anyway -- only 4.1 masters write SET statements,\n\tin 5.0 there are no SET statements in the binary log)\n      - DROP TEMPORARY TABLE IF EXISTS: we always execute it (otherwise we\n        have stale files on slave caused by exclusion of one tmp table).\n    */\n    if (!(lex->sql_command == SQLCOM_UPDATE_MULTI) &&\n\t!(lex->sql_command == SQLCOM_SET_OPTION) &&\n\t!((lex->sql_command == SQLCOM_DROP_TABLE ||\n           lex->sql_command == SQLCOM_DROP_SEQUENCE) &&\n          lex->tmp_table() && lex->if_exists()) &&\n        all_tables_not_ok(thd, all_tables))\n    {\n      /* we warn the slave SQL thread */\n      my_message(ER_SLAVE_IGNORED_TABLE, ER_THD(thd, ER_SLAVE_IGNORED_TABLE),\n                 MYF(0));\n      DBUG_RETURN(0);\n    }\n    /* \n       Execute deferred events first\n    */\n    if (slave_execute_deferred_events(thd))\n      DBUG_RETURN(-1);\n  }\n  else\n  {\n#endif /* HAVE_REPLICATION */\n    /*\n      When option readonly is set deny operations which change non-temporary\n      tables. Except for the replication thread and the 'super' users.\n    */\n    if (deny_updates_if_read_only_option(thd, all_tables))\n    {\n      my_error(ER_OPTION_PREVENTS_STATEMENT, MYF(0), \"--read-only\");\n      DBUG_RETURN(-1);\n    }\n#ifdef HAVE_REPLICATION\n  } /* endif unlikely slave */\n#endif\n  Opt_trace_start ots(thd, all_tables, lex->sql_command, &lex->var_list,\n                      thd->query(), thd->query_length(),\n                      thd->variables.character_set_client);\n\n  Json_writer_object trace_command(thd);\n  Json_writer_array trace_command_steps(thd, \"steps\");\n\n  /* store old value of binlog format */\n  enum_binlog_format orig_binlog_format,orig_current_stmt_binlog_format;\n\n  thd->get_binlog_format(&orig_binlog_format,\n                         &orig_current_stmt_binlog_format);\n#ifdef WITH_WSREP\n  if (WSREP(thd))\n  {\n    /*\n      change LOCK TABLE WRITE to transaction\n    */\n    if (lex->sql_command== SQLCOM_LOCK_TABLES && wsrep_convert_LOCK_to_trx)\n    {\n      for (TABLE_LIST *table= all_tables; table; table= table->next_global)\n      {\n\tif (table->lock_type >= TL_WRITE_ALLOW_WRITE)\n        {\n\t  lex->sql_command= SQLCOM_BEGIN;\n\t  thd->wsrep_converted_lock_session= true;\n\t  break;\n\t}\n      }\n    }\n    if (lex->sql_command== SQLCOM_UNLOCK_TABLES &&\n\tthd->wsrep_converted_lock_session)\n    {\n      thd->wsrep_converted_lock_session= false;\n      lex->sql_command= SQLCOM_COMMIT;\n      lex->tx_release= TVL_NO;\n    }\n\n    /*\n     * Bail out if DB snapshot has not been installed. We however,\n     * allow SET and SHOW queries and reads from information schema\n     * and dirty reads (if configured)\n     */\n    if (!(thd->wsrep_applier) &&\n        !(wsrep_ready_get() && wsrep_reject_queries == WSREP_REJECT_NONE)  &&\n        !(thd->variables.wsrep_dirty_reads &&\n          (sql_command_flags[lex->sql_command] & CF_CHANGES_DATA) == 0)    &&\n        !wsrep_tables_accessible_when_detached(all_tables)                 &&\n        lex->sql_command != SQLCOM_SET_OPTION                              &&\n        !wsrep_is_show_query(lex->sql_command))\n    {\n      my_message(ER_UNKNOWN_COM_ERROR,\n                 \"WSREP has not yet prepared node for application use\", MYF(0));\n      goto error;\n    }\n  }\n#endif /* WITH_WSREP */\n  status_var_increment(thd->status_var.com_stat[lex->sql_command]);\n  thd->progress.report_to_client= MY_TEST(sql_command_flags[lex->sql_command] &\n                                          CF_REPORT_PROGRESS);\n\n  DBUG_ASSERT(thd->transaction.stmt.modified_non_trans_table == FALSE);\n\n  /*\n    Assign system variables with values specified by the clause\n    SET STATEMENT var1=value1 [, var2=value2, ...] FOR <statement>\n    if they are any.\n  */\n  if (run_set_statement_if_requested(thd, lex))\n    goto error;\n\n  if (thd->lex->mi.connection_name.str == NULL)\n      thd->lex->mi.connection_name= thd->variables.default_master_connection;\n\n  /*\n    Force statement logging for DDL commands to allow us to update\n    privilege, system or statistic tables directly without the updates\n    getting logged.\n  */\n  if (!(sql_command_flags[lex->sql_command] &\n        (CF_CAN_GENERATE_ROW_EVENTS | CF_FORCE_ORIGINAL_BINLOG_FORMAT |\n         CF_STATUS_COMMAND)))\n    thd->set_binlog_format_stmt();\n\n  /*\n    End a active transaction so that this command will have it's\n    own transaction and will also sync the binary log. If a DDL is\n    not run in it's own transaction it may simply never appear on\n    the slave in case the outside transaction rolls back.\n  */\n  if (stmt_causes_implicit_commit(thd, CF_IMPLICIT_COMMIT_BEGIN))\n  {\n    /*\n      Note that this should never happen inside of stored functions\n      or triggers as all such statements prohibited there.\n    */\n    DBUG_ASSERT(! thd->in_sub_stmt);\n    /* Statement transaction still should not be started. */\n    DBUG_ASSERT(thd->transaction.stmt.is_empty());\n    if (!(thd->variables.option_bits & OPTION_GTID_BEGIN))\n    {\n      /* Commit the normal transaction if one is active. */\n      bool commit_failed= trans_commit_implicit(thd);\n      /* Release metadata locks acquired in this transaction. */\n      thd->release_transactional_locks();\n      if (commit_failed)\n      {\n        WSREP_DEBUG(\"implicit commit failed, MDL released: %lld\",\n                    (longlong) thd->thread_id);\n        goto error;\n      }\n    }\n    thd->transaction.stmt.mark_trans_did_ddl();\n#ifdef WITH_WSREP\n    /* Clean up the previous transaction on implicit commit */\n    if (WSREP_NNULL(thd) && wsrep_thd_is_local(thd) &&\n        wsrep_after_statement(thd))\n    {\n      goto error;\n    }\n#endif /* WITH_WSREP */\n  }\n\n#ifndef DBUG_OFF\n  if (lex->sql_command != SQLCOM_SET_OPTION)\n    DEBUG_SYNC(thd,\"before_execute_sql_command\");\n#endif\n\n  /*\n    Check if we are in a read-only transaction and we're trying to\n    execute a statement which should always be disallowed in such cases.\n\n    Note that this check is done after any implicit commits.\n  */\n  if (thd->tx_read_only &&\n      (sql_command_flags[lex->sql_command] & CF_DISALLOW_IN_RO_TRANS))\n  {\n    my_error(ER_CANT_EXECUTE_IN_READ_ONLY_TRANSACTION, MYF(0));\n    goto error;\n  }\n\n  /*\n    Close tables open by HANDLERs before executing DDL statement\n    which is going to affect those tables.\n\n    This should happen before temporary tables are pre-opened as\n    otherwise we will get errors about attempt to re-open tables\n    if table to be changed is open through HANDLER.\n\n    Note that even although this is done before any privilege\n    checks there is no security problem here as closing open\n    HANDLER doesn't require any privileges anyway.\n  */\n  if (sql_command_flags[lex->sql_command] & CF_HA_CLOSE)\n    mysql_ha_rm_tables(thd, all_tables);\n\n  /*\n    Pre-open temporary tables to simplify privilege checking\n    for statements which need this.\n  */\n  if (sql_command_flags[lex->sql_command] & CF_PREOPEN_TMP_TABLES)\n  {\n    if (thd->open_temporary_tables(all_tables))\n      goto error;\n  }\n\n  if (sql_command_flags[lex->sql_command] & CF_STATUS_COMMAND)\n    thd->query_plan_flags|= QPLAN_STATUS;\n  if (sql_command_flags[lex->sql_command] & CF_ADMIN_COMMAND)\n    thd->query_plan_flags|= QPLAN_ADMIN;\n\n  /* Start timeouts */\n  thd->set_query_timer();\n\n#ifdef WITH_WSREP\n  /*\n    Always start a new transaction for a wsrep THD unless the\n    current command is DDL or explicit BEGIN. This will guarantee that\n    the THD is BF abortable even if it does not generate any\n    changes and takes only read locks. If the statement does not\n    start a multi STMT transaction, the wsrep_transaction is\n    committed as empty at the end of this function.\n\n    Transaction is started for BEGIN in trans_begin(), for DDL the\n    implicit commit took care of committing previous transaction\n    above and a new transaction should not be started.\n\n    Do not start transaction for stored procedures, it will be handled\n    internally in SP processing.\n  */\n  if (WSREP_NNULL(thd)                    &&\n      wsrep_thd_is_local(thd)             &&\n      lex->sql_command != SQLCOM_BEGIN    &&\n      lex->sql_command != SQLCOM_CALL     &&\n      lex->sql_command != SQLCOM_EXECUTE  &&\n      lex->sql_command != SQLCOM_EXECUTE_IMMEDIATE &&\n      !(sql_command_flags[lex->sql_command] & CF_AUTO_COMMIT_TRANS))\n  {\n    wsrep_start_trx_if_not_started(thd);\n  }\n#endif /* WITH_WSREP */\n\n  switch (lex->sql_command) {\n\n  case SQLCOM_SHOW_EVENTS:\n#ifndef HAVE_EVENT_SCHEDULER\n    my_error(ER_NOT_SUPPORTED_YET, MYF(0), \"embedded server\");\n    break;\n#endif\n  case SQLCOM_SHOW_STATUS:\n  {\n    WSREP_SYNC_WAIT(thd, WSREP_SYNC_WAIT_BEFORE_SHOW);\n    execute_show_status(thd, all_tables);\n\n    break;\n  }\n  case SQLCOM_SHOW_EXPLAIN:\n  {\n    if (!thd->security_ctx->priv_user[0] &&\n        check_global_access(thd,PROCESS_ACL))\n      break;\n\n    /*\n      The select should use only one table, it's the SHOW EXPLAIN pseudo-table\n    */\n    if (lex->sroutines.records || lex->query_tables->next_global)\n    {\n      my_message(ER_SET_CONSTANTS_ONLY, ER_THD(thd, ER_SET_CONSTANTS_ONLY),\n\t\t MYF(0));\n      goto error;\n    }\n\n    Item **it= lex->value_list.head_ref();\n    if (!(*it)->basic_const_item() ||\n        (*it)->fix_fields_if_needed_for_scalar(lex->thd, it))\n    {\n      my_message(ER_SET_CONSTANTS_ONLY, ER_THD(thd, ER_SET_CONSTANTS_ONLY),\n\t\t MYF(0));\n      goto error;\n    }\n  }\n    /* fall through */\n  case SQLCOM_SHOW_STATUS_PROC:\n  case SQLCOM_SHOW_STATUS_FUNC:\n  case SQLCOM_SHOW_STATUS_PACKAGE:\n  case SQLCOM_SHOW_STATUS_PACKAGE_BODY:\n  case SQLCOM_SHOW_DATABASES:\n  case SQLCOM_SHOW_TABLES:\n  case SQLCOM_SHOW_TRIGGERS:\n  case SQLCOM_SHOW_TABLE_STATUS:\n  case SQLCOM_SHOW_OPEN_TABLES:\n  case SQLCOM_SHOW_GENERIC:\n  case SQLCOM_SHOW_PLUGINS:\n  case SQLCOM_SHOW_FIELDS:\n  case SQLCOM_SHOW_KEYS:\n  case SQLCOM_SHOW_VARIABLES:\n  case SQLCOM_SHOW_CHARSETS:\n  case SQLCOM_SHOW_COLLATIONS:\n  case SQLCOM_SHOW_STORAGE_ENGINES:\n  case SQLCOM_SHOW_PROFILE:\n  case SQLCOM_SELECT:\n  {\n#ifdef WITH_WSREP\n    if (lex->sql_command == SQLCOM_SELECT)\n    {\n      WSREP_SYNC_WAIT(thd, WSREP_SYNC_WAIT_BEFORE_READ);\n    }\n    else\n    {\n      WSREP_SYNC_WAIT(thd, WSREP_SYNC_WAIT_BEFORE_SHOW);\n# ifdef ENABLED_PROFILING\n      if (lex->sql_command == SQLCOM_SHOW_PROFILE)\n        thd->profiling.discard_current_query();\n# endif\n    }\n#endif /* WITH_WSREP */\n\n    thd->status_var.last_query_cost= 0.0;\n\n    /*\n      lex->exchange != NULL implies SELECT .. INTO OUTFILE and this\n      requires FILE_ACL access.\n    */\n    ulong privileges_requested= lex->exchange ? SELECT_ACL | FILE_ACL :\n      SELECT_ACL;\n\n    if (all_tables)\n      res= check_table_access(thd,\n                              privileges_requested,\n                              all_tables, FALSE, UINT_MAX, FALSE);\n    else\n      res= check_access(thd, privileges_requested, any_db, NULL, NULL, 0, 0);\n\n    if (!res)\n      res= execute_sqlcom_select(thd, all_tables);\n\n    break;\n  }\n  case SQLCOM_EXECUTE_IMMEDIATE:\n  {\n    mysql_sql_stmt_execute_immediate(thd);\n    break;\n  }\n  case SQLCOM_PREPARE:\n  {\n    mysql_sql_stmt_prepare(thd);\n    break;\n  }\n  case SQLCOM_EXECUTE:\n  {\n    mysql_sql_stmt_execute(thd);\n    break;\n  }\n  case SQLCOM_DEALLOCATE_PREPARE:\n  {\n    mysql_sql_stmt_close(thd);\n    break;\n  }\n  case SQLCOM_DO:\n    if (check_table_access(thd, SELECT_ACL, all_tables, FALSE, UINT_MAX, FALSE)\n        || open_and_lock_tables(thd, all_tables, TRUE, 0))\n      goto error;\n\n    res= mysql_do(thd, *lex->insert_list);\n    break;\n\n  case SQLCOM_EMPTY_QUERY:\n    my_ok(thd);\n    break;\n\n  case SQLCOM_HELP:\n    res= mysqld_help(thd,lex->help_arg);\n    break;\n\n#ifndef EMBEDDED_LIBRARY\n  case SQLCOM_PURGE:\n  {\n    if (check_global_access(thd, SUPER_ACL))\n      goto error;\n    /* PURGE MASTER LOGS TO 'file' */\n    res = purge_master_logs(thd, lex->to_log);\n    break;\n  }\n  case SQLCOM_PURGE_BEFORE:\n  {\n    Item *it;\n\n    if (check_global_access(thd, SUPER_ACL))\n      goto error;\n    /* PURGE MASTER LOGS BEFORE 'data' */\n    it= (Item *)lex->value_list.head();\n    if (it->fix_fields_if_needed_for_scalar(lex->thd, &it))\n    {\n      my_error(ER_WRONG_ARGUMENTS, MYF(0), \"PURGE LOGS BEFORE\");\n      goto error;\n    }\n    it= new (thd->mem_root) Item_func_unix_timestamp(thd, it);\n    it->fix_fields(thd, &it);\n    res = purge_master_logs_before_date(thd, (ulong)it->val_int());\n    break;\n  }\n#endif\n  case SQLCOM_SHOW_WARNS:\n  {\n    res= mysqld_show_warnings(thd, (ulong)\n\t\t\t      ((1L << (uint) Sql_condition::WARN_LEVEL_NOTE) |\n\t\t\t       (1L << (uint) Sql_condition::WARN_LEVEL_WARN) |\n\t\t\t       (1L << (uint) Sql_condition::WARN_LEVEL_ERROR)\n\t\t\t       ));\n    break;\n  }\n  case SQLCOM_SHOW_ERRORS:\n  {\n    res= mysqld_show_warnings(thd, (ulong)\n\t\t\t      (1L << (uint) Sql_condition::WARN_LEVEL_ERROR));\n    break;\n  }\n  case SQLCOM_SHOW_PROFILES:\n  {\n#if defined(ENABLED_PROFILING)\n    thd->profiling.discard_current_query();\n    res= thd->profiling.show_profiles();\n    if (res)\n      goto error;\n#else\n    my_error(ER_FEATURE_DISABLED, MYF(0), \"SHOW PROFILES\", \"enable-profiling\");\n    goto error;\n#endif\n    break;\n  }\n\n#ifdef HAVE_REPLICATION\n  case SQLCOM_SHOW_SLAVE_HOSTS:\n  {\n    if (check_global_access(thd, REPL_SLAVE_ACL))\n      goto error;\n    res = show_slave_hosts(thd);\n    break;\n  }\n  case SQLCOM_SHOW_RELAYLOG_EVENTS: /* fall through */\n  case SQLCOM_SHOW_BINLOG_EVENTS:\n  {\n    WSREP_SYNC_WAIT(thd, WSREP_SYNC_WAIT_BEFORE_SHOW);\n    if (check_global_access(thd, REPL_SLAVE_ACL))\n      goto error;\n    res = mysql_show_binlog_events(thd);\n    break;\n  }\n#endif\n\n  case SQLCOM_ASSIGN_TO_KEYCACHE:\n  {\n    DBUG_ASSERT(first_table == all_tables && first_table != 0);\n    if (check_access(thd, INDEX_ACL, first_table->db.str,\n                     &first_table->grant.privilege,\n                     &first_table->grant.m_internal,\n                     0, 0))\n      goto error;\n    res= mysql_assign_to_keycache(thd, first_table, &lex->ident);\n    break;\n  }\n  case SQLCOM_PRELOAD_KEYS:\n  {\n    DBUG_ASSERT(first_table == all_tables && first_table != 0);\n    if (check_access(thd, INDEX_ACL, first_table->db.str,\n                     &first_table->grant.privilege,\n                     &first_table->grant.m_internal,\n                     0, 0))\n      goto error;\n    res = mysql_preload_keys(thd, first_table);\n    break;\n  }\n#ifdef HAVE_REPLICATION\n  case SQLCOM_CHANGE_MASTER:\n  {\n    LEX_MASTER_INFO *lex_mi= &thd->lex->mi;\n    Master_info *mi;\n    bool new_master= 0;\n    bool master_info_added;\n\n    if (check_global_access(thd, SUPER_ACL))\n      goto error;\n    /*\n      In this code it's ok to use LOCK_active_mi as we are adding new things\n      into master_info_index\n    */\n    mysql_mutex_lock(&LOCK_active_mi);\n    if (!master_info_index)\n    {\n      mysql_mutex_unlock(&LOCK_active_mi);\n      my_error(ER_SERVER_SHUTDOWN, MYF(0));\n      goto error;\n    }\n\n    mi= master_info_index->get_master_info(&lex_mi->connection_name,\n                                           Sql_condition::WARN_LEVEL_NOTE);\n\n    if (mi == NULL)\n    {\n      /* New replication created */\n      mi= new Master_info(&lex_mi->connection_name, relay_log_recovery); \n      if (unlikely(!mi || mi->error()))\n      {\n        delete mi;\n        res= 1;\n        mysql_mutex_unlock(&LOCK_active_mi);\n        break;\n      }\n      new_master= 1;\n    }\n\n    res= change_master(thd, mi, &master_info_added);\n    if (res && new_master)\n    {\n      /*\n        If the new master was added by change_master(), remove it as it didn't\n        work (this will free mi as well).\n\n        If new master was not added, we still need to free mi.\n      */\n      if (master_info_added)\n        master_info_index->remove_master_info(mi);\n      else\n        delete mi;\n    }\n    else\n    {\n      mi->rpl_filter= get_or_create_rpl_filter(lex_mi->connection_name.str,\n                                               lex_mi->connection_name.length);\n    }\n\n    mysql_mutex_unlock(&LOCK_active_mi);\n    break;\n  }\n  case SQLCOM_SHOW_SLAVE_STAT:\n  {\n    /* Accept one of two privileges */\n    if (check_global_access(thd, SUPER_ACL | REPL_CLIENT_ACL))\n      goto error;\n\n    if (lex->verbose)\n    {\n      mysql_mutex_lock(&LOCK_active_mi);\n      res= show_all_master_info(thd);\n      mysql_mutex_unlock(&LOCK_active_mi);\n    }\n    else\n    {\n      LEX_MASTER_INFO *lex_mi= &thd->lex->mi;\n      Master_info *mi;\n      if ((mi= get_master_info(&lex_mi->connection_name,\n                               Sql_condition::WARN_LEVEL_ERROR)))\n      {\n        res= show_master_info(thd, mi, 0);\n        mi->release();\n      }\n    }\n    break;\n  }\n  case SQLCOM_SHOW_MASTER_STAT:\n  {\n    /* Accept one of two privileges */\n    if (check_global_access(thd, SUPER_ACL | REPL_CLIENT_ACL))\n      goto error;\n    res = show_binlog_info(thd);\n    break;\n  }\n\n#endif /* HAVE_REPLICATION */\n  case SQLCOM_SHOW_ENGINE_STATUS:\n    {\n      if (check_global_access(thd, PROCESS_ACL))\n        goto error;\n      res = ha_show_status(thd, lex->create_info.db_type, HA_ENGINE_STATUS);\n      break;\n    }\n  case SQLCOM_SHOW_ENGINE_MUTEX:\n    {\n      if (check_global_access(thd, PROCESS_ACL))\n        goto error;\n      res = ha_show_status(thd, lex->create_info.db_type, HA_ENGINE_MUTEX);\n      break;\n    }\n  case SQLCOM_CREATE_INDEX:\n  case SQLCOM_DROP_INDEX:\n  /*\n    CREATE INDEX and DROP INDEX are implemented by calling ALTER\n    TABLE with proper arguments.\n\n    In the future ALTER TABLE will notice that the request is to\n    only add indexes and create these one by one for the existing\n    table without having to do a full rebuild.\n  */\n  {\n    /* Prepare stack copies to be re-execution safe */\n    HA_CREATE_INFO create_info;\n    Alter_info alter_info(lex->alter_info, thd->mem_root);\n\n    if (unlikely(thd->is_fatal_error)) /* out of memory creating alter_info */\n      goto error;\n\n    DBUG_ASSERT(first_table == all_tables && first_table != 0);\n    if (check_one_table_access(thd, INDEX_ACL, all_tables))\n      goto error; /* purecov: inspected */\n    WSREP_TO_ISOLATION_BEGIN(first_table->db.str, first_table->table_name.str, NULL);\n\n    bzero((char*) &create_info, sizeof(create_info));\n    create_info.db_type= 0;\n    create_info.row_type= ROW_TYPE_NOT_USED;\n    create_info.default_table_charset= thd->variables.collation_database;\n\n    res= mysql_alter_table(thd, &first_table->db, &first_table->table_name,\n                           &create_info, first_table, &alter_info,\n                           0, (ORDER*) 0, 0);\n    break;\n  }\n#ifdef HAVE_REPLICATION\n  case SQLCOM_SLAVE_START:\n  {\n    LEX_MASTER_INFO* lex_mi= &thd->lex->mi;\n    Master_info *mi;\n    int load_error;\n\n    load_error= rpl_load_gtid_slave_state(thd);\n\n    /*\n      We don't need to ensure that only one user is using master_info\n      as start_slave is protected against simultaneous usage\n    */\n    if (unlikely((mi= get_master_info(&lex_mi->connection_name,\n                                      Sql_condition::WARN_LEVEL_ERROR))))\n    {\n      if (load_error)\n      {\n        /*\n          We cannot start a slave using GTID if we cannot load the\n          GTID position from the mysql.gtid_slave_pos table. But we\n          can allow non-GTID replication (useful eg. during upgrade).\n        */\n        if (mi->using_gtid != Master_info::USE_GTID_NO)\n        {\n          mi->release();\n          break;\n        }\n        else\n          thd->clear_error();\n      }\n      if (!start_slave(thd, mi, 1 /* net report*/))\n        my_ok(thd);\n      mi->release();\n    }\n    break;\n  }\n  case SQLCOM_SLAVE_STOP:\n  {\n    LEX_MASTER_INFO *lex_mi;\n    Master_info *mi;\n    /*\n      If the client thread has locked tables, a deadlock is possible.\n      Assume that\n      - the client thread does LOCK TABLE t READ.\n      - then the master updates t.\n      - then the SQL slave thread wants to update t,\n        so it waits for the client thread because t is locked by it.\n    - then the client thread does SLAVE STOP.\n      SLAVE STOP waits for the SQL slave thread to terminate its\n      update t, which waits for the client thread because t is locked by it.\n      To prevent that, refuse SLAVE STOP if the\n      client thread has locked tables\n    */\n    if (thd->locked_tables_mode ||\n        thd->in_active_multi_stmt_transaction() ||\n        thd->global_read_lock.is_acquired())\n    {\n      my_message(ER_LOCK_OR_ACTIVE_TRANSACTION,\n                 ER_THD(thd, ER_LOCK_OR_ACTIVE_TRANSACTION), MYF(0));\n      goto error;\n    }\n\n    lex_mi= &thd->lex->mi;\n    if ((mi= get_master_info(&lex_mi->connection_name,\n                             Sql_condition::WARN_LEVEL_ERROR)))\n    {\n      if (stop_slave(thd, mi, 1/* net report*/))\n        res= 1;\n      mi->release();\n      if (rpl_parallel_resize_pool_if_no_slaves())\n        res= 1;\n      if (!res)\n        my_ok(thd);\n    }\n    break;\n  }\n  case SQLCOM_SLAVE_ALL_START:\n  {\n    mysql_mutex_lock(&LOCK_active_mi);\n    if (master_info_index && !master_info_index->start_all_slaves(thd))\n      my_ok(thd);\n    mysql_mutex_unlock(&LOCK_active_mi);\n    break;\n  }\n  case SQLCOM_SLAVE_ALL_STOP:\n  {\n    if (thd->locked_tables_mode ||\n        thd->in_active_multi_stmt_transaction() ||\n        thd->global_read_lock.is_acquired())\n    {\n      my_message(ER_LOCK_OR_ACTIVE_TRANSACTION,\n                 ER_THD(thd, ER_LOCK_OR_ACTIVE_TRANSACTION), MYF(0));\n      goto error;\n    }\n    mysql_mutex_lock(&LOCK_active_mi);\n    if (master_info_index && !master_info_index->stop_all_slaves(thd))\n      my_ok(thd);      \n    mysql_mutex_unlock(&LOCK_active_mi);\n    break;\n  }\n#endif /* HAVE_REPLICATION */\n  case SQLCOM_RENAME_TABLE:\n  {\n    if (check_rename_table(thd, first_table, all_tables))\n      goto error;\n\n    WSREP_TO_ISOLATION_BEGIN(0, 0, first_table);\n\n    if (mysql_rename_tables(thd, first_table, 0))\n      goto error;\n    break;\n  }\n#ifndef EMBEDDED_LIBRARY\n  case SQLCOM_SHOW_BINLOGS:\n#ifdef DONT_ALLOW_SHOW_COMMANDS\n    my_message(ER_NOT_ALLOWED_COMMAND, ER_THD(thd, ER_NOT_ALLOWED_COMMAND),\n               MYF(0)); /* purecov: inspected */\n    goto error;\n#else\n    {\n      if (check_global_access(thd, SUPER_ACL | REPL_CLIENT_ACL))\n\tgoto error;\n      WSREP_SYNC_WAIT(thd, WSREP_SYNC_WAIT_BEFORE_SHOW);\n      res = show_binlogs(thd);\n      break;\n    }\n#endif\n#endif /* EMBEDDED_LIBRARY */\n  case SQLCOM_SHOW_CREATE:\n  {\n     DBUG_ASSERT(first_table == all_tables && first_table != 0);\n#ifdef DONT_ALLOW_SHOW_COMMANDS\n    my_message(ER_NOT_ALLOWED_COMMAND, ER_THD(thd, ER_NOT_ALLOWED_COMMAND),\n               MYF(0)); /* purecov: inspected */\n    goto error;\n#else\n      WSREP_SYNC_WAIT(thd, WSREP_SYNC_WAIT_BEFORE_SHOW);\n\n     /*\n        Access check:\n        SHOW CREATE TABLE require any privileges on the table level (ie\n        effecting all columns in the table).\n        SHOW CREATE VIEW require the SHOW_VIEW and SELECT ACLs on the table\n        level.\n        NOTE: SHOW_VIEW ACL is checked when the view is created.\n      */\n\n      DBUG_PRINT(\"debug\", (\"lex->only_view: %d, table: %s.%s\",\n                           lex->table_type == TABLE_TYPE_VIEW,\n                           first_table->db.str, first_table->table_name.str));\n      res= mysqld_show_create(thd, first_table);\n      break;\n#endif\n  }\n  case SQLCOM_CHECKSUM:\n  {\n    DBUG_ASSERT(first_table == all_tables && first_table != 0);\n    WSREP_SYNC_WAIT(thd, WSREP_SYNC_WAIT_BEFORE_READ);\n\n    if (check_table_access(thd, SELECT_ACL, all_tables,\n                           FALSE, UINT_MAX, FALSE))\n      goto error; /* purecov: inspected */\n\n    res = mysql_checksum_table(thd, first_table, &lex->check_opt);\n    break;\n  }\n  case SQLCOM_UPDATE:\n  {\n    WSREP_SYNC_WAIT(thd, WSREP_SYNC_WAIT_BEFORE_UPDATE_DELETE);\n    ha_rows found= 0, updated= 0;\n    DBUG_ASSERT(first_table == all_tables && first_table != 0);\n    WSREP_SYNC_WAIT(thd, WSREP_SYNC_WAIT_BEFORE_UPDATE_DELETE);\n\n    if (update_precheck(thd, all_tables))\n      break;\n\n    /*\n      UPDATE IGNORE can be unsafe. We therefore use row based\n      logging if mixed or row based logging is available.\n      TODO: Check if the order of the output of the select statement is\n      deterministic. Waiting for BUG#42415\n    */\n    if (lex->ignore)\n      lex->set_stmt_unsafe(LEX::BINLOG_STMT_UNSAFE_UPDATE_IGNORE);\n\n    DBUG_ASSERT(select_lex->offset_limit == 0);\n    unit->set_limit(select_lex);\n    MYSQL_UPDATE_START(thd->query());\n    res= up_result= mysql_update(thd, all_tables,\n                                  select_lex->item_list,\n                                  lex->value_list,\n                                  select_lex->where,\n                                  select_lex->order_list.elements,\n                                  select_lex->order_list.first,\n                                  unit->select_limit_cnt,\n                                  lex->ignore, &found, &updated);\n    MYSQL_UPDATE_DONE(res, found, updated);\n    /* mysql_update return 2 if we need to switch to multi-update */\n    if (up_result != 2)\n      break;\n    if (thd->lex->period_conditions.is_set())\n    {\n      DBUG_ASSERT(0); // Should never happen\n      goto error;\n    }\n  }\n  /* fall through */\n  case SQLCOM_UPDATE_MULTI:\n  {\n    DBUG_ASSERT(first_table == all_tables && first_table != 0);\n    /* if we switched from normal update, rights are checked */\n    if (up_result != 2)\n    {\n      WSREP_SYNC_WAIT(thd, WSREP_SYNC_WAIT_BEFORE_UPDATE_DELETE);\n      if ((res= multi_update_precheck(thd, all_tables)))\n        break;\n    }\n    else\n      res= 0;\n\n    unit->set_limit(select_lex);\n    /*\n      We can not use mysql_explain_union() because of parameters of\n      mysql_select in mysql_multi_update so just set the option if needed\n    */\n    if (thd->lex->describe)\n    {\n      select_lex->set_explain_type(FALSE);\n      select_lex->options|= SELECT_DESCRIBE;\n    }\n\n    res= mysql_multi_update_prepare(thd);\n\n#ifdef HAVE_REPLICATION\n    /* Check slave filtering rules */\n    if (unlikely(thd->slave_thread && !have_table_map_for_update))\n    {\n      if (all_tables_not_ok(thd, all_tables))\n      {\n        if (res!= 0)\n        {\n          res= 0;             /* don't care of prev failure  */\n          thd->clear_error(); /* filters are of highest prior */\n        }\n        /* we warn the slave SQL thread */\n        my_error(ER_SLAVE_IGNORED_TABLE, MYF(0));\n        break;\n      }\n      if (res)\n        break;\n    }\n    else\n    {\n#endif /* HAVE_REPLICATION */\n      if (res)\n        break;\n      if (opt_readonly &&\n\t  !(thd->security_ctx->master_access & SUPER_ACL) &&\n\t  some_non_temp_table_to_be_updated(thd, all_tables))\n      {\n\tmy_error(ER_OPTION_PREVENTS_STATEMENT, MYF(0), \"--read-only\");\n\tbreak;\n      }\n#ifdef HAVE_REPLICATION\n    }  /* unlikely */\n#endif\n    {\n      multi_update *result_obj;\n      MYSQL_MULTI_UPDATE_START(thd->query());\n      res= mysql_multi_update(thd, all_tables,\n                              &select_lex->item_list,\n                              &lex->value_list,\n                              select_lex->where,\n                              select_lex->options,\n                              lex->duplicates,\n                              lex->ignore,\n                              unit,\n                              select_lex,\n                              &result_obj);\n      if (result_obj)\n      {\n        MYSQL_MULTI_UPDATE_DONE(res, result_obj->num_found(),\n                                result_obj->num_updated());\n        res= FALSE; /* Ignore errors here */\n        delete result_obj;\n      }\n      else\n      {\n        MYSQL_MULTI_UPDATE_DONE(1, 0, 0);\n      }\n    }\n    break;\n  }\n  case SQLCOM_REPLACE:\n#ifndef DBUG_OFF\n    if (mysql_bin_log.is_open())\n    {\n      /*\n        Generate an incident log event before writing the real event\n        to the binary log.  We put this event is before the statement\n        since that makes it simpler to check that the statement was\n        not executed on the slave (since incidents usually stop the\n        slave).\n\n        Observe that any row events that are generated will be\n        generated before.\n\n        This is only for testing purposes and will not be present in a\n        release build.\n      */\n\n      Incident incident= INCIDENT_NONE;\n      DBUG_PRINT(\"debug\", (\"Just before generate_incident()\"));\n      DBUG_EXECUTE_IF(\"incident_database_resync_on_replace\",\n                      incident= INCIDENT_LOST_EVENTS;);\n      if (incident)\n      {\n        Incident_log_event ev(thd, incident);\n        (void) mysql_bin_log.write(&ev);        /* error is ignored */\n        if (mysql_bin_log.rotate_and_purge(true))\n        {\n          res= 1;\n          break;\n        }\n      }\n      DBUG_PRINT(\"debug\", (\"Just after generate_incident()\"));\n    }\n#endif\n    /* fall through */\n  case SQLCOM_INSERT:\n  {\n    WSREP_SYNC_WAIT(thd, WSREP_SYNC_WAIT_BEFORE_INSERT_REPLACE);\n    DBUG_ASSERT(first_table == all_tables && first_table != 0);\n\n    WSREP_SYNC_WAIT(thd, WSREP_SYNC_WAIT_BEFORE_INSERT_REPLACE);\n\n    /*\n      Since INSERT DELAYED doesn't support temporary tables, we could\n      not pre-open temporary tables for SQLCOM_INSERT / SQLCOM_REPLACE.\n      Open them here instead.\n    */\n    if (first_table->lock_type != TL_WRITE_DELAYED)\n    {\n      res= (thd->open_temporary_tables(all_tables)) ? TRUE : FALSE;\n      if (res)\n        break;\n    }\n\n    if ((res= insert_precheck(thd, all_tables)))\n      break;\n\n    MYSQL_INSERT_START(thd->query());\n    res= mysql_insert(thd, all_tables, lex->field_list, lex->many_values,\n\t\t      lex->update_list, lex->value_list,\n                      lex->duplicates, lex->ignore);\n    MYSQL_INSERT_DONE(res, (ulong) thd->get_row_count_func());\n    /*\n      If we have inserted into a VIEW, and the base table has\n      AUTO_INCREMENT column, but this column is not accessible through\n      a view, then we should restore LAST_INSERT_ID to the value it\n      had before the statement.\n    */\n    if (first_table->view && !first_table->contain_auto_increment)\n      thd->first_successful_insert_id_in_cur_stmt=\n        thd->first_successful_insert_id_in_prev_stmt;\n\n#ifdef ENABLED_DEBUG_SYNC\n    DBUG_EXECUTE_IF(\"after_mysql_insert\",\n                    {\n                      const char act1[]=\n                        \"now \"\n                        \"wait_for signal.continue\";\n                      const char act2[]=\n                        \"now \"\n                        \"signal signal.continued\";\n                      DBUG_ASSERT(debug_sync_service);\n                      DBUG_ASSERT(!debug_sync_set_action(thd,\n                                                         STRING_WITH_LEN(act1)));\n                      DBUG_ASSERT(!debug_sync_set_action(thd,\n                                                         STRING_WITH_LEN(act2)));\n                    };);\n    DEBUG_SYNC(thd, \"after_mysql_insert\");\n#endif\n    break;\n  }\n  case SQLCOM_REPLACE_SELECT:\n  case SQLCOM_INSERT_SELECT:\n  {\n    WSREP_SYNC_WAIT(thd, WSREP_SYNC_WAIT_BEFORE_INSERT_REPLACE);\n    select_insert *sel_result;\n    bool explain= MY_TEST(lex->describe);\n    DBUG_ASSERT(first_table == all_tables && first_table != 0);\n    WSREP_SYNC_WAIT(thd, WSREP_SYNC_WAIT_BEFORE_UPDATE_DELETE);\n\n    if ((res= insert_precheck(thd, all_tables)))\n      break;\n#ifdef WITH_WSREP\n    if (WSREP(thd) && thd->wsrep_consistency_check == CONSISTENCY_CHECK_DECLARED)\n    {\n      thd->wsrep_consistency_check = CONSISTENCY_CHECK_RUNNING;\n      WSREP_TO_ISOLATION_BEGIN(first_table->db.str, first_table->table_name.str, NULL);\n    }\n#endif /* WITH_WSREP */\n\n    /*\n      INSERT...SELECT...ON DUPLICATE KEY UPDATE/REPLACE SELECT/\n      INSERT...IGNORE...SELECT can be unsafe, unless ORDER BY PRIMARY KEY\n      clause is used in SELECT statement. We therefore use row based\n      logging if mixed or row based logging is available.\n      TODO: Check if the order of the output of the select statement is\n      deterministic. Waiting for BUG#42415\n    */\n    if (lex->sql_command == SQLCOM_INSERT_SELECT &&\n        lex->duplicates == DUP_UPDATE)\n      lex->set_stmt_unsafe(LEX::BINLOG_STMT_UNSAFE_INSERT_SELECT_UPDATE);\n\n    if (lex->sql_command == SQLCOM_INSERT_SELECT && lex->ignore)\n      lex->set_stmt_unsafe(LEX::BINLOG_STMT_UNSAFE_INSERT_IGNORE_SELECT);\n\n    if (lex->sql_command == SQLCOM_REPLACE_SELECT)\n      lex->set_stmt_unsafe(LEX::BINLOG_STMT_UNSAFE_REPLACE_SELECT);\n\n    /* Fix lock for first table */\n    if (first_table->lock_type == TL_WRITE_DELAYED)\n      first_table->lock_type= TL_WRITE;\n\n    /* Don't unlock tables until command is written to binary log */\n    select_lex->options|= SELECT_NO_UNLOCK;\n\n    unit->set_limit(select_lex);\n\n    if (!(res=open_and_lock_tables(thd, all_tables, TRUE, 0)))\n    {\n      MYSQL_INSERT_SELECT_START(thd->query());\n      /*\n        Only the INSERT table should be merged. Other will be handled by\n        select.\n      */\n      /* Skip first table, which is the table we are inserting in */\n      TABLE_LIST *second_table= first_table->next_local;\n      /*\n        This is a hack: this leaves select_lex->table_list in an inconsistent\n        state as 'elements' does not contain number of elements in the list.\n        Moreover, if second_table == NULL then 'next' becomes invalid.\n        TODO: fix it by removing the front element (restoring of it should\n        be done properly as well)\n      */\n      select_lex->table_list.first= second_table;\n      select_lex->context.table_list= \n        select_lex->context.first_name_resolution_table= second_table;\n      res= mysql_insert_select_prepare(thd);\n      if (!res && (sel_result= new (thd->mem_root) select_insert(thd,\n                                                             first_table,\n                                                             first_table->table,\n                                                             &lex->field_list,\n                                                             &lex->update_list,\n                                                             &lex->value_list,\n                                                             lex->duplicates,\n                                                             lex->ignore)))\n      {\n        if (lex->analyze_stmt)\n          ((select_result_interceptor*)sel_result)->disable_my_ok_calls();\n\n        if (explain)\n          res= mysql_explain_union(thd, &thd->lex->unit, sel_result);\n        else\n          res= handle_select(thd, lex, sel_result, OPTION_SETUP_TABLES_DONE);\n        /*\n          Invalidate the table in the query cache if something changed\n          after unlocking when changes become visible.\n          TODO: this is workaround. right way will be move invalidating in\n          the unlock procedure.\n        */\n        if (!res && first_table->lock_type ==  TL_WRITE_CONCURRENT_INSERT &&\n            thd->lock)\n        {\n          /* INSERT ... SELECT should invalidate only the very first table */\n          TABLE_LIST *save_table= first_table->next_local;\n          first_table->next_local= 0;\n          query_cache_invalidate3(thd, first_table, 1);\n          first_table->next_local= save_table;\n        }\n        if (explain)\n        {\n          /*\n            sel_result needs to be cleaned up properly.\n            INSERT... SELECT statement will call either send_eof() or\n            abort_result_set(). EXPLAIN doesn't call either, so we need\n            to cleanup manually.\n          */\n          sel_result->abort_result_set();\n        }\n        delete sel_result;\n      }\n\n      if (!res && (explain || lex->analyze_stmt))\n        res= thd->lex->explain->send_explain(thd);\n\n      /* revert changes for SP */\n      MYSQL_INSERT_SELECT_DONE(res, (ulong) thd->get_row_count_func());\n      select_lex->table_list.first= first_table;\n    }\n    /*\n      If we have inserted into a VIEW, and the base table has\n      AUTO_INCREMENT column, but this column is not accessible through\n      a view, then we should restore LAST_INSERT_ID to the value it\n      had before the statement.\n    */\n    if (first_table->view && !first_table->contain_auto_increment)\n      thd->first_successful_insert_id_in_cur_stmt=\n        thd->first_successful_insert_id_in_prev_stmt;\n\n    break;\n  }\n  case SQLCOM_DELETE:\n  {\n    WSREP_SYNC_WAIT(thd, WSREP_SYNC_WAIT_BEFORE_UPDATE_DELETE);\n    select_result *sel_result= NULL;\n    DBUG_ASSERT(first_table == all_tables && first_table != 0);\n    WSREP_SYNC_WAIT(thd, WSREP_SYNC_WAIT_BEFORE_UPDATE_DELETE);\n\n    if ((res= delete_precheck(thd, all_tables)))\n      break;\n    DBUG_ASSERT(select_lex->offset_limit == 0);\n    unit->set_limit(select_lex);\n\n    MYSQL_DELETE_START(thd->query());\n    Protocol * UNINIT_VAR(save_protocol);\n    bool replaced_protocol= false;\n\n    if (!select_lex->item_list.is_empty())\n    {\n      /* This is DELETE ... RETURNING.  It will return output to the client */\n      if (thd->lex->analyze_stmt)\n      {\n        /* \n          Actually, it is ANALYZE .. DELETE .. RETURNING. We need to produce\n          output and then discard it.\n        */\n        sel_result= new (thd->mem_root) select_send_analyze(thd);\n        replaced_protocol= true;\n        save_protocol= thd->protocol;\n        thd->protocol= new Protocol_discard(thd);\n      }\n      else\n      {\n        if (!lex->result && !(sel_result= new (thd->mem_root) select_send(thd)))\n          goto error;\n      }\n    }\n\n    res = mysql_delete(thd, all_tables, \n                       select_lex->where, &select_lex->order_list,\n                       unit->select_limit_cnt, select_lex->options,\n                       lex->result ? lex->result : sel_result);\n\n    if (replaced_protocol)\n    {\n      delete thd->protocol;\n      thd->protocol= save_protocol;\n    }\n\n    if (thd->lex->analyze_stmt || thd->lex->describe)\n    {\n      if (!res)\n        res= thd->lex->explain->send_explain(thd);\n    }\n\n    delete sel_result;\n    MYSQL_DELETE_DONE(res, (ulong) thd->get_row_count_func());\n    break;\n  }\n  case SQLCOM_DELETE_MULTI:\n  {\n    WSREP_SYNC_WAIT(thd, WSREP_SYNC_WAIT_BEFORE_UPDATE_DELETE);\n    DBUG_ASSERT(first_table == all_tables && first_table != 0);\n    TABLE_LIST *aux_tables= thd->lex->auxiliary_table_list.first;\n    multi_delete *result;\n    WSREP_SYNC_WAIT(thd, WSREP_SYNC_WAIT_BEFORE_UPDATE_DELETE);\n\n    if ((res= multi_delete_precheck(thd, all_tables)))\n      break;\n\n    /* condition will be TRUE on SP re-excuting */\n    if (select_lex->item_list.elements != 0)\n      select_lex->item_list.empty();\n    if (add_item_to_list(thd, new (thd->mem_root) Item_null(thd)))\n      goto error;\n\n    THD_STAGE_INFO(thd, stage_init);\n    if ((res= open_and_lock_tables(thd, all_tables, TRUE, 0)))\n      break;\n\n    MYSQL_MULTI_DELETE_START(thd->query());\n    if (unlikely(res= mysql_multi_delete_prepare(thd)))\n    {\n      MYSQL_MULTI_DELETE_DONE(1, 0);\n      goto error;\n    }\n\n    if (likely(!thd->is_fatal_error))\n    {\n      result= new (thd->mem_root) multi_delete(thd, aux_tables,\n                                               lex->table_count);\n      if (likely(result))\n      {\n        if (unlikely(select_lex->vers_setup_conds(thd, aux_tables)))\n          goto multi_delete_error;\n        res= mysql_select(thd,\n                          select_lex->get_table_list(),\n                          select_lex->with_wild,\n                          select_lex->item_list,\n                          select_lex->where,\n                          0, (ORDER *)NULL, (ORDER *)NULL, (Item *)NULL,\n                          (ORDER *)NULL,\n                          (select_lex->options | thd->variables.option_bits |\n                          SELECT_NO_JOIN_CACHE | SELECT_NO_UNLOCK |\n                          OPTION_SETUP_TABLES_DONE) & ~OPTION_BUFFER_RESULT,\n                          result, unit, select_lex);\n        res|= (int)(thd->is_error());\n\n        MYSQL_MULTI_DELETE_DONE(res, result->num_deleted());\n        if (res)\n          result->abort_result_set(); /* for both DELETE and EXPLAIN DELETE */\n        else\n        {\n          if (lex->describe || lex->analyze_stmt)\n            res= thd->lex->explain->send_explain(thd);\n        }\n      multi_delete_error:\n        delete result;\n      }\n    }\n    else\n    {\n      res= TRUE;                                // Error\n      MYSQL_MULTI_DELETE_DONE(1, 0);\n    }\n    break;\n  }\n  case SQLCOM_DROP_SEQUENCE:\n  case SQLCOM_DROP_TABLE:\n  {\n    int result;\n    DBUG_ASSERT(first_table == all_tables && first_table != 0);\n\n    thd->open_options|= HA_OPEN_FOR_REPAIR;\n    result= thd->open_temporary_tables(all_tables);\n    thd->open_options&= ~HA_OPEN_FOR_REPAIR;\n    if (result)\n      goto error;\n    if (!lex->tmp_table())\n    {\n      if (check_table_access(thd, DROP_ACL, all_tables, FALSE, UINT_MAX, FALSE))\n\tgoto error;\t\t\t\t/* purecov: inspected */\n    }\n    else\n    {\n      status_var_decrement(thd->status_var.com_stat[lex->sql_command]);\n      status_var_increment(thd->status_var.com_drop_tmp_table);\n\n      /* So that DROP TEMPORARY TABLE gets to binlog at commit/rollback */\n      thd->variables.option_bits|= OPTION_KEEP_LOG;\n    }\n    /*\n      If we are a slave, we should add IF EXISTS if the query executed\n      on the master without an error. This will help a slave to\n      recover from multi-table DROP TABLE that was aborted in the\n      middle.\n    */\n    if (thd->slave_thread && !thd->slave_expected_error &&\n        slave_ddl_exec_mode_options == SLAVE_EXEC_MODE_IDEMPOTENT)\n      lex->create_info.set(DDL_options_st::OPT_IF_EXISTS);\n\n    if (WSREP(thd))\n    {\n      for (TABLE_LIST *table= all_tables; table; table= table->next_global)\n      {\n        if (!lex->tmp_table() &&\n           (!thd->is_current_stmt_binlog_format_row() ||\n\t    !thd->find_temporary_table(table)))\n        {\n          WSREP_TO_ISOLATION_BEGIN(NULL, NULL, all_tables);\n          break;\n        }\n      }\n    }\n    \n    /* DDL and binlog write order are protected by metadata locks. */\n    res= mysql_rm_table(thd, first_table, lex->if_exists(), lex->tmp_table(),\n                        lex->table_type == TABLE_TYPE_SEQUENCE);\n\n    /*\n      When dropping temporary tables if @@session_track_state_change is ON\n      then send the boolean tracker in the OK packet\n    */\n    if(!res && (lex->create_info.options & HA_LEX_CREATE_TMP_TABLE))\n    {\n      SESSION_TRACKER_CHANGED(thd, SESSION_STATE_CHANGE_TRACKER, NULL);\n    }\n    break;\n  }\n  case SQLCOM_SHOW_PROCESSLIST:\n    if (!thd->security_ctx->priv_user[0] &&\n        check_global_access(thd,PROCESS_ACL))\n      break;\n    mysqld_list_processes(thd,\n\t\t\t  (thd->security_ctx->master_access & PROCESS_ACL ?\n                           NullS :\n                           thd->security_ctx->priv_user),\n                          lex->verbose);\n    break;\n  case SQLCOM_SHOW_AUTHORS:\n    res= mysqld_show_authors(thd);\n    break;\n  case SQLCOM_SHOW_CONTRIBUTORS:\n    res= mysqld_show_contributors(thd);\n    break;\n  case SQLCOM_SHOW_PRIVILEGES:\n    res= mysqld_show_privileges(thd);\n    break;\n  case SQLCOM_SHOW_ENGINE_LOGS:\n#ifdef DONT_ALLOW_SHOW_COMMANDS\n    my_message(ER_NOT_ALLOWED_COMMAND, ER_THD(thd, ER_NOT_ALLOWED_COMMAND),\n               MYF(0));\t/* purecov: inspected */\n    goto error;\n#else\n    {\n      if (check_access(thd, FILE_ACL, any_db, NULL, NULL, 0, 0))\n\tgoto error;\n      res= ha_show_status(thd, lex->create_info.db_type, HA_ENGINE_LOGS);\n      break;\n    }\n#endif\n  case SQLCOM_CHANGE_DB:\n  {\n    if (!mysql_change_db(thd, &select_lex->db, FALSE))\n      my_ok(thd);\n\n    break;\n  }\n\n  case SQLCOM_LOAD:\n  {\n    DBUG_ASSERT(first_table == all_tables && first_table != 0);\n    uint privilege= (lex->duplicates == DUP_REPLACE ?\n\t\t     INSERT_ACL | DELETE_ACL : INSERT_ACL) |\n                    (lex->local_file ? 0 : FILE_ACL);\n\n    if (lex->local_file)\n    {\n      if (!(thd->client_capabilities & CLIENT_LOCAL_FILES) ||\n          !opt_local_infile)\n      {\n\tmy_message(ER_NOT_ALLOWED_COMMAND, ER_THD(thd, ER_NOT_ALLOWED_COMMAND), MYF(0));\n\tgoto error;\n      }\n    }\n\n    if (check_one_table_access(thd, privilege, all_tables))\n      goto error;\n\n    res= mysql_load(thd, lex->exchange, first_table, lex->field_list,\n                    lex->update_list, lex->value_list, lex->duplicates,\n                    lex->ignore, (bool) lex->local_file);\n    break;\n  }\n\n  case SQLCOM_SET_OPTION:\n  {\n    List<set_var_base> *lex_var_list= &lex->var_list;\n\n    if ((check_table_access(thd, SELECT_ACL, all_tables, FALSE, UINT_MAX, FALSE)\n         || open_and_lock_tables(thd, all_tables, TRUE, 0)))\n      goto error;\n    if (likely(!(res= sql_set_variables(thd, lex_var_list, true))))\n    {\n      if (likely(!thd->is_error()))\n        my_ok(thd);\n    }\n    else\n    {\n      /*\n        We encountered some sort of error, but no message was sent.\n        Send something semi-generic here since we don't know which\n        assignment in the list caused the error.\n      */\n      if (!thd->is_error())\n        my_error(ER_WRONG_ARGUMENTS,MYF(0),\"SET\");\n      goto error;\n    }\n\n    break;\n  }\n\n  case SQLCOM_UNLOCK_TABLES:\n    /*\n      It is critical for mysqldump --single-transaction --master-data that\n      UNLOCK TABLES does not implicitely commit a connection which has only\n      done FLUSH TABLES WITH READ LOCK + BEGIN. If this assumption becomes\n      false, mysqldump will not work.\n    */\n    if (thd->variables.option_bits & OPTION_TABLE_LOCK)\n    {\n      res= trans_commit_implicit(thd);\n      thd->locked_tables_list.unlock_locked_tables(thd);\n      thd->release_transactional_locks();\n      thd->variables.option_bits&= ~(OPTION_TABLE_LOCK);\n    }\n    if (thd->global_read_lock.is_acquired() &&\n        thd->current_backup_stage == BACKUP_FINISHED)\n      thd->global_read_lock.unlock_global_read_lock(thd);\n    if (res)\n      goto error;\n    my_ok(thd);\n    break;\n  case SQLCOM_LOCK_TABLES:\n    /* We must end the transaction first, regardless of anything */\n    res= trans_commit_implicit(thd);\n    thd->locked_tables_list.unlock_locked_tables(thd);\n    /* Release transactional metadata locks. */\n    thd->release_transactional_locks();\n    if (res)\n      goto error;\n\n#ifdef WITH_WSREP\n    /* Clean up the previous transaction on implicit commit. */\n    if (wsrep_on(thd) && !wsrep_not_committed(thd) && wsrep_after_statement(thd))\n      goto error;\n#endif\n\n    /* We can't have any kind of table locks while backup is active */\n    if (thd->current_backup_stage != BACKUP_FINISHED)\n    {\n      my_error(ER_BACKUP_LOCK_IS_ACTIVE, MYF(0));\n      goto error;\n    }\n\n    /* Should not lock tables while BACKUP LOCK is active */\n    if (thd->mdl_backup_lock)\n    {\n      my_error(ER_LOCK_OR_ACTIVE_TRANSACTION, MYF(0));\n      goto error;\n    }\n\n    /*\n      Here we have to pre-open temporary tables for LOCK TABLES.\n\n      CF_PREOPEN_TMP_TABLES is not set for this SQL statement simply\n      because LOCK TABLES calls close_thread_tables() as a first thing\n      (it's called from unlock_locked_tables() above). So even if\n      CF_PREOPEN_TMP_TABLES was set and the tables would be pre-opened\n      in a usual way, they would have been closed.\n    */\n    if (thd->open_temporary_tables(all_tables))\n      goto error;\n\n    if (lock_tables_precheck(thd, all_tables))\n      goto error;\n\n    thd->variables.option_bits|= OPTION_TABLE_LOCK;\n\n    res= lock_tables_open_and_lock_tables(thd, all_tables);\n\n    if (res)\n    {\n      thd->variables.option_bits&= ~(OPTION_TABLE_LOCK);\n    }\n    else\n    {\n#ifdef HAVE_QUERY_CACHE\n      if (thd->variables.query_cache_wlock_invalidate)\n\tquery_cache.invalidate_locked_for_write(thd, first_table);\n#endif /*HAVE_QUERY_CACHE*/\n      my_ok(thd);\n    }\n    break;\n  case SQLCOM_BACKUP:\n    if (check_global_access(thd, RELOAD_ACL))\n      goto error;\n    if (!(res= run_backup_stage(thd, lex->backup_stage)))\n      my_ok(thd);\n    break;\n  case SQLCOM_BACKUP_LOCK:\n    if (check_global_access(thd, RELOAD_ACL))\n      goto error;\n    /* first table is set for lock. For unlock the list is empty */\n    if (first_table)\n      res= backup_lock(thd, first_table);\n    else\n      backup_unlock(thd);\n    if (!res)\n      my_ok(thd);\n    break;\n  case SQLCOM_CREATE_DB:\n  {\n    if (prepare_db_action(thd, lex->create_info.or_replace() ?\n                          (CREATE_ACL | DROP_ACL) : CREATE_ACL,\n                          &lex->name))\n      break;\n    WSREP_TO_ISOLATION_BEGIN(lex->name.str, NULL, NULL);\n    res= mysql_create_db(thd, &lex->name,\n                         lex->create_info, &lex->create_info);\n    break;\n  }\n  case SQLCOM_DROP_DB:\n  {\n    if (prepare_db_action(thd, DROP_ACL, &lex->name))\n      break;\n    WSREP_TO_ISOLATION_BEGIN(lex->name.str, NULL, NULL);\n    res= mysql_rm_db(thd, &lex->name, lex->if_exists());\n    break;\n  }\n  case SQLCOM_ALTER_DB_UPGRADE:\n  {\n    LEX_CSTRING *db= &lex->name;\n#ifdef HAVE_REPLICATION\n    if (thd->slave_thread)\n    {\n      rpl_filter= thd->system_thread_info.rpl_sql_info->rpl_filter;\n      if (!rpl_filter->db_ok(db->str) ||\n          !rpl_filter->db_ok_with_wild_table(db->str))\n      {\n        res= 1;\n        my_message(ER_SLAVE_IGNORED_TABLE, ER_THD(thd, ER_SLAVE_IGNORED_TABLE), MYF(0));\n        break;\n      }\n    }\n#endif\n    if (check_db_name((LEX_STRING*) db))\n    {\n      my_error(ER_WRONG_DB_NAME, MYF(0), db->str);\n      break;\n    }\n    if (check_access(thd, ALTER_ACL, db->str, NULL, NULL, 1, 0) ||\n        check_access(thd, DROP_ACL, db->str, NULL, NULL, 1, 0) ||\n        check_access(thd, CREATE_ACL, db->str, NULL, NULL, 1, 0))\n    {\n      res= 1;\n      break;\n    }\n    WSREP_TO_ISOLATION_BEGIN(db->str, NULL, NULL);\n    res= mysql_upgrade_db(thd, db);\n    if (!res)\n      my_ok(thd);\n    break;\n  }\n  case SQLCOM_ALTER_DB:\n  {\n    LEX_CSTRING *db= &lex->name;\n    if (prepare_db_action(thd, ALTER_ACL, db))\n      break;\n    WSREP_TO_ISOLATION_BEGIN(db->str, NULL, NULL);\n    res= mysql_alter_db(thd, db, &lex->create_info);\n    break;\n  }\n  case SQLCOM_SHOW_CREATE_DB:\n  {\n    char db_name_buff[NAME_LEN+1];\n    LEX_CSTRING db_name;\n    DBUG_EXECUTE_IF(\"4x_server_emul\",\n                    my_error(ER_UNKNOWN_ERROR, MYF(0)); goto error;);\n\n    db_name.str= db_name_buff;\n    db_name.length= lex->name.length;\n    strmov(db_name_buff, lex->name.str);\n\n    WSREP_SYNC_WAIT(thd, WSREP_SYNC_WAIT_BEFORE_SHOW);\n\n    if (check_db_name((LEX_STRING*) &db_name))\n    {\n      my_error(ER_WRONG_DB_NAME, MYF(0), db_name.str);\n      break;\n    }\n    res= mysqld_show_create_db(thd, &db_name, &lex->name, lex->create_info);\n    break;\n  }\n  case SQLCOM_CREATE_EVENT:\n  case SQLCOM_ALTER_EVENT:\n  #ifdef HAVE_EVENT_SCHEDULER\n  do\n  {\n    DBUG_ASSERT(lex->event_parse_data);\n    if (lex->table_or_sp_used())\n    {\n      my_error(ER_SUBQUERIES_NOT_SUPPORTED, MYF(0), \"CREATE/ALTER EVENT\");\n      break;\n    }\n\n    res= sp_process_definer(thd);\n    if (res)\n      break;\n\n    switch (lex->sql_command) {\n    case SQLCOM_CREATE_EVENT:\n    {\n      res= Events::create_event(thd, lex->event_parse_data);\n      break;\n    }\n    case SQLCOM_ALTER_EVENT:\n      res= Events::update_event(thd, lex->event_parse_data,\n                                lex->spname ? &lex->spname->m_db : NULL,\n                                lex->spname ? &lex->spname->m_name : NULL);\n      break;\n    default:\n      DBUG_ASSERT(0);\n    }\n    DBUG_PRINT(\"info\",(\"DDL error code=%d\", res));\n    if (!res)\n      my_ok(thd);\n\n  } while (0);\n  /* Don't do it, if we are inside a SP */\n  if (!thd->spcont)\n  {\n    sp_head::destroy(lex->sphead);\n    lex->sphead= NULL;\n  }\n  /* lex->unit.cleanup() is called outside, no need to call it here */\n  break;\n  case SQLCOM_SHOW_CREATE_EVENT:\n    WSREP_SYNC_WAIT(thd, WSREP_SYNC_WAIT_BEFORE_SHOW);\n    res= Events::show_create_event(thd, &lex->spname->m_db,\n                                   &lex->spname->m_name);\n    break;\n  case SQLCOM_DROP_EVENT:\n    if (!(res= Events::drop_event(thd,\n                                  &lex->spname->m_db, &lex->spname->m_name,\n                                  lex->if_exists())))\n      my_ok(thd);\n    break;\n#else\n    my_error(ER_NOT_SUPPORTED_YET,MYF(0),\"embedded server\");\n    break;\n#endif\n  case SQLCOM_CREATE_FUNCTION:                  // UDF function\n  {\n    if (check_access(thd, lex->create_info.or_replace() ?\n                          (INSERT_ACL | DELETE_ACL) : INSERT_ACL,\n                     \"mysql\", NULL, NULL, 1, 0))\n      break;\n#ifdef HAVE_DLOPEN\n    WSREP_TO_ISOLATION_BEGIN(WSREP_MYSQL_DB, NULL, NULL);\n    if (!(res = mysql_create_function(thd, &lex->udf)))\n      my_ok(thd);\n#else\n    my_error(ER_CANT_OPEN_LIBRARY, MYF(0), lex->udf.dl, 0, \"feature disabled\");\n    res= TRUE;\n#endif\n    break;\n  }\n#ifndef NO_EMBEDDED_ACCESS_CHECKS\n  case SQLCOM_CREATE_USER:\n  case SQLCOM_CREATE_ROLE:\n  {\n    if (check_access(thd, lex->create_info.or_replace() ?\n                          INSERT_ACL | DELETE_ACL : INSERT_ACL,\n                     \"mysql\", NULL, NULL, 1, 1) &&\n        check_global_access(thd,CREATE_USER_ACL))\n      break;\n    WSREP_TO_ISOLATION_BEGIN(WSREP_MYSQL_DB, NULL, NULL);\n    /* Conditionally writes to binlog */\n    if (!(res= mysql_create_user(thd, lex->users_list,\n                                 lex->sql_command == SQLCOM_CREATE_ROLE)))\n      my_ok(thd);\n    break;\n  }\n  case SQLCOM_DROP_USER:\n  case SQLCOM_DROP_ROLE:\n  {\n    if (check_access(thd, DELETE_ACL, \"mysql\", NULL, NULL, 1, 1) &&\n        check_global_access(thd,CREATE_USER_ACL))\n      break;\n    /* Conditionally writes to binlog */\n    WSREP_TO_ISOLATION_BEGIN(WSREP_MYSQL_DB, NULL, NULL);\n    if (!(res= mysql_drop_user(thd, lex->users_list,\n                               lex->sql_command == SQLCOM_DROP_ROLE)))\n      my_ok(thd);\n    break;\n  }\n  case SQLCOM_ALTER_USER:\n  case SQLCOM_RENAME_USER:\n  {\n    if (check_access(thd, UPDATE_ACL, \"mysql\", NULL, NULL, 1, 1) &&\n        check_global_access(thd,CREATE_USER_ACL))\n      break;\n    /* Conditionally writes to binlog */\n    WSREP_TO_ISOLATION_BEGIN(WSREP_MYSQL_DB, NULL, NULL);\n    if (lex->sql_command == SQLCOM_ALTER_USER)\n      res= mysql_alter_user(thd, lex->users_list);\n    else\n      res= mysql_rename_user(thd, lex->users_list);\n    if (!res)\n      my_ok(thd);\n    break;\n  }\n  case SQLCOM_REVOKE_ALL:\n  {\n    if (check_access(thd, UPDATE_ACL, \"mysql\", NULL, NULL, 1, 1) &&\n        check_global_access(thd,CREATE_USER_ACL))\n      break;\n\n    /* Conditionally writes to binlog */\n    WSREP_TO_ISOLATION_BEGIN(WSREP_MYSQL_DB, NULL, NULL);\n    if (!(res = mysql_revoke_all(thd, lex->users_list)))\n      my_ok(thd);\n    break;\n  }\n  case SQLCOM_REVOKE:\n  case SQLCOM_GRANT:\n  {\n    if (lex->type != TYPE_ENUM_PROXY &&\n        check_access(thd, lex->grant | lex->grant_tot_col | GRANT_ACL,\n                     first_table ?  first_table->db.str : select_lex->db.str,\n                     first_table ? &first_table->grant.privilege : NULL,\n                     first_table ? &first_table->grant.m_internal : NULL,\n                     first_table ? 0 : 1, 0))\n      goto error;\n\n    /* Replicate current user as grantor */\n    thd->binlog_invoker(false);\n\n    if (thd->security_ctx->user)              // If not replication\n    {\n      LEX_USER *user;\n      bool first_user= TRUE;\n\n      List_iterator <LEX_USER> user_list(lex->users_list);\n      while ((user= user_list++))\n      {\n        if (specialflag & SPECIAL_NO_RESOLVE &&\n            hostname_requires_resolving(user->host.str))\n          push_warning_printf(thd, Sql_condition::WARN_LEVEL_WARN,\n                              ER_WARN_HOSTNAME_WONT_WORK,\n                              ER_THD(thd, ER_WARN_HOSTNAME_WONT_WORK));\n\n        /*\n          GRANT/REVOKE PROXY has the target user as a first entry in the list. \n         */\n        if (lex->type == TYPE_ENUM_PROXY && first_user)\n        {\n          if (!(user= get_current_user(thd, user)) || !user->host.str)\n            goto error;\n\n          first_user= FALSE;\n          if (acl_check_proxy_grant_access (thd, user->host.str, user->user.str,\n                                        lex->grant & GRANT_ACL))\n            goto error;\n        } \n      }\n    }\n    if (first_table)\n    {\n      const Sp_handler *sph= Sp_handler::handler((stored_procedure_type)\n                                                 lex->type);\n      if (sph)\n      {\n        uint grants= lex->all_privileges \n\t\t   ? (PROC_ACLS & ~GRANT_ACL) | (lex->grant & GRANT_ACL)\n\t\t   : lex->grant;\n        if (check_grant_routine(thd, grants | GRANT_ACL, all_tables, sph, 0))\n\t  goto error;\n        /* Conditionally writes to binlog */\n        WSREP_TO_ISOLATION_BEGIN(WSREP_MYSQL_DB, NULL, NULL);\n        res= mysql_routine_grant(thd, all_tables, sph,\n                                 lex->users_list, grants,\n                                 lex->sql_command == SQLCOM_REVOKE, TRUE);\n        if (!res)\n          my_ok(thd);\n      }\n      else\n      {\n\tif (check_grant(thd,(lex->grant | lex->grant_tot_col | GRANT_ACL),\n                        all_tables, FALSE, UINT_MAX, FALSE))\n\t  goto error;\n        /* Conditionally writes to binlog */\n        WSREP_TO_ISOLATION_BEGIN(WSREP_MYSQL_DB, NULL, NULL);\n        res= mysql_table_grant(thd, all_tables, lex->users_list,\n\t\t\t       lex->columns, lex->grant,\n\t\t\t       lex->sql_command == SQLCOM_REVOKE);\n      }\n    }\n    else\n    {\n      if (lex->columns.elements || (lex->type && lex->type != TYPE_ENUM_PROXY))\n      {\n\tmy_message(ER_ILLEGAL_GRANT_FOR_TABLE, ER_THD(thd, ER_ILLEGAL_GRANT_FOR_TABLE),\n                   MYF(0));\n        goto error;\n      }\n      else\n      {\n        WSREP_TO_ISOLATION_BEGIN(WSREP_MYSQL_DB, NULL, NULL);\n        /* Conditionally writes to binlog */\n        res= mysql_grant(thd, select_lex->db.str, lex->users_list, lex->grant,\n                         lex->sql_command == SQLCOM_REVOKE,\n                         lex->type == TYPE_ENUM_PROXY);\n      }\n      if (!res)\n      {\n\tif (lex->sql_command == SQLCOM_GRANT)\n\t{\n\t  List_iterator <LEX_USER> str_list(lex->users_list);\n\t  LEX_USER *user, *tmp_user;\n\t  while ((tmp_user=str_list++))\n          {\n            if (!(user= get_current_user(thd, tmp_user)))\n              goto error;\n\t    reset_mqh(user, 0);\n          }\n\t}\n      }\n    }\n    break;\n  }\n  case SQLCOM_REVOKE_ROLE:\n  case SQLCOM_GRANT_ROLE:\n  {\n    WSREP_TO_ISOLATION_BEGIN(WSREP_MYSQL_DB, NULL, NULL);\n    if (!(res= mysql_grant_role(thd, lex->users_list,\n                                lex->sql_command != SQLCOM_GRANT_ROLE)))\n      my_ok(thd);\n    break;\n  }\n#endif /*!NO_EMBEDDED_ACCESS_CHECKS*/\n  case SQLCOM_RESET:\n    /*\n      RESET commands are never written to the binary log, so we have to\n      initialize this variable because RESET shares the same code as FLUSH\n    */\n    lex->no_write_to_binlog= 1;\n    /* fall through */\n  case SQLCOM_FLUSH:\n  {\n    int write_to_binlog;\n    if (check_global_access(thd,RELOAD_ACL))\n      goto error;\n\n    if (first_table && lex->type & (REFRESH_READ_LOCK|REFRESH_FOR_EXPORT))\n    {\n      /* Check table-level privileges. */\n      if (check_table_access(thd, PRIV_LOCK_TABLES, all_tables,\n                             FALSE, UINT_MAX, FALSE))\n        goto error;\n\n      if (flush_tables_with_read_lock(thd, all_tables))\n        goto error;\n\n      my_ok(thd);\n      break;\n    }\n\n#ifdef WITH_WSREP\n    if (lex->type & (\n    REFRESH_GRANT                           |\n    REFRESH_HOSTS                           |\n#ifdef HAVE_OPENSSL\n    REFRESH_DES_KEY_FILE                    |\n#endif\n    /*\n      Write all flush log statements except\n      FLUSH LOGS\n      FLUSH BINARY LOGS\n      Check reload_acl_and_cache for why.\n    */\n    REFRESH_RELAY_LOG                       |\n    REFRESH_SLOW_LOG                        |\n    REFRESH_GENERAL_LOG                     |\n    REFRESH_ENGINE_LOG                      |\n    REFRESH_ERROR_LOG                       |\n#ifdef HAVE_QUERY_CACHE\n    REFRESH_QUERY_CACHE_FREE                |\n#endif /* HAVE_QUERY_CACHE */\n    REFRESH_STATUS                          |\n    REFRESH_USER_RESOURCES))\n    {\n      WSREP_TO_ISOLATION_BEGIN_WRTCHK(WSREP_MYSQL_DB, NULL, NULL);\n    }\n#endif /* WITH_WSREP*/\n\n#ifdef HAVE_REPLICATION\n    if (lex->type & REFRESH_READ_LOCK)\n    {\n      /*\n        We need to pause any parallel replication slave workers during FLUSH\n        TABLES WITH READ LOCK. Otherwise we might cause a deadlock, as\n        worker threads eun run in arbitrary order but need to commit in a\n        specific given order.\n      */\n      if (rpl_pause_for_ftwrl(thd))\n        goto error;\n    }\n#endif\n    /*\n      reload_acl_and_cache() will tell us if we are allowed to write to the\n      binlog or not.\n    */\n    if (!reload_acl_and_cache(thd, lex->type, first_table, &write_to_binlog))\n    {\n#ifdef WITH_WSREP\n      if ((lex->type & REFRESH_TABLES) && !(lex->type & (REFRESH_FOR_EXPORT|REFRESH_READ_LOCK)))\n      {\n        /*\n          This is done after reload_acl_and_cache is because\n          LOCK TABLES is not replicated in galera, the upgrade of which\n          is checked in reload_acl_and_cache.\n          Hence, done after/if we are able to upgrade locks.\n        */\n        if (first_table)\n        {\n          WSREP_TO_ISOLATION_BEGIN_WRTCHK(NULL, NULL, first_table);\n        }\n        else\n        {\n          WSREP_TO_ISOLATION_BEGIN_WRTCHK(WSREP_MYSQL_DB, NULL, NULL);\n        }\n      }\n#endif /* WITH_WSREP */\n      /*\n        We WANT to write and we CAN write.\n        ! we write after unlocking the table.\n      */\n      /*\n        Presumably, RESET and binlog writing doesn't require synchronization\n      */\n\n      if (write_to_binlog > 0)  // we should write\n      { \n        if (!lex->no_write_to_binlog)\n          res= write_bin_log(thd, FALSE, thd->query(), thd->query_length());\n      } else if (write_to_binlog < 0) \n      {\n        /* \n           We should not write, but rather report error because \n           reload_acl_and_cache binlog interactions failed \n         */\n        res= 1;\n      }\n\n      if (!res)\n        my_ok(thd);\n    } \n    else\n      res= 1;                                   // reload_acl_and_cache failed\n#ifdef HAVE_REPLICATION\n    if (lex->type & REFRESH_READ_LOCK)\n      rpl_unpause_after_ftwrl(thd);\n#endif\n    \n    break;\n  }\n  case SQLCOM_KILL:\n  {\n    if (lex->table_or_sp_used())\n    {\n      my_error(ER_SUBQUERIES_NOT_SUPPORTED, MYF(0), \"KILL\");\n      break;\n    }\n\n    if (lex->kill_type == KILL_TYPE_ID || lex->kill_type == KILL_TYPE_QUERY)\n    {\n      Item *it= (Item *)lex->value_list.head();\n      if (it->fix_fields_if_needed_for_scalar(lex->thd, &it))\n      {\n        my_message(ER_SET_CONSTANTS_ONLY, ER_THD(thd, ER_SET_CONSTANTS_ONLY),\n                   MYF(0));\n        goto error;\n      }\n      sql_kill(thd, it->val_int(), lex->kill_signal, lex->kill_type);\n    }\n    else\n      sql_kill_user(thd, get_current_user(thd, lex->users_list.head()),\n                    lex->kill_signal);\n    break;\n  }\n  case SQLCOM_SHUTDOWN:\n#ifndef EMBEDDED_LIBRARY\n    DBUG_EXECUTE_IF(\"crash_shutdown\", DBUG_SUICIDE(););\n    if (check_global_access(thd,SHUTDOWN_ACL))\n      goto error;\n    kill_mysql(thd);\n    my_ok(thd);\n#else\n    my_error(ER_NOT_SUPPORTED_YET, MYF(0), \"embedded server\");\n#endif\n    break;\n\n#ifndef NO_EMBEDDED_ACCESS_CHECKS\n  case SQLCOM_SHOW_CREATE_USER:\n  {\n    LEX_USER *grant_user= lex->grant_user;\n    if (!grant_user)\n      goto error;\n\n    res = mysql_show_create_user(thd, grant_user);\n    break;\n  }\n  case SQLCOM_SHOW_GRANTS:\n  {\n    LEX_USER *grant_user= lex->grant_user;\n    if (!grant_user)\n      goto error;\n\n    WSREP_SYNC_WAIT(thd, WSREP_SYNC_WAIT_BEFORE_SHOW);\n    res = mysql_show_grants(thd, grant_user);\n    break;\n  }\n#endif\n  case SQLCOM_HA_OPEN:\n    DBUG_ASSERT(first_table == all_tables && first_table != 0);\n    if (check_table_access(thd, SELECT_ACL, all_tables, FALSE, UINT_MAX, FALSE))\n      goto error;\n    /* Close temporary tables which were pre-opened for privilege checking. */\n    close_thread_tables(thd);\n    all_tables->table= NULL;\n    res= mysql_ha_open(thd, first_table, 0);\n    break;\n  case SQLCOM_HA_CLOSE:\n    DBUG_ASSERT(first_table == all_tables && first_table != 0);\n    res= mysql_ha_close(thd, first_table);\n    break;\n  case SQLCOM_HA_READ:\n    DBUG_ASSERT(first_table == all_tables && first_table != 0);\n    /*\n      There is no need to check for table permissions here, because\n      if a user has no permissions to read a table, he won't be\n      able to open it (with SQLCOM_HA_OPEN) in the first place.\n    */\n    unit->set_limit(select_lex);\n\n    res= mysql_ha_read(thd, first_table, lex->ha_read_mode, lex->ident.str,\n                       lex->insert_list, lex->ha_rkey_mode, select_lex->where,\n                       unit->select_limit_cnt, unit->offset_limit_cnt);\n    break;\n\n  case SQLCOM_BEGIN:\n    DBUG_PRINT(\"info\", (\"Executing SQLCOM_BEGIN  thd: %p\", thd));\n    if (trans_begin(thd, lex->start_transaction_opt))\n    {\n      thd->release_transactional_locks();\n      WSREP_DEBUG(\"BEGIN failed, MDL released: %lld\",\n                  (longlong) thd->thread_id);\n      WSREP_DEBUG(\"stmt_da, sql_errno: %d\", (thd->get_stmt_da()->is_error()) ? thd->get_stmt_da()->sql_errno() : 0);\n      goto error;\n    }\n    my_ok(thd);\n    break;\n  case SQLCOM_COMMIT:\n  {\n    DBUG_ASSERT(thd->lock == NULL ||\n                thd->locked_tables_mode == LTM_LOCK_TABLES);\n    bool tx_chain= (lex->tx_chain == TVL_YES ||\n                    (thd->variables.completion_type == 1 &&\n                     lex->tx_chain != TVL_NO));\n    bool tx_release= (lex->tx_release == TVL_YES ||\n                      (thd->variables.completion_type == 2 &&\n                       lex->tx_release != TVL_NO));\n    bool commit_failed= trans_commit(thd);\n    thd->release_transactional_locks();\n    if (commit_failed)\n    {\n      WSREP_DEBUG(\"COMMIT failed, MDL released: %lld\",\n                  (longlong) thd->thread_id);\n      goto error;\n    }\n    /* Begin transaction with the same isolation level. */\n    if (tx_chain)\n    {\n      if (trans_begin(thd))\n        goto error;\n    }\n    else\n    {\n      /* Reset the isolation level and access mode if no chaining transaction.*/\n      trans_reset_one_shot_chistics(thd);\n    }\n    /* Disconnect the current client connection. */\n    if (tx_release)\n    {\n      thd->set_killed(KILL_CONNECTION);\n      thd->print_aborted_warning(3, \"RELEASE\");\n    }\n    my_ok(thd);\n    break;\n  }\n  case SQLCOM_ROLLBACK:\n  {\n    DBUG_ASSERT(thd->lock == NULL ||\n                thd->locked_tables_mode == LTM_LOCK_TABLES);\n    bool tx_chain= (lex->tx_chain == TVL_YES ||\n                    (thd->variables.completion_type == 1 &&\n                     lex->tx_chain != TVL_NO));\n    bool tx_release= (lex->tx_release == TVL_YES ||\n                      (thd->variables.completion_type == 2 &&\n                       lex->tx_release != TVL_NO));\n    bool rollback_failed= trans_rollback(thd);\n    thd->release_transactional_locks();\n\n    if (rollback_failed)\n    {\n      WSREP_DEBUG(\"rollback failed, MDL released: %lld\",\n                  (longlong) thd->thread_id);\n      goto error;\n    }\n    /* Begin transaction with the same isolation level. */\n    if (tx_chain)\n    {\n#ifdef WITH_WSREP\n      /* If there are pending changes after rollback we should clear them */\n      if (wsrep_on(thd) && wsrep_has_changes(thd))\n        wsrep_after_statement(thd);\n#endif\n      if (trans_begin(thd))\n        goto error;\n    }\n    else\n    {\n      /* Reset the isolation level and access mode if no chaining transaction.*/\n      trans_reset_one_shot_chistics(thd);\n    }\n    /* Disconnect the current client connection. */\n    if (tx_release)\n      thd->set_killed(KILL_CONNECTION);\n    my_ok(thd);\n   break;\n  }\n  case SQLCOM_RELEASE_SAVEPOINT:\n    if (trans_release_savepoint(thd, lex->ident))\n      goto error;\n    my_ok(thd);\n    break;\n  case SQLCOM_ROLLBACK_TO_SAVEPOINT:\n    if (trans_rollback_to_savepoint(thd, lex->ident))\n      goto error;\n    my_ok(thd);\n    break;\n  case SQLCOM_SAVEPOINT:\n    if (trans_savepoint(thd, lex->ident))\n      goto error;\n    my_ok(thd);\n    break;\n  case SQLCOM_CREATE_PROCEDURE:\n  case SQLCOM_CREATE_SPFUNCTION:\n  case SQLCOM_CREATE_PACKAGE:\n  case SQLCOM_CREATE_PACKAGE_BODY:\n  {\n    if (mysql_create_routine(thd, lex))\n      goto error;\n    my_ok(thd);\n    break; /* break super switch */\n  } /* end case group bracket */\n  case SQLCOM_COMPOUND:\n    DBUG_ASSERT(all_tables == 0);\n    DBUG_ASSERT(thd->in_sub_stmt == 0);\n    lex->sphead->m_sql_mode= thd->variables.sql_mode;\n    if (do_execute_sp(thd, lex->sphead))\n      goto error;\n    break;\n\n  case SQLCOM_ALTER_PROCEDURE:\n  case SQLCOM_ALTER_FUNCTION:\n    {\n      int sp_result;\n      const Sp_handler *sph= Sp_handler::handler(lex->sql_command);\n      if (check_routine_access(thd, ALTER_PROC_ACL, &lex->spname->m_db,\n                               &lex->spname->m_name, sph, 0))\n        goto error;\n\n      /*\n        Note that if you implement the capability of ALTER FUNCTION to\n        alter the body of the function, this command should be made to\n        follow the restrictions that log-bin-trust-function-creators=0\n        already puts on CREATE FUNCTION.\n      */\n      /* Conditionally writes to binlog */\n      sp_result= sph->sp_update_routine(thd, lex->spname, &lex->sp_chistics);\n      switch (sp_result)\n      {\n      case SP_OK:\n\tmy_ok(thd);\n\tbreak;\n      case SP_KEY_NOT_FOUND:\n\tmy_error(ER_SP_DOES_NOT_EXIST, MYF(0),\n                 sph->type_str(), ErrConvDQName(lex->spname).ptr());\n\tgoto error;\n      default:\n\tmy_error(ER_SP_CANT_ALTER, MYF(0),\n                 sph->type_str(), ErrConvDQName(lex->spname).ptr());\n\tgoto error;\n      }\n      break;\n    }\n  case SQLCOM_DROP_PROCEDURE:\n  case SQLCOM_DROP_FUNCTION:\n  case SQLCOM_DROP_PACKAGE:\n  case SQLCOM_DROP_PACKAGE_BODY:\n    {\n#ifdef HAVE_DLOPEN\n      if (lex->sql_command == SQLCOM_DROP_FUNCTION &&\n          ! lex->spname->m_explicit_name)\n      {\n        /* DROP FUNCTION <non qualified name> */\n        enum drop_udf_result rc= mysql_drop_function(thd,\n                                                     &lex->spname->m_name);\n        if (rc == UDF_DEL_RESULT_DELETED)\n        {\n          my_ok(thd);\n          break;\n        }\n\n        if (rc == UDF_DEL_RESULT_ERROR)\n          goto error;\n\n        DBUG_ASSERT(rc == UDF_DEL_RESULT_ABSENT);\n\n        // If there was no current database, so it can not be SP\n        if (lex->spname->m_db.str == NULL)\n        {\n          if (lex->if_exists())\n          {\n            push_warning_printf(thd, Sql_condition::WARN_LEVEL_NOTE,\n                                ER_SP_DOES_NOT_EXIST, ER_THD(thd, ER_SP_DOES_NOT_EXIST),\n                                \"FUNCTION (UDF)\", lex->spname->m_name.str);\n            res= FALSE;\n            my_ok(thd);\n            break;\n          }\n          my_error(ER_SP_DOES_NOT_EXIST, MYF(0),\n                   \"FUNCTION (UDF)\", lex->spname->m_name.str);\n          goto error;\n        }\n        /* Fall thought to test for a stored function */\n      }\n#endif\n\n      int sp_result;\n      const Sp_handler *sph= Sp_handler::handler(lex->sql_command);\n\n      if (check_routine_access(thd, ALTER_PROC_ACL, &lex->spname->m_db, &lex->spname->m_name,\n                               Sp_handler::handler(lex->sql_command), 0))\n        goto error;\n      WSREP_TO_ISOLATION_BEGIN(WSREP_MYSQL_DB, NULL, NULL);\n\n      /* Conditionally writes to binlog */\n      sp_result= sph->sp_drop_routine(thd, lex->spname);\n\n#ifndef NO_EMBEDDED_ACCESS_CHECKS\n      /*\n        We're going to issue an implicit REVOKE statement so we close all\n        open tables. We have to keep metadata locks as this ensures that\n        this statement is atomic against concurent FLUSH TABLES WITH READ\n        LOCK. Deadlocks which can arise due to fact that this implicit\n        statement takes metadata locks should be detected by a deadlock\n        detector in MDL subsystem and reported as errors.\n\n        No need to commit/rollback statement transaction, it's not started.\n\n        TODO: Long-term we should either ensure that implicit REVOKE statement\n              is written into binary log as a separate statement or make both\n              dropping of routine and implicit REVOKE parts of one fully atomic\n              statement.\n      */\n      DBUG_ASSERT(thd->transaction.stmt.is_empty());\n      close_thread_tables(thd);\n\n      if (sp_result != SP_KEY_NOT_FOUND &&\n          sp_automatic_privileges && !opt_noacl &&\n          sp_revoke_privileges(thd, lex->spname->m_db.str, lex->spname->m_name.str,\n                               Sp_handler::handler(lex->sql_command)))\n      {\n        push_warning(thd, Sql_condition::WARN_LEVEL_WARN,\n                     ER_PROC_AUTO_REVOKE_FAIL,\n                     ER_THD(thd, ER_PROC_AUTO_REVOKE_FAIL));\n        /* If this happens, an error should have been reported. */\n        goto error;\n      }\n#endif\n\n      res= sp_result;\n      switch (sp_result) {\n      case SP_OK:\n\tmy_ok(thd);\n\tbreak;\n      case SP_KEY_NOT_FOUND:\n\tif (lex->if_exists())\n\t{\n          res= write_bin_log(thd, TRUE, thd->query(), thd->query_length());\n\t  push_warning_printf(thd, Sql_condition::WARN_LEVEL_NOTE,\n\t\t\t      ER_SP_DOES_NOT_EXIST, ER_THD(thd, ER_SP_DOES_NOT_EXIST),\n                              sph->type_str(),\n                              ErrConvDQName(lex->spname).ptr());\n          if (!res)\n            my_ok(thd);\n\t  break;\n\t}\n\tmy_error(ER_SP_DOES_NOT_EXIST, MYF(0),\n                 sph->type_str(), ErrConvDQName(lex->spname).ptr());\n\tgoto error;\n      default:\n\tmy_error(ER_SP_DROP_FAILED, MYF(0),\n                 sph->type_str(), ErrConvDQName(lex->spname).ptr());\n\tgoto error;\n      }\n      break;\n    }\n  case SQLCOM_SHOW_CREATE_PROC:\n  case SQLCOM_SHOW_CREATE_FUNC:\n  case SQLCOM_SHOW_CREATE_PACKAGE:\n  case SQLCOM_SHOW_CREATE_PACKAGE_BODY:\n    {\n      WSREP_SYNC_WAIT(thd, WSREP_SYNC_WAIT_BEFORE_SHOW);\n      const Sp_handler *sph= Sp_handler::handler(lex->sql_command);\n      if (sph->sp_show_create_routine(thd, lex->spname))\n        goto error;\n      break;\n    }\n  case SQLCOM_SHOW_PROC_CODE:\n  case SQLCOM_SHOW_FUNC_CODE:\n  case SQLCOM_SHOW_PACKAGE_BODY_CODE:\n    {\n#ifndef DBUG_OFF\n      Database_qualified_name pkgname(&null_clex_str, &null_clex_str);\n      sp_head *sp;\n      const Sp_handler *sph= Sp_handler::handler(lex->sql_command);\n      WSREP_SYNC_WAIT(thd, WSREP_SYNC_WAIT_BEFORE_SHOW);\n      if (sph->sp_resolve_package_routine(thd, thd->lex->sphead,\n                                          lex->spname, &sph, &pkgname))\n        return true;\n      if (sph->sp_cache_routine(thd, lex->spname, false, &sp))\n        goto error;\n      if (!sp || sp->show_routine_code(thd))\n      {\n        /* We don't distinguish between errors for now */\n        my_error(ER_SP_DOES_NOT_EXIST, MYF(0),\n                 sph->type_str(), lex->spname->m_name.str);\n        goto error;\n      }\n      break;\n#else\n      my_error(ER_FEATURE_DISABLED, MYF(0),\n               \"SHOW PROCEDURE|FUNCTION CODE\", \"--with-debug\");\n      goto error;\n#endif // ifndef DBUG_OFF\n    }\n  case SQLCOM_SHOW_CREATE_TRIGGER:\n    {\n      if (check_ident_length(&lex->spname->m_name))\n        goto error;\n\n      WSREP_SYNC_WAIT(thd, WSREP_SYNC_WAIT_BEFORE_SHOW);\n      if (show_create_trigger(thd, lex->spname))\n        goto error; /* Error has been already logged. */\n\n      break;\n    }\n  case SQLCOM_CREATE_VIEW:\n    {\n      /*\n        Note: SQLCOM_CREATE_VIEW also handles 'ALTER VIEW' commands\n        as specified through the thd->lex->create_view->mode flag.\n      */\n      res= mysql_create_view(thd, first_table, thd->lex->create_view->mode);\n      break;\n    }\n  case SQLCOM_DROP_VIEW:\n    {\n      if (check_table_access(thd, DROP_ACL, all_tables, FALSE, UINT_MAX, FALSE))\n        goto error;\n      /* Conditionally writes to binlog. */\n      WSREP_TO_ISOLATION_BEGIN(WSREP_MYSQL_DB, NULL, NULL);\n      res= mysql_drop_view(thd, first_table, thd->lex->drop_mode);\n      break;\n    }\n  case SQLCOM_CREATE_TRIGGER:\n  {\n    /* Conditionally writes to binlog. */\n    res= mysql_create_or_drop_trigger(thd, all_tables, 1);\n\n    break;\n  }\n  case SQLCOM_DROP_TRIGGER:\n  {\n    /* Conditionally writes to binlog. */\n    res= mysql_create_or_drop_trigger(thd, all_tables, 0);\n    break;\n  }\n  case SQLCOM_XA_START:\n#ifdef WITH_WSREP\n    if (WSREP_ON)\n    {\n      my_error(ER_NOT_SUPPORTED_YET, MYF(0),\n               \"XA transactions with Galera replication\");\n      break;\n    }\n#endif /* WITH_WSREP */\n    if (trans_xa_start(thd))\n      goto error;\n    my_ok(thd);\n    break;\n  case SQLCOM_XA_END:\n    if (trans_xa_end(thd))\n      goto error;\n    my_ok(thd);\n    break;\n  case SQLCOM_XA_PREPARE:\n    if (trans_xa_prepare(thd))\n      goto error;\n    my_ok(thd);\n    break;\n  case SQLCOM_XA_COMMIT:\n  {\n    bool commit_failed= trans_xa_commit(thd);\n    if (commit_failed)\n    {\n      WSREP_DEBUG(\"XA commit failed, MDL released: %lld\",\n                  (longlong) thd->thread_id);\n      goto error;\n    }\n    /*\n      We've just done a commit, reset transaction\n      isolation level and access mode to the session default.\n    */\n    trans_reset_one_shot_chistics(thd);\n    my_ok(thd);\n    break;\n  }\n  case SQLCOM_XA_ROLLBACK:\n  {\n    bool rollback_failed= trans_xa_rollback(thd);\n    if (rollback_failed)\n    {\n      WSREP_DEBUG(\"XA rollback failed, MDL released: %lld\",\n                  (longlong) thd->thread_id);\n      goto error;\n    }\n    /*\n      We've just done a rollback, reset transaction\n      isolation level and access mode to the session default.\n    */\n    trans_reset_one_shot_chistics(thd);\n    my_ok(thd);\n    break;\n  }\n  case SQLCOM_XA_RECOVER:\n    res= mysql_xa_recover(thd);\n    break;\n  case SQLCOM_ALTER_TABLESPACE:\n    if (check_global_access(thd, CREATE_TABLESPACE_ACL))\n      break;\n    if (!(res= mysql_alter_tablespace(thd, lex->alter_tablespace_info)))\n      my_ok(thd);\n    break;\n  case SQLCOM_INSTALL_PLUGIN:\n    if (! (res= mysql_install_plugin(thd, &thd->lex->comment,\n                                     &thd->lex->ident)))\n      my_ok(thd);\n    break;\n  case SQLCOM_UNINSTALL_PLUGIN:\n    if (! (res= mysql_uninstall_plugin(thd, &thd->lex->comment,\n                                       &thd->lex->ident)))\n      my_ok(thd);\n    break;\n  case SQLCOM_BINLOG_BASE64_EVENT:\n  {\n#ifndef EMBEDDED_LIBRARY\n    mysql_client_binlog_statement(thd);\n#else /* EMBEDDED_LIBRARY */\n    my_error(ER_OPTION_PREVENTS_STATEMENT, MYF(0), \"embedded\");\n#endif /* EMBEDDED_LIBRARY */\n    break;\n  }\n  case SQLCOM_CREATE_SERVER:\n  {\n    DBUG_PRINT(\"info\", (\"case SQLCOM_CREATE_SERVER\"));\n\n    if (check_global_access(thd, SUPER_ACL))\n      break;\n\n    WSREP_TO_ISOLATION_BEGIN(WSREP_MYSQL_DB, NULL, NULL);\n\n    res= create_server(thd, &lex->server_options);\n    break;\n  }\n  case SQLCOM_ALTER_SERVER:\n  {\n    int error;\n    DBUG_PRINT(\"info\", (\"case SQLCOM_ALTER_SERVER\"));\n\n    if (check_global_access(thd, SUPER_ACL))\n      break;\n\n    WSREP_TO_ISOLATION_BEGIN(WSREP_MYSQL_DB, NULL, NULL);\n\n    if (unlikely((error= alter_server(thd, &lex->server_options))))\n    {\n      DBUG_PRINT(\"info\", (\"problem altering server <%s>\",\n                          lex->server_options.server_name.str));\n      my_error(error, MYF(0), lex->server_options.server_name.str);\n      break;\n    }\n    my_ok(thd, 1);\n    break;\n  }\n  case SQLCOM_DROP_SERVER:\n  {\n    int err_code;\n    DBUG_PRINT(\"info\", (\"case SQLCOM_DROP_SERVER\"));\n\n    if (check_global_access(thd, SUPER_ACL))\n      break;\n\n    WSREP_TO_ISOLATION_BEGIN(WSREP_MYSQL_DB, NULL, NULL);\n\n    if ((err_code= drop_server(thd, &lex->server_options)))\n    {\n      if (! lex->if_exists() && err_code == ER_FOREIGN_SERVER_DOESNT_EXIST)\n      {\n        DBUG_PRINT(\"info\", (\"problem dropping server %s\",\n                            lex->server_options.server_name.str));\n        my_error(err_code, MYF(0), lex->server_options.server_name.str);\n      }\n      else\n      {\n        my_ok(thd, 0);\n      }\n      break;\n    }\n    my_ok(thd, 1);\n    break;\n  }\n  case SQLCOM_ANALYZE:\n  case SQLCOM_CHECK:\n  case SQLCOM_OPTIMIZE:\n  case SQLCOM_REPAIR:\n  case SQLCOM_TRUNCATE:\n  case SQLCOM_CREATE_TABLE:\n  case SQLCOM_CREATE_SEQUENCE:\n  case SQLCOM_ALTER_TABLE:\n      DBUG_ASSERT(first_table == all_tables && first_table != 0);\n    /* fall through */\n  case SQLCOM_ALTER_SEQUENCE:\n  case SQLCOM_SIGNAL:\n  case SQLCOM_RESIGNAL:\n  case SQLCOM_GET_DIAGNOSTICS:\n  case SQLCOM_CALL:\n    DBUG_ASSERT(lex->m_sql_cmd != NULL);\n    res= lex->m_sql_cmd->execute(thd);\n    break;\n  default:\n\n#ifndef EMBEDDED_LIBRARY\n    DBUG_ASSERT(0);                             /* Impossible */\n#endif\n    my_ok(thd);\n    break;\n  }\n  THD_STAGE_INFO(thd, stage_query_end);\n  thd->update_stats();\n\n  goto finish;\n\nerror:\n#ifdef WITH_WSREP\nwsrep_error_label:\n#endif\n  res= true;\n\nfinish:\n\n  thd->reset_query_timer();\n  DBUG_ASSERT(!thd->in_active_multi_stmt_transaction() ||\n               thd->in_multi_stmt_transaction_mode());\n\n  lex->unit.cleanup();\n\n  /* close/reopen tables that were marked to need reopen under LOCK TABLES */\n  if (unlikely(thd->locked_tables_list.some_table_marked_for_reopen) &&\n      !thd->lex->requires_prelocking())\n    thd->locked_tables_list.reopen_tables(thd, true);\n\n  if (! thd->in_sub_stmt)\n  {\n    if (thd->killed != NOT_KILLED)\n    {\n      /* report error issued during command execution */\n      if (thd->killed_errno())\n      {\n        /* If we already sent 'ok', we can ignore any kill query statements */\n        if (! thd->get_stmt_da()->is_set())\n          thd->send_kill_message();\n      }\n      thd->reset_kill_query();\n    }\n    if (unlikely(thd->is_error()) ||\n        (thd->variables.option_bits & OPTION_MASTER_SQL_ERROR))\n    {\n      THD_STAGE_INFO(thd, stage_rollback);\n      trans_rollback_stmt(thd);\n    }\n    else\n    {\n      /* If commit fails, we should be able to reset the OK status. */\n      THD_STAGE_INFO(thd, stage_commit);\n      thd->get_stmt_da()->set_overwrite_status(true);\n      trans_commit_stmt(thd);\n      thd->get_stmt_da()->set_overwrite_status(false);\n    }\n    ha_maria_implicit_commit(thd, FALSE);\n  }\n\n  /* Free tables. Set stage 'closing tables' */\n  close_thread_tables(thd);\n\n\n#ifndef DBUG_OFF\n  if (lex->sql_command != SQLCOM_SET_OPTION && ! thd->in_sub_stmt)\n    DEBUG_SYNC(thd, \"execute_command_after_close_tables\");\n#endif\n  if (!(sql_command_flags[lex->sql_command] &\n        (CF_CAN_GENERATE_ROW_EVENTS | CF_FORCE_ORIGINAL_BINLOG_FORMAT |\n         CF_STATUS_COMMAND)))\n    thd->set_binlog_format(orig_binlog_format,\n                           orig_current_stmt_binlog_format);\n\n  if (! thd->in_sub_stmt && thd->transaction_rollback_request)\n  {\n    /*\n      We are not in sub-statement and transaction rollback was requested by\n      one of storage engines (e.g. due to deadlock). Rollback transaction in\n      all storage engines including binary log.\n    */\n    THD_STAGE_INFO(thd, stage_rollback_implicit);\n    trans_rollback_implicit(thd);\n    thd->release_transactional_locks();\n  }\n  else if (stmt_causes_implicit_commit(thd, CF_IMPLICIT_COMMIT_END))\n  {\n    /* No transaction control allowed in sub-statements. */\n    DBUG_ASSERT(! thd->in_sub_stmt);\n    if (!(thd->variables.option_bits & OPTION_GTID_BEGIN))\n    {\n      THD_STAGE_INFO(thd, stage_commit_implicit);\n      /* If commit fails, we should be able to reset the OK status. */\n      thd->get_stmt_da()->set_overwrite_status(true);\n      /* Commit the normal transaction if one is active. */\n      trans_commit_implicit(thd);\n      thd->get_stmt_da()->set_overwrite_status(false);\n      thd->release_transactional_locks();\n    }\n  }\n  else if (! thd->in_sub_stmt && ! thd->in_multi_stmt_transaction_mode())\n  {\n    /*\n      - If inside a multi-statement transaction,\n      defer the release of metadata locks until the current\n      transaction is either committed or rolled back. This prevents\n      other statements from modifying the table for the entire\n      duration of this transaction.  This provides commit ordering\n      and guarantees serializability across multiple transactions.\n      - If in autocommit mode, or outside a transactional context,\n      automatically release metadata locks of the current statement.\n    */\n    thd->release_transactional_locks();\n  }\n  else if (! thd->in_sub_stmt)\n  {\n    thd->mdl_context.release_statement_locks();\n  }\n\n  THD_STAGE_INFO(thd, stage_starting_cleanup);\n\n  TRANSACT_TRACKER(add_trx_state_from_thd(thd));\n\n#ifdef WITH_WSREP\n  thd->wsrep_consistency_check= NO_CONSISTENCY_CHECK;\n  \n  WSREP_TO_ISOLATION_END;\n  /*\n    Force release of transactional locks if not in active MST and wsrep is on.\n  */\n  if (WSREP(thd) &&\n      ! thd->in_sub_stmt &&\n      ! thd->in_active_multi_stmt_transaction() &&\n      thd->mdl_context.has_transactional_locks())\n  {\n    WSREP_DEBUG(\"Forcing release of transactional locks for thd: %lld\",\n                (longlong) thd->thread_id);\n    thd->release_transactional_locks();\n  }\n\n  /*\n    Current command did not start multi STMT transaction and the command\n    did not cause commit to happen (e.g. read only). Commit the wsrep\n    transaction as empty.\n  */\n  if (!thd->in_active_multi_stmt_transaction() &&\n      !thd->in_sub_stmt &&\n      thd->wsrep_trx().active() &&\n      thd->wsrep_trx().state() == wsrep::transaction::s_executing)\n  {\n    wsrep_commit_empty(thd, true);\n  }\n\n  /* assume PA safety for next transaction */\n  thd->wsrep_PA_safe= true;\n#endif /* WITH_WSREP */\n\n  DBUG_RETURN(res || thd->is_error());\n }",
        "target": 0
    },
    {
        "func": "  void set_no_partitions() { no_partitions= true; }",
        "target": 0
    },
    {
        "func": "  bool stmt_create_routine_start(const DDL_options_st &options)\n  {\n    create_info.set(options);\n    return main_select_push() || check_create_options(options);\n  }",
        "target": 0
    },
    {
        "func": "bool do_command(THD *thd)\n{\n  bool return_value;\n  char *packet= 0;\n  ulong packet_length;\n  NET *net= &thd->net;\n  enum enum_server_command command;\n  DBUG_ENTER(\"do_command\");\n\n  /*\n    indicator of uninitialized lex => normal flow of errors handling\n    (see my_message_sql)\n  */\n  thd->lex->current_select= 0;\n\n  /*\n    This thread will do a blocking read from the client which\n    will be interrupted when the next command is received from\n    the client, the connection is closed or \"net_wait_timeout\"\n    number of seconds has passed.\n  */\n  if (!thd->skip_wait_timeout)\n    my_net_set_read_timeout(net, thd->get_net_wait_timeout());\n\n  /* Errors and diagnostics are cleared once here before query */\n  thd->clear_error(1);\n\n  net_new_transaction(net);\n\n  /* Save for user statistics */\n  thd->start_bytes_received= thd->status_var.bytes_received;\n\n  /*\n    Synchronization point for testing of KILL_CONNECTION.\n    This sync point can wait here, to simulate slow code execution\n    between the last test of thd->killed and blocking in read().\n\n    The goal of this test is to verify that a connection does not\n    hang, if it is killed at this point of execution.\n    (Bug#37780 - main.kill fails randomly)\n\n    Note that the sync point wait itself will be terminated by a\n    kill. In this case it consumes a condition broadcast, but does\n    not change anything else. The consumed broadcast should not\n    matter here, because the read/recv() below doesn't use it.\n  */\n  DEBUG_SYNC(thd, \"before_do_command_net_read\");\n\n  packet_length= my_net_read_packet(net, 1);\n\n  if (unlikely(packet_length == packet_error))\n  {\n    DBUG_PRINT(\"info\",(\"Got error %d reading command from socket %s\",\n\t\t       net->error,\n\t\t       vio_description(net->vio)));\n\n    /* Instrument this broken statement as \"statement/com/error\" */\n    thd->m_statement_psi= MYSQL_REFINE_STATEMENT(thd->m_statement_psi,\n                                                 com_statement_info[COM_END].\n                                                 m_key);\n\n\n    /* Check if we can continue without closing the connection */\n\n    /* The error must be set. */\n    DBUG_ASSERT(thd->is_error());\n    thd->protocol->end_statement();\n\n    /* Mark the statement completed. */\n    MYSQL_END_STATEMENT(thd->m_statement_psi, thd->get_stmt_da());\n    thd->m_statement_psi= NULL;\n    thd->m_digest= NULL;\n\n    if (net->error != 3)\n    {\n      return_value= TRUE;                       // We have to close it.\n      goto out;\n    }\n\n    net->error= 0;\n    return_value= FALSE;\n    goto out;\n  }\n\n  packet= (char*) net->read_pos;\n  /*\n    'packet_length' contains length of data, as it was stored in packet\n    header. In case of malformed header, my_net_read returns zero.\n    If packet_length is not zero, my_net_read ensures that the returned\n    number of bytes was actually read from network.\n    There is also an extra safety measure in my_net_read:\n    it sets packet[packet_length]= 0, but only for non-zero packets.\n  */\n  if (packet_length == 0)                       /* safety */\n  {\n    /* Initialize with COM_SLEEP packet */\n    packet[0]= (uchar) COM_SLEEP;\n    packet_length= 1;\n  }\n  /* Do not rely on my_net_read, extra safety against programming errors. */\n  packet[packet_length]= '\\0';                  /* safety */\n\n\n  command= fetch_command(thd, packet);\n\n#ifdef WITH_WSREP\n  DEBUG_SYNC(thd, \"wsrep_before_before_command\");\n  /*\n    If this command does not return a result, then we\n    instruct wsrep_before_command() to skip result handling.\n    This causes BF aborted transaction to roll back but keep\n    the error state until next command which is able to return\n    a result to the client.\n  */\n  if (wsrep_before_command(thd, wsrep_command_no_result(command)))\n  {\n    /*\n      Aborted by background rollbacker thread.\n      Handle error here and jump straight to out.\n      Notice that thd->store_globals() is called\n      in wsrep_before_command().\n    */\n    WSREP_LOG_THD(thd, \"enter found BF aborted\");\n    DBUG_ASSERT(!thd->mdl_context.has_locks());\n    DBUG_ASSERT(!thd->get_stmt_da()->is_set());\n    /* We let COM_QUIT and COM_STMT_CLOSE to execute even if wsrep aborted. */\n    if (command == COM_STMT_EXECUTE)\n    {\n      WSREP_DEBUG(\"PS BF aborted at do_command\");\n      thd->wsrep_delayed_BF_abort= true;\n    }\n    if (command != COM_STMT_CLOSE   &&\n\tcommand != COM_STMT_EXECUTE &&\n        command != COM_QUIT)\n    {\n      my_error(ER_LOCK_DEADLOCK, MYF(0));\n      WSREP_DEBUG(\"Deadlock error for: %s\", thd->query());\n      thd->reset_killed();\n      thd->mysys_var->abort     = 0;\n      thd->wsrep_retry_counter  = 0;\n\n      /* Instrument this broken statement as \"statement/com/error\" */\n      thd->m_statement_psi= MYSQL_REFINE_STATEMENT(thd->m_statement_psi,\n                                                 com_statement_info[COM_END].\n                                                 m_key);\n\n      thd->protocol->end_statement();\n\n      /* Mark the statement completed. */\n      MYSQL_END_STATEMENT(thd->m_statement_psi, thd->get_stmt_da());\n      thd->m_statement_psi= NULL;\n      thd->m_digest= NULL;\n      return_value= FALSE;\n\n      wsrep_after_command_before_result(thd);\n      goto out;\n    }\n  }\n\n  if (WSREP(thd))\n  {\n    /*\n     * bail out if DB snapshot has not been installed. We however,\n     * allow queries \"SET\" and \"SHOW\", they are trapped later in execute_command\n     */\n    if (!(thd->wsrep_applier) &&\n        (!wsrep_ready_get() || wsrep_reject_queries != WSREP_REJECT_NONE) &&\n        (server_command_flags[command] & CF_SKIP_WSREP_CHECK) == 0)\n    {\n      my_message(ER_UNKNOWN_COM_ERROR,\n                 \"WSREP has not yet prepared node for application use\", MYF(0));\n      thd->protocol->end_statement();\n\n      /* Performance Schema Interface instrumentation end. */\n      MYSQL_END_STATEMENT(thd->m_statement_psi, thd->get_stmt_da());\n      thd->m_statement_psi= NULL;\n      thd->m_digest= NULL;\n\n      return_value= FALSE;\n      wsrep_after_command_before_result(thd);\n      goto out;\n    }\n  }\n#endif /* WITH_WSREP */\n  /* Restore read timeout value */\n  my_net_set_read_timeout(net, thd->variables.net_read_timeout);\n\n  DBUG_ASSERT(packet_length);\n  DBUG_ASSERT(!thd->apc_target.is_enabled());\n  return_value= dispatch_command(command, thd, packet+1,\n                                 (uint) (packet_length-1), FALSE, FALSE);\n  DBUG_ASSERT(!thd->apc_target.is_enabled());\n\nout:\n  thd->lex->restore_set_statement_var();\n  /* The statement instrumentation must be closed in all cases. */\n  DBUG_ASSERT(thd->m_digest == NULL);\n  DBUG_ASSERT(thd->m_statement_psi == NULL);\n#ifdef WITH_WSREP\n  if (packet_length != packet_error)\n  {\n    /* there was a command to process, and before_command() has been called */\n    wsrep_after_command_after_result(thd);\n  }\n\n  if (thd->wsrep_delayed_BF_abort)\n  {\n      my_error(ER_LOCK_DEADLOCK, MYF(0));\n      WSREP_DEBUG(\"Deadlock error for PS query: %s\", thd->query());\n      thd->reset_killed();\n      thd->mysys_var->abort     = 0;\n      thd->wsrep_retry_counter  = 0;\n\n      thd->wsrep_delayed_BF_abort= false;\n  }\n#endif /* WITH_WSREP */\n  DBUG_RETURN(return_value);\n}",
        "target": 0
    },
    {
        "func": "Field_pair *get_corresponding_field_pair(Item *item,\n                                         List<Field_pair> pair_list)\n{\n  DBUG_ASSERT(item->type() == Item::FIELD_ITEM ||\n              (item->type() == Item::REF_ITEM &&\n               ((((Item_ref *) item)->ref_type() == Item_ref::VIEW_REF) ||\n               (((Item_ref *) item)->ref_type() == Item_ref::REF))));\n\n  List_iterator<Field_pair> it(pair_list);\n  Field_pair *field_pair;\n  Item_field *field_item= (Item_field *) (item->real_item());\n  while ((field_pair= it++))\n  {\n    if (field_item->field == field_pair->field)\n      return field_pair;\n  }\n  return NULL;\n}",
        "target": 0
    },
    {
        "func": "void Lex_input_stream::body_utf8_append_escape(THD *thd,\n                                               const LEX_CSTRING *txt,\n                                               CHARSET_INFO *cs,\n                                               const char *end_ptr,\n                                               my_wc_t sep)\n{\n  DBUG_ASSERT(sep == '\\'' || sep == '\"');\n  if (!m_cpp_utf8_processed_ptr)\n    return;\n  uint errors;\n  /**\n    We previously alloced m_body_utf8 to be able to store the query with all\n    strings properly escaped. See get_body_utf8_maximum_length().\n    So here we have guaranteedly enough space to append any string literal\n    with escaping. Passing txt->length*2 as \"available space\" is always safe.\n    For better safety purposes we could calculate get_body_utf8_maximum_length()\n    every time we append a string, but this would affect performance negatively,\n    so let's check that we don't get beyond the allocated buffer in\n    debug build only.\n  */\n  DBUG_ASSERT(m_body_utf8 + get_body_utf8_maximum_length(thd) >=\n              m_body_utf8_ptr + txt->length * 2);\n  uint32 cnv_length= my_convert_using_func(m_body_utf8_ptr, txt->length * 2,\n                                           &my_charset_utf8_general_ci,\n                                           get_escape_func(thd, sep),\n                                           txt->str, txt->length,\n                                           cs, cs->cset->mb_wc,\n                                           &errors);\n  m_body_utf8_ptr+= cnv_length;\n  *m_body_utf8_ptr= 0;\n  m_cpp_utf8_processed_ptr= end_ptr;\n}",
        "target": 0
    },
    {
        "func": "  bool sp_block_finalize(THD *thd, const LEX_CSTRING *end_label)\n  {\n    return sp_block_finalize(thd, Lex_spblock(), end_label);\n  }",
        "target": 0
    },
    {
        "func": "  virtual class Query_arena *query_arena()\n  {\n    DBUG_ASSERT(0);\n    return NULL;\n  }",
        "target": 0
    },
    {
        "func": "void LEX::save_values_list_state()\n{\n  current_select->save_many_values= many_values;\n  current_select->save_insert_list= insert_list;\n}",
        "target": 0
    },
    {
        "func": "  void set_delete_all_rows(ha_rows rows_arg) \n  { \n    deleting_all_rows= true;\n    scanned_rows= rows_arg;\n  }",
        "target": 0
    },
    {
        "func": "void lex_free(void)\n{                                        // Call this when daemon ends\n  DBUG_ENTER(\"lex_free\");\n  DBUG_VOID_RETURN;\n}",
        "target": 0
    },
    {
        "func": "void LEX::cleanup_lex_after_parse_error(THD *thd)\n{\n  /*\n    Delete sphead for the side effect of restoring of the original\n    LEX state, thd->lex, thd->mem_root and thd->free_list if they\n    were replaced when parsing stored procedure statements.  We\n    will never use sphead object after a parse error, so it's okay\n    to delete it only for the sake of the side effect.\n    TODO: make this functionality explicit in sp_head class.\n    Sic: we must nullify the member of the main lex, not the\n    current one that will be thrown away\n  */\n  if (thd->lex->sphead)\n  {\n    sp_package *pkg;\n    thd->lex->sphead->restore_thd_mem_root(thd);\n    if ((pkg= thd->lex->sphead->m_parent))\n    {\n      /*\n        If a syntax error happened inside a package routine definition,\n        then thd->lex points to the routine sublex. We need to restore to\n        the top level LEX.\n      */\n      DBUG_ASSERT(pkg->m_top_level_lex);\n      DBUG_ASSERT(pkg == pkg->m_top_level_lex->sphead);\n      pkg->restore_thd_mem_root(thd);\n      LEX *top= pkg->m_top_level_lex;\n      sp_package::destroy(pkg);\n      thd->lex= top;\n      thd->lex->sphead= NULL;\n    }\n    else\n    {\n      sp_head::destroy(thd->lex->sphead);\n      thd->lex->sphead= NULL;\n    }\n  }\n}",
        "target": 0
    },
    {
        "func": "  Account_options() { }",
        "target": 0
    },
    {
        "func": "Item *LEX::create_item_func_lastval(THD *thd,\n                                    const LEX_CSTRING *db,\n                                    const LEX_CSTRING *name)\n{\n  Table_ident *table_ident;\n  if (unlikely(!(table_ident=\n                 new (thd->mem_root) Table_ident(thd, db, name, false))))\n    return NULL;\n  return create_item_func_lastval(thd, table_ident);\n}",
        "target": 0
    },
    {
        "func": "bool LEX::add_grant_command(THD *thd, enum_sql_command sql_command_arg,\n                            stored_procedure_type type_arg)\n{\n  if (columns.elements)\n  {\n    thd->parse_error();\n    return true;\n  }\n  sql_command= sql_command_arg,\n  type= type_arg;\n  return false;\n}",
        "target": 0
    },
    {
        "func": "  bool sp_for_loop_finalize(THD *thd, const Lex_for_loop_st &loop)\n  {\n    return loop.is_for_loop_cursor() ?\n           sp_for_loop_cursor_finalize(thd, loop) :\n           sp_for_loop_intrange_finalize(thd, loop);\n  }",
        "target": 0
    },
    {
        "func": "  sp_lex_local(THD *thd, const LEX *oldlex)\n  {\n    /* Reset most stuff. */\n    start(thd);\n    /* Keep the parent SP stuff */\n    sphead= oldlex->sphead;\n    spcont= oldlex->spcont;\n    /* Keep the parent trigger stuff too */\n    trg_chistics= oldlex->trg_chistics;\n    trg_table_fields.empty();\n    sp_lex_in_use= false;\n  }",
        "target": 0
    },
    {
        "func": "bool st_select_lex::init_nested_join(THD *thd)\n{\n  TABLE_LIST *ptr;\n  NESTED_JOIN *nested_join;\n  DBUG_ENTER(\"init_nested_join\");\n\n  if (unlikely(!(ptr= (TABLE_LIST*) thd->calloc(ALIGN_SIZE(sizeof(TABLE_LIST))+\n                                                sizeof(NESTED_JOIN)))))\n    DBUG_RETURN(1);\n  nested_join= ptr->nested_join=\n    ((NESTED_JOIN*) ((uchar*) ptr + ALIGN_SIZE(sizeof(TABLE_LIST))));\n\n  ptr->embedding= embedding;\n  ptr->join_list= join_list;\n  ptr->alias.str=\"(nested_join)\";\n  ptr->alias.length= sizeof(\"(nested_join)\")-1;\n  embedding= ptr;\n  join_list= &nested_join->join_list;\n  join_list->empty();\n  DBUG_RETURN(0);\n}",
        "target": 0
    },
    {
        "func": "bool LEX::sp_body_finalize_procedure(THD *thd)\n{\n  return sphead->check_group_aggregate_instructions_forbid() ||\n         sp_body_finalize_routine(thd);\n}",
        "target": 0
    },
    {
        "func": "void st_select_lex_node::link_chain_down(st_select_lex_node *first)\n{\n  st_select_lex_node *last_node;\n  st_select_lex_node *node= first;\n  do\n  {\n    last_node= node;\n    node->master= this;\n    node= node->next;\n  } while (node);\n  if ((last_node->next= slave))\n  {\n    slave->prev= &last_node->next;\n  }\n  first->prev= &slave;\n  slave= first;\n}",
        "target": 0
    },
    {
        "func": "bool LEX::sp_for_loop_outer_block_finalize(THD *thd,\n                                           const Lex_for_loop_st &loop)\n{\n  Lex_spblock tmp;\n  tmp.curs= MY_TEST(loop.m_implicit_cursor);\n  if (unlikely(sp_block_finalize(thd, tmp))) // The outer DECLARE..BEGIN..END\n    return true;\n  if (!loop.is_for_loop_explicit_cursor())\n    return false;\n  /*\n    Explicit cursor FOR loop must close the cursor automatically.\n    Note, implicit cursor FOR loop does not need to close the cursor,\n    it's closed by sp_instr_cpop.\n  */\n  sp_instr_cclose *ic= new (thd->mem_root)\n                       sp_instr_cclose(sphead->instructions(), spcont,\n                                       loop.m_cursor_offset);\n  return ic == NULL || sphead->add_instr(ic);\n}",
        "target": 0
    },
    {
        "func": "bool LEX::select_finalize(st_select_lex_unit *expr)\n{\n  sql_command= SQLCOM_SELECT;\n  selects_allow_into= TRUE;\n  selects_allow_procedure= TRUE;\n  if (set_main_unit(expr))\n    return true;\n  return check_main_unit_semantics();\n}",
        "target": 0
    },
    {
        "func": "  bool init(THD *thd, char *buff, size_t length)\n  {\n    return m_lip.init(thd, buff, length);\n  }",
        "target": 0
    },
    {
        "func": "  bool add_create_index(Key::Keytype key_type, const LEX_CSTRING *key_name,\n                        ha_key_alg algorithm, DDL_options_st ddl)\n  {\n    if (check_create_options(ddl) ||\n       !(last_key= new Key(key_type, key_name, algorithm, false, ddl)))\n      return true;\n    alter_info.key_list.push_back(last_key);\n    return false;\n  }",
        "target": 0
    },
    {
        "func": "void st_select_lex_unit::fix_distinct()\n{\n  if (union_distinct && this != union_distinct->master_unit())\n    reset_distinct();\n}",
        "target": 0
    },
    {
        "func": "int ORAlex(YYSTYPE *yylval, THD *thd)\n{\n  return thd->m_parser_state->m_lip.lex_token(yylval, thd);\n}",
        "target": 0
    },
    {
        "func": "  ~Query_tables_list() {}",
        "target": 0
    },
    {
        "func": "  void set_ident(const char *s, size_t len, bool is_8bit)\n  {\n    set(s, len, is_8bit, '\\0');\n  }",
        "target": 0
    },
    {
        "func": "void st_select_lex::pushdown_cond_into_where_clause(THD *thd, Item *cond,\n                                                    Item **remaining_cond,\n                                                    Item_transformer transformer,\n                                                    uchar *arg)\n{\n  if (!cond_pushdown_is_allowed())\n    return;\n  thd->lex->current_select= this;\n  if (have_window_funcs())\n  {\n    Item *cond_over_partition_fields;\n    check_cond_extraction_for_grouping_fields(thd, cond);\n    cond_over_partition_fields=\n      build_cond_for_grouping_fields(thd, cond, true);\n    if (cond_over_partition_fields)\n      cond_over_partition_fields= cond_over_partition_fields->transform(thd,\n                                &Item::grouping_field_transformer_for_where,\n                                (uchar*) this);\n    if (cond_over_partition_fields)\n    {\n      cond_over_partition_fields->walk(\n        &Item::cleanup_excluding_const_fields_processor, 0, 0);\n      cond_pushed_into_where= cond_over_partition_fields;\n    }\n\n    return;\n  }\n\n  if (!join->group_list && !with_sum_func)\n  {\n    cond= transform_condition_or_part(thd, cond, transformer, arg);\n    if (cond)\n    {\n      cond->walk(\n        &Item::cleanup_excluding_const_fields_processor, 0, 0);\n      cond_pushed_into_where= cond;\n    }\n\n    return;\n  }\n\n  /*\n    Figure out what can be extracted from cond and pushed into\n    the WHERE clause of this select.\n  */\n  Item *cond_over_grouping_fields;\n  check_cond_extraction_for_grouping_fields(thd, cond);\n  cond_over_grouping_fields=\n    build_cond_for_grouping_fields(thd, cond, true);\n\n  /*\n    Transform references to the columns of condition that can be pushed\n    into WHERE so it can be pushed.\n  */\n  if (cond_over_grouping_fields)\n  {\n    cond_over_grouping_fields= \n       transform_condition_or_part(thd, cond_over_grouping_fields,\n                                   &Item::grouping_field_transformer_for_where,\n                                   (uchar*) this);\n  }\n\n  if (cond_over_grouping_fields)\n  {\n\n    /*\n      Remove top conjuncts in cond that has been pushed into the WHERE\n      clause of this select\n    */\n    cond= remove_pushed_top_conjuncts(thd, cond);\n\n    cond_over_grouping_fields->walk(\n      &Item::cleanup_excluding_const_fields_processor, 0, 0);\n    cond_pushed_into_where= cond_over_grouping_fields;\n  }\n\n  *remaining_cond= cond;\n}",
        "target": 0
    },
    {
        "func": "Item *LEX::create_item_ident(THD *thd,\n                             const Lex_ident_cli_st *ca,\n                             const Lex_ident_cli_st *cb)\n{\n  const char *start= ca->pos();\n  const char *end= cb->end();\n  const Sp_rcontext_handler *rh;\n  sp_variable *spv;\n  DBUG_ASSERT(thd->m_parser_state->m_lip.get_buf() <= start);\n  DBUG_ASSERT(start <= end);\n  DBUG_ASSERT(end <= thd->m_parser_state->m_lip.get_end_of_query());\n  Lex_ident_sys a(thd, ca), b(thd, cb);\n  if (a.is_null() || b.is_null())\n    return NULL; // OEM\n  if ((spv= find_variable(&a, &rh)) &&\n      (spv->field_def.is_row() ||\n       spv->field_def.is_table_rowtype_ref() ||\n       spv->field_def.is_cursor_rowtype_ref()))\n    return create_item_spvar_row_field(thd, rh, &a, &b, spv, start, end);\n\n  if ((thd->variables.sql_mode & MODE_ORACLE) && b.length == 7)\n  {\n    if (!my_strnncoll(system_charset_info,\n                      (const uchar *) b.str, 7,\n                      (const uchar *) \"NEXTVAL\", 7))\n      return create_item_func_nextval(thd, &null_clex_str, &a);\n    else if (!my_strnncoll(system_charset_info,\n                          (const uchar *) b.str, 7,\n                          (const uchar *) \"CURRVAL\", 7))\n      return create_item_func_lastval(thd, &null_clex_str, &a);\n  }\n\n  return create_item_ident_nospvar(thd, &a, &b);\n}",
        "target": 0
    },
    {
        "func": "bool LEX::sp_proc_stmt_statement_finalize_buf(THD *thd, const LEX_CSTRING &qbuf)\n{\n  sphead->m_flags|= sp_get_flags_for_command(this);\n  /* \"USE db\" doesn't work in a procedure */\n  if (unlikely(sql_command == SQLCOM_CHANGE_DB))\n  {\n    my_error(ER_SP_BADSTATEMENT, MYF(0), \"USE\");\n    return true;\n  }\n  /*\n    Don't add an instruction for SET statements, since all\n    instructions for them were already added during processing\n    of \"set\" rule.\n  */\n  DBUG_ASSERT(sql_command != SQLCOM_SET_OPTION || var_list.is_empty());\n  if (sql_command != SQLCOM_SET_OPTION)\n    return new_sp_instr_stmt(thd, empty_clex_str, qbuf);\n  return false;\n}",
        "target": 0
    },
    {
        "func": "bool LEX::sp_while_loop_finalize(THD *thd)\n{\n  sp_label *lab= spcont->last_label();  /* Jumping back */\n  sp_instr_jump *i= new (thd->mem_root)\n    sp_instr_jump(sphead->instructions(), spcont, lab->ip);\n  if (unlikely(i == NULL) ||\n      unlikely(sphead->add_instr(i)))\n    return true;\n  sphead->do_cont_backpatch();\n  return false;\n}",
        "target": 0
    },
    {
        "func": "static bool wsrep_mysql_parse(THD *thd, char *rawbuf, uint length,\n                              Parser_state *parser_state,\n                              bool is_com_multi,\n                              bool is_next_command)\n{\n  bool is_autocommit=\n    !thd->in_multi_stmt_transaction_mode()                  &&\n    wsrep_read_only_option(thd, thd->lex->query_tables);\n  bool retry_autocommit;\n  do\n  {\n    retry_autocommit= false;\n    mysql_parse(thd, rawbuf, length, parser_state, is_com_multi, is_next_command);\n\n    /*\n      Convert all ER_QUERY_INTERRUPTED errors to ER_LOCK_DEADLOCK\n      if the transaction was BF aborted. This can happen when the\n      transaction is being BF aborted via thd->awake() while it is\n      still executing.\n\n      Note that this must be done before wsrep_after_statement() call\n      since it clears the transaction for autocommit queries.\n     */\n    if (((thd->get_stmt_da()->is_error() &&\n          thd->get_stmt_da()->sql_errno() == ER_QUERY_INTERRUPTED) ||\n         !thd->get_stmt_da()->is_set()) &&\n        thd->wsrep_trx().bf_aborted())\n    {\n      WSREP_DEBUG(\"overriding error: %d with DEADLOCK\",\n                  (thd->get_stmt_da()->is_error()) ?\n                   thd->get_stmt_da()->sql_errno() : 0);\n\n      thd->reset_kill_query();\n      wsrep_override_error(thd, ER_LOCK_DEADLOCK);\n    }\n\n#ifdef ENABLED_DEBUG_SYNC\n    /* we need the test otherwise we get stuck in the \"SET DEBUG_SYNC\" itself */\n    if (thd->lex->sql_command != SQLCOM_SET_OPTION)\n      DEBUG_SYNC(thd, \"wsrep_after_statement_enter\");\n#endif\n\n    if (wsrep_after_statement(thd) &&\n        is_autocommit              &&\n        thd_is_connection_alive(thd))\n    {\n      thd->reset_for_next_command();\n      thd->reset_kill_query();\n      if (is_autocommit                           &&\n          thd->lex->sql_command != SQLCOM_SELECT  &&\n          thd->wsrep_retry_counter < thd->variables.wsrep_retry_autocommit)\n      {\n\tDBUG_EXECUTE_IF(\"sync.wsrep_retry_autocommit\",\n                    {\n                      const char act[]=\n                        \"now \"\n                        \"SIGNAL wsrep_retry_autocommit_reached \"\n                        \"WAIT_FOR wsrep_retry_autocommit_continue\";\n                      DBUG_ASSERT(!debug_sync_set_action(thd, STRING_WITH_LEN(act)));\n                    });\n        WSREP_DEBUG(\"wsrep retrying AC query: %lu  %s\",\n                    thd->wsrep_retry_counter, wsrep_thd_query(thd));\n        wsrep_prepare_for_autocommit_retry(thd, rawbuf, length, parser_state);\n        if (thd->lex->explain)\n          delete_explain_query(thd->lex);\n        retry_autocommit= true;\n      }\n      else\n      {\n        WSREP_DEBUG(\"%s, thd: %llu is_AC: %d, retry: %lu - %lu SQL: %s\",\n                    wsrep_thd_transaction_state_str(thd),\n                    thd->thread_id,\n                    is_autocommit,\n                    thd->wsrep_retry_counter,\n                    thd->variables.wsrep_retry_autocommit,\n                    wsrep_thd_query(thd));\n        my_error(ER_LOCK_DEADLOCK, MYF(0));\n        thd->reset_kill_query();\n        thd->wsrep_retry_counter= 0;             //  reset\n      }\n    }\n    else\n    {\n      set_if_smaller(thd->wsrep_retry_counter, 0); // reset; eventually ok\n    }\n  }  while (retry_autocommit);\n\n  if (thd->wsrep_retry_query)\n  {\n    WSREP_DEBUG(\"releasing retry_query: \"\n                \"conf %s sent %d kill %d  errno %d SQL %s\",\n                wsrep_thd_transaction_state_str(thd),\n                thd->get_stmt_da()->is_sent(),\n                thd->killed,\n                thd->get_stmt_da()->is_error() ?\n                thd->get_stmt_da()->sql_errno() : 0,\n                thd->wsrep_retry_query);\n    my_free(thd->wsrep_retry_query);\n    thd->wsrep_retry_query      = NULL;\n    thd->wsrep_retry_query_len  = 0;\n    thd->wsrep_retry_command    = COM_CONNECT;\n  }\n  return false;\n}",
        "target": 0
    },
    {
        "func": "Lex_input_stream::body_utf8_append_ident(THD *thd,\n                                         const Lex_string_with_metadata_st *txt,\n                                         const char *end_ptr)\n{\n  if (!m_cpp_utf8_processed_ptr)\n    return;\n\n  LEX_CSTRING utf_txt;\n  thd->make_text_string_sys(&utf_txt, txt); // QQ: check return value?\n\n  /* NOTE: utf_txt.length is in bytes, not in symbols. */\n  memcpy(m_body_utf8_ptr, utf_txt.str, utf_txt.length);\n  m_body_utf8_ptr += utf_txt.length;\n  *m_body_utf8_ptr= 0;\n\n  m_cpp_utf8_processed_ptr= end_ptr;\n}",
        "target": 0
    },
    {
        "func": "  void mark_as_requiring_prelocking(TABLE_LIST **tables_own_last)\n  {\n    query_tables_own_last= tables_own_last;\n  }",
        "target": 0
    },
    {
        "func": "void st_select_lex::update_correlated_cache()\n{\n  TABLE_LIST *tl;\n  List_iterator<TABLE_LIST> ti(leaf_tables);\n\n  is_correlated= false;\n\n  while ((tl= ti++))\n  {\n    //    is_correlated|= tl->is_with_table_recursive_reference();\n    if (tl->on_expr)\n      is_correlated|= MY_TEST(tl->on_expr->used_tables() & OUTER_REF_TABLE_BIT);\n    for (TABLE_LIST *embedding= tl->embedding ; embedding ;\n         embedding= embedding->embedding)\n    {\n      if (embedding->on_expr)\n        is_correlated|= MY_TEST(embedding->on_expr->used_tables() &\n                                OUTER_REF_TABLE_BIT);\n    }\n  }\n\n  if (join->conds)\n    is_correlated|= MY_TEST(join->conds->used_tables() & OUTER_REF_TABLE_BIT);\n\n  is_correlated|= join->having_is_correlated;\n\n  if (join->having)\n    is_correlated|= MY_TEST(join->having->used_tables() & OUTER_REF_TABLE_BIT);\n\n  if (join->tmp_having)\n    is_correlated|= MY_TEST(join->tmp_having->used_tables() &\n                            OUTER_REF_TABLE_BIT);\n\n  Item *item;\n  List_iterator_fast<Item> it(join->fields_list);\n  while ((item= it++))\n    is_correlated|= MY_TEST(item->used_tables() & OUTER_REF_TABLE_BIT);\n\n  for (ORDER *order= group_list.first; order; order= order->next)\n    is_correlated|= MY_TEST((*order->item)->used_tables() &\n                            OUTER_REF_TABLE_BIT);\n\n  if (!master_unit()->is_unit_op())\n  {\n    for (ORDER *order= order_list.first; order; order= order->next)\n      is_correlated|= MY_TEST((*order->item)->used_tables() &\n                              OUTER_REF_TABLE_BIT);\n  }\n\n  if (!is_correlated)\n    uncacheable&= ~UNCACHEABLE_DEPENDENT;\n}",
        "target": 0
    },
    {
        "func": "Item *LEX::create_item_limit(THD *thd, const Lex_ident_cli_st *ca)\n{\n  DBUG_ASSERT(thd->m_parser_state->m_lip.get_buf() <= ca->pos());\n  DBUG_ASSERT(ca->pos() <= ca->end());\n  DBUG_ASSERT(ca->end() <= thd->m_parser_state->m_lip.get_end_of_query());\n\n  const Sp_rcontext_handler *rh;\n  sp_variable *spv;\n  Lex_ident_sys sa(thd, ca);\n  if (sa.is_null())\n    return NULL; // EOM\n  if (!(spv= find_variable(&sa, &rh)))\n  {\n    my_error(ER_SP_UNDECLARED_VAR, MYF(0), sa.str);\n    return NULL;\n  }\n\n  Query_fragment pos(thd, sphead, ca->pos(), ca->end());\n  Item_splocal *item;\n  if (unlikely(!(item= new (thd->mem_root)\n                 Item_splocal(thd, rh, &sa,\n                              spv->offset, spv->type_handler(),\n                              clone_spec_offset ? 0 : pos.pos(),\n                              clone_spec_offset ? 0 : pos.length()))))\n    return NULL;\n#ifdef DBUG_ASSERT_EXISTS\n  item->m_sp= sphead;\n#endif\n  safe_to_cache_query= 0;\n\n  if (!item->is_valid_limit_clause_variable_with_error())\n    return NULL;\n\n  item->limit_clause_param= true;\n  return item;\n}",
        "target": 0
    },
    {
        "func": "  Lex_ident_sys(const char *name, size_t length)\n  {\n    LEX_CSTRING tmp= {name, length};\n    set_valid_utf8(&tmp);\n  }",
        "target": 0
    },
    {
        "func": "bool LEX::can_be_merged()\n{\n  // TODO: do not forget implement case when select_lex.table_list.elements==0\n\n  /* find non VIEW subqueries/unions */\n  bool selects_allow_merge= (first_select_lex()->next_select() == 0 &&\n                             !(first_select_lex()->uncacheable &\n                               UNCACHEABLE_RAND));\n  if (selects_allow_merge)\n  {\n    for (SELECT_LEX_UNIT *tmp_unit= first_select_lex()->first_inner_unit();\n         tmp_unit;\n         tmp_unit= tmp_unit->next_unit())\n    {\n      if (tmp_unit->first_select()->parent_lex == this &&\n          (tmp_unit->item != 0 &&\n           (tmp_unit->item->place() != IN_WHERE &&\n            tmp_unit->item->place() != IN_ON &&\n            tmp_unit->item->place() != SELECT_LIST)))\n      {\n        selects_allow_merge= 0;\n        break;\n      }\n    }\n  }\n\n  return (selects_allow_merge &&\n          first_select_lex()->group_list.elements == 0 &&\n          first_select_lex()->having == 0 &&\n          first_select_lex()->with_sum_func == 0 &&\n          first_select_lex()->table_list.elements >= 1 &&\n          !(first_select_lex()->options & SELECT_DISTINCT) &&\n          first_select_lex()->select_limit == 0);\n}",
        "target": 0
    },
    {
        "func": "  virtual ~LEX()\n  {\n    free_set_stmt_mem_root();\n    destroy_query_tables_list();\n    plugin_unlock_list(NULL, (plugin_ref *)plugins.buffer, plugins.elements);\n    delete_dynamic(&plugins);\n  }",
        "target": 0
    },
    {
        "func": "  void reset()\n  {\n    bzero(this, sizeof(*this));\n    ssl_type= SSL_TYPE_NOT_SPECIFIED;\n  }",
        "target": 0
    },
    {
        "func": "  size_t get_body_utf8_length()\n  {\n    return (size_t) (m_body_utf8_ptr - m_body_utf8);\n  }",
        "target": 0
    },
    {
        "func": "  const char *get_tok_end()\n  {\n    return m_tok_end;\n  }",
        "target": 0
    },
    {
        "func": "bool LEX::call_statement_start(THD *thd, const LEX_CSTRING *name1,\n                                         const LEX_CSTRING *name2)\n{\n  sp_name *spname= make_sp_name(thd, name1, name2);\n  return unlikely(!spname) || call_statement_start(thd, spname);\n}",
        "target": 0
    },
    {
        "func": "  virtual ~Sql_statement()\n  {\n    /*\n      Sql_statement objects are allocated in thd->mem_root.\n      In MySQL, the C++ destructor is never called, the underlying MEM_ROOT is\n      simply destroyed instead.\n      Do not rely on the destructor for any cleanup.\n    */\n    DBUG_ASSERT(FALSE);\n  }",
        "target": 0
    },
    {
        "func": "ha_rows st_select_lex::get_limit()\n{\n  ulonglong val= HA_POS_ERROR;\n\n  if (select_limit)\n  {\n    /*\n      fix_fields() has not been called for select_limit. That's due to the\n      historical reasons -- this item could be only of type Item_int, and\n      Item_int does not require fix_fields(). Thus, fix_fields() was never\n      called for select_limit.\n\n      Some time ago, Item_splocal was also allowed for LIMIT / OFFSET clauses.\n      However, the fix_fields() behavior was not updated, which led to a crash\n      in some cases.\n\n      There is no single place where to call fix_fields() for LIMIT / OFFSET\n      items during the fix-fields-phase. Thus, for the sake of readability,\n      it was decided to do it here, on the evaluation phase (which is a\n      violation of design, but we chose the lesser of two evils).\n\n      We can call fix_fields() here, because select_limit can be of two\n      types only: Item_int and Item_splocal. Item_int::fix_fields() is trivial,\n      and Item_splocal::fix_fields() (or rather Item_sp_variable::fix_fields())\n      has the following properties:\n        1) it does not affect other items;\n        2) it does not fail.\n\n      Nevertheless DBUG_ASSERT was added to catch future changes in\n      fix_fields() implementation. Also added runtime check against a result\n      of fix_fields() in order to handle error condition in non-debug build.\n    */\n    bool err= select_limit->fix_fields_if_needed(master_unit()->thd, NULL);\n    DBUG_ASSERT(!err);\n    val= err ? HA_POS_ERROR : select_limit->val_uint();\n  }\n\n  return (ha_rows)val;\n}",
        "target": 0
    },
    {
        "func": "  void set(const char *s, size_t len, bool is_8bit, char quote)\n  {\n    str= s;\n    length= len;\n    set_metadata(is_8bit, quote);\n  }",
        "target": 0
    },
    {
        "func": "TABLE_LIST *LEX::unlink_first_table(bool *link_to_local)\n{\n  TABLE_LIST *first;\n  if ((first= query_tables))\n  {\n    /*\n      Exclude from global table list\n    */\n    if ((query_tables= query_tables->next_global))\n      query_tables->prev_global= &query_tables;\n    else\n      query_tables_last= &query_tables;\n    first->next_global= 0;\n\n    /*\n      and from local list if it is not empty\n    */\n    if ((*link_to_local= MY_TEST(first_select_lex()->table_list.first)))\n    {\n      first_select_lex()->context.table_list=\n         first_select_lex()->context.first_name_resolution_table=\n         first->next_local;\n      first_select_lex()->table_list.first= first->next_local;\n      first_select_lex()->table_list.elements--;  //safety\n      first->next_local= 0;\n      /*\n        Ensure that the global list has the same first table as the local\n        list.\n      */\n      first_lists_tables_same();\n    }\n  }\n  return first;\n}",
        "target": 0
    },
    {
        "func": "  unsigned char yyGetLast()\n  {\n    return m_ptr[-1];\n  }",
        "target": 0
    },
    {
        "func": "void LEX::stmt_deallocate_prepare(const Lex_ident_sys_st &ident)\n{\n  sql_command= SQLCOM_DEALLOCATE_PREPARE;\n  prepared_stmt.set(ident, NULL, NULL);\n}",
        "target": 0
    },
    {
        "func": "inline int cmp_unit_op(enum sub_select_type op1, enum sub_select_type op2)\n{\n  DBUG_ASSERT(op1 >= UNION_TYPE && op1 <= EXCEPT_TYPE);\n  DBUG_ASSERT(op2 >= UNION_TYPE && op2 <= EXCEPT_TYPE);\n  return (op1 == INTERSECT_TYPE ? 1 : 0) - (op2 == INTERSECT_TYPE ? 1 : 0);\n}",
        "target": 0
    },
    {
        "func": "  inline void free_set_stmt_mem_root()\n  {\n    DBUG_ASSERT(!is_arena_for_set_stmt());\n    if (mem_root_for_set_stmt)\n    {\n      free_root(mem_root_for_set_stmt, MYF(0));\n      delete mem_root_for_set_stmt;\n      mem_root_for_set_stmt= 0;\n    }\n  }",
        "target": 0
    },
    {
        "func": "  Lex_prepared_stmt()\n   :m_code(NULL)\n  { }",
        "target": 0
    },
    {
        "func": "bool add_to_list(THD *thd, SQL_I_List<ORDER> &list, Item *item,bool asc)\n{\n  ORDER *order;\n  DBUG_ENTER(\"add_to_list\");\n  if (unlikely(!(order = (ORDER *) thd->alloc(sizeof(ORDER)))))\n    DBUG_RETURN(1);\n  order->item_ptr= item;\n  order->item= &order->item_ptr;\n  order->direction= (asc ? ORDER::ORDER_ASC : ORDER::ORDER_DESC);\n  order->used=0;\n  order->counter_used= 0;\n  order->fast_field_copier_setup= 0; \n  list.link_in_list(order, &order->next);\n  DBUG_RETURN(0);\n}",
        "target": 0
    },
    {
        "func": "Item *LEX::create_item_ident_nospvar(THD *thd,\n                                     const Lex_ident_sys_st *a,\n                                     const Lex_ident_sys_st *b)\n{\n  DBUG_ASSERT(this == thd->lex);\n  /*\n    FIXME This will work ok in simple_ident_nospvar case because\n    we can't meet simple_ident_nospvar in trigger now. But it\n    should be changed in future.\n  */\n  if (is_trigger_new_or_old_reference(a))\n  {\n    bool new_row= (a->str[0]=='N' || a->str[0]=='n');\n\n    return create_and_link_Item_trigger_field(thd, b, new_row);\n  }\n\n  if (unlikely(current_select->no_table_names_allowed))\n  {\n    my_error(ER_TABLENAME_NOT_ALLOWED_HERE, MYF(0), a->str, thd->where);\n    return NULL;\n  }\n\n  if (current_select->parsing_place == FOR_LOOP_BOUND)\n    return create_item_for_loop_bound(thd, &null_clex_str, a, b);\n\n  return create_item_ident_field(thd, NullS, a->str, b);\n}",
        "target": 0
    },
    {
        "func": "Item *LEX::create_item_func_nextval(THD *thd, Table_ident *table_ident)\n{\n  TABLE_LIST *table;\n  if (unlikely(!(table= current_select->add_table_to_list(thd, table_ident, 0,\n                                                          TL_OPTION_SEQUENCE,\n                                                          TL_WRITE_ALLOW_WRITE,\n                                                          MDL_SHARED_WRITE))))\n    return NULL;\n  thd->lex->set_stmt_unsafe(LEX::BINLOG_STMT_UNSAFE_SYSTEM_FUNCTION);\n  return new (thd->mem_root) Item_func_nextval(thd, table);\n}",
        "target": 0
    },
    {
        "func": "  inline bool stmt_writes_to_non_temp_table()\n  {\n    DBUG_ENTER(\"THD::stmt_writes_to_non_temp_table\");\n\n    DBUG_RETURN((stmt_accessed_table_flag &\n                ((1U << STMT_WRITES_TRANS_TABLE) |\n                 (1U << STMT_WRITES_NON_TRANS_TABLE))));\n  }",
        "target": 0
    },
    {
        "func": "static TABLE_LIST *multi_delete_table_match(LEX *lex, TABLE_LIST *tbl,\n                                            TABLE_LIST *tables)\n{\n  TABLE_LIST *match= NULL;\n  DBUG_ENTER(\"multi_delete_table_match\");\n\n  for (TABLE_LIST *elem= tables; elem; elem= elem->next_local)\n  {\n    int res;\n\n    if (tbl->is_fqtn && elem->is_alias)\n      continue; /* no match */\n    if (tbl->is_fqtn && elem->is_fqtn)\n      res= (my_strcasecmp(table_alias_charset, tbl->table_name.str, elem->table_name.str) ||\n            cmp(&tbl->db, &elem->db));\n    else if (elem->is_alias)\n      res= my_strcasecmp(table_alias_charset, tbl->alias.str, elem->alias.str);\n    else\n      res= (my_strcasecmp(table_alias_charset, tbl->table_name.str, elem->table_name.str) ||\n            cmp(&tbl->db, &elem->db));\n\n    if (res)\n      continue;\n\n    if (match)\n    {\n      my_error(ER_NONUNIQ_TABLE, MYF(0), elem->alias.str);\n      DBUG_RETURN(NULL);\n    }\n\n    match= elem;\n  }\n\n  if (!match)\n    my_error(ER_UNKNOWN_TABLE, MYF(0), tbl->table_name.str, \"MULTI DELETE\");\n\n  DBUG_RETURN(match);\n}",
        "target": 0
    },
    {
        "func": "bool LEX::select_finalize(st_select_lex_unit *expr, Lex_select_lock l)\n{\n  return expr->set_lock_to_the_last_select(l) ||\n         select_finalize(expr);\n}",
        "target": 0
    },
    {
        "func": " Set_signal_information() {} ",
        "target": 0
    },
    {
        "func": "bool st_select_lex::add_window_def(THD *thd,\n                                   LEX_CSTRING *win_name,\n                                   LEX_CSTRING *win_ref,\n                                   SQL_I_List<ORDER> win_partition_list,\n                                   SQL_I_List<ORDER> win_order_list,\n                                   Window_frame *win_frame)\n{\n  SQL_I_List<ORDER> *win_part_list_ptr=\n    new (thd->mem_root) SQL_I_List<ORDER> (win_partition_list);\n  SQL_I_List<ORDER> *win_order_list_ptr=\n    new (thd->mem_root) SQL_I_List<ORDER> (win_order_list);\n  if (!(win_part_list_ptr && win_order_list_ptr))\n    return true;\n  Window_def *win_def= new (thd->mem_root) Window_def(win_name,\n                                                      win_ref,\n                                                      win_part_list_ptr,\n                                                      win_order_list_ptr,\n                                                      win_frame);\n  group_list= thd->lex->save_group_list;\n  order_list= thd->lex->save_order_list;\n  if (parsing_place != SELECT_LIST)\n  {\n    fields_in_window_functions+= win_part_list_ptr->elements +\n                                 win_order_list_ptr->elements;\n  }\n  return (win_def == NULL || window_specs.push_back(win_def));\n}",
        "target": 0
    },
    {
        "func": "  Lex_input_stream()\n  {\n  }",
        "target": 0
    },
    {
        "func": "void SELECT_LEX::update_used_tables()\n{\n  TABLE_LIST *tl;\n  List_iterator<TABLE_LIST> ti(leaf_tables);\n\n  while ((tl= ti++))\n  {\n    if (tl->table && !tl->is_view_or_derived())\n    {\n      TABLE_LIST *embedding= tl->embedding;\n      for (embedding= tl->embedding; embedding; embedding=embedding->embedding)\n      {\n        if (embedding->is_view_or_derived())\n        {\n          DBUG_ASSERT(embedding->is_merged_derived());\n          TABLE *tab= tl->table;\n          tab->covering_keys= tab->s->keys_for_keyread;\n          tab->covering_keys.intersect(tab->keys_in_use_for_query);\n          /*\n            View/derived was merged. Need to recalculate read_set\n            bitmaps here. For example:\n              CREATE VIEW v1 AS SELECT f1,f2,f3 FROM t1;\n              SELECT f1 FROM v1;\n            Initially, the view definition will put all f1,f2,f3 in the\n            read_set for t1. But after the view is merged, only f1 should\n            be in the read_set.\n          */\n          bitmap_clear_all(tab->read_set);\n          break;\n        }\n      }\n    }\n  }\n\n  ti.rewind();\n  while ((tl= ti++))\n  {\n    TABLE_LIST *embedding= tl;\n    do\n    {\n      bool maybe_null;\n      if ((maybe_null= MY_TEST(embedding->outer_join)))\n      {\n        tl->table->maybe_null= maybe_null;\n        break;\n      }\n    }\n    while ((embedding= embedding->embedding));\n    if (tl->on_expr)\n    {\n      tl->on_expr->update_used_tables();\n      tl->on_expr->walk(&Item::eval_not_null_tables, 0, NULL);\n    }\n    /*\n      - There is no need to check sj_on_expr, because merged semi-joins inject\n        sj_on_expr into the parent's WHERE clase.\n      - For non-merged semi-joins (aka JTBMs), we need to check their\n        left_expr. There is no need to check the rest of the subselect, we know\n        it is uncorrelated and so cannot refer to any tables in this select.\n    */\n    if (tl->jtbm_subselect)\n    {\n      Item *left_expr= tl->jtbm_subselect->left_expr;\n      left_expr->walk(&Item::update_table_bitmaps_processor, FALSE, NULL);\n    }\n\n    embedding= tl->embedding;\n    while (embedding)\n    {\n      if (embedding->on_expr && \n          embedding->nested_join->join_list.head() == tl)\n      {\n        embedding->on_expr->update_used_tables();\n        embedding->on_expr->walk(&Item::eval_not_null_tables, 0, NULL);\n      }\n      tl= embedding;\n      embedding= tl->embedding;\n    }\n  }\n\n  if (join->conds)\n  {\n    join->conds->update_used_tables();\n    join->conds->walk(&Item::eval_not_null_tables, 0, NULL);\n  }\n  if (join->having)\n  {\n    join->having->update_used_tables();\n  }\n\n  Item *item;\n  List_iterator_fast<Item> it(join->all_fields);\n  select_list_tables= 0;\n  while ((item= it++))\n  {\n    item->update_used_tables();\n    select_list_tables|= item->used_tables();\n  }\n  Item_outer_ref *ref;\n  List_iterator_fast<Item_outer_ref> ref_it(inner_refs_list);\n  while ((ref= ref_it++))\n  {\n    item= ref->outer_ref;\n    item->update_used_tables();\n  }\n  for (ORDER *order= group_list.first; order; order= order->next)\n    (*order->item)->update_used_tables();\n  if (!master_unit()->is_unit_op() ||\n      master_unit()->global_parameters() != this)\n  {\n    for (ORDER *order= order_list.first; order; order= order->next)\n      (*order->item)->update_used_tables();\n  }\n  join->result->update_used_tables();\n}",
        "target": 0
    },
    {
        "func": "void Lex_input_stream::body_utf8_start(THD *thd, const char *begin_ptr)\n{\n  DBUG_ASSERT(begin_ptr);\n  DBUG_ASSERT(m_cpp_buf <= begin_ptr && begin_ptr <= m_cpp_buf + m_buf_length);\n\n  size_t body_utf8_length= get_body_utf8_maximum_length(thd);\n\n  m_body_utf8= (char *) thd->alloc(body_utf8_length + 1);\n  m_body_utf8_ptr= m_body_utf8;\n  *m_body_utf8_ptr= 0;\n\n  m_cpp_utf8_processed_ptr= begin_ptr;\n}",
        "target": 0
    },
    {
        "func": "st_select_lex::build_pushable_cond_for_having_pushdown(THD *thd, Item *cond)\n{\n  List<Item> equalities;\n\n  /* Condition can't be pushed */\n  if (cond->get_extraction_flag() == NO_EXTRACTION_FL)\n    return false;\n\n  /**\n    Condition can be pushed entirely.\n    Transform its multiple equalities and add to attach_to_conds list.\n  */\n  if (cond->get_extraction_flag() == FULL_EXTRACTION_FL)\n  {\n    Item *result= cond->transform(thd,\n                                  &Item::multiple_equality_transformer,\n                                  (uchar *)this);\n    if (!result)\n      return true;\n    if (result->type() == Item::COND_ITEM &&\n        ((Item_cond*) result)->functype() == Item_func::COND_AND_FUNC)\n    {\n      List_iterator<Item> li(*((Item_cond*) result)->argument_list());\n      Item *item;\n      while ((item= li++))\n      {\n        if (attach_to_conds.push_back(item, thd->mem_root))\n          return true;\n      }\n    }\n    else\n    {\n      if (attach_to_conds.push_back(result, thd->mem_root))\n        return true;\n    }\n    return false;\n  }\n\n  /**\n    There is no flag set for this condition. It means that some\n    part of this condition can be pushed.\n  */\n  if (cond->type() != Item::COND_ITEM)\n    return false;\n\n  if (((Item_cond *)cond)->functype() != Item_cond::COND_AND_FUNC)\n  {\n    /*\n      cond is not a conjunctive formula and it cannot be pushed into WHERE.\n      Try to extract a formula that can be pushed.\n    */\n    Item *fix= cond->build_pushable_cond(thd, 0, 0);\n    if (!fix)\n      return false;\n    if (attach_to_conds.push_back(fix, thd->mem_root))\n      return true;\n  }\n  else\n  {\n    List_iterator<Item> li(*((Item_cond*) cond)->argument_list());\n    Item *item;\n    while ((item=li++))\n    {\n      if (item->get_extraction_flag() == NO_EXTRACTION_FL)\n        continue;\n      else if (item->get_extraction_flag() == FULL_EXTRACTION_FL)\n      {\n        Item *result= item->transform(thd,\n                                      &Item::multiple_equality_transformer,\n                                      (uchar *)item);\n        if (!result)\n          return true;\n        if (result->type() == Item::COND_ITEM &&\n           ((Item_cond*) result)->functype() == Item_func::COND_AND_FUNC)\n        {\n          List_iterator<Item> li(*((Item_cond*) result)->argument_list());\n          Item *item;\n          while ((item=li++))\n          {\n            if (attach_to_conds.push_back(item, thd->mem_root))\n              return true;\n          }\n        }\n        else\n        {\n          if (attach_to_conds.push_back(result, thd->mem_root))\n            return true;\n        }\n      }\n      else\n      {\n        Item *fix= item->build_pushable_cond(thd, 0, 0);\n        if (!fix)\n          continue;\n        if (attach_to_conds.push_back(fix, thd->mem_root))\n          return true;\n      }\n    }\n  }\n  return false;\n}",
        "target": 0
    },
    {
        "func": "bool LEX::sp_add_agg_cfetch()\n{\n  sphead->m_flags|= sp_head::HAS_AGGREGATE_INSTR;\n  sp_instr_agg_cfetch *i=\n    new (thd->mem_root) sp_instr_agg_cfetch(sphead->instructions(), spcont);\n  return i == NULL || sphead->add_instr(i);\n}",
        "target": 0
    },
    {
        "func": "bool LEX::check_expr_allows_fields_or_error(THD *thd, const char *name) const\n{\n  if (select_stack_top > 0)\n    return false; // OK, fields are allowed\n  my_error(ER_BAD_FIELD_ERROR, MYF(0), name, thd->where);\n  return true;    // Error, fields are not allowed\n}",
        "target": 0
    },
    {
        "func": "st_select_lex_node *st_select_lex_node:: insert_chain_before(\n                                         st_select_lex_node **ptr_pos_to_insert,\n                                         st_select_lex_node *end_chain_node)\n{\n  end_chain_node->link_next= *ptr_pos_to_insert;\n  (*ptr_pos_to_insert)->link_prev= &end_chain_node->link_next;\n  this->link_prev= ptr_pos_to_insert;\n  return this;\n}",
        "target": 0
    },
    {
        "func": "int prepare_schema_table(THD *thd, LEX *lex, Table_ident *table_ident,\n                         enum enum_schema_tables schema_table_idx)\n{\n  SELECT_LEX *schema_select_lex= NULL;\n  DBUG_ENTER(\"prepare_schema_table\");\n\n  switch (schema_table_idx) {\n  case SCH_SCHEMATA:\n#if defined(DONT_ALLOW_SHOW_COMMANDS)\n    my_message(ER_NOT_ALLOWED_COMMAND,\n               ER_THD(thd, ER_NOT_ALLOWED_COMMAND), MYF(0));\n    DBUG_RETURN(1);\n#else\n    break;\n#endif\n\n  case SCH_TABLE_NAMES:\n  case SCH_TABLES:\n  case SCH_CHECK_CONSTRAINTS:\n  case SCH_VIEWS:\n  case SCH_TRIGGERS:\n  case SCH_EVENTS:\n#ifdef DONT_ALLOW_SHOW_COMMANDS\n    my_message(ER_NOT_ALLOWED_COMMAND,\n               ER_THD(thd, ER_NOT_ALLOWED_COMMAND), MYF(0));\n    DBUG_RETURN(1);\n#else\n    {\n      if (lex->first_select_lex()->db.str == NULL &&\n          lex->copy_db_to(&lex->first_select_lex()->db))\n      {\n        DBUG_RETURN(1);\n      }\n      schema_select_lex= new (thd->mem_root) SELECT_LEX();\n      schema_select_lex->table_list.first= NULL;\n      if (lower_case_table_names == 1)\n        lex->first_select_lex()->db.str=\n          thd->strdup(lex->first_select_lex()->db.str);\n      schema_select_lex->db= lex->first_select_lex()->db;\n      /*\n        check_db_name() may change db.str if lower_case_table_names == 1,\n        but that's ok as the db is allocted above in this case.\n      */\n      if (check_db_name((LEX_STRING*) &lex->first_select_lex()->db))\n      {\n        my_error(ER_WRONG_DB_NAME, MYF(0), lex->first_select_lex()->db.str);\n        DBUG_RETURN(1);\n      }\n      break;\n    }\n#endif\n  case SCH_COLUMNS:\n  case SCH_STATISTICS:\n#ifdef DONT_ALLOW_SHOW_COMMANDS\n    my_message(ER_NOT_ALLOWED_COMMAND,\n               ER_THD(thd, ER_NOT_ALLOWED_COMMAND), MYF(0));\n    DBUG_RETURN(1);\n#else\n  {\n    DBUG_ASSERT(table_ident);\n    TABLE_LIST **query_tables_last= lex->query_tables_last;\n    schema_select_lex= new (thd->mem_root) SELECT_LEX();\n    /* 'parent_lex' is used in init_query() so it must be before it. */\n    schema_select_lex->parent_lex= lex;\n    schema_select_lex->init_query();\n    if (!schema_select_lex->add_table_to_list(thd, table_ident, 0, 0, TL_READ,\n                                              MDL_SHARED_READ))\n      DBUG_RETURN(1);\n    lex->query_tables_last= query_tables_last;\n    break;\n#endif\n  }\n  case SCH_PROFILES:\n    /* \n      Mark this current profiling record to be discarded.  We don't\n      wish to have SHOW commands show up in profiling.\n    */\n#if defined(ENABLED_PROFILING)\n    thd->profiling.discard_current_query();\n#endif\n    break;\n  default:\n    break;\n  }\n  if (schema_select_lex)\n    schema_select_lex->set_master_unit(&lex->unit);\n  SELECT_LEX *select_lex= lex->current_select;\n  if (make_schema_select(thd, select_lex, get_schema_table(schema_table_idx)))\n    DBUG_RETURN(1);\n\n  select_lex->table_list.first->schema_select_lex= schema_select_lex;\n  DBUG_RETURN(0);\n}",
        "target": 0
    },
    {
        "func": "LEX::sp_variable_declarations_with_ref_finalize(THD *thd, int nvars,\n                                                Qualified_column_ident *ref,\n                                                Item *def)\n{\n  return ref->db.length == 0 && ref->table.length == 0 ?\n    sp_variable_declarations_vartype_finalize(thd, nvars, ref->m_column, def) :\n    sp_variable_declarations_column_type_finalize(thd, nvars, ref, def);\n}",
        "target": 0
    },
    {
        "func": "LEX::create_unit(SELECT_LEX *first_sel)\n{\n  SELECT_LEX_UNIT *unit;\n  DBUG_ENTER(\"LEX::create_unit\");\n\n  unit = first_sel->master_unit();\n\n  if (!unit && !(unit= alloc_unit()))\n    DBUG_RETURN(NULL);\n\n  unit->register_select_chain(first_sel);\n  if (first_sel->next_select())\n  {\n    unit->reset_distinct();\n    DBUG_ASSERT(!unit->fake_select_lex);\n    if (unit->add_fake_select_lex(thd))\n      DBUG_RETURN(NULL);\n  }\n  DBUG_RETURN(unit);\n}",
        "target": 0
    },
    {
        "func": "  bool sp_for_loop_condition_test(THD *thd, const Lex_for_loop_st &loop)\n  {\n    return loop.is_for_loop_cursor() ?\n           sp_for_loop_cursor_condition_test(thd, loop) :\n           sp_for_loop_intrange_condition_test(thd, loop);\n  }",
        "target": 0
    },
    {
        "func": "LEX::add_tail_to_query_expression_body_ext_parens(SELECT_LEX_UNIT *unit,\n                                                  Lex_order_limit_lock *l)\n{\n  SELECT_LEX *sel= unit->first_select()->next_select() ? unit->fake_select_lex :\n                                                         unit->first_select();\n\n  DBUG_ASSERT(l != NULL);\n\n  pop_select();\n  if (sel->is_set_query_expr_tail)\n  {\n    if (!l->order_list && !sel->explicit_limit)\n      l->order_list= &sel->order_list;\n    else\n    {\n      if (!unit)\n        return NULL;\n      sel= wrap_unit_into_derived(unit);\n      if (!sel)\n        return NULL;\n     if (!create_unit(sel))\n      return NULL;\n   }\n  }\n  l->set_to(sel);\n  return sel->master_unit();\n}",
        "target": 0
    },
    {
        "func": "  sp_variable *find_variable(const LEX_CSTRING *name,\n                             const Sp_rcontext_handler **rh) const\n  {\n    sp_pcontext *not_used_ctx;\n    return find_variable(name, &not_used_ctx, rh);\n  }",
        "target": 0
    },
    {
        "func": "sp_head *LEX::make_sp_head(THD *thd, const sp_name *name,\n                           const Sp_handler *sph,\n                           enum_sp_aggregate_type agg_type)\n{\n  sp_package *package= get_sp_package();\n  sp_head *sp;\n\n  /* Order is important here: new - reset - init */\n  if (likely((sp= sp_head::create(package, sph, agg_type))))\n  {\n    sp->reset_thd_mem_root(thd);\n    sp->init(this);\n    if (name)\n    {\n      if (package)\n        sp->make_package_routine_name(sp->get_main_mem_root(),\n                                      package->m_db,\n                                      package->m_name,\n                                      name->m_name);\n      else\n        sp->init_sp_name(name);\n      sp->make_qname(sp->get_main_mem_root(), &sp->m_qname);\n    }\n    sphead= sp;\n  }\n  sp_chistics.init();\n  return sp;\n}",
        "target": 0
    },
    {
        "func": "  inline bool is_mixed_stmt_unsafe(bool in_multi_stmt_transaction_mode,\n                                   bool binlog_direct,\n                                   bool trx_cache_is_not_empty,\n                                   uint tx_isolation)\n  {\n    bool unsafe= FALSE;\n\n    if (in_multi_stmt_transaction_mode)\n    {\n       uint condition=\n         (binlog_direct ? BINLOG_DIRECT_ON : BINLOG_DIRECT_OFF) &\n         (trx_cache_is_not_empty ? TRX_CACHE_NOT_EMPTY : TRX_CACHE_EMPTY) &\n         (tx_isolation >= ISO_REPEATABLE_READ ? IL_GTE_REPEATABLE : IL_LT_REPEATABLE);\n\n      unsafe= (binlog_unsafe_map[stmt_accessed_table_flag] & condition);\n\n#if !defined(DBUG_OFF)\n      DBUG_PRINT(\"LEX::is_mixed_stmt_unsafe\", (\"RESULT %02X %02X %02X\", condition,\n              binlog_unsafe_map[stmt_accessed_table_flag],\n              (binlog_unsafe_map[stmt_accessed_table_flag] & condition)));\n \n      int type_in= 0;\n      for (; type_in < STMT_ACCESS_TABLE_COUNT; type_in++)\n      {\n        if (stmt_accessed_table((enum_stmt_accessed_table) type_in))\n          DBUG_PRINT(\"LEX::is_mixed_stmt_unsafe\", (\"ACCESSED %s \",\n                  stmt_accessed_table_string((enum_stmt_accessed_table) type_in)));\n      }\n#endif\n    }\n\n    if (stmt_accessed_table(STMT_WRITES_NON_TRANS_TABLE) &&\n      stmt_accessed_table(STMT_READS_TRANS_TABLE) &&\n      tx_isolation < ISO_REPEATABLE_READ)\n      unsafe= TRUE;\n    else if (stmt_accessed_table(STMT_WRITES_TEMP_NON_TRANS_TABLE) &&\n      stmt_accessed_table(STMT_READS_TRANS_TABLE) &&\n      tx_isolation < ISO_REPEATABLE_READ)\n      unsafe= TRUE;\n\n    return(unsafe);\n  }",
        "target": 0
    },
    {
        "func": "void st_select_lex_node::init_query_common()\n{\n  options= 0;\n  set_linkage(UNSPECIFIED_TYPE);\n  distinct= TRUE;\n  no_table_names_allowed= 0;\n  uncacheable= 0;\n}",
        "target": 0
    },
    {
        "func": "  bool requires_prelocking()\n  {\n    return MY_TEST(query_tables_own_last);\n  }",
        "target": 0
    },
    {
        "func": "  void link_neighbour(st_select_lex_node *neighbour)\n  {\n    DBUG_ASSERT(next == NULL);\n    DBUG_ASSERT(neighbour != NULL);\n    next= neighbour;\n    neighbour->prev= &next;\n  }",
        "target": 0
    },
    {
        "func": "  unsigned char yyPeekn(int n)\n  {\n    return m_ptr[n];\n  }",
        "target": 0
    },
    {
        "func": "static bool prepare_db_action(THD *thd, ulong want_access, LEX_CSTRING *dbname)\n{\n  if (check_db_name((LEX_STRING*)dbname))\n  {\n    my_error(ER_WRONG_DB_NAME, MYF(0), dbname->str);\n    return true;\n  }\n  /*\n    If in a slave thread :\n    - CREATE DATABASE DB was certainly not preceded by USE DB.\n    - ALTER DATABASE DB may not be preceded by USE DB.\n    - DROP DATABASE DB may not be preceded by USE DB.\n    For that reason, db_ok() in sql/slave.cc did not check the\n    do_db/ignore_db. And as this query involves no tables, tables_ok()\n    was not called. So we have to check rules again here.\n  */\n#ifdef HAVE_REPLICATION\n  if (thd->slave_thread)\n  {\n    Rpl_filter *rpl_filter;\n    rpl_filter= thd->system_thread_info.rpl_sql_info->rpl_filter;\n    if (!rpl_filter->db_ok(dbname->str) ||\n        !rpl_filter->db_ok_with_wild_table(dbname->str))\n    {\n      my_message(ER_SLAVE_IGNORED_TABLE,\n                 ER_THD(thd, ER_SLAVE_IGNORED_TABLE), MYF(0));\n      return true;\n    }\n  }\n#endif\n  return check_access(thd, want_access, dbname->str, NULL, NULL, 1, 0);\n}",
        "target": 0
    },
    {
        "func": "void LEX::set_trg_event_type_for_tables()\n{\n  uint8 new_trg_event_map= 0;\n  DBUG_ENTER(\"LEX::set_trg_event_type_for_tables\");\n\n  /*\n    Some auxiliary operations\n    (e.g. GRANT processing) create TABLE_LIST instances outside\n    the parser. Additionally, some commands (e.g. OPTIMIZE) change\n    the lock type for a table only after parsing is done. Luckily,\n    these do not fire triggers and do not need to pre-load them.\n    For these TABLE_LISTs set_trg_event_type is never called, and\n    trg_event_map is always empty. That means that the pre-locking\n    algorithm will ignore triggers defined on these tables, if\n    any, and the execution will either fail with an assert in\n    sql_trigger.cc or with an error that a used table was not\n    pre-locked, in case of a production build.\n\n    TODO: this usage pattern creates unnecessary module dependencies\n    and should be rewritten to go through the parser.\n    Table list instances created outside the parser in most cases\n    refer to mysql.* system tables. It is not allowed to have\n    a trigger on a system table, but keeping track of\n    initialization provides extra safety in case this limitation\n    is circumvented.\n  */\n\n  switch (sql_command) {\n  case SQLCOM_LOCK_TABLES:\n  /*\n    On a LOCK TABLE, all triggers must be pre-loaded for this TABLE_LIST\n    when opening an associated TABLE.\n  */\n    new_trg_event_map= trg2bit(TRG_EVENT_INSERT) | trg2bit(TRG_EVENT_UPDATE) |\n                       trg2bit(TRG_EVENT_DELETE);\n    break;\n  /*\n    Basic INSERT. If there is an additional ON DUPLIATE KEY UPDATE\n    clause, it will be handled later in this method.\n  */\n  case SQLCOM_INSERT:                           /* fall through */\n  case SQLCOM_INSERT_SELECT:\n  /*\n    LOAD DATA ... INFILE is expected to fire BEFORE/AFTER INSERT\n    triggers.\n    If the statement also has REPLACE clause, it will be\n    handled later in this method.\n  */\n  case SQLCOM_LOAD:                             /* fall through */\n  /*\n    REPLACE is semantically equivalent to INSERT. In case\n    of a primary or unique key conflict, it deletes the old\n    record and inserts a new one. So we also may need to\n    fire ON DELETE triggers. This functionality is handled\n    later in this method.\n  */\n  case SQLCOM_REPLACE:                          /* fall through */\n  case SQLCOM_REPLACE_SELECT:\n  /*\n    CREATE TABLE ... SELECT defaults to INSERT if the table or\n    view already exists. REPLACE option of CREATE TABLE ...\n    REPLACE SELECT is handled later in this method.\n  */\n  case SQLCOM_CREATE_TABLE:\n  case SQLCOM_CREATE_SEQUENCE:\n    new_trg_event_map|= trg2bit(TRG_EVENT_INSERT);\n    break;\n  /* Basic update and multi-update */\n  case SQLCOM_UPDATE:                           /* fall through */\n  case SQLCOM_UPDATE_MULTI:\n    new_trg_event_map|= trg2bit(TRG_EVENT_UPDATE);\n    break;\n  /* Basic delete and multi-delete */\n  case SQLCOM_DELETE:                           /* fall through */\n  case SQLCOM_DELETE_MULTI:\n    new_trg_event_map|= trg2bit(TRG_EVENT_DELETE);\n    break;\n  default:\n    break;\n  }\n\n  switch (duplicates) {\n  case DUP_UPDATE:\n    new_trg_event_map|= trg2bit(TRG_EVENT_UPDATE);\n    break;\n  case DUP_REPLACE:\n    new_trg_event_map|= trg2bit(TRG_EVENT_DELETE);\n    break;\n  case DUP_ERROR:\n  default:\n    break;\n  }\n\n  if (period_conditions.is_set())\n  {\n    switch (sql_command)\n    {\n    case SQLCOM_DELETE:\n    case SQLCOM_UPDATE:\n    case SQLCOM_REPLACE:\n      new_trg_event_map |= trg2bit(TRG_EVENT_INSERT);\n    default:\n      break;\n    }\n  }\n\n\n  /*\n    Do not iterate over sub-selects, only the tables in the outermost\n    SELECT_LEX can be modified, if any.\n  */\n  TABLE_LIST *tables= first_select_lex()->get_table_list();\n\n  while (tables)\n  {\n    /*\n      This is a fast check to filter out statements that do\n      not change data, or tables  on the right side, in case of\n      INSERT .. SELECT, CREATE TABLE .. SELECT and so on.\n      Here we also filter out OPTIMIZE statement and non-updateable\n      views, for which lock_type is TL_UNLOCK or TL_READ after\n      parsing.\n    */\n    if (static_cast<int>(tables->lock_type) >=\n        static_cast<int>(TL_WRITE_ALLOW_WRITE))\n      tables->trg_event_map= new_trg_event_map;\n    tables= tables->next_local;\n  }\n  DBUG_VOID_RETURN;\n}",
        "target": 0
    },
    {
        "func": "  inline uint32 get_stmt_unsafe_flags() const {\n    DBUG_ENTER(\"get_stmt_unsafe_flags\");\n    DBUG_RETURN(binlog_stmt_flags & BINLOG_STMT_UNSAFE_ALL_FLAGS);\n  }",
        "target": 0
    },
    {
        "func": "sp_package *LEX::create_package_start(THD *thd,\n                                      enum_sql_command command,\n                                      const Sp_handler *sph,\n                                      const sp_name *name_arg,\n                                      DDL_options_st options)\n{\n  sp_package *pkg;\n\n  if (unlikely(sphead))\n  {\n    my_error(ER_SP_NO_RECURSIVE_CREATE, MYF(0), sph->type_str());\n    return NULL;\n  }\n  if (unlikely(set_command_with_check(command, options)))\n    return NULL;\n  if (sph->type() == TYPE_ENUM_PACKAGE_BODY)\n  {\n    /*\n      If we start parsing a \"CREATE PACKAGE BODY\", we need to load\n      the corresponding \"CREATE PACKAGE\", for the following reasons:\n      1. \"CREATE PACKAGE BODY\" is allowed only if \"CREATE PACKAGE\"\n         was done earlier for the same package name.\n         So if \"CREATE PACKAGE\" does not exist, we throw an error here.\n      2. When parsing \"CREATE PACKAGE BODY\", we need to know all package\n         public and private routine names, to translate procedure and\n         function calls correctly.\n         For example, this statement inside a package routine:\n           CALL p;\n         can be translated to:\n           CALL db.pkg.p; -- p is a known (public or private) package routine\n           CALL db.p;     -- p is not a known package routine\n    */\n    sp_head *spec;\n    int ret= sp_handler_package_spec.\n               sp_cache_routine_reentrant(thd, name_arg, &spec);\n    if (unlikely(!spec))\n    {\n      if (!ret)\n        my_error(ER_SP_DOES_NOT_EXIST, MYF(0),\n                 \"PACKAGE\", ErrConvDQName(name_arg).ptr());\n      return 0;\n    }\n  }\n  if (unlikely(!(pkg= sp_package::create(this, name_arg, sph))))\n    return NULL;\n  pkg->reset_thd_mem_root(thd);\n  pkg->init(this);\n  pkg->make_qname(pkg->get_main_mem_root(), &pkg->m_qname);\n  sphead= pkg;\n  return pkg;\n}",
        "target": 0
    },
    {
        "func": "void st_select_lex_unit::print(String *str, enum_query_type query_type)\n{\n  bool union_all= !union_distinct;\n  if (with_clause)\n    with_clause->print(str, query_type);\n  for (SELECT_LEX *sl= first_select(); sl; sl= sl->next_select())\n  {\n    if (sl != first_select())\n    {\n      switch (sl->linkage)\n      {\n      default:\n        DBUG_ASSERT(0);\n        /* fall through */\n      case UNION_TYPE:\n        str->append(STRING_WITH_LEN(\" union \"));\n        if (union_all)\n          str->append(STRING_WITH_LEN(\"all \"));\n        break;\n      case INTERSECT_TYPE:\n        str->append(STRING_WITH_LEN(\" intersect \"));\n        break;\n      case EXCEPT_TYPE:\n        str->append(STRING_WITH_LEN(\" except \"));\n        break;\n      }\n      if (sl == union_distinct)\n        union_all= TRUE;\n    }\n    if (sl->braces)\n      str->append('(');\n    sl->print(thd, str, query_type);\n    if (sl->braces)\n      str->append(')');\n  }\n  if (fake_select_lex)\n  {\n    if (fake_select_lex->order_list.elements)\n    {\n      str->append(STRING_WITH_LEN(\" order by \"));\n      fake_select_lex->print_order(str,\n        fake_select_lex->order_list.first,\n        query_type);\n    }\n    fake_select_lex->print_limit(thd, str, query_type);\n  }\n  else if (saved_fake_select_lex)\n    saved_fake_select_lex->print_limit(thd, str, query_type);\n}",
        "target": 0
    },
    {
        "func": "bool SELECT_LEX::make_unique_derived_name(THD *thd, LEX_CSTRING *alias)\n{\n  // uint32 digits + two underscores + trailing '\\0'\n  char buff[MAX_INT_WIDTH + 2 + 1];\n  alias->length= my_snprintf(buff, sizeof(buff), \"__%u\", select_number);\n  alias->str= thd->strmake(buff, alias->length);\n  return !alias->str;\n}",
        "target": 0
    },
    {
        "func": "void LEX::first_lists_tables_same()\n{\n  TABLE_LIST *first_table= first_select_lex()->table_list.first;\n  if (query_tables != first_table && first_table != 0)\n  {\n    TABLE_LIST *next;\n    if (query_tables_last == &first_table->next_global)\n      query_tables_last= first_table->prev_global;\n\n    if (query_tables_own_last == &first_table->next_global)\n      query_tables_own_last= first_table->prev_global;\n\n    if ((next= *first_table->prev_global= first_table->next_global))\n      next->prev_global= first_table->prev_global;\n    /* include in new place */\n    first_table->next_global= query_tables;\n    /*\n       We are sure that query_tables is not 0, because first_table was not\n       first table in the global list => we can use\n       query_tables->prev_global without check of query_tables\n    */\n    query_tables->prev_global= &first_table->next_global;\n    first_table->prev_global= &query_tables;\n    query_tables= first_table;\n  }\n}",
        "target": 0
    },
    {
        "func": "bool Lex_input_stream::consume_comment(int remaining_recursions_permitted)\n{\n  // only one level of nested comments are allowed\n  DBUG_ASSERT(remaining_recursions_permitted == 0 ||\n              remaining_recursions_permitted == 1);\n  uchar c;\n  while (!eof())\n  {\n    c= yyGet();\n\n    if (remaining_recursions_permitted == 1)\n    {\n      if ((c == '/') && (yyPeek() == '*'))\n      {\n        yyUnput('(');  // Replace nested \"/*...\" with \"(*...\"\n        yySkip();      // and skip \"(\"\n\n        yySkip(); /* Eat asterisk */\n        if (consume_comment(0))\n          return true;\n\n        yyUnput(')');  // Replace \"...*/\" with \"...*)\"\n        yySkip();      // and skip \")\"\n        continue;\n      }\n    }\n\n    if (c == '*')\n    {\n      if (yyPeek() == '/')\n      {\n        yySkip(); // Eat slash\n        return FALSE;\n      }\n    }\n\n    if (c == '\\n')\n      yylineno++;\n  }\n\n  return TRUE;\n}",
        "target": 0
    },
    {
        "func": "bool Lex_ident_sys_st::convert(THD *thd,\n                               const LEX_CSTRING *src, CHARSET_INFO *cs)\n{\n  LEX_STRING tmp;\n  if (thd->convert_with_error(system_charset_info, &tmp, cs,\n                              src->str, src->length))\n    return true;\n  str=    tmp.str;\n  length= tmp.length;\n  return false;\n}",
        "target": 0
    },
    {
        "func": "void Lex_select_lock::set_to(SELECT_LEX *sel)\n{\n  if (defined_lock)\n  {\n    if (sel->master_unit() &&\n        sel == sel->master_unit()->fake_select_lex)\n      sel->master_unit()->set_lock_to_the_last_select(*this);\n    else\n    {\n      sel->parent_lex->safe_to_cache_query= 0;\n      if (update_lock)\n      {\n        sel->lock_type= TL_WRITE;\n        sel->set_lock_for_tables(TL_WRITE, false);\n      }\n      else\n      {\n        sel->lock_type= TL_READ_WITH_SHARED_LOCKS;\n        sel->set_lock_for_tables(TL_READ_WITH_SHARED_LOCKS, false);\n      }\n    }\n  }\n}",
        "target": 0
    },
    {
        "func": "LEX::sp_block_with_exceptions_finalize_executable_section(THD *thd,\n                                         uint executable_section_ip)\n{\n  /*\n    We're now at the end of \"executable_section\" of the block,\n    near the \"EXCEPTION\" or the \"END\" keyword.\n    Generate a jump to the END of the block over the EXCEPTION section.\n  */\n  if (sphead->add_instr_jump_forward_with_backpatch(thd, spcont))\n    return true;\n  /*\n    Set the destination for the jump that we added in\n    sp_block_with_exceptions_finalize_declarations().\n  */\n  sp_instr *instr= sphead->get_instr(executable_section_ip - 1);\n  instr->backpatch(sphead->instructions(), spcont);\n  return false;\n}",
        "target": 0
    },
    {
        "func": "bool LEX::sp_exit_block(THD *thd, sp_label *lab, Item *when)\n{\n  if (!when)\n    return sp_exit_block(thd, lab);\n\n  DBUG_ASSERT(sphead == thd->lex->sphead);\n  DBUG_ASSERT(spcont == thd->lex->spcont);\n  sp_instr_jump_if_not *i= new (thd->mem_root)\n                           sp_instr_jump_if_not(sphead->instructions(),\n                                                spcont,\n                                                when, thd->lex);\n  if (unlikely(i == NULL) ||\n      unlikely(sphead->add_instr(i)) ||\n      unlikely(sp_exit_block(thd, lab)))\n    return true;\n  i->backpatch(sphead->instructions(), spcont);\n  return false;\n}",
        "target": 0
    },
    {
        "func": "  bool is_part_of_union() { return master_unit()->is_unit_op(); }",
        "target": 0
    },
    {
        "func": "bool LEX::sp_exit_statement(THD *thd, const LEX_CSTRING *label_name, Item *item)\n{\n  sp_label *lab= spcont->find_label(label_name);\n  if (unlikely(!lab || lab->type != sp_label::ITERATION))\n  {\n    my_error(ER_SP_LILABEL_MISMATCH, MYF(0), \"EXIT\", label_name->str);\n    return true;\n  }\n  return sp_exit_block(thd, lab, item);\n}",
        "target": 0
    },
    {
        "func": "Spvar_definition *LEX::row_field_name(THD *thd, const Lex_ident_sys_st &name)\n{\n  Spvar_definition *res;\n  if (unlikely(check_string_char_length(&name, 0, NAME_CHAR_LEN,\n                                        system_charset_info, 1)))\n  {\n    my_error(ER_TOO_LONG_IDENT, MYF(0), name.str);\n    return NULL;\n  }\n  if (unlikely(!(res= new (thd->mem_root) Spvar_definition())))\n    return NULL;\n  init_last_field(res, &name, thd->variables.collation_database);\n  return res;\n}",
        "target": 0
    },
    {
        "func": "Item *LEX::create_item_limit(THD *thd,\n                             const Lex_ident_cli_st *ca,\n                             const Lex_ident_cli_st *cb)\n{\n  DBUG_ASSERT(thd->m_parser_state->m_lip.get_buf() <= ca->pos());\n  DBUG_ASSERT(ca->pos() <= cb->end());\n  DBUG_ASSERT(cb->end() <= thd->m_parser_state->m_lip.get_end_of_query());\n\n  const Sp_rcontext_handler *rh;\n  sp_variable *spv;\n  Lex_ident_sys sa(thd, ca), sb(thd, cb);\n  if (unlikely(sa.is_null() || sb.is_null()))\n    return NULL; // EOM\n  if (!(spv= find_variable(&sa, &rh)))\n  {\n    my_error(ER_SP_UNDECLARED_VAR, MYF(0), sa.str);\n    return NULL;\n  }\n  // Qualified %TYPE variables are not possible\n  DBUG_ASSERT(!spv->field_def.column_type_ref());\n  Item_splocal *item;\n  if (unlikely(!(item= create_item_spvar_row_field(thd, rh, &sa, &sb, spv,\n                                                   ca->pos(), cb->end()))))\n    return NULL;\n  if (!item->is_valid_limit_clause_variable_with_error())\n    return NULL;\n  item->limit_clause_param= true;\n  return item;\n}",
        "target": 0
    },
    {
        "func": "bool parse_sql(THD *thd, Parser_state *parser_state,\n               Object_creation_ctx *creation_ctx, bool do_pfs_digest)\n{\n  bool ret_value;\n  DBUG_ENTER(\"parse_sql\");\n  DBUG_ASSERT(thd->m_parser_state == NULL);\n  DBUG_ASSERT(thd->lex->m_sql_cmd == NULL);\n\n  MYSQL_QUERY_PARSE_START(thd->query());\n  /* Backup creation context. */\n\n  Object_creation_ctx *backup_ctx= NULL;\n\n  if (creation_ctx)\n    backup_ctx= creation_ctx->set_n_backup(thd);\n\n  /* Set parser state. */\n\n  thd->m_parser_state= parser_state;\n\n  parser_state->m_digest_psi= NULL;\n  parser_state->m_lip.m_digest= NULL;\n\n  if (do_pfs_digest)\n  {\n    /* Start Digest */\n    parser_state->m_digest_psi= MYSQL_DIGEST_START(thd->m_statement_psi);\n\n    if (parser_state->m_digest_psi != NULL)\n    {\n      /*\n        If either:\n        - the caller wants to compute a digest\n        - the performance schema wants to compute a digest\n        set the digest listener in the lexer.\n      */\n      parser_state->m_lip.m_digest= thd->m_digest;\n      parser_state->m_lip.m_digest->m_digest_storage.m_charset_number= thd->charset()->number;\n    }\n  }\n\n  /* Parse the query. */\n\n  bool mysql_parse_status=\n         ((thd->variables.sql_mode & MODE_ORACLE) ?\n          ORAparse(thd) :\n          MYSQLparse(thd)) != 0;\n  DBUG_ASSERT(opt_bootstrap || mysql_parse_status ||\n              thd->lex->select_stack_top == 0);\n  thd->lex->current_select= thd->lex->first_select_lex();\n\n  /*\n    Check that if MYSQLparse() failed either thd->is_error() is set, or an\n    internal error handler is set.\n\n    The assert will not catch a situation where parsing fails without an\n    error reported if an error handler exists. The problem is that the\n    error handler might have intercepted the error, so thd->is_error() is\n    not set. However, there is no way to be 100% sure here (the error\n    handler might be for other errors than parsing one).\n  */\n\n  DBUG_ASSERT(!mysql_parse_status ||\n              thd->is_error() ||\n              thd->get_internal_handler());\n\n  /* Reset parser state. */\n\n  thd->m_parser_state= NULL;\n\n  /* Restore creation context. */\n\n  if (creation_ctx)\n    creation_ctx->restore_env(thd, backup_ctx);\n\n  /* That's it. */\n\n  ret_value= mysql_parse_status || thd->is_fatal_error;\n\n  if ((ret_value == 0) && (parser_state->m_digest_psi != NULL))\n  {\n    /*\n      On parsing success, record the digest in the performance schema.\n    */\n    DBUG_ASSERT(do_pfs_digest);\n    DBUG_ASSERT(thd->m_digest != NULL);\n    MYSQL_DIGEST_END(parser_state->m_digest_psi,\n                     & thd->m_digest->m_digest_storage);\n  }\n\n  MYSQL_QUERY_PARSE_DONE(ret_value);\n  DBUG_RETURN(ret_value);\n}",
        "target": 0
    },
    {
        "func": "LEX_USER *create_definer(THD *thd, LEX_CSTRING *user_name,\n                         LEX_CSTRING *host_name)\n{\n  LEX_USER *definer;\n\n  /* Create and initialize. */\n\n  if (unlikely(!(definer= (LEX_USER*) thd->alloc(sizeof(LEX_USER)))))\n    return 0;\n\n  definer->user= *user_name;\n  definer->host= *host_name;\n  definer->auth= NULL;\n\n  return definer;\n}",
        "target": 0
    },
    {
        "func": "  void skip_binary(int n)\n  {\n    if (m_echo)\n    {\n      memcpy(m_cpp_ptr, m_ptr, n);\n      m_cpp_ptr += n;\n    }\n    m_ptr += n;\n  }",
        "target": 0
    },
    {
        "func": "int Lex_input_stream::lex_one_token(YYSTYPE *yylval, THD *thd)\n{\n  uchar UNINIT_VAR(c);\n  bool comment_closed;\n  int tokval;\n  uint length;\n  enum my_lex_states state;\n  LEX *lex= thd->lex;\n  CHARSET_INFO *const cs= thd->charset();\n  const uchar *const state_map= cs->state_map;\n  const uchar *const ident_map= cs->ident_map;\n\n  start_token();\n  state= next_state;\n  next_state= MY_LEX_OPERATOR_OR_IDENT;\n  for (;;)\n  {\n    switch (state) {\n    case MY_LEX_OPERATOR_OR_IDENT:        // Next is operator or keyword\n    case MY_LEX_START:                    // Start of token\n      // Skip starting whitespace\n      while(state_map[c= yyPeek()] == MY_LEX_SKIP)\n      {\n        if (c == '\\n')\n          yylineno++;\n\n        yySkip();\n      }\n\n      /* Start of real token */\n      restart_token();\n      c= yyGet();\n      state= (enum my_lex_states) state_map[c];\n      break;\n    case MY_LEX_ESCAPE:\n      if (!eof() && yyGet() == 'N')\n      {                                        // Allow \\N as shortcut for NULL\n        yylval->lex_str.str= (char*) \"\\\\N\";\n        yylval->lex_str.length= 2;\n        return NULL_SYM;\n      }\n      /* Fall through */\n    case MY_LEX_CHAR:                          // Unknown or single char token\n      if (c == '%' && (m_thd->variables.sql_mode & MODE_ORACLE))\n      {\n        next_state= MY_LEX_START;\n        return PERCENT_ORACLE_SYM;\n      }\n      if (c == '[' && (m_thd->variables.sql_mode & MODE_MSSQL))\n        return scan_ident_delimited(thd, &yylval->ident_cli, ']');\n      /* Fall through */\n    case MY_LEX_SKIP:                          // This should not happen\n      if (c != ')')\n        next_state= MY_LEX_START;         // Allow signed numbers\n      yylval->kwd.set_keyword(m_tok_start, 1);\n      return((int) c);\n\n    case MY_LEX_MINUS_OR_COMMENT:\n      if (yyPeek() == '-' &&\n          (my_isspace(cs,yyPeekn(1)) ||\n           my_iscntrl(cs,yyPeekn(1))))\n      {\n        state=MY_LEX_COMMENT;\n        break;\n      }\n      next_state= MY_LEX_START;        // Allow signed numbers\n      return((int) c);\n\n    case MY_LEX_PLACEHOLDER:\n      /*\n        Check for a placeholder: it should not precede a possible identifier\n        because of binlogging: when a placeholder is replaced with\n        its value in a query for the binlog, the query must stay\n        grammatically correct.\n      */\n      next_state= MY_LEX_START;        // Allow signed numbers\n      if (stmt_prepare_mode && !ident_map[(uchar) yyPeek()])\n        return(PARAM_MARKER);\n      return((int) c);\n\n    case MY_LEX_COMMA:\n      next_state= MY_LEX_START;        // Allow signed numbers\n      /*\n        Warning:\n        This is a work around, to make the \"remember_name\" rule in\n        sql/sql_yacc.yy work properly.\n        The problem is that, when parsing \"select expr1, expr2\",\n        the code generated by bison executes the *pre* action\n        remember_name (see select_item) *before* actually parsing the\n        first token of expr2.\n      */\n      restart_token();\n      return((int) c);\n\n    case MY_LEX_IDENT_OR_NCHAR:\n    {\n      uint sep;\n      if (yyPeek() != '\\'')\n      {\n        state= MY_LEX_IDENT;\n        break;\n      }\n      /* Found N'string' */\n      yySkip();                         // Skip '\n      if (get_text(&yylval->lex_string_with_metadata, (sep= yyGetLast()), 2, 1))\n      {\n        state= MY_LEX_CHAR;                    // Read char by char\n        break;\n      }\n\n      body_utf8_append(m_cpp_text_start);\n      body_utf8_append_escape(thd, &yylval->lex_string_with_metadata,\n                                   national_charset_info,\n                                   m_cpp_text_end, sep);\n      return(NCHAR_STRING);\n    }\n    case MY_LEX_IDENT_OR_HEX:\n      if (yyPeek() == '\\'')\n      {                                      // Found x'hex-number'\n        state= MY_LEX_HEX_NUMBER;\n        break;\n      }\n      /* fall through */\n    case MY_LEX_IDENT_OR_BIN:\n      if (yyPeek() == '\\'')\n      {                                 // Found b'bin-number'\n        state= MY_LEX_BIN_NUMBER;\n        break;\n      }\n      /* fall through */\n    case MY_LEX_IDENT:\n    {\n      tokval= scan_ident_middle(thd, &yylval->ident_cli,\n                                &yylval->charset, &state);\n      if (!tokval)\n        continue;\n      if (tokval == UNDERSCORE_CHARSET)\n        m_underscore_cs= yylval->charset;\n      return tokval;\n    }\n\n    case MY_LEX_IDENT_SEP:                  // Found ident and now '.'\n      yylval->lex_str.str= (char*) get_ptr();\n      yylval->lex_str.length= 1;\n      c= yyGet();                          // should be '.'\n      if (lex->parsing_options.lookup_keywords_after_qualifier)\n        next_state= MY_LEX_IDENT_OR_KEYWORD;\n      else\n        next_state= MY_LEX_IDENT_START;    // Next is ident (not keyword)\n      if (!ident_map[(uchar) yyPeek()])    // Probably ` or \"\n        next_state= MY_LEX_START;\n      return((int) c);\n\n    case MY_LEX_NUMBER_IDENT:                   // number or ident which num-start\n      if (yyGetLast() == '0')\n      {\n        c= yyGet();\n        if (c == 'x')\n        {\n          while (my_isxdigit(cs, (c = yyGet()))) ;\n          if ((yyLength() >= 3) && !ident_map[c])\n          {\n            /* skip '0x' */\n            yylval->lex_str= get_token(2, yyLength() - 2);\n            return (HEX_NUM);\n          }\n          yyUnget();\n          state= MY_LEX_IDENT_START;\n          break;\n        }\n        else if (c == 'b')\n        {\n          while ((c= yyGet()) == '0' || c == '1')\n            ;\n          if ((yyLength() >= 3) && !ident_map[c])\n          {\n            /* Skip '0b' */\n            yylval->lex_str= get_token(2, yyLength() - 2);\n            return (BIN_NUM);\n          }\n          yyUnget();\n          state= MY_LEX_IDENT_START;\n          break;\n        }\n        yyUnget();\n      }\n\n      while (my_isdigit(cs, (c= yyGet()))) ;\n      if (!ident_map[c])\n      {                                        // Can't be identifier\n        state=MY_LEX_INT_OR_REAL;\n        break;\n      }\n      if (c == 'e' || c == 'E')\n      {\n        // The following test is written this way to allow numbers of type 1e1\n        if (my_isdigit(cs, yyPeek()) ||\n            (c=(yyGet())) == '+' || c == '-')\n        {                                       // Allow 1E+10\n          if (my_isdigit(cs, yyPeek()))         // Number must have digit after sign\n          {\n            yySkip();\n            while (my_isdigit(cs, yyGet())) ;\n            yylval->lex_str= get_token(0, yyLength());\n            return(FLOAT_NUM);\n          }\n        }\n        /*\n          We've found:\n          - A sequence of digits\n          - Followed by 'e' or 'E'\n          - Followed by some byte XX which is not a known mantissa start,\n            and it's known to be a valid identifier part.\n            XX can be either a 8bit identifier character, or a multi-byte head.\n        */\n        yyUnget();\n        return scan_ident_start(thd, &yylval->ident_cli);\n      }\n      /*\n        We've found:\n        - A sequence of digits\n        - Followed by some character XX, which is neither 'e' nor 'E',\n          and it's known to be a valid identifier part.\n          XX can be a 8bit identifier character, or a multi-byte head.\n      */\n      yyUnget();\n      return scan_ident_start(thd, &yylval->ident_cli);\n\n    case MY_LEX_IDENT_START:                    // We come here after '.'\n      return scan_ident_start(thd, &yylval->ident_cli);\n\n    case MY_LEX_USER_VARIABLE_DELIMITER:        // Found quote char\n      return scan_ident_delimited(thd, &yylval->ident_cli, m_tok_start[0]);\n\n    case MY_LEX_INT_OR_REAL:                    // Complete int or incomplete real\n      if (c != '.' || yyPeek() == '.')\n      {\n        /*\n          Found a complete integer number:\n          - the number is either not followed by a dot at all, or\n          - the number is followed by a double dot as in: FOR i IN 1..10\n        */\n        yylval->lex_str= get_token(0, yyLength());\n        return int_token(yylval->lex_str.str, (uint) yylval->lex_str.length);\n      }\n      // fall through\n    case MY_LEX_REAL:                           // Incomplete real number\n      while (my_isdigit(cs, c= yyGet())) ;\n\n      if (c == 'e' || c == 'E')\n      {\n        c= yyGet();\n        if (c == '-' || c == '+')\n          c= yyGet();                           // Skip sign\n        if (!my_isdigit(cs, c))\n\t  return ABORT_SYM; // No digit after sign\n        while (my_isdigit(cs, yyGet())) ;\n        yylval->lex_str= get_token(0, yyLength());\n        return(FLOAT_NUM);\n      }\n      yylval->lex_str= get_token(0, yyLength());\n      return(DECIMAL_NUM);\n\n    case MY_LEX_HEX_NUMBER:             // Found x'hexstring'\n      yySkip();                    // Accept opening '\n      while (my_isxdigit(cs, (c= yyGet()))) ;\n      if (c != '\\'')\n        return(ABORT_SYM);              // Illegal hex constant\n      yySkip();                    // Accept closing '\n      length= yyLength();          // Length of hexnum+3\n      if ((length % 2) == 0)\n        return(ABORT_SYM);              // odd number of hex digits\n      yylval->lex_str= get_token(2,            // skip x'\n                                 length - 3);  // don't count x' and last '\n      return HEX_STRING;\n\n    case MY_LEX_BIN_NUMBER:           // Found b'bin-string'\n      yySkip();                  // Accept opening '\n      while ((c= yyGet()) == '0' || c == '1')\n        ;\n      if (c != '\\'')\n        return(ABORT_SYM);            // Illegal hex constant\n      yySkip();                  // Accept closing '\n      length= yyLength();        // Length of bin-num + 3\n      yylval->lex_str= get_token(2,           // skip b'\n                                 length - 3); // don't count b' and last '\n      return (BIN_NUM);\n\n    case MY_LEX_CMP_OP:                     // Incomplete comparison operator\n      next_state= MY_LEX_START;        // Allow signed numbers\n      if (state_map[(uchar) yyPeek()] == MY_LEX_CMP_OP ||\n          state_map[(uchar) yyPeek()] == MY_LEX_LONG_CMP_OP)\n      {\n        yySkip();\n        if ((tokval= find_keyword(&yylval->kwd, 2, 0)))\n          return(tokval);\n        yyUnget();\n      }\n      return(c);\n\n    case MY_LEX_LONG_CMP_OP:                // Incomplete comparison operator\n      next_state= MY_LEX_START;\n      if (state_map[(uchar) yyPeek()] == MY_LEX_CMP_OP ||\n          state_map[(uchar) yyPeek()] == MY_LEX_LONG_CMP_OP)\n      {\n        yySkip();\n        if (state_map[(uchar) yyPeek()] == MY_LEX_CMP_OP)\n        {\n          yySkip();\n          if ((tokval= find_keyword(&yylval->kwd, 3, 0)))\n            return(tokval);\n          yyUnget();\n        }\n        if ((tokval= find_keyword(&yylval->kwd, 2, 0)))\n          return(tokval);\n        yyUnget();\n      }\n      return(c);\n\n    case MY_LEX_BOOL:\n      if (c != yyPeek())\n      {\n        state= MY_LEX_CHAR;\n        break;\n      }\n      yySkip();\n      tokval= find_keyword(&yylval->kwd, 2, 0);  // Is a bool operator\n      next_state= MY_LEX_START;                  // Allow signed numbers\n      return(tokval);\n\n    case MY_LEX_STRING_OR_DELIMITER:\n      if (thd->variables.sql_mode & MODE_ANSI_QUOTES)\n      {\n        state= MY_LEX_USER_VARIABLE_DELIMITER;\n        break;\n      }\n      /* \" used for strings */\n      /* fall through */\n    case MY_LEX_STRING:                        // Incomplete text string\n    {\n      uint sep;\n      if (get_text(&yylval->lex_string_with_metadata, (sep= yyGetLast()), 1, 1))\n      {\n        state= MY_LEX_CHAR;                     // Read char by char\n        break;\n      }\n      CHARSET_INFO *strcs= m_underscore_cs ? m_underscore_cs : cs;\n      body_utf8_append(m_cpp_text_start);\n\n      body_utf8_append_escape(thd, &yylval->lex_string_with_metadata,\n                                   strcs, m_cpp_text_end, sep);\n      m_underscore_cs= NULL;\n      return(TEXT_STRING);\n    }\n    case MY_LEX_COMMENT:                       //  Comment\n      lex->lex_options|= OPTION_LEX_FOUND_COMMENT;\n      while ((c= yyGet()) != '\\n' && c) ;\n      yyUnget();                          // Safety against eof\n      state= MY_LEX_START;                     // Try again\n      break;\n    case MY_LEX_LONG_COMMENT:                  // Long C comment?\n      if (yyPeek() != '*')\n      {\n        state= MY_LEX_CHAR;                     // Probable division\n        break;\n      }\n      lex->lex_options|= OPTION_LEX_FOUND_COMMENT;\n      /* Reject '/' '*', since we might need to turn off the echo */\n      yyUnget();\n\n      save_in_comment_state();\n\n      if (yyPeekn(2) == '!' ||\n          (yyPeekn(2) == 'M' && yyPeekn(3) == '!'))\n      {\n        bool maria_comment_syntax= yyPeekn(2) == 'M';\n        in_comment= DISCARD_COMMENT;\n        /* Accept '/' '*' '!', but do not keep this marker. */\n        set_echo(FALSE);\n        yySkipn(maria_comment_syntax ? 4 : 3);\n\n        /*\n          The special comment format is very strict:\n          '/' '*' '!', followed by an optional 'M' and exactly\n          1-2 digits (major), 2 digits (minor), then 2 digits (dot).\n          32302  -> 3.23.02\n          50032  -> 5.0.32\n          50114  -> 5.1.14\n          100000 -> 10.0.0\n        */\n        if (  my_isdigit(cs, yyPeekn(0))\n           && my_isdigit(cs, yyPeekn(1))\n           && my_isdigit(cs, yyPeekn(2))\n           && my_isdigit(cs, yyPeekn(3))\n           && my_isdigit(cs, yyPeekn(4))\n           )\n        {\n          ulong version;\n          uint length= 5;\n          char *end_ptr= (char*) get_ptr() + length;\n          int error;\n          if (my_isdigit(cs, yyPeekn(5)))\n          {\n            end_ptr++;                          // 6 digit number\n            length++;\n          }\n\n          version= (ulong) my_strtoll10(get_ptr(), &end_ptr, &error);\n\n          /*\n            MySQL-5.7 has new features and might have new SQL syntax that\n            MariaDB-10.0 does not understand. Ignore all versioned comments\n            with MySQL versions in the range 50700-999999, but\n            do not ignore MariaDB specific comments for the same versions.\n          */ \n          if (version <= MYSQL_VERSION_ID &&\n              (version < 50700 || version > 99999 || maria_comment_syntax))\n          {\n            /* Accept 'M' 'm' 'm' 'd' 'd' */\n            yySkipn(length);\n            /* Expand the content of the special comment as real code */\n            set_echo(TRUE);\n            state=MY_LEX_START;\n            break;  /* Do not treat contents as a comment.  */\n          }\n          else\n          {\n#ifdef WITH_WSREP\n            if (WSREP(thd) && version == 99997 && wsrep_thd_is_local(thd))\n            {\n              WSREP_DEBUG(\"consistency check: %s\", thd->query());\n              thd->wsrep_consistency_check= CONSISTENCY_CHECK_DECLARED;\n              yySkipn(5);\n              set_echo(TRUE);\n              state= MY_LEX_START;\n              break;  /* Do not treat contents as a comment.  */\n            }\n#endif /* WITH_WSREP */\n            /*\n              Patch and skip the conditional comment to avoid it\n              being propagated infinitely (eg. to a slave).\n            */\n            char *pcom= yyUnput(' ');\n            comment_closed= ! consume_comment(1);\n            if (! comment_closed)\n            {\n              *pcom= '!';\n            }\n            /* version allowed to have one level of comment inside. */\n          }\n        }\n        else\n        {\n          /* Not a version comment. */\n          state=MY_LEX_START;\n          set_echo(TRUE);\n          break;\n        }\n      }\n      else\n      {\n        in_comment= PRESERVE_COMMENT;\n        yySkip();                  // Accept /\n        yySkip();                  // Accept *\n        comment_closed= ! consume_comment(0);\n        /* regular comments can have zero comments inside. */\n      }\n      /*\n        Discard:\n        - regular '/' '*' comments,\n        - special comments '/' '*' '!' for a future version,\n        by scanning until we find a closing '*' '/' marker.\n\n        Nesting regular comments isn't allowed.  The first \n        '*' '/' returns the parser to the previous state.\n\n        /#!VERSI oned containing /# regular #/ is allowed #/\n\n                Inside one versioned comment, another versioned comment\n                is treated as a regular discardable comment.  It gets\n                no special parsing.\n      */\n\n      /* Unbalanced comments with a missing '*' '/' are a syntax error */\n      if (! comment_closed)\n        return (ABORT_SYM);\n      state = MY_LEX_START;             // Try again\n      restore_in_comment_state();\n      break;\n    case MY_LEX_END_LONG_COMMENT:\n      if ((in_comment != NO_COMMENT) && yyPeek() == '/')\n      {\n        /* Reject '*' '/' */\n        yyUnget();\n        /* Accept '*' '/', with the proper echo */\n        set_echo(in_comment == PRESERVE_COMMENT);\n        yySkipn(2);\n        /* And start recording the tokens again */\n        set_echo(TRUE);\n        in_comment= NO_COMMENT;\n        state=MY_LEX_START;\n      }\n      else\n        state= MY_LEX_CHAR;              // Return '*'\n      break;\n    case MY_LEX_SET_VAR:                // Check if ':='\n      if (yyPeek() != '=')\n      {\n        next_state= MY_LEX_START;\n        if (m_thd->variables.sql_mode & MODE_ORACLE)\n        {\n          yylval->kwd.set_keyword(m_tok_start, 1);\n          return COLON_ORACLE_SYM;\n        }\n        return (int) ':';\n      }\n      yySkip();\n      return (SET_VAR);\n    case MY_LEX_SEMICOLON:              // optional line terminator\n      state= MY_LEX_CHAR;               // Return ';'\n      break;\n    case MY_LEX_EOL:\n      if (eof())\n      {\n        yyUnget();                 // Reject the last '\\0'\n        set_echo(FALSE);\n        yySkip();\n        set_echo(TRUE);\n        /* Unbalanced comments with a missing '*' '/' are a syntax error */\n        if (in_comment != NO_COMMENT)\n          return (ABORT_SYM);\n        next_state= MY_LEX_END;     // Mark for next loop\n        return(END_OF_INPUT);\n      }\n      state=MY_LEX_CHAR;\n      break;\n    case MY_LEX_END:\n      next_state= MY_LEX_END;\n      return(0);                        // We found end of input last time\n\n      /* Actually real shouldn't start with . but allow them anyhow */\n    case MY_LEX_REAL_OR_POINT:\n      if (my_isdigit(cs, (c= yyPeek())))\n        state = MY_LEX_REAL;            // Real\n      else if (c == '.')\n      {\n        yySkip();\n        return DOT_DOT_SYM;\n      }\n      else\n      {\n        state= MY_LEX_IDENT_SEP;        // return '.'\n        yyUnget();                 // Put back '.'\n      }\n      break;\n    case MY_LEX_USER_END:               // end '@' of user@hostname\n      switch (state_map[(uchar) yyPeek()]) {\n      case MY_LEX_STRING:\n      case MY_LEX_USER_VARIABLE_DELIMITER:\n      case MY_LEX_STRING_OR_DELIMITER:\n        break;\n      case MY_LEX_USER_END:\n        next_state= MY_LEX_SYSTEM_VAR;\n        break;\n      default:\n        next_state= MY_LEX_HOSTNAME;\n        break;\n      }\n      yylval->lex_str.str= (char*) get_ptr();\n      yylval->lex_str.length= 1;\n      return((int) '@');\n    case MY_LEX_HOSTNAME:               // end '@' of user@hostname\n      for (c= yyGet() ;\n           my_isalnum(cs, c) || c == '.' || c == '_' ||  c == '$';\n           c= yyGet()) ;\n      yylval->lex_str= get_token(0, yyLength());\n      return(LEX_HOSTNAME);\n    case MY_LEX_SYSTEM_VAR:\n      yylval->lex_str.str= (char*) get_ptr();\n      yylval->lex_str.length= 1;\n      yySkip();                                    // Skip '@'\n      next_state= (state_map[(uchar) yyPeek()] ==\n                        MY_LEX_USER_VARIABLE_DELIMITER ?\n                        MY_LEX_OPERATOR_OR_IDENT :\n                        MY_LEX_IDENT_OR_KEYWORD);\n      return((int) '@');\n    case MY_LEX_IDENT_OR_KEYWORD:\n      /*\n        We come here when we have found two '@' in a row.\n        We should now be able to handle:\n        [(global | local | session) .]variable_name\n      */\n      return scan_ident_sysvar(thd, &yylval->ident_cli);\n    }\n  }\n}",
        "target": 0
    },
    {
        "func": "bool LEX::part_values_current(THD *thd)\n{\n  partition_element *elem= part_info->curr_part_elem;\n  if (!is_partition_management())\n  {\n    if (unlikely(part_info->part_type != VERSIONING_PARTITION))\n    {\n      my_error(ER_PARTITION_WRONG_TYPE, MYF(0), \"SYSTEM_TIME\");\n      return true;\n    }\n  }\n  else\n  {\n    DBUG_ASSERT(create_last_non_select_table);\n    DBUG_ASSERT(create_last_non_select_table->table_name.str);\n    // FIXME: other ALTER commands?\n    my_error(ER_VERS_WRONG_PARTS, MYF(0),\n             create_last_non_select_table->table_name.str);\n    return true;\n  }\n  elem->type= partition_element::CURRENT;\n  DBUG_ASSERT(part_info->vers_info);\n  part_info->vers_info->now_part= elem;\n  return false;\n}",
        "target": 0
    },
    {
        "func": "  void init() { bzero(this, sizeof(*this)); }",
        "target": 0
    },
    {
        "func": "  SELECT_LEX *pop_select()\n  {\n    DBUG_ENTER(\"LEX::pop_select\");\n    SELECT_LEX *select_lex;\n    if (likely(select_stack_top))\n      select_lex= select_stack[--select_stack_top];\n    else\n      select_lex= 0;\n    DBUG_PRINT(\"info\", (\"Top Select is %p (%d)  depth: %u  poped: %p (%d)\",\n                        select_stack_head(),\n                        select_stack_top,\n                        (select_stack_top ?\n                         select_stack_head()->select_number :\n                         0),\n                        select_lex,\n                        (select_lex ? select_lex->select_number : 0)));\n    DBUG_ASSERT(select_lex);\n\n    pop_context();\n\n    if (unlikely(!select_stack_top))\n    {\n      current_select= &builtin_select;\n      DBUG_PRINT(\"info\", (\"Top Select is empty -> sel builtin: %p\",\n                          current_select));\n    }\n    else\n      current_select= select_stack[select_stack_top - 1];\n\n    DBUG_RETURN(select_lex);\n  }",
        "target": 0
    },
    {
        "func": "  bool stmt_create_procedure_start(const DDL_options_st &options)\n  {\n    sql_command= SQLCOM_CREATE_PROCEDURE;\n    return stmt_create_routine_start(options);\n  }",
        "target": 0
    },
    {
        "func": "  void yySkip()\n  {\n    if (m_echo)\n      *m_cpp_ptr++ = *m_ptr++;\n    else\n      m_ptr++;\n  }",
        "target": 0
    },
    {
        "func": "  bool add_create_options_with_check(DDL_options_st options)\n  {\n    create_info.add(options);\n    return check_create_options(create_info);\n  }",
        "target": 0
    },
    {
        "func": "  Name_resolution_context *current_context()\n  {\n    return context_stack.head();\n  }",
        "target": 0
    },
    {
        "func": "LEX::sp_variable_declarations_column_type_finalize(THD *thd, int nvars,\n                                                   Qualified_column_ident *ref,\n                                                   Item *def)\n{\n  for (uint i= 0 ; i < (uint) nvars; i++)\n  {\n    sp_variable *spvar= spcont->get_last_context_variable((uint) nvars - 1 - i);\n    spvar->field_def.set_column_type_ref(ref);\n    spvar->field_def.field_name= spvar->name;\n  }\n  sphead->m_flags|= sp_head::HAS_COLUMN_TYPE_REFS;\n  if (sp_variable_declarations_set_default(thd, nvars, def))\n    return true;\n  spcont->declare_var_boundary(0);\n  return sphead->restore_lex(thd);\n}",
        "target": 0
    },
    {
        "func": "static bool check_show_access(THD *thd, TABLE_LIST *table)\n{\n  /*\n    This is a SHOW command using an INFORMATION_SCHEMA table.\n    check_access() has not been called for 'table',\n    and SELECT is currently always granted on the I_S, so we automatically\n    grant SELECT on table here, to bypass a call to check_access().\n    Note that not calling check_access(table) is an optimization,\n    which needs to be revisited if the INFORMATION_SCHEMA does\n    not always automatically grant SELECT but use the grant tables.\n    See Bug#38837 need a way to disable information_schema for security\n  */\n  table->grant.privilege= SELECT_ACL;\n\n  switch (get_schema_table_idx(table->schema_table)) {\n  case SCH_SCHEMATA:\n    return (specialflag & SPECIAL_SKIP_SHOW_DB) &&\n      check_global_access(thd, SHOW_DB_ACL);\n\n  case SCH_TABLE_NAMES:\n  case SCH_TABLES:\n  case SCH_VIEWS:\n  case SCH_TRIGGERS:\n  case SCH_EVENTS:\n  {\n    const char *dst_db_name= table->schema_select_lex->db.str;\n\n    DBUG_ASSERT(dst_db_name);\n\n    if (check_access(thd, SELECT_ACL, dst_db_name,\n                     &thd->col_access, NULL, FALSE, FALSE))\n      return TRUE;\n\n    if (!thd->col_access && check_grant_db(thd, dst_db_name))\n    {\n      status_var_increment(thd->status_var.access_denied_errors);\n      my_error(ER_DBACCESS_DENIED_ERROR, MYF(0),\n               thd->security_ctx->priv_user,\n               thd->security_ctx->priv_host,\n               dst_db_name);\n      return TRUE;\n    }\n\n    return FALSE;\n  }\n\n  case SCH_COLUMNS:\n  case SCH_STATISTICS:\n  {\n    TABLE_LIST *dst_table;\n    dst_table= table->schema_select_lex->table_list.first;\n\n    DBUG_ASSERT(dst_table);\n\n    /*\n      Open temporary tables to be able to detect them during privilege check.\n    */\n    if (thd->open_temporary_tables(dst_table))\n      return TRUE;\n\n    if (check_access(thd, SELECT_ACL, dst_table->db.str,\n                     &dst_table->grant.privilege,\n                     &dst_table->grant.m_internal,\n                     FALSE, FALSE))\n          return TRUE; /* Access denied */\n\n    /*\n      Check_grant will grant access if there is any column privileges on\n      all of the tables thanks to the fourth parameter (bool show_table).\n    */\n    if (check_grant(thd, SELECT_ACL, dst_table, TRUE, 1, FALSE))\n      return TRUE; /* Access denied */\n\n    close_thread_tables(thd);\n    dst_table->table= NULL;\n\n    /* Access granted */\n    return FALSE;\n  }\n  default:\n    break;\n  }\n\n  return FALSE;\n}",
        "target": 0
    },
    {
        "func": "bool st_select_lex::collect_fields_equal_to_grouping(THD *thd)\n{\n  if (!join->cond_equal || join->cond_equal->is_empty())\n    return false;\n\n  List_iterator_fast<Item_equal> li(join->cond_equal->current_level);\n  Item_equal *item_equal;\n\n  while ((item_equal= li++))\n  {\n    Item_equal_fields_iterator it(*item_equal);\n    Item *item;\n    while ((item= it++))\n    {\n      if (get_corresponding_field_pair(item, grouping_tmp_fields))\n        break;\n    }\n    if (!item)\n      break;\n\n    it.rewind();\n    while ((item= it++))\n    {\n      if (get_corresponding_field_pair(item, grouping_tmp_fields))\n        continue;\n      Field_pair *grouping_tmp_field=\n        new Field_pair(((Item_field *)item->real_item())->field, item);\n      if (grouping_tmp_fields.push_back(grouping_tmp_field, thd->mem_root))\n        return true;\n    }\n  }\n  return false;\n}",
        "target": 0
    },
    {
        "func": "Item *LEX::create_item_func_setval(THD *thd, Table_ident *table_ident,\n                                   longlong nextval, ulonglong round,\n                                   bool is_used)\n{\n  TABLE_LIST *table;\n  if (unlikely(!(table= current_select->add_table_to_list(thd, table_ident, 0,\n                                                          TL_OPTION_SEQUENCE,\n                                                          TL_WRITE_ALLOW_WRITE,\n                                                          MDL_SHARED_WRITE))))\n    return NULL;\n  return new (thd->mem_root) Item_func_setval(thd, table, nextval, round,\n                                              is_used);\n}",
        "target": 0
    },
    {
        "func": "  const st_select_lex* first_select() const\n  {\n    return reinterpret_cast<const st_select_lex*>(slave);\n  }",
        "target": 0
    },
    {
        "func": "  inline st_select_lex *global_parameters()\n  {\n    if (fake_select_lex != NULL)\n      return fake_select_lex;\n    else if (saved_fake_select_lex != NULL)\n      return saved_fake_select_lex;\n    return first_select();\n  };",
        "target": 0
    },
    {
        "func": "  void restart_token()\n  {\n    m_tok_start= m_ptr;\n    m_cpp_tok_start= m_cpp_ptr;\n  }",
        "target": 0
    },
    {
        "func": "bool LEX::stmt_uninstall_plugin_by_soname(const DDL_options_st &opt,\n                                          const LEX_CSTRING &soname)\n{\n  check_opt.init();\n  if (add_create_options_with_check(opt))\n    return true;\n  sql_command= SQLCOM_UNINSTALL_PLUGIN;\n  comment= null_clex_str;\n  ident= soname;\n  return false;\n}",
        "target": 0
    },
    {
        "func": "  st_select_lex* first_select()\n  {\n    return reinterpret_cast<st_select_lex*>(slave);\n  }",
        "target": 0
    },
    {
        "func": "THD *find_thread_by_id(longlong id, bool query_id)\n{\n  find_thread_callback_arg arg(id, query_id);\n  server_threads.iterate(find_thread_callback, &arg);\n  return arg.thd;\n}",
        "target": 0
    },
    {
        "func": "  bool sp_block_finalize(THD *thd, const Lex_spblock_st spblock)\n  {\n    class sp_label *tmp;\n    return sp_block_finalize(thd, spblock, &tmp);\n  }",
        "target": 0
    },
    {
        "func": "bool LEX::sp_push_loop_empty_label(THD *thd)\n{\n  if (maybe_start_compound_statement(thd))\n    return true;\n  /* Unlabeled controls get an empty label. */\n  spcont->push_label(thd, &empty_clex_str, sphead->instructions(),\n                     sp_label::ITERATION);\n  return false;\n}",
        "target": 0
    },
    {
        "func": "bool LEX::set_variable(const LEX_CSTRING *name1,\n                       const LEX_CSTRING *name2,\n                       Item *item)\n{\n  const Sp_rcontext_handler *rh;\n  sp_pcontext *ctx;\n  sp_variable *spv;\n  if (spcont && (spv= find_variable(name1, &ctx, &rh)))\n  {\n    if (spv->field_def.is_table_rowtype_ref() ||\n        spv->field_def.is_cursor_rowtype_ref())\n      return sphead->set_local_variable_row_field_by_name(thd, ctx,\n                                                          rh,\n                                                          spv, name2,\n                                                          item, this);\n    // A field of a ROW variable\n    uint row_field_offset;\n    return !spv->find_row_field(name1, name2, &row_field_offset) ||\n           sphead->set_local_variable_row_field(thd, ctx, rh,\n                                                spv, row_field_offset,\n                                                item, this);\n  }\n\n  if (is_trigger_new_or_old_reference(name1))\n    return set_trigger_field(name1, name2, item);\n\n  return set_system_variable(thd, option_type, name1, name2, item);\n}",
        "target": 0
    },
    {
        "func": "bool LEX::stmt_execute(const Lex_ident_sys_st &ident, List<Item> *params)\n{\n  sql_command= SQLCOM_EXECUTE;\n  prepared_stmt.set(ident, NULL, params);\n  return stmt_prepare_validate(\"EXECUTE..USING\");\n}",
        "target": 0
    },
    {
        "func": "  With_clause *get_with_clause()\n  {\n    return master_unit()->with_clause;\n  }",
        "target": 0
    },
    {
        "func": "  bool has_lookahead() const\n  {\n    return lookahead_token >= 0;\n  }",
        "target": 0
    },
    {
        "func": "  const char *pos() const { return str - is_quoted(); }",
        "target": 0
    },
    {
        "func": "  bool is_single_level_stmt() \n  { \n    /* \n      This check exploits the fact that the last added to all_select_list is\n      on its top. So select_lex (as the first added) will be at the tail \n      of the list.\n    */ \n    if (first_select_lex() == all_selects_list && !sroutines.records)\n    {\n      return TRUE;\n    }\n    return FALSE;\n  }",
        "target": 0
    },
    {
        "func": "Item *LEX::make_item_func_substr(THD *thd, Item *a, Item *b, Item *c)\n{\n  return (thd->variables.sql_mode & MODE_ORACLE) ?\n    new (thd->mem_root) Item_func_substr_oracle(thd, a, b, c) :\n    new (thd->mem_root) Item_func_substr(thd, a, b, c);\n}",
        "target": 0
    },
    {
        "func": "int path_starts_from_data_home_dir(const char *path)\n{\n  size_t dir_len= strlen(path);\n  DBUG_ENTER(\"path_starts_from_data_home_dir\");\n\n  if (mysql_unpacked_real_data_home_len<= dir_len)\n  {\n    if (dir_len > mysql_unpacked_real_data_home_len &&\n        path[mysql_unpacked_real_data_home_len] != FN_LIBCHAR)\n      DBUG_RETURN(0);\n\n    if (lower_case_file_system)\n    {\n      if (!my_strnncoll(default_charset_info, (const uchar*) path,\n                        mysql_unpacked_real_data_home_len,\n                        (const uchar*) mysql_unpacked_real_data_home,\n                        mysql_unpacked_real_data_home_len))\n      {\n        DBUG_PRINT(\"error\", (\"Path is part of mysql_real_data_home\"));\n        DBUG_RETURN(1);\n      }\n    }\n    else if (!memcmp(path, mysql_unpacked_real_data_home,\n                     mysql_unpacked_real_data_home_len))\n    {\n      DBUG_PRINT(\"error\", (\"Path is part of mysql_real_data_home\"));\n      DBUG_RETURN(1);\n    }\n  }\n  DBUG_RETURN(0);\n}",
        "target": 0
    },
    {
        "func": "void st_select_lex::add_statistics(SELECT_LEX_UNIT *unit)\n{\n  for (;\n       unit;\n       unit= unit->next_unit())\n    for(SELECT_LEX *child= unit->first_select();\n        child;\n        child= child->next_select())\n    {\n      /*\n        A subselect can add fields to an outer select.\n        Reserve space for them.\n      */\n      select_n_where_fields+= child->select_n_where_fields;\n      /*\n        Aggregate functions in having clause may add fields\n        to an outer select. Count them also.\n      */\n      select_n_having_items+= child->select_n_having_items;\n    }\n}",
        "target": 0
    },
    {
        "func": "static bool do_execute_sp(THD *thd, sp_head *sp)\n{\n  /* bits that should be cleared in thd->server_status */\n  uint bits_to_be_cleared= 0;\n  ulonglong affected_rows;\n  if (sp->m_flags & sp_head::MULTI_RESULTS)\n  {\n    if (!(thd->client_capabilities & CLIENT_MULTI_RESULTS))\n    {\n      /* The client does not support multiple result sets being sent back */\n      my_error(ER_SP_BADSELECT, MYF(0), ErrConvDQName(sp).ptr());\n      return 1;\n    }\n  }\n  /*\n    If SERVER_MORE_RESULTS_EXISTS is not set,\n    then remember that it should be cleared\n  */\n  bits_to_be_cleared= (~thd->server_status &\n                       SERVER_MORE_RESULTS_EXISTS);\n  thd->server_status|= SERVER_MORE_RESULTS_EXISTS;\n  ha_rows select_limit= thd->variables.select_limit;\n  thd->variables.select_limit= HA_POS_ERROR;\n\n  /*\n    Reset current_select as it may point to random data as a\n    result of previous parsing.\n  */\n  thd->lex->current_select= NULL;\n  thd->lex->in_sum_func= 0;                     // For Item_field::fix_fields()\n\n  /*\n    We never write CALL statements into binlog:\n     - If the mode is non-prelocked, each statement will be logged\n       separately.\n     - If the mode is prelocked, the invoking statement will care\n       about writing into binlog.\n    So just execute the statement.\n  */\n  int res= sp->execute_procedure(thd, &thd->lex->value_list);\n\n  thd->variables.select_limit= select_limit;\n  thd->server_status&= ~bits_to_be_cleared;\n\n  if (res)\n  {\n    DBUG_ASSERT(thd->is_error() || thd->killed);\n    return 1;  \t\t// Substatement should already have sent error\n  }\n\n  affected_rows= thd->affected_rows; // Affected rows for all sub statements\n  thd->affected_rows= 0;             // Reset total, as my_ok() adds to it\n  my_ok(thd, affected_rows);\n  return 0;\n}",
        "target": 0
    },
    {
        "func": "TABLE_LIST *st_select_lex::add_table_to_list(THD *thd,\n\t\t\t\t\t     Table_ident *table,\n\t\t\t\t\t     LEX_CSTRING *alias,\n\t\t\t\t\t     ulong table_options,\n\t\t\t\t\t     thr_lock_type lock_type,\n\t\t\t\t\t     enum_mdl_type mdl_type,\n\t\t\t\t\t     List<Index_hint> *index_hints_arg,\n                                             List<String> *partition_names,\n                                             LEX_STRING *option)\n{\n  TABLE_LIST *ptr;\n  TABLE_LIST *UNINIT_VAR(previous_table_ref); /* The table preceding the current one. */\n  LEX_CSTRING alias_str;\n  LEX *lex= thd->lex;\n  DBUG_ENTER(\"add_table_to_list\");\n  DBUG_PRINT(\"enter\", (\"Table '%s' (%p)  Select %p (%u)\",\n                        (alias ? alias->str : table->table.str),\n                        table,\n                        this, select_number));\n  DBUG_ASSERT(!is_service_select  || (table_options & TL_OPTION_SEQUENCE));\n\n  if (unlikely(!table))\n    DBUG_RETURN(0);\t\t\t\t// End of memory\n  alias_str= alias ? *alias : table->table;\n  DBUG_ASSERT(alias_str.str);\n  if (!MY_TEST(table_options & TL_OPTION_ALIAS) &&\n      unlikely(check_table_name(table->table.str, table->table.length, FALSE)))\n  {\n    my_error(ER_WRONG_TABLE_NAME, MYF(0), table->table.str);\n    DBUG_RETURN(0);\n  }\n\n  if (unlikely(table->is_derived_table() == FALSE && table->db.str &&\n               check_db_name((LEX_STRING*) &table->db)))\n  {\n    my_error(ER_WRONG_DB_NAME, MYF(0), table->db.str);\n    DBUG_RETURN(0);\n  }\n\n  if (!alias)                            /* Alias is case sensitive */\n  {\n    if (unlikely(table->sel))\n    {\n      my_message(ER_DERIVED_MUST_HAVE_ALIAS,\n                 ER_THD(thd, ER_DERIVED_MUST_HAVE_ALIAS), MYF(0));\n      DBUG_RETURN(0);\n    }\n    /* alias_str points to table->table;  Let's make a copy */\n    if (unlikely(!(alias_str.str= (char*) thd->memdup(alias_str.str, alias_str.length+1))))\n      DBUG_RETURN(0);\n  }\n  if (unlikely(!(ptr = (TABLE_LIST *) thd->calloc(sizeof(TABLE_LIST)))))\n    DBUG_RETURN(0);\t\t\t\t/* purecov: inspected */\n  if (table->db.str)\n  {\n    ptr->is_fqtn= TRUE;\n    ptr->db= table->db;\n  }\n  else if (!lex->with_cte_resolution && lex->copy_db_to(&ptr->db))\n    DBUG_RETURN(0);\n  else\n    ptr->is_fqtn= FALSE;\n\n  ptr->alias= alias_str;\n  ptr->is_alias= alias ? TRUE : FALSE;\n  if (lower_case_table_names)\n  {\n    if (table->table.length)\n      table->table.length= my_casedn_str(files_charset_info,\n                                         (char*) table->table.str);\n    if (ptr->db.length && ptr->db.str != any_db)\n      ptr->db.length= my_casedn_str(files_charset_info, (char*) ptr->db.str);\n  }\n\n  ptr->table_name= table->table;\n  ptr->lock_type= lock_type;\n  ptr->mdl_type= mdl_type;\n  ptr->table_options= table_options;\n  ptr->updating=    MY_TEST(table_options & TL_OPTION_UPDATING);\n  /* TODO: remove TL_OPTION_FORCE_INDEX as it looks like it's not used */\n  ptr->force_index= MY_TEST(table_options & TL_OPTION_FORCE_INDEX);\n  ptr->ignore_leaves= MY_TEST(table_options & TL_OPTION_IGNORE_LEAVES);\n  ptr->sequence=      MY_TEST(table_options & TL_OPTION_SEQUENCE);\n  ptr->derived=\t    table->sel;\n  if (!ptr->derived && is_infoschema_db(&ptr->db))\n  {\n    if (ptr->updating &&\n        /* Special cases which are processed by commands itself */\n        lex->sql_command != SQLCOM_CHECK &&\n        lex->sql_command != SQLCOM_CHECKSUM)\n    {\n      my_error(ER_DBACCESS_DENIED_ERROR, MYF(0),\n               thd->security_ctx->priv_user,\n               thd->security_ctx->priv_host,\n               INFORMATION_SCHEMA_NAME.str);\n      DBUG_RETURN(0);\n    }\n    ST_SCHEMA_TABLE *schema_table;\n    schema_table= find_schema_table(thd, &ptr->table_name);\n    ptr->schema_table_name= ptr->table_name;\n    ptr->schema_table= schema_table;\n  }\n  ptr->select_lex= this;\n  /*\n    We can't cache internal temporary tables between prepares as the\n    table may be deleted before next exection.\n */\n  ptr->cacheable_table= !table->is_derived_table();\n  ptr->index_hints= index_hints_arg;\n  ptr->option= option ? option->str : 0;\n  /* check that used name is unique. Sequences are ignored */\n  if (lock_type != TL_IGNORE && !ptr->sequence)\n  {\n    TABLE_LIST *first_table= table_list.first;\n    if (lex->sql_command == SQLCOM_CREATE_VIEW)\n      first_table= first_table ? first_table->next_local : NULL;\n    for (TABLE_LIST *tables= first_table ;\n\t tables ;\n\t tables=tables->next_local)\n    {\n      if (unlikely(!my_strcasecmp(table_alias_charset, alias_str.str,\n                                  tables->alias.str) &&\n                   !cmp(&ptr->db, &tables->db) && ! tables->sequence))\n      {\n\tmy_error(ER_NONUNIQ_TABLE, MYF(0), alias_str.str); /* purecov: tested */\n\tDBUG_RETURN(0);\t\t\t\t/* purecov: tested */\n      }\n    }\n  }\n  /* Store the table reference preceding the current one. */\n  if (table_list.elements > 0 && likely(!ptr->sequence))\n  {\n    /*\n      table_list.next points to the last inserted TABLE_LIST->next_local'\n      element\n      We don't use the offsetof() macro here to avoid warnings from gcc\n    */\n    previous_table_ref= (TABLE_LIST*) ((char*) table_list.next -\n                                       ((char*) &(ptr->next_local) -\n                                        (char*) ptr));\n    /*\n      Set next_name_resolution_table of the previous table reference to point\n      to the current table reference. In effect the list\n      TABLE_LIST::next_name_resolution_table coincides with\n      TABLE_LIST::next_local. Later this may be changed in\n      store_top_level_join_columns() for NATURAL/USING joins.\n    */\n    previous_table_ref->next_name_resolution_table= ptr;\n  }\n\n  /*\n    Link the current table reference in a local list (list for current select).\n    Notice that as a side effect here we set the next_local field of the\n    previous table reference to 'ptr'. Here we also add one element to the\n    list 'table_list'.\n    We don't store sequences into the local list to hide them from INSERT\n    and SELECT.\n  */\n  if (likely(!ptr->sequence))\n    table_list.link_in_list(ptr, &ptr->next_local);\n  ptr->next_name_resolution_table= NULL;\n#ifdef WITH_PARTITION_STORAGE_ENGINE\n  ptr->partition_names= partition_names;\n#endif /* WITH_PARTITION_STORAGE_ENGINE */\n  /* Link table in global list (all used tables) */\n  lex->add_to_query_tables(ptr);\n\n  // Pure table aliases do not need to be locked:\n  if (ptr->db.str && !(table_options & TL_OPTION_ALIAS))\n  {\n    ptr->mdl_request.init(MDL_key::TABLE, ptr->db.str, ptr->table_name.str,\n                          mdl_type,\n                          MDL_TRANSACTION);\n  }\n  DBUG_RETURN(ptr);\n}",
        "target": 0
    },
    {
        "func": "  SELECT_LEX *parser_current_outer_select()\n  {\n    return select_stack_top - 1 == select_stack_outer_barrier ?\n             0 : select_stack[select_stack_top - 1];\n  }",
        "target": 0
    },
    {
        "func": "  inline bool stmt_accessed_temp_table()\n  {\n    DBUG_ENTER(\"THD::stmt_accessed_temp_table\");\n    DBUG_RETURN(stmt_accessed_non_trans_temp_table() ||\n                stmt_accessed_trans_temp_table());\n  }",
        "target": 0
    },
    {
        "func": "bool LEX::maybe_start_compound_statement(THD *thd)\n{\n  if (!sphead)\n  {\n    if (!make_sp_head(thd, NULL, &sp_handler_procedure, DEFAULT_AGGREGATE))\n      return true;\n    sphead->set_suid(SP_IS_NOT_SUID);\n    sphead->set_body_start(thd, thd->m_parser_state->m_lip.get_cpp_ptr());\n  }\n  return false;\n}",
        "target": 0
    },
    {
        "func": "  void set_keyword(const char *s, size_t len)\n  {\n    set(s, len, false, '\\0');\n  }",
        "target": 0
    },
    {
        "func": "LEX::sp_variable_declarations_copy_type_finalize(THD *thd, int nvars,\n                                                 const Column_definition &ref,\n                                                 Row_definition_list *fields,\n                                                 Item *default_value)\n{\n  for (uint i= 0 ; i < (uint) nvars; i++)\n  {\n    sp_variable *spvar= spcont->get_last_context_variable((uint) nvars - 1 - i);\n    spvar->field_def.set_type(ref);\n    if (fields)\n    {\n      DBUG_ASSERT(ref.type_handler() == &type_handler_row);\n      spvar->field_def.set_row_field_definitions(fields);\n    }\n    spvar->field_def.field_name= spvar->name;\n  }\n  if (unlikely(sp_variable_declarations_set_default(thd, nvars,\n                                                    default_value)))\n    return true;\n  spcont->declare_var_boundary(0);\n  return sphead->restore_lex(thd);\n}",
        "target": 0
    },
    {
        "func": "LEX::sp_variable_declarations_rowtype_finalize(THD *thd, int nvars,\n                                               Qualified_column_ident *ref,\n                                               Item *def)\n{\n  uint coffp;\n  const sp_pcursor *pcursor= ref->table.str && ref->db.str ? NULL :\n                             spcont->find_cursor(&ref->m_column, &coffp,\n                                                 false);\n  if (pcursor)\n    return sp_variable_declarations_cursor_rowtype_finalize(thd, nvars,\n                                                            coffp, def);\n  /*\n    When parsing a qualified identifier chain, the parser does not know yet\n    if it's going to be a qualified column name (for %TYPE),\n    or a qualified table name (for %ROWTYPE). So it collects the chain\n    into Qualified_column_ident.\n    Now we know that it was actually a qualified table name (%ROWTYPE).\n    Create a new Table_ident from Qualified_column_ident,\n    shifting fields as follows:\n    - ref->m_column becomes table_ref->table\n    - ref->table    becomes table_ref->db\n  */\n  return sp_variable_declarations_table_rowtype_finalize(thd, nvars,\n                                                         ref->table,\n                                                         ref->m_column,\n                                                         def);\n}",
        "target": 0
    },
    {
        "func": "int bootstrap(MYSQL_FILE *file)\n{\n  int bootstrap_error= 0;\n  DBUG_ENTER(\"handle_bootstrap\");\n\n  THD *thd= new THD(next_thread_id());\n#ifdef WITH_WSREP\n  thd->variables.wsrep_on= 0;\n#endif\n  thd->bootstrap=1;\n  my_net_init(&thd->net,(st_vio*) 0, thd, MYF(0));\n  thd->max_client_packet_length= thd->net.max_packet;\n  thd->security_ctx->master_access= ~(ulong)0;\n\n#ifndef EMBEDDED_LIBRARY\n  mysql_thread_set_psi_id(thd->thread_id);\n#else\n  thd->mysql= 0;\n#endif\n\n  /* The following must be called before DBUG_ENTER */\n  thd->thread_stack= (char*) &thd;\n  thd->store_globals();\n\n  thd->security_ctx->user= (char*) my_strdup(\"boot\", MYF(MY_WME));\n  thd->security_ctx->priv_user[0]= thd->security_ctx->priv_host[0]=\n    thd->security_ctx->priv_role[0]= 0;\n  /*\n    Make the \"client\" handle multiple results. This is necessary\n    to enable stored procedures with SELECTs and Dynamic SQL\n    in init-file.\n  */\n  thd->client_capabilities|= CLIENT_MULTI_RESULTS;\n\n  thd->init_for_queries();\n\n  for ( ; ; )\n  {\n    char buffer[MAX_BOOTSTRAP_QUERY_SIZE] = \"\";\n    int rc, length;\n    char *query;\n    int error= 0;\n\n    rc= read_bootstrap_query(buffer, &length, file, fgets_fn, &error);\n\n    if (rc == READ_BOOTSTRAP_EOF)\n      break;\n    /*\n      Check for bootstrap file errors. SQL syntax errors will be\n      caught below.\n    */\n    if (rc != READ_BOOTSTRAP_SUCCESS)\n    {\n      /*\n        mysql_parse() may have set a successful error status for the previous\n        query. We must clear the error status to report the bootstrap error.\n      */\n      thd->get_stmt_da()->reset_diagnostics_area();\n\n      /* Get the nearest query text for reference. */\n      char *err_ptr= buffer + (length <= MAX_BOOTSTRAP_ERROR_LEN ?\n                                        0 : (length - MAX_BOOTSTRAP_ERROR_LEN));\n      switch (rc)\n      {\n      case READ_BOOTSTRAP_ERROR:\n        my_printf_error(ER_UNKNOWN_ERROR, \"Bootstrap file error, return code (%d). \"\n                        \"Nearest query: '%s'\", MYF(0), error, err_ptr);\n        break;\n\n      case READ_BOOTSTRAP_QUERY_SIZE:\n        my_printf_error(ER_UNKNOWN_ERROR, \"Boostrap file error. Query size \"\n                        \"exceeded %d bytes near '%s'.\", MYF(0),\n                        MAX_BOOTSTRAP_LINE_SIZE, err_ptr);\n        break;\n\n      default:\n        DBUG_ASSERT(false);\n        break;\n      }\n\n      thd->protocol->end_statement();\n      bootstrap_error= 1;\n      break;\n    }\n\n    query= (char *) thd->memdup_w_gap(buffer, length + 1,\n                                      thd->db.length + 1 +\n                                      QUERY_CACHE_DB_LENGTH_SIZE +\n                                      QUERY_CACHE_FLAGS_SIZE);\n    size_t db_len= 0;\n    memcpy(query + length + 1, (char *) &db_len, sizeof(size_t));\n    thd->set_query_and_id(query, length, thd->charset(), next_query_id());\n    int2store(query + length + 1, 0);           // No db in bootstrap\n    DBUG_PRINT(\"query\",(\"%-.4096s\",thd->query()));\n#if defined(ENABLED_PROFILING)\n    thd->profiling.start_new_query();\n    thd->profiling.set_query_source(thd->query(), length);\n#endif\n\n    thd->set_time();\n    Parser_state parser_state;\n    if (parser_state.init(thd, thd->query(), length))\n    {\n      thd->protocol->end_statement();\n      bootstrap_error= 1;\n      break;\n    }\n\n    mysql_parse(thd, thd->query(), length, &parser_state, FALSE, FALSE);\n\n    bootstrap_error= thd->is_error();\n    thd->protocol->end_statement();\n\n#if defined(ENABLED_PROFILING)\n    thd->profiling.finish_current_query();\n#endif\n    delete_explain_query(thd->lex);\n\n    if (unlikely(bootstrap_error))\n      break;\n\n    thd->reset_kill_query();  /* Ensure that killed_errmsg is released */\n    free_root(thd->mem_root,MYF(MY_KEEP_PREALLOC));\n    thd->lex->restore_set_statement_var();\n  }\n  delete thd;\n  DBUG_RETURN(bootstrap_error);\n}",
        "target": 0
    },
    {
        "func": "bool check_fk_parent_table_access(THD *thd,\n                                  HA_CREATE_INFO *create_info,\n                                  Alter_info *alter_info,\n                                  const char* create_db)\n{\n  Key *key;\n  List_iterator<Key> key_iterator(alter_info->key_list);\n\n  while ((key= key_iterator++))\n  {\n    if (key->type == Key::FOREIGN_KEY)\n    {\n      TABLE_LIST parent_table;\n      bool is_qualified_table_name;\n      Foreign_key *fk_key= (Foreign_key *)key;\n      LEX_CSTRING db_name;\n      LEX_CSTRING table_name= { fk_key->ref_table.str,\n                               fk_key->ref_table.length };\n      const ulong privileges= (SELECT_ACL | INSERT_ACL | UPDATE_ACL |\n                               DELETE_ACL | REFERENCES_ACL);\n\n      // Check if tablename is valid or not.\n      DBUG_ASSERT(table_name.str != NULL);\n      if (check_table_name(table_name.str, table_name.length, false))\n      {\n        my_error(ER_WRONG_TABLE_NAME, MYF(0), table_name.str);\n        return true;\n      }\n\n      if (fk_key->ref_db.str)\n      {\n        is_qualified_table_name= true;\n        if (!(db_name.str= (char *) thd->memdup(fk_key->ref_db.str,\n                                                fk_key->ref_db.length+1)))\n          return true;\n        db_name.length= fk_key->ref_db.length;\n\n        // Check if database name is valid or not.\n        if (check_db_name((LEX_STRING*) &db_name))\n        {\n          my_error(ER_WRONG_DB_NAME, MYF(0), db_name.str);\n          return true;\n        }\n      }\n      else\n      {\n        if (!thd->db.str)\n        {\n          DBUG_ASSERT(create_db);\n          db_name.length= strlen(create_db);\n          if (!(db_name.str= (char *) thd->memdup(create_db,\n                                                  db_name.length+1)))\n            return true;\n          is_qualified_table_name= true;\n\n          if (check_db_name((LEX_STRING*) &db_name))\n          {\n            my_error(ER_WRONG_DB_NAME, MYF(0), db_name.str);\n            return true;\n          }\n        }\n        else\n        {\n          if (thd->lex->copy_db_to(&db_name))\n            return true;\n          else\n           is_qualified_table_name= false;\n        }\n      }\n\n      // if lower_case_table_names is set then convert tablename to lower case.\n      if (lower_case_table_names)\n      {\n        char *name;\n        table_name.str= name= (char *) thd->memdup(fk_key->ref_table.str,\n                                                   fk_key->ref_table.length+1);\n        table_name.length= my_casedn_str(files_charset_info, name);\n        db_name.length= my_casedn_str(files_charset_info, (char*) db_name.str);\n      }\n\n      parent_table.init_one_table(&db_name, &table_name, 0, TL_IGNORE);\n\n      /*\n       Check if user has any of the \"privileges\" at table level on\n       \"parent_table\".\n       Having privilege on any of the parent_table column is not\n       enough so checking whether user has any of the \"privileges\"\n       at table level only here.\n      */\n      if (check_some_access(thd, privileges, &parent_table) ||\n          parent_table.grant.want_privilege)\n      {\n        if (is_qualified_table_name)\n        {\n          const size_t qualified_table_name_len= NAME_LEN + 1 + NAME_LEN + 1;\n          char *qualified_table_name= (char *) thd->alloc(qualified_table_name_len);\n\n          my_snprintf(qualified_table_name, qualified_table_name_len, \"%s.%s\",\n                      db_name.str, table_name.str);\n          table_name.str= qualified_table_name;\n        }\n\n        my_error(ER_TABLEACCESS_DENIED_ERROR, MYF(0),\n                 \"REFERENCES\",\n                 thd->security_ctx->priv_user,\n                 thd->security_ctx->host_or_ip,\n                 table_name.str);\n\n        return true;\n      }\n    }\n  }\n\n  return false;\n}",
        "target": 0
    },
    {
        "func": "  TABLE_LIST* first_not_own_table()\n  {\n    return ( query_tables_own_last ? *query_tables_own_last : 0);\n  }",
        "target": 0
    },
    {
        "func": "  bool add_key(Key::Keytype key_type, const LEX_CSTRING *key_name,\n               ha_key_alg algorithm, DDL_options_st ddl)\n  {\n    if (check_add_key(ddl) ||\n        !(last_key= new Key(key_type, key_name, algorithm, false, ddl)))\n      return true;\n    alter_info.key_list.push_back(last_key);\n    return false;\n  }",
        "target": 0
    },
    {
        "func": "bool LEX::sp_body_finalize_routine(THD *thd)\n{\n  if (sphead->check_unresolved_goto())\n    return true;\n  sphead->set_stmt_end(thd);\n  sphead->restore_thd_mem_root(thd);\n  return false;\n}",
        "target": 0
    },
    {
        "func": "  const SELECT_LEX *first_select_lex() const { return unit.first_select(); }",
        "target": 0
    },
    {
        "func": "  void set_agg_func_used(bool val)      { m_agg_func_used= val; }",
        "target": 0
    },
    {
        "func": "  void set_8bit(bool is_8bit) { m_is_8bit= is_8bit; }",
        "target": 0
    },
    {
        "func": "sp_variable *LEX::sp_add_for_loop_variable(THD *thd, const LEX_CSTRING *name,\n                                           Item *value)\n{\n  sp_variable *spvar= spcont->add_variable(thd, name);\n  spcont->declare_var_boundary(1);\n  spvar->field_def.field_name= spvar->name;\n  spvar->field_def.set_handler(&type_handler_longlong);\n  type_handler_longlong.Column_definition_prepare_stage2(&spvar->field_def,\n                                                         NULL, HA_CAN_GEOMETRY);\n  if (!value && unlikely(!(value= new (thd->mem_root) Item_null(thd))))\n    return NULL;\n\n  spvar->default_value= value;\n  sp_instr_set *is= new (this->thd->mem_root)\n                    sp_instr_set(sphead->instructions(),\n                                 spcont, &sp_rcontext_handler_local,\n                                 spvar->offset, value,\n                                 this, true);\n  if (unlikely(is == NULL || sphead->add_instr(is)))\n    return NULL;\n  spcont->declare_var_boundary(0);\n  return spvar;\n}",
        "target": 0
    },
    {
        "func": "  inline bool is_prepared() { return prepared; }",
        "target": 0
    },
    {
        "func": "SELECT_LEX *LEX::alloc_select(bool select)\n{\n  SELECT_LEX *select_lex;\n  DBUG_ENTER(\"LEX::alloc_select\");\n  if (!(select_lex= new (thd->mem_root) SELECT_LEX()))\n    DBUG_RETURN(NULL);\n  DBUG_PRINT(\"info\", (\"Allocate select: %p #%u  statement lex: %p\",\n                      select_lex, thd->lex->stmt_lex->current_select_number,\n                      thd->lex->stmt_lex));\n  /*\n    TODO: move following init to constructor when we get rid of builtin\n    select\n  */\n  select_lex->select_number= ++thd->lex->stmt_lex->current_select_number;\n  select_lex->parent_lex= this; /* Used in init_query. */\n  select_lex->init_query();\n  if (select)\n    select_lex->init_select();\n  select_lex->nest_level_base= &this->unit;\n  select_lex->include_global((st_select_lex_node**)&all_selects_list);\n  select_lex->context.resolve_in_select_list= TRUE;\n  DBUG_RETURN(select_lex);\n}",
        "target": 0
    },
    {
        "func": "bool LEX::sp_open_cursor(THD *thd, const LEX_CSTRING *name,\n                         List<sp_assignment_lex> *parameters)\n{\n  uint offset;\n  const sp_pcursor *pcursor;\n  uint param_count= parameters ? parameters->elements : 0;\n  return !(pcursor= spcont->find_cursor_with_error(name, &offset, false)) ||\n         pcursor->check_param_count_with_error(param_count) ||\n         sphead->add_open_cursor(thd, spcont, offset,\n                                 pcursor->param_context(), parameters);\n}",
        "target": 0
    },
    {
        "func": "static my_bool find_thread_callback(THD *thd, find_thread_callback_arg *arg)\n{\n  if (arg->id == (arg->query_id ? thd->query_id : (longlong) thd->thread_id))\n  {\n    mysql_mutex_lock(&thd->LOCK_thd_kill);    // Lock from delete\n    arg->thd= thd;\n    return 1;\n  }\n  return 0;\n}",
        "target": 0
    },
    {
        "func": "bool SELECT_LEX_UNIT::set_lock_to_the_last_select(Lex_select_lock l)\n{\n  if (l.defined_lock)\n  {\n    SELECT_LEX *sel= first_select();\n    while (sel->next_select())\n      sel= sel->next_select();\n    if (sel->braces)\n    {\n      my_error(ER_WRONG_USAGE, MYF(0), \"lock options\",\n               \"SELECT in brackets\");\n      return TRUE;\n    }\n    l.set_to(sel);\n  }\n  return FALSE;\n}",
        "target": 0
    },
    {
        "func": "  bool eof(int n)\n  {\n    return ((m_ptr + n) >= m_end_of_query);\n  }",
        "target": 0
    },
    {
        "func": "  void set(const Lex_ident_sys_st &ident, Item *code, List<Item> *params)\n  {\n    DBUG_ASSERT(m_params.elements == 0);\n    m_name= ident;\n    m_code= code;\n    if (params)\n      m_params= *params;\n  }",
        "target": 0
    },
    {
        "func": "  void set_query_tables_list(Query_tables_list *state)\n  {\n    *this= *state;\n  }",
        "target": 0
    },
    {
        "func": "bool LEX::sp_exit_block(THD *thd, sp_label *lab)\n{\n  /*\n    When jumping to a BEGIN-END block end, the target jump\n    points to the block hpop/cpop cleanup instructions,\n    so we should exclude the block context here.\n    When jumping to something else (i.e., SP_LAB_ITER),\n    there are no hpop/cpop at the jump destination,\n    so we should include the block context here for cleanup.\n  */\n  bool exclusive= (lab->type == sp_label::BEGIN);\n  return sp_change_context(thd, lab->ctx, exclusive) ||\n         sphead->add_instr_jump_forward_with_backpatch(thd, spcont, lab);\n}",
        "target": 0
    },
    {
        "func": "  enum sub_select_type get_linkage() { return linkage; }",
        "target": 0
    },
    {
        "func": "  bool sp_declarations_join(Lex_spblock_st *res,\n                            const Lex_spblock_st b1,\n                            const Lex_spblock_st b2) const\n  {\n    if ((b2.vars || b2.conds) && (b1.curs || b1.hndlrs))\n    {\n      my_error(ER_SP_VARCOND_AFTER_CURSHNDLR, MYF(0));\n      return true;\n    }\n    if (b2.curs && b1.hndlrs)\n    {\n      my_error(ER_SP_CURSOR_AFTER_HANDLER, MYF(0));\n      return true;\n    }\n    res->join(b1, b2);\n    return false;\n  }",
        "target": 0
    },
    {
        "func": "static void wsrep_copy_query(THD *thd)\n{\n  thd->wsrep_retry_command   = thd->get_command();\n  thd->wsrep_retry_query_len = thd->query_length();\n  if (thd->wsrep_retry_query) {\n      my_free(thd->wsrep_retry_query);\n  }\n  thd->wsrep_retry_query     = (char *)my_malloc(\n                                 thd->wsrep_retry_query_len + 1, MYF(0));\n  strncpy(thd->wsrep_retry_query, thd->query(), thd->wsrep_retry_query_len);\n  thd->wsrep_retry_query[thd->wsrep_retry_query_len] = '\\0';\n}",
        "target": 0
    },
    {
        "func": "sp_name *LEX::make_sp_name(THD *thd, const LEX_CSTRING *name)\n{\n  sp_name *res;\n  LEX_CSTRING db;\n  if (unlikely(check_routine_name(name)) ||\n      unlikely(copy_db_to(&db)) ||\n      unlikely((!(res= new (thd->mem_root) sp_name(&db, name, false)))))\n    return NULL;\n  return res;\n}",
        "target": 0
    },
    {
        "func": "void LEX::restore_values_list_state()\n{\n  many_values= current_select->save_many_values;\n  insert_list= current_select->save_insert_list;\n}",
        "target": 0
    },
    {
        "func": "  bool sp_block_finalize(THD *thd)\n  {\n    return sp_block_finalize(thd, Lex_spblock());\n  }",
        "target": 0
    },
    {
        "func": "bool LEX::sp_for_loop_cursor_finalize(THD *thd, const Lex_for_loop_st &loop)\n{\n  sp_instr_cfetch *instr=\n    new (thd->mem_root) sp_instr_cfetch(sphead->instructions(),\n                                        spcont, loop.m_cursor_offset, false);\n  if (unlikely(instr == NULL) || unlikely(sphead->add_instr(instr)))\n    return true;\n  instr->add_to_varlist(loop.m_index);\n  // Generate a jump to the beginning of the loop\n  return sp_while_loop_finalize(thd);\n}",
        "target": 0
    },
    {
        "func": "  void cut_next() { next= NULL; }",
        "target": 0
    },
    {
        "func": "bool LEX::add_alter_view(THD *thd, uint16 algorithm,\n                         enum_view_suid suid,\n                         Table_ident *table_ident)\n{\n  if (unlikely(sphead))\n  {\n    my_error(ER_SP_BADSTATEMENT, MYF(0), \"ALTER VIEW\");\n    return true;\n  }\n  if (unlikely(!(create_view= new (thd->mem_root)\n                 Create_view_info(VIEW_ALTER, algorithm, suid))))\n    return true;\n  return create_or_alter_view_finalize(thd, table_ident);\n}",
        "target": 0
    },
    {
        "func": "  With_element *get_with_element()\n  {\n    return master_unit()->cloned_from ?\n           master_unit()->cloned_from->with_element :\n           master_unit()->with_element;\n  }",
        "target": 0
    },
    {
        "func": "  inline void set_stmt_unsafe(enum_binlog_stmt_unsafe unsafe_type) {\n    DBUG_ENTER(\"set_stmt_unsafe\");\n    DBUG_ASSERT(unsafe_type >= 0 && unsafe_type < BINLOG_STMT_UNSAFE_COUNT);\n    binlog_stmt_flags|= (1U << unsafe_type);\n    DBUG_VOID_RETURN;\n  }",
        "target": 0
    },
    {
        "func": "void st_select_lex_node::fast_exclude()\n{\n  if (link_prev)\n  {\n    if ((*link_prev= link_next))\n      link_next->link_prev= link_prev;\n  }\n  // Remove slave structure\n  for (; slave; slave= slave->next)\n    slave->fast_exclude();\n\n}",
        "target": 0
    },
    {
        "func": "Item *LEX::create_item_ident_field(THD *thd, const char *db,\n                                   const char *table,\n                                   const Lex_ident_sys_st *name)\n{\n  if (check_expr_allows_fields_or_error(thd, name->str))\n    return NULL;\n\n  if (current_select->parsing_place != IN_HAVING ||\n      current_select->get_in_sum_expr() > 0)\n    return new (thd->mem_root) Item_field(thd, current_context(),\n                                          db, table, name);\n\n  return new (thd->mem_root) Item_ref(thd, current_context(),\n                                      db, table, name);\n}",
        "target": 0
    },
    {
        "func": "  bool have_window_funcs() const { return (window_funcs.elements !=0); }",
        "target": 0
    },
    {
        "func": "int Lex_input_stream::scan_ident_sysvar(THD *thd, Lex_ident_cli_st *str)\n{\n  uchar last_char;\n  uint length;\n  int tokval;\n  bool is_8bit;\n  DBUG_ASSERT(m_tok_start == m_ptr);\n\n  is_8bit= get_7bit_or_8bit_ident(thd, &last_char);\n\n  if (last_char == '.')\n    next_state= MY_LEX_IDENT_SEP;\n  if (!(length= yyLength()))\n    return ABORT_SYM;                  // Names must be nonempty.\n  if ((tokval= find_keyword(str, length, 0)))\n  {\n    yyUnget();                         // Put back 'c'\n    return tokval;                     // Was keyword\n  }\n\n  yyUnget();                       // ptr points now after last token char\n  str->set_ident(m_tok_start, length, is_8bit);\n\n  m_cpp_text_start= m_cpp_tok_start;\n  m_cpp_text_end= m_cpp_text_start + length;\n  body_utf8_append(m_cpp_text_start);\n  body_utf8_append_ident(thd, str, m_cpp_text_end);\n\n  return is_8bit ? IDENT_QUOTED : IDENT;\n}",
        "target": 0
    },
    {
        "func": "  bool uses_stored_routines() const\n  { return sroutines_list.elements != 0; }",
        "target": 0
    },
    {
        "func": "  Create_view_info(enum_view_create_mode mode_arg,\n                   uint16 algorithm_arg,\n                   enum_view_suid suid_arg)\n   :select(null_clex_str),\n    mode(mode_arg),\n    algorithm(algorithm_arg),\n    check(VIEW_CHECK_NONE),\n    suid(suid_arg)\n  { }",
        "target": 0
    },
    {
        "func": "bool LEX::stmt_create_stored_function_start(const DDL_options_st &options,\n                                            enum_sp_aggregate_type agg_type,\n                                            const sp_name *spname)\n{\n  if (stmt_create_function_start(options) ||\n      unlikely(!make_sp_head_no_recursive(thd, spname,\n                                          &sp_handler_function, agg_type)))\n    return true;\n  return false;\n}",
        "target": 0
    },
    {
        "func": "bool LEX::insert_select_hack(SELECT_LEX *sel)\n{\n  DBUG_ENTER(\"LEX::insert_select_hack\");\n\n  DBUG_ASSERT(first_select_lex() == &builtin_select);\n  DBUG_ASSERT(sel != NULL);\n\n  DBUG_ASSERT(builtin_select.first_inner_unit() == NULL);\n\n  if (builtin_select.link_prev)\n  {\n    if ((*builtin_select.link_prev= builtin_select.link_next))\n      ((st_select_lex *)builtin_select.link_next)->link_prev=\n        builtin_select.link_prev;\n    builtin_select.link_prev= NULL; // indicator of removal\n  }\n\n  if (set_main_unit(sel->master_unit()))\n    return true;\n\n  DBUG_ASSERT(builtin_select.table_list.elements == 1);\n  TABLE_LIST *insert_table= builtin_select.table_list.first;\n\n  if (!(insert_table->next_local= sel->table_list.first))\n  {\n    sel->table_list.next= &insert_table->next_local;\n  }\n  sel->table_list.first= insert_table;\n  sel->table_list.elements++;\n  insert_table->select_lex= sel;\n\n  sel->context.first_name_resolution_table= insert_table;\n  builtin_select.context= sel->context;\n  change_item_list_context(&field_list, &sel->context);\n\n  if (sel->tvc && !sel->next_select() &&\n      (sql_command == SQLCOM_INSERT_SELECT ||\n       sql_command == SQLCOM_REPLACE_SELECT))\n  {\n    DBUG_PRINT(\"info\", (\"'Usual' INSERT detected\"));\n    many_values= sel->tvc->lists_of_values;\n    sel->options= sel->tvc->select_options;\n    sel->tvc= NULL;\n    if (sql_command == SQLCOM_INSERT_SELECT)\n      sql_command= SQLCOM_INSERT;\n    else\n      sql_command= SQLCOM_REPLACE;\n  }\n\n\n  for (SELECT_LEX *sel= all_selects_list;\n       sel;\n       sel= sel->next_select_in_list())\n  {\n    if (sel->select_number != 1)\n      sel->select_number--;\n  };\n\n  DBUG_RETURN(FALSE);\n}",
        "target": 0
    },
    {
        "func": "  void set(const st_sp_chistics &other) { *this= other; }",
        "target": 0
    },
    {
        "func": "void SELECT_LEX::mark_const_derived(bool empty)\n{\n  TABLE_LIST *derived= master_unit()->derived;\n  /* join == NULL in  DELETE ... RETURNING */\n  if (!(join && join->thd->lex->describe) && derived)\n  {\n    if (!empty)\n      increase_derived_records(1);\n    if (!master_unit()->is_unit_op() && !derived->is_merged_derived() &&\n        !(join && join->with_two_phase_optimization))\n      derived->fill_me= TRUE;\n  }\n}",
        "target": 0
    },
    {
        "func": "bool LEX::sp_block_with_exceptions_finalize_declarations(THD *thd)\n{\n  /*\n    [ DECLARE declarations ]\n    BEGIN executable_section\n    [ EXCEPTION exceptions ]\n    END\n\n    We are now at the \"BEGIN\" keyword.\n    We have collected all declarations, including DECLARE HANDLER directives.\n    But there will be possibly more handlers in the EXCEPTION section.\n\n    Generate a forward jump from the end of the DECLARE section to the\n    beginning of the EXCEPTION section, over the executable section.\n  */\n  return sphead->add_instr_jump(thd, spcont);\n}",
        "target": 0
    },
    {
        "func": "LEX::sp_add_for_loop_cursor_variable(THD *thd,\n                                     const LEX_CSTRING *name,\n                                     const sp_pcursor *pcursor,\n                                     uint coffset,\n                                     sp_assignment_lex *param_lex,\n                                     Item_args *parameters)\n{\n  sp_variable *spvar= spcont->add_variable(thd, name);\n  if (!spvar)\n    return NULL;\n  spcont->declare_var_boundary(1);\n  sphead->fill_spvar_definition(thd, &spvar->field_def, &spvar->name);\n  if (unlikely(!(spvar->default_value= new (thd->mem_root) Item_null(thd))))\n    return NULL;\n\n  spvar->field_def.set_cursor_rowtype_ref(coffset);\n\n  if (unlikely(sphead->add_for_loop_open_cursor(thd, spcont, spvar, pcursor,\n                                                coffset,\n                                                param_lex, parameters)))\n    return NULL;\n\n  spcont->declare_var_boundary(0);\n  return spvar;\n}",
        "target": 0
    },
    {
        "func": "  inline bool is_stmt_row_injection() const {\n    return binlog_stmt_flags &\n      (1U << (BINLOG_STMT_UNSAFE_COUNT + BINLOG_STMT_TYPE_ROW_INJECTION));\n  }",
        "target": 0
    },
    {
        "func": "static void wsrep_prepare_for_autocommit_retry(THD* thd,\n                                               char* rawbuf,\n                                               uint length,\n                                               Parser_state* parser_state)\n{\n  thd->clear_error();\n  close_thread_tables(thd);\n  thd->wsrep_retry_counter++;            // grow\n  wsrep_copy_query(thd);\n  thd->set_time();\n  parser_state->reset(rawbuf, length);\n\n  /* PSI end */\n  MYSQL_END_STATEMENT(thd->m_statement_psi, thd->get_stmt_da());\n  thd->m_statement_psi= NULL;\n  thd->m_digest= NULL;\n\n  /* DTRACE end */\n  if (MYSQL_QUERY_DONE_ENABLED())\n  {\n    MYSQL_QUERY_DONE(thd->is_error());\n  }\n\n  /* SHOW PROFILE end */\n#if defined(ENABLED_PROFILING)\n  thd->profiling.finish_current_query();\n#endif\n\n  /* SHOW PROFILE begin */\n#if defined(ENABLED_PROFILING)\n  thd->profiling.start_new_query(\"continuing\");\n  thd->profiling.set_query_source(rawbuf, length);\n#endif\n\n  /* DTRACE begin */\n  MYSQL_QUERY_START(rawbuf, thd->thread_id,\n                    thd->get_db(),\n                    &thd->security_ctx->priv_user[0],\n                    (char *) thd->security_ctx->host_or_ip);\n\n  /* Performance Schema Interface instrumentation, begin */\n  thd->m_statement_psi= MYSQL_REFINE_STATEMENT(thd->m_statement_psi,\n                                               com_statement_info[thd->get_command()].m_key);\n  MYSQL_SET_STATEMENT_TEXT(thd->m_statement_psi, thd->query(),\n                           thd->query_length());\n \n  DBUG_ASSERT(thd->wsrep_trx().active() == false);\n  thd->wsrep_cs().reset_error();\n  thd->set_query_id(next_query_id());\n}",
        "target": 0
    },
    {
        "func": "LEX::sp_variable_declarations_vartype_finalize(THD *thd, int nvars,\n                                               const LEX_CSTRING &ref,\n                                               Item *default_value)\n{\n  sp_variable *t;\n  if (!spcont || !(t= spcont->find_variable(&ref, false)))\n  {\n    my_error(ER_SP_UNDECLARED_VAR, MYF(0), ref.str);\n    return true;\n  }\n\n  if (t->field_def.is_cursor_rowtype_ref())\n  {\n    uint offset= t->field_def.cursor_rowtype_offset();\n    return sp_variable_declarations_cursor_rowtype_finalize(thd, nvars,\n                                                            offset,\n                                                            default_value);\n  }\n\n  if (t->field_def.is_column_type_ref())\n  {\n    Qualified_column_ident *tmp= t->field_def.column_type_ref();\n    return sp_variable_declarations_column_type_finalize(thd, nvars, tmp,\n                                                         default_value);\n  }\n\n  if (t->field_def.is_table_rowtype_ref())\n  {\n    const Table_ident *tmp= t->field_def.table_rowtype_ref();\n    return sp_variable_declarations_table_rowtype_finalize(thd, nvars,\n                                                           tmp->db,\n                                                           tmp->table,\n                                                           default_value);\n  }\n\n  // A reference to a scalar or a row variable with an explicit data type\n  return sp_variable_declarations_copy_type_finalize(thd, nvars,\n                                                     t->field_def,\n                                                     t->field_def.\n                                                       row_field_definitions(),\n                                                     default_value);\n}",
        "target": 0
    },
    {
        "func": "bool check_host_name(LEX_CSTRING *str)\n{\n  const char *name= str->str;\n  const char *end= str->str + str->length;\n  if (check_string_byte_length(str, ER_HOSTNAME, HOSTNAME_LENGTH))\n    return TRUE;\n\n  while (name != end)\n  {\n    if (*name == '@')\n    {\n      my_printf_error(ER_UNKNOWN_ERROR, \n                      \"Malformed hostname (illegal symbol: '%c')\", MYF(0),\n                      *name);\n      return TRUE;\n    }\n    name++;\n  }\n  return FALSE;\n}",
        "target": 0
    },
    {
        "func": "  void yyUnget()\n  {\n    m_ptr--;\n    if (m_echo)\n      m_cpp_ptr--;\n  }",
        "target": 0
    },
    {
        "func": "static int pptp_echo_rply(struct pptp_conn_t *conn)\n{\n\tstruct pptp_echo_rply *msg = (struct pptp_echo_rply *)conn->in_buf;\n\n\tif (conf_verbose)\n\t\tlog_ppp_debug(\"recv [PPTP Echo-Reply <Identifier %x>]\\n\", msg->identifier);\n\n\tconn->echo_sent = 0;\n\treturn 0;\n}",
        "target": 0
    },
    {
        "func": "static int send_pptp_stop_ctrl_conn_rply(struct pptp_conn_t *conn, int reason, int err_code)\n{\n\tstruct pptp_stop_ctrl_conn msg = {\n\t\t.header = PPTP_HEADER_CTRL(PPTP_STOP_CTRL_CONN_RPLY),\n\t\t.reason_result = hton8(reason),\n\t\t.error_code = hton8(err_code),\n\t};\n\n\tif (conf_verbose)\n\t\tlog_ppp_info2(\"send [PPTP Stop-Ctrl-Conn-Reply <Result %i> <Error %i>]\\n\", msg.reason_result, msg.error_code);\n\n\treturn post_msg(conn, &msg, sizeof(msg));\n}",
        "target": 0
    },
    {
        "func": "static int post_msg(struct pptp_conn_t *conn, void *buf, int size)\n{\n\tint n;\n\tif (conn->out_size) {\n\t\tlog_error(\"pptp: buffer is not empty\\n\");\n\t\treturn -1;\n\t}\n\nagain:\n\tn=write(conn->hnd.fd, buf, size);\n\tif (n < 0) {\n\t\tif (errno == EINTR)\n\t\t\tgoto again;\n\t\telse if (errno == EAGAIN)\n\t\t\tn = 0;\n\t\telse {\n\t\t\tif (errno != EPIPE) {\n\t\t\t\tif (conf_verbose)\n\t\t\t\t\tlog_ppp_info2(\"pptp: write: %s\\n\", strerror(errno));\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif ( n<size ) {\n\t\tmemcpy(conn->out_buf, (uint8_t *)buf + n, size - n);\n\t\ttriton_md_enable_handler(&conn->hnd, MD_MODE_WRITE);\n\t}\n\n\treturn 0;\n}",
        "target": 0
    },
    {
        "func": "static void pptp_ctx_switch(struct triton_context_t *ctx, void *arg)\n{\n\tif (arg) {\n\t\tstruct ap_session *s = arg;\n\t\tnet = s->net;\n\t} else\n\t\tnet = def_net;\n\tlog_switch(ctx, arg);\n}",
        "target": 0
    },
    {
        "func": "static void disconnect(struct pptp_conn_t *conn)\n{\n\tlog_ppp_debug(\"pptp: disconnect\\n\");\n\n\ttriton_md_unregister_handler(&conn->hnd, 1);\n\n\tif (conn->timeout_timer.tpd)\n\t\ttriton_timer_del(&conn->timeout_timer);\n\n\tif (conn->echo_timer.tpd)\n\t\ttriton_timer_del(&conn->echo_timer);\n\n\tif (conn->state == STATE_PPP) {\n\t\t__sync_sub_and_fetch(&stat_active, 1);\n\t\tconn->state = STATE_CLOSE;\n\t\tap_session_terminate(&conn->ppp.ses, TERM_LOST_CARRIER, 1);\n\t} else if (conn->state != STATE_CLOSE)\n\t\t__sync_sub_and_fetch(&stat_starting, 1);\n\n\ttriton_event_fire(EV_CTRL_FINISHED, &conn->ppp.ses);\n\n\tlog_ppp_info1(\"disconnected\\n\");\n\n\ttriton_context_unregister(&conn->ctx);\n\n\tif (conn->ppp.ses.chan_name)\n\t\t_free(conn->ppp.ses.chan_name);\n\n\t_free(conn->in_buf);\n\t_free(conn->out_buf);\n\t_free(conn->ctrl.calling_station_id);\n\t_free(conn->ctrl.called_station_id);\n\tmempool_free(conn);\n}",
        "target": 0
    },
    {
        "func": "static void pptp_serv_close(struct triton_context_t *ctx)\n{\n\tstruct pptp_serv_t *s=container_of(ctx,typeof(*s),ctx);\n\ttriton_md_unregister_handler(&s->hnd, 1);\n\ttriton_context_unregister(ctx);\n}",
        "target": 0
    },
    {
        "func": "static int send_pptp_stop_ctrl_conn_rqst(struct pptp_conn_t *conn, int reason)\n{\n\tstruct pptp_stop_ctrl_conn msg = {\n\t\t.header = PPTP_HEADER_CTRL(PPTP_STOP_CTRL_CONN_RQST),\n\t\t.reason_result = hton8(reason),\n\t};\n\n\tif (conf_verbose)\n\t\tlog_ppp_info2(\"send [PPTP Stop-Ctrl-Conn-Request <Reason %i>]\\n\", reason);\n\n\treturn post_msg(conn, &msg, sizeof(msg));\n}",
        "target": 0
    },
    {
        "func": "static void pptp_close(struct triton_context_t *ctx)\n{\n\tstruct pptp_conn_t *conn = container_of(ctx, typeof(*conn), ctx);\n\tif (conn->state == STATE_PPP) {\n\t\t__sync_sub_and_fetch(&stat_active, 1);\n\t\tconn->state = STATE_CLOSE;\n\t\tap_session_terminate(&conn->ppp.ses, TERM_ADMIN_RESET, 1);\n\t\tif (send_pptp_call_disconnect_notify(conn, 3)) {\n\t\t\ttriton_context_call(&conn->ctx, (void (*)(void*))disconnect, conn);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tif (send_pptp_stop_ctrl_conn_rqst(conn, 0)) {\n\t\t\ttriton_context_call(&conn->ctx, (void (*)(void*))disconnect, conn);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (conn->timeout_timer.tpd)\n\t\ttriton_timer_mod(&conn->timeout_timer, 0);\n\telse\n\t\ttriton_timer_add(ctx, &conn->timeout_timer, 0);\n}",
        "target": 0
    },
    {
        "func": "static void pptp_init(void)\n{\n\tstruct sockaddr_in addr;\n\tchar *opt;\n\tint fd;\n\n\tfd = socket(AF_PPPOX, SOCK_STREAM, PX_PROTO_PPTP);\n\tif (fd >= 0)\n\t\tclose(fd);\n\telse if (system(\"modprobe -q pptp\"))\n\t\tlog_warn(\"failed to load pptp kernel module\\n\");\n\n\tserv.hnd.fd = socket(PF_INET, SOCK_STREAM, 0);\n\tif (serv.hnd.fd < 0) {\n\t\tlog_emerg(\"pptp: failed to create server socket: %s\\n\", strerror(errno));\n\t\treturn;\n\t}\n\n\tfcntl(serv.hnd.fd, F_SETFD, fcntl(serv.hnd.fd, F_GETFD) | FD_CLOEXEC);\n\n\taddr.sin_family = AF_INET;\n\n\topt = conf_get_opt(\"pptp\", \"bind\");\n\tif (opt)\n\t\taddr.sin_addr.s_addr = inet_addr(opt);\n\telse\n\t\taddr.sin_addr.s_addr = htonl(INADDR_ANY);\n\n\topt = conf_get_opt(\"pptp\", \"port\");\n\tif (opt && atoi(opt) > 0)\n\t\taddr.sin_port = htons(atoi(opt));\n\telse\n\t\taddr.sin_port = htons(PPTP_PORT);\n\n  setsockopt(serv.hnd.fd, SOL_SOCKET, SO_REUSEADDR, &serv.hnd.fd, 4);\n  if (bind (serv.hnd.fd, (struct sockaddr *) &addr, sizeof (addr)) < 0) {\n    log_emerg(\"pptp: failed to bind socket: %s\\n\", strerror(errno));\n\t\tclose(serv.hnd.fd);\n    return;\n  }\n\n  if (listen (serv.hnd.fd, 100) < 0) {\n    log_emerg(\"pptp: failed to listen socket: %s\\n\", strerror(errno));\n\t\tclose(serv.hnd.fd);\n    return;\n  }\n\n\tif (fcntl(serv.hnd.fd, F_SETFL, O_NONBLOCK)) {\n    log_emerg(\"pptp: failed to set nonblocking mode: %s\\n\", strerror(errno));\n\t\tclose(serv.hnd.fd);\n    return;\n\t}\n\n\tconn_pool = mempool_create(sizeof(struct pptp_conn_t));\n\n\tload_config();\n\n\ttriton_context_register(&serv.ctx, NULL);\n\ttriton_md_register_handler(&serv.ctx, &serv.hnd);\n\ttriton_md_enable_handler(&serv.hnd, MD_MODE_READ);\n\ttriton_context_wakeup(&serv.ctx);\n\n\tcli_register_simple_cmd2(show_stat_exec, NULL, 2, \"show\", \"stat\");\n\n\ttriton_event_register_handler(EV_CONFIG_RELOAD, (triton_event_func)load_config);\n}",
        "target": 0
    },
    {
        "func": "static int send_pptp_start_ctrl_conn_rply(struct pptp_conn_t *conn, int res_code, int err_code)\n{\n\tstruct pptp_start_ctrl_conn msg = {\n\t\t.header = PPTP_HEADER_CTRL(PPTP_START_CTRL_CONN_RPLY),\n\t\t.version = htons(PPTP_VERSION),\n\t\t.result_code = res_code,\n\t\t.error_code = err_code,\n\t\t.framing_cap = htonl(PPTP_FRAME_ANY),\n\t\t.bearer_cap = htonl(PPTP_BEARER_ANY),\n\t\t.max_channels = htons(1),\n\t\t.firmware_rev = htons(PPTP_FIRMWARE_VERSION),\n\t};\n\n\tmemset(msg.hostname, 0, sizeof(msg.hostname));\n\tstrcpy((char*)msg.hostname, PPTP_HOSTNAME);\n\n\tmemset(msg.vendor, 0, sizeof(msg.vendor));\n\tstrcpy((char*)msg.vendor, PPTP_VENDOR);\n\n\tif (conf_verbose)\n\t\tlog_ppp_info2(\"send [PPTP Start-Ctrl-Conn-Reply <Version %i> <Result %i> <Error %i> <Framing %x> <Bearer %x> <Max-Chan %i>]\\n\", msg.version, msg.result_code, msg.error_code, ntohl(msg.framing_cap), ntohl(msg.bearer_cap), ntohs(msg.max_channels));\n\n\treturn post_msg(conn, &msg, sizeof(msg));\n}",
        "target": 0
    },
    {
        "func": "static int pptp_stop_ctrl_conn_rply(struct pptp_conn_t *conn)\n{\n\tstruct pptp_stop_ctrl_conn *msg = (struct pptp_stop_ctrl_conn*)conn->in_buf;\n\tif (conf_verbose)\n\t\tlog_ppp_info2(\"recv [PPTP Stop-Ctrl-Conn-Reply <Result %i> <Error %i>]\\n\", msg->reason_result, msg->error_code);\n\treturn -1;\n}",
        "target": 0
    },
    {
        "func": "static int pptp_out_call_rqst(struct pptp_conn_t *conn)\n{\n\tstruct pptp_out_call_rqst *msg = (struct pptp_out_call_rqst *)conn->in_buf;\n\tstruct sockaddr_pppox src_addr, dst_addr;\n  struct sockaddr_in addr;\n\tsocklen_t addrlen;\n\tint pptp_sock;\n\n\tif (conf_verbose)\n\t\tlog_ppp_info2(\"recv [PPTP Outgoing-Call-Request <Call-ID %x> <Call-Serial %x> <Min-BPS %i> <Max-BPS %i> <Bearer %x> <Framing %x> <Window-Size %i> <Delay %i>]\\n\", ntohs(msg->call_id), ntohs(msg->call_sernum), ntohl(msg->bps_min), ntohl(msg->bps_max), ntohl(msg->bearer), ntohl(msg->framing), ntohs(msg->recv_size), ntohs(msg->delay));\n\n\tif (conn->state != STATE_ESTB) {\n\t\tlog_ppp_warn(\"unexpected PPTP_OUT_CALL_RQST\\n\");\n\t\tif (send_pptp_out_call_rply(conn, msg, 0, PPTP_CALL_RES_GE, PPTP_GE_NOCONN))\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\n\tmemset(&src_addr, 0, sizeof(src_addr));\n\tsrc_addr.sa_family = AF_PPPOX;\n\tsrc_addr.sa_protocol = PX_PROTO_PPTP;\n\tsrc_addr.sa_addr.pptp.call_id = 0;\n\taddrlen = sizeof(addr);\n\tgetsockname(conn->hnd.fd, (struct sockaddr*)&addr, &addrlen);\n\tsrc_addr.sa_addr.pptp.sin_addr = addr.sin_addr;\n\n\tmemset(&dst_addr, 0, sizeof(dst_addr));\n\tdst_addr.sa_family = AF_PPPOX;\n\tdst_addr.sa_protocol = PX_PROTO_PPTP;\n\tdst_addr.sa_addr.pptp.call_id = htons(msg->call_id);\n\taddrlen = sizeof(addr);\n\tgetpeername(conn->hnd.fd, (struct sockaddr*)&addr, &addrlen);\n\tdst_addr.sa_addr.pptp.sin_addr = addr.sin_addr;\n\n\tpptp_sock = socket(AF_PPPOX, SOCK_STREAM, PX_PROTO_PPTP);\n\tif (pptp_sock < 0) {\n\t\tlog_ppp_error(\"failed to create PPTP socket (%s)\\n\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tfcntl(pptp_sock, F_SETFD, fcntl(pptp_sock, F_GETFD) | FD_CLOEXEC);\n\n\tif (bind(pptp_sock, (struct sockaddr*)&src_addr, sizeof(src_addr))) {\n\t\tlog_ppp_error(\"failed to bind PPTP socket (%s)\\n\", strerror(errno));\n\t\tclose(pptp_sock);\n\t\treturn -1;\n\t}\n\taddrlen = sizeof(src_addr);\n\tgetsockname(pptp_sock, (struct sockaddr*)&src_addr, &addrlen);\n\n\tif (connect(pptp_sock, (struct sockaddr*)&dst_addr, sizeof(dst_addr))) {\n\t\tlog_ppp_error(\"failed to connect PPTP socket (%s)\\n\", strerror(errno));\n\t\tclose(pptp_sock);\n\t\treturn -1;\n\t}\n\n\tif (send_pptp_out_call_rply(conn, msg, src_addr.sa_addr.pptp.call_id, PPTP_CALL_RES_OK, 0))\n\t\treturn -1;\n\n\tconn->call_id = src_addr.sa_addr.pptp.call_id;\n\tconn->peer_call_id = msg->call_id;\n\tconn->ppp.fd = pptp_sock;\n\tconn->ppp.ses.chan_name = _strdup(inet_ntoa(dst_addr.sa_addr.pptp.sin_addr));\n\n\ttriton_event_fire(EV_CTRL_STARTED, &conn->ppp.ses);\n\n\tif (establish_ppp(&conn->ppp)) {\n\t\tclose(pptp_sock);\n\t\t//if (send_pptp_stop_ctrl_conn_rqst(conn, 0, 0))\n\t\tconn->state = STATE_FIN;\n\t\treturn -1;\n\t}\n\tconn->state = STATE_PPP;\n\t__sync_sub_and_fetch(&stat_starting, 1);\n\t__sync_add_and_fetch(&stat_active, 1);\n\n\tif (conn->timeout_timer.tpd)\n\t\ttriton_timer_del(&conn->timeout_timer);\n\n\tif (conf_echo_interval) {\n\t\tconn->echo_timer.period = conf_echo_interval * 1000;\n\t\ttriton_timer_add(&conn->ctx, &conn->echo_timer, 0);\n\t}\n\n\treturn 0;\n}",
        "target": 0
    },
    {
        "func": "static int pptp_write(struct triton_md_handler_t *h)\n{\n\tstruct pptp_conn_t *conn = container_of(h, typeof(*conn), hnd);\n\tint n;\n\n\twhile (1) {\n\t\tn = write(h->fd, conn->out_buf+conn->out_pos, conn->out_size-conn->out_pos);\n\n\t\tif (n < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tif (errno == EAGAIN)\n\t\t\t\tn = 0;\n\t\t\telse {\n\t\t\t\tif (errno != EPIPE) {\n\t\t\t\t\tif (conf_verbose)\n\t\t\t\t\t\tlog_ppp_info2(\"pptp: post_msg: %s\\n\", strerror(errno));\n\t\t\t\t}\n\t\t\t\tdisconnect(conn);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\n\t\tconn->out_pos += n;\n\t\tif (conn->out_pos == conn->out_size) {\n\t\t\tconn->out_pos = 0;\n\t\t\tconn->out_size = 0;\n\t\t\ttriton_md_disable_handler(h, MD_MODE_WRITE);\n\t\t\treturn 0;\n\t\t}\n\t}\n}",
        "target": 0
    },
    {
        "func": "static int pptp_read(struct triton_md_handler_t *h)\n{\n\tstruct pptp_conn_t *conn=container_of(h,typeof(*conn),hnd);\n\tstruct pptp_header *hdr=(struct pptp_header *)conn->in_buf;\n\tint n;\n\n\twhile(1) {\n\t\tn = read(h->fd, conn->in_buf + conn->in_size, PPTP_CTRL_SIZE_MAX - conn->in_size);\n\t\tif (n < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tif (errno == EAGAIN)\n\t\t\t\treturn 0;\n\t\t\tlog_ppp_error(\"pptp: read: %s\\n\",strerror(errno));\n\t\t\tgoto drop;\n\t\t}\n\t\tif (n == 0) {\n\t\t\tif (conf_verbose)\n\t\t\t\tlog_ppp_info2(\"pptp: disconnect by peer\\n\");\n\t\t\tgoto drop;\n\t\t}\n\t\tconn->in_size += n;\n\t\tif (conn->in_size >= sizeof(*hdr)) {\n\t\t\tif (hdr->magic != htonl(PPTP_MAGIC)) {\n\t\t\t\tlog_ppp_error(\"pptp: invalid magic\\n\");\n\t\t\t\tgoto drop;\n\t\t\t}\n\t\t\tif (ntohs(hdr->length) >= PPTP_CTRL_SIZE_MAX) {\n\t\t\t\tlog_ppp_error(\"pptp: message is too long\\n\");\n\t\t\t\tgoto drop;\n\t\t\t}\n\t\t\tif (ntohs(hdr->length) > conn->in_size)\n\t\t\t\tcontinue;\n\t\t\tif (ntohs(hdr->length) <= conn->in_size) {\n\t\t\t\tif (ntohs(hdr->length) != PPTP_CTRL_SIZE(ntohs(hdr->ctrl_type))) {\n\t\t\t\t\tlog_ppp_error(\"pptp: invalid message length\\n\");\n\t\t\t\t\tgoto drop;\n\t\t\t\t}\n\t\t\t\tif (process_packet(conn))\n\t\t\t\t\tgoto drop;\n\t\t\t\tconn->in_size -= ntohs(hdr->length);\n\t\t\t\tif (conn->in_size)\n\t\t\t\t\tmemmove(conn->in_buf, conn->in_buf + ntohs(hdr->length), conn->in_size);\n\t\t\t}\n\t\t}\n\t}\ndrop:\n\tdisconnect(conn);\n\treturn 1;\n}",
        "target": 0
    },
    {
        "func": "static int process_packet(struct pptp_conn_t *conn)\n{\n\tstruct pptp_header *hdr = (struct pptp_header *)conn->in_buf;\n\tswitch(ntohs(hdr->ctrl_type))\n\t{\n\t\tcase PPTP_START_CTRL_CONN_RQST:\n\t\t\treturn pptp_start_ctrl_conn_rqst(conn);\n\t\tcase PPTP_STOP_CTRL_CONN_RQST:\n\t\t\treturn pptp_stop_ctrl_conn_rqst(conn);\n\t\tcase PPTP_STOP_CTRL_CONN_RPLY:\n\t\t\treturn pptp_stop_ctrl_conn_rply(conn);\n\t\tcase PPTP_OUT_CALL_RQST:\n\t\t\treturn pptp_out_call_rqst(conn);\n\t\tcase PPTP_ECHO_RQST:\n\t\t\treturn pptp_echo_rqst(conn);\n\t\tcase PPTP_ECHO_RPLY:\n\t\t\treturn pptp_echo_rply(conn);\n\t\tcase PPTP_CALL_CLEAR_RQST:\n\t\t\treturn pptp_call_clear_rqst(conn);\n\t\tcase PPTP_SET_LINK_INFO:\n\t\t\tif (conf_verbose)\n\t\t\t\tlog_ppp_info2(\"recv [PPTP Set-Link-Info]\\n\");\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\tlog_ppp_warn(\"recv [PPTP Unknown (%x)]\\n\", ntohs(hdr->ctrl_type));\n\t}\n\treturn 0;\n}",
        "target": 0
    },
    {
        "func": "static int send_pptp_out_call_rply(struct pptp_conn_t *conn, struct pptp_out_call_rqst *rqst, int call_id, int res_code, int err_code)\n{\n\tstruct pptp_out_call_rply msg = {\n\t\t.header = PPTP_HEADER_CTRL(PPTP_OUT_CALL_RPLY),\n\t\t.call_id = htons(call_id),\n\t\t.call_id_peer = rqst->call_id,\n\t\t.result_code = res_code,\n\t\t.error_code = err_code,\n\t\t.cause_code = 0,\n\t\t.speed = rqst->bps_max,\n\t\t.recv_size = rqst->recv_size,\n\t\t.delay = 0,\n\t\t.channel = 0,\n\t};\n\n\tif (conf_verbose)\n\t\tlog_ppp_info2(\"send [PPTP Outgoing-Call-Reply <Call-ID %x> <Peer-Call-ID %x> <Result %i> <Error %i> <Cause %i> <Speed %i> <Window-Size %i> <Delay %i> <Channel %x>]\\n\", ntohs(msg.call_id), ntohs(msg.call_id_peer), msg.result_code, msg.error_code, ntohs(msg.cause_code), ntohl(msg.speed), ntohs(msg.recv_size), ntohs(msg.delay), ntohl(msg.channel));\n\n\treturn post_msg(conn, &msg, sizeof(msg));\n}",
        "target": 0
    },
    {
        "func": "static int show_stat_exec(const char *cmd, char * const *fields, int fields_cnt, void *client)\n{\n\tcli_send(client, \"pptp:\\r\\n\");\n\tcli_sendv(client,\"  starting: %u\\r\\n\", stat_starting);\n\tcli_sendv(client,\"  active: %u\\r\\n\", stat_active);\n\n\treturn CLI_CMD_OK;\n}",
        "target": 0
    },
    {
        "func": "static int pptp_call_clear_rqst(struct pptp_conn_t *conn)\n{\n\tstruct pptp_call_clear_rqst *rqst = (struct pptp_call_clear_rqst *)conn->in_buf;\n\n\tif (conf_verbose)\n\t\tlog_ppp_info2(\"recv [PPTP Call-Clear-Request <Call-ID %x>]\\n\", ntohs(rqst->call_id));\n\n\tif (conn->echo_timer.tpd)\n\t\ttriton_timer_del(&conn->echo_timer);\n\n\tif (conn->state == STATE_PPP) {\n\t\t__sync_sub_and_fetch(&stat_active, 1);\n\t\tconn->state = STATE_CLOSE;\n\t\tap_session_terminate(&conn->ppp.ses, TERM_USER_REQUEST, 1);\n\t}\n\n\treturn send_pptp_call_disconnect_notify(conn, 4);\n}",
        "target": 0
    },
    {
        "func": "static void ppp_finished(struct ap_session *ses)\n{\n\tstruct ppp_t *ppp = container_of(ses, typeof(*ppp), ses);\n\tstruct pptp_conn_t *conn = container_of(ppp, typeof(*conn), ppp);\n\n\tif (conn->state != STATE_CLOSE) {\n\t\tlog_ppp_debug(\"pptp: ppp finished\\n\");\n\t\tconn->state = STATE_CLOSE;\n\t\t__sync_sub_and_fetch(&stat_active, 1);\n\n\t\tif (send_pptp_call_disconnect_notify(conn, 3))\n\t\t\ttriton_context_call(&conn->ctx, (void (*)(void*))disconnect, conn);\n\t\telse if (send_pptp_stop_ctrl_conn_rqst(conn, 0))\n\t\t\ttriton_context_call(&conn->ctx, (void (*)(void*))disconnect, conn);\n\t\telse {\n\t\t\tif (conn->timeout_timer.tpd)\n\t\t\t\ttriton_timer_mod(&conn->timeout_timer, 0);\n\t\t\telse\n\t\t\t\ttriton_timer_add(&conn->ctx, &conn->timeout_timer, 0);\n\t\t}\n\t}\n}",
        "target": 0
    },
    {
        "func": "static int pptp_start_ctrl_conn_rqst(struct pptp_conn_t *conn)\n{\n\tstruct pptp_start_ctrl_conn *msg = (struct pptp_start_ctrl_conn *)conn->in_buf;\n\n\tif (conf_verbose)\n\t\tlog_ppp_info2(\"recv [PPTP Start-Ctrl-Conn-Request <Version %i> <Framing %x> <Bearer %x> <Max-Chan %i>]\\n\", msg->version, ntohl(msg->framing_cap), ntohl(msg->bearer_cap), ntohs(msg->max_channels));\n\n\tif (conn->state != STATE_IDLE) {\n\t\tlog_ppp_warn(\"unexpected PPTP_START_CTRL_CONN_RQST\\n\");\n\t\tif (send_pptp_start_ctrl_conn_rply(conn, PPTP_CONN_RES_EXISTS, 0))\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\n\tif (msg->version != htons(PPTP_VERSION)) {\n\t\tlog_ppp_warn(\"PPTP version mismatch: expecting %x, received %\" PRIu32 \"\\n\", PPTP_VERSION, msg->version);\n\t\tif (send_pptp_start_ctrl_conn_rply(conn, PPTP_CONN_RES_PROTOCOL, 0))\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\t/*if (!(ntohl(msg->framing_cap) & PPTP_FRAME_SYNC)) {\n\t\tlog_ppp_warn(\"connection does not supports sync mode\\n\");\n\t\tif (send_pptp_start_ctrl_conn_rply(conn, PPTP_CONN_RES_GE, 0))\n\t\t\treturn -1;\n\t\treturn 0;\n\t}*/\n\tif (send_pptp_start_ctrl_conn_rply(conn, PPTP_CONN_RES_SUCCESS, 0))\n\t\treturn -1;\n\n\tif (conn->timeout_timer.tpd)\n\t\ttriton_timer_mod(&conn->timeout_timer, 0);\n\n\tconn->state = STATE_ESTB;\n\n\treturn 0;\n}",
        "target": 0
    },
    {
        "func": "static void pptp_timeout(struct triton_timer_t *t)\n{\n\tstruct pptp_conn_t *conn = container_of(t, typeof(*conn), timeout_timer);\n\tdisconnect(conn);\n}",
        "target": 0
    },
    {
        "func": "static void ppp_started(struct ap_session *ses)\n{\n\tlog_ppp_debug(\"pptp: ppp started\\n\");\n}",
        "target": 0
    },
    {
        "func": "static void load_config(void)\n{\n\tchar *opt;\n\n\topt = conf_get_opt(\"pptp\", \"timeout\");\n\tif (opt && atoi(opt) > 0)\n\t\tconf_timeout = atoi(opt);\n\n\topt = conf_get_opt(\"pptp\", \"echo-interval\");\n\tif (opt && atoi(opt) >= 0)\n\t\tconf_echo_interval = atoi(opt);\n\n\topt = conf_get_opt(\"pptp\", \"echo-failure\");\n\tif (opt && atoi(opt) >= 0)\n\t\tconf_echo_failure = atoi(opt);\n\n\topt = conf_get_opt(\"pptp\", \"verbose\");\n\tif (opt && atoi(opt) >= 0)\n\t\tconf_verbose = atoi(opt) > 0;\n\n\topt = conf_get_opt(\"pptp\", \"ppp-max-mtu\");\n\tif (opt && atoi(opt) > 0)\n\t\tconf_ppp_max_mtu = atoi(opt);\n\telse\n\t\tconf_ppp_max_mtu = PPTP_MAX_MTU;\n\n\tconf_mppe = MPPE_UNSET;\n\topt = conf_get_opt(\"pptp\", \"mppe\");\n\tif (opt) {\n\t\tif (strcmp(opt, \"deny\") == 0)\n\t\t\tconf_mppe = MPPE_DENY;\n\t\telse if (strcmp(opt, \"allow\") == 0)\n\t\t\tconf_mppe = MPPE_ALLOW;\n\t\telse if (strcmp(opt, \"prefer\") == 0)\n\t\t\tconf_mppe = MPPE_PREFER;\n\t\telse if (strcmp(opt, \"require\") == 0)\n\t\t\tconf_mppe = MPPE_REQUIRE;\n\t}\n\n\tconf_ip_pool = conf_get_opt(\"pptp\", \"ip-pool\");\n\tconf_ipv6_pool = conf_get_opt(\"pptp\", \"ipv6-pool\");\n\tconf_dpv6_pool = conf_get_opt(\"pptp\", \"ipv6-pool-delegate\");\n\tconf_ifname = conf_get_opt(\"pptp\", \"ifname\");\n\n\tswitch (iprange_check_activation()) {\n\tcase IPRANGE_DISABLED:\n\t\tlog_warn(\"pptp: iprange module disabled, improper IP configuration of PPP interfaces may cause kernel soft lockup\\n\");\n\t\tbreak;\n\tcase IPRANGE_NO_RANGE:\n\t\tlog_warn(\"pptp: no IP address range defined in section [%s], incoming PPTP connections will be rejected\\n\",\n\t\t\t IPRANGE_CONF_SECTION);\n\t\tbreak;\n\tdefault:\n\t\t/* Makes compiler happy */\n\t\tbreak;\n\t}\n}",
        "target": 0
    },
    {
        "func": "static int pptp_stop_ctrl_conn_rqst(struct pptp_conn_t *conn)\n{\n\tstruct pptp_stop_ctrl_conn *msg = (struct pptp_stop_ctrl_conn *)conn->in_buf;\n\tif (conf_verbose)\n\t\tlog_ppp_info2(\"recv [PPTP Stop-Ctrl-Conn-Request <Reason %i>]\\n\", msg->reason_result);\n\n\tsend_pptp_stop_ctrl_conn_rply(conn, PPTP_CONN_STOP_OK, 0);\n\n\treturn -1;\n}",
        "target": 0
    },
    {
        "func": "static int pptp_connect(struct triton_md_handler_t *h)\n{\n  struct sockaddr_in addr;\n\tsocklen_t size = sizeof(addr);\n\tint sock;\n\tstruct pptp_conn_t *conn;\n\n\twhile(1) {\n\t\tsock = accept(h->fd, (struct sockaddr *)&addr, &size);\n\t\tif (sock < 0) {\n\t\t\tif (errno == EAGAIN)\n\t\t\t\treturn 0;\n\t\t\tlog_error(\"pptp: accept failed: %s\\n\", strerror(errno));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ap_shutdown) {\n\t\t\tclose(sock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (conf_max_starting && ap_session_stat.starting >= conf_max_starting) {\n\t\t\tclose(sock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (conf_max_sessions && ap_session_stat.active + ap_session_stat.starting >= conf_max_sessions) {\n\t\t\tclose(sock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (triton_module_loaded(\"connlimit\") && connlimit_check(cl_key_from_ipv4(addr.sin_addr.s_addr))) {\n\t\t\tclose(sock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlog_info2(\"pptp: new connection from %s\\n\", inet_ntoa(addr.sin_addr));\n\n\t\tif (iprange_client_check(addr.sin_addr.s_addr)) {\n\t\t\tlog_warn(\"pptp: IP is out of client-ip-range, droping connection...\\n\");\n\t\t\tclose(sock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (fcntl(sock, F_SETFL, O_NONBLOCK)) {\n\t\t\tlog_error(\"pptp: failed to set nonblocking mode: %s, closing connection...\\n\", strerror(errno));\n\t\t\tclose(sock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tconn = mempool_alloc(conn_pool);\n\t\tmemset(conn, 0, sizeof(*conn));\n\t\tconn->hnd.fd = sock;\n\t\tconn->hnd.read = pptp_read;\n\t\tconn->hnd.write = pptp_write;\n\t\tconn->ctx.close = pptp_close;\n\t\tconn->ctx.before_switch = pptp_ctx_switch;\n\t\tconn->in_buf = _malloc(PPTP_CTRL_SIZE_MAX);\n\t\tconn->out_buf = _malloc(PPTP_CTRL_SIZE_MAX);\n\t\tconn->timeout_timer.expire = pptp_timeout;\n\t\tconn->timeout_timer.period = conf_timeout * 1000;\n\t\tconn->echo_timer.expire = pptp_send_echo;\n\t\tconn->ctrl.ctx = &conn->ctx;\n\t\tconn->ctrl.started = ppp_started;\n\t\tconn->ctrl.finished = ppp_finished;\n\t\tconn->ctrl.terminate = ppp_terminate;\n\t\tconn->ctrl.max_mtu = conf_ppp_max_mtu;\n\t\tconn->ctrl.type = CTRL_TYPE_PPTP;\n\t\tconn->ctrl.ppp = 1;\n\t\tconn->ctrl.name = \"pptp\";\n\t\tconn->ctrl.ifname = \"\";\n\t\tconn->ctrl.mppe = conf_mppe;\n\n\t\tconn->ctrl.calling_station_id = _malloc(17);\n\t\tconn->ctrl.called_station_id = _malloc(17);\n\t\tu_inet_ntoa(addr.sin_addr.s_addr, conn->ctrl.calling_station_id);\n\t\tgetsockname(sock, &addr, &size);\n\t\tu_inet_ntoa(addr.sin_addr.s_addr, conn->ctrl.called_station_id);\n\n\t\tppp_init(&conn->ppp);\n\t\tconn->ppp.ses.ctrl = &conn->ctrl;\n\n\t\tif (conf_ip_pool)\n\t\t\tconn->ppp.ses.ipv4_pool_name = _strdup(conf_ip_pool);\n\t\tif (conf_ipv6_pool)\n\t\t\tconn->ppp.ses.ipv6_pool_name = _strdup(conf_ipv6_pool);\n\t\tif (conf_dpv6_pool)\n\t\t\tconn->ppp.ses.dpv6_pool_name = _strdup(conf_dpv6_pool);\n\t\tif (conf_ifname)\n\t\t\tconn->ppp.ses.ifname_rename = _strdup(conf_ifname);\n\n\t\ttriton_context_register(&conn->ctx, &conn->ppp.ses);\n\t\ttriton_md_register_handler(&conn->ctx, &conn->hnd);\n\t\ttriton_md_enable_handler(&conn->hnd,MD_MODE_READ);\n\t\ttriton_timer_add(&conn->ctx, &conn->timeout_timer, 0);\n\t\ttriton_context_wakeup(&conn->ctx);\n\n\t\ttriton_event_fire(EV_CTRL_STARTING, &conn->ppp.ses);\n\n\t\t__sync_add_and_fetch(&stat_starting, 1);\n\t}\n\treturn 0;\n}",
        "target": 0
    },
    {
        "func": "void __export pptp_get_stat(unsigned int **starting, unsigned int **active)\n{\n\t*starting = &stat_starting;\n\t*active = &stat_active;\n}",
        "target": 0
    },
    {
        "func": "static int pptp_echo_rqst(struct pptp_conn_t *conn)\n{\n\tstruct pptp_echo_rqst *in_msg = (struct pptp_echo_rqst *)conn->in_buf;\n\tstruct pptp_echo_rply out_msg = {\n\t\t.header = PPTP_HEADER_CTRL(PPTP_ECHO_RPLY),\n\t\t.identifier = in_msg->identifier,\n\t\t.result_code = 1,\n\t};\n\n\tif (conf_verbose) {\n\t\tlog_ppp_debug(\"recv [PPTP Echo-Request <Identifier %x>]\\n\", in_msg->identifier);\n\t\tlog_ppp_debug(\"send [PPTP Echo-Reply <Identifier %x>]\\n\", out_msg.identifier);\n\t}\n\n\tif (conn->echo_timer.tpd)\n\t\ttriton_timer_mod(&conn->echo_timer, 0);\n\n\treturn post_msg(conn, &out_msg, sizeof(out_msg));\n}",
        "target": 0
    },
    {
        "func": "static void pptp_send_echo(struct triton_timer_t *t)\n{\n\tstruct pptp_conn_t *conn = container_of(t, typeof(*conn), echo_timer);\n\tstruct pptp_echo_rqst msg = {\n\t\t.header = PPTP_HEADER_CTRL(PPTP_ECHO_RQST),\n\t};\n\n\tif (++conn->echo_sent == conf_echo_failure) {\n\t\tlog_ppp_warn(\"pptp: no echo reply\\n\");\n\t\tdisconnect(conn);\n\t\treturn;\n\t}\n\n\tmsg.identifier = random();\n\n\tif (conf_verbose)\n\t\tlog_ppp_debug(\"send [PPTP Echo-Request <Identifier %x>]\\n\", msg.identifier);\n\n\tif (post_msg(conn, &msg, sizeof(msg)))\n\t\tdisconnect(conn);\n}",
        "target": 0
    },
    {
        "func": "static int send_pptp_call_disconnect_notify(struct pptp_conn_t *conn, int result)\n{\n\tstruct pptp_call_clear_ntfy msg = {\n\t\t.header = PPTP_HEADER_CTRL(PPTP_CALL_CLEAR_NTFY),\n\t\t.call_id = htons(conn->peer_call_id),\n\t\t.result_code = result,\n\t\t.error_code = 0,\n\t\t.cause_code = 0,\n\t};\n\n\tif (conf_verbose)\n\t\tlog_ppp_info2(\"send [PPTP Call-Disconnect-Notify <Call-ID %x> <Result %i> <Error %i> <Cause %i>]\\n\", ntohs(msg.call_id), msg.result_code, msg.error_code, msg.cause_code);\n\n\treturn post_msg(conn, &msg, sizeof(msg));\n}",
        "target": 0
    },
    {
        "func": "static void RSAZ_exp52x20_x2_256(BN_ULONG *out,          /* [2][20] */\n                                 const BN_ULONG *base,   /* [2][20] */\n                                 const BN_ULONG *exp[2], /* 2x16    */\n                                 const BN_ULONG *m,      /* [2][20] */\n                                 const BN_ULONG *rr,     /* [2][20] */\n                                 const BN_ULONG k0[2])\n{\n# define BITSIZE_MODULUS (1024)\n# define EXP_WIN_SIZE (5)\n# define EXP_WIN_MASK ((1U << EXP_WIN_SIZE) - 1)\n/*\n * Number of digits (64-bit words) in redundant representation to handle\n * modulus bits\n */\n# define RED_DIGITS (20)\n# define EXP_DIGITS (16)\n# define DAMM ossl_rsaz_amm52x20_x2_256\n/*\n * Squaring is done using multiplication now. That can be a subject of\n * optimization in future.\n */\n# define DAMS(r,a,m,k0) \\\n              ossl_rsaz_amm52x20_x2_256((r),(a),(a),(m),(k0))\n\n    /* Allocate stack for red(undant) result Y and multiplier X */\n    ALIGN64 BN_ULONG red_Y[2][RED_DIGITS];\n    ALIGN64 BN_ULONG red_X[2][RED_DIGITS];\n\n    /* Allocate expanded exponent */\n    ALIGN64 BN_ULONG expz[2][EXP_DIGITS + 1];\n\n    /* Pre-computed table of base powers */\n    ALIGN64 BN_ULONG red_table[1U << EXP_WIN_SIZE][2][RED_DIGITS];\n\n    int idx;\n\n    memset(red_Y, 0, sizeof(red_Y));\n    memset(red_table, 0, sizeof(red_table));\n    memset(red_X, 0, sizeof(red_X));\n\n    /*\n     * Compute table of powers base^i, i = 0, ..., (2^EXP_WIN_SIZE) - 1\n     *   table[0] = mont(x^0) = mont(1)\n     *   table[1] = mont(x^1) = mont(x)\n     */\n    red_X[0][0] = 1;\n    red_X[1][0] = 1;\n    DAMM(red_table[0][0], (const BN_ULONG*)red_X, rr, m, k0);\n    DAMM(red_table[1][0], base,  rr, m, k0);\n\n    for (idx = 1; idx < (int)((1U << EXP_WIN_SIZE) / 2); idx++) {\n        DAMS(red_table[2 * idx + 0][0], red_table[1 * idx][0], m, k0);\n        DAMM(red_table[2 * idx + 1][0], red_table[2 * idx][0], red_table[1][0], m, k0);\n    }\n\n    /* Copy and expand exponents */\n    memcpy(expz[0], exp[0], EXP_DIGITS * sizeof(BN_ULONG));\n    expz[0][EXP_DIGITS] = 0;\n    memcpy(expz[1], exp[1], EXP_DIGITS * sizeof(BN_ULONG));\n    expz[1][EXP_DIGITS] = 0;\n\n    /* Exponentiation */\n    {\n        const int rem = BITSIZE_MODULUS % EXP_WIN_SIZE;\n        BN_ULONG table_idx_mask = EXP_WIN_MASK;\n\n        int exp_bit_no = BITSIZE_MODULUS - rem;\n        int exp_chunk_no = exp_bit_no / 64;\n        int exp_chunk_shift = exp_bit_no % 64;\n\n        BN_ULONG red_table_idx_0, red_table_idx_1;\n\n        /*\n         * If rem == 0, then\n         *      exp_bit_no = modulus_bitsize - exp_win_size\n         * However, this isn't possible because rem is { 1024, 1536, 2048 } % 5\n         * which is { 4, 1, 3 } respectively.\n         *\n         * If this assertion ever fails the fix above is easy.\n         */\n        OPENSSL_assert(rem != 0);\n\n        /* Process 1-st exp window - just init result */\n        red_table_idx_0 = expz[0][exp_chunk_no];\n        red_table_idx_1 = expz[1][exp_chunk_no];\n        /*\n         * The function operates with fixed moduli sizes divisible by 64,\n         * thus table index here is always in supported range [0, EXP_WIN_SIZE).\n         */\n        red_table_idx_0 >>= exp_chunk_shift;\n        red_table_idx_1 >>= exp_chunk_shift;\n\n        ossl_extract_multiplier_2x20_win5(red_Y[0], (const BN_ULONG*)red_table,\n                                          (int)red_table_idx_0, 0);\n        ossl_extract_multiplier_2x20_win5(red_Y[1], (const BN_ULONG*)red_table,\n                                          (int)red_table_idx_1, 1);\n\n        /* Process other exp windows */\n        for (exp_bit_no -= EXP_WIN_SIZE; exp_bit_no >= 0; exp_bit_no -= EXP_WIN_SIZE) {\n            /* Extract pre-computed multiplier from the table */\n            {\n                BN_ULONG T;\n\n                exp_chunk_no = exp_bit_no / 64;\n                exp_chunk_shift = exp_bit_no % 64;\n                {\n                    red_table_idx_0 = expz[0][exp_chunk_no];\n                    T = expz[0][exp_chunk_no + 1];\n\n                    red_table_idx_0 >>= exp_chunk_shift;\n                    /*\n                     * Get additional bits from then next quadword\n                     * when 64-bit boundaries are crossed.\n                     */\n                    if (exp_chunk_shift > 64 - EXP_WIN_SIZE) {\n                        T <<= (64 - exp_chunk_shift);\n                        red_table_idx_0 ^= T;\n                    }\n                    red_table_idx_0 &= table_idx_mask;\n\n                    ossl_extract_multiplier_2x20_win5(red_X[0],\n                                                      (const BN_ULONG*)red_table,\n                                                      (int)red_table_idx_0, 0);\n                }\n                {\n                    red_table_idx_1 = expz[1][exp_chunk_no];\n                    T = expz[1][exp_chunk_no + 1];\n\n                    red_table_idx_1 >>= exp_chunk_shift;\n                    /*\n                     * Get additional bits from then next quadword\n                     * when 64-bit boundaries are crossed.\n                     */\n                    if (exp_chunk_shift > 64 - EXP_WIN_SIZE) {\n                        T <<= (64 - exp_chunk_shift);\n                        red_table_idx_1 ^= T;\n                    }\n                    red_table_idx_1 &= table_idx_mask;\n\n                    ossl_extract_multiplier_2x20_win5(red_X[1],\n                                                      (const BN_ULONG*)red_table,\n                                                      (int)red_table_idx_1, 1);\n                }\n            }\n\n            /* Series of squaring */\n            DAMS((BN_ULONG*)red_Y, (const BN_ULONG*)red_Y, m, k0);\n            DAMS((BN_ULONG*)red_Y, (const BN_ULONG*)red_Y, m, k0);\n            DAMS((BN_ULONG*)red_Y, (const BN_ULONG*)red_Y, m, k0);\n            DAMS((BN_ULONG*)red_Y, (const BN_ULONG*)red_Y, m, k0);\n            DAMS((BN_ULONG*)red_Y, (const BN_ULONG*)red_Y, m, k0);\n\n            DAMM((BN_ULONG*)red_Y, (const BN_ULONG*)red_Y, (const BN_ULONG*)red_X, m, k0);\n        }\n    }\n\n    /*\n     *\n     * NB: After the last AMM of exponentiation in Montgomery domain, the result\n     * may be 1025-bit, but the conversion out of Montgomery domain performs an\n     * AMM(x,1) which guarantees that the final result is less than |m|, so no\n     * conditional subtraction is needed here. See \"Efficient Software\n     * Implementations of Modular Exponentiation\" (by Shay Gueron) paper for details.\n     */\n\n    /* Convert result back in regular 2^52 domain */\n    memset(red_X, 0, sizeof(red_X));\n    red_X[0][0] = 1;\n    red_X[1][0] = 1;\n    DAMM(out, (const BN_ULONG*)red_Y, (const BN_ULONG*)red_X, m, k0);\n\n    /* Clear exponents */\n    OPENSSL_cleanse(expz, sizeof(expz));\n    OPENSSL_cleanse(red_Y, sizeof(red_Y));\n\n# undef DAMS\n# undef DAMM\n# undef EXP_DIGITS\n# undef RED_DIGITS\n# undef EXP_WIN_MASK\n# undef EXP_WIN_SIZE\n# undef BITSIZE_MODULUS\n}",
        "target": 0
    },
    {
        "func": "int ossl_rsaz_mod_exp_avx512_x2(BN_ULONG *res1,\n                                const BN_ULONG *base1,\n                                const BN_ULONG *exp1,\n                                const BN_ULONG *m1,\n                                const BN_ULONG *rr1,\n                                BN_ULONG k0_1,\n                                BN_ULONG *res2,\n                                const BN_ULONG *base2,\n                                const BN_ULONG *exp2,\n                                const BN_ULONG *m2,\n                                const BN_ULONG *rr2,\n                                BN_ULONG k0_2,\n                                int factor_size)\n{\n    int ret = 0;\n\n    /*\n     * Number of word-size (BN_ULONG) digits to store exponent in redundant\n     * representation.\n     */\n    int exp_digits = number_of_digits(factor_size + 2, DIGIT_SIZE);\n    int coeff_pow = 4 * (DIGIT_SIZE * exp_digits - factor_size);\n    BN_ULONG *base1_red, *m1_red, *rr1_red;\n    BN_ULONG *base2_red, *m2_red, *rr2_red;\n    BN_ULONG *coeff_red;\n    BN_ULONG *storage = NULL;\n    BN_ULONG *storage_aligned = NULL;\n    BN_ULONG storage_len_bytes = 7 * exp_digits * sizeof(BN_ULONG);\n\n    /* AMM = Almost Montgomery Multiplication */\n    AMM52 amm = NULL;\n    /* Dual (2-exps in parallel) exponentiation */\n    EXP52_x2 exp_x2 = NULL;\n\n    const BN_ULONG *exp[2] = {0};\n    BN_ULONG k0[2] = {0};\n\n    /* Only 1024-bit factor size is supported now */\n    switch (factor_size) {\n    case 1024:\n        amm = ossl_rsaz_amm52x20_x1_256;\n        exp_x2 = RSAZ_exp52x20_x2_256;\n        break;\n    default:\n        goto err;\n    }\n\n    storage = (BN_ULONG *)OPENSSL_malloc(storage_len_bytes + 64);\n    if (storage == NULL)\n        goto err;\n    storage_aligned = (BN_ULONG *)ALIGN_OF(storage, 64);\n\n    /* Memory layout for red(undant) representations */\n    base1_red = storage_aligned;\n    base2_red = storage_aligned + 1 * exp_digits;\n    m1_red    = storage_aligned + 2 * exp_digits;\n    m2_red    = storage_aligned + 3 * exp_digits;\n    rr1_red   = storage_aligned + 4 * exp_digits;\n    rr2_red   = storage_aligned + 5 * exp_digits;\n    coeff_red = storage_aligned + 6 * exp_digits;\n\n    /* Convert base_i, m_i, rr_i, from regular to 52-bit radix */\n    to_words52(base1_red, exp_digits, base1, factor_size);\n    to_words52(base2_red, exp_digits, base2, factor_size);\n    to_words52(m1_red, exp_digits, m1, factor_size);\n    to_words52(m2_red, exp_digits, m2, factor_size);\n    to_words52(rr1_red, exp_digits, rr1, factor_size);\n    to_words52(rr2_red, exp_digits, rr2, factor_size);\n\n    /*\n     * Compute target domain Montgomery converters RR' for each modulus\n     * based on precomputed original domain's RR.\n     *\n     * RR -> RR' transformation steps:\n     *  (1) coeff = 2^k\n     *  (2) t = AMM(RR,RR) = RR^2 / R' mod m\n     *  (3) RR' = AMM(t, coeff) = RR^2 * 2^k / R'^2 mod m\n     * where\n     *  k = 4 * (52 * digits52 - modlen)\n     *  R  = 2^(64 * ceil(modlen/64)) mod m\n     *  RR = R^2 mod M\n     *  R' = 2^(52 * ceil(modlen/52)) mod m\n     *\n     *  modlen = 1024: k = 64, RR = 2^2048 mod m, RR' = 2^2080 mod m\n     */\n    memset(coeff_red, 0, exp_digits * sizeof(BN_ULONG));\n    /* (1) in reduced domain representation */\n    set_bit(coeff_red, 64 * (int)(coeff_pow / 52) + coeff_pow % 52);\n\n    amm(rr1_red, rr1_red, rr1_red, m1_red, k0_1);     /* (2) for m1 */\n    amm(rr1_red, rr1_red, coeff_red, m1_red, k0_1);   /* (3) for m1 */\n\n    amm(rr2_red, rr2_red, rr2_red, m2_red, k0_2);     /* (2) for m2 */\n    amm(rr2_red, rr2_red, coeff_red, m2_red, k0_2);   /* (3) for m2 */\n\n    exp[0] = exp1;\n    exp[1] = exp2;\n\n    k0[0] = k0_1;\n    k0[1] = k0_2;\n\n    exp_x2(rr1_red, base1_red, exp, m1_red, rr1_red, k0);\n\n    /* Convert rr_i back to regular radix */\n    from_words52(res1, factor_size, rr1_red);\n    from_words52(res2, factor_size, rr2_red);\n\n    /* bn_reduce_once_in_place expects number of BN_ULONG, not bit size */\n    factor_size /= sizeof(BN_ULONG) * 8;\n\n    bn_reduce_once_in_place(res1, /*carry=*/0, m1, storage, factor_size);\n    bn_reduce_once_in_place(res2, /*carry=*/0, m2, storage, factor_size);\n\n    ret = 1;\nerr:\n    if (storage != NULL) {\n        OPENSSL_cleanse(storage, storage_len_bytes);\n        OPENSSL_free(storage);\n    }\n    return ret;\n}",
        "target": 0
    },
    {
        "func": "static void from_words52(BN_ULONG *out, int out_bitsize, const BN_ULONG *in)\n{\n    int i;\n    int out_len = BITS2WORD64_SIZE(out_bitsize);\n\n    assert(out != NULL);\n    assert(in != NULL);\n\n    for (i = 0; i < out_len; i++)\n        out[i] = 0;\n\n    {\n        uint8_t *out_str = (uint8_t *)out;\n\n        for (; out_bitsize >= (2 * DIGIT_SIZE); out_bitsize -= (2 * DIGIT_SIZE), in += 2) {\n            (*(uint64_t *)out_str) = in[0];\n            out_str += 6;\n            (*(uint64_t *)out_str) ^= in[1] << 4;\n            out_str += 7;\n        }\n\n        if (out_bitsize > DIGIT_SIZE) {\n            put_digit52(out_str, 7, in[0]);\n            out_str += 6;\n            out_bitsize -= DIGIT_SIZE;\n            put_digit52(out_str, BITS2WORD8_SIZE(out_bitsize),\n                        (in[1] << 4 | in[0] >> 48));\n        } else if (out_bitsize) {\n            put_digit52(out_str, BITS2WORD8_SIZE(out_bitsize), in[0]);\n        }\n    }\n}",
        "target": 0
    },
    {
        "func": "static ossl_inline uint64_t get_digit52(const uint8_t *in, int in_len)\n{\n    uint64_t digit = 0;\n\n    assert(in != NULL);\n\n    for (; in_len > 0; in_len--) {\n        digit <<= 8;\n        digit += (uint64_t)(in[in_len - 1]);\n    }\n    return digit;\n}",
        "target": 0
    },
    {
        "func": "static ossl_inline void put_digit52(uint8_t *pStr, int strLen, uint64_t digit)\n{\n    assert(pStr != NULL);\n\n    for (; strLen > 0; strLen--) {\n        *pStr++ = (uint8_t)(digit & 0xFF);\n        digit >>= 8;\n    }\n}",
        "target": 0
    },
    {
        "func": "static void to_words52(BN_ULONG *out, int out_len,\n                       const BN_ULONG *in, int in_bitsize)\n{\n    uint8_t *in_str = NULL;\n\n    assert(out != NULL);\n    assert(in != NULL);\n    /* Check destination buffer capacity */\n    assert(out_len >= number_of_digits(in_bitsize, DIGIT_SIZE));\n\n    in_str = (uint8_t *)in;\n\n    for (; in_bitsize >= (2 * DIGIT_SIZE); in_bitsize -= (2 * DIGIT_SIZE), out += 2) {\n        out[0] = (*(uint64_t *)in_str) & DIGIT_MASK;\n        in_str += 6;\n        out[1] = ((*(uint64_t *)in_str) >> 4) & DIGIT_MASK;\n        in_str += 7;\n        out_len -= 2;\n    }\n\n    if (in_bitsize > DIGIT_SIZE) {\n        uint64_t digit = get_digit52(in_str, 7);\n\n        out[0] = digit & DIGIT_MASK;\n        in_str += 6;\n        in_bitsize -= DIGIT_SIZE;\n        digit = get_digit52(in_str, BITS2WORD8_SIZE(in_bitsize));\n        out[1] = digit >> 4;\n        out += 2;\n        out_len -= 2;\n    } else if (in_bitsize > 0) {\n        out[0] = get_digit52(in_str, BITS2WORD8_SIZE(in_bitsize));\n        out++;\n        out_len--;\n    }\n\n    while (out_len > 0) {\n        *out = 0;\n        out_len--;\n        out++;\n    }\n}",
        "target": 0
    },
    {
        "func": "void Dispatcher::onEvent(cl_event event, cl_int status, Device & d) {\n\tif (status != CL_COMPLETE) {\n\t\tstd::cout << \"Dispatcher::onEvent - Got bad status: \" << status << std::endl;\n\t}\n\telse if (d.m_eventFinished != NULL) {\n\t\tinitContinue(d);\n\t} else {\n\t\t++d.m_round;\n\t\thandleResult(d);\n\n\t\tbool bDispatch = true;\n\t\t{\n\t\t\tstd::lock_guard<std::mutex> lock(m_mutex);\n\t\t\td.m_speed.sample(m_size);\n\t\t\tprintSpeed();\n\n\t\t\tif( m_quit ) {\n\t\t\t\tbDispatch = false;\n\t\t\t\tif(--m_countRunning == 0) {\n\t\t\t\t\tclSetUserEventStatus(m_eventFinished, CL_COMPLETE);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (bDispatch) {\n\t\t\tdispatch(d);\n\t\t}\n\t}\n}",
        "target": 0
    },
    {
        "func": "void Dispatcher::initBegin(Device & d) {\n\t// Set mode data\n\tfor (auto i = 0; i < 20; ++i) {\n\t\td.m_memData1[i] = m_mode.data1[i];\n\t\td.m_memData2[i] = m_mode.data2[i];\n\t}\n\n\t// Write precompute table and mode data\n\td.m_memPrecomp.write(true);\n\td.m_memData1.write(true);\n\td.m_memData2.write(true);\n\n\t// Kernel arguments - profanity_begin\n\td.m_memPrecomp.setKernelArg(d.m_kernelInit, 0);\n\td.m_memPointsDeltaX.setKernelArg(d.m_kernelInit, 1);\n\td.m_memPrevLambda.setKernelArg(d.m_kernelInit, 2);\n\td.m_memResult.setKernelArg(d.m_kernelInit, 3);\n\tCLMemory<cl_ulong4>::setKernelArg(d.m_kernelInit, 4, d.m_clSeed);\n\n\t// Kernel arguments - profanity_inverse\n\td.m_memPointsDeltaX.setKernelArg(d.m_kernelInverse, 0);\n\td.m_memInversedNegativeDoubleGy.setKernelArg(d.m_kernelInverse, 1);\n\n\t// Kernel arguments - profanity_iterate\n\td.m_memPointsDeltaX.setKernelArg(d.m_kernelIterate, 0);\n\td.m_memInversedNegativeDoubleGy.setKernelArg(d.m_kernelIterate, 1);\n\td.m_memPrevLambda.setKernelArg(d.m_kernelIterate, 2);\n\n\t// Kernel arguments - profanity_transform_*\n\tif(d.m_kernelTransform) {\n\t\td.m_memInversedNegativeDoubleGy.setKernelArg(d.m_kernelTransform, 0);\n\t}\n\n\t// Kernel arguments - profanity_score_*\n\td.m_memInversedNegativeDoubleGy.setKernelArg(d.m_kernelScore, 0);\n\td.m_memResult.setKernelArg(d.m_kernelScore, 1);\n\td.m_memData1.setKernelArg(d.m_kernelScore, 2);\n\td.m_memData2.setKernelArg(d.m_kernelScore, 3);\n\n\tCLMemory<cl_uchar>::setKernelArg(d.m_kernelScore, 4, d.m_clScoreMax); // Updated in handleResult()\n\n\t// Seed device\n\tinitContinue(d);\n}",
        "target": 0
    },
    {
        "func": "unsigned int getKernelExecutionTimeMicros(cl_event & e) {\n\tcl_ulong timeStart = 0, timeEnd = 0;\n\tclWaitForEvents(1, &e);\n\tclGetEventProfilingInfo(e, CL_PROFILING_COMMAND_START, sizeof(timeStart), &timeStart, NULL);\n\tclGetEventProfilingInfo(e, CL_PROFILING_COMMAND_END, sizeof(timeEnd), &timeEnd, NULL);\n\treturn (timeEnd - timeStart) / 1000;\n}",
        "target": 0
    },
    {
        "func": "void Dispatcher::addDevice(cl_device_id clDeviceId, const size_t worksizeLocal, const size_t index) {\n\tDevice * pDevice = new Device(*this, m_clContext, m_clProgram, clDeviceId, worksizeLocal, m_size, index, m_mode);\n\tm_vDevices.push_back(pDevice);\n}",
        "target": 0
    },
    {
        "func": "void Dispatcher::enqueueKernelDevice(Device & d, cl_kernel & clKernel, size_t worksizeGlobal, cl_event * pEvent = NULL) {\n\ttry {\n\t\tenqueueKernel(d.m_clQueue, clKernel, worksizeGlobal, d.m_worksizeLocal, pEvent);\n\t} catch ( OpenCLException & e ) {\n\t\t// If local work size is invalid, abandon it and let implementation decide\n\t\tif ((e.m_res == CL_INVALID_WORK_GROUP_SIZE || e.m_res == CL_INVALID_WORK_ITEM_SIZE) && d.m_worksizeLocal != 0) {\n\t\t\tstd::cout << std::endl << \"warning: local work size abandoned on GPU\" << d.m_index << std::endl;\n\t\t\td.m_worksizeLocal = 0;\n\t\t\tenqueueKernel(d.m_clQueue, clKernel, worksizeGlobal, d.m_worksizeLocal, pEvent);\n\t\t}\n\t\telse {\n\t\t\tthrow;\n\t\t}\n\t}\n}",
        "target": 0
    },
    {
        "func": "bool printResult(const cl_int err) {\n\tstd::cout << ((err != CL_SUCCESS) ? toString(err) : \"OK\") << std::endl;\n\treturn err != CL_SUCCESS;\n}",
        "target": 0
    },
    {
        "func": "Dispatcher::Device::~Device() {\n\n}",
        "target": 0
    },
    {
        "func": "T clGetWrapper(U function, V param, W param2) {\n\tT t;\n\tfunction(param, param2, sizeof(t), &t, NULL);\n\treturn t;\n}",
        "target": 0
    },
    {
        "func": "void Dispatcher::run() {\n\tm_eventFinished = clCreateUserEvent(m_clContext, NULL);\n\ttimeStart = std::chrono::steady_clock::now();\n\n\tinit();\n\n\tconst auto timeInitialization = std::chrono::duration_cast<std::chrono::seconds>(std::chrono::steady_clock::now() - timeStart).count();\n\tstd::cout << \"Initialization time: \" << timeInitialization << \" seconds\" << std::endl;\n\n\tm_quit = false;\n\tm_countRunning = m_vDevices.size();\n\n\tstd::cout << \"Running...\" << std::endl;\n\tstd::cout << \"  Always verify that a private key generated by this program corresponds to the\" << std::endl;\n\tstd::cout << \"  public key printed by importing it to a wallet of your choice. This program\" << std::endl;\n\tstd::cout << \"  like any software might contain bugs and it does by design cut corners to\" << std::endl;\n\tstd::cout << \"  improve overall performance.\" << std::endl;\n\tstd::cout << std::endl;\n\n\tfor (auto it = m_vDevices.begin(); it != m_vDevices.end(); ++it) {\n\t\tdispatch(*(*it));\n\t}\n\n\tclWaitForEvents(1, &m_eventFinished);\n\tclReleaseEvent(m_eventFinished);\n\tm_eventFinished = NULL;\n}",
        "target": 0
    },
    {
        "func": "Dispatcher::Dispatcher(cl_context & clContext, cl_program & clProgram, const Mode mode, const size_t worksizeMax, const size_t inverseSize, const size_t inverseMultiple, const cl_uchar clScoreQuit)\n\t: m_clContext(clContext), m_clProgram(clProgram), m_mode(mode), m_worksizeMax(worksizeMax), m_inverseSize(inverseSize), m_size(inverseSize*inverseMultiple), m_clScoreMax(mode.score), m_clScoreQuit(clScoreQuit), m_eventFinished(NULL), m_countPrint(0) {\n\n}",
        "target": 0
    },
    {
        "func": "std::vector<std::string> getBinaries(cl_program & clProgram) {\n\tstd::vector<std::string> vReturn;\n\tauto vSizes = clGetWrapperVector<size_t>(clGetProgramInfo, clProgram, CL_PROGRAM_BINARY_SIZES);\n\tif (!vSizes.empty()) {\n\t\tunsigned char * * pBuffers = new unsigned char *[vSizes.size()];\n\t\tfor (size_t i = 0; i < vSizes.size(); ++i) {\n\t\t\tpBuffers[i] = new unsigned char[vSizes[i]];\n\t\t}\n\n\t\tclGetProgramInfo(clProgram, CL_PROGRAM_BINARIES, vSizes.size() * sizeof(unsigned char *), pBuffers, NULL);\n\t\tfor (size_t i = 0; i < vSizes.size(); ++i) {\n\t\t\tstd::string strData(reinterpret_cast<char *>(pBuffers[i]), vSizes[i]);\n\t\t\tvReturn.push_back(strData);\n\t\t\tdelete[] pBuffers[i];\n\t\t}\n\n\t\tdelete[] pBuffers;\n\t}\n\n\treturn vReturn;\n}",
        "target": 0
    },
    {
        "func": "std::string Dispatcher::formatSpeed(double f) {\n\tconst std::string S = \" KMGT\";\n\n\tunsigned int index = 0;\n\twhile (f > 1000.0f && index < S.size()) {\n\t\tf /= 1000.0f;\n\t\t++index;\n\t}\n\n\tstd::ostringstream ss;\n\tss << std::fixed << std::setprecision(3) << (double)f << \" \" << S[index] << \"H/s\";\n\treturn ss.str();\n}",
        "target": 0
    },
    {
        "func": "cl_ulong4 Dispatcher::Device::createSeed() {\n#ifdef PROFANITY_DEBUG\n\tcl_ulong4 r;\n\tr.s[0] = 1;\n\tr.s[1] = 1;\n\tr.s[2] = 1;\n\tr.s[3] = 1;\n\treturn r;\n#else\n\t// Randomize private keys\n\tstd::random_device rd;\n\t//\n\tuint64_t rt = rd();\n\tuint64_t r1 = (rt << 32) | rd();\n\tr.s[0] = r1;\n\t//\n\trt = rd();\n\tr1 = (rt << 32) | rd();\n\tr.s[1] = r1;\n\t//\n\trt = rd();\n\tr1 = (rt << 32) | rd();\n\tr.s[2] = r1;\n\t// \n\trt = rd();\n\tr1 = (rt << 32) | rd();\n\tr.s[3] = r1;\n\treturn r;\n#endif\n}",
        "target": 0
    },
    {
        "func": "std::string clGetWrapperString(U function, V param, W param2) {\n\tsize_t len;\n\tfunction(param, param2, 0, NULL, &len);\n\tchar * const szString = new char[len];\n\tfunction(param, param2, len, szString, NULL);\n\tstd::string r(szString);\n\tdelete[] szString;\n\treturn r;\n}",
        "target": 0
    },
    {
        "func": "void Dispatcher::printSpeed() {\n\t++m_countPrint;\n\tif( m_countPrint > m_vDevices.size() ) {\n\t\tstd::string strGPUs;\n\t\tdouble speedTotal = 0;\n\t\tunsigned int i = 0;\n\t\tfor (auto & e : m_vDevices) {\n\t\t\tconst auto curSpeed = e->m_speed.getSpeed();\n\t\t\tspeedTotal += curSpeed;\n\t\t\tstrGPUs += \" GPU\" + toString(e->m_index) + \": \" + formatSpeed(curSpeed);\n\t\t\t++i;\n\t\t}\n\n\t\tconst std::string strVT100ClearLine = \"\\33[2K\\r\";\n\t\tstd::cerr << strVT100ClearLine << \"Total: \" << formatSpeed(speedTotal) << \" -\" << strGPUs << '\\r' << std::flush;\n\t\tm_countPrint = 0;\n\t}\n}",
        "target": 0
    },
    {
        "func": "std::string readFile(const char * const szFilename)\n{\n\tstd::ifstream in(szFilename, std::ios::in | std::ios::binary);\n\tstd::ostringstream contents;\n\tcontents << in.rdbuf();\n\treturn contents.str();\n}",
        "target": 0
    },
    {
        "func": "std::string getDeviceCacheFilename(cl_device_id & d, const size_t & inverseSize) {\n\tconst auto uniqueId = getUniqueDeviceIdentifier(d);\n\treturn \"cache-opencl.\" + toString(inverseSize) + \".\" + toString(uniqueId);\n}",
        "target": 0
    },
    {
        "func": "unsigned int getUniqueDeviceIdentifier(const cl_device_id & deviceId) {\n#if defined(CL_DEVICE_TOPOLOGY_AMD)\n\tauto topology = clGetWrapper<cl_device_topology_amd>(clGetDeviceInfo, deviceId, CL_DEVICE_TOPOLOGY_AMD);\n\tif (topology.raw.type == CL_DEVICE_TOPOLOGY_TYPE_PCIE_AMD) {\n\t\treturn (topology.pcie.bus << 16) + (topology.pcie.device << 8) + topology.pcie.function;\n\t}\n#endif\n\tcl_int bus_id = clGetWrapper<cl_int>(clGetDeviceInfo, deviceId, CL_DEVICE_PCI_BUS_ID_NV);\n\tcl_int slot_id = clGetWrapper<cl_int>(clGetDeviceInfo, deviceId, CL_DEVICE_PCI_SLOT_ID_NV);\n\treturn (bus_id << 16) + slot_id;\n}",
        "target": 0
    },
    {
        "func": "void Dispatcher::dispatch(Device & d) {\n\tcl_event event;\n\td.m_memResult.read(false, &event);\n\n#ifdef PROFANITY_DEBUG\n\tcl_event eventInverse;\n\tcl_event eventIterate;\n\n\tenqueueKernelDevice(d, d.m_kernelInverse, m_size / m_inverseSize, &eventInverse);\n\tenqueueKernelDevice(d, d.m_kernelIterate, m_size, &eventIterate);\n#else\n\tenqueueKernelDevice(d, d.m_kernelInverse, m_size / m_inverseSize);\n\tenqueueKernelDevice(d, d.m_kernelIterate, m_size);\n#endif\n\n\tif (d.m_kernelTransform) {\n\t\tenqueueKernelDevice(d, d.m_kernelTransform, m_size);\n\t}\n\n\tenqueueKernelDevice(d, d.m_kernelScore, m_size);\n\tclFlush(d.m_clQueue);\n\n#ifdef PROFANITY_DEBUG\n\t// We're actually not allowed to call clFinish here because this function is ultimately asynchronously called by OpenCL.\n\t// However, this happens to work on my computer and it's not really intended for release, just something to aid me in\n\t// optimizations.\n\tclFinish(d.m_clQueue); \n\tstd::cout << \"Timing: profanity_inverse = \" << getKernelExecutionTimeMicros(eventInverse) << \"us, profanity_iterate = \" << getKernelExecutionTimeMicros(eventIterate) << \"us\" << std::endl;\n#endif\n\n\tconst auto res = clSetEventCallback(event, CL_COMPLETE, staticCallback, &d);\n\tOpenCLException::throwIfError(\"failed to set custom callback\", res);\n}",
        "target": 0
    },
    {
        "func": "Dispatcher::OpenCLException::OpenCLException(const std::string s, const cl_int res) :\n\tstd::runtime_error( s + \" (res = \" + toString(res) + \")\"),\n\tm_res(res)\n{\n\n}",
        "target": 0
    },
    {
        "func": "std::vector<T> clGetWrapperVector(U function, V param, W param2) {\n\tsize_t len;\n\tfunction(param, param2, 0, NULL, &len);\n\tlen /= sizeof(T);\n\tstd::vector<T> v;\n\tif (len > 0) {\n\t\tT * pArray = new T[len];\n\t\tfunction(param, param2, len * sizeof(T), pArray, NULL);\n\t\tfor (size_t i = 0; i < len; ++i) {\n\t\t\tv.push_back(pArray[i]);\n\t\t}\n\t\tdelete[] pArray;\n\t}\n\treturn v;\n}",
        "target": 0
    },
    {
        "func": "void Dispatcher::initContinue(Device & d) {\n\tsize_t sizeLeft = m_size - d.m_sizeInitialized;\n\tconst size_t sizeInitLimit = m_size / 20;\n\n\t// Print progress\n\tconst size_t percentDone = m_sizeInitDone * 100 / m_sizeInitTotal;\n\tstd::cout << \"  \" << percentDone << \"%\\r\" << std::flush;\n\n\tif (sizeLeft) {\n\t\tcl_event event;\n\t\tconst size_t sizeRun = std::min(sizeInitLimit, std::min(sizeLeft, m_worksizeMax));\n\t\tconst auto resEnqueue = clEnqueueNDRangeKernel(d.m_clQueue, d.m_kernelInit, 1, &d.m_sizeInitialized, &sizeRun, NULL, 0, NULL, &event);\n\t\tOpenCLException::throwIfError(\"kernel queueing failed during initilization\", resEnqueue);\n\n\t\t// See: https://www.khronos.org/registry/OpenCL/sdk/1.2/docs/man/xhtml/clSetEventCallback.html\n\t\t// If an application needs to wait for completion of a routine from the above list in a callback, please use the non-blocking form of the function, and\n\t\t// assign a completion callback to it to do the remainder of your work. Note that when a callback (or other code) enqueues commands to a command-queue,\n\t\t// the commands are not required to begin execution until the queue is flushed. In standard usage, blocking enqueue calls serve this role by implicitly\n\t\t// flushing the queue. Since blocking calls are not permitted in callbacks, those callbacks that enqueue commands on a command queue should either call\n\t\t// clFlush on the queue before returning or arrange for clFlush to be called later on another thread.\n\t\tclFlush(d.m_clQueue); \n\n\t\tstd::lock_guard<std::mutex> lock(m_mutex);\n\t\td.m_sizeInitialized += sizeRun;\n\t\tm_sizeInitDone += sizeRun;\n\n\t\tconst auto resCallback = clSetEventCallback(event, CL_COMPLETE, staticCallback, &d);\n\t\tOpenCLException::throwIfError(\"failed to set custom callback during initialization\", resCallback);\n\t} else {\n\t\t// Printing one whole string at once helps in avoiding garbled output when executed in parallell\n\t\tconst std::string strOutput = \"  GPU\" + toString(d.m_index) + \" initialized\";\n\t\tstd::cout << strOutput << std::endl;\n\t\tclSetUserEventStatus(d.m_eventFinished, CL_COMPLETE);\n\t}\n}",
        "target": 0
    },
    {
        "func": "std::vector<cl_device_id> getAllDevices(cl_device_type deviceType = CL_DEVICE_TYPE_GPU)\n{\n\tstd::vector<cl_device_id> vDevices;\n\n\tcl_uint platformIdCount = 0;\n\tclGetPlatformIDs (0, NULL, &platformIdCount);\n\n\tstd::vector<cl_platform_id> platformIds (platformIdCount);\n\tclGetPlatformIDs (platformIdCount, platformIds.data (), NULL);\n\n\tfor( auto it = platformIds.cbegin(); it != platformIds.cend(); ++it ) {\n\t\tcl_uint countDevice;\n\t\tclGetDeviceIDs(*it, deviceType, 0, NULL, &countDevice);\n\n\t\tstd::vector<cl_device_id> deviceIds(countDevice);\n\t\tclGetDeviceIDs(*it, deviceType, countDevice, deviceIds.data(), &countDevice);\n\n\t\tstd::copy( deviceIds.begin(), deviceIds.end(), std::back_inserter(vDevices) );\n\t}\n\n\treturn vDevices;\n}",
        "target": 0
    },
    {
        "func": "static void printResult(cl_ulong4 seed, cl_ulong round, result r, cl_uchar score, const std::chrono::time_point<std::chrono::steady_clock> & timeStart, const Mode & mode) {\n\t// Time delta\n\tconst auto seconds = std::chrono::duration_cast<std::chrono::seconds>(std::chrono::steady_clock::now() - timeStart).count();\n\n\t// Format private key\n\tcl_ulong carry = 0;\n\tcl_ulong4 seedRes;\n\n\tseedRes.s[0] = seed.s[0] + round; carry = seedRes.s[0] < round;\n\tseedRes.s[1] = seed.s[1] + carry; carry = !seedRes.s[1];\n\tseedRes.s[2] = seed.s[2] + carry; carry = !seedRes.s[2];\n\tseedRes.s[3] = seed.s[3] + carry + r.foundId;\n\n\tstd::ostringstream ss;\n\tss << std::hex << std::setfill('0');\n\tss << std::setw(16) << seedRes.s[3] << std::setw(16) << seedRes.s[2] << std::setw(16) << seedRes.s[1] << std::setw(16) << seedRes.s[0];\n\tconst std::string strPrivate = ss.str();\n\n\t// Format public key\n\tconst std::string strPublic = toHex(r.foundHash, 20);\n\n\t// Print\n\tconst std::string strVT100ClearLine = \"\\33[2K\\r\";\n\tstd::cout << strVT100ClearLine << \"  Time: \" << std::setw(5) << seconds << \"s Score: \" << std::setw(2) << (int) score << \" Private: 0x\" << strPrivate << ' ';\n\n\tstd::cout << mode.transformName();\n\tstd::cout << \": 0x\" << strPublic << std::endl;\n}",
        "target": 0
    },
    {
        "func": "void Dispatcher::init() {\n\tstd::cout << \"Initializing devices...\" << std::endl;\n\tstd::cout << \"  This should take less than a minute. The number of objects initialized on each\" << std::endl;\n\tstd::cout << \"  device is equal to inverse-size * inverse-multiple. To lower\" << std::endl;\n\tstd::cout << \"  initialization time (and memory footprint) I suggest lowering the\" << std::endl;\n\tstd::cout << \"  inverse-multiple first. You can do this via the -I switch. Do note that\" << std::endl;\n\tstd::cout << \"  this might negatively impact your performance.\" << std::endl;\n\tstd::cout << std::endl;\n\n\tconst auto deviceCount = m_vDevices.size();\n\tm_sizeInitTotal = m_size * deviceCount;\n\tm_sizeInitDone = 0;\n\n\tcl_event * const pInitEvents = new cl_event[deviceCount];\n\n\tfor (size_t i = 0; i < deviceCount; ++i) {\n\t\tpInitEvents[i] = clCreateUserEvent(m_clContext, NULL);\n\t\tm_vDevices[i]->m_eventFinished = pInitEvents[i];\n\t\tinitBegin(*m_vDevices[i]);\n\t}\n\n\tclWaitForEvents(deviceCount, pInitEvents);\n\tfor (size_t i = 0; i < deviceCount; ++i) {\n\t\tm_vDevices[i]->m_eventFinished = NULL;\n\t\tclReleaseEvent(pInitEvents[i]);\n\t}\n\n\tdelete[] pInitEvents;\n\n\tstd::cout << std::endl;\n}",
        "target": 0
    },
    {
        "func": "cl_command_queue Dispatcher::Device::createQueue(cl_context & clContext, cl_device_id & clDeviceId) {\n\t// nVidia CUDA Toolkit 10.1 only supports OpenCL 1.2 so we revert back to older functions for compatability\n#ifdef PROFANITY_DEBUG\n\tcl_command_queue_properties p = CL_QUEUE_PROFILING_ENABLE;\n#else\n\tcl_command_queue_properties p = NULL;\n#endif\n\n#ifdef CL_VERSION_2_0\n\tconst cl_command_queue ret = clCreateCommandQueueWithProperties(clContext, clDeviceId, &p, NULL);\n#else\n\tconst cl_command_queue ret = clCreateCommandQueue(clContext, clDeviceId, p, NULL);\n#endif\n\treturn ret == NULL ? throw std::runtime_error(\"failed to create command queue\") : ret;\n}",
        "target": 0
    },
    {
        "func": "void Dispatcher::handleResult(Device & d) {\n\tfor (auto i = PROFANITY_MAX_SCORE; i > m_clScoreMax; --i) {\n\t\tresult & r = d.m_memResult[i];\n\n\t\tif (r.found > 0 && i >= d.m_clScoreMax) {\n\t\t\td.m_clScoreMax = i;\n\t\t\tCLMemory<cl_uchar>::setKernelArg(d.m_kernelScore, 4, d.m_clScoreMax);\n\n\t\t\tstd::lock_guard<std::mutex> lock(m_mutex);\n\t\t\tif (i >= m_clScoreMax) {\n\t\t\t\tm_clScoreMax = i;\n\n\t\t\t\tif (m_clScoreQuit && i >= m_clScoreQuit) {\n\t\t\t\t\tm_quit = true;\n\t\t\t\t}\n\n\t\t\t\tprintResult(d.m_clSeed, d.m_round, r, i, timeStart, m_mode);\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t}\n}",
        "target": 0
    },
    {
        "func": "template <typename T> bool printResult(const T & t, const cl_int & err) {\n\tstd::cout << ((t == NULL) ? toString(err) : \"OK\") << std::endl;\n\treturn t == NULL;\n}",
        "target": 0
    },
    {
        "func": "void CL_CALLBACK Dispatcher::staticCallback(cl_event event, cl_int event_command_exec_status, void * user_data) {\n\tDevice * const pDevice = static_cast<Device *>(user_data);\n\tpDevice->m_parent.onEvent(event, event_command_exec_status, *pDevice);\n\tclReleaseEvent(event);\n}",
        "target": 0
    },
    {
        "func": "int main(int argc, char * * argv) {\n\t// THIS LINE WILL LEAD TO A COMPILE ERROR. THIS TOOL SHOULD NOT BE USED, SEE README.\n\n\ttry {\n\t\tArgParser argp(argc, argv);\n\t\tbool bHelp = false;\n\t\tbool bModeBenchmark = false;\n\t\tbool bModeZeros = false;\n\t\tbool bModeLetters = false;\n\t\tbool bModeNumbers = false;\n\t\tstd::string strModeLeading;\n\t\tstd::string strModeMatching;\n\t\tbool bModeLeadingRange = false;\n\t\tbool bModeRange = false;\n\t\tbool bModeMirror = false;\n\t\tbool bModeDoubles = false;\n\t\tint rangeMin = 0;\n\t\tint rangeMax = 0;\n\t\tstd::vector<size_t> vDeviceSkipIndex;\n\t\tsize_t worksizeLocal = 64;\n\t\tsize_t worksizeMax = 0; // Will be automatically determined later if not overriden by user\n\t\tbool bNoCache = false;\n\t\tsize_t inverseSize = 255;\n\t\tsize_t inverseMultiple = 16384;\n\t\tbool bMineContract = false;\n\n\t\targp.addSwitch('h', \"help\", bHelp);\n\t\targp.addSwitch('0', \"benchmark\", bModeBenchmark);\n\t\targp.addSwitch('1', \"zeros\", bModeZeros);\n\t\targp.addSwitch('2', \"letters\", bModeLetters);\n\t\targp.addSwitch('3', \"numbers\", bModeNumbers);\n\t\targp.addSwitch('4', \"leading\", strModeLeading);\n\t\targp.addSwitch('5', \"matching\", strModeMatching);\n\t\targp.addSwitch('6', \"leading-range\", bModeLeadingRange);\n\t\targp.addSwitch('7', \"range\", bModeRange);\n\t\targp.addSwitch('8', \"mirror\", bModeMirror);\n\t\targp.addSwitch('9', \"leading-doubles\", bModeDoubles);\n\t\targp.addSwitch('m', \"min\", rangeMin);\n\t\targp.addSwitch('M', \"max\", rangeMax);\n\t\targp.addMultiSwitch('s', \"skip\", vDeviceSkipIndex);\n\t\targp.addSwitch('w', \"work\", worksizeLocal);\n\t\targp.addSwitch('W', \"work-max\", worksizeMax);\n\t\targp.addSwitch('n', \"no-cache\", bNoCache);\n\t\targp.addSwitch('i', \"inverse-size\", inverseSize);\n\t\targp.addSwitch('I', \"inverse-multiple\", inverseMultiple);\n\t\targp.addSwitch('c', \"contract\", bMineContract);\n\n\t\tif (!argp.parse()) {\n\t\t\tstd::cout << \"error: bad arguments, try again :<\" << std::endl;\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (bHelp) {\n\t\t\tstd::cout << g_strHelp << std::endl;\n\t\t\treturn 0;\n\t\t}\n\n\t\tMode mode = Mode::benchmark();\n\t\tif (bModeBenchmark) {\n\t\t\tmode = Mode::benchmark();\n\t\t} else if (bModeZeros) {\n\t\t\tmode = Mode::zeros();\n\t\t} else if (bModeLetters) {\n\t\t\tmode = Mode::letters();\n\t\t} else if (bModeNumbers) {\n\t\t\tmode = Mode::numbers();\n\t\t} else if (!strModeLeading.empty()) {\n\t\t\tmode = Mode::leading(strModeLeading.front());\n\t\t} else if (!strModeMatching.empty()) {\n\t\t\tmode = Mode::matching(strModeMatching);\n\t\t} else if (bModeLeadingRange) {\n\t\t\tmode = Mode::leadingRange(rangeMin, rangeMax);\n\t\t} else if (bModeRange) {\n\t\t\tmode = Mode::range(rangeMin, rangeMax);\n\t\t} else if(bModeMirror) {\n\t\t\tmode = Mode::mirror();\n\t\t} else if (bModeDoubles) {\n\t\t\tmode = Mode::doubles();\n\t\t} else {\n\t\t\tstd::cout << g_strHelp << std::endl;\n\t\t\treturn 0;\n\t\t}\n\t\tstd::cout << \"Mode: \" << mode.name << std::endl;\n\n\t\tif (bMineContract) {\n\t\t\tmode.target = CONTRACT;\n\t\t} else {\n\t\t\tmode.target = ADDRESS;\n\t\t}\n\t\tstd::cout << \"Target: \" << mode.transformName() << std:: endl;\n\n\t\tstd::vector<cl_device_id> vFoundDevices = getAllDevices();\n\t\tstd::vector<cl_device_id> vDevices;\n\t\tstd::map<cl_device_id, size_t> mDeviceIndex;\n\n\t\tstd::vector<std::string> vDeviceBinary;\n\t\tstd::vector<size_t> vDeviceBinarySize;\n\t\tcl_int errorCode;\n\t\tbool bUsedCache = false;\n\n\t\tstd::cout << \"Devices:\" << std::endl;\n\t\tfor (size_t i = 0; i < vFoundDevices.size(); ++i) {\n\t\t\t// Ignore devices in skip index\n\t\t\tif (std::find(vDeviceSkipIndex.begin(), vDeviceSkipIndex.end(), i) != vDeviceSkipIndex.end()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcl_device_id & deviceId = vFoundDevices[i];\n\n\t\t\tconst auto strName = clGetWrapperString(clGetDeviceInfo, deviceId, CL_DEVICE_NAME);\n\t\t\tconst auto computeUnits = clGetWrapper<cl_uint>(clGetDeviceInfo, deviceId, CL_DEVICE_MAX_COMPUTE_UNITS);\n\t\t\tconst auto globalMemSize = clGetWrapper<cl_ulong>(clGetDeviceInfo, deviceId, CL_DEVICE_GLOBAL_MEM_SIZE);\n\t\t\tbool precompiled = false;\n\n\t\t\t// Check if there's a prebuilt binary for this device and load it\n\t\t\tif(!bNoCache) {\n\t\t\t\tstd::ifstream fileIn(getDeviceCacheFilename(deviceId, inverseSize), std::ios::binary);\n\t\t\t\tif (fileIn.is_open()) {\n\t\t\t\t\tvDeviceBinary.push_back(std::string((std::istreambuf_iterator<char>(fileIn)), std::istreambuf_iterator<char>()));\n\t\t\t\t\tvDeviceBinarySize.push_back(vDeviceBinary.back().size());\n\t\t\t\t\tprecompiled = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstd::cout << \"  GPU\" << i << \": \" << strName << \", \" << globalMemSize << \" bytes available, \" << computeUnits << \" compute units (precompiled = \" << (precompiled ? \"yes\" : \"no\") << \")\" << std::endl;\n\t\t\tvDevices.push_back(vFoundDevices[i]);\n\t\t\tmDeviceIndex[vFoundDevices[i]] = i;\n\t\t}\n\n\t\tif (vDevices.empty()) {\n\t\t\treturn 1;\n\t\t}\n\n\t\tstd::cout << std::endl;\n\t\tstd::cout << \"Initializing OpenCL...\" << std::endl;\n\t\tstd::cout << \"  Creating context...\" << std::flush;\n\t\tauto clContext = clCreateContext( NULL, vDevices.size(), vDevices.data(), NULL, NULL, &errorCode);\n\t\tif (printResult(clContext, errorCode)) {\n\t\t\treturn 1;\n\t\t}\n\n\t\tcl_program clProgram;\n\t\tif (vDeviceBinary.size() == vDevices.size()) {\n\t\t\t// Create program from binaries\n\t\t\tbUsedCache = true;\n\n\t\t\tstd::cout << \"  Loading kernel from binary...\" << std::flush;\n\t\t\tconst unsigned char * * pKernels = new const unsigned char *[vDevices.size()];\n\t\t\tfor (size_t i = 0; i < vDeviceBinary.size(); ++i) {\n\t\t\t\tpKernels[i] = reinterpret_cast<const unsigned char *>(vDeviceBinary[i].data());\n\t\t\t}\n\n\t\t\tcl_int * pStatus = new cl_int[vDevices.size()];\n\n\t\t\tclProgram = clCreateProgramWithBinary(clContext, vDevices.size(), vDevices.data(), vDeviceBinarySize.data(), pKernels, pStatus, &errorCode);\n\t\t\tif(printResult(clProgram, errorCode)) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else {\n\t\t\t// Create a program from the kernel source\n\t\t\tstd::cout << \"  Compiling kernel...\" << std::flush;\n\t\t\tconst std::string strKeccak = readFile(\"keccak.cl\");\n\t\t\tconst std::string strVanity = readFile(\"profanity.cl\");\n\t\t\tconst char * szKernels[] = { strKeccak.c_str(), strVanity.c_str() };\n\n\t\t\tclProgram = clCreateProgramWithSource(clContext, sizeof(szKernels) / sizeof(char *), szKernels, NULL, &errorCode);\n\t\t\tif (printResult(clProgram, errorCode)) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\n\t\t// Build the program\n\t\tstd::cout << \"  Building program...\" << std::flush;\n\t\tconst std::string strBuildOptions = \"-D PROFANITY_INVERSE_SIZE=\" + toString(inverseSize) + \" -D PROFANITY_MAX_SCORE=\" + toString(PROFANITY_MAX_SCORE);\n\t\tif (printResult(clBuildProgram(clProgram, vDevices.size(), vDevices.data(), strBuildOptions.c_str(), NULL, NULL))) {\n#ifdef PROFANITY_DEBUG\n\t\t\tstd::cout << std::endl;\n\t\t\tstd::cout << \"build log:\" << std::endl;\n\n\t\t\tsize_t sizeLog;\n\t\t\tclGetProgramBuildInfo(clProgram, vDevices[0], CL_PROGRAM_BUILD_LOG, 0, NULL, &sizeLog);\n\t\t\tchar * const szLog = new char[sizeLog];\n\t\t\tclGetProgramBuildInfo(clProgram, vDevices[0], CL_PROGRAM_BUILD_LOG, sizeLog, szLog, NULL);\n\n\t\t\tstd::cout << szLog << std::endl;\n\t\t\tdelete[] szLog;\n#endif\n\t\t\treturn 1;\n\t\t}\n\n\t\t// Save binary to improve future start times\n\t\tif( !bUsedCache && !bNoCache ) {\n\t\t\tstd::cout << \"  Saving program...\" << std::flush;\n\t\t\tauto binaries = getBinaries(clProgram);\n\t\t\tfor (size_t i = 0; i < binaries.size(); ++i) {\n\t\t\t\tstd::ofstream fileOut(getDeviceCacheFilename(vDevices[i], inverseSize), std::ios::binary);\n\t\t\t\tfileOut.write(binaries[i].data(), binaries[i].size());\n\t\t\t}\n\t\t\tstd::cout << \"OK\" << std::endl;\n\t\t}\n\n\t\tstd::cout << std::endl;\n\n\t\tDispatcher d(clContext, clProgram, mode, worksizeMax == 0 ? inverseSize * inverseMultiple : worksizeMax, inverseSize, inverseMultiple, 0);\n\t\tfor (auto & i : vDevices) {\n\t\t\td.addDevice(i, worksizeLocal, mDeviceIndex[i]);\n\t\t}\n\n\t\td.run();\n\t\tclReleaseContext(clContext);\n\t\treturn 0;\n\t} catch (std::runtime_error & e) {\n\t\tstd::cout << \"std::runtime_error - \" << e.what() << std::endl;\n\t} catch (...) {\n\t\tstd::cout << \"unknown exception occured\" << std::endl;\n\t}\n\n\treturn 1;\n}",
        "target": 0
    },
    {
        "func": "Dispatcher::Device::Device(Dispatcher & parent, cl_context & clContext, cl_program & clProgram, cl_device_id clDeviceId, const size_t worksizeLocal, const size_t size, const size_t index, const Mode & mode) :\n\tm_parent(parent),\n\tm_index(index),\n\tm_clDeviceId(clDeviceId),\n\tm_worksizeLocal(worksizeLocal),\n\tm_clScoreMax(0),\n\tm_clQueue(createQueue(clContext, clDeviceId) ),\n\tm_kernelInit( createKernel(clProgram, \"profanity_init\") ),\n\tm_kernelInverse(createKernel(clProgram, \"profanity_inverse\")),\n\tm_kernelIterate(createKernel(clProgram, \"profanity_iterate\")),\n\tm_kernelTransform( mode.transformKernel() == \"\" ? NULL : createKernel(clProgram, mode.transformKernel())),\n\tm_kernelScore(createKernel(clProgram, mode.kernel)),\n\tm_memPrecomp(clContext, m_clQueue, CL_MEM_READ_ONLY | CL_MEM_HOST_WRITE_ONLY, sizeof(g_precomp), g_precomp),\n\tm_memPointsDeltaX(clContext, m_clQueue, CL_MEM_READ_WRITE | CL_MEM_HOST_NO_ACCESS, size, true),\n\tm_memInversedNegativeDoubleGy(clContext, m_clQueue, CL_MEM_READ_WRITE | CL_MEM_HOST_NO_ACCESS, size, true),\n\tm_memPrevLambda(clContext, m_clQueue, CL_MEM_READ_WRITE | CL_MEM_HOST_NO_ACCESS, size, true),\n\tm_memResult(clContext, m_clQueue, CL_MEM_READ_WRITE | CL_MEM_HOST_READ_ONLY, PROFANITY_MAX_SCORE + 1),\n\tm_memData1(clContext, m_clQueue, CL_MEM_READ_ONLY | CL_MEM_HOST_WRITE_ONLY, 20),\n\tm_memData2(clContext, m_clQueue, CL_MEM_READ_ONLY | CL_MEM_HOST_WRITE_ONLY, 20),\n\tm_clSeed(createSeed()),\n\tm_round(0),\n\tm_speed(PROFANITY_SPEEDSAMPLES),\n\tm_sizeInitialized(0),\n\tm_eventFinished(NULL)\n{\n\n}",
        "target": 0
    },
    {
        "func": "Dispatcher::~Dispatcher() {\n\n}",
        "target": 0
    },
    {
        "func": "void Dispatcher::enqueueKernel(cl_command_queue & clQueue, cl_kernel & clKernel, size_t worksizeGlobal, const size_t worksizeLocal, cl_event * pEvent = NULL) {\n\tconst size_t worksizeMax = m_worksizeMax;\n\tsize_t worksizeOffset = 0;\n\twhile (worksizeGlobal) {\n\t\tconst size_t worksizeRun = std::min(worksizeGlobal, worksizeMax);\n\t\tconst size_t * const pWorksizeLocal = (worksizeLocal == 0 ? NULL : &worksizeLocal);\n\t\tconst auto res = clEnqueueNDRangeKernel(clQueue, clKernel, 1, &worksizeOffset, &worksizeRun, pWorksizeLocal, 0, NULL, pEvent);\n\t\tOpenCLException::throwIfError(\"kernel queueing failed\", res);\n\n\t\tworksizeGlobal -= worksizeRun;\n\t\tworksizeOffset += worksizeRun;\n\t}\n}",
        "target": 0
    },
    {
        "func": "static std::string toHex(const uint8_t * const s, const size_t len) {\n\tstd::string b(\"0123456789abcdef\");\n\tstd::string r;\n\n\tfor (size_t i = 0; i < len; ++i) {\n\t\tconst unsigned char h = s[i] / 16;\n\t\tconst unsigned char l = s[i] % 16;\n\n\t\tr = r + b.substr(h, 1) + b.substr(l, 1);\n\t}\n\n\treturn r;\n}",
        "target": 0
    },
    {
        "func": "cl_kernel Dispatcher::Device::createKernel(cl_program & clProgram, const std::string s) {\n\tcl_kernel ret  = clCreateKernel(clProgram, s.c_str(), NULL);\n\treturn ret == NULL ? throw std::runtime_error(\"failed to create kernel \\\"\" + s + \"\\\"\") : ret;\n}",
        "target": 0
    },
    {
        "func": "void Dispatcher::OpenCLException::OpenCLException::throwIfError(const std::string s, const cl_int res) {\n\tif (res != CL_SUCCESS) {\n\t\tthrow OpenCLException(s, res);\n\t}\n}",
        "target": 0
    },
    {
        "func": "makegamtab(float gam)\n{\n    int i;\n\n    for(i=0; i<256; i++) \n\tgamtab[i] = (unsigned short) (IMAX*pow(i/255.0,gam)+0.5);\n}",
        "target": 0
    },
    {
        "func": "process(register int code, unsigned char** fill)\n{\n    int incode;\n    static unsigned char firstchar;\n\n    if (code == clear) {\n\tcodesize = datasize + 1;\n\tcodemask = (1 << codesize) - 1;\n\tavail = clear + 2;\n\toldcode = -1;\n\treturn 1;\n    }\n\n    if (oldcode == -1) {\n        if (code >= clear) {\n            fprintf(stderr, \"bad input: code=%d is larger than clear=%d\\n\",code, clear);\n            return 0;\n        }\n\t*(*fill)++ = suffix[code];\n\tfirstchar = oldcode = code;\n\treturn 1;\n    }\n    if (code > avail) {\n\tfprintf(stderr, \"code %d too large for %d\\n\", code, avail);\n\treturn 0; \n    }\n\n    incode = code;\n    if (code == avail) {      /* the first code is always < avail */\n\t*stackp++ = firstchar;\n\tcode = oldcode;\n    }\n    while (code > clear) {\n\t*stackp++ = suffix[code];\n\tcode = prefix[code];\n    }\n\n    *stackp++ = firstchar = suffix[code];\n    prefix[avail] = oldcode;\n    suffix[avail] = firstchar;\n    avail++;\n\n    if (((avail & codemask) == 0) && (avail < 4096)) {\n\tcodesize++;\n\tcodemask += avail;\n    }\n    oldcode = incode;\n    do {\n\t*(*fill)++ = *--stackp;\n    } while (stackp > stack);\n    return 1;\n}",
        "target": 0
    },
    {
        "func": "readraster(void)\n{\n    unsigned char *fill = raster;\n    unsigned char buf[255];\n    register int bits=0;\n    register unsigned long datum=0;\n    register unsigned char *ch;\n    register int count, code;\n    int status = 1;\n\n    datasize = getc(infile);\n    if (datasize > 12)\n\treturn 0;\n    clear = 1 << datasize;\n    eoi = clear + 1;\n    avail = clear + 2;\n    oldcode = -1;\n    codesize = datasize + 1;\n    codemask = (1 << codesize) - 1;\n    for (code = 0; code < clear; code++) {\n\tprefix[code] = 0;\n\tsuffix[code] = code;\n    }\n    stackp = stack;\n    for (count = getc(infile); count > 0; count = getc(infile)) {\n\tfread(buf,1,count,infile);\n\tfor (ch=buf; count-- > 0; ch++) {\n\t    datum += (unsigned long) *ch << bits;\n\t    bits += 8;\n\t    while (bits >= codesize) {\n\t\tcode = datum & codemask;\n\t\tdatum >>= codesize;\n\t\tbits -= codesize;\n\t\tif (code == eoi) {               /* This kludge put in */\n\t\t    goto exitloop;               /* because some GIF files*/\n\t\t}                                /* aren't standard */\n\t\tif (!process(code, &fill)) {\n\t\t    status = 0;\n\t\t    goto exitloop;\n\t\t}\n\t    }\n\t}\n\tif (fill >= raster + width*height) {\n\t    fprintf(stderr, \"raster full before eoi code\\n\");\n\t    break;\n\t}\n    }\nexitloop:\n    if (fill != raster + width*height)  {\n\tfprintf(stderr, \"warning: wrong rastersize: %ld bytes\\n\",\n\t\t\t\t\t\t      (long) (fill-raster));\n\tfprintf(stderr, \"         instead of %ld bytes\\n\",\n\t\t\t\t\t\t      (long) width*height);\n    }\n    return status;\n}",
        "target": 0
    },
    {
        "func": "readscreen(void)\n{\n    unsigned char buf[7];\n\n    fread(buf,1,7,infile);\n    global = buf[4] & 0x80;\n    if (global) {\n        globalbits = (buf[4] & 0x07) + 1;\n        fread(globalmap,3,((size_t)1)<<globalbits,infile);\n    }\n}",
        "target": 0
    },
    {
        "func": "initcolors(unsigned char colormap[COLSIZE][3], int ncolors)\n{\n    register int i;\n\n    for (i = 0; i < ncolors; i++) {\n        red[i]   = gamtab[colormap[i][0]];\n        green[i] = gamtab[colormap[i][1]];\n        blue[i]  = gamtab[colormap[i][2]];\n    }\n}",
        "target": 0
    },
    {
        "func": "processCompressOptions(char* opt)\n{\n\tif (streq(opt, \"none\"))\n\t\tcompression = COMPRESSION_NONE;\n\telse if (streq(opt, \"packbits\"))\n\t\tcompression = COMPRESSION_PACKBITS;\n\telse if (strneq(opt, \"lzw\", 3)) {\n\t\tchar* cp = strchr(opt, ':');\n\t\tif (cp)\n\t\t\tpredictor = atoi(cp+1);\n\t\tcompression = COMPRESSION_LZW;\n\t} else if (strneq(opt, \"zip\", 3)) {\n\t\tchar* cp = strchr(opt, ':');\n\t\tif (cp)\n\t\t\tpredictor = atoi(cp+1);\n\t\tcompression = COMPRESSION_DEFLATE;\n\t} else\n\t\treturn (0);\n\treturn (1);\n}",
        "target": 0
    },
    {
        "func": "convert(void)\n{\n    int ch;\n    char* mode = \"w\";\n\n    if (!checksignature())\n        return (-1);\n    readscreen();\n    while ((ch = getc(infile)) != ';' && ch != EOF) {\n        switch (ch) {\n            case '\\0':  break;  /* this kludge for non-standard files */\n            case ',':   if (!readgifimage(mode))\n                           return (-1);\n\t\t\tmode = \"a\";\t\t/* subsequent images append */\n                        break;\n            case '!':   readextension();\n                        break;\n            default:    fprintf(stderr, \"illegal GIF block type\\n\");\n                        return (-1);\n        }\n    }\n    return (0);\n}",
        "target": 0
    },
    {
        "func": "readextension(void)\n{\n    int count;\n    char buf[255];\n\n    (void) getc(infile);\n    while ((count = getc(infile)))\n        fread(buf, 1, count, infile);\n}",
        "target": 0
    },
    {
        "func": "rasterize(int interleaved, char* mode)\n{\n    register unsigned long row;\n    unsigned char *newras;\n    unsigned char *ras;\n    TIFF *tif;\n    tstrip_t strip;\n    tsize_t stripsize;\n\n    if ((newras = (unsigned char*) _TIFFmalloc(width*height+EXTRAFUDGE)) == NULL) {\n        fprintf(stderr, \"not enough memory for image\\n\");\n        return;\n    }\n#define DRAWSEGMENT(offset, step) {\t\t\t\\\n        for (row = offset; row < height; row += step) {\t\\\n            _TIFFmemcpy(newras + row*width, ras, width);\\\n            ras += width;                            \t\\\n        }\t\t\t\t\t\t\\\n    }\n    ras = raster;\n    if (interleaved) {\n        DRAWSEGMENT(0, 8);\n        DRAWSEGMENT(4, 8);\n        DRAWSEGMENT(2, 4);\n        DRAWSEGMENT(1, 2);\n    } else \n        DRAWSEGMENT(0, 1);\n#undef DRAWSEGMENT\n\n    tif = TIFFOpen(imagename, mode);\n    if (!tif) {\n\tTIFFError(imagename,\"Can not open output image\");\n\texit(-1);\n    }\n    TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, (uint32) width);\n    TIFFSetField(tif, TIFFTAG_IMAGELENGTH, (uint32) height);\n    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_PALETTE);\n    TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 1);\n    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8);\n    TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, \n\trowsperstrip = TIFFDefaultStripSize(tif, rowsperstrip));\n    TIFFSetField(tif, TIFFTAG_COMPRESSION, compression);\n    switch (compression) {\n    case COMPRESSION_LZW:\n    case COMPRESSION_DEFLATE:\n\t    if (predictor != 0)\n\t\t    TIFFSetField(tif, TIFFTAG_PREDICTOR, predictor);\n\t    break;\n    }\n    TIFFSetField(tif, TIFFTAG_COLORMAP, red, green, blue);\n    TIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n    strip = 0;\n    stripsize = TIFFStripSize(tif);\n    for (row=0; row<height; row += rowsperstrip) {\n\tif (rowsperstrip > height-row) {\n\t    rowsperstrip = height-row;\n\t    stripsize = TIFFVStripSize(tif, rowsperstrip);\n\t}\n\tif (TIFFWriteEncodedStrip(tif, strip, newras+row*width, stripsize) < 0)\n\t    break;\n\tstrip++;\n    }\n    TIFFClose(tif);\n\n    _TIFFfree(newras);\n}",
        "target": 0
    },
    {
        "func": "main(int argc, char* argv[])\n{\n    extern int optind;\n    extern char *optarg;\n    int c, status;\n\n    while ((c = getopt(argc, argv, \"c:r:\")) != -1)\n\t    switch (c) {\n\t    case 'c':\t\t/* compression scheme */\n\t\t    if (!processCompressOptions(optarg))\n\t\t\t    usage();\n\t\t    break;\n\t    case 'r':\t\t/* rows/strip */\n\t\t    rowsperstrip = atoi(optarg);\n\t\t    break;\n\t    case '?':\n\t\t    usage();\n\t\t    /*NOTREACHED*/\n\t    }\n    if (argc - optind != 2)\n\t    usage();\n\n    makegamtab(GIFGAMMA);\n    filename = argv[optind];\n    imagename = argv[optind+1];\n    if ((infile = fopen(imagename, \"rb\")) != NULL) {\n\tint c;\n\tfclose(infile);\n\tprintf(\"overwrite %s? \", imagename); fflush(stdout);\n\tc = getc(stdin);\n\tif (c != 'y' && c != 'Y')\n\t    return (1);\n    }\n    if ((infile = fopen(filename, \"rb\")) == NULL) {\n\tperror(filename);\n\treturn (1);\n    }\n    status = convert();\n    fclose(infile);\n    return (status);\n}",
        "target": 0
    },
    {
        "func": "checksignature(void)\n{\n    char buf[6];\n\n    fread(buf,1,6,infile);\n    if (strncmp(buf,\"GIF\",3)) {\n        fprintf(stderr, \"file is not a GIF file\\n\");\n        return 0;\n    }\n    if (strncmp(&buf[3],\"87a\",3)) {\n        fprintf(stderr, \"unknown GIF version number\\n\");\n        return 0;\n    }\n    return 1;\n}",
        "target": 0
    },
    {
        "func": "readgifimage(char* mode)\n{\n    unsigned char buf[9];\n    int local, interleaved;\n    unsigned char localmap[256][3];\n    int localbits;\n    int status;\n\n    if (fread(buf, 1, 9, infile) == 0) {\n        perror(filename);\n\treturn (0);\n    }\n    width = buf[4] + (buf[5] << 8);\n    height = buf[6] + (buf[7] << 8);\n    local = buf[8] & 0x80;\n    interleaved = buf[8] & 0x40;\n\n    if (local == 0 && global == 0) {\n        fprintf(stderr, \"no colormap present for image\\n\");\n        return (0);\n    }\n    if ((raster = (unsigned char*) _TIFFmalloc(width*height+EXTRAFUDGE)) == NULL) {\n        fprintf(stderr, \"not enough memory for image\\n\");\n        return (0);\n    }\n    if (local) {\n        localbits = (buf[8] & 0x7) + 1;\n\n        fprintf(stderr, \"   local colors: %d\\n\", 1<<localbits);\n\n        fread(localmap, 3, ((size_t)1)<<localbits, infile);\n        initcolors(localmap, 1<<localbits);\n    } else if (global) {\n        initcolors(globalmap, 1<<globalbits);\n    }\n    if ((status = readraster()))\n\trasterize(interleaved, mode);\n    _TIFFfree(raster);\n    return status;\n}",
        "target": 0
    },
    {
        "func": "  inline void set_stmt_row_injection() {\n    DBUG_ENTER(\"set_stmt_row_injection\");\n    binlog_stmt_flags|= (1U << BINLOG_STMT_TYPE_ROW_INJECTION);\n    DBUG_VOID_RETURN;\n  }",
        "target": 0
    },
    {
        "func": "  bool vers_history_generating() const\n  {\n    switch (sql_command)\n    {\n      case SQLCOM_DELETE:\n        return !vers_conditions.delete_history;\n      case SQLCOM_UPDATE:\n      case SQLCOM_UPDATE_MULTI:\n      case SQLCOM_DELETE_MULTI:\n      case SQLCOM_REPLACE:\n      case SQLCOM_REPLACE_SELECT:\n        return true;\n      case SQLCOM_INSERT:\n      case SQLCOM_INSERT_SELECT:\n        return duplicates == DUP_UPDATE;\n      case SQLCOM_LOAD:\n        return duplicates == DUP_REPLACE;\n      default:\n        return false;\n    }\n  }",
        "target": 0
    },
    {
        "func": "void LEX::relink_hack(st_select_lex *select_lex)\n{\n  if (!select_stack_top) // Statements of the second type\n  {\n    if (!select_lex->outer_select() &&\n        !builtin_select.first_inner_unit())\n    {\n      builtin_select.register_unit(select_lex->master_unit(),\n                                   &builtin_select.context);\n      builtin_select.add_statistics(select_lex->master_unit());\n    }\n  }\n}",
        "target": 0
    },
    {
        "func": "int Lex_input_stream::scan_ident_delimited(THD *thd,\n                                           Lex_ident_cli_st *str,\n                                           uchar quote_char)\n{\n  CHARSET_INFO *const cs= thd->charset();\n  uchar c;\n  DBUG_ASSERT(m_ptr == m_tok_start + 1);\n\n  for ( ; ; )\n  {\n    if (!(c= yyGet()))\n    {\n      /*\n        End-of-query or straight 0x00 inside a delimited identifier.\n        Return the quote character, to have the parser fail on syntax error.\n      */\n      m_ptr= (char *) m_tok_start + 1;\n      if (m_echo)\n        m_cpp_ptr= (char *) m_cpp_tok_start + 1;\n      return quote_char;\n    }\n    int var_length= my_charlen(cs, get_ptr() - 1, get_end_of_query());\n    if (var_length == 1)\n    {\n      if (c == quote_char)\n      {\n        if (yyPeek() != quote_char)\n          break;\n        c= yyGet();\n        continue;\n      }\n    }\n    else if (var_length > 1)\n    {\n      skip_binary(var_length - 1);\n    }\n  }\n\n  str->set_ident_quoted(m_tok_start + 1, yyLength() - 1, true, quote_char);\n  yyUnget();                       // ptr points now after last token char\n\n  m_cpp_text_start= m_cpp_tok_start + 1;\n  m_cpp_text_end= m_cpp_text_start + str->length;\n\n  if (c == quote_char)\n    yySkip();                  // Skip end `\n  next_state= MY_LEX_START;\n  body_utf8_append(m_cpp_text_start);\n  // QQQ: shouldn't it add unescaped version ????\n  body_utf8_append_ident(thd, str, m_cpp_text_end);\n  return IDENT_QUOTED;\n}",
        "target": 0
    },
    {
        "func": "init_lex_with_single_table(THD *thd, TABLE *table, LEX *lex)\n{\n  TABLE_LIST *table_list;\n  Table_ident *table_ident;\n  SELECT_LEX *select_lex= lex->first_select_lex();\n  Name_resolution_context *context= &select_lex->context;\n  /*\n    We will call the parser to create a part_info struct based on the\n    partition string stored in the frm file.\n    We will use a local lex object for this purpose. However we also\n    need to set the Name_resolution_object for this lex object. We\n    do this by using add_table_to_list where we add the table that\n    we're working with to the Name_resolution_context.\n  */\n  thd->lex= lex;\n  lex_start(thd);\n  context->init();\n  if (unlikely((!(table_ident= new Table_ident(thd,\n                                               &table->s->db,\n                                               &table->s->table_name,\n                                               TRUE)))) ||\n      (unlikely(!(table_list= select_lex->add_table_to_list(thd,\n                                                            table_ident,\n                                                            NULL,\n                                                            0)))))\n    return TRUE;\n  context->resolve_in_table_list_only(table_list);\n  lex->use_only_table_context= TRUE;\n  select_lex->cur_pos_in_select_list= UNDEF_POS;\n  table->map= 1; //To ensure correct calculation of const item\n  table_list->table= table;\n  table_list->cacheable_table= false;\n  lex->create_last_non_select_table= table_list;\n  return FALSE;\n}",
        "target": 0
    },
    {
        "func": "  SELECT_LEX *parser_current_outer_select()\n  {\n    return select_stack_top - 1 == select_stack_outer_barrier ?\n             0 : select_stack[select_stack_top - 2];\n  }",
        "target": 0
    },
    {
        "func": "  inline bool is_stmt_row_injection() const {\n    return binlog_stmt_flags & (1U << BINLOG_STMT_TYPE_ROW_INJECTION);\n  }",
        "target": 0
    },
    {
        "func": "bool LEX::maybe_start_compound_statement(THD *thd)\n{\n  if (!sphead)\n  {\n    if (!make_sp_head(thd, NULL, &sp_handler_procedure, DEFAULT_AGGREGATE))\n      return true;\n    sphead->set_suid(SP_IS_NOT_SUID);\n    sphead->set_body_start(thd, thd->m_parser_state->m_lip.get_cpp_tok_start());\n  }\n  return false;\n}",
        "target": 0
    },
    {
        "func": "void SELECT_LEX::update_used_tables()\n{\n  TABLE_LIST *tl;\n  List_iterator<TABLE_LIST> ti(leaf_tables);\n\n  while ((tl= ti++))\n  {\n    if (tl->table && !tl->is_view_or_derived())\n    {\n      TABLE_LIST *embedding= tl->embedding;\n      for (embedding= tl->embedding; embedding; embedding=embedding->embedding)\n      {\n        if (embedding->is_view_or_derived())\n        {\n          DBUG_ASSERT(embedding->is_merged_derived());\n          TABLE *tab= tl->table;\n          tab->covering_keys= tab->s->keys_for_keyread;\n          tab->covering_keys.intersect(tab->keys_in_use_for_query);\n          /*\n            View/derived was merged. Need to recalculate read_set\n            bitmaps here. For example:\n              CREATE VIEW v1 AS SELECT f1,f2,f3 FROM t1;\n              SELECT f1 FROM v1;\n            Initially, the view definition will put all f1,f2,f3 in the\n            read_set for t1. But after the view is merged, only f1 should\n            be in the read_set.\n          */\n          bitmap_clear_all(tab->read_set);\n          break;\n        }\n      }\n    }\n  }\n\n  ti.rewind();\n  while ((tl= ti++))\n  {\n    TABLE_LIST *embedding= tl;\n    if (!is_eliminated_table(join->eliminated_tables, tl))\n    {\n      do\n      {\n        bool maybe_null;\n        if ((maybe_null= MY_TEST(embedding->outer_join)))\n        {\n          tl->table->maybe_null= maybe_null;\n          break;\n        }\n      }\n      while ((embedding= embedding->embedding));\n    }\n\n    if (tl->on_expr && !is_eliminated_table(join->eliminated_tables, tl))\n    {\n      tl->on_expr->update_used_tables();\n      tl->on_expr->walk(&Item::eval_not_null_tables, 0, NULL);\n    }\n    /*\n      - There is no need to check sj_on_expr, because merged semi-joins inject\n        sj_on_expr into the parent's WHERE clase.\n      - For non-merged semi-joins (aka JTBMs), we need to check their\n        left_expr. There is no need to check the rest of the subselect, we know\n        it is uncorrelated and so cannot refer to any tables in this select.\n    */\n    if (tl->jtbm_subselect)\n    {\n      Item *left_expr= tl->jtbm_subselect->left_expr;\n      left_expr->walk(&Item::update_table_bitmaps_processor, FALSE, NULL);\n    }\n\n    embedding= tl->embedding;\n    while (embedding)\n    {\n      if (embedding->on_expr && \n          embedding->nested_join->join_list.head() == tl)\n      {\n        if (!is_eliminated_table(join->eliminated_tables, embedding))\n        {\n          embedding->on_expr->update_used_tables();\n          embedding->on_expr->walk(&Item::eval_not_null_tables, 0, NULL);\n        }\n      }\n      tl= embedding;\n      embedding= tl->embedding;\n    }\n  }\n\n  if (join->conds)\n  {\n    join->conds->update_used_tables();\n    join->conds->walk(&Item::eval_not_null_tables, 0, NULL);\n  }\n  if (join->having)\n  {\n    join->having->update_used_tables();\n  }\n\n  Item *item;\n  List_iterator_fast<Item> it(join->all_fields);\n  select_list_tables= 0;\n  while ((item= it++))\n  {\n    item->update_used_tables();\n    select_list_tables|= item->used_tables();\n  }\n  Item_outer_ref *ref;\n  List_iterator_fast<Item_outer_ref> ref_it(inner_refs_list);\n  while ((ref= ref_it++))\n  {\n    item= ref->outer_ref;\n    item->update_used_tables();\n  }\n  for (ORDER *order= group_list.first; order; order= order->next)\n    (*order->item)->update_used_tables();\n  if (!master_unit()->is_unit_op() ||\n      master_unit()->global_parameters() != this)\n  {\n    for (ORDER *order= order_list.first; order; order= order->next)\n      (*order->item)->update_used_tables();\n  }\n  join->result->update_used_tables();\n}",
        "target": 0
    },
    {
        "func": "static int ssl3_record_app_data_waiting(SSL *s)\n{\n    SSL3_BUFFER *rbuf;\n    int left, len;\n    unsigned char *p;\n\n    rbuf = RECORD_LAYER_get_rbuf(&s->rlayer);\n\n    p = SSL3_BUFFER_get_buf(rbuf);\n    if (p == NULL)\n        return 0;\n\n    left = SSL3_BUFFER_get_left(rbuf);\n\n    if (left < SSL3_RT_HEADER_LENGTH)\n        return 0;\n\n    p += SSL3_BUFFER_get_offset(rbuf);\n\n    /*\n     * We only check the type and record length, we will sanity check version\n     * etc later\n     */\n    if (*p != SSL3_RT_APPLICATION_DATA)\n        return 0;\n\n    p += 3;\n    n2s(p, len);\n\n    if (left < SSL3_RT_HEADER_LENGTH + len)\n        return 0;\n\n    return 1;\n}",
        "target": 0
    },
    {
        "func": "int tls1_set_curves_list(unsigned char **pext, size_t *pextlen, const char *str)\n{\n    nid_cb_st ncb;\n    ncb.nidcnt = 0;\n    if (!CONF_parse_list(str, ':', 1, nid_cb, &ncb))\n        return 0;\n    if (pext == NULL)\n        return 1;\n    return tls1_set_curves(pext, pextlen, ncb.nid_arr, ncb.nidcnt);\n}",
        "target": 0
    },
    {
        "func": "void SSL3_RECORD_clear(SSL3_RECORD *r, unsigned int num_recs)\n{\n    unsigned char *comp;\n    unsigned int i;\n\n    for (i = 0; i < num_recs; i++) {\n        comp = r[i].comp;\n\n        memset(&r[i], 0, sizeof(*r));\n        r[i].comp = comp;\n    }\n}",
        "target": 0
    },
    {
        "func": "void ssl3_cbc_copy_mac(unsigned char *out,\n                       const SSL3_RECORD *rec, unsigned md_size)\n{\n#if defined(CBC_MAC_ROTATE_IN_PLACE)\n    unsigned char rotated_mac_buf[64 + EVP_MAX_MD_SIZE];\n    unsigned char *rotated_mac;\n#else\n    unsigned char rotated_mac[EVP_MAX_MD_SIZE];\n#endif\n\n    /*\n     * mac_end is the index of |rec->data| just after the end of the MAC.\n     */\n    unsigned mac_end = rec->length;\n    unsigned mac_start = mac_end - md_size;\n    unsigned in_mac;\n    /*\n     * scan_start contains the number of bytes that we can ignore because the\n     * MAC's position can only vary by 255 bytes.\n     */\n    unsigned scan_start = 0;\n    unsigned i, j;\n    unsigned rotate_offset;\n\n    OPENSSL_assert(rec->orig_len >= md_size);\n    OPENSSL_assert(md_size <= EVP_MAX_MD_SIZE);\n\n#if defined(CBC_MAC_ROTATE_IN_PLACE)\n    rotated_mac = rotated_mac_buf + ((0 - (size_t)rotated_mac_buf) & 63);\n#endif\n\n    /* This information is public so it's safe to branch based on it. */\n    if (rec->orig_len > md_size + 255 + 1)\n        scan_start = rec->orig_len - (md_size + 255 + 1);\n\n    in_mac = 0;\n    rotate_offset = 0;\n    memset(rotated_mac, 0, md_size);\n    for (i = scan_start, j = 0; i < rec->orig_len; i++) {\n        unsigned mac_started = constant_time_eq(i, mac_start);\n        unsigned mac_ended = constant_time_lt(i, mac_end);\n        unsigned char b = rec->data[i];\n\n        in_mac |= mac_started;\n        in_mac &= mac_ended;\n        rotate_offset |= j & mac_started;\n        rotated_mac[j++] |= b & in_mac;\n        j &= constant_time_lt(j, md_size);\n    }\n\n    /* Now rotate the MAC */\n#if defined(CBC_MAC_ROTATE_IN_PLACE)\n    j = 0;\n    for (i = 0; i < md_size; i++) {\n        /* in case cache-line is 32 bytes, touch second line */\n        ((volatile unsigned char *)rotated_mac)[rotate_offset ^ 32];\n        out[j++] = rotated_mac[rotate_offset++];\n        rotate_offset &= constant_time_lt(rotate_offset, md_size);\n    }\n#else\n    memset(out, 0, md_size);\n    rotate_offset = md_size - rotate_offset;\n    rotate_offset &= constant_time_lt(rotate_offset, md_size);\n    for (i = 0; i < md_size; i++) {\n        for (j = 0; j < md_size; j++)\n            out[j] |= rotated_mac[i] & constant_time_eq_8(j, rotate_offset);\n        rotate_offset++;\n        rotate_offset &= constant_time_lt(rotate_offset, md_size);\n    }\n#endif\n}",
        "target": 0
    },
    {
        "func": "void tls1_free(SSL *s)\n{\n    OPENSSL_free(s->tlsext_session_ticket);\n    ssl3_free(s);\n}",
        "target": 0
    },
    {
        "func": "void ssl_set_sig_mask(uint32_t *pmask_a, SSL *s, int op)\n{\n    const unsigned char *sigalgs;\n    size_t i, sigalgslen;\n    int have_rsa = 0, have_dsa = 0, have_ecdsa = 0;\n    /*\n     * Now go through all signature algorithms seeing if we support any for\n     * RSA, DSA, ECDSA. Do this for all versions not just TLS 1.2. To keep\n     * down calls to security callback only check if we have to.\n     */\n    sigalgslen = tls12_get_psigalgs(s, 1, &sigalgs);\n    for (i = 0; i < sigalgslen; i += 2, sigalgs += 2) {\n        switch (sigalgs[1]) {\n#ifndef OPENSSL_NO_RSA\n        case TLSEXT_signature_rsa:\n            if (!have_rsa && tls12_sigalg_allowed(s, op, sigalgs))\n                have_rsa = 1;\n            break;\n#endif\n#ifndef OPENSSL_NO_DSA\n        case TLSEXT_signature_dsa:\n            if (!have_dsa && tls12_sigalg_allowed(s, op, sigalgs))\n                have_dsa = 1;\n            break;\n#endif\n#ifndef OPENSSL_NO_EC\n        case TLSEXT_signature_ecdsa:\n            if (!have_ecdsa && tls12_sigalg_allowed(s, op, sigalgs))\n                have_ecdsa = 1;\n            break;\n#endif\n        }\n    }\n    if (!have_rsa)\n        *pmask_a |= SSL_aRSA;\n    if (!have_dsa)\n        *pmask_a |= SSL_aDSS;\n    if (!have_ecdsa)\n        *pmask_a |= SSL_aECDSA;\n}",
        "target": 0
    },
    {
        "func": "unsigned char *ssl_add_clienthello_tlsext(SSL *s, unsigned char *buf,\n                                          unsigned char *limit, int *al)\n{\n    int extdatalen = 0;\n    unsigned char *orig = buf;\n    unsigned char *ret = buf;\n#ifndef OPENSSL_NO_EC\n    /* See if we support any ECC ciphersuites */\n    int using_ecc = 0;\n    if (s->version >= TLS1_VERSION || SSL_IS_DTLS(s)) {\n        int i;\n        unsigned long alg_k, alg_a;\n        STACK_OF(SSL_CIPHER) *cipher_stack = SSL_get_ciphers(s);\n\n        for (i = 0; i < sk_SSL_CIPHER_num(cipher_stack); i++) {\n            const SSL_CIPHER *c = sk_SSL_CIPHER_value(cipher_stack, i);\n\n            alg_k = c->algorithm_mkey;\n            alg_a = c->algorithm_auth;\n            if ((alg_k & (SSL_kECDHE | SSL_kECDHEPSK))\n                || (alg_a & SSL_aECDSA)) {\n                using_ecc = 1;\n                break;\n            }\n        }\n    }\n#endif\n\n    ret += 2;\n\n    if (ret >= limit)\n        return NULL;            /* this really never occurs, but ... */\n\n    /* Add RI if renegotiating */\n    if (s->renegotiate) {\n        int el;\n\n        if (!ssl_add_clienthello_renegotiate_ext(s, 0, &el, 0)) {\n            SSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n            return NULL;\n        }\n\n        if (CHECKLEN(ret, 4 + el, limit))\n            return NULL;\n\n        s2n(TLSEXT_TYPE_renegotiate, ret);\n        s2n(el, ret);\n\n        if (!ssl_add_clienthello_renegotiate_ext(s, ret, &el, el)) {\n            SSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n            return NULL;\n        }\n\n        ret += el;\n    }\n    /* Only add RI for SSLv3 */\n    if (s->client_version == SSL3_VERSION)\n        goto done;\n\n    if (s->tlsext_hostname != NULL) {\n        /* Add TLS extension servername to the Client Hello message */\n        size_t size_str;\n\n        /*-\n         * check for enough space.\n         * 4 for the servername type and extension length\n         * 2 for servernamelist length\n         * 1 for the hostname type\n         * 2 for hostname length\n         * + hostname length\n         */\n        size_str = strlen(s->tlsext_hostname);\n        if (CHECKLEN(ret, 9 + size_str, limit))\n            return NULL;\n\n        /* extension type and length */\n        s2n(TLSEXT_TYPE_server_name, ret);\n        s2n(size_str + 5, ret);\n\n        /* length of servername list */\n        s2n(size_str + 3, ret);\n\n        /* hostname type, length and hostname */\n        *(ret++) = (unsigned char)TLSEXT_NAMETYPE_host_name;\n        s2n(size_str, ret);\n        memcpy(ret, s->tlsext_hostname, size_str);\n        ret += size_str;\n    }\n#ifndef OPENSSL_NO_SRP\n    /* Add SRP username if there is one */\n    if (s->srp_ctx.login != NULL) { /* Add TLS extension SRP username to the\n                                     * Client Hello message */\n\n        size_t login_len = strlen(s->srp_ctx.login);\n        if (login_len > 255 || login_len == 0) {\n            SSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n            return NULL;\n        }\n\n        /*-\n         * check for enough space.\n         * 4 for the srp type type and extension length\n         * 1 for the srp user identity\n         * + srp user identity length\n         */\n        if (CHECKLEN(ret, 5 + login_len, limit))\n            return NULL;\n\n        /* fill in the extension */\n        s2n(TLSEXT_TYPE_srp, ret);\n        s2n(login_len + 1, ret);\n        (*ret++) = (unsigned char)login_len;\n        memcpy(ret, s->srp_ctx.login, login_len);\n        ret += login_len;\n    }\n#endif\n\n#ifndef OPENSSL_NO_EC\n    if (using_ecc) {\n        /*\n         * Add TLS extension ECPointFormats to the ClientHello message\n         */\n        const unsigned char *pcurves, *pformats;\n        size_t num_curves, num_formats, curves_list_len;\n        size_t i;\n        unsigned char *etmp;\n\n        tls1_get_formatlist(s, &pformats, &num_formats);\n\n        if (num_formats > 255) {\n            SSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n            return NULL;\n        }\n        /*-\n         * check for enough space.\n         * 4 bytes for the ec point formats type and extension length\n         * 1 byte for the length of the formats\n         * + formats length\n         */\n        if (CHECKLEN(ret, 5 + num_formats, limit))\n            return NULL;\n\n        s2n(TLSEXT_TYPE_ec_point_formats, ret);\n        /* The point format list has 1-byte length. */\n        s2n(num_formats + 1, ret);\n        *(ret++) = (unsigned char)num_formats;\n        memcpy(ret, pformats, num_formats);\n        ret += num_formats;\n\n        /*\n         * Add TLS extension EllipticCurves to the ClientHello message\n         */\n        pcurves = s->tlsext_ellipticcurvelist;\n        if (!tls1_get_curvelist(s, 0, &pcurves, &num_curves))\n            return NULL;\n\n        if (num_curves > 65532 / 2) {\n            SSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n            return NULL;\n        }\n        /*-\n         * check for enough space.\n         * 4 bytes for the ec curves type and extension length\n         * 2 bytes for the curve list length\n         * + curve list length\n         */\n        if (CHECKLEN(ret, 6 + (num_curves * 2), limit))\n            return NULL;\n\n        s2n(TLSEXT_TYPE_elliptic_curves, ret);\n        etmp = ret + 4;\n        /* Copy curve ID if supported */\n        for (i = 0; i < num_curves; i++, pcurves += 2) {\n            if (tls_curve_allowed(s, pcurves, SSL_SECOP_CURVE_SUPPORTED)) {\n                *etmp++ = pcurves[0];\n                *etmp++ = pcurves[1];\n            }\n        }\n\n        curves_list_len = etmp - ret - 4;\n\n        s2n(curves_list_len + 2, ret);\n        s2n(curves_list_len, ret);\n        ret += curves_list_len;\n    }\n#endif                          /* OPENSSL_NO_EC */\n\n    if (tls_use_ticket(s)) {\n        size_t ticklen;\n        if (!s->new_session && s->session && s->session->tlsext_tick)\n            ticklen = s->session->tlsext_ticklen;\n        else if (s->session && s->tlsext_session_ticket &&\n                 s->tlsext_session_ticket->data) {\n            ticklen = s->tlsext_session_ticket->length;\n            s->session->tlsext_tick = OPENSSL_malloc(ticklen);\n            if (s->session->tlsext_tick == NULL)\n                return NULL;\n            memcpy(s->session->tlsext_tick,\n                   s->tlsext_session_ticket->data, ticklen);\n            s->session->tlsext_ticklen = ticklen;\n        } else\n            ticklen = 0;\n        if (ticklen == 0 && s->tlsext_session_ticket &&\n            s->tlsext_session_ticket->data == NULL)\n            goto skip_ext;\n        /*\n         * Check for enough room 2 for extension type, 2 for len rest for\n         * ticket\n         */\n        if (CHECKLEN(ret, 4 + ticklen, limit))\n            return NULL;\n        s2n(TLSEXT_TYPE_session_ticket, ret);\n        s2n(ticklen, ret);\n        if (ticklen > 0) {\n            memcpy(ret, s->session->tlsext_tick, ticklen);\n            ret += ticklen;\n        }\n    }\n skip_ext:\n\n    if (SSL_CLIENT_USE_SIGALGS(s)) {\n        size_t salglen;\n        const unsigned char *salg;\n        unsigned char *etmp;\n        salglen = tls12_get_psigalgs(s, 1, &salg);\n\n        /*-\n         * check for enough space.\n         * 4 bytes for the sigalgs type and extension length\n         * 2 bytes for the sigalg list length\n         * + sigalg list length\n         */\n        if (CHECKLEN(ret, salglen + 6, limit))\n            return NULL;\n        s2n(TLSEXT_TYPE_signature_algorithms, ret);\n        etmp = ret;\n        /* Skip over lengths for now */\n        ret += 4;\n        salglen = tls12_copy_sigalgs(s, ret, salg, salglen);\n        /* Fill in lengths */\n        s2n(salglen + 2, etmp);\n        s2n(salglen, etmp);\n        ret += salglen;\n    }\n#ifndef OPENSSL_NO_OCSP\n    if (s->tlsext_status_type == TLSEXT_STATUSTYPE_ocsp) {\n        int i;\n        size_t extlen, idlen;\n        int lentmp;\n        OCSP_RESPID *id;\n\n        idlen = 0;\n        for (i = 0; i < sk_OCSP_RESPID_num(s->tlsext_ocsp_ids); i++) {\n            id = sk_OCSP_RESPID_value(s->tlsext_ocsp_ids, i);\n            lentmp = i2d_OCSP_RESPID(id, NULL);\n            if (lentmp <= 0)\n                return NULL;\n            idlen += (size_t)lentmp + 2;\n        }\n\n        if (s->tlsext_ocsp_exts) {\n            lentmp = i2d_X509_EXTENSIONS(s->tlsext_ocsp_exts, NULL);\n            if (lentmp < 0)\n                return NULL;\n            extlen = (size_t)lentmp;\n        } else\n            extlen = 0;\n\n        if (extlen + idlen > 0xFFF0)\n            return NULL;\n        /*\n         * 2 bytes for status request type\n         * 2 bytes for status request len\n         * 1 byte for OCSP request type\n         * 2 bytes for length of ids\n         * 2 bytes for length of extensions\n         * + length of ids\n         * + length of extensions\n         */\n        if (CHECKLEN(ret, 9 + idlen + extlen, limit))\n            return NULL;\n\n        s2n(TLSEXT_TYPE_status_request, ret);\n        s2n(extlen + idlen + 5, ret);\n        *(ret++) = TLSEXT_STATUSTYPE_ocsp;\n        s2n(idlen, ret);\n        for (i = 0; i < sk_OCSP_RESPID_num(s->tlsext_ocsp_ids); i++) {\n            /* save position of id len */\n            unsigned char *q = ret;\n            id = sk_OCSP_RESPID_value(s->tlsext_ocsp_ids, i);\n            /* skip over id len */\n            ret += 2;\n            lentmp = i2d_OCSP_RESPID(id, &ret);\n            /* write id len */\n            s2n(lentmp, q);\n        }\n        s2n(extlen, ret);\n        if (extlen > 0)\n            i2d_X509_EXTENSIONS(s->tlsext_ocsp_exts, &ret);\n    }\n#endif\n#ifndef OPENSSL_NO_HEARTBEATS\n    if (SSL_IS_DTLS(s)) {\n        /* Add Heartbeat extension */\n\n        /*-\n         * check for enough space.\n         * 4 bytes for the heartbeat ext type and extension length\n         * 1 byte for the mode\n         */\n        if (CHECKLEN(ret, 5, limit))\n            return NULL;\n\n        s2n(TLSEXT_TYPE_heartbeat, ret);\n        s2n(1, ret);\n        /*-\n         * Set mode:\n         * 1: peer may send requests\n         * 2: peer not allowed to send requests\n         */\n        if (s->tlsext_heartbeat & SSL_DTLSEXT_HB_DONT_RECV_REQUESTS)\n            *(ret++) = SSL_DTLSEXT_HB_DONT_SEND_REQUESTS;\n        else\n            *(ret++) = SSL_DTLSEXT_HB_ENABLED;\n    }\n#endif\n\n#ifndef OPENSSL_NO_NEXTPROTONEG\n    if (s->ctx->next_proto_select_cb && !s->s3->tmp.finish_md_len) {\n        /*\n         * The client advertises an empty extension to indicate its support\n         * for Next Protocol Negotiation\n         */\n\n        /*-\n         * check for enough space.\n         * 4 bytes for the NPN ext type and extension length\n         */\n        if (CHECKLEN(ret, 4, limit))\n            return NULL;\n        s2n(TLSEXT_TYPE_next_proto_neg, ret);\n        s2n(0, ret);\n    }\n#endif\n\n    /*\n     * finish_md_len is non-zero during a renegotiation, so\n     * this avoids sending ALPN during the renegotiation\n     * (see longer comment below)\n     */\n    if (s->alpn_client_proto_list && !s->s3->tmp.finish_md_len) {\n        /*-\n         * check for enough space.\n         * 4 bytes for the ALPN type and extension length\n         * 2 bytes for the ALPN protocol list length\n         * + ALPN protocol list length\n         */\n        if (CHECKLEN(ret, 6 + s->alpn_client_proto_list_len, limit))\n            return NULL;\n        s2n(TLSEXT_TYPE_application_layer_protocol_negotiation, ret);\n        s2n(2 + s->alpn_client_proto_list_len, ret);\n        s2n(s->alpn_client_proto_list_len, ret);\n        memcpy(ret, s->alpn_client_proto_list, s->alpn_client_proto_list_len);\n        ret += s->alpn_client_proto_list_len;\n        s->s3->alpn_sent = 1;\n    }\n#ifndef OPENSSL_NO_SRTP\n    if (SSL_IS_DTLS(s) && SSL_get_srtp_profiles(s)) {\n        int el;\n\n        /* Returns 0 on success!! */\n        if (ssl_add_clienthello_use_srtp_ext(s, 0, &el, 0)) {\n            SSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n            return NULL;\n        }\n\n        /*-\n         * check for enough space.\n         * 4 bytes for the SRTP type and extension length\n         * + SRTP profiles length\n         */\n        if (CHECKLEN(ret, 4 + el, limit))\n            return NULL;\n\n        s2n(TLSEXT_TYPE_use_srtp, ret);\n        s2n(el, ret);\n\n        if (ssl_add_clienthello_use_srtp_ext(s, ret, &el, el)) {\n            SSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n            return NULL;\n        }\n        ret += el;\n    }\n#endif\n    custom_ext_init(&s->cert->cli_ext);\n    /* Add custom TLS Extensions to ClientHello */\n    if (!custom_ext_add(s, 0, &ret, limit, al))\n        return NULL;\n    /*\n     * In 1.1.0 before 1.1.0c we negotiated EtM with DTLS, then just\n     * silently failed to actually do it. It is fixed in 1.1.1 but to\n     * ease the transition especially from 1.1.0b to 1.1.0c, we just\n     * disable it in 1.1.0.\n     */\n    if (!SSL_IS_DTLS(s)) {\n        /*-\n         * check for enough space.\n         * 4 bytes for the ETM type and extension length\n         */\n        if (CHECKLEN(ret, 4, limit))\n            return NULL;\n        s2n(TLSEXT_TYPE_encrypt_then_mac, ret);\n        s2n(0, ret);\n    }\n\n#ifndef OPENSSL_NO_CT\n    if (s->ct_validation_callback != NULL) {\n        /*-\n         * check for enough space.\n         * 4 bytes for the SCT type and extension length\n         */\n        if (CHECKLEN(ret, 4, limit))\n            return NULL;\n\n        s2n(TLSEXT_TYPE_signed_certificate_timestamp, ret);\n        s2n(0, ret);\n    }\n#endif\n\n    /*-\n     * check for enough space.\n     * 4 bytes for the EMS type and extension length\n     */\n    if (CHECKLEN(ret, 4, limit))\n        return NULL;\n    s2n(TLSEXT_TYPE_extended_master_secret, ret);\n    s2n(0, ret);\n\n    /*\n     * Add padding to workaround bugs in F5 terminators. See\n     * https://tools.ietf.org/html/draft-agl-tls-padding-03 NB: because this\n     * code works out the length of all existing extensions it MUST always\n     * appear last.\n     */\n    if (s->options & SSL_OP_TLSEXT_PADDING) {\n        int hlen = ret - (unsigned char *)s->init_buf->data;\n\n        if (hlen > 0xff && hlen < 0x200) {\n            hlen = 0x200 - hlen;\n            if (hlen >= 4)\n                hlen -= 4;\n            else\n                hlen = 0;\n\n            /*-\n             * check for enough space. Strictly speaking we know we've already\n             * got enough space because to get here the message size is < 0x200,\n             * but we know that we've allocated far more than that in the buffer\n             * - but for consistency and robustness we're going to check anyway.\n             *\n             * 4 bytes for the padding type and extension length\n             * + padding length\n             */\n            if (CHECKLEN(ret, 4 + hlen, limit))\n                return NULL;\n            s2n(TLSEXT_TYPE_padding, ret);\n            s2n(hlen, ret);\n            memset(ret, 0, hlen);\n            ret += hlen;\n        }\n    }\n\n done:\n\n    if ((extdatalen = ret - orig - 2) == 0)\n        return orig;\n\n    s2n(extdatalen, orig);\n    return ret;\n}",
        "target": 0
    },
    {
        "func": "int tls1_cbc_remove_padding(const SSL *s,\n                            SSL3_RECORD *rec,\n                            unsigned block_size, unsigned mac_size)\n{\n    unsigned padding_length, good, to_check, i;\n    const unsigned overhead = 1 /* padding length byte */  + mac_size;\n    /* Check if version requires explicit IV */\n    if (SSL_USE_EXPLICIT_IV(s)) {\n        /*\n         * These lengths are all public so we can test them in non-constant\n         * time.\n         */\n        if (overhead + block_size > rec->length)\n            return 0;\n        /* We can now safely skip explicit IV */\n        rec->data += block_size;\n        rec->input += block_size;\n        rec->length -= block_size;\n        rec->orig_len -= block_size;\n    } else if (overhead > rec->length)\n        return 0;\n\n    padding_length = rec->data[rec->length - 1];\n\n    if (EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(s->enc_read_ctx)) &\n        EVP_CIPH_FLAG_AEAD_CIPHER) {\n        /* padding is already verified */\n        rec->length -= padding_length + 1;\n        return 1;\n    }\n\n    good = constant_time_ge(rec->length, overhead + padding_length);\n    /*\n     * The padding consists of a length byte at the end of the record and\n     * then that many bytes of padding, all with the same value as the length\n     * byte. Thus, with the length byte included, there are i+1 bytes of\n     * padding. We can't check just |padding_length+1| bytes because that\n     * leaks decrypted information. Therefore we always have to check the\n     * maximum amount of padding possible. (Again, the length of the record\n     * is public information so we can use it.)\n     */\n    to_check = 256;            /* maximum amount of padding, inc length byte. */\n    if (to_check > rec->length)\n        to_check = rec->length;\n\n    for (i = 0; i < to_check; i++) {\n        unsigned char mask = constant_time_ge_8(padding_length, i);\n        unsigned char b = rec->data[rec->length - 1 - i];\n        /*\n         * The final |padding_length+1| bytes should all have the value\n         * |padding_length|. Therefore the XOR should be zero.\n         */\n        good &= ~(mask & (padding_length ^ b));\n    }\n\n    /*\n     * If any of the final |padding_length+1| bytes had the wrong value, one\n     * or more of the lower eight bits of |good| will be cleared.\n     */\n    good = constant_time_eq(0xff, good & 0xff);\n    rec->length -= good & (padding_length + 1);\n\n    return constant_time_select_int(good, 1, -1);\n}",
        "target": 0
    },
    {
        "func": "int tls1_generate_master_secret(SSL *s, unsigned char *out, unsigned char *p,\n                                int len)\n{\n    if (s->session->flags & SSL_SESS_FLAG_EXTMS) {\n        unsigned char hash[EVP_MAX_MD_SIZE * 2];\n        int hashlen;\n        /*\n         * Digest cached records keeping record buffer (if present): this wont\n         * affect client auth because we're freezing the buffer at the same\n         * point (after client key exchange and before certificate verify)\n         */\n        if (!ssl3_digest_cached_records(s, 1))\n            return -1;\n        hashlen = ssl_handshake_hash(s, hash, sizeof(hash));\n#ifdef SSL_DEBUG\n        fprintf(stderr, \"Handshake hashes:\\n\");\n        BIO_dump_fp(stderr, (char *)hash, hashlen);\n#endif\n        tls1_PRF(s,\n                 TLS_MD_EXTENDED_MASTER_SECRET_CONST,\n                 TLS_MD_EXTENDED_MASTER_SECRET_CONST_SIZE,\n                 hash, hashlen,\n                 NULL, 0,\n                 NULL, 0,\n                 NULL, 0, p, len, s->session->master_key,\n                 SSL3_MASTER_SECRET_SIZE);\n        OPENSSL_cleanse(hash, hashlen);\n    } else {\n        tls1_PRF(s,\n                 TLS_MD_MASTER_SECRET_CONST,\n                 TLS_MD_MASTER_SECRET_CONST_SIZE,\n                 s->s3->client_random, SSL3_RANDOM_SIZE,\n                 NULL, 0,\n                 s->s3->server_random, SSL3_RANDOM_SIZE,\n                 NULL, 0, p, len, s->session->master_key,\n                 SSL3_MASTER_SECRET_SIZE);\n    }\n#ifdef SSL_DEBUG\n    fprintf(stderr, \"Premaster Secret:\\n\");\n    BIO_dump_fp(stderr, (char *)p, len);\n    fprintf(stderr, \"Client Random:\\n\");\n    BIO_dump_fp(stderr, (char *)s->s3->client_random, SSL3_RANDOM_SIZE);\n    fprintf(stderr, \"Server Random:\\n\");\n    BIO_dump_fp(stderr, (char *)s->s3->server_random, SSL3_RANDOM_SIZE);\n    fprintf(stderr, \"Master Secret:\\n\");\n    BIO_dump_fp(stderr, (char *)s->session->master_key,\n                SSL3_MASTER_SECRET_SIZE);\n#endif\n\n#ifdef OPENSSL_SSL_TRACE_CRYPTO\n    if (s->msg_callback) {\n        s->msg_callback(2, s->version, TLS1_RT_CRYPTO_PREMASTER,\n                        p, len, s, s->msg_callback_arg);\n        s->msg_callback(2, s->version, TLS1_RT_CRYPTO_CLIENT_RANDOM,\n                        s->s3->client_random, SSL3_RANDOM_SIZE,\n                        s, s->msg_callback_arg);\n        s->msg_callback(2, s->version, TLS1_RT_CRYPTO_SERVER_RANDOM,\n                        s->s3->server_random, SSL3_RANDOM_SIZE,\n                        s, s->msg_callback_arg);\n        s->msg_callback(2, s->version, TLS1_RT_CRYPTO_MASTER,\n                        s->session->master_key,\n                        SSL3_MASTER_SECRET_SIZE, s, s->msg_callback_arg);\n    }\n#endif\n\n    return (SSL3_MASTER_SECRET_SIZE);\n}",
        "target": 0
    },
    {
        "func": "static int ssl_scan_serverhello_tlsext(SSL *s, PACKET *pkt, int *al)\n{\n    unsigned int length, type, size;\n    int tlsext_servername = 0;\n    int renegotiate_seen = 0;\n\n#ifndef OPENSSL_NO_NEXTPROTONEG\n    s->s3->next_proto_neg_seen = 0;\n#endif\n    s->tlsext_ticket_expected = 0;\n\n    OPENSSL_free(s->s3->alpn_selected);\n    s->s3->alpn_selected = NULL;\n#ifndef OPENSSL_NO_HEARTBEATS\n    s->tlsext_heartbeat &= ~(SSL_DTLSEXT_HB_ENABLED |\n                             SSL_DTLSEXT_HB_DONT_SEND_REQUESTS);\n#endif\n\n    s->tlsext_use_etm = 0;\n\n    s->s3->flags &= ~TLS1_FLAGS_RECEIVED_EXTMS;\n\n    if (!PACKET_get_net_2(pkt, &length))\n        goto ri_check;\n\n    if (PACKET_remaining(pkt) != length) {\n        *al = SSL_AD_DECODE_ERROR;\n        return 0;\n    }\n\n    if (!tls1_check_duplicate_extensions(pkt)) {\n        *al = SSL_AD_DECODE_ERROR;\n        return 0;\n    }\n\n    while (PACKET_get_net_2(pkt, &type) && PACKET_get_net_2(pkt, &size)) {\n        const unsigned char *data;\n        PACKET spkt;\n\n        if (!PACKET_get_sub_packet(pkt, &spkt, size)\n            || !PACKET_peek_bytes(&spkt, &data, size))\n            goto ri_check;\n\n        if (s->tlsext_debug_cb)\n            s->tlsext_debug_cb(s, 1, type, data, size, s->tlsext_debug_arg);\n\n        if (type == TLSEXT_TYPE_renegotiate) {\n            if (!ssl_parse_serverhello_renegotiate_ext(s, &spkt, al))\n                return 0;\n            renegotiate_seen = 1;\n        } else if (s->version == SSL3_VERSION) {\n        } else if (type == TLSEXT_TYPE_server_name) {\n            if (s->tlsext_hostname == NULL || size > 0) {\n                *al = TLS1_AD_UNRECOGNIZED_NAME;\n                return 0;\n            }\n            tlsext_servername = 1;\n        }\n#ifndef OPENSSL_NO_EC\n        else if (type == TLSEXT_TYPE_ec_point_formats) {\n            unsigned int ecpointformatlist_length;\n            if (!PACKET_get_1(&spkt, &ecpointformatlist_length)\n                || ecpointformatlist_length != size - 1) {\n                *al = TLS1_AD_DECODE_ERROR;\n                return 0;\n            }\n            if (!s->hit) {\n                s->session->tlsext_ecpointformatlist_length = 0;\n                OPENSSL_free(s->session->tlsext_ecpointformatlist);\n                if ((s->session->tlsext_ecpointformatlist =\n                     OPENSSL_malloc(ecpointformatlist_length)) == NULL) {\n                    *al = TLS1_AD_INTERNAL_ERROR;\n                    return 0;\n                }\n                s->session->tlsext_ecpointformatlist_length =\n                    ecpointformatlist_length;\n                if (!PACKET_copy_bytes(&spkt,\n                                       s->session->tlsext_ecpointformatlist,\n                                       ecpointformatlist_length)) {\n                    *al = TLS1_AD_DECODE_ERROR;\n                    return 0;\n                }\n\n            }\n        }\n#endif                          /* OPENSSL_NO_EC */\n\n        else if (type == TLSEXT_TYPE_session_ticket) {\n            if (s->tls_session_ticket_ext_cb &&\n                !s->tls_session_ticket_ext_cb(s, data, size,\n                                              s->tls_session_ticket_ext_cb_arg))\n            {\n                *al = TLS1_AD_INTERNAL_ERROR;\n                return 0;\n            }\n            if (!tls_use_ticket(s) || (size > 0)) {\n                *al = TLS1_AD_UNSUPPORTED_EXTENSION;\n                return 0;\n            }\n            s->tlsext_ticket_expected = 1;\n        } else if (type == TLSEXT_TYPE_status_request) {\n            /*\n             * MUST be empty and only sent if we've requested a status\n             * request message.\n             */\n            if ((s->tlsext_status_type == -1) || (size > 0)) {\n                *al = TLS1_AD_UNSUPPORTED_EXTENSION;\n                return 0;\n            }\n            /* Set flag to expect CertificateStatus message */\n            s->tlsext_status_expected = 1;\n        }\n#ifndef OPENSSL_NO_CT\n        /*\n         * Only take it if we asked for it - i.e if there is no CT validation\n         * callback set, then a custom extension MAY be processing it, so we\n         * need to let control continue to flow to that.\n         */\n        else if (type == TLSEXT_TYPE_signed_certificate_timestamp &&\n                 s->ct_validation_callback != NULL) {\n            /* Simply copy it off for later processing */\n            if (s->tlsext_scts != NULL) {\n                OPENSSL_free(s->tlsext_scts);\n                s->tlsext_scts = NULL;\n            }\n            s->tlsext_scts_len = size;\n            if (size > 0) {\n                s->tlsext_scts = OPENSSL_malloc(size);\n                if (s->tlsext_scts == NULL) {\n                    *al = TLS1_AD_INTERNAL_ERROR;\n                    return 0;\n                }\n                memcpy(s->tlsext_scts, data, size);\n            }\n        }\n#endif\n#ifndef OPENSSL_NO_NEXTPROTONEG\n        else if (type == TLSEXT_TYPE_next_proto_neg &&\n                 s->s3->tmp.finish_md_len == 0) {\n            unsigned char *selected;\n            unsigned char selected_len;\n            /* We must have requested it. */\n            if (s->ctx->next_proto_select_cb == NULL) {\n                *al = TLS1_AD_UNSUPPORTED_EXTENSION;\n                return 0;\n            }\n            /* The data must be valid */\n            if (!ssl_next_proto_validate(&spkt)) {\n                *al = TLS1_AD_DECODE_ERROR;\n                return 0;\n            }\n            if (s->ctx->next_proto_select_cb(s, &selected, &selected_len, data,\n                                             size,\n                                             s->\n                                             ctx->next_proto_select_cb_arg) !=\n                SSL_TLSEXT_ERR_OK) {\n                *al = TLS1_AD_INTERNAL_ERROR;\n                return 0;\n            }\n            /*\n             * Could be non-NULL if server has sent multiple NPN extensions in\n             * a single Serverhello\n             */\n            OPENSSL_free(s->next_proto_negotiated);\n            s->next_proto_negotiated = OPENSSL_malloc(selected_len);\n            if (s->next_proto_negotiated == NULL) {\n                *al = TLS1_AD_INTERNAL_ERROR;\n                return 0;\n            }\n            memcpy(s->next_proto_negotiated, selected, selected_len);\n            s->next_proto_negotiated_len = selected_len;\n            s->s3->next_proto_neg_seen = 1;\n        }\n#endif\n\n        else if (type == TLSEXT_TYPE_application_layer_protocol_negotiation) {\n            unsigned len;\n            /* We must have requested it. */\n            if (!s->s3->alpn_sent) {\n                *al = TLS1_AD_UNSUPPORTED_EXTENSION;\n                return 0;\n            }\n            /*-\n             * The extension data consists of:\n             *   uint16 list_length\n             *   uint8 proto_length;\n             *   uint8 proto[proto_length];\n             */\n            if (!PACKET_get_net_2(&spkt, &len)\n                || PACKET_remaining(&spkt) != len || !PACKET_get_1(&spkt, &len)\n                || PACKET_remaining(&spkt) != len) {\n                *al = TLS1_AD_DECODE_ERROR;\n                return 0;\n            }\n            OPENSSL_free(s->s3->alpn_selected);\n            s->s3->alpn_selected = OPENSSL_malloc(len);\n            if (s->s3->alpn_selected == NULL) {\n                *al = TLS1_AD_INTERNAL_ERROR;\n                return 0;\n            }\n            if (!PACKET_copy_bytes(&spkt, s->s3->alpn_selected, len)) {\n                *al = TLS1_AD_DECODE_ERROR;\n                return 0;\n            }\n            s->s3->alpn_selected_len = len;\n        }\n#ifndef OPENSSL_NO_HEARTBEATS\n        else if (SSL_IS_DTLS(s) && type == TLSEXT_TYPE_heartbeat) {\n            unsigned int hbtype;\n            if (!PACKET_get_1(&spkt, &hbtype)) {\n                *al = SSL_AD_DECODE_ERROR;\n                return 0;\n            }\n            switch (hbtype) {\n            case 0x01:         /* Server allows us to send HB requests */\n                s->tlsext_heartbeat |= SSL_DTLSEXT_HB_ENABLED;\n                break;\n            case 0x02:         /* Server doesn't accept HB requests */\n                s->tlsext_heartbeat |= SSL_DTLSEXT_HB_ENABLED;\n                s->tlsext_heartbeat |= SSL_DTLSEXT_HB_DONT_SEND_REQUESTS;\n                break;\n            default:\n                *al = SSL_AD_ILLEGAL_PARAMETER;\n                return 0;\n            }\n        }\n#endif\n#ifndef OPENSSL_NO_SRTP\n        else if (SSL_IS_DTLS(s) && type == TLSEXT_TYPE_use_srtp) {\n            if (ssl_parse_serverhello_use_srtp_ext(s, &spkt, al))\n                return 0;\n        }\n#endif\n        else if (type == TLSEXT_TYPE_encrypt_then_mac) {\n            /* Ignore if inappropriate ciphersuite */\n            if (s->s3->tmp.new_cipher->algorithm_mac != SSL_AEAD\n                && s->s3->tmp.new_cipher->algorithm_enc != SSL_RC4)\n                s->tlsext_use_etm = 1;\n        } else if (type == TLSEXT_TYPE_extended_master_secret) {\n            s->s3->flags |= TLS1_FLAGS_RECEIVED_EXTMS;\n            if (!s->hit)\n                s->session->flags |= SSL_SESS_FLAG_EXTMS;\n        }\n        /*\n         * If this extension type was not otherwise handled, but matches a\n         * custom_cli_ext_record, then send it to the c callback\n         */\n        else if (custom_ext_parse(s, 0, type, data, size, al) <= 0)\n            return 0;\n    }\n\n    if (PACKET_remaining(pkt) != 0) {\n        *al = SSL_AD_DECODE_ERROR;\n        return 0;\n    }\n\n    if (!s->hit && tlsext_servername == 1) {\n        if (s->tlsext_hostname) {\n            if (s->session->tlsext_hostname == NULL) {\n                s->session->tlsext_hostname =\n                    OPENSSL_strdup(s->tlsext_hostname);\n                if (!s->session->tlsext_hostname) {\n                    *al = SSL_AD_UNRECOGNIZED_NAME;\n                    return 0;\n                }\n            } else {\n                *al = SSL_AD_DECODE_ERROR;\n                return 0;\n            }\n        }\n    }\n\n ri_check:\n\n    /*\n     * Determine if we need to see RI. Strictly speaking if we want to avoid\n     * an attack we should *always* see RI even on initial server hello\n     * because the client doesn't see any renegotiation during an attack.\n     * However this would mean we could not connect to any server which\n     * doesn't support RI so for the immediate future tolerate RI absence\n     */\n    if (!renegotiate_seen && !(s->options & SSL_OP_LEGACY_SERVER_CONNECT)\n        && !(s->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION)) {\n        *al = SSL_AD_HANDSHAKE_FAILURE;\n        SSLerr(SSL_F_SSL_SCAN_SERVERHELLO_TLSEXT,\n               SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED);\n        return 0;\n    }\n\n    if (s->hit) {\n        /*\n         * Check extended master secret extension is consistent with\n         * original session.\n         */\n        if (!(s->s3->flags & TLS1_FLAGS_RECEIVED_EXTMS) !=\n            !(s->session->flags & SSL_SESS_FLAG_EXTMS)) {\n            *al = SSL_AD_HANDSHAKE_FAILURE;\n            SSLerr(SSL_F_SSL_SCAN_SERVERHELLO_TLSEXT, SSL_R_INCONSISTENT_EXTMS);\n            return 0;\n        }\n    }\n\n    return 1;\n}",
        "target": 0
    },
    {
        "func": "int tls1_mac(SSL *ssl, SSL3_RECORD *rec, unsigned char *md, int send)\n{\n    unsigned char *seq;\n    EVP_MD_CTX *hash;\n    size_t md_size;\n    int i;\n    EVP_MD_CTX *hmac = NULL, *mac_ctx;\n    unsigned char header[13];\n    int stream_mac = (send ? (ssl->mac_flags & SSL_MAC_FLAG_WRITE_MAC_STREAM)\n                      : (ssl->mac_flags & SSL_MAC_FLAG_READ_MAC_STREAM));\n    int t;\n\n    if (send) {\n        seq = RECORD_LAYER_get_write_sequence(&ssl->rlayer);\n        hash = ssl->write_hash;\n    } else {\n        seq = RECORD_LAYER_get_read_sequence(&ssl->rlayer);\n        hash = ssl->read_hash;\n    }\n\n    t = EVP_MD_CTX_size(hash);\n    OPENSSL_assert(t >= 0);\n    md_size = t;\n\n    /* I should fix this up TLS TLS TLS TLS TLS XXXXXXXX */\n    if (stream_mac) {\n        mac_ctx = hash;\n    } else {\n        hmac = EVP_MD_CTX_new();\n        if (hmac == NULL || !EVP_MD_CTX_copy(hmac, hash))\n            return -1;\n        mac_ctx = hmac;\n    }\n\n    if (SSL_IS_DTLS(ssl)) {\n        unsigned char dtlsseq[8], *p = dtlsseq;\n\n        s2n(send ? DTLS_RECORD_LAYER_get_w_epoch(&ssl->rlayer) :\n            DTLS_RECORD_LAYER_get_r_epoch(&ssl->rlayer), p);\n        memcpy(p, &seq[2], 6);\n\n        memcpy(header, dtlsseq, 8);\n    } else\n        memcpy(header, seq, 8);\n\n    header[8] = rec->type;\n    header[9] = (unsigned char)(ssl->version >> 8);\n    header[10] = (unsigned char)(ssl->version);\n    header[11] = (rec->length) >> 8;\n    header[12] = (rec->length) & 0xff;\n\n    if (!send && !SSL_READ_ETM(ssl) &&\n        EVP_CIPHER_CTX_mode(ssl->enc_read_ctx) == EVP_CIPH_CBC_MODE &&\n        ssl3_cbc_record_digest_supported(mac_ctx)) {\n        /*\n         * This is a CBC-encrypted record. We must avoid leaking any\n         * timing-side channel information about how many blocks of data we\n         * are hashing because that gives an attacker a timing-oracle.\n         */\n        /* Final param == not SSLv3 */\n        if (ssl3_cbc_digest_record(mac_ctx,\n                                   md, &md_size,\n                                   header, rec->input,\n                                   rec->length + md_size, rec->orig_len,\n                                   ssl->s3->read_mac_secret,\n                                   ssl->s3->read_mac_secret_size, 0) <= 0) {\n            EVP_MD_CTX_free(hmac);\n            return -1;\n        }\n    } else {\n        if (EVP_DigestSignUpdate(mac_ctx, header, sizeof(header)) <= 0\n            || EVP_DigestSignUpdate(mac_ctx, rec->input, rec->length) <= 0\n            || EVP_DigestSignFinal(mac_ctx, md, &md_size) <= 0) {\n            EVP_MD_CTX_free(hmac);\n            return -1;\n        }\n        if (!send && !SSL_READ_ETM(ssl) && FIPS_mode())\n            if (!tls_fips_digest_extra(ssl->enc_read_ctx,\n                                       mac_ctx, rec->input,\n                                       rec->length, rec->orig_len)) {\n                EVP_MD_CTX_free(hmac);\n                return -1;\n            }\n    }\n\n    EVP_MD_CTX_free(hmac);\n\n#ifdef SSL_DEBUG\n    fprintf(stderr, \"seq=\");\n    {\n        int z;\n        for (z = 0; z < 8; z++)\n            fprintf(stderr, \"%02X \", seq[z]);\n        fprintf(stderr, \"\\n\");\n    }\n    fprintf(stderr, \"rec=\");\n    {\n        unsigned int z;\n        for (z = 0; z < rec->length; z++)\n            fprintf(stderr, \"%02X \", rec->data[z]);\n        fprintf(stderr, \"\\n\");\n    }\n#endif\n\n    if (!SSL_IS_DTLS(ssl)) {\n        for (i = 7; i >= 0; i--) {\n            ++seq[i];\n            if (seq[i] != 0)\n                break;\n        }\n    }\n#ifdef SSL_DEBUG\n    {\n        unsigned int z;\n        for (z = 0; z < md_size; z++)\n            fprintf(stderr, \"%02X \", md[z]);\n        fprintf(stderr, \"\\n\");\n    }\n#endif\n    return (md_size);\n}",
        "target": 0
    },
    {
        "func": "void tls1_clear(SSL *s)\n{\n    ssl3_clear(s);\n    if (s->method->version == TLS_ANY_VERSION)\n        s->version = TLS_MAX_VERSION;\n    else\n        s->version = s->method->version;\n}",
        "target": 0
    },
    {
        "func": "int ssl_check_clienthello_tlsext_late(SSL *s, int *al)\n{\n    s->tlsext_status_expected = 0;\n\n    /*\n     * If status request then ask callback what to do. Note: this must be\n     * called after servername callbacks in case the certificate has changed,\n     * and must be called after the cipher has been chosen because this may\n     * influence which certificate is sent\n     */\n    if ((s->tlsext_status_type != -1) && s->ctx && s->ctx->tlsext_status_cb) {\n        int ret;\n        CERT_PKEY *certpkey;\n        certpkey = ssl_get_server_send_pkey(s);\n        /* If no certificate can't return certificate status */\n        if (certpkey != NULL) {\n            /*\n             * Set current certificate to one we will use so SSL_get_certificate\n             * et al can pick it up.\n             */\n            s->cert->key = certpkey;\n            ret = s->ctx->tlsext_status_cb(s, s->ctx->tlsext_status_arg);\n            switch (ret) {\n                /* We don't want to send a status request response */\n            case SSL_TLSEXT_ERR_NOACK:\n                s->tlsext_status_expected = 0;\n                break;\n                /* status request response should be sent */\n            case SSL_TLSEXT_ERR_OK:\n                if (s->tlsext_ocsp_resp)\n                    s->tlsext_status_expected = 1;\n                break;\n                /* something bad happened */\n            case SSL_TLSEXT_ERR_ALERT_FATAL:\n            default:\n                *al = SSL_AD_INTERNAL_ERROR;\n                return 0;\n            }\n        }\n    }\n\n    if (!tls1_alpn_handle_client_hello_late(s, al)) {\n        return 0;\n    }\n\n    return 1;\n}",
        "target": 0
    },
    {
        "func": "int tls1_check_ec_tmp_key(SSL *s, unsigned long cid)\n{\n    /*\n     * If Suite B, AES128 MUST use P-256 and AES256 MUST use P-384, no other\n     * curves permitted.\n     */\n    if (tls1_suiteb(s)) {\n        unsigned char curve_id[2];\n        /* Curve to check determined by ciphersuite */\n        if (cid == TLS1_CK_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256)\n            curve_id[1] = TLSEXT_curve_P_256;\n        else if (cid == TLS1_CK_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384)\n            curve_id[1] = TLSEXT_curve_P_384;\n        else\n            return 0;\n        curve_id[0] = 0;\n        /* Check this curve is acceptable */\n        if (!tls1_check_ec_key(s, curve_id, NULL))\n            return 0;\n        return 1;\n    }\n    /* Need a shared curve */\n    if (tls1_shared_curve(s, 0))\n        return 1;\n    return 0;\n}",
        "target": 0
    },
    {
        "func": "int ssl3_do_uncompress(SSL *ssl, SSL3_RECORD *rr)\n{\n#ifndef OPENSSL_NO_COMP\n    int i;\n\n    if (rr->comp == NULL) {\n        rr->comp = (unsigned char *)\n            OPENSSL_malloc(SSL3_RT_MAX_ENCRYPTED_LENGTH);\n    }\n    if (rr->comp == NULL)\n        return 0;\n\n    i = COMP_expand_block(ssl->expand, rr->comp,\n                          SSL3_RT_MAX_PLAIN_LENGTH, rr->data, (int)rr->length);\n    if (i < 0)\n        return 0;\n    else\n        rr->length = i;\n    rr->data = rr->comp;\n#endif\n    return 1;\n}",
        "target": 0
    },
    {
        "func": "int do_ssl3_write(SSL *s, int type, const unsigned char *buf,\n                  unsigned int *pipelens, unsigned int numpipes,\n                  int create_empty_fragment)\n{\n    unsigned char *outbuf[SSL_MAX_PIPELINES], *plen[SSL_MAX_PIPELINES];\n    SSL3_RECORD wr[SSL_MAX_PIPELINES];\n    int i, mac_size, clear = 0;\n    int prefix_len = 0;\n    int eivlen;\n    size_t align = 0;\n    SSL3_BUFFER *wb;\n    SSL_SESSION *sess;\n    unsigned int totlen = 0;\n    unsigned int j;\n\n    for (j = 0; j < numpipes; j++)\n        totlen += pipelens[j];\n    /*\n     * first check if there is a SSL3_BUFFER still being written out.  This\n     * will happen with non blocking IO\n     */\n    if (RECORD_LAYER_write_pending(&s->rlayer))\n        return (ssl3_write_pending(s, type, buf, totlen));\n\n    /* If we have an alert to send, lets send it */\n    if (s->s3->alert_dispatch) {\n        i = s->method->ssl_dispatch_alert(s);\n        if (i <= 0)\n            return (i);\n        /* if it went, fall through and send more stuff */\n    }\n\n    if (s->rlayer.numwpipes < numpipes)\n        if (!ssl3_setup_write_buffer(s, numpipes, 0))\n            return -1;\n\n    if (totlen == 0 && !create_empty_fragment)\n        return 0;\n\n    sess = s->session;\n\n    if ((sess == NULL) ||\n        (s->enc_write_ctx == NULL) || (EVP_MD_CTX_md(s->write_hash) == NULL)) {\n        clear = s->enc_write_ctx ? 0 : 1; /* must be AEAD cipher */\n        mac_size = 0;\n    } else {\n        mac_size = EVP_MD_CTX_size(s->write_hash);\n        if (mac_size < 0)\n            goto err;\n    }\n\n    /*\n     * 'create_empty_fragment' is true only when this function calls itself\n     */\n    if (!clear && !create_empty_fragment && !s->s3->empty_fragment_done) {\n        /*\n         * countermeasure against known-IV weakness in CBC ciphersuites (see\n         * http://www.openssl.org/~bodo/tls-cbc.txt)\n         */\n\n        if (s->s3->need_empty_fragments && type == SSL3_RT_APPLICATION_DATA) {\n            /*\n             * recursive function call with 'create_empty_fragment' set; this\n             * prepares and buffers the data for an empty fragment (these\n             * 'prefix_len' bytes are sent out later together with the actual\n             * payload)\n             */\n            unsigned int tmppipelen = 0;\n\n            prefix_len = do_ssl3_write(s, type, buf, &tmppipelen, 1, 1);\n            if (prefix_len <= 0)\n                goto err;\n\n            if (prefix_len >\n                (SSL3_RT_HEADER_LENGTH + SSL3_RT_SEND_MAX_ENCRYPTED_OVERHEAD)) {\n                /* insufficient space */\n                SSLerr(SSL_F_DO_SSL3_WRITE, ERR_R_INTERNAL_ERROR);\n                goto err;\n            }\n        }\n\n        s->s3->empty_fragment_done = 1;\n    }\n\n    if (create_empty_fragment) {\n        wb = &s->rlayer.wbuf[0];\n#if defined(SSL3_ALIGN_PAYLOAD) && SSL3_ALIGN_PAYLOAD!=0\n        /*\n         * extra fragment would be couple of cipher blocks, which would be\n         * multiple of SSL3_ALIGN_PAYLOAD, so if we want to align the real\n         * payload, then we can just pretend we simply have two headers.\n         */\n        align = (size_t)SSL3_BUFFER_get_buf(wb) + 2 * SSL3_RT_HEADER_LENGTH;\n        align = SSL3_ALIGN_PAYLOAD - 1 - ((align - 1) % SSL3_ALIGN_PAYLOAD);\n#endif\n        outbuf[0] = SSL3_BUFFER_get_buf(wb) + align;\n        SSL3_BUFFER_set_offset(wb, align);\n    } else if (prefix_len) {\n        wb = &s->rlayer.wbuf[0];\n        outbuf[0] = SSL3_BUFFER_get_buf(wb) + SSL3_BUFFER_get_offset(wb)\n            + prefix_len;\n    } else {\n        for (j = 0; j < numpipes; j++) {\n            wb = &s->rlayer.wbuf[j];\n#if defined(SSL3_ALIGN_PAYLOAD) && SSL3_ALIGN_PAYLOAD!=0\n            align = (size_t)SSL3_BUFFER_get_buf(wb) + SSL3_RT_HEADER_LENGTH;\n            align = SSL3_ALIGN_PAYLOAD - 1 - ((align - 1) % SSL3_ALIGN_PAYLOAD);\n#endif\n            outbuf[j] = SSL3_BUFFER_get_buf(wb) + align;\n            SSL3_BUFFER_set_offset(wb, align);\n        }\n    }\n\n    /* Explicit IV length, block ciphers appropriate version flag */\n    if (s->enc_write_ctx && SSL_USE_EXPLICIT_IV(s)) {\n        int mode = EVP_CIPHER_CTX_mode(s->enc_write_ctx);\n        if (mode == EVP_CIPH_CBC_MODE) {\n            eivlen = EVP_CIPHER_CTX_iv_length(s->enc_write_ctx);\n            if (eivlen <= 1)\n                eivlen = 0;\n        }\n        /* Need explicit part of IV for GCM mode */\n        else if (mode == EVP_CIPH_GCM_MODE)\n            eivlen = EVP_GCM_TLS_EXPLICIT_IV_LEN;\n        else if (mode == EVP_CIPH_CCM_MODE)\n            eivlen = EVP_CCM_TLS_EXPLICIT_IV_LEN;\n        else\n            eivlen = 0;\n    } else\n        eivlen = 0;\n\n    totlen = 0;\n    /* Clear our SSL3_RECORD structures */\n    memset(wr, 0, sizeof wr);\n    for (j = 0; j < numpipes; j++) {\n        /* write the header */\n        *(outbuf[j]++) = type & 0xff;\n        SSL3_RECORD_set_type(&wr[j], type);\n\n        *(outbuf[j]++) = (s->version >> 8);\n        /*\n         * Some servers hang if initial client hello is larger than 256 bytes\n         * and record version number > TLS 1.0\n         */\n        if (SSL_get_state(s) == TLS_ST_CW_CLNT_HELLO\n            && !s->renegotiate && TLS1_get_version(s) > TLS1_VERSION)\n            *(outbuf[j]++) = 0x1;\n        else\n            *(outbuf[j]++) = s->version & 0xff;\n\n        /* field where we are to write out packet length */\n        plen[j] = outbuf[j];\n        outbuf[j] += 2;\n\n        /* lets setup the record stuff. */\n        SSL3_RECORD_set_data(&wr[j], outbuf[j] + eivlen);\n        SSL3_RECORD_set_length(&wr[j], (int)pipelens[j]);\n        SSL3_RECORD_set_input(&wr[j], (unsigned char *)&buf[totlen]);\n        totlen += pipelens[j];\n\n        /*\n         * we now 'read' from wr->input, wr->length bytes into wr->data\n         */\n\n        /* first we compress */\n        if (s->compress != NULL) {\n            if (!ssl3_do_compress(s, &wr[j])) {\n                SSLerr(SSL_F_DO_SSL3_WRITE, SSL_R_COMPRESSION_FAILURE);\n                goto err;\n            }\n        } else {\n            memcpy(wr[j].data, wr[j].input, wr[j].length);\n            SSL3_RECORD_reset_input(&wr[j]);\n        }\n\n        /*\n         * we should still have the output to wr->data and the input from\n         * wr->input.  Length should be wr->length. wr->data still points in the\n         * wb->buf\n         */\n\n        if (!SSL_WRITE_ETM(s) && mac_size != 0) {\n            if (s->method->ssl3_enc->mac(s, &wr[j],\n                                         &(outbuf[j][wr[j].length + eivlen]),\n                                         1) < 0)\n                goto err;\n            SSL3_RECORD_add_length(&wr[j], mac_size);\n        }\n\n        SSL3_RECORD_set_data(&wr[j], outbuf[j]);\n        SSL3_RECORD_reset_input(&wr[j]);\n\n        if (eivlen) {\n            /*\n             * if (RAND_pseudo_bytes(p, eivlen) <= 0) goto err;\n             */\n            SSL3_RECORD_add_length(&wr[j], eivlen);\n        }\n    }\n\n    if (s->method->ssl3_enc->enc(s, wr, numpipes, 1) < 1)\n        goto err;\n\n    for (j = 0; j < numpipes; j++) {\n        if (SSL_WRITE_ETM(s) && mac_size != 0) {\n            if (s->method->ssl3_enc->mac(s, &wr[j],\n                                         outbuf[j] + wr[j].length, 1) < 0)\n                goto err;\n            SSL3_RECORD_add_length(&wr[j], mac_size);\n        }\n\n        /* record length after mac and block padding */\n        s2n(SSL3_RECORD_get_length(&wr[j]), plen[j]);\n\n        if (s->msg_callback)\n            s->msg_callback(1, 0, SSL3_RT_HEADER, plen[j] - 5, 5, s,\n                            s->msg_callback_arg);\n\n        /*\n         * we should now have wr->data pointing to the encrypted data, which is\n         * wr->length long\n         */\n        SSL3_RECORD_set_type(&wr[j], type); /* not needed but helps for\n                                             * debugging */\n        SSL3_RECORD_add_length(&wr[j], SSL3_RT_HEADER_LENGTH);\n\n        if (create_empty_fragment) {\n            /*\n             * we are in a recursive call; just return the length, don't write\n             * out anything here\n             */\n            if (j > 0) {\n                /* We should never be pipelining an empty fragment!! */\n                SSLerr(SSL_F_DO_SSL3_WRITE, ERR_R_INTERNAL_ERROR);\n                goto err;\n            }\n            return SSL3_RECORD_get_length(wr);\n        }\n\n        /* now let's set up wb */\n        SSL3_BUFFER_set_left(&s->rlayer.wbuf[j],\n                             prefix_len + SSL3_RECORD_get_length(&wr[j]));\n    }\n\n    /*\n     * memorize arguments so that ssl3_write_pending can detect bad write\n     * retries later\n     */\n    s->rlayer.wpend_tot = totlen;\n    s->rlayer.wpend_buf = buf;\n    s->rlayer.wpend_type = type;\n    s->rlayer.wpend_ret = totlen;\n\n    /* we now just need to write the buffer */\n    return ssl3_write_pending(s, type, buf, totlen);\n err:\n    return -1;\n}",
        "target": 0
    },
    {
        "func": "int tls1_enc(SSL *s, SSL3_RECORD *recs, unsigned int n_recs, int send)\n{\n    EVP_CIPHER_CTX *ds;\n    size_t reclen[SSL_MAX_PIPELINES];\n    unsigned char buf[SSL_MAX_PIPELINES][EVP_AEAD_TLS1_AAD_LEN];\n    int bs, i, j, k, pad = 0, ret, mac_size = 0;\n    const EVP_CIPHER *enc;\n    unsigned int ctr;\n\n    if (send) {\n        if (EVP_MD_CTX_md(s->write_hash)) {\n            int n = EVP_MD_CTX_size(s->write_hash);\n            OPENSSL_assert(n >= 0);\n        }\n        ds = s->enc_write_ctx;\n        if (s->enc_write_ctx == NULL)\n            enc = NULL;\n        else {\n            int ivlen;\n            enc = EVP_CIPHER_CTX_cipher(s->enc_write_ctx);\n            /* For TLSv1.1 and later explicit IV */\n            if (SSL_USE_EXPLICIT_IV(s)\n                && EVP_CIPHER_mode(enc) == EVP_CIPH_CBC_MODE)\n                ivlen = EVP_CIPHER_iv_length(enc);\n            else\n                ivlen = 0;\n            if (ivlen > 1) {\n                for (ctr = 0; ctr < n_recs; ctr++) {\n                    if (recs[ctr].data != recs[ctr].input) {\n                        /*\n                         * we can't write into the input stream: Can this ever\n                         * happen?? (steve)\n                         */\n                        SSLerr(SSL_F_TLS1_ENC, ERR_R_INTERNAL_ERROR);\n                        return -1;\n                    } else if (RAND_bytes(recs[ctr].input, ivlen) <= 0) {\n                        SSLerr(SSL_F_TLS1_ENC, ERR_R_INTERNAL_ERROR);\n                        return -1;\n                    }\n                }\n            }\n        }\n    } else {\n        if (EVP_MD_CTX_md(s->read_hash)) {\n            int n = EVP_MD_CTX_size(s->read_hash);\n            OPENSSL_assert(n >= 0);\n        }\n        ds = s->enc_read_ctx;\n        if (s->enc_read_ctx == NULL)\n            enc = NULL;\n        else\n            enc = EVP_CIPHER_CTX_cipher(s->enc_read_ctx);\n    }\n\n    if ((s->session == NULL) || (ds == NULL) || (enc == NULL)) {\n        for (ctr = 0; ctr < n_recs; ctr++) {\n            memmove(recs[ctr].data, recs[ctr].input, recs[ctr].length);\n            recs[ctr].input = recs[ctr].data;\n        }\n        ret = 1;\n    } else {\n        bs = EVP_CIPHER_block_size(EVP_CIPHER_CTX_cipher(ds));\n\n        if (n_recs > 1) {\n            if (!(EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(ds))\n                  & EVP_CIPH_FLAG_PIPELINE)) {\n                /*\n                 * We shouldn't have been called with pipeline data if the\n                 * cipher doesn't support pipelining\n                 */\n                SSLerr(SSL_F_TLS1_ENC, SSL_R_PIPELINE_FAILURE);\n                return -1;\n            }\n        }\n        for (ctr = 0; ctr < n_recs; ctr++) {\n            reclen[ctr] = recs[ctr].length;\n\n            if (EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(ds))\n                & EVP_CIPH_FLAG_AEAD_CIPHER) {\n                unsigned char *seq;\n\n                seq = send ? RECORD_LAYER_get_write_sequence(&s->rlayer)\n                    : RECORD_LAYER_get_read_sequence(&s->rlayer);\n\n                if (SSL_IS_DTLS(s)) {\n                    /* DTLS does not support pipelining */\n                    unsigned char dtlsseq[9], *p = dtlsseq;\n\n                    s2n(send ? DTLS_RECORD_LAYER_get_w_epoch(&s->rlayer) :\n                        DTLS_RECORD_LAYER_get_r_epoch(&s->rlayer), p);\n                    memcpy(p, &seq[2], 6);\n                    memcpy(buf[ctr], dtlsseq, 8);\n                } else {\n                    memcpy(buf[ctr], seq, 8);\n                    for (i = 7; i >= 0; i--) { /* increment */\n                        ++seq[i];\n                        if (seq[i] != 0)\n                            break;\n                    }\n                }\n\n                buf[ctr][8] = recs[ctr].type;\n                buf[ctr][9] = (unsigned char)(s->version >> 8);\n                buf[ctr][10] = (unsigned char)(s->version);\n                buf[ctr][11] = recs[ctr].length >> 8;\n                buf[ctr][12] = recs[ctr].length & 0xff;\n                pad = EVP_CIPHER_CTX_ctrl(ds, EVP_CTRL_AEAD_TLS1_AAD,\n                                          EVP_AEAD_TLS1_AAD_LEN, buf[ctr]);\n                if (pad <= 0)\n                    return -1;\n\n                if (send) {\n                    reclen[ctr] += pad;\n                    recs[ctr].length += pad;\n                }\n\n            } else if ((bs != 1) && send) {\n                i = bs - ((int)reclen[ctr] % bs);\n\n                /* Add weird padding of upto 256 bytes */\n\n                /* we need to add 'i' padding bytes of value j */\n                j = i - 1;\n                for (k = (int)reclen[ctr]; k < (int)(reclen[ctr] + i); k++)\n                    recs[ctr].input[k] = j;\n                reclen[ctr] += i;\n                recs[ctr].length += i;\n            }\n\n            if (!send) {\n                if (reclen[ctr] == 0 || reclen[ctr] % bs != 0)\n                    return 0;\n            }\n        }\n        if (n_recs > 1) {\n            unsigned char *data[SSL_MAX_PIPELINES];\n\n            /* Set the output buffers */\n            for (ctr = 0; ctr < n_recs; ctr++) {\n                data[ctr] = recs[ctr].data;\n            }\n            if (EVP_CIPHER_CTX_ctrl(ds, EVP_CTRL_SET_PIPELINE_OUTPUT_BUFS,\n                                    n_recs, data) <= 0) {\n                SSLerr(SSL_F_TLS1_ENC, SSL_R_PIPELINE_FAILURE);\n            }\n            /* Set the input buffers */\n            for (ctr = 0; ctr < n_recs; ctr++) {\n                data[ctr] = recs[ctr].input;\n            }\n            if (EVP_CIPHER_CTX_ctrl(ds, EVP_CTRL_SET_PIPELINE_INPUT_BUFS,\n                                    n_recs, data) <= 0\n                || EVP_CIPHER_CTX_ctrl(ds, EVP_CTRL_SET_PIPELINE_INPUT_LENS,\n                                       n_recs, reclen) <= 0) {\n                SSLerr(SSL_F_TLS1_ENC, SSL_R_PIPELINE_FAILURE);\n                return -1;\n            }\n        }\n\n        i = EVP_Cipher(ds, recs[0].data, recs[0].input, reclen[0]);\n        if ((EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(ds))\n             & EVP_CIPH_FLAG_CUSTOM_CIPHER)\n            ? (i < 0)\n            : (i == 0))\n            return -1;          /* AEAD can fail to verify MAC */\n        if (send == 0) {\n            if (EVP_CIPHER_mode(enc) == EVP_CIPH_GCM_MODE) {\n                for (ctr = 0; ctr < n_recs; ctr++) {\n                    recs[ctr].data += EVP_GCM_TLS_EXPLICIT_IV_LEN;\n                    recs[ctr].input += EVP_GCM_TLS_EXPLICIT_IV_LEN;\n                    recs[ctr].length -= EVP_GCM_TLS_EXPLICIT_IV_LEN;\n                }\n            } else if (EVP_CIPHER_mode(enc) == EVP_CIPH_CCM_MODE) {\n                for (ctr = 0; ctr < n_recs; ctr++) {\n                    recs[ctr].data += EVP_CCM_TLS_EXPLICIT_IV_LEN;\n                    recs[ctr].input += EVP_CCM_TLS_EXPLICIT_IV_LEN;\n                    recs[ctr].length -= EVP_CCM_TLS_EXPLICIT_IV_LEN;\n                }\n            }\n        }\n\n        ret = 1;\n        if (!SSL_READ_ETM(s) && EVP_MD_CTX_md(s->read_hash) != NULL)\n            mac_size = EVP_MD_CTX_size(s->read_hash);\n        if ((bs != 1) && !send) {\n            int tmpret;\n            for (ctr = 0; ctr < n_recs; ctr++) {\n                tmpret = tls1_cbc_remove_padding(s, &recs[ctr], bs, mac_size);\n                /*\n                 * If tmpret == 0 then this means publicly invalid so we can\n                 * short circuit things here. Otherwise we must respect constant\n                 * time behaviour.\n                 */\n                if (tmpret == 0)\n                    return 0;\n                ret = constant_time_select_int(constant_time_eq_int(tmpret, 1),\n                                               ret, -1);\n            }\n        }\n        if (pad && !send) {\n            for (ctr = 0; ctr < n_recs; ctr++) {\n                recs[ctr].length -= pad;\n            }\n        }\n    }\n    return ret;\n}",
        "target": 0
    },
    {
        "func": "static int tls1_generate_key_block(SSL *s, unsigned char *km, int num)\n{\n    int ret;\n    ret = tls1_PRF(s,\n                   TLS_MD_KEY_EXPANSION_CONST,\n                   TLS_MD_KEY_EXPANSION_CONST_SIZE, s->s3->server_random,\n                   SSL3_RANDOM_SIZE, s->s3->client_random, SSL3_RANDOM_SIZE,\n                   NULL, 0, NULL, 0, s->session->master_key,\n                   s->session->master_key_length, km, num);\n\n    return ret;\n}",
        "target": 0
    },
    {
        "func": "void tls1_set_cert_validity(SSL *s)\n{\n    tls1_check_chain(s, NULL, NULL, NULL, SSL_PKEY_RSA_ENC);\n    tls1_check_chain(s, NULL, NULL, NULL, SSL_PKEY_RSA_SIGN);\n    tls1_check_chain(s, NULL, NULL, NULL, SSL_PKEY_DSA_SIGN);\n    tls1_check_chain(s, NULL, NULL, NULL, SSL_PKEY_ECC);\n    tls1_check_chain(s, NULL, NULL, NULL, SSL_PKEY_GOST01);\n    tls1_check_chain(s, NULL, NULL, NULL, SSL_PKEY_GOST12_256);\n    tls1_check_chain(s, NULL, NULL, NULL, SSL_PKEY_GOST12_512);\n}",
        "target": 0
    },
    {
        "func": "static int tls1_check_duplicate_extensions(const PACKET *packet)\n{\n    PACKET extensions = *packet;\n    size_t num_extensions = 0, i = 0;\n    unsigned int *extension_types = NULL;\n    int ret = 0;\n\n    /* First pass: count the extensions. */\n    while (PACKET_remaining(&extensions) > 0) {\n        unsigned int type;\n        PACKET extension;\n        if (!PACKET_get_net_2(&extensions, &type) ||\n            !PACKET_get_length_prefixed_2(&extensions, &extension)) {\n            goto done;\n        }\n        num_extensions++;\n    }\n\n    if (num_extensions <= 1)\n        return 1;\n\n    extension_types = OPENSSL_malloc(sizeof(unsigned int) * num_extensions);\n    if (extension_types == NULL) {\n        SSLerr(SSL_F_TLS1_CHECK_DUPLICATE_EXTENSIONS, ERR_R_MALLOC_FAILURE);\n        goto done;\n    }\n\n    /* Second pass: gather the extension types. */\n    extensions = *packet;\n    for (i = 0; i < num_extensions; i++) {\n        PACKET extension;\n        if (!PACKET_get_net_2(&extensions, &extension_types[i]) ||\n            !PACKET_get_length_prefixed_2(&extensions, &extension)) {\n            /* This should not happen. */\n            SSLerr(SSL_F_TLS1_CHECK_DUPLICATE_EXTENSIONS, ERR_R_INTERNAL_ERROR);\n            goto done;\n        }\n    }\n\n    if (PACKET_remaining(&extensions) != 0) {\n        SSLerr(SSL_F_TLS1_CHECK_DUPLICATE_EXTENSIONS, ERR_R_INTERNAL_ERROR);\n        goto done;\n    }\n    /* Sort the extensions and make sure there are no duplicates. */\n    qsort(extension_types, num_extensions, sizeof(unsigned int), compare_uint);\n    for (i = 1; i < num_extensions; i++) {\n        if (extension_types[i - 1] == extension_types[i])\n            goto done;\n    }\n    ret = 1;\n done:\n    OPENSSL_free(extension_types);\n    return ret;\n}",
        "target": 0
    },
    {
        "func": "int ssl3_write_bytes(SSL *s, int type, const void *buf_, int len)\n{\n    const unsigned char *buf = buf_;\n    int tot;\n    unsigned int n, split_send_fragment, maxpipes;\n#if !defined(OPENSSL_NO_MULTIBLOCK) && EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK\n    unsigned int max_send_fragment, nw;\n    unsigned int u_len = (unsigned int)len;\n#endif\n    SSL3_BUFFER *wb = &s->rlayer.wbuf[0];\n    int i;\n\n    if (len < 0) {\n        SSLerr(SSL_F_SSL3_WRITE_BYTES, SSL_R_SSL_NEGATIVE_LENGTH);\n        return -1;\n    }\n\n    s->rwstate = SSL_NOTHING;\n    tot = s->rlayer.wnum;\n    /*\n     * ensure that if we end up with a smaller value of data to write out\n     * than the the original len from a write which didn't complete for\n     * non-blocking I/O and also somehow ended up avoiding the check for\n     * this in ssl3_write_pending/SSL_R_BAD_WRITE_RETRY as it must never be\n     * possible to end up with (len-tot) as a large number that will then\n     * promptly send beyond the end of the users buffer ... so we trap and\n     * report the error in a way the user will notice\n     */\n    if ((unsigned int)len < s->rlayer.wnum) {\n        SSLerr(SSL_F_SSL3_WRITE_BYTES, SSL_R_BAD_LENGTH);\n        return -1;\n    }\n\n    s->rlayer.wnum = 0;\n\n    if (SSL_in_init(s) && !ossl_statem_get_in_handshake(s)) {\n        i = s->handshake_func(s);\n        if (i < 0)\n            return (i);\n        if (i == 0) {\n            SSLerr(SSL_F_SSL3_WRITE_BYTES, SSL_R_SSL_HANDSHAKE_FAILURE);\n            return -1;\n        }\n    }\n\n    /*\n     * first check if there is a SSL3_BUFFER still being written out.  This\n     * will happen with non blocking IO\n     */\n    if (wb->left != 0) {\n        i = ssl3_write_pending(s, type, &buf[tot], s->rlayer.wpend_tot);\n        if (i <= 0) {\n            /* XXX should we ssl3_release_write_buffer if i<0? */\n            s->rlayer.wnum = tot;\n            return i;\n        }\n        tot += i;               /* this might be last fragment */\n    }\n#if !defined(OPENSSL_NO_MULTIBLOCK) && EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK\n    /*\n     * Depending on platform multi-block can deliver several *times*\n     * better performance. Downside is that it has to allocate\n     * jumbo buffer to accommodate up to 8 records, but the\n     * compromise is considered worthy.\n     */\n    if (type == SSL3_RT_APPLICATION_DATA &&\n        u_len >= 4 * (max_send_fragment = s->max_send_fragment) &&\n        s->compress == NULL && s->msg_callback == NULL &&\n        !SSL_WRITE_ETM(s) && SSL_USE_EXPLICIT_IV(s) &&\n        EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(s->enc_write_ctx)) &\n        EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK) {\n        unsigned char aad[13];\n        EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM mb_param;\n        int packlen;\n\n        /* minimize address aliasing conflicts */\n        if ((max_send_fragment & 0xfff) == 0)\n            max_send_fragment -= 512;\n\n        if (tot == 0 || wb->buf == NULL) { /* allocate jumbo buffer */\n            ssl3_release_write_buffer(s);\n\n            packlen = EVP_CIPHER_CTX_ctrl(s->enc_write_ctx,\n                                          EVP_CTRL_TLS1_1_MULTIBLOCK_MAX_BUFSIZE,\n                                          max_send_fragment, NULL);\n\n            if (u_len >= 8 * max_send_fragment)\n                packlen *= 8;\n            else\n                packlen *= 4;\n\n            if (!ssl3_setup_write_buffer(s, 1, packlen)) {\n                SSLerr(SSL_F_SSL3_WRITE_BYTES, ERR_R_MALLOC_FAILURE);\n                return -1;\n            }\n        } else if (tot == len) { /* done? */\n            /* free jumbo buffer */\n            ssl3_release_write_buffer(s);\n            return tot;\n        }\n\n        n = (len - tot);\n        for (;;) {\n            if (n < 4 * max_send_fragment) {\n                /* free jumbo buffer */\n                ssl3_release_write_buffer(s);\n                break;\n            }\n\n            if (s->s3->alert_dispatch) {\n                i = s->method->ssl_dispatch_alert(s);\n                if (i <= 0) {\n                    s->rlayer.wnum = tot;\n                    return i;\n                }\n            }\n\n            if (n >= 8 * max_send_fragment)\n                nw = max_send_fragment * (mb_param.interleave = 8);\n            else\n                nw = max_send_fragment * (mb_param.interleave = 4);\n\n            memcpy(aad, s->rlayer.write_sequence, 8);\n            aad[8] = type;\n            aad[9] = (unsigned char)(s->version >> 8);\n            aad[10] = (unsigned char)(s->version);\n            aad[11] = 0;\n            aad[12] = 0;\n            mb_param.out = NULL;\n            mb_param.inp = aad;\n            mb_param.len = nw;\n\n            packlen = EVP_CIPHER_CTX_ctrl(s->enc_write_ctx,\n                                          EVP_CTRL_TLS1_1_MULTIBLOCK_AAD,\n                                          sizeof(mb_param), &mb_param);\n\n            if (packlen <= 0 || packlen > (int)wb->len) { /* never happens */\n                /* free jumbo buffer */\n                ssl3_release_write_buffer(s);\n                break;\n            }\n\n            mb_param.out = wb->buf;\n            mb_param.inp = &buf[tot];\n            mb_param.len = nw;\n\n            if (EVP_CIPHER_CTX_ctrl(s->enc_write_ctx,\n                                    EVP_CTRL_TLS1_1_MULTIBLOCK_ENCRYPT,\n                                    sizeof(mb_param), &mb_param) <= 0)\n                return -1;\n\n            s->rlayer.write_sequence[7] += mb_param.interleave;\n            if (s->rlayer.write_sequence[7] < mb_param.interleave) {\n                int j = 6;\n                while (j >= 0 && (++s->rlayer.write_sequence[j--]) == 0) ;\n            }\n\n            wb->offset = 0;\n            wb->left = packlen;\n\n            s->rlayer.wpend_tot = nw;\n            s->rlayer.wpend_buf = &buf[tot];\n            s->rlayer.wpend_type = type;\n            s->rlayer.wpend_ret = nw;\n\n            i = ssl3_write_pending(s, type, &buf[tot], nw);\n            if (i <= 0) {\n                if (i < 0 && (!s->wbio || !BIO_should_retry(s->wbio))) {\n                    /* free jumbo buffer */\n                    ssl3_release_write_buffer(s);\n                }\n                s->rlayer.wnum = tot;\n                return i;\n            }\n            if (i == (int)n) {\n                /* free jumbo buffer */\n                ssl3_release_write_buffer(s);\n                return tot + i;\n            }\n            n -= i;\n            tot += i;\n        }\n    } else\n#endif\n    if (tot == len) {           /* done? */\n        if (s->mode & SSL_MODE_RELEASE_BUFFERS && !SSL_IS_DTLS(s))\n            ssl3_release_write_buffer(s);\n\n        return tot;\n    }\n\n    n = (len - tot);\n\n    split_send_fragment = s->split_send_fragment;\n    /*\n     * If max_pipelines is 0 then this means \"undefined\" and we default to\n     * 1 pipeline. Similarly if the cipher does not support pipelined\n     * processing then we also only use 1 pipeline, or if we're not using\n     * explicit IVs\n     */\n    maxpipes = s->max_pipelines;\n    if (maxpipes > SSL_MAX_PIPELINES) {\n        /*\n         * We should have prevented this when we set max_pipelines so we\n         * shouldn't get here\n         */\n        SSLerr(SSL_F_SSL3_WRITE_BYTES, ERR_R_INTERNAL_ERROR);\n        return -1;\n    }\n    if (maxpipes == 0\n        || s->enc_write_ctx == NULL\n        || !(EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(s->enc_write_ctx))\n             & EVP_CIPH_FLAG_PIPELINE)\n        || !SSL_USE_EXPLICIT_IV(s))\n        maxpipes = 1;\n    if (s->max_send_fragment == 0 || split_send_fragment > s->max_send_fragment\n        || split_send_fragment == 0) {\n        /*\n         * We should have prevented this when we set the split and max send\n         * fragments so we shouldn't get here\n         */\n        SSLerr(SSL_F_SSL3_WRITE_BYTES, ERR_R_INTERNAL_ERROR);\n        return -1;\n    }\n\n    for (;;) {\n        unsigned int pipelens[SSL_MAX_PIPELINES], tmppipelen, remain;\n        unsigned int numpipes, j;\n\n        if (n == 0)\n            numpipes = 1;\n        else\n            numpipes = ((n - 1) / split_send_fragment) + 1;\n        if (numpipes > maxpipes)\n            numpipes = maxpipes;\n\n        if (n / numpipes >= s->max_send_fragment) {\n            /*\n             * We have enough data to completely fill all available\n             * pipelines\n             */\n            for (j = 0; j < numpipes; j++) {\n                pipelens[j] = s->max_send_fragment;\n            }\n        } else {\n            /* We can partially fill all available pipelines */\n            tmppipelen = n / numpipes;\n            remain = n % numpipes;\n            for (j = 0; j < numpipes; j++) {\n                pipelens[j] = tmppipelen;\n                if (j < remain)\n                    pipelens[j]++;\n            }\n        }\n\n        i = do_ssl3_write(s, type, &(buf[tot]), pipelens, numpipes, 0);\n        if (i <= 0) {\n            /* XXX should we ssl3_release_write_buffer if i<0? */\n            s->rlayer.wnum = tot;\n            return i;\n        }\n\n        if ((i == (int)n) ||\n            (type == SSL3_RT_APPLICATION_DATA &&\n             (s->mode & SSL_MODE_ENABLE_PARTIAL_WRITE))) {\n            /*\n             * next chunk of data should get another prepended empty fragment\n             * in ciphersuites with known-IV weakness:\n             */\n            s->s3->empty_fragment_done = 0;\n\n            if ((i == (int)n) && s->mode & SSL_MODE_RELEASE_BUFFERS &&\n                !SSL_IS_DTLS(s))\n                ssl3_release_write_buffer(s);\n\n            return tot + i;\n        }\n\n        n -= i;\n        tot += i;\n    }\n}",
        "target": 0
    },
    {
        "func": "void ssl_set_client_disabled(SSL *s)\n{\n    s->s3->tmp.mask_a = 0;\n    s->s3->tmp.mask_k = 0;\n    ssl_set_sig_mask(&s->s3->tmp.mask_a, s, SSL_SECOP_SIGALG_MASK);\n    ssl_get_client_min_max_version(s, &s->s3->tmp.min_ver, &s->s3->tmp.max_ver);\n#ifndef OPENSSL_NO_PSK\n    /* with PSK there must be client callback set */\n    if (!s->psk_client_callback) {\n        s->s3->tmp.mask_a |= SSL_aPSK;\n        s->s3->tmp.mask_k |= SSL_PSK;\n    }\n#endif                          /* OPENSSL_NO_PSK */\n#ifndef OPENSSL_NO_SRP\n    if (!(s->srp_ctx.srp_Mask & SSL_kSRP)) {\n        s->s3->tmp.mask_a |= SSL_aSRP;\n        s->s3->tmp.mask_k |= SSL_kSRP;\n    }\n#endif\n}",
        "target": 0
    },
    {
        "func": "void SSL3_RECORD_release(SSL3_RECORD *r, unsigned int num_recs)\n{\n    unsigned int i;\n\n    for (i = 0; i < num_recs; i++) {\n        OPENSSL_free(r[i].comp);\n        r[i].comp = NULL;\n    }\n}",
        "target": 0
    },
    {
        "func": "static int ssl_check_clienthello_tlsext_early(SSL *s)\n{\n    int ret = SSL_TLSEXT_ERR_NOACK;\n    int al = SSL_AD_UNRECOGNIZED_NAME;\n\n#ifndef OPENSSL_NO_EC\n    /*\n     * The handling of the ECPointFormats extension is done elsewhere, namely\n     * in ssl3_choose_cipher in s3_lib.c.\n     */\n    /*\n     * The handling of the EllipticCurves extension is done elsewhere, namely\n     * in ssl3_choose_cipher in s3_lib.c.\n     */\n#endif\n\n    if (s->ctx != NULL && s->ctx->tlsext_servername_callback != 0)\n        ret =\n            s->ctx->tlsext_servername_callback(s, &al,\n                                               s->ctx->tlsext_servername_arg);\n    else if (s->session_ctx != NULL\n             && s->session_ctx->tlsext_servername_callback != 0)\n        ret =\n            s->session_ctx->tlsext_servername_callback(s, &al,\n                                                       s->\n                                                       session_ctx->tlsext_servername_arg);\n\n    switch (ret) {\n    case SSL_TLSEXT_ERR_ALERT_FATAL:\n        ssl3_send_alert(s, SSL3_AL_FATAL, al);\n        return -1;\n\n    case SSL_TLSEXT_ERR_ALERT_WARNING:\n        ssl3_send_alert(s, SSL3_AL_WARNING, al);\n        return 1;\n\n    case SSL_TLSEXT_ERR_NOACK:\n        s->servername_done = 0;\n    default:\n        return 1;\n    }\n}",
        "target": 0
    },
    {
        "func": "int tls1_change_cipher_state(SSL *s, int which)\n{\n    unsigned char *p, *mac_secret;\n    unsigned char tmp1[EVP_MAX_KEY_LENGTH];\n    unsigned char tmp2[EVP_MAX_KEY_LENGTH];\n    unsigned char iv1[EVP_MAX_IV_LENGTH * 2];\n    unsigned char iv2[EVP_MAX_IV_LENGTH * 2];\n    unsigned char *ms, *key, *iv;\n    EVP_CIPHER_CTX *dd;\n    const EVP_CIPHER *c;\n#ifndef OPENSSL_NO_COMP\n    const SSL_COMP *comp;\n#endif\n    const EVP_MD *m;\n    int mac_type;\n    int *mac_secret_size;\n    EVP_MD_CTX *mac_ctx;\n    EVP_PKEY *mac_key;\n    int n, i, j, k, cl;\n    int reuse_dd = 0;\n\n    c = s->s3->tmp.new_sym_enc;\n    m = s->s3->tmp.new_hash;\n    mac_type = s->s3->tmp.new_mac_pkey_type;\n#ifndef OPENSSL_NO_COMP\n    comp = s->s3->tmp.new_compression;\n#endif\n\n    if (which & SSL3_CC_READ) {\n        if (s->tlsext_use_etm)\n            s->s3->flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC_READ;\n        else\n            s->s3->flags &= ~TLS1_FLAGS_ENCRYPT_THEN_MAC_READ;\n\n        if (s->s3->tmp.new_cipher->algorithm2 & TLS1_STREAM_MAC)\n            s->mac_flags |= SSL_MAC_FLAG_READ_MAC_STREAM;\n        else\n            s->mac_flags &= ~SSL_MAC_FLAG_READ_MAC_STREAM;\n\n        if (s->enc_read_ctx != NULL)\n            reuse_dd = 1;\n        else if ((s->enc_read_ctx = EVP_CIPHER_CTX_new()) == NULL)\n            goto err;\n        else\n            /*\n             * make sure it's initialised in case we exit later with an error\n             */\n            EVP_CIPHER_CTX_reset(s->enc_read_ctx);\n        dd = s->enc_read_ctx;\n        mac_ctx = ssl_replace_hash(&s->read_hash, NULL);\n        if (mac_ctx == NULL)\n            goto err;\n#ifndef OPENSSL_NO_COMP\n        COMP_CTX_free(s->expand);\n        s->expand = NULL;\n        if (comp != NULL) {\n            s->expand = COMP_CTX_new(comp->method);\n            if (s->expand == NULL) {\n                SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,\n                       SSL_R_COMPRESSION_LIBRARY_ERROR);\n                goto err2;\n            }\n        }\n#endif\n        /*\n         * this is done by dtls1_reset_seq_numbers for DTLS\n         */\n        if (!SSL_IS_DTLS(s))\n            RECORD_LAYER_reset_read_sequence(&s->rlayer);\n        mac_secret = &(s->s3->read_mac_secret[0]);\n        mac_secret_size = &(s->s3->read_mac_secret_size);\n    } else {\n        if (s->tlsext_use_etm)\n            s->s3->flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC_WRITE;\n        else\n            s->s3->flags &= ~TLS1_FLAGS_ENCRYPT_THEN_MAC_WRITE;\n\n        if (s->s3->tmp.new_cipher->algorithm2 & TLS1_STREAM_MAC)\n            s->mac_flags |= SSL_MAC_FLAG_WRITE_MAC_STREAM;\n        else\n            s->mac_flags &= ~SSL_MAC_FLAG_WRITE_MAC_STREAM;\n        if (s->enc_write_ctx != NULL && !SSL_IS_DTLS(s))\n            reuse_dd = 1;\n        else if ((s->enc_write_ctx = EVP_CIPHER_CTX_new()) == NULL)\n            goto err;\n        dd = s->enc_write_ctx;\n        if (SSL_IS_DTLS(s)) {\n            mac_ctx = EVP_MD_CTX_new();\n            if (mac_ctx == NULL)\n                goto err;\n            s->write_hash = mac_ctx;\n        } else {\n            mac_ctx = ssl_replace_hash(&s->write_hash, NULL);\n            if (mac_ctx == NULL)\n                goto err;\n        }\n#ifndef OPENSSL_NO_COMP\n        COMP_CTX_free(s->compress);\n        s->compress = NULL;\n        if (comp != NULL) {\n            s->compress = COMP_CTX_new(comp->method);\n            if (s->compress == NULL) {\n                SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,\n                       SSL_R_COMPRESSION_LIBRARY_ERROR);\n                goto err2;\n            }\n        }\n#endif\n        /*\n         * this is done by dtls1_reset_seq_numbers for DTLS\n         */\n        if (!SSL_IS_DTLS(s))\n            RECORD_LAYER_reset_write_sequence(&s->rlayer);\n        mac_secret = &(s->s3->write_mac_secret[0]);\n        mac_secret_size = &(s->s3->write_mac_secret_size);\n    }\n\n    if (reuse_dd)\n        EVP_CIPHER_CTX_reset(dd);\n\n    p = s->s3->tmp.key_block;\n    i = *mac_secret_size = s->s3->tmp.new_mac_secret_size;\n\n    cl = EVP_CIPHER_key_length(c);\n    j = cl;\n    /* Was j=(exp)?5:EVP_CIPHER_key_length(c); */\n    /* If GCM/CCM mode only part of IV comes from PRF */\n    if (EVP_CIPHER_mode(c) == EVP_CIPH_GCM_MODE)\n        k = EVP_GCM_TLS_FIXED_IV_LEN;\n    else if (EVP_CIPHER_mode(c) == EVP_CIPH_CCM_MODE)\n        k = EVP_CCM_TLS_FIXED_IV_LEN;\n    else\n        k = EVP_CIPHER_iv_length(c);\n    if ((which == SSL3_CHANGE_CIPHER_CLIENT_WRITE) ||\n        (which == SSL3_CHANGE_CIPHER_SERVER_READ)) {\n        ms = &(p[0]);\n        n = i + i;\n        key = &(p[n]);\n        n += j + j;\n        iv = &(p[n]);\n        n += k + k;\n    } else {\n        n = i;\n        ms = &(p[n]);\n        n += i + j;\n        key = &(p[n]);\n        n += j + k;\n        iv = &(p[n]);\n        n += k;\n    }\n\n    if (n > s->s3->tmp.key_block_length) {\n        SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR);\n        goto err2;\n    }\n\n    memcpy(mac_secret, ms, i);\n\n    if (!(EVP_CIPHER_flags(c) & EVP_CIPH_FLAG_AEAD_CIPHER)) {\n        mac_key = EVP_PKEY_new_mac_key(mac_type, NULL,\n                                       mac_secret, *mac_secret_size);\n        if (mac_key == NULL\n            || EVP_DigestSignInit(mac_ctx, NULL, m, NULL, mac_key) <= 0) {\n            EVP_PKEY_free(mac_key);\n            SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR);\n            goto err2;\n        }\n        EVP_PKEY_free(mac_key);\n    }\n#ifdef SSL_DEBUG\n    printf(\"which = %04X\\nmac key=\", which);\n    {\n        int z;\n        for (z = 0; z < i; z++)\n            printf(\"%02X%c\", ms[z], ((z + 1) % 16) ? ' ' : '\\n');\n    }\n#endif\n\n    if (EVP_CIPHER_mode(c) == EVP_CIPH_GCM_MODE) {\n        if (!EVP_CipherInit_ex(dd, c, NULL, key, NULL, (which & SSL3_CC_WRITE))\n            || !EVP_CIPHER_CTX_ctrl(dd, EVP_CTRL_GCM_SET_IV_FIXED, k, iv)) {\n            SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR);\n            goto err2;\n        }\n    } else if (EVP_CIPHER_mode(c) == EVP_CIPH_CCM_MODE) {\n        int taglen;\n        if (s->s3->tmp.\n            new_cipher->algorithm_enc & (SSL_AES128CCM8 | SSL_AES256CCM8))\n            taglen = 8;\n        else\n            taglen = 16;\n        if (!EVP_CipherInit_ex(dd, c, NULL, NULL, NULL, (which & SSL3_CC_WRITE))\n            || !EVP_CIPHER_CTX_ctrl(dd, EVP_CTRL_AEAD_SET_IVLEN, 12, NULL)\n            || !EVP_CIPHER_CTX_ctrl(dd, EVP_CTRL_AEAD_SET_TAG, taglen, NULL)\n            || !EVP_CIPHER_CTX_ctrl(dd, EVP_CTRL_CCM_SET_IV_FIXED, k, iv)\n            || !EVP_CipherInit_ex(dd, NULL, NULL, key, NULL, -1)) {\n            SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR);\n            goto err2;\n        }\n    } else {\n        if (!EVP_CipherInit_ex(dd, c, NULL, key, iv, (which & SSL3_CC_WRITE))) {\n            SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR);\n            goto err2;\n        }\n    }\n    /* Needed for \"composite\" AEADs, such as RC4-HMAC-MD5 */\n    if ((EVP_CIPHER_flags(c) & EVP_CIPH_FLAG_AEAD_CIPHER) && *mac_secret_size\n        && !EVP_CIPHER_CTX_ctrl(dd, EVP_CTRL_AEAD_SET_MAC_KEY,\n                                *mac_secret_size, mac_secret)) {\n        SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR);\n        goto err2;\n    }\n#ifdef OPENSSL_SSL_TRACE_CRYPTO\n    if (s->msg_callback) {\n        int wh = which & SSL3_CC_WRITE ? TLS1_RT_CRYPTO_WRITE : 0;\n        if (*mac_secret_size)\n            s->msg_callback(2, s->version, wh | TLS1_RT_CRYPTO_MAC,\n                            mac_secret, *mac_secret_size,\n                            s, s->msg_callback_arg);\n        if (c->key_len)\n            s->msg_callback(2, s->version, wh | TLS1_RT_CRYPTO_KEY,\n                            key, c->key_len, s, s->msg_callback_arg);\n        if (k) {\n            if (EVP_CIPHER_mode(c) == EVP_CIPH_GCM_MODE)\n                wh |= TLS1_RT_CRYPTO_FIXED_IV;\n            else\n                wh |= TLS1_RT_CRYPTO_IV;\n            s->msg_callback(2, s->version, wh, iv, k, s, s->msg_callback_arg);\n        }\n    }\n#endif\n\n#ifdef SSL_DEBUG\n    printf(\"which = %04X\\nkey=\", which);\n    {\n        int z;\n        for (z = 0; z < EVP_CIPHER_key_length(c); z++)\n            printf(\"%02X%c\", key[z], ((z + 1) % 16) ? ' ' : '\\n');\n    }\n    printf(\"\\niv=\");\n    {\n        int z;\n        for (z = 0; z < k; z++)\n            printf(\"%02X%c\", iv[z], ((z + 1) % 16) ? ' ' : '\\n');\n    }\n    printf(\"\\n\");\n#endif\n\n    OPENSSL_cleanse(tmp1, sizeof(tmp1));\n    OPENSSL_cleanse(tmp2, sizeof(tmp1));\n    OPENSSL_cleanse(iv1, sizeof(iv1));\n    OPENSSL_cleanse(iv2, sizeof(iv2));\n    return (1);\n err:\n    SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE, ERR_R_MALLOC_FAILURE);\n err2:\n    OPENSSL_cleanse(tmp1, sizeof(tmp1));\n    OPENSSL_cleanse(tmp2, sizeof(tmp1));\n    OPENSSL_cleanse(iv1, sizeof(iv1));\n    OPENSSL_cleanse(iv2, sizeof(iv2));\n    return (0);\n}",
        "target": 0
    },
    {
        "func": "int tls12_get_sigid(const EVP_PKEY *pk)\n{\n    return tls12_find_id(EVP_PKEY_id(pk), tls12_sig, OSSL_NELEM(tls12_sig));\n}",
        "target": 0
    },
    {
        "func": "int ssl_prepare_clienthello_tlsext(SSL *s)\n{\n    s->s3->alpn_sent = 0;\n    return 1;\n}",
        "target": 0
    },
    {
        "func": "size_t tls12_copy_sigalgs(SSL *s, unsigned char *out,\n                          const unsigned char *psig, size_t psiglen)\n{\n    unsigned char *tmpout = out;\n    size_t i;\n    for (i = 0; i < psiglen; i += 2, psig += 2) {\n        if (tls12_sigalg_allowed(s, SSL_SECOP_SIGALG_SUPPORTED, psig)) {\n            *tmpout++ = psig[0];\n            *tmpout++ = psig[1];\n        }\n    }\n    return tmpout - out;\n}",
        "target": 0
    },
    {
        "func": "static int tls1_get_curvelist(SSL *s, int sess,\n                              const unsigned char **pcurves, size_t *num_curves)\n{\n    size_t pcurveslen = 0;\n\n    if (sess) {\n        *pcurves = s->session->tlsext_ellipticcurvelist;\n        pcurveslen = s->session->tlsext_ellipticcurvelist_length;\n    } else {\n        /* For Suite B mode only include P-256, P-384 */\n        switch (tls1_suiteb(s)) {\n        case SSL_CERT_FLAG_SUITEB_128_LOS:\n            *pcurves = suiteb_curves;\n            pcurveslen = sizeof(suiteb_curves);\n            break;\n\n        case SSL_CERT_FLAG_SUITEB_128_LOS_ONLY:\n            *pcurves = suiteb_curves;\n            pcurveslen = 2;\n            break;\n\n        case SSL_CERT_FLAG_SUITEB_192_LOS:\n            *pcurves = suiteb_curves + 2;\n            pcurveslen = 2;\n            break;\n        default:\n            *pcurves = s->tlsext_ellipticcurvelist;\n            pcurveslen = s->tlsext_ellipticcurvelist_length;\n        }\n        if (!*pcurves) {\n            *pcurves = eccurves_default;\n            pcurveslen = sizeof(eccurves_default);\n        }\n    }\n\n    /* We do not allow odd length arrays to enter the system. */\n    if (pcurveslen & 1) {\n        SSLerr(SSL_F_TLS1_GET_CURVELIST, ERR_R_INTERNAL_ERROR);\n        *num_curves = 0;\n        return 0;\n    }\n    *num_curves = pcurveslen / 2;\n    return 1;\n}",
        "target": 0
    },
    {
        "func": "static void get_sigorhash(int *psig, int *phash, const char *str)\n{\n    if (strcmp(str, \"RSA\") == 0) {\n        *psig = EVP_PKEY_RSA;\n    } else if (strcmp(str, \"DSA\") == 0) {\n        *psig = EVP_PKEY_DSA;\n    } else if (strcmp(str, \"ECDSA\") == 0) {\n        *psig = EVP_PKEY_EC;\n    } else {\n        *phash = OBJ_sn2nid(str);\n        if (*phash == NID_undef)\n            *phash = OBJ_ln2nid(str);\n    }\n}",
        "target": 0
    },
    {
        "func": "static int tls1_set_shared_sigalgs(SSL *s)\n{\n    const unsigned char *pref, *allow, *conf;\n    size_t preflen, allowlen, conflen;\n    size_t nmatch;\n    TLS_SIGALGS *salgs = NULL;\n    CERT *c = s->cert;\n    unsigned int is_suiteb = tls1_suiteb(s);\n\n    OPENSSL_free(c->shared_sigalgs);\n    c->shared_sigalgs = NULL;\n    c->shared_sigalgslen = 0;\n    /* If client use client signature algorithms if not NULL */\n    if (!s->server && c->client_sigalgs && !is_suiteb) {\n        conf = c->client_sigalgs;\n        conflen = c->client_sigalgslen;\n    } else if (c->conf_sigalgs && !is_suiteb) {\n        conf = c->conf_sigalgs;\n        conflen = c->conf_sigalgslen;\n    } else\n        conflen = tls12_get_psigalgs(s, 0, &conf);\n    if (s->options & SSL_OP_CIPHER_SERVER_PREFERENCE || is_suiteb) {\n        pref = conf;\n        preflen = conflen;\n        allow = s->s3->tmp.peer_sigalgs;\n        allowlen = s->s3->tmp.peer_sigalgslen;\n    } else {\n        allow = conf;\n        allowlen = conflen;\n        pref = s->s3->tmp.peer_sigalgs;\n        preflen = s->s3->tmp.peer_sigalgslen;\n    }\n    nmatch = tls12_shared_sigalgs(s, NULL, pref, preflen, allow, allowlen);\n    if (nmatch) {\n        salgs = OPENSSL_malloc(nmatch * sizeof(TLS_SIGALGS));\n        if (salgs == NULL)\n            return 0;\n        nmatch = tls12_shared_sigalgs(s, salgs, pref, preflen, allow, allowlen);\n    } else {\n        salgs = NULL;\n    }\n    c->shared_sigalgs = salgs;\n    c->shared_sigalgslen = nmatch;\n    return 1;\n}",
        "target": 0
    },
    {
        "func": "int tls1_set_server_sigalgs(SSL *s)\n{\n    int al;\n    size_t i;\n\n    /* Clear any shared signature algorithms */\n    OPENSSL_free(s->cert->shared_sigalgs);\n    s->cert->shared_sigalgs = NULL;\n    s->cert->shared_sigalgslen = 0;\n    /* Clear certificate digests and validity flags */\n    for (i = 0; i < SSL_PKEY_NUM; i++) {\n        s->s3->tmp.md[i] = NULL;\n        s->s3->tmp.valid_flags[i] = 0;\n    }\n\n    /* If sigalgs received process it. */\n    if (s->s3->tmp.peer_sigalgs) {\n        if (!tls1_process_sigalgs(s)) {\n            SSLerr(SSL_F_TLS1_SET_SERVER_SIGALGS, ERR_R_MALLOC_FAILURE);\n            al = SSL_AD_INTERNAL_ERROR;\n            goto err;\n        }\n        /* Fatal error is no shared signature algorithms */\n        if (!s->cert->shared_sigalgs) {\n            SSLerr(SSL_F_TLS1_SET_SERVER_SIGALGS,\n                   SSL_R_NO_SHARED_SIGNATURE_ALGORITHMS);\n            al = SSL_AD_ILLEGAL_PARAMETER;\n            goto err;\n        }\n    } else {\n        ssl_set_default_md(s);\n    }\n    return 1;\n err:\n    ssl3_send_alert(s, SSL3_AL_FATAL, al);\n    return 0;\n}",
        "target": 0
    },
    {
        "func": "static int tls12_sigalg_allowed(SSL *s, int op, const unsigned char *ptmp)\n{\n    /* See if we have an entry in the hash table and it is enabled */\n    const tls12_hash_info *hinf = tls12_get_hash_info(ptmp[0]);\n    if (hinf == NULL || ssl_md(hinf->md_idx) == NULL)\n        return 0;\n    /* See if public key algorithm allowed */\n    if (tls12_get_pkey_idx(ptmp[1]) == -1)\n        return 0;\n    /* Finally see if security callback allows it */\n    return ssl_security(s, op, hinf->secbits, hinf->nid, (void *)ptmp);\n}",
        "target": 0
    },
    {
        "func": "int tls1_set_curves(unsigned char **pext, size_t *pextlen,\n                    int *curves, size_t ncurves)\n{\n    unsigned char *clist, *p;\n    size_t i;\n    /*\n     * Bitmap of curves included to detect duplicates: only works while curve\n     * ids < 32\n     */\n    unsigned long dup_list = 0;\n    clist = OPENSSL_malloc(ncurves * 2);\n    if (clist == NULL)\n        return 0;\n    for (i = 0, p = clist; i < ncurves; i++) {\n        unsigned long idmask;\n        int id;\n        id = tls1_ec_nid2curve_id(curves[i]);\n        idmask = 1L << id;\n        if (!id || (dup_list & idmask)) {\n            OPENSSL_free(clist);\n            return 0;\n        }\n        dup_list |= idmask;\n        s2n(id, p);\n    }\n    OPENSSL_free(*pext);\n    *pext = clist;\n    *pextlen = ncurves * 2;\n    return 1;\n}",
        "target": 0
    },
    {
        "func": "void SSL3_RECORD_set_seq_num(SSL3_RECORD *r, const unsigned char *seq_num)\n{\n    memcpy(r->seq_num, seq_num, SEQ_NUM_SIZE);\n}",
        "target": 0
    },
    {
        "func": "int n_ssl3_mac(SSL *ssl, SSL3_RECORD *rec, unsigned char *md, int send)\n{\n    unsigned char *mac_sec, *seq;\n    const EVP_MD_CTX *hash;\n    unsigned char *p, rec_char;\n    size_t md_size;\n    int npad;\n    int t;\n\n    if (send) {\n        mac_sec = &(ssl->s3->write_mac_secret[0]);\n        seq = RECORD_LAYER_get_write_sequence(&ssl->rlayer);\n        hash = ssl->write_hash;\n    } else {\n        mac_sec = &(ssl->s3->read_mac_secret[0]);\n        seq = RECORD_LAYER_get_read_sequence(&ssl->rlayer);\n        hash = ssl->read_hash;\n    }\n\n    t = EVP_MD_CTX_size(hash);\n    if (t < 0)\n        return -1;\n    md_size = t;\n    npad = (48 / md_size) * md_size;\n\n    if (!send &&\n        EVP_CIPHER_CTX_mode(ssl->enc_read_ctx) == EVP_CIPH_CBC_MODE &&\n        ssl3_cbc_record_digest_supported(hash)) {\n        /*\n         * This is a CBC-encrypted record. We must avoid leaking any\n         * timing-side channel information about how many blocks of data we\n         * are hashing because that gives an attacker a timing-oracle.\n         */\n\n        /*-\n         * npad is, at most, 48 bytes and that's with MD5:\n         *   16 + 48 + 8 (sequence bytes) + 1 + 2 = 75.\n         *\n         * With SHA-1 (the largest hash speced for SSLv3) the hash size\n         * goes up 4, but npad goes down by 8, resulting in a smaller\n         * total size.\n         */\n        unsigned char header[75];\n        unsigned j = 0;\n        memcpy(header + j, mac_sec, md_size);\n        j += md_size;\n        memcpy(header + j, ssl3_pad_1, npad);\n        j += npad;\n        memcpy(header + j, seq, 8);\n        j += 8;\n        header[j++] = rec->type;\n        header[j++] = rec->length >> 8;\n        header[j++] = rec->length & 0xff;\n\n        /* Final param == is SSLv3 */\n        if (ssl3_cbc_digest_record(hash,\n                                   md, &md_size,\n                                   header, rec->input,\n                                   rec->length + md_size, rec->orig_len,\n                                   mac_sec, md_size, 1) <= 0)\n            return -1;\n    } else {\n        unsigned int md_size_u;\n        /* Chop the digest off the end :-) */\n        EVP_MD_CTX *md_ctx = EVP_MD_CTX_new();\n\n        if (md_ctx == NULL)\n            return -1;\n\n        rec_char = rec->type;\n        p = md;\n        s2n(rec->length, p);\n        if (EVP_MD_CTX_copy_ex(md_ctx, hash) <= 0\n            || EVP_DigestUpdate(md_ctx, mac_sec, md_size) <= 0\n            || EVP_DigestUpdate(md_ctx, ssl3_pad_1, npad) <= 0\n            || EVP_DigestUpdate(md_ctx, seq, 8) <= 0\n            || EVP_DigestUpdate(md_ctx, &rec_char, 1) <= 0\n            || EVP_DigestUpdate(md_ctx, md, 2) <= 0\n            || EVP_DigestUpdate(md_ctx, rec->input, rec->length) <= 0\n            || EVP_DigestFinal_ex(md_ctx, md, NULL) <= 0\n            || EVP_MD_CTX_copy_ex(md_ctx, hash) <= 0\n            || EVP_DigestUpdate(md_ctx, mac_sec, md_size) <= 0\n            || EVP_DigestUpdate(md_ctx, ssl3_pad_2, npad) <= 0\n            || EVP_DigestUpdate(md_ctx, md, md_size) <= 0\n            || EVP_DigestFinal_ex(md_ctx, md, &md_size_u) <= 0) {\n            EVP_MD_CTX_reset(md_ctx);\n            return -1;\n        }\n        md_size = md_size_u;\n\n        EVP_MD_CTX_free(md_ctx);\n    }\n\n    ssl3_record_sequence_update(seq);\n    return (md_size);\n}",
        "target": 0
    },
    {
        "func": "DH *ssl_get_auto_dh(SSL *s)\n{\n    int dh_secbits = 80;\n    if (s->cert->dh_tmp_auto == 2)\n        return DH_get_1024_160();\n    if (s->s3->tmp.new_cipher->algorithm_auth & (SSL_aNULL | SSL_aPSK)) {\n        if (s->s3->tmp.new_cipher->strength_bits == 256)\n            dh_secbits = 128;\n        else\n            dh_secbits = 80;\n    } else {\n        CERT_PKEY *cpk = ssl_get_server_send_pkey(s);\n        dh_secbits = EVP_PKEY_security_bits(cpk->privatekey);\n    }\n\n    if (dh_secbits >= 128) {\n        DH *dhp = DH_new();\n        BIGNUM *p, *g;\n        if (dhp == NULL)\n            return NULL;\n        g = BN_new();\n        if (g != NULL)\n            BN_set_word(g, 2);\n        if (dh_secbits >= 192)\n            p = BN_get_rfc3526_prime_8192(NULL);\n        else\n            p = BN_get_rfc3526_prime_3072(NULL);\n        if (p == NULL || g == NULL || !DH_set0_pqg(dhp, p, NULL, g)) {\n            DH_free(dhp);\n            BN_free(p);\n            BN_free(g);\n            return NULL;\n        }\n        return dhp;\n    }\n    if (dh_secbits >= 112)\n        return DH_get_2048_224();\n    return DH_get_1024_160();\n}",
        "target": 0
    },
    {
        "func": "int tls1_check_chain(SSL *s, X509 *x, EVP_PKEY *pk, STACK_OF(X509) *chain,\n                     int idx)\n{\n    int i;\n    int rv = 0;\n    int check_flags = 0, strict_mode;\n    CERT_PKEY *cpk = NULL;\n    CERT *c = s->cert;\n    uint32_t *pvalid;\n    unsigned int suiteb_flags = tls1_suiteb(s);\n    /* idx == -1 means checking server chains */\n    if (idx != -1) {\n        /* idx == -2 means checking client certificate chains */\n        if (idx == -2) {\n            cpk = c->key;\n            idx = cpk - c->pkeys;\n        } else\n            cpk = c->pkeys + idx;\n        pvalid = s->s3->tmp.valid_flags + idx;\n        x = cpk->x509;\n        pk = cpk->privatekey;\n        chain = cpk->chain;\n        strict_mode = c->cert_flags & SSL_CERT_FLAGS_CHECK_TLS_STRICT;\n        /* If no cert or key, forget it */\n        if (!x || !pk)\n            goto end;\n    } else {\n        if (!x || !pk)\n            return 0;\n        idx = ssl_cert_type(x, pk);\n        if (idx == -1)\n            return 0;\n        pvalid = s->s3->tmp.valid_flags + idx;\n\n        if (c->cert_flags & SSL_CERT_FLAGS_CHECK_TLS_STRICT)\n            check_flags = CERT_PKEY_STRICT_FLAGS;\n        else\n            check_flags = CERT_PKEY_VALID_FLAGS;\n        strict_mode = 1;\n    }\n\n    if (suiteb_flags) {\n        int ok;\n        if (check_flags)\n            check_flags |= CERT_PKEY_SUITEB;\n        ok = X509_chain_check_suiteb(NULL, x, chain, suiteb_flags);\n        if (ok == X509_V_OK)\n            rv |= CERT_PKEY_SUITEB;\n        else if (!check_flags)\n            goto end;\n    }\n\n    /*\n     * Check all signature algorithms are consistent with signature\n     * algorithms extension if TLS 1.2 or later and strict mode.\n     */\n    if (TLS1_get_version(s) >= TLS1_2_VERSION && strict_mode) {\n        int default_nid;\n        unsigned char rsign = 0;\n        if (s->s3->tmp.peer_sigalgs)\n            default_nid = 0;\n        /* If no sigalgs extension use defaults from RFC5246 */\n        else {\n            switch (idx) {\n            case SSL_PKEY_RSA_ENC:\n            case SSL_PKEY_RSA_SIGN:\n                rsign = TLSEXT_signature_rsa;\n                default_nid = NID_sha1WithRSAEncryption;\n                break;\n\n            case SSL_PKEY_DSA_SIGN:\n                rsign = TLSEXT_signature_dsa;\n                default_nid = NID_dsaWithSHA1;\n                break;\n\n            case SSL_PKEY_ECC:\n                rsign = TLSEXT_signature_ecdsa;\n                default_nid = NID_ecdsa_with_SHA1;\n                break;\n\n            case SSL_PKEY_GOST01:\n                rsign = TLSEXT_signature_gostr34102001;\n                default_nid = NID_id_GostR3411_94_with_GostR3410_2001;\n                break;\n\n            case SSL_PKEY_GOST12_256:\n                rsign = TLSEXT_signature_gostr34102012_256;\n                default_nid = NID_id_tc26_signwithdigest_gost3410_2012_256;\n                break;\n\n            case SSL_PKEY_GOST12_512:\n                rsign = TLSEXT_signature_gostr34102012_512;\n                default_nid = NID_id_tc26_signwithdigest_gost3410_2012_512;\n                break;\n\n            default:\n                default_nid = -1;\n                break;\n            }\n        }\n        /*\n         * If peer sent no signature algorithms extension and we have set\n         * preferred signature algorithms check we support sha1.\n         */\n        if (default_nid > 0 && c->conf_sigalgs) {\n            size_t j;\n            const unsigned char *p = c->conf_sigalgs;\n            for (j = 0; j < c->conf_sigalgslen; j += 2, p += 2) {\n                if (p[0] == TLSEXT_hash_sha1 && p[1] == rsign)\n                    break;\n            }\n            if (j == c->conf_sigalgslen) {\n                if (check_flags)\n                    goto skip_sigs;\n                else\n                    goto end;\n            }\n        }\n        /* Check signature algorithm of each cert in chain */\n        if (!tls1_check_sig_alg(c, x, default_nid)) {\n            if (!check_flags)\n                goto end;\n        } else\n            rv |= CERT_PKEY_EE_SIGNATURE;\n        rv |= CERT_PKEY_CA_SIGNATURE;\n        for (i = 0; i < sk_X509_num(chain); i++) {\n            if (!tls1_check_sig_alg(c, sk_X509_value(chain, i), default_nid)) {\n                if (check_flags) {\n                    rv &= ~CERT_PKEY_CA_SIGNATURE;\n                    break;\n                } else\n                    goto end;\n            }\n        }\n    }\n    /* Else not TLS 1.2, so mark EE and CA signing algorithms OK */\n    else if (check_flags)\n        rv |= CERT_PKEY_EE_SIGNATURE | CERT_PKEY_CA_SIGNATURE;\n skip_sigs:\n    /* Check cert parameters are consistent */\n    if (tls1_check_cert_param(s, x, check_flags ? 1 : 2))\n        rv |= CERT_PKEY_EE_PARAM;\n    else if (!check_flags)\n        goto end;\n    if (!s->server)\n        rv |= CERT_PKEY_CA_PARAM;\n    /* In strict mode check rest of chain too */\n    else if (strict_mode) {\n        rv |= CERT_PKEY_CA_PARAM;\n        for (i = 0; i < sk_X509_num(chain); i++) {\n            X509 *ca = sk_X509_value(chain, i);\n            if (!tls1_check_cert_param(s, ca, 0)) {\n                if (check_flags) {\n                    rv &= ~CERT_PKEY_CA_PARAM;\n                    break;\n                } else\n                    goto end;\n            }\n        }\n    }\n    if (!s->server && strict_mode) {\n        STACK_OF(X509_NAME) *ca_dn;\n        int check_type = 0;\n        switch (EVP_PKEY_id(pk)) {\n        case EVP_PKEY_RSA:\n            check_type = TLS_CT_RSA_SIGN;\n            break;\n        case EVP_PKEY_DSA:\n            check_type = TLS_CT_DSS_SIGN;\n            break;\n        case EVP_PKEY_EC:\n            check_type = TLS_CT_ECDSA_SIGN;\n            break;\n        }\n        if (check_type) {\n            const unsigned char *ctypes;\n            int ctypelen;\n            if (c->ctypes) {\n                ctypes = c->ctypes;\n                ctypelen = (int)c->ctype_num;\n            } else {\n                ctypes = (unsigned char *)s->s3->tmp.ctype;\n                ctypelen = s->s3->tmp.ctype_num;\n            }\n            for (i = 0; i < ctypelen; i++) {\n                if (ctypes[i] == check_type) {\n                    rv |= CERT_PKEY_CERT_TYPE;\n                    break;\n                }\n            }\n            if (!(rv & CERT_PKEY_CERT_TYPE) && !check_flags)\n                goto end;\n        } else\n            rv |= CERT_PKEY_CERT_TYPE;\n\n        ca_dn = s->s3->tmp.ca_names;\n\n        if (!sk_X509_NAME_num(ca_dn))\n            rv |= CERT_PKEY_ISSUER_NAME;\n\n        if (!(rv & CERT_PKEY_ISSUER_NAME)) {\n            if (ssl_check_ca_name(ca_dn, x))\n                rv |= CERT_PKEY_ISSUER_NAME;\n        }\n        if (!(rv & CERT_PKEY_ISSUER_NAME)) {\n            for (i = 0; i < sk_X509_num(chain); i++) {\n                X509 *xtmp = sk_X509_value(chain, i);\n                if (ssl_check_ca_name(ca_dn, xtmp)) {\n                    rv |= CERT_PKEY_ISSUER_NAME;\n                    break;\n                }\n            }\n        }\n        if (!check_flags && !(rv & CERT_PKEY_ISSUER_NAME))\n            goto end;\n    } else\n        rv |= CERT_PKEY_ISSUER_NAME | CERT_PKEY_CERT_TYPE;\n\n    if (!check_flags || (rv & check_flags) == check_flags)\n        rv |= CERT_PKEY_VALID;\n\n end:\n\n    if (TLS1_get_version(s) >= TLS1_2_VERSION) {\n        if (*pvalid & CERT_PKEY_EXPLICIT_SIGN)\n            rv |= CERT_PKEY_EXPLICIT_SIGN | CERT_PKEY_SIGN;\n        else if (s->s3->tmp.md[idx] != NULL)\n            rv |= CERT_PKEY_SIGN;\n    } else\n        rv |= CERT_PKEY_SIGN | CERT_PKEY_EXPLICIT_SIGN;\n\n    /*\n     * When checking a CERT_PKEY structure all flags are irrelevant if the\n     * chain is invalid.\n     */\n    if (!check_flags) {\n        if (rv & CERT_PKEY_VALID)\n            *pvalid = rv;\n        else {\n            /* Preserve explicit sign flag, clear rest */\n            *pvalid &= CERT_PKEY_EXPLICIT_SIGN;\n            return 0;\n        }\n    }\n    return rv;\n}",
        "target": 0
    },
    {
        "func": "static int sig_cb(const char *elem, int len, void *arg)\n{\n    sig_cb_st *sarg = arg;\n    size_t i;\n    char etmp[20], *p;\n    int sig_alg = NID_undef, hash_alg = NID_undef;\n    if (elem == NULL)\n        return 0;\n    if (sarg->sigalgcnt == MAX_SIGALGLEN)\n        return 0;\n    if (len > (int)(sizeof(etmp) - 1))\n        return 0;\n    memcpy(etmp, elem, len);\n    etmp[len] = 0;\n    p = strchr(etmp, '+');\n    if (!p)\n        return 0;\n    *p = 0;\n    p++;\n    if (!*p)\n        return 0;\n\n    get_sigorhash(&sig_alg, &hash_alg, etmp);\n    get_sigorhash(&sig_alg, &hash_alg, p);\n\n    if (sig_alg == NID_undef || hash_alg == NID_undef)\n        return 0;\n\n    for (i = 0; i < sarg->sigalgcnt; i += 2) {\n        if (sarg->sigalgs[i] == sig_alg && sarg->sigalgs[i + 1] == hash_alg)\n            return 0;\n    }\n    sarg->sigalgs[sarg->sigalgcnt++] = hash_alg;\n    sarg->sigalgs[sarg->sigalgcnt++] = sig_alg;\n    return 1;\n}",
        "target": 0
    },
    {
        "func": "const EVP_MD *tls12_get_hash(unsigned char hash_alg)\n{\n    const tls12_hash_info *inf;\n    if (hash_alg == TLSEXT_hash_md5 && FIPS_mode())\n        return NULL;\n    inf = tls12_get_hash_info(hash_alg);\n    if (!inf)\n        return NULL;\n    return ssl_md(inf->md_idx);\n}",
        "target": 0
    },
    {
        "func": "static int tls12_find_nid(int id, const tls12_lookup *table, size_t tlen)\n{\n    size_t i;\n    for (i = 0; i < tlen; i++) {\n        if ((table[i].id) == id)\n            return table[i].nid;\n    }\n    return NID_undef;\n}",
        "target": 0
    },
    {
        "func": "int dtls1_get_record(SSL *s)\n{\n    int ssl_major, ssl_minor;\n    int i, n;\n    SSL3_RECORD *rr;\n    unsigned char *p = NULL;\n    unsigned short version;\n    DTLS1_BITMAP *bitmap;\n    unsigned int is_next_epoch;\n\n    rr = RECORD_LAYER_get_rrec(&s->rlayer);\n\n again:\n    /*\n     * The epoch may have changed.  If so, process all the pending records.\n     * This is a non-blocking operation.\n     */\n    if (!dtls1_process_buffered_records(s))\n        return -1;\n\n    /* if we're renegotiating, then there may be buffered records */\n    if (dtls1_get_processed_record(s))\n        return 1;\n\n    /* get something from the wire */\n\n    /* check if we have the header */\n    if ((RECORD_LAYER_get_rstate(&s->rlayer) != SSL_ST_READ_BODY) ||\n        (RECORD_LAYER_get_packet_length(&s->rlayer) < DTLS1_RT_HEADER_LENGTH)) {\n        n = ssl3_read_n(s, DTLS1_RT_HEADER_LENGTH,\n                        SSL3_BUFFER_get_len(&s->rlayer.rbuf), 0, 1);\n        /* read timeout is handled by dtls1_read_bytes */\n        if (n <= 0)\n            return (n);         /* error or non-blocking */\n\n        /* this packet contained a partial record, dump it */\n        if (RECORD_LAYER_get_packet_length(&s->rlayer) !=\n            DTLS1_RT_HEADER_LENGTH) {\n            RECORD_LAYER_reset_packet_length(&s->rlayer);\n            goto again;\n        }\n\n        RECORD_LAYER_set_rstate(&s->rlayer, SSL_ST_READ_BODY);\n\n        p = RECORD_LAYER_get_packet(&s->rlayer);\n\n        if (s->msg_callback)\n            s->msg_callback(0, 0, SSL3_RT_HEADER, p, DTLS1_RT_HEADER_LENGTH,\n                            s, s->msg_callback_arg);\n\n        /* Pull apart the header into the DTLS1_RECORD */\n        rr->type = *(p++);\n        ssl_major = *(p++);\n        ssl_minor = *(p++);\n        version = (ssl_major << 8) | ssl_minor;\n\n        /* sequence number is 64 bits, with top 2 bytes = epoch */\n        n2s(p, rr->epoch);\n\n        memcpy(&(RECORD_LAYER_get_read_sequence(&s->rlayer)[2]), p, 6);\n        p += 6;\n\n        n2s(p, rr->length);\n\n        /* Lets check version */\n        if (!s->first_packet) {\n            if (version != s->version) {\n                /* unexpected version, silently discard */\n                rr->length = 0;\n                RECORD_LAYER_reset_packet_length(&s->rlayer);\n                goto again;\n            }\n        }\n\n        if ((version & 0xff00) != (s->version & 0xff00)) {\n            /* wrong version, silently discard record */\n            rr->length = 0;\n            RECORD_LAYER_reset_packet_length(&s->rlayer);\n            goto again;\n        }\n\n        if (rr->length > SSL3_RT_MAX_ENCRYPTED_LENGTH) {\n            /* record too long, silently discard it */\n            rr->length = 0;\n            RECORD_LAYER_reset_packet_length(&s->rlayer);\n            goto again;\n        }\n\n        /* now s->rlayer.rstate == SSL_ST_READ_BODY */\n    }\n\n    /* s->rlayer.rstate == SSL_ST_READ_BODY, get and decode the data */\n\n    if (rr->length >\n        RECORD_LAYER_get_packet_length(&s->rlayer) - DTLS1_RT_HEADER_LENGTH) {\n        /* now s->packet_length == DTLS1_RT_HEADER_LENGTH */\n        i = rr->length;\n        n = ssl3_read_n(s, i, i, 1, 1);\n        /* this packet contained a partial record, dump it */\n        if (n != i) {\n            rr->length = 0;\n            RECORD_LAYER_reset_packet_length(&s->rlayer);\n            goto again;\n        }\n\n        /*\n         * now n == rr->length, and s->packet_length ==\n         * DTLS1_RT_HEADER_LENGTH + rr->length\n         */\n    }\n    /* set state for later operations */\n    RECORD_LAYER_set_rstate(&s->rlayer, SSL_ST_READ_HEADER);\n\n    /* match epochs.  NULL means the packet is dropped on the floor */\n    bitmap = dtls1_get_bitmap(s, rr, &is_next_epoch);\n    if (bitmap == NULL) {\n        rr->length = 0;\n        RECORD_LAYER_reset_packet_length(&s->rlayer); /* dump this record */\n        goto again;             /* get another record */\n    }\n#ifndef OPENSSL_NO_SCTP\n    /* Only do replay check if no SCTP bio */\n    if (!BIO_dgram_is_sctp(SSL_get_rbio(s))) {\n#endif\n        /* Check whether this is a repeat, or aged record. */\n        /*\n         * TODO: Does it make sense to have replay protection in epoch 0 where\n         * we have no integrity negotiated yet?\n         */\n        if (!dtls1_record_replay_check(s, bitmap)) {\n            rr->length = 0;\n            RECORD_LAYER_reset_packet_length(&s->rlayer); /* dump this record */\n            goto again;         /* get another record */\n        }\n#ifndef OPENSSL_NO_SCTP\n    }\n#endif\n\n    /* just read a 0 length packet */\n    if (rr->length == 0)\n        goto again;\n\n    /*\n     * If this record is from the next epoch (either HM or ALERT), and a\n     * handshake is currently in progress, buffer it since it cannot be\n     * processed at this time.\n     */\n    if (is_next_epoch) {\n        if ((SSL_in_init(s) || ossl_statem_get_in_handshake(s))) {\n            if (dtls1_buffer_record\n                (s, &(DTLS_RECORD_LAYER_get_unprocessed_rcds(&s->rlayer)),\n                 rr->seq_num) < 0)\n                return -1;\n        }\n        rr->length = 0;\n        RECORD_LAYER_reset_packet_length(&s->rlayer);\n        goto again;\n    }\n\n    if (!dtls1_process_record(s, bitmap)) {\n        rr->length = 0;\n        RECORD_LAYER_reset_packet_length(&s->rlayer); /* dump this record */\n        goto again;             /* get another record */\n    }\n\n    return (1);\n\n}",
        "target": 0
    },
    {
        "func": "int tls12_check_peer_sigalg(const EVP_MD **pmd, SSL *s,\n                            const unsigned char *sig, EVP_PKEY *pkey)\n{\n    const unsigned char *sent_sigs;\n    size_t sent_sigslen, i;\n    int sigalg = tls12_get_sigid(pkey);\n    /* Should never happen */\n    if (sigalg == -1)\n        return -1;\n    /* Check key type is consistent with signature */\n    if (sigalg != (int)sig[1]) {\n        SSLerr(SSL_F_TLS12_CHECK_PEER_SIGALG, SSL_R_WRONG_SIGNATURE_TYPE);\n        return 0;\n    }\n#ifndef OPENSSL_NO_EC\n    if (EVP_PKEY_id(pkey) == EVP_PKEY_EC) {\n        unsigned char curve_id[2], comp_id;\n        /* Check compression and curve matches extensions */\n        if (!tls1_set_ec_id(curve_id, &comp_id, EVP_PKEY_get0_EC_KEY(pkey)))\n            return 0;\n        if (!s->server && !tls1_check_ec_key(s, curve_id, &comp_id)) {\n            SSLerr(SSL_F_TLS12_CHECK_PEER_SIGALG, SSL_R_WRONG_CURVE);\n            return 0;\n        }\n        /* If Suite B only P-384+SHA384 or P-256+SHA-256 allowed */\n        if (tls1_suiteb(s)) {\n            if (curve_id[0])\n                return 0;\n            if (curve_id[1] == TLSEXT_curve_P_256) {\n                if (sig[0] != TLSEXT_hash_sha256) {\n                    SSLerr(SSL_F_TLS12_CHECK_PEER_SIGALG,\n                           SSL_R_ILLEGAL_SUITEB_DIGEST);\n                    return 0;\n                }\n            } else if (curve_id[1] == TLSEXT_curve_P_384) {\n                if (sig[0] != TLSEXT_hash_sha384) {\n                    SSLerr(SSL_F_TLS12_CHECK_PEER_SIGALG,\n                           SSL_R_ILLEGAL_SUITEB_DIGEST);\n                    return 0;\n                }\n            } else\n                return 0;\n        }\n    } else if (tls1_suiteb(s))\n        return 0;\n#endif\n\n    /* Check signature matches a type we sent */\n    sent_sigslen = tls12_get_psigalgs(s, 1, &sent_sigs);\n    for (i = 0; i < sent_sigslen; i += 2, sent_sigs += 2) {\n        if (sig[0] == sent_sigs[0] && sig[1] == sent_sigs[1])\n            break;\n    }\n    /* Allow fallback to SHA1 if not strict mode */\n    if (i == sent_sigslen\n        && (sig[0] != TLSEXT_hash_sha1\n            || s->cert->cert_flags & SSL_CERT_FLAGS_CHECK_TLS_STRICT)) {\n        SSLerr(SSL_F_TLS12_CHECK_PEER_SIGALG, SSL_R_WRONG_SIGNATURE_TYPE);\n        return 0;\n    }\n    *pmd = tls12_get_hash(sig[0]);\n    if (*pmd == NULL) {\n        SSLerr(SSL_F_TLS12_CHECK_PEER_SIGALG, SSL_R_UNKNOWN_DIGEST);\n        return 0;\n    }\n    /* Make sure security callback allows algorithm */\n    if (!ssl_security(s, SSL_SECOP_SIGALG_CHECK,\n                      EVP_MD_size(*pmd) * 4, EVP_MD_type(*pmd), (void *)sig)) {\n        SSLerr(SSL_F_TLS12_CHECK_PEER_SIGALG, SSL_R_WRONG_SIGNATURE_TYPE);\n        return 0;\n    }\n    /*\n     * Store the digest used so applications can retrieve it if they wish.\n     */\n    s->s3->tmp.peer_md = *pmd;\n    return 1;\n}",
        "target": 0
    },
    {
        "func": "static char ssl_next_proto_validate(PACKET *pkt)\n{\n    PACKET tmp_protocol;\n\n    while (PACKET_remaining(pkt)) {\n        if (!PACKET_get_length_prefixed_1(pkt, &tmp_protocol)\n            || PACKET_remaining(&tmp_protocol) == 0)\n            return 0;\n    }\n\n    return 1;\n}",
        "target": 0
    },
    {
        "func": "static const tls12_hash_info *tls12_get_hash_info(unsigned char hash_alg)\n{\n    unsigned int i;\n    if (hash_alg == 0)\n        return NULL;\n\n    for (i = 0; i < OSSL_NELEM(tls12_md_info); i++) {\n        if (tls12_md_info[i].tlsext_hash == hash_alg)\n            return tls12_md_info + i;\n    }\n\n    return NULL;\n}",
        "target": 0
    },
    {
        "func": "static int tls12_shared_sigalgs(SSL *s, TLS_SIGALGS *shsig,\n                                const unsigned char *pref, size_t preflen,\n                                const unsigned char *allow, size_t allowlen)\n{\n    const unsigned char *ptmp, *atmp;\n    size_t i, j, nmatch = 0;\n    for (i = 0, ptmp = pref; i < preflen; i += 2, ptmp += 2) {\n        /* Skip disabled hashes or signature algorithms */\n        if (!tls12_sigalg_allowed(s, SSL_SECOP_SIGALG_SHARED, ptmp))\n            continue;\n        for (j = 0, atmp = allow; j < allowlen; j += 2, atmp += 2) {\n            if (ptmp[0] == atmp[0] && ptmp[1] == atmp[1]) {\n                nmatch++;\n                if (shsig) {\n                    shsig->rhash = ptmp[0];\n                    shsig->rsign = ptmp[1];\n                    tls1_lookup_sigalg(&shsig->hash_nid,\n                                       &shsig->sign_nid,\n                                       &shsig->signandhash_nid, ptmp);\n                    shsig++;\n                }\n                break;\n            }\n        }\n    }\n    return nmatch;\n}",
        "target": 0
    },
    {
        "func": "int ssl3_do_compress(SSL *ssl, SSL3_RECORD *wr)\n{\n#ifndef OPENSSL_NO_COMP\n    int i;\n\n    i = COMP_compress_block(ssl->compress, wr->data,\n                            SSL3_RT_MAX_COMPRESSED_LENGTH,\n                            wr->input, (int)wr->length);\n    if (i < 0)\n        return (0);\n    else\n        wr->length = i;\n\n    wr->input = wr->data;\n#endif\n    return (1);\n}",
        "target": 0
    },
    {
        "func": "int ssl3_get_record(SSL *s)\n{\n    int ssl_major, ssl_minor, al;\n    int enc_err, n, i, ret = -1;\n    SSL3_RECORD *rr;\n    SSL3_BUFFER *rbuf;\n    SSL_SESSION *sess;\n    unsigned char *p;\n    unsigned char md[EVP_MAX_MD_SIZE];\n    short version;\n    unsigned mac_size;\n    unsigned int num_recs = 0;\n    unsigned int max_recs;\n    unsigned int j;\n\n    rr = RECORD_LAYER_get_rrec(&s->rlayer);\n    rbuf = RECORD_LAYER_get_rbuf(&s->rlayer);\n    max_recs = s->max_pipelines;\n    if (max_recs == 0)\n        max_recs = 1;\n    sess = s->session;\n\n    do {\n        /* check if we have the header */\n        if ((RECORD_LAYER_get_rstate(&s->rlayer) != SSL_ST_READ_BODY) ||\n            (RECORD_LAYER_get_packet_length(&s->rlayer)\n             < SSL3_RT_HEADER_LENGTH)) {\n            n = ssl3_read_n(s, SSL3_RT_HEADER_LENGTH,\n                            SSL3_BUFFER_get_len(rbuf), 0,\n                            num_recs == 0 ? 1 : 0);\n            if (n <= 0)\n                return (n);     /* error or non-blocking */\n            RECORD_LAYER_set_rstate(&s->rlayer, SSL_ST_READ_BODY);\n\n            p = RECORD_LAYER_get_packet(&s->rlayer);\n\n            /*\n             * The first record received by the server may be a V2ClientHello.\n             */\n            if (s->server && RECORD_LAYER_is_first_record(&s->rlayer)\n                && (p[0] & 0x80) && (p[2] == SSL2_MT_CLIENT_HELLO)) {\n                /*\n                 *  SSLv2 style record\n                 *\n                 * |num_recs| here will actually always be 0 because\n                 * |num_recs > 0| only ever occurs when we are processing\n                 * multiple app data records - which we know isn't the case here\n                 * because it is an SSLv2ClientHello. We keep it using\n                 * |num_recs| for the sake of consistency\n                 */\n                rr[num_recs].type = SSL3_RT_HANDSHAKE;\n                rr[num_recs].rec_version = SSL2_VERSION;\n\n                rr[num_recs].length = ((p[0] & 0x7f) << 8) | p[1];\n\n                if (rr[num_recs].length > SSL3_BUFFER_get_len(rbuf)\n                    - SSL2_RT_HEADER_LENGTH) {\n                    al = SSL_AD_RECORD_OVERFLOW;\n                    SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_PACKET_LENGTH_TOO_LONG);\n                    goto f_err;\n                }\n\n                if (rr[num_recs].length < MIN_SSL2_RECORD_LEN) {\n                    al = SSL_AD_HANDSHAKE_FAILURE;\n                    SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_LENGTH_TOO_SHORT);\n                    goto f_err;\n                }\n            } else {\n                /* SSLv3+ style record */\n                if (s->msg_callback)\n                    s->msg_callback(0, 0, SSL3_RT_HEADER, p, 5, s,\n                                    s->msg_callback_arg);\n\n                /* Pull apart the header into the SSL3_RECORD */\n                rr[num_recs].type = *(p++);\n                ssl_major = *(p++);\n                ssl_minor = *(p++);\n                version = (ssl_major << 8) | ssl_minor;\n                rr[num_recs].rec_version = version;\n                n2s(p, rr[num_recs].length);\n\n                /* Lets check version */\n                if (!s->first_packet && version != s->version) {\n                    SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_WRONG_VERSION_NUMBER);\n                    if ((s->version & 0xFF00) == (version & 0xFF00)\n                        && !s->enc_write_ctx && !s->write_hash) {\n                        if (rr->type == SSL3_RT_ALERT) {\n                            /*\n                             * The record is using an incorrect version number,\n                             * but what we've got appears to be an alert. We\n                             * haven't read the body yet to check whether its a\n                             * fatal or not - but chances are it is. We probably\n                             * shouldn't send a fatal alert back. We'll just\n                             * end.\n                             */\n                            goto err;\n                        }\n                        /*\n                         * Send back error using their minor version number :-)\n                         */\n                        s->version = (unsigned short)version;\n                    }\n                    al = SSL_AD_PROTOCOL_VERSION;\n                    goto f_err;\n                }\n\n                if ((version >> 8) != SSL3_VERSION_MAJOR) {\n                    if (RECORD_LAYER_is_first_record(&s->rlayer)) {\n                        /* Go back to start of packet, look at the five bytes\n                         * that we have. */\n                        p = RECORD_LAYER_get_packet(&s->rlayer);\n                        if (strncmp((char *)p, \"GET \", 4) == 0 ||\n                            strncmp((char *)p, \"POST \", 5) == 0 ||\n                            strncmp((char *)p, \"HEAD \", 5) == 0 ||\n                            strncmp((char *)p, \"PUT \", 4) == 0) {\n                            SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_HTTP_REQUEST);\n                            goto err;\n                        } else if (strncmp((char *)p, \"CONNE\", 5) == 0) {\n                            SSLerr(SSL_F_SSL3_GET_RECORD,\n                                   SSL_R_HTTPS_PROXY_REQUEST);\n                            goto err;\n                        }\n\n                        /* Doesn't look like TLS - don't send an alert */\n                        SSLerr(SSL_F_SSL3_GET_RECORD,\n                               SSL_R_WRONG_VERSION_NUMBER);\n                        goto err;\n                    } else {\n                        SSLerr(SSL_F_SSL3_GET_RECORD,\n                               SSL_R_WRONG_VERSION_NUMBER);\n                        al = SSL_AD_PROTOCOL_VERSION;\n                        goto f_err;\n                    }\n                }\n\n                if (rr[num_recs].length >\n                    SSL3_BUFFER_get_len(rbuf) - SSL3_RT_HEADER_LENGTH) {\n                    al = SSL_AD_RECORD_OVERFLOW;\n                    SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_PACKET_LENGTH_TOO_LONG);\n                    goto f_err;\n                }\n            }\n\n            /* now s->rlayer.rstate == SSL_ST_READ_BODY */\n        }\n\n        /*\n         * s->rlayer.rstate == SSL_ST_READ_BODY, get and decode the data.\n         * Calculate how much more data we need to read for the rest of the\n         * record\n         */\n        if (rr[num_recs].rec_version == SSL2_VERSION) {\n            i = rr[num_recs].length + SSL2_RT_HEADER_LENGTH\n                - SSL3_RT_HEADER_LENGTH;\n        } else {\n            i = rr[num_recs].length;\n        }\n        if (i > 0) {\n            /* now s->packet_length == SSL3_RT_HEADER_LENGTH */\n\n            n = ssl3_read_n(s, i, i, 1, 0);\n            if (n <= 0)\n                return (n);     /* error or non-blocking io */\n        }\n\n        /* set state for later operations */\n        RECORD_LAYER_set_rstate(&s->rlayer, SSL_ST_READ_HEADER);\n\n        /*\n         * At this point, s->packet_length == SSL3_RT_HEADER_LENGTH + rr->length,\n         * or s->packet_length == SSL2_RT_HEADER_LENGTH + rr->length\n         * and we have that many bytes in s->packet\n         */\n        if (rr[num_recs].rec_version == SSL2_VERSION) {\n            rr[num_recs].input =\n                &(RECORD_LAYER_get_packet(&s->rlayer)[SSL2_RT_HEADER_LENGTH]);\n        } else {\n            rr[num_recs].input =\n                &(RECORD_LAYER_get_packet(&s->rlayer)[SSL3_RT_HEADER_LENGTH]);\n        }\n\n        /*\n         * ok, we can now read from 's->packet' data into 'rr' rr->input points\n         * at rr->length bytes, which need to be copied into rr->data by either\n         * the decryption or by the decompression When the data is 'copied' into\n         * the rr->data buffer, rr->input will be pointed at the new buffer\n         */\n\n        /*\n         * We now have - encrypted [ MAC [ compressed [ plain ] ] ] rr->length\n         * bytes of encrypted compressed stuff.\n         */\n\n        /* check is not needed I believe */\n        if (rr[num_recs].length > SSL3_RT_MAX_ENCRYPTED_LENGTH) {\n            al = SSL_AD_RECORD_OVERFLOW;\n            SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_ENCRYPTED_LENGTH_TOO_LONG);\n            goto f_err;\n        }\n\n        /* decrypt in place in 'rr->input' */\n        rr[num_recs].data = rr[num_recs].input;\n        rr[num_recs].orig_len = rr[num_recs].length;\n\n        /* Mark this record as not read by upper layers yet */\n        rr[num_recs].read = 0;\n\n        num_recs++;\n\n        /* we have pulled in a full packet so zero things */\n        RECORD_LAYER_reset_packet_length(&s->rlayer);\n        RECORD_LAYER_clear_first_record(&s->rlayer);\n    } while (num_recs < max_recs\n             && rr[num_recs - 1].type == SSL3_RT_APPLICATION_DATA\n             && SSL_USE_EXPLICIT_IV(s)\n             && s->enc_read_ctx != NULL\n             && (EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(s->enc_read_ctx))\n                 & EVP_CIPH_FLAG_PIPELINE)\n             && ssl3_record_app_data_waiting(s));\n\n    /*\n     * If in encrypt-then-mac mode calculate mac from encrypted record. All\n     * the details below are public so no timing details can leak.\n     */\n    if (SSL_READ_ETM(s) && s->read_hash) {\n        unsigned char *mac;\n        mac_size = EVP_MD_CTX_size(s->read_hash);\n        OPENSSL_assert(mac_size <= EVP_MAX_MD_SIZE);\n        for (j = 0; j < num_recs; j++) {\n            if (rr[j].length < mac_size) {\n                al = SSL_AD_DECODE_ERROR;\n                SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_LENGTH_TOO_SHORT);\n                goto f_err;\n            }\n            rr[j].length -= mac_size;\n            mac = rr[j].data + rr[j].length;\n            i = s->method->ssl3_enc->mac(s, &rr[j], md, 0 /* not send */ );\n            if (i < 0 || CRYPTO_memcmp(md, mac, (size_t)mac_size) != 0) {\n                al = SSL_AD_BAD_RECORD_MAC;\n                SSLerr(SSL_F_SSL3_GET_RECORD,\n                       SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC);\n                goto f_err;\n            }\n        }\n    }\n\n    enc_err = s->method->ssl3_enc->enc(s, rr, num_recs, 0);\n    /*-\n     * enc_err is:\n     *    0: (in non-constant time) if the record is publically invalid.\n     *    1: if the padding is valid\n     *    -1: if the padding is invalid\n     */\n    if (enc_err == 0) {\n        al = SSL_AD_DECRYPTION_FAILED;\n        SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_BLOCK_CIPHER_PAD_IS_WRONG);\n        goto f_err;\n    }\n#ifdef SSL_DEBUG\n    printf(\"dec %d\\n\", rr->length);\n    {\n        unsigned int z;\n        for (z = 0; z < rr->length; z++)\n            printf(\"%02X%c\", rr->data[z], ((z + 1) % 16) ? ' ' : '\\n');\n    }\n    printf(\"\\n\");\n#endif\n\n    /* r->length is now the compressed data plus mac */\n    if ((sess != NULL) &&\n        (s->enc_read_ctx != NULL) &&\n        (!SSL_READ_ETM(s) && EVP_MD_CTX_md(s->read_hash) != NULL)) {\n        /* s->read_hash != NULL => mac_size != -1 */\n        unsigned char *mac = NULL;\n        unsigned char mac_tmp[EVP_MAX_MD_SIZE];\n\n        mac_size = EVP_MD_CTX_size(s->read_hash);\n        OPENSSL_assert(mac_size <= EVP_MAX_MD_SIZE);\n\n        for (j = 0; j < num_recs; j++) {\n            /*\n             * orig_len is the length of the record before any padding was\n             * removed. This is public information, as is the MAC in use,\n             * therefore we can safely process the record in a different amount\n             * of time if it's too short to possibly contain a MAC.\n             */\n            if (rr[j].orig_len < mac_size ||\n                /* CBC records must have a padding length byte too. */\n                (EVP_CIPHER_CTX_mode(s->enc_read_ctx) == EVP_CIPH_CBC_MODE &&\n                 rr[j].orig_len < mac_size + 1)) {\n                al = SSL_AD_DECODE_ERROR;\n                SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_LENGTH_TOO_SHORT);\n                goto f_err;\n            }\n\n            if (EVP_CIPHER_CTX_mode(s->enc_read_ctx) == EVP_CIPH_CBC_MODE) {\n                /*\n                 * We update the length so that the TLS header bytes can be\n                 * constructed correctly but we need to extract the MAC in\n                 * constant time from within the record, without leaking the\n                 * contents of the padding bytes.\n                 */\n                mac = mac_tmp;\n                ssl3_cbc_copy_mac(mac_tmp, &rr[j], mac_size);\n                rr[j].length -= mac_size;\n            } else {\n                /*\n                 * In this case there's no padding, so |rec->orig_len| equals\n                 * |rec->length| and we checked that there's enough bytes for\n                 * |mac_size| above.\n                 */\n                rr[j].length -= mac_size;\n                mac = &rr[j].data[rr[j].length];\n            }\n\n            i = s->method->ssl3_enc->mac(s, &rr[j], md, 0 /* not send */ );\n            if (i < 0 || mac == NULL\n                || CRYPTO_memcmp(md, mac, (size_t)mac_size) != 0)\n                enc_err = -1;\n            if (rr->length > SSL3_RT_MAX_COMPRESSED_LENGTH + mac_size)\n                enc_err = -1;\n        }\n    }\n\n    if (enc_err < 0) {\n        /*\n         * A separate 'decryption_failed' alert was introduced with TLS 1.0,\n         * SSL 3.0 only has 'bad_record_mac'.  But unless a decryption\n         * failure is directly visible from the ciphertext anyway, we should\n         * not reveal which kind of error occurred -- this might become\n         * visible to an attacker (e.g. via a logfile)\n         */\n        al = SSL_AD_BAD_RECORD_MAC;\n        SSLerr(SSL_F_SSL3_GET_RECORD,\n               SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC);\n        goto f_err;\n    }\n\n    for (j = 0; j < num_recs; j++) {\n        /* rr[j].length is now just compressed */\n        if (s->expand != NULL) {\n            if (rr[j].length > SSL3_RT_MAX_COMPRESSED_LENGTH) {\n                al = SSL_AD_RECORD_OVERFLOW;\n                SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_COMPRESSED_LENGTH_TOO_LONG);\n                goto f_err;\n            }\n            if (!ssl3_do_uncompress(s, &rr[j])) {\n                al = SSL_AD_DECOMPRESSION_FAILURE;\n                SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_BAD_DECOMPRESSION);\n                goto f_err;\n            }\n        }\n\n        if (rr[j].length > SSL3_RT_MAX_PLAIN_LENGTH) {\n            al = SSL_AD_RECORD_OVERFLOW;\n            SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_DATA_LENGTH_TOO_LONG);\n            goto f_err;\n        }\n\n        rr[j].off = 0;\n        /*-\n         * So at this point the following is true\n         * rr[j].type   is the type of record\n         * rr[j].length == number of bytes in record\n         * rr[j].off    == offset to first valid byte\n         * rr[j].data   == where to take bytes from, increment after use :-).\n         */\n\n        /* just read a 0 length packet */\n        if (rr[j].length == 0) {\n            RECORD_LAYER_inc_empty_record_count(&s->rlayer);\n            if (RECORD_LAYER_get_empty_record_count(&s->rlayer)\n                > MAX_EMPTY_RECORDS) {\n                al = SSL_AD_UNEXPECTED_MESSAGE;\n                SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_RECORD_TOO_SMALL);\n                goto f_err;\n            }\n        } else {\n            RECORD_LAYER_reset_empty_record_count(&s->rlayer);\n        }\n    }\n\n    RECORD_LAYER_set_numrpipes(&s->rlayer, num_recs);\n    return 1;\n\n f_err:\n    ssl3_send_alert(s, SSL3_AL_FATAL, al);\n err:\n    return ret;\n}",
        "target": 0
    },
    {
        "func": "int ssl3_cbc_remove_padding(SSL3_RECORD *rec,\n                            unsigned block_size, unsigned mac_size)\n{\n    unsigned padding_length, good;\n    const unsigned overhead = 1 /* padding length byte */  + mac_size;\n\n    /*\n     * These lengths are all public so we can test them in non-constant time.\n     */\n    if (overhead > rec->length)\n        return 0;\n\n    padding_length = rec->data[rec->length - 1];\n    good = constant_time_ge(rec->length, padding_length + overhead);\n    /* SSLv3 requires that the padding is minimal. */\n    good &= constant_time_ge(block_size, padding_length + 1);\n    rec->length -= good & (padding_length + 1);\n    return constant_time_select_int(good, 1, -1);\n}",
        "target": 0
    },
    {
        "func": "static int tls1_PRF(SSL *s,\n                    const void *seed1, int seed1_len,\n                    const void *seed2, int seed2_len,\n                    const void *seed3, int seed3_len,\n                    const void *seed4, int seed4_len,\n                    const void *seed5, int seed5_len,\n                    const unsigned char *sec, int slen,\n                    unsigned char *out, int olen)\n{\n    const EVP_MD *md = ssl_prf_md(s);\n    EVP_PKEY_CTX *pctx = NULL;\n\n    int ret = 0;\n    size_t outlen = olen;\n\n    if (md == NULL) {\n        /* Should never happen */\n        SSLerr(SSL_F_TLS1_PRF, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n    pctx = EVP_PKEY_CTX_new_id(EVP_PKEY_TLS1_PRF, NULL);\n    if (pctx == NULL || EVP_PKEY_derive_init(pctx) <= 0\n        || EVP_PKEY_CTX_set_tls1_prf_md(pctx, md) <= 0\n        || EVP_PKEY_CTX_set1_tls1_prf_secret(pctx, sec, slen) <= 0)\n        goto err;\n\n    if (EVP_PKEY_CTX_add1_tls1_prf_seed(pctx, seed1, seed1_len) <= 0)\n        goto err;\n    if (EVP_PKEY_CTX_add1_tls1_prf_seed(pctx, seed2, seed2_len) <= 0)\n        goto err;\n    if (EVP_PKEY_CTX_add1_tls1_prf_seed(pctx, seed3, seed3_len) <= 0)\n        goto err;\n    if (EVP_PKEY_CTX_add1_tls1_prf_seed(pctx, seed4, seed4_len) <= 0)\n        goto err;\n    if (EVP_PKEY_CTX_add1_tls1_prf_seed(pctx, seed5, seed5_len) <= 0)\n        goto err;\n\n    if (EVP_PKEY_derive(pctx, out, &outlen) <= 0)\n        goto err;\n    ret = 1;\n\n err:\n    EVP_PKEY_CTX_free(pctx);\n    return ret;\n}",
        "target": 0
    },
    {
        "func": "int ssl_parse_serverhello_tlsext(SSL *s, PACKET *pkt)\n{\n    int al = -1;\n    if (s->version < SSL3_VERSION)\n        return 1;\n    if (ssl_scan_serverhello_tlsext(s, pkt, &al) <= 0) {\n        ssl3_send_alert(s, SSL3_AL_FATAL, al);\n        return 0;\n    }\n\n    if (ssl_check_serverhello_tlsext(s) <= 0) {\n        SSLerr(SSL_F_SSL_PARSE_SERVERHELLO_TLSEXT, SSL_R_SERVERHELLO_TLSEXT);\n        return 0;\n    }\n    return 1;\n}",
        "target": 0
    },
    {
        "func": "size_t tls12_get_psigalgs(SSL *s, int sent, const unsigned char **psigs)\n{\n    /*\n     * If Suite B mode use Suite B sigalgs only, ignore any other\n     * preferences.\n     */\n#ifndef OPENSSL_NO_EC\n    switch (tls1_suiteb(s)) {\n    case SSL_CERT_FLAG_SUITEB_128_LOS:\n        *psigs = suiteb_sigalgs;\n        return sizeof(suiteb_sigalgs);\n\n    case SSL_CERT_FLAG_SUITEB_128_LOS_ONLY:\n        *psigs = suiteb_sigalgs;\n        return 2;\n\n    case SSL_CERT_FLAG_SUITEB_192_LOS:\n        *psigs = suiteb_sigalgs + 2;\n        return 2;\n    }\n#endif\n    /* If server use client authentication sigalgs if not NULL */\n    if (s->server == sent && s->cert->client_sigalgs) {\n        *psigs = s->cert->client_sigalgs;\n        return s->cert->client_sigalgslen;\n    } else if (s->cert->conf_sigalgs) {\n        *psigs = s->cert->conf_sigalgs;\n        return s->cert->conf_sigalgslen;\n    } else {\n        *psigs = tls12_sigalgs;\n        return sizeof(tls12_sigalgs);\n    }\n}",
        "target": 0
    },
    {
        "func": "int ssl3_enc(SSL *s, SSL3_RECORD *inrecs, unsigned int n_recs, int send)\n{\n    SSL3_RECORD *rec;\n    EVP_CIPHER_CTX *ds;\n    unsigned long l;\n    int bs, i, mac_size = 0;\n    const EVP_CIPHER *enc;\n\n    rec = inrecs;\n    /*\n     * We shouldn't ever be called with more than one record in the SSLv3 case\n     */\n    if (n_recs != 1)\n        return 0;\n    if (send) {\n        ds = s->enc_write_ctx;\n        if (s->enc_write_ctx == NULL)\n            enc = NULL;\n        else\n            enc = EVP_CIPHER_CTX_cipher(s->enc_write_ctx);\n    } else {\n        ds = s->enc_read_ctx;\n        if (s->enc_read_ctx == NULL)\n            enc = NULL;\n        else\n            enc = EVP_CIPHER_CTX_cipher(s->enc_read_ctx);\n    }\n\n    if ((s->session == NULL) || (ds == NULL) || (enc == NULL)) {\n        memmove(rec->data, rec->input, rec->length);\n        rec->input = rec->data;\n    } else {\n        l = rec->length;\n        bs = EVP_CIPHER_CTX_block_size(ds);\n\n        /* COMPRESS */\n\n        if ((bs != 1) && send) {\n            i = bs - ((int)l % bs);\n\n            /* we need to add 'i-1' padding bytes */\n            l += i;\n            /*\n             * the last of these zero bytes will be overwritten with the\n             * padding length.\n             */\n            memset(&rec->input[rec->length], 0, i);\n            rec->length += i;\n            rec->input[l - 1] = (i - 1);\n        }\n\n        if (!send) {\n            if (l == 0 || l % bs != 0)\n                return 0;\n            /* otherwise, rec->length >= bs */\n        }\n\n        if (EVP_Cipher(ds, rec->data, rec->input, l) < 1)\n            return -1;\n\n        if (EVP_MD_CTX_md(s->read_hash) != NULL)\n            mac_size = EVP_MD_CTX_size(s->read_hash);\n        if ((bs != 1) && !send)\n            return ssl3_cbc_remove_padding(rec, bs, mac_size);\n    }\n    return (1);\n}",
        "target": 0
    },
    {
        "func": "static int tls1_set_ec_id(unsigned char *curve_id, unsigned char *comp_id,\n                          EC_KEY *ec)\n{\n    int id;\n    const EC_GROUP *grp;\n    if (!ec)\n        return 0;\n    /* Determine if it is a prime field */\n    grp = EC_KEY_get0_group(ec);\n    if (!grp)\n        return 0;\n    /* Determine curve ID */\n    id = EC_GROUP_get_curve_name(grp);\n    id = tls1_ec_nid2curve_id(id);\n    /* If no id return error: we don't support arbitrary explicit curves */\n    if (id == 0)\n        return 0;\n    curve_id[0] = 0;\n    curve_id[1] = (unsigned char)id;\n    if (comp_id) {\n        if (EC_KEY_get0_public_key(ec) == NULL)\n            return 0;\n        if (EC_KEY_get_conv_form(ec) == POINT_CONVERSION_UNCOMPRESSED) {\n            *comp_id = TLSEXT_ECPOINTFORMAT_uncompressed;\n        } else {\n            if ((nid_list[id - 1].flags & TLS_CURVE_TYPE) == TLS_CURVE_PRIME)\n                *comp_id = TLSEXT_ECPOINTFORMAT_ansiX962_compressed_prime;\n            else\n                *comp_id = TLSEXT_ECPOINTFORMAT_ansiX962_compressed_char2;\n        }\n    }\n    return 1;\n}",
        "target": 0
    },
    {
        "func": "int tls1_check_curve(SSL *s, const unsigned char *p, size_t len)\n{\n    const unsigned char *curves;\n    size_t num_curves, i;\n    unsigned int suiteb_flags = tls1_suiteb(s);\n    if (len != 3 || p[0] != NAMED_CURVE_TYPE)\n        return 0;\n    /* Check curve matches Suite B preferences */\n    if (suiteb_flags) {\n        unsigned long cid = s->s3->tmp.new_cipher->id;\n        if (p[1])\n            return 0;\n        if (cid == TLS1_CK_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256) {\n            if (p[2] != TLSEXT_curve_P_256)\n                return 0;\n        } else if (cid == TLS1_CK_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384) {\n            if (p[2] != TLSEXT_curve_P_384)\n                return 0;\n        } else                  /* Should never happen */\n            return 0;\n    }\n    if (!tls1_get_curvelist(s, 0, &curves, &num_curves))\n        return 0;\n    for (i = 0; i < num_curves; i++, curves += 2) {\n        if (p[1] == curves[0] && p[2] == curves[1])\n            return tls_curve_allowed(s, p + 1, SSL_SECOP_CURVE_CHECK);\n    }\n    return 0;\n}",
        "target": 0
    },
    {
        "func": "static void ssl_check_for_safari(SSL *s, const PACKET *pkt)\n{\n    unsigned int type;\n    PACKET sni, tmppkt;\n    size_t ext_len;\n\n    static const unsigned char kSafariExtensionsBlock[] = {\n        0x00, 0x0a,             /* elliptic_curves extension */\n        0x00, 0x08,             /* 8 bytes */\n        0x00, 0x06,             /* 6 bytes of curve ids */\n        0x00, 0x17,             /* P-256 */\n        0x00, 0x18,             /* P-384 */\n        0x00, 0x19,             /* P-521 */\n\n        0x00, 0x0b,             /* ec_point_formats */\n        0x00, 0x02,             /* 2 bytes */\n        0x01,                   /* 1 point format */\n        0x00,                   /* uncompressed */\n        /* The following is only present in TLS 1.2 */\n        0x00, 0x0d,             /* signature_algorithms */\n        0x00, 0x0c,             /* 12 bytes */\n        0x00, 0x0a,             /* 10 bytes */\n        0x05, 0x01,             /* SHA-384/RSA */\n        0x04, 0x01,             /* SHA-256/RSA */\n        0x02, 0x01,             /* SHA-1/RSA */\n        0x04, 0x03,             /* SHA-256/ECDSA */\n        0x02, 0x03,             /* SHA-1/ECDSA */\n    };\n\n    /* Length of the common prefix (first two extensions). */\n    static const size_t kSafariCommonExtensionsLength = 18;\n\n    tmppkt = *pkt;\n\n    if (!PACKET_forward(&tmppkt, 2)\n        || !PACKET_get_net_2(&tmppkt, &type)\n        || !PACKET_get_length_prefixed_2(&tmppkt, &sni)) {\n        return;\n    }\n\n    if (type != TLSEXT_TYPE_server_name)\n        return;\n\n    ext_len = TLS1_get_client_version(s) >= TLS1_2_VERSION ?\n        sizeof(kSafariExtensionsBlock) : kSafariCommonExtensionsLength;\n\n    s->s3->is_probably_safari = PACKET_equal(&tmppkt, kSafariExtensionsBlock,\n                                             ext_len);\n}",
        "target": 0
    },
    {
        "func": "static int tls_curve_allowed(SSL *s, const unsigned char *curve, int op)\n{\n    const tls_curve_info *cinfo;\n    if (curve[0])\n        return 1;\n    if ((curve[1] < 1) || ((size_t)curve[1] > OSSL_NELEM(nid_list)))\n        return 0;\n    cinfo = &nid_list[curve[1] - 1];\n# ifdef OPENSSL_NO_EC2M\n    if (cinfo->flags & TLS_CURVE_CHAR2)\n        return 0;\n# endif\n    return ssl_security(s, op, cinfo->secbits, cinfo->nid, (void *)curve);\n}",
        "target": 0
    },
    {
        "func": "int tls1_process_sigalgs(SSL *s)\n{\n    int idx;\n    size_t i;\n    const EVP_MD *md;\n    const EVP_MD **pmd = s->s3->tmp.md;\n    uint32_t *pvalid = s->s3->tmp.valid_flags;\n    CERT *c = s->cert;\n    TLS_SIGALGS *sigptr;\n    if (!tls1_set_shared_sigalgs(s))\n        return 0;\n\n    for (i = 0, sigptr = c->shared_sigalgs;\n         i < c->shared_sigalgslen; i++, sigptr++) {\n        idx = tls12_get_pkey_idx(sigptr->rsign);\n        if (idx > 0 && pmd[idx] == NULL) {\n            md = tls12_get_hash(sigptr->rhash);\n            pmd[idx] = md;\n            pvalid[idx] = CERT_PKEY_EXPLICIT_SIGN;\n            if (idx == SSL_PKEY_RSA_SIGN) {\n                pvalid[SSL_PKEY_RSA_ENC] = CERT_PKEY_EXPLICIT_SIGN;\n                pmd[SSL_PKEY_RSA_ENC] = md;\n            }\n        }\n\n    }\n    /*\n     * In strict mode leave unset digests as NULL to indicate we can't use\n     * the certificate for signing.\n     */\n    if (!(s->cert->cert_flags & SSL_CERT_FLAGS_CHECK_TLS_STRICT)) {\n        /*\n         * Set any remaining keys to default values. NOTE: if alg is not\n         * supported it stays as NULL.\n         */\n#ifndef OPENSSL_NO_DSA\n        if (pmd[SSL_PKEY_DSA_SIGN] == NULL)\n            pmd[SSL_PKEY_DSA_SIGN] = EVP_sha1();\n#endif\n#ifndef OPENSSL_NO_RSA\n        if (pmd[SSL_PKEY_RSA_SIGN] == NULL) {\n            pmd[SSL_PKEY_RSA_SIGN] = EVP_sha1();\n            pmd[SSL_PKEY_RSA_ENC] = EVP_sha1();\n        }\n#endif\n#ifndef OPENSSL_NO_EC\n        if (pmd[SSL_PKEY_ECC] == NULL)\n            pmd[SSL_PKEY_ECC] = EVP_sha1();\n#endif\n#ifndef OPENSSL_NO_GOST\n        if (pmd[SSL_PKEY_GOST01] == NULL)\n            pmd[SSL_PKEY_GOST01] = EVP_get_digestbynid(NID_id_GostR3411_94);\n        if (pmd[SSL_PKEY_GOST12_256] == NULL)\n            pmd[SSL_PKEY_GOST12_256] =\n                EVP_get_digestbynid(NID_id_GostR3411_2012_256);\n        if (pmd[SSL_PKEY_GOST12_512] == NULL)\n            pmd[SSL_PKEY_GOST12_512] =\n                EVP_get_digestbynid(NID_id_GostR3411_2012_512);\n#endif\n    }\n    return 1;\n}",
        "target": 0
    },
    {
        "func": "static int tls1_check_cert_param(SSL *s, X509 *x, int set_ee_md)\n{\n    unsigned char comp_id, curve_id[2];\n    EVP_PKEY *pkey;\n    int rv;\n    pkey = X509_get0_pubkey(x);\n    if (!pkey)\n        return 0;\n    /* If not EC nothing to do */\n    if (EVP_PKEY_id(pkey) != EVP_PKEY_EC)\n        return 1;\n    rv = tls1_set_ec_id(curve_id, &comp_id, EVP_PKEY_get0_EC_KEY(pkey));\n    if (!rv)\n        return 0;\n    /*\n     * Can't check curve_id for client certs as we don't have a supported\n     * curves extension.\n     */\n    rv = tls1_check_ec_key(s, s->server ? curve_id : NULL, &comp_id);\n    if (!rv)\n        return 0;\n    /*\n     * Special case for suite B. We *MUST* sign using SHA256+P-256 or\n     * SHA384+P-384, adjust digest if necessary.\n     */\n    if (set_ee_md && tls1_suiteb(s)) {\n        int check_md;\n        size_t i;\n        CERT *c = s->cert;\n        if (curve_id[0])\n            return 0;\n        /* Check to see we have necessary signing algorithm */\n        if (curve_id[1] == TLSEXT_curve_P_256)\n            check_md = NID_ecdsa_with_SHA256;\n        else if (curve_id[1] == TLSEXT_curve_P_384)\n            check_md = NID_ecdsa_with_SHA384;\n        else\n            return 0;           /* Should never happen */\n        for (i = 0; i < c->shared_sigalgslen; i++)\n            if (check_md == c->shared_sigalgs[i].signandhash_nid)\n                break;\n        if (i == c->shared_sigalgslen)\n            return 0;\n        if (set_ee_md == 2) {\n            if (check_md == NID_ecdsa_with_SHA256)\n                s->s3->tmp.md[SSL_PKEY_ECC] = EVP_sha256();\n            else\n                s->s3->tmp.md[SSL_PKEY_ECC] = EVP_sha384();\n        }\n    }\n    return rv;\n}",
        "target": 0
    },
    {
        "func": "int tls1_shared_curve(SSL *s, int nmatch)\n{\n    const unsigned char *pref, *supp;\n    size_t num_pref, num_supp, i, j;\n    int k;\n\n    /* Can't do anything on client side */\n    if (s->server == 0)\n        return -1;\n    if (nmatch == -2) {\n        if (tls1_suiteb(s)) {\n            /*\n             * For Suite B ciphersuite determines curve: we already know\n             * these are acceptable due to previous checks.\n             */\n            unsigned long cid = s->s3->tmp.new_cipher->id;\n\n            if (cid == TLS1_CK_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256)\n                return NID_X9_62_prime256v1; /* P-256 */\n            if (cid == TLS1_CK_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384)\n                return NID_secp384r1; /* P-384 */\n            /* Should never happen */\n            return NID_undef;\n        }\n        /* If not Suite B just return first preference shared curve */\n        nmatch = 0;\n    }\n    /*\n     * Avoid truncation. tls1_get_curvelist takes an int\n     * but s->options is a long...\n     */\n    if (!tls1_get_curvelist(s,\n            (s->options & SSL_OP_CIPHER_SERVER_PREFERENCE) != 0,\n            &supp, &num_supp))\n        /* In practice, NID_undef == 0 but let's be precise. */\n        return nmatch == -1 ? 0 : NID_undef;\n    if (!tls1_get_curvelist(s,\n            (s->options & SSL_OP_CIPHER_SERVER_PREFERENCE) == 0,\n            &pref, &num_pref))\n        return nmatch == -1 ? 0 : NID_undef;\n\n    for (k = 0, i = 0; i < num_pref; i++, pref += 2) {\n        const unsigned char *tsupp = supp;\n\n        for (j = 0; j < num_supp; j++, tsupp += 2) {\n            if (pref[0] == tsupp[0] && pref[1] == tsupp[1]) {\n                if (!tls_curve_allowed(s, pref, SSL_SECOP_CURVE_SHARED))\n                    continue;\n                if (nmatch == k) {\n                    int id = (pref[0] << 8) | pref[1];\n\n                    return tls1_ec_curve_id2nid(id, NULL);\n                }\n                k++;\n            }\n        }\n    }\n    if (nmatch == -1)\n        return k;\n    /* Out of range (nmatch > k). */\n    return NID_undef;\n}",
        "target": 0
    },
    {
        "func": "static int tls1_alpn_handle_client_hello_late(SSL *s, int *al)\n{\n    const unsigned char *selected = NULL;\n    unsigned char selected_len = 0;\n\n    if (s->ctx->alpn_select_cb != NULL && s->s3->alpn_proposed != NULL) {\n        int r = s->ctx->alpn_select_cb(s, &selected, &selected_len,\n                                       s->s3->alpn_proposed,\n                                       s->s3->alpn_proposed_len,\n                                       s->ctx->alpn_select_cb_arg);\n\n        if (r == SSL_TLSEXT_ERR_OK) {\n            OPENSSL_free(s->s3->alpn_selected);\n            s->s3->alpn_selected = OPENSSL_memdup(selected, selected_len);\n            if (s->s3->alpn_selected == NULL) {\n                *al = SSL_AD_INTERNAL_ERROR;\n                return 0;\n            }\n            s->s3->alpn_selected_len = selected_len;\n#ifndef OPENSSL_NO_NEXTPROTONEG\n            /* ALPN takes precedence over NPN. */\n            s->s3->next_proto_neg_seen = 0;\n#endif\n        } else {\n            *al = SSL_AD_NO_APPLICATION_PROTOCOL;\n            return 0;\n        }\n    }\n\n    return 1;\n}",
        "target": 0
    },
    {
        "func": "int tls1_ec_nid2curve_id(int nid)\n{\n    size_t i;\n    for (i = 0; i < OSSL_NELEM(nid_list); i++) {\n        if (nid_list[i].nid == nid)\n            return i + 1;\n    }\n    return 0;\n}",
        "target": 0
    },
    {
        "func": "int dtls1_process_record(SSL *s, DTLS1_BITMAP *bitmap)\n{\n    int i, al;\n    int enc_err;\n    SSL_SESSION *sess;\n    SSL3_RECORD *rr;\n    unsigned int mac_size;\n    unsigned char md[EVP_MAX_MD_SIZE];\n\n    rr = RECORD_LAYER_get_rrec(&s->rlayer);\n    sess = s->session;\n\n    /*\n     * At this point, s->packet_length == SSL3_RT_HEADER_LNGTH + rr->length,\n     * and we have that many bytes in s->packet\n     */\n    rr->input = &(RECORD_LAYER_get_packet(&s->rlayer)[DTLS1_RT_HEADER_LENGTH]);\n\n    /*\n     * ok, we can now read from 's->packet' data into 'rr' rr->input points\n     * at rr->length bytes, which need to be copied into rr->data by either\n     * the decryption or by the decompression When the data is 'copied' into\n     * the rr->data buffer, rr->input will be pointed at the new buffer\n     */\n\n    /*\n     * We now have - encrypted [ MAC [ compressed [ plain ] ] ] rr->length\n     * bytes of encrypted compressed stuff.\n     */\n\n    /* check is not needed I believe */\n    if (rr->length > SSL3_RT_MAX_ENCRYPTED_LENGTH) {\n        al = SSL_AD_RECORD_OVERFLOW;\n        SSLerr(SSL_F_DTLS1_PROCESS_RECORD, SSL_R_ENCRYPTED_LENGTH_TOO_LONG);\n        goto f_err;\n    }\n\n    /* decrypt in place in 'rr->input' */\n    rr->data = rr->input;\n    rr->orig_len = rr->length;\n\n    enc_err = s->method->ssl3_enc->enc(s, rr, 1, 0);\n    /*-\n     * enc_err is:\n     *    0: (in non-constant time) if the record is publically invalid.\n     *    1: if the padding is valid\n     *   -1: if the padding is invalid\n     */\n    if (enc_err == 0) {\n        /* For DTLS we simply ignore bad packets. */\n        rr->length = 0;\n        RECORD_LAYER_reset_packet_length(&s->rlayer);\n        goto err;\n    }\n#ifdef SSL_DEBUG\n    printf(\"dec %d\\n\", rr->length);\n    {\n        unsigned int z;\n        for (z = 0; z < rr->length; z++)\n            printf(\"%02X%c\", rr->data[z], ((z + 1) % 16) ? ' ' : '\\n');\n    }\n    printf(\"\\n\");\n#endif\n\n    /* r->length is now the compressed data plus mac */\n    if ((sess != NULL) &&\n        (s->enc_read_ctx != NULL) && (EVP_MD_CTX_md(s->read_hash) != NULL)) {\n        /* s->read_hash != NULL => mac_size != -1 */\n        unsigned char *mac = NULL;\n        unsigned char mac_tmp[EVP_MAX_MD_SIZE];\n        mac_size = EVP_MD_CTX_size(s->read_hash);\n        OPENSSL_assert(mac_size <= EVP_MAX_MD_SIZE);\n\n        /*\n         * orig_len is the length of the record before any padding was\n         * removed. This is public information, as is the MAC in use,\n         * therefore we can safely process the record in a different amount\n         * of time if it's too short to possibly contain a MAC.\n         */\n        if (rr->orig_len < mac_size ||\n            /* CBC records must have a padding length byte too. */\n            (EVP_CIPHER_CTX_mode(s->enc_read_ctx) == EVP_CIPH_CBC_MODE &&\n             rr->orig_len < mac_size + 1)) {\n            al = SSL_AD_DECODE_ERROR;\n            SSLerr(SSL_F_DTLS1_PROCESS_RECORD, SSL_R_LENGTH_TOO_SHORT);\n            goto f_err;\n        }\n\n        if (EVP_CIPHER_CTX_mode(s->enc_read_ctx) == EVP_CIPH_CBC_MODE) {\n            /*\n             * We update the length so that the TLS header bytes can be\n             * constructed correctly but we need to extract the MAC in\n             * constant time from within the record, without leaking the\n             * contents of the padding bytes.\n             */\n            mac = mac_tmp;\n            ssl3_cbc_copy_mac(mac_tmp, rr, mac_size);\n            rr->length -= mac_size;\n        } else {\n            /*\n             * In this case there's no padding, so |rec->orig_len| equals\n             * |rec->length| and we checked that there's enough bytes for\n             * |mac_size| above.\n             */\n            rr->length -= mac_size;\n            mac = &rr->data[rr->length];\n        }\n\n        i = s->method->ssl3_enc->mac(s, rr, md, 0 /* not send */ );\n        if (i < 0 || mac == NULL\n            || CRYPTO_memcmp(md, mac, (size_t)mac_size) != 0)\n            enc_err = -1;\n        if (rr->length > SSL3_RT_MAX_COMPRESSED_LENGTH + mac_size)\n            enc_err = -1;\n    }\n\n    if (enc_err < 0) {\n        /* decryption failed, silently discard message */\n        rr->length = 0;\n        RECORD_LAYER_reset_packet_length(&s->rlayer);\n        goto err;\n    }\n\n    /* r->length is now just compressed */\n    if (s->expand != NULL) {\n        if (rr->length > SSL3_RT_MAX_COMPRESSED_LENGTH) {\n            al = SSL_AD_RECORD_OVERFLOW;\n            SSLerr(SSL_F_DTLS1_PROCESS_RECORD,\n                   SSL_R_COMPRESSED_LENGTH_TOO_LONG);\n            goto f_err;\n        }\n        if (!ssl3_do_uncompress(s, rr)) {\n            al = SSL_AD_DECOMPRESSION_FAILURE;\n            SSLerr(SSL_F_DTLS1_PROCESS_RECORD, SSL_R_BAD_DECOMPRESSION);\n            goto f_err;\n        }\n    }\n\n    if (rr->length > SSL3_RT_MAX_PLAIN_LENGTH) {\n        al = SSL_AD_RECORD_OVERFLOW;\n        SSLerr(SSL_F_DTLS1_PROCESS_RECORD, SSL_R_DATA_LENGTH_TOO_LONG);\n        goto f_err;\n    }\n\n    rr->off = 0;\n    /*-\n     * So at this point the following is true\n     * ssl->s3->rrec.type   is the type of record\n     * ssl->s3->rrec.length == number of bytes in record\n     * ssl->s3->rrec.off    == offset to first valid byte\n     * ssl->s3->rrec.data   == where to take bytes from, increment\n     *                         after use :-).\n     */\n\n    /* we have pulled in a full packet so zero things */\n    RECORD_LAYER_reset_packet_length(&s->rlayer);\n\n    /* Mark receipt of record. */\n    dtls1_record_bitmap_update(s, bitmap);\n\n    return (1);\n\n f_err:\n    ssl3_send_alert(s, SSL3_AL_FATAL, al);\n err:\n    return (0);\n}",
        "target": 0
    },
    {
        "func": "int tls1_save_sigalgs(SSL *s, const unsigned char *data, int dsize)\n{\n    CERT *c = s->cert;\n    /* Extension ignored for inappropriate versions */\n    if (!SSL_USE_SIGALGS(s))\n        return 1;\n    /* Should never happen */\n    if (!c)\n        return 0;\n\n    OPENSSL_free(s->s3->tmp.peer_sigalgs);\n    s->s3->tmp.peer_sigalgs = OPENSSL_malloc(dsize);\n    if (s->s3->tmp.peer_sigalgs == NULL)\n        return 0;\n    s->s3->tmp.peer_sigalgslen = dsize;\n    memcpy(s->s3->tmp.peer_sigalgs, data, dsize);\n    return 1;\n}",
        "target": 0
    },
    {
        "func": "static int tls1_alpn_handle_client_hello(SSL *s, PACKET *pkt, int *al)\n{\n    PACKET protocol_list, save_protocol_list, protocol;\n\n    *al = SSL_AD_DECODE_ERROR;\n\n    if (!PACKET_as_length_prefixed_2(pkt, &protocol_list)\n        || PACKET_remaining(&protocol_list) < 2) {\n        return 0;\n    }\n\n    save_protocol_list = protocol_list;\n    do {\n        /* Protocol names can't be empty. */\n        if (!PACKET_get_length_prefixed_1(&protocol_list, &protocol)\n            || PACKET_remaining(&protocol) == 0) {\n            return 0;\n        }\n    } while (PACKET_remaining(&protocol_list) != 0);\n\n    if (!PACKET_memdup(&save_protocol_list,\n                       &s->s3->alpn_proposed, &s->s3->alpn_proposed_len)) {\n        *al = TLS1_AD_INTERNAL_ERROR;\n        return 0;\n    }\n\n    return 1;\n}",
        "target": 0
    },
    {
        "func": "int ssl3_write_pending(SSL *s, int type, const unsigned char *buf,\n                       unsigned int len)\n{\n    int i;\n    SSL3_BUFFER *wb = s->rlayer.wbuf;\n    unsigned int currbuf = 0;\n\n/* XXXX */\n    if ((s->rlayer.wpend_tot > (int)len)\n        || ((s->rlayer.wpend_buf != buf) &&\n            !(s->mode & SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER))\n        || (s->rlayer.wpend_type != type)) {\n        SSLerr(SSL_F_SSL3_WRITE_PENDING, SSL_R_BAD_WRITE_RETRY);\n        return (-1);\n    }\n\n    for (;;) {\n        /* Loop until we find a buffer we haven't written out yet */\n        if (SSL3_BUFFER_get_left(&wb[currbuf]) == 0\n            && currbuf < s->rlayer.numwpipes - 1) {\n            currbuf++;\n            continue;\n        }\n        clear_sys_error();\n        if (s->wbio != NULL) {\n            s->rwstate = SSL_WRITING;\n            i = BIO_write(s->wbio, (char *)\n                          &(SSL3_BUFFER_get_buf(&wb[currbuf])\n                            [SSL3_BUFFER_get_offset(&wb[currbuf])]),\n                          (unsigned int)SSL3_BUFFER_get_left(&wb[currbuf]));\n        } else {\n            SSLerr(SSL_F_SSL3_WRITE_PENDING, SSL_R_BIO_NOT_SET);\n            i = -1;\n        }\n        if (i == SSL3_BUFFER_get_left(&wb[currbuf])) {\n            SSL3_BUFFER_set_left(&wb[currbuf], 0);\n            SSL3_BUFFER_add_offset(&wb[currbuf], i);\n            if (currbuf + 1 < s->rlayer.numwpipes)\n                continue;\n            s->rwstate = SSL_NOTHING;\n            return (s->rlayer.wpend_ret);\n        } else if (i <= 0) {\n            if (SSL_IS_DTLS(s)) {\n                /*\n                 * For DTLS, just drop it. That's kind of the whole point in\n                 * using a datagram service\n                 */\n                SSL3_BUFFER_set_left(&wb[currbuf], 0);\n            }\n            return i;\n        }\n        SSL3_BUFFER_add_offset(&wb[currbuf], i);\n        SSL3_BUFFER_add_left(&wb[currbuf], -i);\n    }\n}",
        "target": 0
    },
    {
        "func": "int tls12_get_sigandhash(unsigned char *p, const EVP_PKEY *pk, const EVP_MD *md)\n{\n    int sig_id, md_id;\n    if (!md)\n        return 0;\n    md_id = tls12_find_id(EVP_MD_type(md), tls12_md, OSSL_NELEM(tls12_md));\n    if (md_id == -1)\n        return 0;\n    sig_id = tls12_get_sigid(pk);\n    if (sig_id == -1)\n        return 0;\n    p[0] = (unsigned char)md_id;\n    p[1] = (unsigned char)sig_id;\n    return 1;\n}",
        "target": 0
    },
    {
        "func": "int ssl_check_serverhello_tlsext(SSL *s)\n{\n    int ret = SSL_TLSEXT_ERR_NOACK;\n    int al = SSL_AD_UNRECOGNIZED_NAME;\n\n#ifndef OPENSSL_NO_EC\n    /*\n     * If we are client and using an elliptic curve cryptography cipher\n     * suite, then if server returns an EC point formats lists extension it\n     * must contain uncompressed.\n     */\n    unsigned long alg_k = s->s3->tmp.new_cipher->algorithm_mkey;\n    unsigned long alg_a = s->s3->tmp.new_cipher->algorithm_auth;\n    if ((s->tlsext_ecpointformatlist != NULL)\n        && (s->tlsext_ecpointformatlist_length > 0)\n        && (s->session->tlsext_ecpointformatlist != NULL)\n        && (s->session->tlsext_ecpointformatlist_length > 0)\n        && ((alg_k & SSL_kECDHE) || (alg_a & SSL_aECDSA))) {\n        /* we are using an ECC cipher */\n        size_t i;\n        unsigned char *list;\n        int found_uncompressed = 0;\n        list = s->session->tlsext_ecpointformatlist;\n        for (i = 0; i < s->session->tlsext_ecpointformatlist_length; i++) {\n            if (*(list++) == TLSEXT_ECPOINTFORMAT_uncompressed) {\n                found_uncompressed = 1;\n                break;\n            }\n        }\n        if (!found_uncompressed) {\n            SSLerr(SSL_F_SSL_CHECK_SERVERHELLO_TLSEXT,\n                   SSL_R_TLS_INVALID_ECPOINTFORMAT_LIST);\n            return -1;\n        }\n    }\n    ret = SSL_TLSEXT_ERR_OK;\n#endif                          /* OPENSSL_NO_EC */\n\n    if (s->ctx != NULL && s->ctx->tlsext_servername_callback != 0)\n        ret =\n            s->ctx->tlsext_servername_callback(s, &al,\n                                               s->ctx->tlsext_servername_arg);\n    else if (s->session_ctx != NULL\n             && s->session_ctx->tlsext_servername_callback != 0)\n        ret =\n            s->session_ctx->tlsext_servername_callback(s, &al,\n                                                       s->\n                                                       session_ctx->tlsext_servername_arg);\n\n    /*\n     * Ensure we get sensible values passed to tlsext_status_cb in the event\n     * that we don't receive a status message\n     */\n    OPENSSL_free(s->tlsext_ocsp_resp);\n    s->tlsext_ocsp_resp = NULL;\n    s->tlsext_ocsp_resplen = -1;\n\n    switch (ret) {\n    case SSL_TLSEXT_ERR_ALERT_FATAL:\n        ssl3_send_alert(s, SSL3_AL_FATAL, al);\n        return -1;\n\n    case SSL_TLSEXT_ERR_ALERT_WARNING:\n        ssl3_send_alert(s, SSL3_AL_WARNING, al);\n        return 1;\n\n    case SSL_TLSEXT_ERR_NOACK:\n        s->servername_done = 0;\n    default:\n        return 1;\n    }\n}",
        "target": 0
    },
    {
        "func": "static int compare_uint(const void *p1, const void *p2)\n{\n    unsigned int u1 = *((const unsigned int *)p1);\n    unsigned int u2 = *((const unsigned int *)p2);\n    if (u1 < u2)\n        return -1;\n    else if (u1 > u2)\n        return 1;\n    else\n        return 0;\n}",
        "target": 0
    },
    {
        "func": "int tls_check_serverhello_tlsext_early(SSL *s, const PACKET *ext,\n                                       const PACKET *session_id,\n                                       SSL_SESSION **ret)\n{\n    unsigned int i;\n    PACKET local_ext = *ext;\n    int retv = -1;\n\n    int have_ticket = 0;\n    int use_ticket = tls_use_ticket(s);\n\n    *ret = NULL;\n    s->tlsext_ticket_expected = 0;\n    s->s3->flags &= ~TLS1_FLAGS_RECEIVED_EXTMS;\n\n    /*\n     * If tickets disabled behave as if no ticket present to permit stateful\n     * resumption.\n     */\n    if ((s->version <= SSL3_VERSION))\n        return 0;\n\n    if (!PACKET_get_net_2(&local_ext, &i)) {\n        retv = 0;\n        goto end;\n    }\n    while (PACKET_remaining(&local_ext) >= 4) {\n        unsigned int type, size;\n\n        if (!PACKET_get_net_2(&local_ext, &type)\n            || !PACKET_get_net_2(&local_ext, &size)) {\n            /* Shouldn't ever happen */\n            retv = -1;\n            goto end;\n        }\n        if (PACKET_remaining(&local_ext) < size) {\n            retv = 0;\n            goto end;\n        }\n        if (type == TLSEXT_TYPE_session_ticket && use_ticket) {\n            int r;\n            const unsigned char *etick;\n\n            /* Duplicate extension */\n            if (have_ticket != 0) {\n                retv = -1;\n                goto end;\n            }\n            have_ticket = 1;\n\n            if (size == 0) {\n                /*\n                 * The client will accept a ticket but doesn't currently have\n                 * one.\n                 */\n                s->tlsext_ticket_expected = 1;\n                retv = 1;\n                continue;\n            }\n            if (s->tls_session_secret_cb) {\n                /*\n                 * Indicate that the ticket couldn't be decrypted rather than\n                 * generating the session from ticket now, trigger\n                 * abbreviated handshake based on external mechanism to\n                 * calculate the master secret later.\n                 */\n                retv = 2;\n                continue;\n            }\n            if (!PACKET_get_bytes(&local_ext, &etick, size)) {\n                /* Shouldn't ever happen */\n                retv = -1;\n                goto end;\n            }\n            r = tls_decrypt_ticket(s, etick, size, PACKET_data(session_id),\n                                   PACKET_remaining(session_id), ret);\n            switch (r) {\n            case 2:            /* ticket couldn't be decrypted */\n                s->tlsext_ticket_expected = 1;\n                retv = 2;\n                break;\n            case 3:            /* ticket was decrypted */\n                retv = r;\n                break;\n            case 4:            /* ticket decrypted but need to renew */\n                s->tlsext_ticket_expected = 1;\n                retv = 3;\n                break;\n            default:           /* fatal error */\n                retv = -1;\n                break;\n            }\n            continue;\n        } else {\n            if (type == TLSEXT_TYPE_extended_master_secret)\n                s->s3->flags |= TLS1_FLAGS_RECEIVED_EXTMS;\n            if (!PACKET_forward(&local_ext, size)) {\n                retv = -1;\n                goto end;\n            }\n        }\n    }\n    if (have_ticket == 0)\n        retv = 0;\n end:\n    return retv;\n}",
        "target": 0
    },
    {
        "func": "unsigned char *ssl_add_serverhello_tlsext(SSL *s, unsigned char *buf,\n                                          unsigned char *limit, int *al)\n{\n    int extdatalen = 0;\n    unsigned char *orig = buf;\n    unsigned char *ret = buf;\n#ifndef OPENSSL_NO_NEXTPROTONEG\n    int next_proto_neg_seen;\n#endif\n#ifndef OPENSSL_NO_EC\n    unsigned long alg_k = s->s3->tmp.new_cipher->algorithm_mkey;\n    unsigned long alg_a = s->s3->tmp.new_cipher->algorithm_auth;\n    int using_ecc = (alg_k & SSL_kECDHE) || (alg_a & SSL_aECDSA);\n    using_ecc = using_ecc && (s->session->tlsext_ecpointformatlist != NULL);\n#endif\n\n    ret += 2;\n    if (ret >= limit)\n        return NULL;            /* this really never occurs, but ... */\n\n    if (s->s3->send_connection_binding) {\n        int el;\n\n        if (!ssl_add_serverhello_renegotiate_ext(s, 0, &el, 0)) {\n            SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n            return NULL;\n        }\n\n        /*-\n         * check for enough space.\n         * 4 bytes for the reneg type and extension length\n         * + reneg data length\n         */\n        if (CHECKLEN(ret, 4 + el, limit))\n            return NULL;\n\n        s2n(TLSEXT_TYPE_renegotiate, ret);\n        s2n(el, ret);\n\n        if (!ssl_add_serverhello_renegotiate_ext(s, ret, &el, el)) {\n            SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n            return NULL;\n        }\n\n        ret += el;\n    }\n\n    /* Only add RI for SSLv3 */\n    if (s->version == SSL3_VERSION)\n        goto done;\n\n    if (!s->hit && s->servername_done == 1\n        && s->session->tlsext_hostname != NULL) {\n        /*-\n         * check for enough space.\n         * 4 bytes for the server name type and extension length\n         */\n        if (CHECKLEN(ret, 4, limit))\n            return NULL;\n\n        s2n(TLSEXT_TYPE_server_name, ret);\n        s2n(0, ret);\n    }\n#ifndef OPENSSL_NO_EC\n    if (using_ecc) {\n        const unsigned char *plist;\n        size_t plistlen;\n        /*\n         * Add TLS extension ECPointFormats to the ServerHello message\n         */\n\n        tls1_get_formatlist(s, &plist, &plistlen);\n\n        if (plistlen > 255) {\n            SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n            return NULL;\n        }\n\n        /*-\n         * check for enough space.\n         * 4 bytes for the ec points format type and extension length\n         * 1 byte for the points format list length\n         * + length of points format list\n         */\n        if (CHECKLEN(ret, 5 + plistlen, limit))\n            return NULL;\n\n        s2n(TLSEXT_TYPE_ec_point_formats, ret);\n        s2n(plistlen + 1, ret);\n        *(ret++) = (unsigned char)plistlen;\n        memcpy(ret, plist, plistlen);\n        ret += plistlen;\n\n    }\n    /*\n     * Currently the server should not respond with a SupportedCurves\n     * extension\n     */\n#endif                          /* OPENSSL_NO_EC */\n\n    if (s->tlsext_ticket_expected && tls_use_ticket(s)) {\n        /*-\n         * check for enough space.\n         * 4 bytes for the Ticket type and extension length\n         */\n        if (CHECKLEN(ret, 4, limit))\n            return NULL;\n        s2n(TLSEXT_TYPE_session_ticket, ret);\n        s2n(0, ret);\n    } else {\n        /*\n         * if we don't add the above TLSEXT, we can't add a session ticket\n         * later\n         */\n        s->tlsext_ticket_expected = 0;\n    }\n\n    if (s->tlsext_status_expected) {\n        /*-\n         * check for enough space.\n         * 4 bytes for the Status request type and extension length\n         */\n        if (CHECKLEN(ret, 4, limit))\n            return NULL;\n        s2n(TLSEXT_TYPE_status_request, ret);\n        s2n(0, ret);\n    }\n#ifndef OPENSSL_NO_SRTP\n    if (SSL_IS_DTLS(s) && s->srtp_profile) {\n        int el;\n\n        /* Returns 0 on success!! */\n        if (ssl_add_serverhello_use_srtp_ext(s, 0, &el, 0)) {\n            SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n            return NULL;\n        }\n        /*-\n         * check for enough space.\n         * 4 bytes for the SRTP profiles type and extension length\n         * + length of the SRTP profiles list\n         */\n        if (CHECKLEN(ret, 4 + el, limit))\n            return NULL;\n\n        s2n(TLSEXT_TYPE_use_srtp, ret);\n        s2n(el, ret);\n\n        if (ssl_add_serverhello_use_srtp_ext(s, ret, &el, el)) {\n            SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n            return NULL;\n        }\n        ret += el;\n    }\n#endif\n\n    if (((s->s3->tmp.new_cipher->id & 0xFFFF) == 0x80\n         || (s->s3->tmp.new_cipher->id & 0xFFFF) == 0x81)\n        && (SSL_get_options(s) & SSL_OP_CRYPTOPRO_TLSEXT_BUG)) {\n        const unsigned char cryptopro_ext[36] = {\n            0xfd, 0xe8,         /* 65000 */\n            0x00, 0x20,         /* 32 bytes length */\n            0x30, 0x1e, 0x30, 0x08, 0x06, 0x06, 0x2a, 0x85,\n            0x03, 0x02, 0x02, 0x09, 0x30, 0x08, 0x06, 0x06,\n            0x2a, 0x85, 0x03, 0x02, 0x02, 0x16, 0x30, 0x08,\n            0x06, 0x06, 0x2a, 0x85, 0x03, 0x02, 0x02, 0x17\n        };\n\n        /* check for enough space. */\n        if (CHECKLEN(ret, sizeof(cryptopro_ext), limit))\n            return NULL;\n        memcpy(ret, cryptopro_ext, sizeof(cryptopro_ext));\n        ret += sizeof(cryptopro_ext);\n\n    }\n#ifndef OPENSSL_NO_HEARTBEATS\n    /* Add Heartbeat extension if we've received one */\n    if (SSL_IS_DTLS(s) && (s->tlsext_heartbeat & SSL_DTLSEXT_HB_ENABLED)) {\n        /*-\n         * check for enough space.\n         * 4 bytes for the Heartbeat type and extension length\n         * 1 byte for the mode\n         */\n        if (CHECKLEN(ret, 5, limit))\n            return NULL;\n        s2n(TLSEXT_TYPE_heartbeat, ret);\n        s2n(1, ret);\n        /*-\n         * Set mode:\n         * 1: peer may send requests\n         * 2: peer not allowed to send requests\n         */\n        if (s->tlsext_heartbeat & SSL_DTLSEXT_HB_DONT_RECV_REQUESTS)\n            *(ret++) = SSL_DTLSEXT_HB_DONT_SEND_REQUESTS;\n        else\n            *(ret++) = SSL_DTLSEXT_HB_ENABLED;\n\n    }\n#endif\n\n#ifndef OPENSSL_NO_NEXTPROTONEG\n    next_proto_neg_seen = s->s3->next_proto_neg_seen;\n    s->s3->next_proto_neg_seen = 0;\n    if (next_proto_neg_seen && s->ctx->next_protos_advertised_cb) {\n        const unsigned char *npa;\n        unsigned int npalen;\n        int r;\n\n        r = s->ctx->next_protos_advertised_cb(s, &npa, &npalen,\n                                              s->\n                                              ctx->next_protos_advertised_cb_arg);\n        if (r == SSL_TLSEXT_ERR_OK) {\n            /*-\n             * check for enough space.\n             * 4 bytes for the NPN type and extension length\n             * + length of protocols list\n             */\n            if (CHECKLEN(ret, 4 + npalen, limit))\n                return NULL;\n            s2n(TLSEXT_TYPE_next_proto_neg, ret);\n            s2n(npalen, ret);\n            memcpy(ret, npa, npalen);\n            ret += npalen;\n            s->s3->next_proto_neg_seen = 1;\n        }\n    }\n#endif\n    if (!custom_ext_add(s, 1, &ret, limit, al))\n        return NULL;\n    if (s->tlsext_use_etm) {\n        /*\n         * Don't use encrypt_then_mac if AEAD or RC4 might want to disable\n         * for other cases too.\n         */\n        if (SSL_IS_DTLS(s) || s->s3->tmp.new_cipher->algorithm_mac == SSL_AEAD\n            || s->s3->tmp.new_cipher->algorithm_enc == SSL_RC4\n            || s->s3->tmp.new_cipher->algorithm_enc == SSL_eGOST2814789CNT\n            || s->s3->tmp.new_cipher->algorithm_enc == SSL_eGOST2814789CNT12)\n            s->tlsext_use_etm = 0;\n        else {\n            /*-\n             * check for enough space.\n             * 4 bytes for the ETM type and extension length\n             */\n            if (CHECKLEN(ret, 4, limit))\n                return NULL;\n            s2n(TLSEXT_TYPE_encrypt_then_mac, ret);\n            s2n(0, ret);\n        }\n    }\n    if (s->s3->flags & TLS1_FLAGS_RECEIVED_EXTMS) {\n        /*-\n         * check for enough space.\n         * 4 bytes for the EMS type and extension length\n         */\n        if (CHECKLEN(ret, 4, limit))\n            return NULL;\n        s2n(TLSEXT_TYPE_extended_master_secret, ret);\n        s2n(0, ret);\n    }\n\n    if (s->s3->alpn_selected != NULL) {\n        const unsigned char *selected = s->s3->alpn_selected;\n        size_t len = s->s3->alpn_selected_len;\n\n        /*-\n         * check for enough space.\n         * 4 bytes for the ALPN type and extension length\n         * 2 bytes for ALPN data length\n         * 1 byte for selected protocol length\n         * + length of the selected protocol\n         */\n        if (CHECKLEN(ret, 7 + len, limit))\n            return NULL;\n        s2n(TLSEXT_TYPE_application_layer_protocol_negotiation, ret);\n        s2n(3 + len, ret);\n        s2n(1 + len, ret);\n        *ret++ = len;\n        memcpy(ret, selected, len);\n        ret += len;\n    }\n\n done:\n\n    if ((extdatalen = ret - orig - 2) == 0)\n        return orig;\n\n    s2n(extdatalen, orig);\n    return ret;\n}",
        "target": 0
    },
    {
        "func": "static int ssl_security_cert_sig(SSL *s, SSL_CTX *ctx, X509 *x, int op)\n{\n    /* Lookup signature algorithm digest */\n    int secbits = -1, md_nid = NID_undef, sig_nid;\n    /* Don't check signature if self signed */\n    if ((X509_get_extension_flags(x) & EXFLAG_SS) != 0)\n        return 1;\n    sig_nid = X509_get_signature_nid(x);\n    if (sig_nid && OBJ_find_sigid_algs(sig_nid, &md_nid, NULL)) {\n        const EVP_MD *md;\n        if (md_nid && (md = EVP_get_digestbynid(md_nid)))\n            secbits = EVP_MD_size(md) * 4;\n    }\n    if (s)\n        return ssl_security(s, op, secbits, md_nid, x);\n    else\n        return ssl_ctx_security(ctx, op, secbits, md_nid, x);\n}",
        "target": 0
    },
    {
        "func": "int tls1_alert_code(int code)\n{\n    switch (code) {\n    case SSL_AD_CLOSE_NOTIFY:\n        return (SSL3_AD_CLOSE_NOTIFY);\n    case SSL_AD_UNEXPECTED_MESSAGE:\n        return (SSL3_AD_UNEXPECTED_MESSAGE);\n    case SSL_AD_BAD_RECORD_MAC:\n        return (SSL3_AD_BAD_RECORD_MAC);\n    case SSL_AD_DECRYPTION_FAILED:\n        return (TLS1_AD_DECRYPTION_FAILED);\n    case SSL_AD_RECORD_OVERFLOW:\n        return (TLS1_AD_RECORD_OVERFLOW);\n    case SSL_AD_DECOMPRESSION_FAILURE:\n        return (SSL3_AD_DECOMPRESSION_FAILURE);\n    case SSL_AD_HANDSHAKE_FAILURE:\n        return (SSL3_AD_HANDSHAKE_FAILURE);\n    case SSL_AD_NO_CERTIFICATE:\n        return (-1);\n    case SSL_AD_BAD_CERTIFICATE:\n        return (SSL3_AD_BAD_CERTIFICATE);\n    case SSL_AD_UNSUPPORTED_CERTIFICATE:\n        return (SSL3_AD_UNSUPPORTED_CERTIFICATE);\n    case SSL_AD_CERTIFICATE_REVOKED:\n        return (SSL3_AD_CERTIFICATE_REVOKED);\n    case SSL_AD_CERTIFICATE_EXPIRED:\n        return (SSL3_AD_CERTIFICATE_EXPIRED);\n    case SSL_AD_CERTIFICATE_UNKNOWN:\n        return (SSL3_AD_CERTIFICATE_UNKNOWN);\n    case SSL_AD_ILLEGAL_PARAMETER:\n        return (SSL3_AD_ILLEGAL_PARAMETER);\n    case SSL_AD_UNKNOWN_CA:\n        return (TLS1_AD_UNKNOWN_CA);\n    case SSL_AD_ACCESS_DENIED:\n        return (TLS1_AD_ACCESS_DENIED);\n    case SSL_AD_DECODE_ERROR:\n        return (TLS1_AD_DECODE_ERROR);\n    case SSL_AD_DECRYPT_ERROR:\n        return (TLS1_AD_DECRYPT_ERROR);\n    case SSL_AD_EXPORT_RESTRICTION:\n        return (TLS1_AD_EXPORT_RESTRICTION);\n    case SSL_AD_PROTOCOL_VERSION:\n        return (TLS1_AD_PROTOCOL_VERSION);\n    case SSL_AD_INSUFFICIENT_SECURITY:\n        return (TLS1_AD_INSUFFICIENT_SECURITY);\n    case SSL_AD_INTERNAL_ERROR:\n        return (TLS1_AD_INTERNAL_ERROR);\n    case SSL_AD_USER_CANCELLED:\n        return (TLS1_AD_USER_CANCELLED);\n    case SSL_AD_NO_RENEGOTIATION:\n        return (TLS1_AD_NO_RENEGOTIATION);\n    case SSL_AD_UNSUPPORTED_EXTENSION:\n        return (TLS1_AD_UNSUPPORTED_EXTENSION);\n    case SSL_AD_CERTIFICATE_UNOBTAINABLE:\n        return (TLS1_AD_CERTIFICATE_UNOBTAINABLE);\n    case SSL_AD_UNRECOGNIZED_NAME:\n        return (TLS1_AD_UNRECOGNIZED_NAME);\n    case SSL_AD_BAD_CERTIFICATE_STATUS_RESPONSE:\n        return (TLS1_AD_BAD_CERTIFICATE_STATUS_RESPONSE);\n    case SSL_AD_BAD_CERTIFICATE_HASH_VALUE:\n        return (TLS1_AD_BAD_CERTIFICATE_HASH_VALUE);\n    case SSL_AD_UNKNOWN_PSK_IDENTITY:\n        return (TLS1_AD_UNKNOWN_PSK_IDENTITY);\n    case SSL_AD_INAPPROPRIATE_FALLBACK:\n        return (TLS1_AD_INAPPROPRIATE_FALLBACK);\n    case SSL_AD_NO_APPLICATION_PROTOCOL:\n        return (TLS1_AD_NO_APPLICATION_PROTOCOL);\n    default:\n        return (-1);\n    }\n}",
        "target": 0
    },
    {
        "func": "static int tls12_get_pkey_idx(unsigned char sig_alg)\n{\n    switch (sig_alg) {\n#ifndef OPENSSL_NO_RSA\n    case TLSEXT_signature_rsa:\n        return SSL_PKEY_RSA_SIGN;\n#endif\n#ifndef OPENSSL_NO_DSA\n    case TLSEXT_signature_dsa:\n        return SSL_PKEY_DSA_SIGN;\n#endif\n#ifndef OPENSSL_NO_EC\n    case TLSEXT_signature_ecdsa:\n        return SSL_PKEY_ECC;\n#endif\n#ifndef OPENSSL_NO_GOST\n    case TLSEXT_signature_gostr34102001:\n        return SSL_PKEY_GOST01;\n\n    case TLSEXT_signature_gostr34102012_256:\n        return SSL_PKEY_GOST12_256;\n\n    case TLSEXT_signature_gostr34102012_512:\n        return SSL_PKEY_GOST12_512;\n#endif\n    }\n    return -1;\n}",
        "target": 0
    },
    {
        "func": "int tls1_set_sigalgs(CERT *c, const int *psig_nids, size_t salglen, int client)\n{\n    unsigned char *sigalgs, *sptr;\n    int rhash, rsign;\n    size_t i;\n    if (salglen & 1)\n        return 0;\n    sigalgs = OPENSSL_malloc(salglen);\n    if (sigalgs == NULL)\n        return 0;\n    for (i = 0, sptr = sigalgs; i < salglen; i += 2) {\n        rhash = tls12_find_id(*psig_nids++, tls12_md, OSSL_NELEM(tls12_md));\n        rsign = tls12_find_id(*psig_nids++, tls12_sig, OSSL_NELEM(tls12_sig));\n\n        if (rhash == -1 || rsign == -1)\n            goto err;\n        *sptr++ = rhash;\n        *sptr++ = rsign;\n    }\n\n    if (client) {\n        OPENSSL_free(c->client_sigalgs);\n        c->client_sigalgs = sigalgs;\n        c->client_sigalgslen = salglen;\n    } else {\n        OPENSSL_free(c->conf_sigalgs);\n        c->conf_sigalgs = sigalgs;\n        c->conf_sigalgslen = salglen;\n    }\n\n    return 1;\n\n err:\n    OPENSSL_free(sigalgs);\n    return 0;\n}",
        "target": 0
    },
    {
        "func": "int ssl3_read_bytes(SSL *s, int type, int *recvd_type, unsigned char *buf,\n                    int len, int peek)\n{\n    int al, i, j, ret;\n    unsigned int n, curr_rec, num_recs, read_bytes;\n    SSL3_RECORD *rr;\n    SSL3_BUFFER *rbuf;\n    void (*cb) (const SSL *ssl, int type2, int val) = NULL;\n\n    rbuf = &s->rlayer.rbuf;\n\n    if (!SSL3_BUFFER_is_initialised(rbuf)) {\n        /* Not initialized yet */\n        if (!ssl3_setup_read_buffer(s))\n            return (-1);\n    }\n\n    if ((type && (type != SSL3_RT_APPLICATION_DATA)\n         && (type != SSL3_RT_HANDSHAKE)) || (peek\n                                             && (type !=\n                                                 SSL3_RT_APPLICATION_DATA))) {\n        SSLerr(SSL_F_SSL3_READ_BYTES, ERR_R_INTERNAL_ERROR);\n        return -1;\n    }\n\n    if ((type == SSL3_RT_HANDSHAKE) && (s->rlayer.handshake_fragment_len > 0))\n        /* (partially) satisfy request from storage */\n    {\n        unsigned char *src = s->rlayer.handshake_fragment;\n        unsigned char *dst = buf;\n        unsigned int k;\n\n        /* peek == 0 */\n        n = 0;\n        while ((len > 0) && (s->rlayer.handshake_fragment_len > 0)) {\n            *dst++ = *src++;\n            len--;\n            s->rlayer.handshake_fragment_len--;\n            n++;\n        }\n        /* move any remaining fragment bytes: */\n        for (k = 0; k < s->rlayer.handshake_fragment_len; k++)\n            s->rlayer.handshake_fragment[k] = *src++;\n\n        if (recvd_type != NULL)\n            *recvd_type = SSL3_RT_HANDSHAKE;\n\n        return n;\n    }\n\n    /*\n     * Now s->rlayer.handshake_fragment_len == 0 if type == SSL3_RT_HANDSHAKE.\n     */\n\n    if (!ossl_statem_get_in_handshake(s) && SSL_in_init(s)) {\n        /* type == SSL3_RT_APPLICATION_DATA */\n        i = s->handshake_func(s);\n        if (i < 0)\n            return (i);\n        if (i == 0) {\n            SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_SSL_HANDSHAKE_FAILURE);\n            return (-1);\n        }\n    }\n start:\n    s->rwstate = SSL_NOTHING;\n\n    /*-\n     * For each record 'i' up to |num_recs]\n     * rr[i].type     - is the type of record\n     * rr[i].data,    - data\n     * rr[i].off,     - offset into 'data' for next read\n     * rr[i].length,  - number of bytes.\n     */\n    rr = s->rlayer.rrec;\n    num_recs = RECORD_LAYER_get_numrpipes(&s->rlayer);\n\n    do {\n        /* get new records if necessary */\n        if (num_recs == 0) {\n            ret = ssl3_get_record(s);\n            if (ret <= 0)\n                return (ret);\n            num_recs = RECORD_LAYER_get_numrpipes(&s->rlayer);\n            if (num_recs == 0) {\n                /* Shouldn't happen */\n                al = SSL_AD_INTERNAL_ERROR;\n                SSLerr(SSL_F_SSL3_READ_BYTES, ERR_R_INTERNAL_ERROR);\n                goto f_err;\n            }\n        }\n        /* Skip over any records we have already read */\n        for (curr_rec = 0;\n             curr_rec < num_recs && SSL3_RECORD_is_read(&rr[curr_rec]);\n             curr_rec++) ;\n        if (curr_rec == num_recs) {\n            RECORD_LAYER_set_numrpipes(&s->rlayer, 0);\n            num_recs = 0;\n            curr_rec = 0;\n        }\n    } while (num_recs == 0);\n    rr = &rr[curr_rec];\n\n    /*\n     * Reset the count of consecutive warning alerts if we've got a non-empty\n     * record that isn't an alert.\n     */\n    if (SSL3_RECORD_get_type(rr) != SSL3_RT_ALERT\n            && SSL3_RECORD_get_length(rr) != 0)\n        s->rlayer.alert_count = 0;\n\n    /* we now have a packet which can be read and processed */\n\n    if (s->s3->change_cipher_spec /* set when we receive ChangeCipherSpec,\n                                   * reset by ssl3_get_finished */\n        && (SSL3_RECORD_get_type(rr) != SSL3_RT_HANDSHAKE)) {\n        al = SSL_AD_UNEXPECTED_MESSAGE;\n        SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_DATA_BETWEEN_CCS_AND_FINISHED);\n        goto f_err;\n    }\n\n    /*\n     * If the other end has shut down, throw anything we read away (even in\n     * 'peek' mode)\n     */\n    if (s->shutdown & SSL_RECEIVED_SHUTDOWN) {\n        SSL3_RECORD_set_length(rr, 0);\n        s->rwstate = SSL_NOTHING;\n        return (0);\n    }\n\n    if (type == SSL3_RECORD_get_type(rr)\n        || (SSL3_RECORD_get_type(rr) == SSL3_RT_CHANGE_CIPHER_SPEC\n            && type == SSL3_RT_HANDSHAKE && recvd_type != NULL)) {\n        /*\n         * SSL3_RT_APPLICATION_DATA or\n         * SSL3_RT_HANDSHAKE or\n         * SSL3_RT_CHANGE_CIPHER_SPEC\n         */\n        /*\n         * make sure that we are not getting application data when we are\n         * doing a handshake for the first time\n         */\n        if (SSL_in_init(s) && (type == SSL3_RT_APPLICATION_DATA) &&\n            (s->enc_read_ctx == NULL)) {\n            al = SSL_AD_UNEXPECTED_MESSAGE;\n            SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_APP_DATA_IN_HANDSHAKE);\n            goto f_err;\n        }\n\n        if (type == SSL3_RT_HANDSHAKE\n            && SSL3_RECORD_get_type(rr) == SSL3_RT_CHANGE_CIPHER_SPEC\n            && s->rlayer.handshake_fragment_len > 0) {\n            al = SSL_AD_UNEXPECTED_MESSAGE;\n            SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_CCS_RECEIVED_EARLY);\n            goto f_err;\n        }\n\n        if (recvd_type != NULL)\n            *recvd_type = SSL3_RECORD_get_type(rr);\n\n        if (len <= 0)\n            return (len);\n\n        read_bytes = 0;\n        do {\n            if ((unsigned int)len - read_bytes > SSL3_RECORD_get_length(rr))\n                n = SSL3_RECORD_get_length(rr);\n            else\n                n = (unsigned int)len - read_bytes;\n\n            memcpy(buf, &(rr->data[rr->off]), n);\n            buf += n;\n            if (peek) {\n                /* Mark any zero length record as consumed CVE-2016-6305 */\n                if (SSL3_RECORD_get_length(rr) == 0)\n                    SSL3_RECORD_set_read(rr);\n            } else {\n                SSL3_RECORD_sub_length(rr, n);\n                SSL3_RECORD_add_off(rr, n);\n                if (SSL3_RECORD_get_length(rr) == 0) {\n                    s->rlayer.rstate = SSL_ST_READ_HEADER;\n                    SSL3_RECORD_set_off(rr, 0);\n                    SSL3_RECORD_set_read(rr);\n                }\n            }\n            if (SSL3_RECORD_get_length(rr) == 0\n                || (peek && n == SSL3_RECORD_get_length(rr))) {\n                curr_rec++;\n                rr++;\n            }\n            read_bytes += n;\n        } while (type == SSL3_RT_APPLICATION_DATA && curr_rec < num_recs\n                 && read_bytes < (unsigned int)len);\n        if (read_bytes == 0) {\n            /* We must have read empty records. Get more data */\n            goto start;\n        }\n        if (!peek && curr_rec == num_recs\n            && (s->mode & SSL_MODE_RELEASE_BUFFERS)\n            && SSL3_BUFFER_get_left(rbuf) == 0)\n            ssl3_release_read_buffer(s);\n        return read_bytes;\n    }\n\n    /*\n     * If we get here, then type != rr->type; if we have a handshake message,\n     * then it was unexpected (Hello Request or Client Hello) or invalid (we\n     * were actually expecting a CCS).\n     */\n\n    /*\n     * Lets just double check that we've not got an SSLv2 record\n     */\n    if (rr->rec_version == SSL2_VERSION) {\n        /*\n         * Should never happen. ssl3_get_record() should only give us an SSLv2\n         * record back if this is the first packet and we are looking for an\n         * initial ClientHello. Therefore |type| should always be equal to\n         * |rr->type|. If not then something has gone horribly wrong\n         */\n        al = SSL_AD_INTERNAL_ERROR;\n        SSLerr(SSL_F_SSL3_READ_BYTES, ERR_R_INTERNAL_ERROR);\n        goto f_err;\n    }\n\n    if (s->method->version == TLS_ANY_VERSION\n        && (s->server || rr->type != SSL3_RT_ALERT)) {\n        /*\n         * If we've got this far and still haven't decided on what version\n         * we're using then this must be a client side alert we're dealing with\n         * (we don't allow heartbeats yet). We shouldn't be receiving anything\n         * other than a ClientHello if we are a server.\n         */\n        s->version = rr->rec_version;\n        al = SSL_AD_UNEXPECTED_MESSAGE;\n        SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_UNEXPECTED_MESSAGE);\n        goto f_err;\n    }\n\n    /*\n     * In case of record types for which we have 'fragment' storage, fill\n     * that so that we can process the data at a fixed place.\n     */\n    {\n        unsigned int dest_maxlen = 0;\n        unsigned char *dest = NULL;\n        unsigned int *dest_len = NULL;\n\n        if (SSL3_RECORD_get_type(rr) == SSL3_RT_HANDSHAKE) {\n            dest_maxlen = sizeof s->rlayer.handshake_fragment;\n            dest = s->rlayer.handshake_fragment;\n            dest_len = &s->rlayer.handshake_fragment_len;\n        } else if (SSL3_RECORD_get_type(rr) == SSL3_RT_ALERT) {\n            dest_maxlen = sizeof s->rlayer.alert_fragment;\n            dest = s->rlayer.alert_fragment;\n            dest_len = &s->rlayer.alert_fragment_len;\n        }\n\n        if (dest_maxlen > 0) {\n            n = dest_maxlen - *dest_len; /* available space in 'dest' */\n            if (SSL3_RECORD_get_length(rr) < n)\n                n = SSL3_RECORD_get_length(rr); /* available bytes */\n\n            /* now move 'n' bytes: */\n            while (n-- > 0) {\n                dest[(*dest_len)++] =\n                    SSL3_RECORD_get_data(rr)[SSL3_RECORD_get_off(rr)];\n                SSL3_RECORD_add_off(rr, 1);\n                SSL3_RECORD_add_length(rr, -1);\n            }\n\n            if (*dest_len < dest_maxlen) {\n                SSL3_RECORD_set_read(rr);\n                goto start;     /* fragment was too small */\n            }\n        }\n    }\n\n    /*-\n     * s->rlayer.handshake_fragment_len == 4  iff  rr->type == SSL3_RT_HANDSHAKE;\n     * s->rlayer.alert_fragment_len == 2      iff  rr->type == SSL3_RT_ALERT.\n     * (Possibly rr is 'empty' now, i.e. rr->length may be 0.)\n     */\n\n    /* If we are a client, check for an incoming 'Hello Request': */\n    if ((!s->server) &&\n        (s->rlayer.handshake_fragment_len >= 4) &&\n        (s->rlayer.handshake_fragment[0] == SSL3_MT_HELLO_REQUEST) &&\n        (s->session != NULL) && (s->session->cipher != NULL)) {\n        s->rlayer.handshake_fragment_len = 0;\n\n        if ((s->rlayer.handshake_fragment[1] != 0) ||\n            (s->rlayer.handshake_fragment[2] != 0) ||\n            (s->rlayer.handshake_fragment[3] != 0)) {\n            al = SSL_AD_DECODE_ERROR;\n            SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_BAD_HELLO_REQUEST);\n            goto f_err;\n        }\n\n        if (s->msg_callback)\n            s->msg_callback(0, s->version, SSL3_RT_HANDSHAKE,\n                            s->rlayer.handshake_fragment, 4, s,\n                            s->msg_callback_arg);\n\n        if (SSL_is_init_finished(s) &&\n            !(s->s3->flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS) &&\n            !s->s3->renegotiate) {\n            ssl3_renegotiate(s);\n            if (ssl3_renegotiate_check(s)) {\n                i = s->handshake_func(s);\n                if (i < 0)\n                    return (i);\n                if (i == 0) {\n                    SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_SSL_HANDSHAKE_FAILURE);\n                    return (-1);\n                }\n\n                if (!(s->mode & SSL_MODE_AUTO_RETRY)) {\n                    if (SSL3_BUFFER_get_left(rbuf) == 0) {\n                        /* no read-ahead left? */\n                        BIO *bio;\n                        /*\n                         * In the case where we try to read application data,\n                         * but we trigger an SSL handshake, we return -1 with\n                         * the retry option set.  Otherwise renegotiation may\n                         * cause nasty problems in the blocking world\n                         */\n                        s->rwstate = SSL_READING;\n                        bio = SSL_get_rbio(s);\n                        BIO_clear_retry_flags(bio);\n                        BIO_set_retry_read(bio);\n                        return (-1);\n                    }\n                }\n            } else {\n                SSL3_RECORD_set_read(rr);\n            }\n        } else {\n            /* Does this ever happen? */\n            SSL3_RECORD_set_read(rr);\n        }\n        /*\n         * we either finished a handshake or ignored the request, now try\n         * again to obtain the (application) data we were asked for\n         */\n        goto start;\n    }\n    /*\n     * If we are a server and get a client hello when renegotiation isn't\n     * allowed send back a no renegotiation alert and carry on. WARNING:\n     * experimental code, needs reviewing (steve)\n     */\n    if (s->server &&\n        SSL_is_init_finished(s) &&\n        !s->s3->send_connection_binding &&\n        (s->version > SSL3_VERSION) &&\n        (s->rlayer.handshake_fragment_len >= 4) &&\n        (s->rlayer.handshake_fragment[0] == SSL3_MT_CLIENT_HELLO) &&\n        (s->session != NULL) && (s->session->cipher != NULL) &&\n        !(s->ctx->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION)) {\n        SSL3_RECORD_set_length(rr, 0);\n        SSL3_RECORD_set_read(rr);\n        ssl3_send_alert(s, SSL3_AL_WARNING, SSL_AD_NO_RENEGOTIATION);\n        goto start;\n    }\n    if (s->rlayer.alert_fragment_len >= 2) {\n        int alert_level = s->rlayer.alert_fragment[0];\n        int alert_descr = s->rlayer.alert_fragment[1];\n\n        s->rlayer.alert_fragment_len = 0;\n\n        if (s->msg_callback)\n            s->msg_callback(0, s->version, SSL3_RT_ALERT,\n                            s->rlayer.alert_fragment, 2, s,\n                            s->msg_callback_arg);\n\n        if (s->info_callback != NULL)\n            cb = s->info_callback;\n        else if (s->ctx->info_callback != NULL)\n            cb = s->ctx->info_callback;\n\n        if (cb != NULL) {\n            j = (alert_level << 8) | alert_descr;\n            cb(s, SSL_CB_READ_ALERT, j);\n        }\n\n        if (alert_level == SSL3_AL_WARNING) {\n            s->s3->warn_alert = alert_descr;\n            SSL3_RECORD_set_read(rr);\n\n            s->rlayer.alert_count++;\n            if (s->rlayer.alert_count == MAX_WARN_ALERT_COUNT) {\n                al = SSL_AD_UNEXPECTED_MESSAGE;\n                SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_TOO_MANY_WARN_ALERTS);\n                goto f_err;\n            }\n\n            if (alert_descr == SSL_AD_CLOSE_NOTIFY) {\n                s->shutdown |= SSL_RECEIVED_SHUTDOWN;\n                return (0);\n            }\n            /*\n             * This is a warning but we receive it if we requested\n             * renegotiation and the peer denied it. Terminate with a fatal\n             * alert because if application tried to renegotiate it\n             * presumably had a good reason and expects it to succeed. In\n             * future we might have a renegotiation where we don't care if\n             * the peer refused it where we carry on.\n             */\n            else if (alert_descr == SSL_AD_NO_RENEGOTIATION) {\n                al = SSL_AD_HANDSHAKE_FAILURE;\n                SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_NO_RENEGOTIATION);\n                goto f_err;\n            }\n#ifdef SSL_AD_MISSING_SRP_USERNAME\n            else if (alert_descr == SSL_AD_MISSING_SRP_USERNAME)\n                return (0);\n#endif\n        } else if (alert_level == SSL3_AL_FATAL) {\n            char tmp[16];\n\n            s->rwstate = SSL_NOTHING;\n            s->s3->fatal_alert = alert_descr;\n            SSLerr(SSL_F_SSL3_READ_BYTES, SSL_AD_REASON_OFFSET + alert_descr);\n            BIO_snprintf(tmp, sizeof tmp, \"%d\", alert_descr);\n            ERR_add_error_data(2, \"SSL alert number \", tmp);\n            s->shutdown |= SSL_RECEIVED_SHUTDOWN;\n            SSL3_RECORD_set_read(rr);\n            SSL_CTX_remove_session(s->session_ctx, s->session);\n            return (0);\n        } else {\n            al = SSL_AD_ILLEGAL_PARAMETER;\n            SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_UNKNOWN_ALERT_TYPE);\n            goto f_err;\n        }\n\n        goto start;\n    }\n\n    if (s->shutdown & SSL_SENT_SHUTDOWN) { /* but we have not received a\n                                            * shutdown */\n        s->rwstate = SSL_NOTHING;\n        SSL3_RECORD_set_length(rr, 0);\n        SSL3_RECORD_set_read(rr);\n        return (0);\n    }\n\n    if (SSL3_RECORD_get_type(rr) == SSL3_RT_CHANGE_CIPHER_SPEC) {\n        al = SSL_AD_UNEXPECTED_MESSAGE;\n        SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_CCS_RECEIVED_EARLY);\n        goto f_err;\n    }\n\n    /*\n     * Unexpected handshake message (Client Hello, or protocol violation)\n     */\n    if ((s->rlayer.handshake_fragment_len >= 4)\n        && !ossl_statem_get_in_handshake(s)) {\n        if (SSL_is_init_finished(s) &&\n            !(s->s3->flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS)) {\n            ossl_statem_set_in_init(s, 1);\n            s->renegotiate = 1;\n            s->new_session = 1;\n        }\n        i = s->handshake_func(s);\n        if (i < 0)\n            return (i);\n        if (i == 0) {\n            SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_SSL_HANDSHAKE_FAILURE);\n            return (-1);\n        }\n\n        if (!(s->mode & SSL_MODE_AUTO_RETRY)) {\n            if (SSL3_BUFFER_get_left(rbuf) == 0) {\n                /* no read-ahead left? */\n                BIO *bio;\n                /*\n                 * In the case where we try to read application data, but we\n                 * trigger an SSL handshake, we return -1 with the retry\n                 * option set.  Otherwise renegotiation may cause nasty\n                 * problems in the blocking world\n                 */\n                s->rwstate = SSL_READING;\n                bio = SSL_get_rbio(s);\n                BIO_clear_retry_flags(bio);\n                BIO_set_retry_read(bio);\n                return (-1);\n            }\n        }\n        goto start;\n    }\n\n    switch (SSL3_RECORD_get_type(rr)) {\n    default:\n        /*\n         * TLS 1.0 and 1.1 say you SHOULD ignore unrecognised record types, but\n         * TLS 1.2 says you MUST send an unexpected message alert. We use the\n         * TLS 1.2 behaviour for all protocol versions to prevent issues where\n         * no progress is being made and the peer continually sends unrecognised\n         * record types, using up resources processing them.\n         */\n        al = SSL_AD_UNEXPECTED_MESSAGE;\n        SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_UNEXPECTED_RECORD);\n        goto f_err;\n    case SSL3_RT_CHANGE_CIPHER_SPEC:\n    case SSL3_RT_ALERT:\n    case SSL3_RT_HANDSHAKE:\n        /*\n         * we already handled all of these, with the possible exception of\n         * SSL3_RT_HANDSHAKE when ossl_statem_get_in_handshake(s) is true, but\n         * that should not happen when type != rr->type\n         */\n        al = SSL_AD_UNEXPECTED_MESSAGE;\n        SSLerr(SSL_F_SSL3_READ_BYTES, ERR_R_INTERNAL_ERROR);\n        goto f_err;\n    case SSL3_RT_APPLICATION_DATA:\n        /*\n         * At this point, we were expecting handshake data, but have\n         * application data.  If the library was running inside ssl3_read()\n         * (i.e. in_read_app_data is set) and it makes sense to read\n         * application data at this point (session renegotiation not yet\n         * started), we will indulge it.\n         */\n        if (ossl_statem_app_data_allowed(s)) {\n            s->s3->in_read_app_data = 2;\n            return (-1);\n        } else {\n            al = SSL_AD_UNEXPECTED_MESSAGE;\n            SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_UNEXPECTED_RECORD);\n            goto f_err;\n        }\n    }\n    /* not reached */\n\n f_err:\n    ssl3_send_alert(s, SSL3_AL_FATAL, al);\n    return (-1);\n}",
        "target": 0
    },
    {
        "func": "int tls1_final_finish_mac(SSL *s, const char *str, int slen, unsigned char *out)\n{\n    int hashlen;\n    unsigned char hash[EVP_MAX_MD_SIZE];\n\n    if (!ssl3_digest_cached_records(s, 0))\n        return 0;\n\n    hashlen = ssl_handshake_hash(s, hash, sizeof(hash));\n\n    if (hashlen == 0)\n        return 0;\n\n    if (!tls1_PRF(s, str, slen, hash, hashlen, NULL, 0, NULL, 0, NULL, 0,\n                  s->session->master_key, s->session->master_key_length,\n                  out, TLS1_FINISH_MAC_LENGTH))\n        return 0;\n    OPENSSL_cleanse(hash, hashlen);\n    return TLS1_FINISH_MAC_LENGTH;\n}",
        "target": 0
    },
    {
        "func": "static int tls_use_ticket(SSL *s)\n{\n    if (s->options & SSL_OP_NO_TICKET)\n        return 0;\n    return ssl_security(s, SSL_SECOP_TICKET, 0, 0, NULL);\n}",
        "target": 0
    },
    {
        "func": "int ssl_parse_clienthello_tlsext(SSL *s, PACKET *pkt)\n{\n    int al = -1;\n    custom_ext_init(&s->cert->srv_ext);\n    if (ssl_scan_clienthello_tlsext(s, pkt, &al) <= 0) {\n        ssl3_send_alert(s, SSL3_AL_FATAL, al);\n        return 0;\n    }\n    if (ssl_check_clienthello_tlsext_early(s) <= 0) {\n        SSLerr(SSL_F_SSL_PARSE_CLIENTHELLO_TLSEXT, SSL_R_CLIENTHELLO_TLSEXT);\n        return 0;\n    }\n    return 1;\n}",
        "target": 0
    },
    {
        "func": "int tls1_export_keying_material(SSL *s, unsigned char *out, size_t olen,\n                                const char *label, size_t llen,\n                                const unsigned char *context,\n                                size_t contextlen, int use_context)\n{\n    unsigned char *val = NULL;\n    size_t vallen = 0, currentvalpos;\n    int rv;\n\n    /*\n     * construct PRF arguments we construct the PRF argument ourself rather\n     * than passing separate values into the TLS PRF to ensure that the\n     * concatenation of values does not create a prohibited label.\n     */\n    vallen = llen + SSL3_RANDOM_SIZE * 2;\n    if (use_context) {\n        vallen += 2 + contextlen;\n    }\n\n    val = OPENSSL_malloc(vallen);\n    if (val == NULL)\n        goto err2;\n    currentvalpos = 0;\n    memcpy(val + currentvalpos, (unsigned char *)label, llen);\n    currentvalpos += llen;\n    memcpy(val + currentvalpos, s->s3->client_random, SSL3_RANDOM_SIZE);\n    currentvalpos += SSL3_RANDOM_SIZE;\n    memcpy(val + currentvalpos, s->s3->server_random, SSL3_RANDOM_SIZE);\n    currentvalpos += SSL3_RANDOM_SIZE;\n\n    if (use_context) {\n        val[currentvalpos] = (contextlen >> 8) & 0xff;\n        currentvalpos++;\n        val[currentvalpos] = contextlen & 0xff;\n        currentvalpos++;\n        if ((contextlen > 0) || (context != NULL)) {\n            memcpy(val + currentvalpos, context, contextlen);\n        }\n    }\n\n    /*\n     * disallow prohibited labels note that SSL3_RANDOM_SIZE > max(prohibited\n     * label len) = 15, so size of val > max(prohibited label len) = 15 and\n     * the comparisons won't have buffer overflow\n     */\n    if (memcmp(val, TLS_MD_CLIENT_FINISH_CONST,\n               TLS_MD_CLIENT_FINISH_CONST_SIZE) == 0)\n        goto err1;\n    if (memcmp(val, TLS_MD_SERVER_FINISH_CONST,\n               TLS_MD_SERVER_FINISH_CONST_SIZE) == 0)\n        goto err1;\n    if (memcmp(val, TLS_MD_MASTER_SECRET_CONST,\n               TLS_MD_MASTER_SECRET_CONST_SIZE) == 0)\n        goto err1;\n    if (memcmp(val, TLS_MD_EXTENDED_MASTER_SECRET_CONST,\n               TLS_MD_EXTENDED_MASTER_SECRET_CONST_SIZE) == 0)\n        goto err1;\n    if (memcmp(val, TLS_MD_KEY_EXPANSION_CONST,\n               TLS_MD_KEY_EXPANSION_CONST_SIZE) == 0)\n        goto err1;\n\n    rv = tls1_PRF(s,\n                  val, vallen,\n                  NULL, 0,\n                  NULL, 0,\n                  NULL, 0,\n                  NULL, 0,\n                  s->session->master_key, s->session->master_key_length,\n                  out, olen);\n\n    goto ret;\n err1:\n    SSLerr(SSL_F_TLS1_EXPORT_KEYING_MATERIAL, SSL_R_TLS_ILLEGAL_EXPORTER_LABEL);\n    rv = 0;\n    goto ret;\n err2:\n    SSLerr(SSL_F_TLS1_EXPORT_KEYING_MATERIAL, ERR_R_MALLOC_FAILURE);\n    rv = 0;\n ret:\n    OPENSSL_clear_free(val, vallen);\n    return (rv);\n}",
        "target": 0
    },
    {
        "func": "int tls1_setup_key_block(SSL *s)\n{\n    unsigned char *p;\n    const EVP_CIPHER *c;\n    const EVP_MD *hash;\n    int num;\n    SSL_COMP *comp;\n    int mac_type = NID_undef, mac_secret_size = 0;\n    int ret = 0;\n\n    if (s->s3->tmp.key_block_length != 0)\n        return (1);\n\n    if (!ssl_cipher_get_evp(s->session, &c, &hash, &mac_type, &mac_secret_size,\n                            &comp, s->tlsext_use_etm)) {\n        SSLerr(SSL_F_TLS1_SETUP_KEY_BLOCK, SSL_R_CIPHER_OR_HASH_UNAVAILABLE);\n        return (0);\n    }\n\n    s->s3->tmp.new_sym_enc = c;\n    s->s3->tmp.new_hash = hash;\n    s->s3->tmp.new_mac_pkey_type = mac_type;\n    s->s3->tmp.new_mac_secret_size = mac_secret_size;\n    num = EVP_CIPHER_key_length(c) + mac_secret_size + EVP_CIPHER_iv_length(c);\n    num *= 2;\n\n    ssl3_cleanup_key_block(s);\n\n    if ((p = OPENSSL_malloc(num)) == NULL) {\n        SSLerr(SSL_F_TLS1_SETUP_KEY_BLOCK, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    s->s3->tmp.key_block_length = num;\n    s->s3->tmp.key_block = p;\n\n#ifdef SSL_DEBUG\n    printf(\"client random\\n\");\n    {\n        int z;\n        for (z = 0; z < SSL3_RANDOM_SIZE; z++)\n            printf(\"%02X%c\", s->s3->client_random[z],\n                   ((z + 1) % 16) ? ' ' : '\\n');\n    }\n    printf(\"server random\\n\");\n    {\n        int z;\n        for (z = 0; z < SSL3_RANDOM_SIZE; z++)\n            printf(\"%02X%c\", s->s3->server_random[z],\n                   ((z + 1) % 16) ? ' ' : '\\n');\n    }\n    printf(\"master key\\n\");\n    {\n        int z;\n        for (z = 0; z < s->session->master_key_length; z++)\n            printf(\"%02X%c\", s->session->master_key[z],\n                   ((z + 1) % 16) ? ' ' : '\\n');\n    }\n#endif\n    if (!tls1_generate_key_block(s, p, num))\n        goto err;\n#ifdef SSL_DEBUG\n    printf(\"\\nkey block\\n\");\n    {\n        int z;\n        for (z = 0; z < num; z++)\n            printf(\"%02X%c\", p[z], ((z + 1) % 16) ? ' ' : '\\n');\n    }\n#endif\n\n    if (!(s->options & SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS)\n        && s->method->version <= TLS1_VERSION) {\n        /*\n         * enable vulnerability countermeasure for CBC ciphers with known-IV\n         * problem (http://www.openssl.org/~bodo/tls-cbc.txt)\n         */\n        s->s3->need_empty_fragments = 1;\n\n        if (s->session->cipher != NULL) {\n            if (s->session->cipher->algorithm_enc == SSL_eNULL)\n                s->s3->need_empty_fragments = 0;\n\n#ifndef OPENSSL_NO_RC4\n            if (s->session->cipher->algorithm_enc == SSL_RC4)\n                s->s3->need_empty_fragments = 0;\n#endif\n        }\n    }\n\n    ret = 1;\n err:\n    return (ret);\n}",
        "target": 0
    },
    {
        "func": "int tls1_ec_curve_id2nid(int curve_id, unsigned int *pflags)\n{\n    const tls_curve_info *cinfo;\n    /* ECC curves from RFC 4492 and RFC 7027 */\n    if ((curve_id < 1) || ((unsigned int)curve_id > OSSL_NELEM(nid_list)))\n        return 0;\n    cinfo = nid_list + curve_id - 1;\n    if (pflags)\n        *pflags = cinfo->flags;\n    return cinfo->nid;\n}",
        "target": 0
    },
    {
        "func": "int SSL_get_sigalgs(SSL *s, int idx,\n                    int *psign, int *phash, int *psignhash,\n                    unsigned char *rsig, unsigned char *rhash)\n{\n    const unsigned char *psig = s->s3->tmp.peer_sigalgs;\n    if (psig == NULL)\n        return 0;\n    if (idx >= 0) {\n        idx <<= 1;\n        if (idx >= (int)s->s3->tmp.peer_sigalgslen)\n            return 0;\n        psig += idx;\n        if (rhash)\n            *rhash = psig[0];\n        if (rsig)\n            *rsig = psig[1];\n        tls1_lookup_sigalg(phash, psign, psignhash, psig);\n    }\n    return s->s3->tmp.peer_sigalgslen / 2;\n}",
        "target": 0
    },
    {
        "func": "static void tls1_lookup_sigalg(int *phash_nid, int *psign_nid,\n                               int *psignhash_nid, const unsigned char *data)\n{\n    int sign_nid = NID_undef, hash_nid = NID_undef;\n    if (!phash_nid && !psign_nid && !psignhash_nid)\n        return;\n    if (phash_nid || psignhash_nid) {\n        hash_nid = tls12_find_nid(data[0], tls12_md, OSSL_NELEM(tls12_md));\n        if (phash_nid)\n            *phash_nid = hash_nid;\n    }\n    if (psign_nid || psignhash_nid) {\n        sign_nid = tls12_find_nid(data[1], tls12_sig, OSSL_NELEM(tls12_sig));\n        if (psign_nid)\n            *psign_nid = sign_nid;\n    }\n    if (psignhash_nid) {\n        if (sign_nid == NID_undef || hash_nid == NID_undef\n            || OBJ_find_sigid_by_algs(psignhash_nid, hash_nid, sign_nid) <= 0)\n            *psignhash_nid = NID_undef;\n    }\n}",
        "target": 0
    },
    {
        "func": "static int tls12_find_id(int nid, const tls12_lookup *table, size_t tlen)\n{\n    size_t i;\n    for (i = 0; i < tlen; i++) {\n        if (table[i].nid == nid)\n            return table[i].id;\n    }\n    return -1;\n}",
        "target": 0
    },
    {
        "func": "int ssl3_read_n(SSL *s, int n, int max, int extend, int clearold)\n{\n    /*\n     * If extend == 0, obtain new n-byte packet; if extend == 1, increase\n     * packet by another n bytes. The packet will be in the sub-array of\n     * s->s3->rbuf.buf specified by s->packet and s->packet_length. (If\n     * s->rlayer.read_ahead is set, 'max' bytes may be stored in rbuf [plus\n     * s->packet_length bytes if extend == 1].)\n     * if clearold == 1, move the packet to the start of the buffer; if\n     * clearold == 0 then leave any old packets where they were\n     */\n    int i, len, left;\n    size_t align = 0;\n    unsigned char *pkt;\n    SSL3_BUFFER *rb;\n\n    if (n <= 0)\n        return n;\n\n    rb = &s->rlayer.rbuf;\n    if (rb->buf == NULL)\n        if (!ssl3_setup_read_buffer(s))\n            return -1;\n\n    left = rb->left;\n#if defined(SSL3_ALIGN_PAYLOAD) && SSL3_ALIGN_PAYLOAD!=0\n    align = (size_t)rb->buf + SSL3_RT_HEADER_LENGTH;\n    align = SSL3_ALIGN_PAYLOAD - 1 - ((align - 1) % SSL3_ALIGN_PAYLOAD);\n#endif\n\n    if (!extend) {\n        /* start with empty packet ... */\n        if (left == 0)\n            rb->offset = align;\n        else if (align != 0 && left >= SSL3_RT_HEADER_LENGTH) {\n            /*\n             * check if next packet length is large enough to justify payload\n             * alignment...\n             */\n            pkt = rb->buf + rb->offset;\n            if (pkt[0] == SSL3_RT_APPLICATION_DATA\n                && (pkt[3] << 8 | pkt[4]) >= 128) {\n                /*\n                 * Note that even if packet is corrupted and its length field\n                 * is insane, we can only be led to wrong decision about\n                 * whether memmove will occur or not. Header values has no\n                 * effect on memmove arguments and therefore no buffer\n                 * overrun can be triggered.\n                 */\n                memmove(rb->buf + align, pkt, left);\n                rb->offset = align;\n            }\n        }\n        s->rlayer.packet = rb->buf + rb->offset;\n        s->rlayer.packet_length = 0;\n        /* ... now we can act as if 'extend' was set */\n    }\n\n    len = s->rlayer.packet_length;\n    pkt = rb->buf + align;\n    /*\n     * Move any available bytes to front of buffer: 'len' bytes already\n     * pointed to by 'packet', 'left' extra ones at the end\n     */\n    if (s->rlayer.packet != pkt && clearold == 1) {\n        memmove(pkt, s->rlayer.packet, len + left);\n        s->rlayer.packet = pkt;\n        rb->offset = len + align;\n    }\n\n    /*\n     * For DTLS/UDP reads should not span multiple packets because the read\n     * operation returns the whole packet at once (as long as it fits into\n     * the buffer).\n     */\n    if (SSL_IS_DTLS(s)) {\n        if (left == 0 && extend)\n            return 0;\n        if (left > 0 && n > left)\n            n = left;\n    }\n\n    /* if there is enough in the buffer from a previous read, take some */\n    if (left >= n) {\n        s->rlayer.packet_length += n;\n        rb->left = left - n;\n        rb->offset += n;\n        return (n);\n    }\n\n    /* else we need to read more data */\n\n    if (n > (int)(rb->len - rb->offset)) { /* does not happen */\n        SSLerr(SSL_F_SSL3_READ_N, ERR_R_INTERNAL_ERROR);\n        return -1;\n    }\n\n    /* We always act like read_ahead is set for DTLS */\n    if (!s->rlayer.read_ahead && !SSL_IS_DTLS(s))\n        /* ignore max parameter */\n        max = n;\n    else {\n        if (max < n)\n            max = n;\n        if (max > (int)(rb->len - rb->offset))\n            max = rb->len - rb->offset;\n    }\n\n    while (left < n) {\n        /*\n         * Now we have len+left bytes at the front of s->s3->rbuf.buf and\n         * need to read in more until we have len+n (up to len+max if\n         * possible)\n         */\n\n        clear_sys_error();\n        if (s->rbio != NULL) {\n            s->rwstate = SSL_READING;\n            i = BIO_read(s->rbio, pkt + len + left, max - left);\n        } else {\n            SSLerr(SSL_F_SSL3_READ_N, SSL_R_READ_BIO_NOT_SET);\n            i = -1;\n        }\n\n        if (i <= 0) {\n            rb->left = left;\n            if (s->mode & SSL_MODE_RELEASE_BUFFERS && !SSL_IS_DTLS(s))\n                if (len + left == 0)\n                    ssl3_release_read_buffer(s);\n            return i;\n        }\n        left += i;\n        /*\n         * reads should *never* span multiple packets for DTLS because the\n         * underlying transport protocol is message oriented as opposed to\n         * byte oriented as in the TLS case.\n         */\n        if (SSL_IS_DTLS(s)) {\n            if (n > left)\n                n = left;       /* makes the while condition false */\n        }\n    }\n\n    /* done reading, now the book-keeping */\n    rb->offset += n;\n    rb->left = left - n;\n    s->rlayer.packet_length += n;\n    s->rwstate = SSL_NOTHING;\n    return (n);\n}",
        "target": 0
    },
    {
        "func": "void RECORD_LAYER_clear(RECORD_LAYER *rl)\n{\n    rl->rstate = SSL_ST_READ_HEADER;\n\n    /*\n     * Do I need to clear read_ahead? As far as I can tell read_ahead did not\n     * previously get reset by SSL_clear...so I'll keep it that way..but is\n     * that right?\n     */\n\n    rl->packet = NULL;\n    rl->packet_length = 0;\n    rl->wnum = 0;\n    memset(rl->alert_fragment, 0, sizeof(rl->alert_fragment));\n    rl->alert_fragment_len = 0;\n    memset(rl->handshake_fragment, 0, sizeof(rl->handshake_fragment));\n    rl->handshake_fragment_len = 0;\n    rl->wpend_tot = 0;\n    rl->wpend_type = 0;\n    rl->wpend_ret = 0;\n    rl->wpend_buf = NULL;\n\n    SSL3_BUFFER_clear(&rl->rbuf);\n    ssl3_release_write_buffer(rl->s);\n    rl->numrpipes = 0;\n    SSL3_RECORD_clear(rl->rrec, SSL_MAX_PIPELINES);\n\n    RECORD_LAYER_reset_read_sequence(rl);\n    RECORD_LAYER_reset_write_sequence(rl);\n\n    if (rl->d)\n        DTLS_RECORD_LAYER_clear(rl);\n}",
        "target": 0
    },
    {
        "func": "static int tls1_check_ec_key(SSL *s,\n                             unsigned char *curve_id, unsigned char *comp_id)\n{\n    const unsigned char *pformats, *pcurves;\n    size_t num_formats, num_curves, i;\n    int j;\n    /*\n     * If point formats extension present check it, otherwise everything is\n     * supported (see RFC4492).\n     */\n    if (comp_id && s->session->tlsext_ecpointformatlist) {\n        pformats = s->session->tlsext_ecpointformatlist;\n        num_formats = s->session->tlsext_ecpointformatlist_length;\n        for (i = 0; i < num_formats; i++, pformats++) {\n            if (*comp_id == *pformats)\n                break;\n        }\n        if (i == num_formats)\n            return 0;\n    }\n    if (!curve_id)\n        return 1;\n    /* Check curve is consistent with client and server preferences */\n    for (j = 0; j <= 1; j++) {\n        if (!tls1_get_curvelist(s, j, &pcurves, &num_curves))\n            return 0;\n        if (j == 1 && num_curves == 0) {\n            /*\n             * If we've not received any curves then skip this check.\n             * RFC 4492 does not require the supported elliptic curves extension\n             * so if it is not sent we can just choose any curve.\n             * It is invalid to send an empty list in the elliptic curves\n             * extension, so num_curves == 0 always means no extension.\n             */\n            break;\n        }\n        for (i = 0; i < num_curves; i++, pcurves += 2) {\n            if (pcurves[0] == curve_id[0] && pcurves[1] == curve_id[1])\n                break;\n        }\n        if (i == num_curves)\n            return 0;\n        /* For clients can only check sent curve list */\n        if (!s->server)\n            break;\n    }\n    return 1;\n}",
        "target": 0
    },
    {
        "func": "void ssl_set_default_md(SSL *s)\n{\n    const EVP_MD **pmd = s->s3->tmp.md;\n#ifndef OPENSSL_NO_DSA\n    pmd[SSL_PKEY_DSA_SIGN] = ssl_md(SSL_MD_SHA1_IDX);\n#endif\n#ifndef OPENSSL_NO_RSA\n    if (SSL_USE_SIGALGS(s))\n        pmd[SSL_PKEY_RSA_SIGN] = ssl_md(SSL_MD_SHA1_IDX);\n    else\n        pmd[SSL_PKEY_RSA_SIGN] = ssl_md(SSL_MD_MD5_SHA1_IDX);\n    pmd[SSL_PKEY_RSA_ENC] = pmd[SSL_PKEY_RSA_SIGN];\n#endif\n#ifndef OPENSSL_NO_EC\n    pmd[SSL_PKEY_ECC] = ssl_md(SSL_MD_SHA1_IDX);\n#endif\n#ifndef OPENSSL_NO_GOST\n    pmd[SSL_PKEY_GOST01] = ssl_md(SSL_MD_GOST94_IDX);\n    pmd[SSL_PKEY_GOST12_256] = ssl_md(SSL_MD_GOST12_256_IDX);\n    pmd[SSL_PKEY_GOST12_512] = ssl_md(SSL_MD_GOST12_512_IDX);\n#endif\n}",
        "target": 0
    },
    {
        "func": "int ssl_cipher_disabled(SSL *s, const SSL_CIPHER *c, int op)\n{\n    if (c->algorithm_mkey & s->s3->tmp.mask_k\n        || c->algorithm_auth & s->s3->tmp.mask_a)\n        return 1;\n    if (s->s3->tmp.max_ver == 0)\n        return 1;\n    if (!SSL_IS_DTLS(s) && ((c->min_tls > s->s3->tmp.max_ver)\n                            || (c->max_tls < s->s3->tmp.min_ver)))\n        return 1;\n    if (SSL_IS_DTLS(s) && (DTLS_VERSION_GT(c->min_dtls, s->s3->tmp.max_ver)\n                           || DTLS_VERSION_LT(c->max_dtls, s->s3->tmp.min_ver)))\n        return 1;\n\n    return !ssl_security(s, op, c->strength_bits, 0, (void *)c);\n}",
        "target": 0
    },
    {
        "func": "static int ssl_scan_clienthello_tlsext(SSL *s, PACKET *pkt, int *al)\n{\n    unsigned int type;\n    int renegotiate_seen = 0;\n    PACKET extensions;\n\n    *al = SSL_AD_DECODE_ERROR;\n    s->servername_done = 0;\n    s->tlsext_status_type = -1;\n#ifndef OPENSSL_NO_NEXTPROTONEG\n    s->s3->next_proto_neg_seen = 0;\n#endif\n\n    OPENSSL_free(s->s3->alpn_selected);\n    s->s3->alpn_selected = NULL;\n    s->s3->alpn_selected_len = 0;\n    OPENSSL_free(s->s3->alpn_proposed);\n    s->s3->alpn_proposed = NULL;\n    s->s3->alpn_proposed_len = 0;\n#ifndef OPENSSL_NO_HEARTBEATS\n    s->tlsext_heartbeat &= ~(SSL_DTLSEXT_HB_ENABLED |\n                             SSL_DTLSEXT_HB_DONT_SEND_REQUESTS);\n#endif\n\n#ifndef OPENSSL_NO_EC\n    if (s->options & SSL_OP_SAFARI_ECDHE_ECDSA_BUG)\n        ssl_check_for_safari(s, pkt);\n#endif                          /* !OPENSSL_NO_EC */\n\n    /* Clear any signature algorithms extension received */\n    OPENSSL_free(s->s3->tmp.peer_sigalgs);\n    s->s3->tmp.peer_sigalgs = NULL;\n    s->tlsext_use_etm = 0;\n\n#ifndef OPENSSL_NO_SRP\n    OPENSSL_free(s->srp_ctx.login);\n    s->srp_ctx.login = NULL;\n#endif\n\n    s->srtp_profile = NULL;\n\n    if (PACKET_remaining(pkt) == 0)\n        goto ri_check;\n\n    if (!PACKET_as_length_prefixed_2(pkt, &extensions))\n        return 0;\n\n    if (!tls1_check_duplicate_extensions(&extensions))\n        return 0;\n\n    /*\n     * We parse all extensions to ensure the ClientHello is well-formed but,\n     * unless an extension specifies otherwise, we ignore extensions upon\n     * resumption.\n     */\n    while (PACKET_get_net_2(&extensions, &type)) {\n        PACKET extension;\n        if (!PACKET_get_length_prefixed_2(&extensions, &extension))\n            return 0;\n\n        if (s->tlsext_debug_cb)\n            s->tlsext_debug_cb(s, 0, type, PACKET_data(&extension),\n                               PACKET_remaining(&extension),\n                               s->tlsext_debug_arg);\n\n        if (type == TLSEXT_TYPE_renegotiate) {\n            if (!ssl_parse_clienthello_renegotiate_ext(s, &extension, al))\n                return 0;\n            renegotiate_seen = 1;\n        } else if (s->version == SSL3_VERSION) {\n        }\n/*-\n * The servername extension is treated as follows:\n *\n * - Only the hostname type is supported with a maximum length of 255.\n * - The servername is rejected if too long or if it contains zeros,\n *   in which case an fatal alert is generated.\n * - The servername field is maintained together with the session cache.\n * - When a session is resumed, the servername call back invoked in order\n *   to allow the application to position itself to the right context.\n * - The servername is acknowledged if it is new for a session or when\n *   it is identical to a previously used for the same session.\n *   Applications can control the behaviour.  They can at any time\n *   set a 'desirable' servername for a new SSL object. This can be the\n *   case for example with HTTPS when a Host: header field is received and\n *   a renegotiation is requested. In this case, a possible servername\n *   presented in the new client hello is only acknowledged if it matches\n *   the value of the Host: field.\n * - Applications must  use SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION\n *   if they provide for changing an explicit servername context for the\n *   session, i.e. when the session has been established with a servername\n *   extension.\n * - On session reconnect, the servername extension may be absent.\n *\n */\n\n        else if (type == TLSEXT_TYPE_server_name) {\n            unsigned int servname_type;\n            PACKET sni, hostname;\n\n            if (!PACKET_as_length_prefixed_2(&extension, &sni)\n                /* ServerNameList must be at least 1 byte long. */\n                || PACKET_remaining(&sni) == 0) {\n                return 0;\n            }\n\n            /*\n             * Although the server_name extension was intended to be\n             * extensible to new name types, RFC 4366 defined the\n             * syntax inextensibility and OpenSSL 1.0.x parses it as\n             * such.\n             * RFC 6066 corrected the mistake but adding new name types\n             * is nevertheless no longer feasible, so act as if no other\n             * SNI types can exist, to simplify parsing.\n             *\n             * Also note that the RFC permits only one SNI value per type,\n             * i.e., we can only have a single hostname.\n             */\n            if (!PACKET_get_1(&sni, &servname_type)\n                || servname_type != TLSEXT_NAMETYPE_host_name\n                || !PACKET_as_length_prefixed_2(&sni, &hostname)) {\n                return 0;\n            }\n\n            if (!s->hit) {\n                if (PACKET_remaining(&hostname) > TLSEXT_MAXLEN_host_name) {\n                    *al = TLS1_AD_UNRECOGNIZED_NAME;\n                    return 0;\n                }\n\n                if (PACKET_contains_zero_byte(&hostname)) {\n                    *al = TLS1_AD_UNRECOGNIZED_NAME;\n                    return 0;\n                }\n\n                if (!PACKET_strndup(&hostname, &s->session->tlsext_hostname)) {\n                    *al = TLS1_AD_INTERNAL_ERROR;\n                    return 0;\n                }\n\n                s->servername_done = 1;\n            } else {\n                /*\n                 * TODO(openssl-team): if the SNI doesn't match, we MUST\n                 * fall back to a full handshake.\n                 */\n                s->servername_done = s->session->tlsext_hostname\n                    && PACKET_equal(&hostname, s->session->tlsext_hostname,\n                                    strlen(s->session->tlsext_hostname));\n            }\n        }\n#ifndef OPENSSL_NO_SRP\n        else if (type == TLSEXT_TYPE_srp) {\n            PACKET srp_I;\n\n            if (!PACKET_as_length_prefixed_1(&extension, &srp_I))\n                return 0;\n\n            if (PACKET_contains_zero_byte(&srp_I))\n                return 0;\n\n            /*\n             * TODO(openssl-team): currently, we re-authenticate the user\n             * upon resumption. Instead, we MUST ignore the login.\n             */\n            if (!PACKET_strndup(&srp_I, &s->srp_ctx.login)) {\n                *al = TLS1_AD_INTERNAL_ERROR;\n                return 0;\n            }\n        }\n#endif\n\n#ifndef OPENSSL_NO_EC\n        else if (type == TLSEXT_TYPE_ec_point_formats) {\n            PACKET ec_point_format_list;\n\n            if (!PACKET_as_length_prefixed_1(&extension, &ec_point_format_list)\n                || PACKET_remaining(&ec_point_format_list) == 0) {\n                return 0;\n            }\n\n            if (!s->hit) {\n                if (!PACKET_memdup(&ec_point_format_list,\n                                   &s->session->tlsext_ecpointformatlist,\n                                   &s->\n                                   session->tlsext_ecpointformatlist_length)) {\n                    *al = TLS1_AD_INTERNAL_ERROR;\n                    return 0;\n                }\n            }\n        } else if (type == TLSEXT_TYPE_elliptic_curves) {\n            PACKET elliptic_curve_list;\n\n            /* Each NamedCurve is 2 bytes and we must have at least 1. */\n            if (!PACKET_as_length_prefixed_2(&extension, &elliptic_curve_list)\n                || PACKET_remaining(&elliptic_curve_list) == 0\n                || (PACKET_remaining(&elliptic_curve_list) % 2) != 0) {\n                return 0;\n            }\n\n            if (!s->hit) {\n                if (!PACKET_memdup(&elliptic_curve_list,\n                                   &s->session->tlsext_ellipticcurvelist,\n                                   &s->\n                                   session->tlsext_ellipticcurvelist_length)) {\n                    *al = TLS1_AD_INTERNAL_ERROR;\n                    return 0;\n                }\n            }\n        }\n#endif                          /* OPENSSL_NO_EC */\n        else if (type == TLSEXT_TYPE_session_ticket) {\n            if (s->tls_session_ticket_ext_cb &&\n                !s->tls_session_ticket_ext_cb(s, PACKET_data(&extension),\n                                              PACKET_remaining(&extension),\n                                              s->tls_session_ticket_ext_cb_arg))\n            {\n                *al = TLS1_AD_INTERNAL_ERROR;\n                return 0;\n            }\n        } else if (type == TLSEXT_TYPE_signature_algorithms) {\n            PACKET supported_sig_algs;\n\n            if (!PACKET_as_length_prefixed_2(&extension, &supported_sig_algs)\n                || (PACKET_remaining(&supported_sig_algs) % 2) != 0\n                || PACKET_remaining(&supported_sig_algs) == 0) {\n                return 0;\n            }\n\n            if (!s->hit) {\n                if (!tls1_save_sigalgs(s, PACKET_data(&supported_sig_algs),\n                                       PACKET_remaining(&supported_sig_algs))) {\n                    return 0;\n                }\n            }\n        } else if (type == TLSEXT_TYPE_status_request) {\n            if (!PACKET_get_1(&extension,\n                              (unsigned int *)&s->tlsext_status_type)) {\n                return 0;\n            }\n#ifndef OPENSSL_NO_OCSP\n            if (s->tlsext_status_type == TLSEXT_STATUSTYPE_ocsp) {\n                const unsigned char *ext_data;\n                PACKET responder_id_list, exts;\n                if (!PACKET_get_length_prefixed_2\n                    (&extension, &responder_id_list))\n                    return 0;\n\n                /*\n                 * We remove any OCSP_RESPIDs from a previous handshake\n                 * to prevent unbounded memory growth - CVE-2016-6304\n                 */\n                sk_OCSP_RESPID_pop_free(s->tlsext_ocsp_ids,\n                                        OCSP_RESPID_free);\n                if (PACKET_remaining(&responder_id_list) > 0) {\n                    s->tlsext_ocsp_ids = sk_OCSP_RESPID_new_null();\n                    if (s->tlsext_ocsp_ids == NULL) {\n                        *al = SSL_AD_INTERNAL_ERROR;\n                        return 0;\n                    }\n                } else {\n                    s->tlsext_ocsp_ids = NULL;\n                }\n\n                while (PACKET_remaining(&responder_id_list) > 0) {\n                    OCSP_RESPID *id;\n                    PACKET responder_id;\n                    const unsigned char *id_data;\n\n                    if (!PACKET_get_length_prefixed_2(&responder_id_list,\n                                                      &responder_id)\n                        || PACKET_remaining(&responder_id) == 0) {\n                        return 0;\n                    }\n\n                    id_data = PACKET_data(&responder_id);\n                    id = d2i_OCSP_RESPID(NULL, &id_data,\n                                         PACKET_remaining(&responder_id));\n                    if (id == NULL)\n                        return 0;\n\n                    if (id_data != PACKET_end(&responder_id)) {\n                        OCSP_RESPID_free(id);\n                        return 0;\n                    }\n\n                    if (!sk_OCSP_RESPID_push(s->tlsext_ocsp_ids, id)) {\n                        OCSP_RESPID_free(id);\n                        *al = SSL_AD_INTERNAL_ERROR;\n                        return 0;\n                    }\n                }\n\n                /* Read in request_extensions */\n                if (!PACKET_as_length_prefixed_2(&extension, &exts))\n                    return 0;\n\n                if (PACKET_remaining(&exts) > 0) {\n                    ext_data = PACKET_data(&exts);\n                    sk_X509_EXTENSION_pop_free(s->tlsext_ocsp_exts,\n                                               X509_EXTENSION_free);\n                    s->tlsext_ocsp_exts =\n                        d2i_X509_EXTENSIONS(NULL, &ext_data,\n                                            PACKET_remaining(&exts));\n                    if (s->tlsext_ocsp_exts == NULL\n                        || ext_data != PACKET_end(&exts)) {\n                        return 0;\n                    }\n                }\n            } else\n#endif\n            {\n                /*\n                 * We don't know what to do with any other type so ignore it.\n                 */\n                s->tlsext_status_type = -1;\n            }\n        }\n#ifndef OPENSSL_NO_HEARTBEATS\n        else if (SSL_IS_DTLS(s) && type == TLSEXT_TYPE_heartbeat) {\n            unsigned int hbtype;\n\n            if (!PACKET_get_1(&extension, &hbtype)\n                || PACKET_remaining(&extension)) {\n                *al = SSL_AD_DECODE_ERROR;\n                return 0;\n            }\n            switch (hbtype) {\n            case 0x01:         /* Client allows us to send HB requests */\n                s->tlsext_heartbeat |= SSL_DTLSEXT_HB_ENABLED;\n                break;\n            case 0x02:         /* Client doesn't accept HB requests */\n                s->tlsext_heartbeat |= SSL_DTLSEXT_HB_ENABLED;\n                s->tlsext_heartbeat |= SSL_DTLSEXT_HB_DONT_SEND_REQUESTS;\n                break;\n            default:\n                *al = SSL_AD_ILLEGAL_PARAMETER;\n                return 0;\n            }\n        }\n#endif\n#ifndef OPENSSL_NO_NEXTPROTONEG\n        else if (type == TLSEXT_TYPE_next_proto_neg &&\n                 s->s3->tmp.finish_md_len == 0) {\n            /*-\n             * We shouldn't accept this extension on a\n             * renegotiation.\n             *\n             * s->new_session will be set on renegotiation, but we\n             * probably shouldn't rely that it couldn't be set on\n             * the initial renegotiation too in certain cases (when\n             * there's some other reason to disallow resuming an\n             * earlier session -- the current code won't be doing\n             * anything like that, but this might change).\n             *\n             * A valid sign that there's been a previous handshake\n             * in this connection is if s->s3->tmp.finish_md_len >\n             * 0.  (We are talking about a check that will happen\n             * in the Hello protocol round, well before a new\n             * Finished message could have been computed.)\n             */\n            s->s3->next_proto_neg_seen = 1;\n        }\n#endif\n\n        else if (type == TLSEXT_TYPE_application_layer_protocol_negotiation &&\n                 s->s3->tmp.finish_md_len == 0) {\n            if (!tls1_alpn_handle_client_hello(s, &extension, al))\n                return 0;\n        }\n\n        /* session ticket processed earlier */\n#ifndef OPENSSL_NO_SRTP\n        else if (SSL_IS_DTLS(s) && SSL_get_srtp_profiles(s)\n                 && type == TLSEXT_TYPE_use_srtp) {\n            if (ssl_parse_clienthello_use_srtp_ext(s, &extension, al))\n                return 0;\n        }\n#endif\n        else if (type == TLSEXT_TYPE_encrypt_then_mac)\n            s->tlsext_use_etm = 1;\n        /*\n         * Note: extended master secret extension handled in\n         * tls_check_serverhello_tlsext_early()\n         */\n\n        /*\n         * If this ClientHello extension was unhandled and this is a\n         * nonresumed connection, check whether the extension is a custom\n         * TLS Extension (has a custom_srv_ext_record), and if so call the\n         * callback and record the extension number so that an appropriate\n         * ServerHello may be later returned.\n         */\n        else if (!s->hit) {\n            if (custom_ext_parse(s, 1, type, PACKET_data(&extension),\n                                 PACKET_remaining(&extension), al) <= 0)\n                return 0;\n        }\n    }\n\n    if (PACKET_remaining(pkt) != 0) {\n        /*\n         * tls1_check_duplicate_extensions should ensure this never happens.\n         */\n        *al = SSL_AD_INTERNAL_ERROR;\n        return 0;\n    }\n\n ri_check:\n\n    /* Need RI if renegotiating */\n\n    if (!renegotiate_seen && s->renegotiate &&\n        !(s->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION)) {\n        *al = SSL_AD_HANDSHAKE_FAILURE;\n        SSLerr(SSL_F_SSL_SCAN_CLIENTHELLO_TLSEXT,\n               SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED);\n        return 0;\n    }\n\n    /*\n     * This function currently has no state to clean up, so it returns directly.\n     * If parsing fails at any point, the function returns early.\n     * The SSL object may be left with partial data from extensions, but it must\n     * then no longer be used, and clearing it up will free the leftovers.\n     */\n    return 1;\n}",
        "target": 0
    },
    {
        "func": "static int tls_decrypt_ticket(SSL *s, const unsigned char *etick,\n                              int eticklen, const unsigned char *sess_id,\n                              int sesslen, SSL_SESSION **psess)\n{\n    SSL_SESSION *sess;\n    unsigned char *sdec;\n    const unsigned char *p;\n    int slen, mlen, renew_ticket = 0, ret = -1;\n    unsigned char tick_hmac[EVP_MAX_MD_SIZE];\n    HMAC_CTX *hctx = NULL;\n    EVP_CIPHER_CTX *ctx;\n    SSL_CTX *tctx = s->session_ctx;\n\n    /* Initialize session ticket encryption and HMAC contexts */\n    hctx = HMAC_CTX_new();\n    if (hctx == NULL)\n        return -2;\n    ctx = EVP_CIPHER_CTX_new();\n    if (ctx == NULL) {\n        ret = -2;\n        goto err;\n    }\n    if (tctx->tlsext_ticket_key_cb) {\n        unsigned char *nctick = (unsigned char *)etick;\n        int rv = tctx->tlsext_ticket_key_cb(s, nctick, nctick + 16,\n                                            ctx, hctx, 0);\n        if (rv < 0)\n            goto err;\n        if (rv == 0) {\n            ret = 2;\n            goto err;\n        }\n        if (rv == 2)\n            renew_ticket = 1;\n    } else {\n        /* Check key name matches */\n        if (memcmp(etick, tctx->tlsext_tick_key_name,\n                   sizeof(tctx->tlsext_tick_key_name)) != 0) {\n            ret = 2;\n            goto err;\n        }\n        if (HMAC_Init_ex(hctx, tctx->tlsext_tick_hmac_key,\n                         sizeof(tctx->tlsext_tick_hmac_key),\n                         EVP_sha256(), NULL) <= 0\n            || EVP_DecryptInit_ex(ctx, EVP_aes_256_cbc(), NULL,\n                                  tctx->tlsext_tick_aes_key,\n                                  etick + sizeof(tctx->tlsext_tick_key_name)) <=\n            0) {\n            goto err;\n        }\n    }\n    /*\n     * Attempt to process session ticket, first conduct sanity and integrity\n     * checks on ticket.\n     */\n    mlen = HMAC_size(hctx);\n    if (mlen < 0) {\n        goto err;\n    }\n    /* Sanity check ticket length: must exceed keyname + IV + HMAC */\n    if (eticklen <=\n        TLSEXT_KEYNAME_LENGTH + EVP_CIPHER_CTX_iv_length(ctx) + mlen) {\n        ret = 2;\n        goto err;\n    }\n    eticklen -= mlen;\n    /* Check HMAC of encrypted ticket */\n    if (HMAC_Update(hctx, etick, eticklen) <= 0\n        || HMAC_Final(hctx, tick_hmac, NULL) <= 0) {\n        goto err;\n    }\n    HMAC_CTX_free(hctx);\n    if (CRYPTO_memcmp(tick_hmac, etick + eticklen, mlen)) {\n        EVP_CIPHER_CTX_free(ctx);\n        return 2;\n    }\n    /* Attempt to decrypt session data */\n    /* Move p after IV to start of encrypted ticket, update length */\n    p = etick + TLSEXT_KEYNAME_LENGTH + EVP_CIPHER_CTX_iv_length(ctx);\n    eticklen -= TLSEXT_KEYNAME_LENGTH + EVP_CIPHER_CTX_iv_length(ctx);\n    sdec = OPENSSL_malloc(eticklen);\n    if (sdec == NULL || EVP_DecryptUpdate(ctx, sdec, &slen, p, eticklen) <= 0) {\n        EVP_CIPHER_CTX_free(ctx);\n        OPENSSL_free(sdec);\n        return -1;\n    }\n    if (EVP_DecryptFinal(ctx, sdec + slen, &mlen) <= 0) {\n        EVP_CIPHER_CTX_free(ctx);\n        OPENSSL_free(sdec);\n        return 2;\n    }\n    slen += mlen;\n    EVP_CIPHER_CTX_free(ctx);\n    ctx = NULL;\n    p = sdec;\n\n    sess = d2i_SSL_SESSION(NULL, &p, slen);\n    OPENSSL_free(sdec);\n    if (sess) {\n        /*\n         * The session ID, if non-empty, is used by some clients to detect\n         * that the ticket has been accepted. So we copy it to the session\n         * structure. If it is empty set length to zero as required by\n         * standard.\n         */\n        if (sesslen)\n            memcpy(sess->session_id, sess_id, sesslen);\n        sess->session_id_length = sesslen;\n        *psess = sess;\n        if (renew_ticket)\n            return 4;\n        else\n            return 3;\n    }\n    ERR_clear_error();\n    /*\n     * For session parse failure, indicate that we need to send a new ticket.\n     */\n    return 2;\n err:\n    EVP_CIPHER_CTX_free(ctx);\n    HMAC_CTX_free(hctx);\n    return ret;\n}",
        "target": 0
    },
    {
        "func": "int ssl3_get_cert_status(SSL *s)\n{\n    int ok, al;\n    unsigned long resplen, n;\n    const unsigned char *p;\n\n    n = s->method->ssl_get_message(s,\n                                   SSL3_ST_CR_CERT_STATUS_A,\n                                   SSL3_ST_CR_CERT_STATUS_B,\n                                   SSL3_MT_CERTIFICATE_STATUS, 16384, &ok);\n\n    if (!ok)\n        return ((int)n);\n    if (n < 4) {\n        /* need at least status type + length */\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_SSL3_GET_CERT_STATUS, SSL_R_LENGTH_MISMATCH);\n        goto f_err;\n    }\n    p = (unsigned char *)s->init_msg;\n    if (*p++ != TLSEXT_STATUSTYPE_ocsp) {\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_SSL3_GET_CERT_STATUS, SSL_R_UNSUPPORTED_STATUS_TYPE);\n        goto f_err;\n    }\n    n2l3(p, resplen);\n    if (resplen + 4 != n) {\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_SSL3_GET_CERT_STATUS, SSL_R_LENGTH_MISMATCH);\n        goto f_err;\n    }\n    OPENSSL_free(s->tlsext_ocsp_resp);\n    s->tlsext_ocsp_resp = BUF_memdup(p, resplen);\n    if (!s->tlsext_ocsp_resp) {\n        al = SSL_AD_INTERNAL_ERROR;\n        SSLerr(SSL_F_SSL3_GET_CERT_STATUS, ERR_R_MALLOC_FAILURE);\n        goto f_err;\n    }\n    s->tlsext_ocsp_resplen = resplen;\n    if (s->ctx->tlsext_status_cb) {\n        int ret;\n        ret = s->ctx->tlsext_status_cb(s, s->ctx->tlsext_status_arg);\n        if (ret == 0) {\n            al = SSL_AD_BAD_CERTIFICATE_STATUS_RESPONSE;\n            SSLerr(SSL_F_SSL3_GET_CERT_STATUS, SSL_R_INVALID_STATUS_RESPONSE);\n            goto f_err;\n        }\n        if (ret < 0) {\n            al = SSL_AD_INTERNAL_ERROR;\n            SSLerr(SSL_F_SSL3_GET_CERT_STATUS, ERR_R_MALLOC_FAILURE);\n            goto f_err;\n        }\n    }\n    return 1;\n f_err:\n    ssl3_send_alert(s, SSL3_AL_FATAL, al);\n    s->state = SSL_ST_ERR;\n    return (-1);\n}",
        "target": 0
    },
    {
        "func": "static int ssl_set_version(SSL *s)\n{\n    unsigned long mask, options = s->options;\n\n    if (s->method->version == TLS_ANY_VERSION) {\n        /*\n         * SSL_OP_NO_X disables all protocols above X *if* there are\n         * some protocols below X enabled. This is required in order\n         * to maintain \"version capability\" vector contiguous. So\n         * that if application wants to disable TLS1.0 in favour of\n         * TLS1>=1, it would be insufficient to pass SSL_NO_TLSv1, the\n         * answer is SSL_OP_NO_TLSv1|SSL_OP_NO_SSLv3.\n         */\n        mask = SSL_OP_NO_TLSv1_1 | SSL_OP_NO_TLSv1\n#if !defined(OPENSSL_NO_SSL3)\n            | SSL_OP_NO_SSLv3\n#endif\n            ;\n#if !defined(OPENSSL_NO_TLS1_2_CLIENT)\n        if (options & SSL_OP_NO_TLSv1_2) {\n            if ((options & mask) != mask) {\n                s->version = TLS1_1_VERSION;\n            } else {\n                SSLerr(SSL_F_SSL_SET_VERSION, SSL_R_NO_PROTOCOLS_AVAILABLE);\n                return 0;\n            }\n        } else {\n            s->version = TLS1_2_VERSION;\n        }\n#else\n        if ((options & mask) == mask) {\n            SSLerr(SSL_F_SSL_SET_VERSION, SSL_R_NO_PROTOCOLS_AVAILABLE);\n            return 0;\n        }\n        s->version = TLS1_1_VERSION;\n#endif\n\n        mask &= ~SSL_OP_NO_TLSv1_1;\n        if ((options & SSL_OP_NO_TLSv1_1) && (options & mask) != mask)\n            s->version = TLS1_VERSION;\n        mask &= ~SSL_OP_NO_TLSv1;\n#if !defined(OPENSSL_NO_SSL3)\n        if ((options & SSL_OP_NO_TLSv1) && (options & mask) != mask)\n            s->version = SSL3_VERSION;\n#endif\n\n        if (s->version != TLS1_2_VERSION && tls1_suiteb(s)) {\n            SSLerr(SSL_F_SSL_SET_VERSION,\n                   SSL_R_ONLY_TLS_1_2_ALLOWED_IN_SUITEB_MODE);\n            return 0;\n        }\n\n        if (s->version == SSL3_VERSION && FIPS_mode()) {\n            SSLerr(SSL_F_SSL_SET_VERSION, SSL_R_ONLY_TLS_ALLOWED_IN_FIPS_MODE);\n            return 0;\n        }\n\n    } else if (s->method->version == DTLS_ANY_VERSION) {\n        /* Determine which DTLS version to use */\n        /* If DTLS 1.2 disabled correct the version number */\n        if (options & SSL_OP_NO_DTLSv1_2) {\n            if (tls1_suiteb(s)) {\n                SSLerr(SSL_F_SSL_SET_VERSION,\n                       SSL_R_ONLY_DTLS_1_2_ALLOWED_IN_SUITEB_MODE);\n                return 0;\n            }\n            /*\n             * Disabling all versions is silly: return an error.\n             */\n            if (options & SSL_OP_NO_DTLSv1) {\n                SSLerr(SSL_F_SSL_SET_VERSION, SSL_R_WRONG_SSL_VERSION);\n                return 0;\n            }\n            /*\n             * Update method so we don't use any DTLS 1.2 features.\n             */\n            s->method = DTLSv1_client_method();\n            s->version = DTLS1_VERSION;\n        } else {\n            /*\n             * We only support one version: update method\n             */\n            if (options & SSL_OP_NO_DTLSv1)\n                s->method = DTLSv1_2_client_method();\n            s->version = DTLS1_2_VERSION;\n        }\n    }\n\n    s->client_version = s->version;\n\n    return 1;\n}",
        "target": 0
    },
    {
        "func": "int ssl3_get_server_hello(SSL *s)\n{\n    STACK_OF(SSL_CIPHER) *sk;\n    const SSL_CIPHER *c;\n    unsigned char *p, *d;\n    int i, al = SSL_AD_INTERNAL_ERROR, ok;\n    unsigned int j;\n    long n;\n#ifndef OPENSSL_NO_COMP\n    SSL_COMP *comp;\n#endif\n    /*\n     * Hello verify request and/or server hello version may not match so set\n     * first packet if we're negotiating version.\n     */\n    s->first_packet = 1;\n\n    n = s->method->ssl_get_message(s,\n                                   SSL3_ST_CR_SRVR_HELLO_A,\n                                   SSL3_ST_CR_SRVR_HELLO_B, -1, 20000, &ok);\n\n    if (!ok)\n        return ((int)n);\n\n    s->first_packet = 0;\n    if (SSL_IS_DTLS(s)) {\n        if (s->s3->tmp.message_type == DTLS1_MT_HELLO_VERIFY_REQUEST) {\n            if (s->d1->send_cookie == 0) {\n                s->s3->tmp.reuse_message = 1;\n                return 1;\n            } else {            /* already sent a cookie */\n\n                al = SSL_AD_UNEXPECTED_MESSAGE;\n                SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_BAD_MESSAGE_TYPE);\n                goto f_err;\n            }\n        }\n    }\n\n    if (s->s3->tmp.message_type != SSL3_MT_SERVER_HELLO) {\n        al = SSL_AD_UNEXPECTED_MESSAGE;\n        SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_BAD_MESSAGE_TYPE);\n        goto f_err;\n    }\n\n    d = p = (unsigned char *)s->init_msg;\n\n    if (s->method->version == TLS_ANY_VERSION) {\n        int sversion = (p[0] << 8) | p[1];\n\n#if TLS_MAX_VERSION != TLS1_2_VERSION\n#error Code needs updating for new TLS version\n#endif\n#ifndef OPENSSL_NO_SSL3\n        if ((sversion == SSL3_VERSION) && !(s->options & SSL_OP_NO_SSLv3)) {\n            if (FIPS_mode()) {\n                SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,\n                       SSL_R_ONLY_TLS_ALLOWED_IN_FIPS_MODE);\n                al = SSL_AD_PROTOCOL_VERSION;\n                goto f_err;\n            }\n            s->method = SSLv3_client_method();\n        } else\n#endif\n        if ((sversion == TLS1_VERSION) && !(s->options & SSL_OP_NO_TLSv1)) {\n            s->method = TLSv1_client_method();\n        } else if ((sversion == TLS1_1_VERSION) &&\n                   !(s->options & SSL_OP_NO_TLSv1_1)) {\n            s->method = TLSv1_1_client_method();\n        } else if ((sversion == TLS1_2_VERSION) &&\n                   !(s->options & SSL_OP_NO_TLSv1_2)) {\n            s->method = TLSv1_2_client_method();\n        } else {\n            SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_UNSUPPORTED_PROTOCOL);\n            al = SSL_AD_PROTOCOL_VERSION;\n            goto f_err;\n        }\n        s->session->ssl_version = s->version = s->method->version;\n\n        if (!ssl_security(s, SSL_SECOP_VERSION, 0, s->version, NULL)) {\n            SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_VERSION_TOO_LOW);\n            al = SSL_AD_PROTOCOL_VERSION;\n            goto f_err;\n        }\n    } else if (s->method->version == DTLS_ANY_VERSION) {\n        /* Work out correct protocol version to use */\n        int hversion = (p[0] << 8) | p[1];\n        int options = s->options;\n        if (hversion == DTLS1_2_VERSION && !(options & SSL_OP_NO_DTLSv1_2))\n            s->method = DTLSv1_2_client_method();\n        else if (tls1_suiteb(s)) {\n            SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,\n                   SSL_R_ONLY_DTLS_1_2_ALLOWED_IN_SUITEB_MODE);\n            s->version = hversion;\n            al = SSL_AD_PROTOCOL_VERSION;\n            goto f_err;\n        } else if (hversion == DTLS1_VERSION && !(options & SSL_OP_NO_DTLSv1))\n            s->method = DTLSv1_client_method();\n        else {\n            SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_WRONG_SSL_VERSION);\n            s->version = hversion;\n            al = SSL_AD_PROTOCOL_VERSION;\n            goto f_err;\n        }\n        s->version = s->method->version;\n    } else if ((p[0] != (s->version >> 8)) || (p[1] != (s->version & 0xff))) {\n        SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_WRONG_SSL_VERSION);\n        s->version = (s->version & 0xff00) | p[1];\n        al = SSL_AD_PROTOCOL_VERSION;\n        goto f_err;\n    }\n    p += 2;\n\n    /* load the server hello data */\n    /* load the server random */\n    memcpy(s->s3->server_random, p, SSL3_RANDOM_SIZE);\n    p += SSL3_RANDOM_SIZE;\n\n    s->hit = 0;\n\n    /* get the session-id */\n    j = *(p++);\n\n    if ((j > sizeof s->session->session_id) || (j > SSL3_SESSION_ID_SIZE)) {\n        al = SSL_AD_ILLEGAL_PARAMETER;\n        SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_SSL3_SESSION_ID_TOO_LONG);\n        goto f_err;\n    }\n\n    /*\n     * Check if we can resume the session based on external pre-shared secret.\n     * EAP-FAST (RFC 4851) supports two types of session resumption.\n     * Resumption based on server-side state works with session IDs.\n     * Resumption based on pre-shared Protected Access Credentials (PACs)\n     * works by overriding the SessionTicket extension at the application\n     * layer, and does not send a session ID. (We do not know whether EAP-FAST\n     * servers would honour the session ID.) Therefore, the session ID alone\n     * is not a reliable indicator of session resumption, so we first check if\n     * we can resume, and later peek at the next handshake message to see if the\n     * server wants to resume.\n     */\n    if (s->version >= TLS1_VERSION && s->tls_session_secret_cb &&\n        s->session->tlsext_tick) {\n        SSL_CIPHER *pref_cipher = NULL;\n        s->session->master_key_length = sizeof(s->session->master_key);\n        if (s->tls_session_secret_cb(s, s->session->master_key,\n                                     &s->session->master_key_length,\n                                     NULL, &pref_cipher,\n                                     s->tls_session_secret_cb_arg)) {\n            s->session->cipher = pref_cipher ?\n                pref_cipher : ssl_get_cipher_by_char(s, p + j);\n        } else {\n            SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, ERR_R_INTERNAL_ERROR);\n            al = SSL_AD_INTERNAL_ERROR;\n            goto f_err;\n        }\n    }\n\n    if (j != 0 && j == s->session->session_id_length\n        && memcmp(p, s->session->session_id, j) == 0) {\n        if (s->sid_ctx_length != s->session->sid_ctx_length\n            || memcmp(s->session->sid_ctx, s->sid_ctx, s->sid_ctx_length)) {\n            /* actually a client application bug */\n            al = SSL_AD_ILLEGAL_PARAMETER;\n            SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,\n                   SSL_R_ATTEMPT_TO_REUSE_SESSION_IN_DIFFERENT_CONTEXT);\n            goto f_err;\n        }\n        s->hit = 1;\n    } else {\n        /*\n         * If we were trying for session-id reuse but the server\n         * didn't echo the ID, make a new SSL_SESSION.\n         * In the case of EAP-FAST and PAC, we do not send a session ID,\n         * so the PAC-based session secret is always preserved. It'll be\n         * overwritten if the server refuses resumption.\n         */\n        if (s->session->session_id_length > 0) {\n            if (!ssl_get_new_session(s, 0)) {\n                goto f_err;\n            }\n        }\n        s->session->session_id_length = j;\n        memcpy(s->session->session_id, p, j); /* j could be 0 */\n    }\n    p += j;\n    c = ssl_get_cipher_by_char(s, p);\n    if (c == NULL) {\n        /* unknown cipher */\n        al = SSL_AD_ILLEGAL_PARAMETER;\n        SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_UNKNOWN_CIPHER_RETURNED);\n        goto f_err;\n    }\n    /* Set version disabled mask now we know version */\n    if (!SSL_USE_TLS1_2_CIPHERS(s))\n        s->s3->tmp.mask_ssl = SSL_TLSV1_2;\n    else\n        s->s3->tmp.mask_ssl = 0;\n    /*\n     * If it is a disabled cipher we didn't send it in client hello, so\n     * return an error.\n     */\n    if (ssl_cipher_disabled(s, c, SSL_SECOP_CIPHER_CHECK)) {\n        al = SSL_AD_ILLEGAL_PARAMETER;\n        SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_WRONG_CIPHER_RETURNED);\n        goto f_err;\n    }\n    p += ssl_put_cipher_by_char(s, NULL, NULL);\n\n    sk = ssl_get_ciphers_by_id(s);\n    i = sk_SSL_CIPHER_find(sk, c);\n    if (i < 0) {\n        /* we did not say we would use this cipher */\n        al = SSL_AD_ILLEGAL_PARAMETER;\n        SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_WRONG_CIPHER_RETURNED);\n        goto f_err;\n    }\n\n    /*\n     * Depending on the session caching (internal/external), the cipher\n     * and/or cipher_id values may not be set. Make sure that cipher_id is\n     * set and use it for comparison.\n     */\n    if (s->session->cipher)\n        s->session->cipher_id = s->session->cipher->id;\n    if (s->hit && (s->session->cipher_id != c->id)) {\n        al = SSL_AD_ILLEGAL_PARAMETER;\n        SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,\n               SSL_R_OLD_SESSION_CIPHER_NOT_RETURNED);\n        goto f_err;\n    }\n    s->s3->tmp.new_cipher = c;\n    /*\n     * Don't digest cached records if no sigalgs: we may need them for client\n     * authentication.\n     */\n    if (!SSL_USE_SIGALGS(s) && !ssl3_digest_cached_records(s))\n        goto f_err;\n    /* lets get the compression algorithm */\n    /* COMPRESSION */\n#ifdef OPENSSL_NO_COMP\n    if (*(p++) != 0) {\n        al = SSL_AD_ILLEGAL_PARAMETER;\n        SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,\n               SSL_R_UNSUPPORTED_COMPRESSION_ALGORITHM);\n        goto f_err;\n    }\n    /*\n     * If compression is disabled we'd better not try to resume a session\n     * using compression.\n     */\n    if (s->session->compress_meth != 0) {\n        SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_INCONSISTENT_COMPRESSION);\n        goto f_err;\n    }\n#else\n    j = *(p++);\n    if (s->hit && j != s->session->compress_meth) {\n        al = SSL_AD_ILLEGAL_PARAMETER;\n        SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,\n               SSL_R_OLD_SESSION_COMPRESSION_ALGORITHM_NOT_RETURNED);\n        goto f_err;\n    }\n    if (j == 0)\n        comp = NULL;\n    else if (!ssl_allow_compression(s)) {\n        al = SSL_AD_ILLEGAL_PARAMETER;\n        SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_COMPRESSION_DISABLED);\n        goto f_err;\n    } else\n        comp = ssl3_comp_find(s->ctx->comp_methods, j);\n\n    if ((j != 0) && (comp == NULL)) {\n        al = SSL_AD_ILLEGAL_PARAMETER;\n        SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,\n               SSL_R_UNSUPPORTED_COMPRESSION_ALGORITHM);\n        goto f_err;\n    } else {\n        s->s3->tmp.new_compression = comp;\n    }\n#endif\n\n    /* TLS extensions */\n    if (!ssl_parse_serverhello_tlsext(s, &p, d, n)) {\n        SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_PARSE_TLSEXT);\n        goto err;\n    }\n\n    if (p != (d + n)) {\n        /* wrong packet length */\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_BAD_PACKET_LENGTH);\n        goto f_err;\n    }\n\n    return (1);\n f_err:\n    ssl3_send_alert(s, SSL3_AL_FATAL, al);\n err:\n    s->state = SSL_ST_ERR;\n    return (-1);\n}",
        "target": 0
    },
    {
        "func": "int ssl3_send_client_certificate(SSL *s)\n{\n    X509 *x509 = NULL;\n    EVP_PKEY *pkey = NULL;\n    int i;\n\n    if (s->state == SSL3_ST_CW_CERT_A) {\n        /* Let cert callback update client certificates if required */\n        if (s->cert->cert_cb) {\n            i = s->cert->cert_cb(s, s->cert->cert_cb_arg);\n            if (i < 0) {\n                s->rwstate = SSL_X509_LOOKUP;\n                return -1;\n            }\n            if (i == 0) {\n                ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);\n                s->state = SSL_ST_ERR;\n                return 0;\n            }\n            s->rwstate = SSL_NOTHING;\n        }\n        if (ssl3_check_client_certificate(s))\n            s->state = SSL3_ST_CW_CERT_C;\n        else\n            s->state = SSL3_ST_CW_CERT_B;\n    }\n\n    /* We need to get a client cert */\n    if (s->state == SSL3_ST_CW_CERT_B) {\n        /*\n         * If we get an error, we need to ssl->rwstate=SSL_X509_LOOKUP;\n         * return(-1); We then get retied later\n         */\n        i = 0;\n        i = ssl_do_client_cert_cb(s, &x509, &pkey);\n        if (i < 0) {\n            s->rwstate = SSL_X509_LOOKUP;\n            return (-1);\n        }\n        s->rwstate = SSL_NOTHING;\n        if ((i == 1) && (pkey != NULL) && (x509 != NULL)) {\n            s->state = SSL3_ST_CW_CERT_B;\n            if (!SSL_use_certificate(s, x509) || !SSL_use_PrivateKey(s, pkey))\n                i = 0;\n        } else if (i == 1) {\n            i = 0;\n            SSLerr(SSL_F_SSL3_SEND_CLIENT_CERTIFICATE,\n                   SSL_R_BAD_DATA_RETURNED_BY_CALLBACK);\n        }\n\n        X509_free(x509);\n        EVP_PKEY_free(pkey);\n        if (i && !ssl3_check_client_certificate(s))\n            i = 0;\n        if (i == 0) {\n            if (s->version == SSL3_VERSION) {\n                s->s3->tmp.cert_req = 0;\n                ssl3_send_alert(s, SSL3_AL_WARNING, SSL_AD_NO_CERTIFICATE);\n                return (1);\n            } else {\n                s->s3->tmp.cert_req = 2;\n                if (s->s3->handshake_buffer && !ssl3_digest_cached_records(s)) {\n                    ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);\n                    s->state = SSL_ST_ERR;\n                    return 0;\n                }\n            }\n        }\n\n        /* Ok, we have a cert */\n        s->state = SSL3_ST_CW_CERT_C;\n    }\n\n    if (s->state == SSL3_ST_CW_CERT_C) {\n        s->state = SSL3_ST_CW_CERT_D;\n        if (!ssl3_output_cert_chain(s,\n                                    (s->s3->tmp.cert_req ==\n                                     2) ? NULL : s->cert->key)) {\n            SSLerr(SSL_F_SSL3_SEND_CLIENT_CERTIFICATE, ERR_R_INTERNAL_ERROR);\n            ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);\n            s->state = SSL_ST_ERR;\n            return 0;\n        }\n    }\n    /* SSL3_ST_CW_CERT_D */\n    return ssl_do_write(s);\n}",
        "target": 0
    },
    {
        "func": "int ssl_cipher_list_to_bytes(SSL *s, STACK_OF(SSL_CIPHER) *sk,\n                             unsigned char *p,\n                             int (*put_cb) (const SSL_CIPHER *,\n                                            unsigned char *))\n{\n    int i, j = 0;\n    SSL_CIPHER *c;\n    unsigned char *q;\n    int empty_reneg_info_scsv = !s->renegotiate;\n    /* Set disabled masks for this session */\n    ssl_set_client_disabled(s);\n\n    if (sk == NULL)\n        return (0);\n    q = p;\n    if (put_cb == NULL)\n        put_cb = s->method->put_cipher_by_char;\n\n    for (i = 0; i < sk_SSL_CIPHER_num(sk); i++) {\n        c = sk_SSL_CIPHER_value(sk, i);\n        /* Skip disabled ciphers */\n        if (ssl_cipher_disabled(s, c, SSL_SECOP_CIPHER_SUPPORTED))\n            continue;\n#ifdef OPENSSL_SSL_DEBUG_BROKEN_PROTOCOL\n        if (c->id == SSL3_CK_SCSV) {\n            if (!empty_reneg_info_scsv)\n                continue;\n            else\n                empty_reneg_info_scsv = 0;\n        }\n#endif\n        j = put_cb(c, p);\n        p += j;\n    }\n    /*\n     * If p == q, no ciphers; caller indicates an error. Otherwise, add\n     * applicable SCSVs.\n     */\n    if (p != q) {\n        if (empty_reneg_info_scsv) {\n            static SSL_CIPHER scsv = {\n                0, NULL, SSL3_CK_SCSV, 0, 0, 0, 0, 0, 0, 0, 0, 0\n            };\n            j = put_cb(&scsv, p);\n            p += j;\n#ifdef OPENSSL_RI_DEBUG\n            fprintf(stderr,\n                    \"TLS_EMPTY_RENEGOTIATION_INFO_SCSV sent by client\\n\");\n#endif\n        }\n        if (s->mode & SSL_MODE_SEND_FALLBACK_SCSV) {\n            static SSL_CIPHER scsv = {\n                0, NULL, SSL3_CK_FALLBACK_SCSV, 0, 0, 0, 0, 0, 0, 0, 0, 0\n            };\n            j = put_cb(&scsv, p);\n            p += j;\n        }\n    }\n\n    return (p - q);\n}",
        "target": 0
    },
    {
        "func": "int ssl3_connect(SSL *s)\n{\n    BUF_MEM *buf = NULL;\n    unsigned long Time = (unsigned long)time(NULL);\n    void (*cb) (const SSL *ssl, int type, int val) = NULL;\n    int ret = -1;\n    int new_state, state, skip = 0;\n\n    RAND_add(&Time, sizeof(Time), 0);\n    ERR_clear_error();\n    clear_sys_error();\n\n    if (s->info_callback != NULL)\n        cb = s->info_callback;\n    else if (s->ctx->info_callback != NULL)\n        cb = s->ctx->info_callback;\n\n    s->in_handshake++;\n    if (!SSL_in_init(s) || SSL_in_before(s)) {\n        if (!SSL_clear(s))\n            return -1;\n    }\n\n#ifndef OPENSSL_NO_HEARTBEATS\n    /*\n     * If we're awaiting a HeartbeatResponse, pretend we already got and\n     * don't await it anymore, because Heartbeats don't make sense during\n     * handshakes anyway.\n     */\n    if (s->tlsext_hb_pending) {\n        s->tlsext_hb_pending = 0;\n        s->tlsext_hb_seq++;\n    }\n#endif\n\n    for (;;) {\n        state = s->state;\n\n        switch (s->state) {\n        case SSL_ST_RENEGOTIATE:\n            s->renegotiate = 1;\n            s->state = SSL_ST_CONNECT;\n            s->ctx->stats.sess_connect_renegotiate++;\n            /* break */\n        case SSL_ST_BEFORE:\n        case SSL_ST_CONNECT:\n        case SSL_ST_BEFORE | SSL_ST_CONNECT:\n        case SSL_ST_OK | SSL_ST_CONNECT:\n\n            s->server = 0;\n            if (cb != NULL)\n                cb(s, SSL_CB_HANDSHAKE_START, 1);\n\n            if ((s->version >> 8) != SSL3_VERSION_MAJOR\n                    && s->version != TLS_ANY_VERSION) {\n                SSLerr(SSL_F_SSL3_CONNECT, ERR_R_INTERNAL_ERROR);\n                s->state = SSL_ST_ERR;\n                ret = -1;\n                goto end;\n            }\n\n            if (s->version != TLS_ANY_VERSION &&\n                    !ssl_security(s, SSL_SECOP_VERSION, 0, s->version, NULL)) {\n                SSLerr(SSL_F_SSL3_CONNECT, SSL_R_VERSION_TOO_LOW);\n                return -1;\n            }\n\n            /* s->version=SSL3_VERSION; */\n            s->type = SSL_ST_CONNECT;\n\n            if (s->init_buf == NULL) {\n                if ((buf = BUF_MEM_new()) == NULL) {\n                    ret = -1;\n                    s->state = SSL_ST_ERR;\n                    goto end;\n                }\n                if (!BUF_MEM_grow(buf, SSL3_RT_MAX_PLAIN_LENGTH)) {\n                    ret = -1;\n                    s->state = SSL_ST_ERR;\n                    goto end;\n                }\n                s->init_buf = buf;\n                buf = NULL;\n            }\n\n            if (!ssl3_setup_buffers(s)) {\n                ret = -1;\n                goto end;\n            }\n\n            /* setup buffing BIO */\n            if (!ssl_init_wbio_buffer(s, 0)) {\n                ret = -1;\n                s->state = SSL_ST_ERR;\n                goto end;\n            }\n\n            /* don't push the buffering BIO quite yet */\n\n            ssl3_init_finished_mac(s);\n\n            s->state = SSL3_ST_CW_CLNT_HELLO_A;\n            s->ctx->stats.sess_connect++;\n            s->init_num = 0;\n            s->s3->flags &= ~SSL3_FLAGS_CCS_OK;\n            /*\n             * Should have been reset by ssl3_get_finished, too.\n             */\n            s->s3->change_cipher_spec = 0;\n            break;\n\n        case SSL3_ST_CW_CLNT_HELLO_A:\n        case SSL3_ST_CW_CLNT_HELLO_B:\n\n            s->shutdown = 0;\n            ret = ssl3_client_hello(s);\n            if (ret <= 0)\n                goto end;\n            s->state = SSL3_ST_CR_SRVR_HELLO_A;\n            s->init_num = 0;\n\n            /* turn on buffering for the next lot of output */\n            if (s->bbio != s->wbio)\n                s->wbio = BIO_push(s->bbio, s->wbio);\n\n            break;\n\n        case SSL3_ST_CR_SRVR_HELLO_A:\n        case SSL3_ST_CR_SRVR_HELLO_B:\n            ret = ssl3_get_server_hello(s);\n            if (ret <= 0)\n                goto end;\n\n            if (s->hit) {\n                s->state = SSL3_ST_CR_FINISHED_A;\n                if (s->tlsext_ticket_expected) {\n                    /* receive renewed session ticket */\n                    s->state = SSL3_ST_CR_SESSION_TICKET_A;\n                }\n            } else {\n                s->state = SSL3_ST_CR_CERT_A;\n            }\n            s->init_num = 0;\n            break;\n        case SSL3_ST_CR_CERT_A:\n        case SSL3_ST_CR_CERT_B:\n            /* Noop (ret = 0) for everything but EAP-FAST. */\n            ret = ssl3_check_finished(s);\n            if (ret < 0)\n                goto end;\n            if (ret == 1) {\n                s->hit = 1;\n                s->state = SSL3_ST_CR_FINISHED_A;\n                s->init_num = 0;\n                break;\n            }\n\n            /* Check if it is anon DH/ECDH, SRP auth */\n            /* or PSK */\n            if (!\n                (s->s3->tmp.\n                 new_cipher->algorithm_auth & (SSL_aNULL | SSL_aSRP))\n&& !(s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK)) {\n                ret = ssl3_get_server_certificate(s);\n                if (ret <= 0)\n                    goto end;\n\n                if (s->tlsext_status_expected)\n                    s->state = SSL3_ST_CR_CERT_STATUS_A;\n                else\n                    s->state = SSL3_ST_CR_KEY_EXCH_A;\n            } else {\n                skip = 1;\n                s->state = SSL3_ST_CR_KEY_EXCH_A;\n            }\n\n            s->init_num = 0;\n            break;\n\n        case SSL3_ST_CR_KEY_EXCH_A:\n        case SSL3_ST_CR_KEY_EXCH_B:\n            ret = ssl3_get_key_exchange(s);\n            if (ret <= 0)\n                goto end;\n            s->state = SSL3_ST_CR_CERT_REQ_A;\n            s->init_num = 0;\n\n            /*\n             * at this point we check that we have the required stuff from\n             * the server\n             */\n            if (!ssl3_check_cert_and_algorithm(s)) {\n                ret = -1;\n                s->state = SSL_ST_ERR;\n                goto end;\n            }\n            break;\n\n        case SSL3_ST_CR_CERT_REQ_A:\n        case SSL3_ST_CR_CERT_REQ_B:\n            ret = ssl3_get_certificate_request(s);\n            if (ret <= 0)\n                goto end;\n            s->state = SSL3_ST_CR_SRVR_DONE_A;\n            s->init_num = 0;\n            break;\n\n        case SSL3_ST_CR_SRVR_DONE_A:\n        case SSL3_ST_CR_SRVR_DONE_B:\n            ret = ssl3_get_server_done(s);\n            if (ret <= 0)\n                goto end;\n#ifndef OPENSSL_NO_SRP\n            if (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kSRP) {\n                if ((ret = SRP_Calc_A_param(s)) <= 0) {\n                    SSLerr(SSL_F_SSL3_CONNECT, SSL_R_SRP_A_CALC);\n                    ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);\n                    s->state = SSL_ST_ERR;\n                    goto end;\n                }\n            }\n#endif\n            if (s->s3->tmp.cert_req)\n                s->state = SSL3_ST_CW_CERT_A;\n            else\n                s->state = SSL3_ST_CW_KEY_EXCH_A;\n            s->init_num = 0;\n\n            break;\n\n        case SSL3_ST_CW_CERT_A:\n        case SSL3_ST_CW_CERT_B:\n        case SSL3_ST_CW_CERT_C:\n        case SSL3_ST_CW_CERT_D:\n            ret = ssl3_send_client_certificate(s);\n            if (ret <= 0)\n                goto end;\n            s->state = SSL3_ST_CW_KEY_EXCH_A;\n            s->init_num = 0;\n            break;\n\n        case SSL3_ST_CW_KEY_EXCH_A:\n        case SSL3_ST_CW_KEY_EXCH_B:\n            ret = ssl3_send_client_key_exchange(s);\n            if (ret <= 0)\n                goto end;\n            /*\n             * EAY EAY EAY need to check for DH fix cert sent back\n             */\n            /*\n             * For TLS, cert_req is set to 2, so a cert chain of nothing is\n             * sent, but no verify packet is sent\n             */\n            /*\n             * XXX: For now, we do not support client authentication in ECDH\n             * cipher suites with ECDH (rather than ECDSA) certificates. We\n             * need to skip the certificate verify message when client's\n             * ECDH public key is sent inside the client certificate.\n             */\n            if (s->s3->tmp.cert_req == 1) {\n                s->state = SSL3_ST_CW_CERT_VRFY_A;\n            } else {\n                s->state = SSL3_ST_CW_CHANGE_A;\n            }\n            if (s->s3->flags & TLS1_FLAGS_SKIP_CERT_VERIFY) {\n                s->state = SSL3_ST_CW_CHANGE_A;\n            }\n\n            s->init_num = 0;\n            break;\n\n        case SSL3_ST_CW_CERT_VRFY_A:\n        case SSL3_ST_CW_CERT_VRFY_B:\n            ret = ssl3_send_client_verify(s);\n            if (ret <= 0)\n                goto end;\n            s->state = SSL3_ST_CW_CHANGE_A;\n            s->init_num = 0;\n            break;\n\n        case SSL3_ST_CW_CHANGE_A:\n        case SSL3_ST_CW_CHANGE_B:\n            ret = ssl3_send_change_cipher_spec(s,\n                                               SSL3_ST_CW_CHANGE_A,\n                                               SSL3_ST_CW_CHANGE_B);\n            if (ret <= 0)\n                goto end;\n\n#if defined(OPENSSL_NO_NEXTPROTONEG)\n            s->state = SSL3_ST_CW_FINISHED_A;\n#else\n            if (s->s3->next_proto_neg_seen)\n                s->state = SSL3_ST_CW_NEXT_PROTO_A;\n            else\n                s->state = SSL3_ST_CW_FINISHED_A;\n#endif\n            s->init_num = 0;\n\n            s->session->cipher = s->s3->tmp.new_cipher;\n#ifdef OPENSSL_NO_COMP\n            s->session->compress_meth = 0;\n#else\n            if (s->s3->tmp.new_compression == NULL)\n                s->session->compress_meth = 0;\n            else\n                s->session->compress_meth = s->s3->tmp.new_compression->id;\n#endif\n            if (!s->method->ssl3_enc->setup_key_block(s)) {\n                ret = -1;\n                s->state = SSL_ST_ERR;\n                goto end;\n            }\n\n            if (!s->method->ssl3_enc->change_cipher_state(s,\n                                                          SSL3_CHANGE_CIPHER_CLIENT_WRITE))\n            {\n                ret = -1;\n                s->state = SSL_ST_ERR;\n                goto end;\n            }\n\n            break;\n\n#if !defined(OPENSSL_NO_NEXTPROTONEG)\n        case SSL3_ST_CW_NEXT_PROTO_A:\n        case SSL3_ST_CW_NEXT_PROTO_B:\n            ret = ssl3_send_next_proto(s);\n            if (ret <= 0)\n                goto end;\n            s->state = SSL3_ST_CW_FINISHED_A;\n            break;\n#endif\n\n        case SSL3_ST_CW_FINISHED_A:\n        case SSL3_ST_CW_FINISHED_B:\n            ret = ssl3_send_finished(s,\n                                     SSL3_ST_CW_FINISHED_A,\n                                     SSL3_ST_CW_FINISHED_B,\n                                     s->method->\n                                     ssl3_enc->client_finished_label,\n                                     s->method->\n                                     ssl3_enc->client_finished_label_len);\n            if (ret <= 0)\n                goto end;\n            s->state = SSL3_ST_CW_FLUSH;\n\n            /* clear flags */\n            s->s3->flags &= ~SSL3_FLAGS_POP_BUFFER;\n            if (s->hit) {\n                s->s3->tmp.next_state = SSL_ST_OK;\n                if (s->s3->flags & SSL3_FLAGS_DELAY_CLIENT_FINISHED) {\n                    s->state = SSL_ST_OK;\n                    s->s3->flags |= SSL3_FLAGS_POP_BUFFER;\n                    s->s3->delay_buf_pop_ret = 0;\n                }\n            } else {\n                /*\n                 * Allow NewSessionTicket if ticket expected\n                 */\n                if (s->tlsext_ticket_expected)\n                    s->s3->tmp.next_state = SSL3_ST_CR_SESSION_TICKET_A;\n                else\n                    s->s3->tmp.next_state = SSL3_ST_CR_FINISHED_A;\n            }\n            s->init_num = 0;\n            break;\n\n        case SSL3_ST_CR_SESSION_TICKET_A:\n        case SSL3_ST_CR_SESSION_TICKET_B:\n            ret = ssl3_get_new_session_ticket(s);\n            if (ret <= 0)\n                goto end;\n            s->state = SSL3_ST_CR_FINISHED_A;\n            s->init_num = 0;\n            break;\n\n        case SSL3_ST_CR_CERT_STATUS_A:\n        case SSL3_ST_CR_CERT_STATUS_B:\n            ret = ssl3_get_cert_status(s);\n            if (ret <= 0)\n                goto end;\n            s->state = SSL3_ST_CR_KEY_EXCH_A;\n            s->init_num = 0;\n            break;\n\n        case SSL3_ST_CR_FINISHED_A:\n        case SSL3_ST_CR_FINISHED_B:\n            if (!s->s3->change_cipher_spec)\n                s->s3->flags |= SSL3_FLAGS_CCS_OK;\n            ret = ssl3_get_finished(s, SSL3_ST_CR_FINISHED_A,\n                                    SSL3_ST_CR_FINISHED_B);\n            if (ret <= 0)\n                goto end;\n\n            if (s->hit)\n                s->state = SSL3_ST_CW_CHANGE_A;\n            else\n                s->state = SSL_ST_OK;\n            s->init_num = 0;\n            break;\n\n        case SSL3_ST_CW_FLUSH:\n            s->rwstate = SSL_WRITING;\n            if (BIO_flush(s->wbio) <= 0) {\n                ret = -1;\n                goto end;\n            }\n            s->rwstate = SSL_NOTHING;\n            s->state = s->s3->tmp.next_state;\n            break;\n\n        case SSL_ST_OK:\n            /* clean a few things up */\n            ssl3_cleanup_key_block(s);\n            BUF_MEM_free(s->init_buf);\n            s->init_buf = NULL;\n\n            /*\n             * If we are not 'joining' the last two packets, remove the\n             * buffering now\n             */\n            if (!(s->s3->flags & SSL3_FLAGS_POP_BUFFER))\n                ssl_free_wbio_buffer(s);\n            /* else do it later in ssl3_write */\n\n            s->init_num = 0;\n            s->renegotiate = 0;\n            s->new_session = 0;\n\n            ssl_update_cache(s, SSL_SESS_CACHE_CLIENT);\n            if (s->hit)\n                s->ctx->stats.sess_hit++;\n\n            ret = 1;\n            /* s->server=0; */\n            s->handshake_func = ssl3_connect;\n            s->ctx->stats.sess_connect_good++;\n\n            if (cb != NULL)\n                cb(s, SSL_CB_HANDSHAKE_DONE, 1);\n\n            goto end;\n            /* break; */\n\n        case SSL_ST_ERR:\n        default:\n            SSLerr(SSL_F_SSL3_CONNECT, SSL_R_UNKNOWN_STATE);\n            ret = -1;\n            goto end;\n            /* break; */\n        }\n\n        /* did we do anything */\n        if (!s->s3->tmp.reuse_message && !skip) {\n            if (s->debug) {\n                if ((ret = BIO_flush(s->wbio)) <= 0)\n                    goto end;\n            }\n\n            if ((cb != NULL) && (s->state != state)) {\n                new_state = s->state;\n                s->state = state;\n                cb(s, SSL_CB_CONNECT_LOOP, 1);\n                s->state = new_state;\n            }\n        }\n        skip = 0;\n    }\n end:\n    s->in_handshake--;\n    BUF_MEM_free(buf);\n    if (cb != NULL)\n        cb(s, SSL_CB_CONNECT_EXIT, ret);\n    return (ret);\n}",
        "target": 0
    },
    {
        "func": "int ssl3_get_new_session_ticket(SSL *s)\n{\n    int ok, al, ret = 0, ticklen;\n    long n;\n    const unsigned char *p;\n    unsigned char *d;\n\n    n = s->method->ssl_get_message(s,\n                                   SSL3_ST_CR_SESSION_TICKET_A,\n                                   SSL3_ST_CR_SESSION_TICKET_B,\n                                   SSL3_MT_NEWSESSION_TICKET, 16384, &ok);\n\n    if (!ok)\n        return ((int)n);\n\n    if (n < 6) {\n        /* need at least ticket_lifetime_hint + ticket length */\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET, SSL_R_LENGTH_MISMATCH);\n        goto f_err;\n    }\n\n    p = d = (unsigned char *)s->init_msg;\n\n    if (s->session->session_id_length > 0) {\n        int i = s->session_ctx->session_cache_mode;\n        SSL_SESSION *new_sess;\n        /*\n         * We reused an existing session, so we need to replace it with a new\n         * one\n         */\n        if (i & SSL_SESS_CACHE_CLIENT) {\n            /*\n             * Remove the old session from the cache\n             */\n            if (i & SSL_SESS_CACHE_NO_INTERNAL_STORE) {\n                if (s->session_ctx->remove_session_cb != NULL)\n                    s->session_ctx->remove_session_cb(s->session_ctx,\n                                                      s->session);\n            } else {\n                /* We carry on if this fails */\n                SSL_CTX_remove_session(s->session_ctx, s->session);\n            }\n        }\n\n        if ((new_sess = ssl_session_dup(s->session, 0)) == 0) {\n            al = SSL_AD_INTERNAL_ERROR;\n            SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET, ERR_R_MALLOC_FAILURE);\n            goto f_err;\n        }\n\n        SSL_SESSION_free(s->session);\n        s->session = new_sess;\n    }\n\n    n2l(p, s->session->tlsext_tick_lifetime_hint);\n    n2s(p, ticklen);\n    /* ticket_lifetime_hint + ticket_length + ticket */\n    if (ticklen + 6 != n) {\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET, SSL_R_LENGTH_MISMATCH);\n        goto f_err;\n    }\n    OPENSSL_free(s->session->tlsext_tick);\n    s->session->tlsext_ticklen = 0;\n    s->session->tlsext_tick = OPENSSL_malloc(ticklen);\n    if (!s->session->tlsext_tick) {\n        SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n    memcpy(s->session->tlsext_tick, p, ticklen);\n    s->session->tlsext_ticklen = ticklen;\n    /*\n     * There are two ways to detect a resumed ticket session. One is to set\n     * an appropriate session ID and then the server must return a match in\n     * ServerHello. This allows the normal client session ID matching to work\n     * and we know much earlier that the ticket has been accepted. The\n     * other way is to set zero length session ID when the ticket is\n     * presented and rely on the handshake to determine session resumption.\n     * We choose the former approach because this fits in with assumptions\n     * elsewhere in OpenSSL. The session ID is set to the SHA256 (or SHA1 is\n     * SHA256 is disabled) hash of the ticket.\n     */\n    EVP_Digest(p, ticklen,\n               s->session->session_id, &s->session->session_id_length,\n               EVP_sha256(), NULL);\n    ret = 1;\n    return (ret);\n f_err:\n    ssl3_send_alert(s, SSL3_AL_FATAL, al);\n err:\n    s->state = SSL_ST_ERR;\n    return (-1);\n}",
        "target": 0
    },
    {
        "func": "int ssl3_check_cert_and_algorithm(SSL *s)\n{\n    int i, idx;\n    long alg_k, alg_a;\n    EVP_PKEY *pkey = NULL;\n    int pkey_bits;\n    SESS_CERT *sc;\n#ifndef OPENSSL_NO_RSA\n    RSA *rsa;\n#endif\n#ifndef OPENSSL_NO_DH\n    DH *dh;\n#endif\n\n    alg_k = s->s3->tmp.new_cipher->algorithm_mkey;\n    alg_a = s->s3->tmp.new_cipher->algorithm_auth;\n\n    /* we don't have a certificate */\n    if ((alg_a & SSL_aNULL) || (alg_k & SSL_kPSK))\n        return (1);\n\n    sc = s->session->sess_cert;\n    if (sc == NULL) {\n        SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n#ifndef OPENSSL_NO_RSA\n    rsa = s->session->sess_cert->peer_rsa_tmp;\n#endif\n#ifndef OPENSSL_NO_DH\n    dh = s->session->sess_cert->peer_dh_tmp;\n#endif\n\n    /* This is the passed certificate */\n\n    idx = sc->peer_cert_type;\n#ifndef OPENSSL_NO_EC\n    if (idx == SSL_PKEY_ECC) {\n        if (ssl_check_srvr_ecc_cert_and_alg(sc->peer_pkeys[idx].x509, s) == 0) {\n            /* check failed */\n            SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM, SSL_R_BAD_ECC_CERT);\n            goto f_err;\n        } else {\n            return 1;\n        }\n    } else if (alg_a & SSL_aECDSA) {\n        SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,\n               SSL_R_MISSING_ECDSA_SIGNING_CERT);\n        goto f_err;\n    } else if (alg_k & (SSL_kECDHr | SSL_kECDHe)) {\n        SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM, SSL_R_MISSING_ECDH_CERT);\n        goto f_err;\n    }\n#endif\n    pkey = X509_get_pubkey(sc->peer_pkeys[idx].x509);\n    pkey_bits = EVP_PKEY_bits(pkey);\n    i = X509_certificate_type(sc->peer_pkeys[idx].x509, pkey);\n    EVP_PKEY_free(pkey);\n\n    /* Check that we have a certificate if we require one */\n    if ((alg_a & SSL_aRSA) && !has_bits(i, EVP_PK_RSA | EVP_PKT_SIGN)) {\n        SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,\n               SSL_R_MISSING_RSA_SIGNING_CERT);\n        goto f_err;\n    }\n#ifndef OPENSSL_NO_DSA\n    else if ((alg_a & SSL_aDSS) && !has_bits(i, EVP_PK_DSA | EVP_PKT_SIGN)) {\n        SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,\n               SSL_R_MISSING_DSA_SIGNING_CERT);\n        goto f_err;\n    }\n#endif\n#ifndef OPENSSL_NO_RSA\n    if ((alg_k & SSL_kRSA) &&\n        !(has_bits(i, EVP_PK_RSA | EVP_PKT_ENC) || (rsa != NULL))) {\n        SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,\n               SSL_R_MISSING_RSA_ENCRYPTING_CERT);\n        goto f_err;\n    }\n#endif\n#ifndef OPENSSL_NO_DH\n    if ((alg_k & SSL_kDHE) &&\n        !(has_bits(i, EVP_PK_DH | EVP_PKT_EXCH) || (dh != NULL))) {\n        SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM, SSL_R_MISSING_DH_KEY);\n        goto f_err;\n    } else if ((alg_k & SSL_kDHr) && !SSL_USE_SIGALGS(s) &&\n               !has_bits(i, EVP_PK_DH | EVP_PKS_RSA)) {\n        SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,\n               SSL_R_MISSING_DH_RSA_CERT);\n        goto f_err;\n    }\n# ifndef OPENSSL_NO_DSA\n    else if ((alg_k & SSL_kDHd) && !SSL_USE_SIGALGS(s) &&\n             !has_bits(i, EVP_PK_DH | EVP_PKS_DSA)) {\n        SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,\n               SSL_R_MISSING_DH_DSA_CERT);\n        goto f_err;\n    }\n# endif\n#endif\n\n    if (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher) &&\n        pkey_bits > SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher)) {\n#ifndef OPENSSL_NO_RSA\n        if (alg_k & SSL_kRSA) {\n            if (rsa == NULL\n                || RSA_size(rsa) * 8 >\n                SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher)) {\n                SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,\n                       SSL_R_MISSING_EXPORT_TMP_RSA_KEY);\n                goto f_err;\n            }\n        } else\n#endif\n#ifndef OPENSSL_NO_DH\n        if (alg_k & (SSL_kDHE | SSL_kDHr | SSL_kDHd)) {\n            if (dh == NULL\n                || DH_size(dh) * 8 >\n                SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher)) {\n                SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,\n                       SSL_R_MISSING_EXPORT_TMP_DH_KEY);\n                goto f_err;\n            }\n        } else\n#endif\n        {\n            SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,\n                   SSL_R_UNKNOWN_KEY_EXCHANGE_TYPE);\n            goto f_err;\n        }\n    }\n    return (1);\n f_err:\n    ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_HANDSHAKE_FAILURE);\n err:\n    return (0);\n}",
        "target": 0
    },
    {
        "func": "int ssl3_send_client_verify(SSL *s)\n{\n    unsigned char *p;\n    unsigned char data[MD5_DIGEST_LENGTH + SHA_DIGEST_LENGTH];\n    EVP_PKEY *pkey;\n    EVP_PKEY_CTX *pctx = NULL;\n    EVP_MD_CTX mctx;\n    unsigned u = 0;\n    unsigned long n;\n    int j;\n\n    EVP_MD_CTX_init(&mctx);\n\n    if (s->state == SSL3_ST_CW_CERT_VRFY_A) {\n        p = ssl_handshake_start(s);\n        pkey = s->cert->key->privatekey;\n/* Create context from key and test if sha1 is allowed as digest */\n        pctx = EVP_PKEY_CTX_new(pkey, NULL);\n        EVP_PKEY_sign_init(pctx);\n        if (EVP_PKEY_CTX_set_signature_md(pctx, EVP_sha1()) > 0) {\n            if (!SSL_USE_SIGALGS(s))\n                s->method->ssl3_enc->cert_verify_mac(s,\n                                                     NID_sha1,\n                                                     &(data\n                                                       [MD5_DIGEST_LENGTH]));\n        } else {\n            ERR_clear_error();\n        }\n        /*\n         * For TLS v1.2 send signature algorithm and signature using agreed\n         * digest and cached handshake records.\n         */\n        if (SSL_USE_SIGALGS(s)) {\n            long hdatalen = 0;\n            void *hdata;\n            const EVP_MD *md = s->s3->tmp.md[s->cert->key - s->cert->pkeys];\n            hdatalen = BIO_get_mem_data(s->s3->handshake_buffer, &hdata);\n            if (hdatalen <= 0 || !tls12_get_sigandhash(p, pkey, md)) {\n                SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY, ERR_R_INTERNAL_ERROR);\n                goto err;\n            }\n            p += 2;\n#ifdef SSL_DEBUG\n            fprintf(stderr, \"Using TLS 1.2 with client alg %s\\n\",\n                    EVP_MD_name(md));\n#endif\n            if (!EVP_SignInit_ex(&mctx, md, NULL)\n                || !EVP_SignUpdate(&mctx, hdata, hdatalen)\n                || !EVP_SignFinal(&mctx, p + 2, &u, pkey)) {\n                SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY, ERR_R_EVP_LIB);\n                goto err;\n            }\n            s2n(u, p);\n            n = u + 4;\n            /*\n             * For extended master secret we've already digested cached\n             * records.\n             */\n            if (s->session->flags & SSL_SESS_FLAG_EXTMS) {\n                BIO_free(s->s3->handshake_buffer);\n                s->s3->handshake_buffer = NULL;\n                s->s3->flags &= ~TLS1_FLAGS_KEEP_HANDSHAKE;\n            } else if (!ssl3_digest_cached_records(s))\n                goto err;\n        } else\n#ifndef OPENSSL_NO_RSA\n        if (pkey->type == EVP_PKEY_RSA) {\n            s->method->ssl3_enc->cert_verify_mac(s, NID_md5, &(data[0]));\n            if (RSA_sign(NID_md5_sha1, data,\n                         MD5_DIGEST_LENGTH + SHA_DIGEST_LENGTH,\n                         &(p[2]), &u, pkey->pkey.rsa) <= 0) {\n                SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY, ERR_R_RSA_LIB);\n                goto err;\n            }\n            s2n(u, p);\n            n = u + 2;\n        } else\n#endif\n#ifndef OPENSSL_NO_DSA\n        if (pkey->type == EVP_PKEY_DSA) {\n            if (!DSA_sign(pkey->save_type,\n                          &(data[MD5_DIGEST_LENGTH]),\n                          SHA_DIGEST_LENGTH, &(p[2]),\n                          (unsigned int *)&j, pkey->pkey.dsa)) {\n                SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY, ERR_R_DSA_LIB);\n                goto err;\n            }\n            s2n(j, p);\n            n = j + 2;\n        } else\n#endif\n#ifndef OPENSSL_NO_EC\n        if (pkey->type == EVP_PKEY_EC) {\n            if (!ECDSA_sign(pkey->save_type,\n                            &(data[MD5_DIGEST_LENGTH]),\n                            SHA_DIGEST_LENGTH, &(p[2]),\n                            (unsigned int *)&j, pkey->pkey.ec)) {\n                SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY, ERR_R_ECDSA_LIB);\n                goto err;\n            }\n            s2n(j, p);\n            n = j + 2;\n        } else\n#endif\n        if (pkey->type == NID_id_GostR3410_94\n                || pkey->type == NID_id_GostR3410_2001) {\n            unsigned char signbuf[64];\n            int i;\n            size_t sigsize = 64;\n            s->method->ssl3_enc->cert_verify_mac(s,\n                                                 NID_id_GostR3411_94, data);\n            if (EVP_PKEY_sign(pctx, signbuf, &sigsize, data, 32) <= 0) {\n                SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY, ERR_R_INTERNAL_ERROR);\n                goto err;\n            }\n            for (i = 63, j = 0; i >= 0; j++, i--) {\n                p[2 + j] = signbuf[i];\n            }\n            s2n(j, p);\n            n = j + 2;\n        } else {\n            SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY, ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n        if (!ssl_set_handshake_header(s, SSL3_MT_CERTIFICATE_VERIFY, n)) {\n            SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY, ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n        s->state = SSL3_ST_CW_CERT_VRFY_B;\n    }\n    EVP_MD_CTX_cleanup(&mctx);\n    EVP_PKEY_CTX_free(pctx);\n    return ssl_do_write(s);\n err:\n    EVP_MD_CTX_cleanup(&mctx);\n    EVP_PKEY_CTX_free(pctx);\n    s->state = SSL_ST_ERR;\n    return (-1);\n}",
        "target": 0
    },
    {
        "func": "static int ssl3_check_client_certificate(SSL *s)\n{\n    unsigned long alg_k;\n    if (!s->cert || !s->cert->key->x509 || !s->cert->key->privatekey)\n        return 0;\n    /* If no suitable signature algorithm can't use certificate */\n    if (SSL_USE_SIGALGS(s) && !s->s3->tmp.md[s->cert->key - s->cert->pkeys])\n        return 0;\n    /*\n     * If strict mode check suitability of chain before using it. This also\n     * adjusts suite B digest if necessary.\n     */\n    if (s->cert->cert_flags & SSL_CERT_FLAGS_CHECK_TLS_STRICT &&\n        !tls1_check_chain(s, NULL, NULL, NULL, -2))\n        return 0;\n    alg_k = s->s3->tmp.new_cipher->algorithm_mkey;\n    /* See if we can use client certificate for fixed DH */\n    if (alg_k & (SSL_kDHr | SSL_kDHd)) {\n        SESS_CERT *scert = s->session->sess_cert;\n        int i = scert->peer_cert_type;\n        EVP_PKEY *clkey = NULL, *spkey = NULL;\n        clkey = s->cert->key->privatekey;\n        /* If client key not DH assume it can be used */\n        if (EVP_PKEY_id(clkey) != EVP_PKEY_DH)\n            return 1;\n        if (i >= 0)\n            spkey = X509_get_pubkey(scert->peer_pkeys[i].x509);\n        if (spkey) {\n            /* Compare server and client parameters */\n            i = EVP_PKEY_cmp_parameters(clkey, spkey);\n            EVP_PKEY_free(spkey);\n            if (i != 1)\n                return 0;\n        }\n        s->s3->flags |= TLS1_FLAGS_SKIP_CERT_VERIFY;\n    }\n    return 1;\n}",
        "target": 0
    },
    {
        "func": "int ssl3_get_server_certificate(SSL *s)\n{\n    int al, i, ok, ret = -1, exp_idx;\n    unsigned long n, nc, llen, l;\n    X509 *x = NULL;\n    const unsigned char *q, *p;\n    unsigned char *d;\n    STACK_OF(X509) *sk = NULL;\n    SESS_CERT *sc;\n    EVP_PKEY *pkey = NULL;\n\n    n = s->method->ssl_get_message(s,\n                                   SSL3_ST_CR_CERT_A,\n                                   SSL3_ST_CR_CERT_B,\n                                   -1, s->max_cert_list, &ok);\n\n    if (!ok)\n        return ((int)n);\n\n    if (s->s3->tmp.message_type == SSL3_MT_SERVER_KEY_EXCHANGE) {\n        s->s3->tmp.reuse_message = 1;\n        return (1);\n    }\n\n    if (s->s3->tmp.message_type != SSL3_MT_CERTIFICATE) {\n        al = SSL_AD_UNEXPECTED_MESSAGE;\n        SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE, SSL_R_BAD_MESSAGE_TYPE);\n        goto f_err;\n    }\n    p = d = (unsigned char *)s->init_msg;\n\n    if ((sk = sk_X509_new_null()) == NULL) {\n        SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    n2l3(p, llen);\n    if (llen + 3 != n) {\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE, SSL_R_LENGTH_MISMATCH);\n        goto f_err;\n    }\n    for (nc = 0; nc < llen;) {\n        n2l3(p, l);\n        if ((l + nc + 3) > llen) {\n            al = SSL_AD_DECODE_ERROR;\n            SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,\n                   SSL_R_CERT_LENGTH_MISMATCH);\n            goto f_err;\n        }\n\n        q = p;\n        x = d2i_X509(NULL, &q, l);\n        if (x == NULL) {\n            al = SSL_AD_BAD_CERTIFICATE;\n            SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE, ERR_R_ASN1_LIB);\n            goto f_err;\n        }\n        if (q != (p + l)) {\n            al = SSL_AD_DECODE_ERROR;\n            SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,\n                   SSL_R_CERT_LENGTH_MISMATCH);\n            goto f_err;\n        }\n        if (!sk_X509_push(sk, x)) {\n            SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n        x = NULL;\n        nc += l + 3;\n        p = q;\n    }\n\n    i = ssl_verify_cert_chain(s, sk);\n    if (s->verify_mode != SSL_VERIFY_NONE && i <= 0) {\n        al = ssl_verify_alarm_type(s->verify_result);\n        SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,\n               SSL_R_CERTIFICATE_VERIFY_FAILED);\n        goto f_err;\n    }\n    ERR_clear_error();          /* but we keep s->verify_result */\n    if (i > 1) {\n        SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE, i);\n        al = SSL_AD_HANDSHAKE_FAILURE;\n        goto f_err;\n    }\n\n    sc = ssl_sess_cert_new();\n    if (sc == NULL)\n        goto err;\n\n    ssl_sess_cert_free(s->session->sess_cert);\n    s->session->sess_cert = sc;\n\n    sc->cert_chain = sk;\n    /*\n     * Inconsistency alert: cert_chain does include the peer's certificate,\n     * which we don't include in s3_srvr.c\n     */\n    x = sk_X509_value(sk, 0);\n    sk = NULL;\n    /*\n     * VRS 19990621: possible memory leak; sk=null ==> !sk_pop_free() @end\n     */\n\n    pkey = X509_get_pubkey(x);\n\n    if (pkey == NULL || EVP_PKEY_missing_parameters(pkey)) {\n        x = NULL;\n        al = SSL3_AL_FATAL;\n        SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,\n               SSL_R_UNABLE_TO_FIND_PUBLIC_KEY_PARAMETERS);\n        goto f_err;\n    }\n\n    i = ssl_cert_type(x, pkey);\n    if (i < 0) {\n        x = NULL;\n        al = SSL3_AL_FATAL;\n        SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,\n               SSL_R_UNKNOWN_CERTIFICATE_TYPE);\n        goto f_err;\n    }\n\n    exp_idx = ssl_cipher_get_cert_index(s->s3->tmp.new_cipher);\n    if (exp_idx >= 0 && i != exp_idx) {\n        x = NULL;\n        al = SSL_AD_ILLEGAL_PARAMETER;\n        SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,\n               SSL_R_WRONG_CERTIFICATE_TYPE);\n        goto f_err;\n    }\n    sc->peer_cert_type = i;\n    CRYPTO_add(&x->references, 1, CRYPTO_LOCK_X509);\n    /*\n     * Why would the following ever happen? We just created sc a couple\n     * of lines ago.\n     */\n    X509_free(sc->peer_pkeys[i].x509);\n    sc->peer_pkeys[i].x509 = x;\n    sc->peer_key = &(sc->peer_pkeys[i]);\n\n    X509_free(s->session->peer);\n    CRYPTO_add(&x->references, 1, CRYPTO_LOCK_X509);\n    s->session->peer = x;\n    s->session->verify_result = s->verify_result;\n\n    x = NULL;\n    ret = 1;\n    goto done;\n\n f_err:\n    ssl3_send_alert(s, SSL3_AL_FATAL, al);\n err:\n    s->state = SSL_ST_ERR;\n done:\n    EVP_PKEY_free(pkey);\n    X509_free(x);\n    sk_X509_pop_free(sk, X509_free);\n    return (ret);\n}",
        "target": 0
    },
    {
        "func": "int ssl3_get_key_exchange(SSL *s)\n{\n#ifndef OPENSSL_NO_RSA\n    unsigned char *q, md_buf[EVP_MAX_MD_SIZE * 2];\n#endif\n    EVP_MD_CTX md_ctx;\n    unsigned char *param, *p;\n    int al, j, ok;\n    long i, param_len, n, alg_k, alg_a;\n    EVP_PKEY *pkey = NULL;\n    const EVP_MD *md = NULL;\n#ifndef OPENSSL_NO_RSA\n    RSA *rsa = NULL;\n#endif\n#ifndef OPENSSL_NO_DH\n    DH *dh = NULL;\n#endif\n#ifndef OPENSSL_NO_EC\n    EC_KEY *ecdh = NULL;\n    BN_CTX *bn_ctx = NULL;\n    EC_POINT *srvr_ecpoint = NULL;\n    int curve_nid = 0;\n    int encoded_pt_len = 0;\n#endif\n\n    EVP_MD_CTX_init(&md_ctx);\n\n    /*\n     * use same message size as in ssl3_get_certificate_request() as\n     * ServerKeyExchange message may be skipped\n     */\n    n = s->method->ssl_get_message(s,\n                                   SSL3_ST_CR_KEY_EXCH_A,\n                                   SSL3_ST_CR_KEY_EXCH_B,\n                                   -1, s->max_cert_list, &ok);\n    if (!ok)\n        return ((int)n);\n\n    alg_k = s->s3->tmp.new_cipher->algorithm_mkey;\n\n    if (s->s3->tmp.message_type != SSL3_MT_SERVER_KEY_EXCHANGE) {\n        /*\n         * Can't skip server key exchange if this is an ephemeral\n         * ciphersuite.\n         */\n        if (alg_k & (SSL_kDHE | SSL_kECDHE)) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_UNEXPECTED_MESSAGE);\n            al = SSL_AD_UNEXPECTED_MESSAGE;\n            goto f_err;\n        }\n#ifndef OPENSSL_NO_PSK\n        /*\n         * In plain PSK ciphersuite, ServerKeyExchange can be omitted if no\n         * identity hint is sent. Set session->sess_cert anyway to avoid\n         * problems later.\n         */\n        if (alg_k & SSL_kPSK) {\n            s->session->sess_cert = ssl_sess_cert_new();\n            OPENSSL_free(s->ctx->psk_identity_hint);\n            s->ctx->psk_identity_hint = NULL;\n        }\n#endif\n        s->s3->tmp.reuse_message = 1;\n        return (1);\n    }\n\n    param = p = (unsigned char *)s->init_msg;\n    if (s->session->sess_cert != NULL) {\n#ifndef OPENSSL_NO_RSA\n        RSA_free(s->session->sess_cert->peer_rsa_tmp);\n        s->session->sess_cert->peer_rsa_tmp = NULL;\n#endif\n#ifndef OPENSSL_NO_DH\n        DH_free(s->session->sess_cert->peer_dh_tmp);\n        s->session->sess_cert->peer_dh_tmp = NULL;\n#endif\n#ifndef OPENSSL_NO_EC\n        EC_KEY_free(s->session->sess_cert->peer_ecdh_tmp);\n        s->session->sess_cert->peer_ecdh_tmp = NULL;\n#endif\n    } else {\n        s->session->sess_cert = ssl_sess_cert_new();\n    }\n\n    /* Total length of the parameters including the length prefix */\n    param_len = 0;\n\n    alg_a = s->s3->tmp.new_cipher->algorithm_auth;\n\n    al = SSL_AD_DECODE_ERROR;\n\n#ifndef OPENSSL_NO_PSK\n    if (alg_k & SSL_kPSK) {\n        char tmp_id_hint[PSK_MAX_IDENTITY_LEN + 1];\n\n        param_len = 2;\n        if (param_len > n) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_LENGTH_TOO_SHORT);\n            goto f_err;\n        }\n        n2s(p, i);\n\n        /*\n         * Store PSK identity hint for later use, hint is used in\n         * ssl3_send_client_key_exchange.  Assume that the maximum length of\n         * a PSK identity hint can be as long as the maximum length of a PSK\n         * identity.\n         */\n        if (i > PSK_MAX_IDENTITY_LEN) {\n            al = SSL_AD_HANDSHAKE_FAILURE;\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_DATA_LENGTH_TOO_LONG);\n            goto f_err;\n        }\n        if (i > n - param_len) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n                   SSL_R_BAD_PSK_IDENTITY_HINT_LENGTH);\n            goto f_err;\n        }\n        param_len += i;\n\n        /*\n         * If received PSK identity hint contains NULL characters, the hint\n         * is truncated from the first NULL. p may not be ending with NULL,\n         * so create a NULL-terminated string.\n         */\n        memcpy(tmp_id_hint, p, i);\n        memset(tmp_id_hint + i, 0, PSK_MAX_IDENTITY_LEN + 1 - i);\n        OPENSSL_free(s->ctx->psk_identity_hint);\n        s->ctx->psk_identity_hint = BUF_strdup(tmp_id_hint);\n        if (s->ctx->psk_identity_hint == NULL) {\n            al = SSL_AD_HANDSHAKE_FAILURE;\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_MALLOC_FAILURE);\n            goto f_err;\n        }\n\n        p += i;\n        n -= param_len;\n    } else\n#endif                          /* !OPENSSL_NO_PSK */\n#ifndef OPENSSL_NO_SRP\n    if (alg_k & SSL_kSRP) {\n        param_len = 2;\n        if (param_len > n) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_LENGTH_TOO_SHORT);\n            goto f_err;\n        }\n        n2s(p, i);\n\n        if (i > n - param_len) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_SRP_N_LENGTH);\n            goto f_err;\n        }\n        param_len += i;\n\n        if ((s->srp_ctx.N = BN_bin2bn(p, i, NULL)) == NULL) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_BN_LIB);\n            goto err;\n        }\n        p += i;\n\n        if (2 > n - param_len) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_LENGTH_TOO_SHORT);\n            goto f_err;\n        }\n        param_len += 2;\n\n        n2s(p, i);\n\n        if (i > n - param_len) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_SRP_G_LENGTH);\n            goto f_err;\n        }\n        param_len += i;\n\n        if ((s->srp_ctx.g = BN_bin2bn(p, i, NULL)) == NULL) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_BN_LIB);\n            goto err;\n        }\n        p += i;\n\n        if (1 > n - param_len) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_LENGTH_TOO_SHORT);\n            goto f_err;\n        }\n        param_len += 1;\n\n        i = (unsigned int)(p[0]);\n        p++;\n\n        if (i > n - param_len) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_SRP_S_LENGTH);\n            goto f_err;\n        }\n        param_len += i;\n\n        if ((s->srp_ctx.s = BN_bin2bn(p, i, NULL)) == NULL) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_BN_LIB);\n            goto err;\n        }\n        p += i;\n\n        if (2 > n - param_len) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_LENGTH_TOO_SHORT);\n            goto f_err;\n        }\n        param_len += 2;\n\n        n2s(p, i);\n\n        if (i > n - param_len) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_SRP_B_LENGTH);\n            goto f_err;\n        }\n        param_len += i;\n\n        if ((s->srp_ctx.B = BN_bin2bn(p, i, NULL)) == NULL) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_BN_LIB);\n            goto err;\n        }\n        p += i;\n        n -= param_len;\n\n        if (!srp_verify_server_param(s, &al)) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_SRP_PARAMETERS);\n            goto f_err;\n        }\n\n/* We must check if there is a certificate */\n# ifndef OPENSSL_NO_RSA\n        if (alg_a & SSL_aRSA)\n            pkey =\n                X509_get_pubkey(s->session->\n                                sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);\n# else\n        if (0) ;\n# endif\n# ifndef OPENSSL_NO_DSA\n        else if (alg_a & SSL_aDSS)\n            pkey =\n                X509_get_pubkey(s->session->\n                                sess_cert->peer_pkeys[SSL_PKEY_DSA_SIGN].\n                                x509);\n# endif\n    } else\n#endif                          /* !OPENSSL_NO_SRP */\n#ifndef OPENSSL_NO_RSA\n    if (alg_k & SSL_kRSA) {\n        /* Temporary RSA keys only allowed in export ciphersuites */\n        if (!SSL_C_IS_EXPORT(s->s3->tmp.new_cipher)) {\n            al = SSL_AD_UNEXPECTED_MESSAGE;\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_UNEXPECTED_MESSAGE);\n            goto f_err;\n        }\n        if ((rsa = RSA_new()) == NULL) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n\n        param_len = 2;\n        if (param_len > n) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_LENGTH_TOO_SHORT);\n            goto f_err;\n        }\n        n2s(p, i);\n\n        if (i > n - param_len) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_RSA_MODULUS_LENGTH);\n            goto f_err;\n        }\n        param_len += i;\n\n        if ((rsa->n = BN_bin2bn(p, i, rsa->n)) == NULL) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_BN_LIB);\n            goto err;\n        }\n        p += i;\n\n        if (2 > n - param_len) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_LENGTH_TOO_SHORT);\n            goto f_err;\n        }\n        param_len += 2;\n\n        n2s(p, i);\n\n        if (i > n - param_len) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_RSA_E_LENGTH);\n            goto f_err;\n        }\n        param_len += i;\n\n        if ((rsa->e = BN_bin2bn(p, i, rsa->e)) == NULL) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_BN_LIB);\n            goto err;\n        }\n        p += i;\n        n -= param_len;\n\n        /* this should be because we are using an export cipher */\n        if (alg_a & SSL_aRSA)\n            pkey =\n                X509_get_pubkey(s->session->\n                                sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);\n        else {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n        s->session->sess_cert->peer_rsa_tmp = rsa;\n        rsa = NULL;\n    }\n#else                           /* OPENSSL_NO_RSA */\n    if (0) ;\n#endif\n#ifndef OPENSSL_NO_DH\n    else if (alg_k & SSL_kDHE) {\n        if ((dh = DH_new()) == NULL) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_DH_LIB);\n            goto err;\n        }\n\n        param_len = 2;\n        if (param_len > n) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_LENGTH_TOO_SHORT);\n            goto f_err;\n        }\n        n2s(p, i);\n\n        if (i > n - param_len) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_DH_P_LENGTH);\n            goto f_err;\n        }\n        param_len += i;\n\n        if ((dh->p = BN_bin2bn(p, i, NULL)) == NULL) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_BN_LIB);\n            goto err;\n        }\n        p += i;\n\n        if (2 > n - param_len) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_LENGTH_TOO_SHORT);\n            goto f_err;\n        }\n        param_len += 2;\n\n        n2s(p, i);\n\n        if (i > n - param_len) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_DH_G_LENGTH);\n            goto f_err;\n        }\n        param_len += i;\n\n        if ((dh->g = BN_bin2bn(p, i, NULL)) == NULL) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_BN_LIB);\n            goto err;\n        }\n        p += i;\n\n        if (2 > n - param_len) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_LENGTH_TOO_SHORT);\n            goto f_err;\n        }\n        param_len += 2;\n\n        n2s(p, i);\n\n        if (i > n - param_len) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_DH_PUB_KEY_LENGTH);\n            goto f_err;\n        }\n        param_len += i;\n\n        if ((dh->pub_key = BN_bin2bn(p, i, NULL)) == NULL) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_BN_LIB);\n            goto err;\n        }\n        p += i;\n        n -= param_len;\n\n        if (!ssl_security(s, SSL_SECOP_TMP_DH, DH_security_bits(dh), 0, dh)) {\n            al = SSL_AD_HANDSHAKE_FAILURE;\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_DH_KEY_TOO_SMALL);\n            goto f_err;\n        }\n# ifndef OPENSSL_NO_RSA\n        if (alg_a & SSL_aRSA)\n            pkey =\n                X509_get_pubkey(s->session->\n                                sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);\n# else\n        if (0) ;\n# endif\n# ifndef OPENSSL_NO_DSA\n        else if (alg_a & SSL_aDSS)\n            pkey =\n                X509_get_pubkey(s->session->\n                                sess_cert->peer_pkeys[SSL_PKEY_DSA_SIGN].\n                                x509);\n# endif\n        /* else anonymous DH, so no certificate or pkey. */\n\n        s->session->sess_cert->peer_dh_tmp = dh;\n        dh = NULL;\n    }\n#endif                          /* !OPENSSL_NO_DH */\n\n#ifndef OPENSSL_NO_EC\n    else if (alg_k & SSL_kECDHE) {\n        EC_GROUP *ngroup;\n        const EC_GROUP *group;\n\n        if ((ecdh = EC_KEY_new()) == NULL) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n\n        /*\n         * Extract elliptic curve parameters and the server's ephemeral ECDH\n         * public key. Keep accumulating lengths of various components in\n         * param_len and make sure it never exceeds n.\n         */\n\n        /*\n         * XXX: For now we only support named (not generic) curves and the\n         * ECParameters in this case is just three bytes. We also need one\n         * byte for the length of the encoded point\n         */\n        param_len = 4;\n        if (param_len > n) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_LENGTH_TOO_SHORT);\n            goto f_err;\n        }\n        /*\n         * Check curve is one of our preferences, if not server has sent an\n         * invalid curve. ECParameters is 3 bytes.\n         */\n        if (!tls1_check_curve(s, p, 3)) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_WRONG_CURVE);\n            goto f_err;\n        }\n\n        if ((curve_nid = tls1_ec_curve_id2nid(*(p + 2))) == 0) {\n            al = SSL_AD_INTERNAL_ERROR;\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n                   SSL_R_UNABLE_TO_FIND_ECDH_PARAMETERS);\n            goto f_err;\n        }\n\n        ngroup = EC_GROUP_new_by_curve_name(curve_nid);\n        if (ngroup == NULL) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_EC_LIB);\n            goto err;\n        }\n        if (EC_KEY_set_group(ecdh, ngroup) == 0) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_EC_LIB);\n            goto err;\n        }\n        EC_GROUP_free(ngroup);\n\n        group = EC_KEY_get0_group(ecdh);\n\n        if (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher) &&\n            (EC_GROUP_get_degree(group) > 163)) {\n            al = SSL_AD_EXPORT_RESTRICTION;\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n                   SSL_R_ECGROUP_TOO_LARGE_FOR_CIPHER);\n            goto f_err;\n        }\n\n        p += 3;\n\n        /* Next, get the encoded ECPoint */\n        if (((srvr_ecpoint = EC_POINT_new(group)) == NULL) ||\n            ((bn_ctx = BN_CTX_new()) == NULL)) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n\n        encoded_pt_len = *p;    /* length of encoded point */\n        p += 1;\n\n        if ((encoded_pt_len > n - param_len) ||\n            (EC_POINT_oct2point(group, srvr_ecpoint,\n                                p, encoded_pt_len, bn_ctx) == 0)) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_ECPOINT);\n            goto f_err;\n        }\n        param_len += encoded_pt_len;\n\n        n -= param_len;\n        p += encoded_pt_len;\n\n        /*\n         * The ECC/TLS specification does not mention the use of DSA to sign\n         * ECParameters in the server key exchange message. We do support RSA\n         * and ECDSA.\n         */\n        if (0) ;\n# ifndef OPENSSL_NO_RSA\n        else if (alg_a & SSL_aRSA)\n            pkey =\n                X509_get_pubkey(s->session->\n                                sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);\n# endif\n# ifndef OPENSSL_NO_EC\n        else if (alg_a & SSL_aECDSA)\n            pkey =\n                X509_get_pubkey(s->session->\n                                sess_cert->peer_pkeys[SSL_PKEY_ECC].x509);\n# endif\n        /* else anonymous ECDH, so no certificate or pkey. */\n        EC_KEY_set_public_key(ecdh, srvr_ecpoint);\n        s->session->sess_cert->peer_ecdh_tmp = ecdh;\n        ecdh = NULL;\n        BN_CTX_free(bn_ctx);\n        bn_ctx = NULL;\n        EC_POINT_free(srvr_ecpoint);\n        srvr_ecpoint = NULL;\n    } else if (alg_k) {\n        al = SSL_AD_UNEXPECTED_MESSAGE;\n        SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_UNEXPECTED_MESSAGE);\n        goto f_err;\n    }\n#endif                          /* !OPENSSL_NO_EC */\n\n    /* p points to the next byte, there are 'n' bytes left */\n\n    /* if it was signed, check the signature */\n    if (pkey != NULL) {\n        if (SSL_USE_SIGALGS(s)) {\n            int rv;\n            if (2 > n) {\n                SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_LENGTH_TOO_SHORT);\n                goto f_err;\n            }\n            rv = tls12_check_peer_sigalg(&md, s, p, pkey);\n            if (rv == -1)\n                goto err;\n            else if (rv == 0) {\n                goto f_err;\n            }\n#ifdef SSL_DEBUG\n            fprintf(stderr, \"USING TLSv1.2 HASH %s\\n\", EVP_MD_name(md));\n#endif\n            p += 2;\n            n -= 2;\n        } else\n            md = EVP_sha1();\n\n        if (2 > n) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_LENGTH_TOO_SHORT);\n            goto f_err;\n        }\n        n2s(p, i);\n        n -= 2;\n        j = EVP_PKEY_size(pkey);\n\n        /*\n         * Check signature length. If n is 0 then signature is empty\n         */\n        if ((i != n) || (n > j) || (n <= 0)) {\n            /* wrong packet length */\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_WRONG_SIGNATURE_LENGTH);\n            goto f_err;\n        }\n#ifndef OPENSSL_NO_RSA\n        if (pkey->type == EVP_PKEY_RSA && !SSL_USE_SIGALGS(s)) {\n            int num;\n            unsigned int size;\n\n            j = 0;\n            q = md_buf;\n            for (num = 2; num > 0; num--) {\n                EVP_MD_CTX_set_flags(&md_ctx, EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);\n                EVP_DigestInit_ex(&md_ctx, (num == 2)\n                                  ? s->ctx->md5 : s->ctx->sha1, NULL);\n                EVP_DigestUpdate(&md_ctx, &(s->s3->client_random[0]),\n                                 SSL3_RANDOM_SIZE);\n                EVP_DigestUpdate(&md_ctx, &(s->s3->server_random[0]),\n                                 SSL3_RANDOM_SIZE);\n                EVP_DigestUpdate(&md_ctx, param, param_len);\n                EVP_DigestFinal_ex(&md_ctx, q, &size);\n                q += size;\n                j += size;\n            }\n            i = RSA_verify(NID_md5_sha1, md_buf, j, p, n, pkey->pkey.rsa);\n            if (i < 0) {\n                al = SSL_AD_DECRYPT_ERROR;\n                SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_RSA_DECRYPT);\n                goto f_err;\n            }\n            if (i == 0) {\n                /* bad signature */\n                al = SSL_AD_DECRYPT_ERROR;\n                SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_SIGNATURE);\n                goto f_err;\n            }\n        } else\n#endif\n        {\n            EVP_VerifyInit_ex(&md_ctx, md, NULL);\n            EVP_VerifyUpdate(&md_ctx, &(s->s3->client_random[0]),\n                             SSL3_RANDOM_SIZE);\n            EVP_VerifyUpdate(&md_ctx, &(s->s3->server_random[0]),\n                             SSL3_RANDOM_SIZE);\n            EVP_VerifyUpdate(&md_ctx, param, param_len);\n            if (EVP_VerifyFinal(&md_ctx, p, (int)n, pkey) <= 0) {\n                /* bad signature */\n                al = SSL_AD_DECRYPT_ERROR;\n                SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_SIGNATURE);\n                goto f_err;\n            }\n        }\n    } else {\n        /* aNULL, aSRP or kPSK do not need public keys */\n        if (!(alg_a & (SSL_aNULL | SSL_aSRP)) && !(alg_k & SSL_kPSK)) {\n            /* Might be wrong key type, check it */\n            if (ssl3_check_cert_and_algorithm(s))\n                /* Otherwise this shouldn't happen */\n                SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n        /* still data left over */\n        if (n != 0) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_EXTRA_DATA_IN_MESSAGE);\n            goto f_err;\n        }\n    }\n    EVP_PKEY_free(pkey);\n    EVP_MD_CTX_cleanup(&md_ctx);\n    return (1);\n f_err:\n    ssl3_send_alert(s, SSL3_AL_FATAL, al);\n err:\n    EVP_PKEY_free(pkey);\n#ifndef OPENSSL_NO_RSA\n    RSA_free(rsa);\n#endif\n#ifndef OPENSSL_NO_DH\n    DH_free(dh);\n#endif\n#ifndef OPENSSL_NO_EC\n    BN_CTX_free(bn_ctx);\n    EC_POINT_free(srvr_ecpoint);\n    EC_KEY_free(ecdh);\n#endif\n    EVP_MD_CTX_cleanup(&md_ctx);\n    s->state = SSL_ST_ERR;\n    return (-1);\n}",
        "target": 0
    },
    {
        "func": "int ssl3_send_client_key_exchange(SSL *s)\n{\n    unsigned char *p;\n    int n;\n    unsigned long alg_k;\n#ifndef OPENSSL_NO_RSA\n    unsigned char *q;\n    EVP_PKEY *pkey = NULL;\n#endif\n#ifndef OPENSSL_NO_EC\n    EC_KEY *clnt_ecdh = NULL;\n    const EC_POINT *srvr_ecpoint = NULL;\n    EVP_PKEY *srvr_pub_pkey = NULL;\n    unsigned char *encodedPoint = NULL;\n    int encoded_pt_len = 0;\n    BN_CTX *bn_ctx = NULL;\n#endif\n    unsigned char *pms = NULL;\n    size_t pmslen = 0;\n\n    if (s->state == SSL3_ST_CW_KEY_EXCH_A) {\n        p = ssl_handshake_start(s);\n\n        alg_k = s->s3->tmp.new_cipher->algorithm_mkey;\n\n        /* Fool emacs indentation */\n        if (0) {\n        }\n#ifndef OPENSSL_NO_RSA\n        else if (alg_k & SSL_kRSA) {\n            RSA *rsa;\n            pmslen = SSL_MAX_MASTER_KEY_LENGTH;\n            pms = OPENSSL_malloc(pmslen);\n            if (!pms)\n                goto memerr;\n\n            if (s->session->sess_cert == NULL) {\n                /*\n                 * We should always have a server certificate with SSL_kRSA.\n                 */\n                SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,\n                       ERR_R_INTERNAL_ERROR);\n                goto err;\n            }\n\n            if (s->session->sess_cert->peer_rsa_tmp != NULL)\n                rsa = s->session->sess_cert->peer_rsa_tmp;\n            else {\n                pkey =\n                    X509_get_pubkey(s->session->\n                                    sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].\n                                    x509);\n                if ((pkey == NULL) || (pkey->type != EVP_PKEY_RSA)\n                    || (pkey->pkey.rsa == NULL)) {\n                    SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,\n                           ERR_R_INTERNAL_ERROR);\n                    goto err;\n                }\n                rsa = pkey->pkey.rsa;\n                EVP_PKEY_free(pkey);\n            }\n\n            pms[0] = s->client_version >> 8;\n            pms[1] = s->client_version & 0xff;\n            if (RAND_bytes(pms + 2, pmslen - 2) <= 0)\n                goto err;\n\n            q = p;\n            /* Fix buf for TLS and beyond */\n            if (s->version > SSL3_VERSION)\n                p += 2;\n            n = RSA_public_encrypt(pmslen, pms, p, rsa, RSA_PKCS1_PADDING);\n# ifdef PKCS1_CHECK\n            if (s->options & SSL_OP_PKCS1_CHECK_1)\n                p[1]++;\n            if (s->options & SSL_OP_PKCS1_CHECK_2)\n                tmp_buf[0] = 0x70;\n# endif\n            if (n <= 0) {\n                SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,\n                       SSL_R_BAD_RSA_ENCRYPT);\n                goto err;\n            }\n\n            /* Fix buf for TLS and beyond */\n            if (s->version > SSL3_VERSION) {\n                s2n(n, q);\n                n += 2;\n            }\n        }\n#endif\n#ifndef OPENSSL_NO_DH\n        else if (alg_k & (SSL_kDHE | SSL_kDHr | SSL_kDHd)) {\n            DH *dh_srvr, *dh_clnt;\n            SESS_CERT *scert = s->session->sess_cert;\n\n            if (scert == NULL) {\n                ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_UNEXPECTED_MESSAGE);\n                SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,\n                       SSL_R_UNEXPECTED_MESSAGE);\n                goto err;\n            }\n\n            if (scert->peer_dh_tmp != NULL)\n                dh_srvr = scert->peer_dh_tmp;\n            else {\n                /* we get them from the cert */\n                int idx = scert->peer_cert_type;\n                EVP_PKEY *spkey = NULL;\n                dh_srvr = NULL;\n                if (idx >= 0)\n                    spkey = X509_get_pubkey(scert->peer_pkeys[idx].x509);\n                if (spkey) {\n                    dh_srvr = EVP_PKEY_get1_DH(spkey);\n                    EVP_PKEY_free(spkey);\n                }\n                if (dh_srvr == NULL) {\n                    SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,\n                           ERR_R_INTERNAL_ERROR);\n                    goto err;\n                }\n            }\n            if (s->s3->flags & TLS1_FLAGS_SKIP_CERT_VERIFY) {\n                /* Use client certificate key */\n                EVP_PKEY *clkey = s->cert->key->privatekey;\n                dh_clnt = NULL;\n                if (clkey)\n                    dh_clnt = EVP_PKEY_get1_DH(clkey);\n                if (dh_clnt == NULL) {\n                    SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,\n                           ERR_R_INTERNAL_ERROR);\n                    goto err;\n                }\n            } else {\n                /* generate a new random key */\n                if ((dh_clnt = DHparams_dup(dh_srvr)) == NULL) {\n                    SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_DH_LIB);\n                    goto err;\n                }\n                if (!DH_generate_key(dh_clnt)) {\n                    SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_DH_LIB);\n                    DH_free(dh_clnt);\n                    goto err;\n                }\n            }\n\n            pmslen = DH_size(dh_clnt);\n            pms = OPENSSL_malloc(pmslen);\n            if (!pms)\n                goto memerr;\n\n            /*\n             * use the 'p' output buffer for the DH key, but make sure to\n             * clear it out afterwards\n             */\n\n            n = DH_compute_key(pms, dh_srvr->pub_key, dh_clnt);\n            if (scert->peer_dh_tmp == NULL)\n                DH_free(dh_srvr);\n\n            if (n <= 0) {\n                SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_DH_LIB);\n                DH_free(dh_clnt);\n                goto err;\n            }\n            pmslen = n;\n\n            if (s->s3->flags & TLS1_FLAGS_SKIP_CERT_VERIFY)\n                n = 0;\n            else {\n                /* send off the data */\n                n = BN_num_bytes(dh_clnt->pub_key);\n                s2n(n, p);\n                BN_bn2bin(dh_clnt->pub_key, p);\n                n += 2;\n            }\n\n            DH_free(dh_clnt);\n\n            /* perhaps clean things up a bit EAY EAY EAY EAY */\n        }\n#endif\n\n#ifndef OPENSSL_NO_EC\n        else if (alg_k & (SSL_kECDHE | SSL_kECDHr | SSL_kECDHe)) {\n            const EC_GROUP *srvr_group = NULL;\n            EC_KEY *tkey;\n            int ecdh_clnt_cert = 0;\n            int field_size = 0;\n\n            if (s->session->sess_cert == NULL) {\n                ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_UNEXPECTED_MESSAGE);\n                SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,\n                       SSL_R_UNEXPECTED_MESSAGE);\n                goto err;\n            }\n\n            /*\n             * Did we send out the client's ECDH share for use in premaster\n             * computation as part of client certificate? If so, set\n             * ecdh_clnt_cert to 1.\n             */\n            if ((alg_k & (SSL_kECDHr | SSL_kECDHe)) && (s->cert != NULL)) {\n                /*-\n                 * XXX: For now, we do not support client\n                 * authentication using ECDH certificates.\n                 * To add such support, one needs to add\n                 * code that checks for appropriate\n                 * conditions and sets ecdh_clnt_cert to 1.\n                 * For example, the cert have an ECC\n                 * key on the same curve as the server's\n                 * and the key should be authorized for\n                 * key agreement.\n                 *\n                 * One also needs to add code in ssl3_connect\n                 * to skip sending the certificate verify\n                 * message.\n                 *\n                 * if ((s->cert->key->privatekey != NULL) &&\n                 *     (s->cert->key->privatekey->type ==\n                 *      EVP_PKEY_EC) && ...)\n                 * ecdh_clnt_cert = 1;\n                 */\n            }\n\n            if (s->session->sess_cert->peer_ecdh_tmp != NULL) {\n                tkey = s->session->sess_cert->peer_ecdh_tmp;\n            } else {\n                /* Get the Server Public Key from Cert */\n                srvr_pub_pkey =\n                    X509_get_pubkey(s->session->\n                                    sess_cert->peer_pkeys[SSL_PKEY_ECC].x509);\n                if ((srvr_pub_pkey == NULL)\n                    || (srvr_pub_pkey->type != EVP_PKEY_EC)\n                    || (srvr_pub_pkey->pkey.ec == NULL)) {\n                    SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,\n                           ERR_R_INTERNAL_ERROR);\n                    goto err;\n                }\n\n                tkey = srvr_pub_pkey->pkey.ec;\n            }\n\n            srvr_group = EC_KEY_get0_group(tkey);\n            srvr_ecpoint = EC_KEY_get0_public_key(tkey);\n\n            if ((srvr_group == NULL) || (srvr_ecpoint == NULL)) {\n                SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,\n                       ERR_R_INTERNAL_ERROR);\n                goto err;\n            }\n\n            if ((clnt_ecdh = EC_KEY_new()) == NULL) {\n                SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,\n                       ERR_R_MALLOC_FAILURE);\n                goto err;\n            }\n\n            if (!EC_KEY_set_group(clnt_ecdh, srvr_group)) {\n                SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_EC_LIB);\n                goto err;\n            }\n            if (ecdh_clnt_cert) {\n                /*\n                 * Reuse key info from our certificate We only need our\n                 * private key to perform the ECDH computation.\n                 */\n                const BIGNUM *priv_key;\n                tkey = s->cert->key->privatekey->pkey.ec;\n                priv_key = EC_KEY_get0_private_key(tkey);\n                if (priv_key == NULL) {\n                    SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,\n                           ERR_R_MALLOC_FAILURE);\n                    goto err;\n                }\n                if (!EC_KEY_set_private_key(clnt_ecdh, priv_key)) {\n                    SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_EC_LIB);\n                    goto err;\n                }\n            } else {\n                /* Generate a new ECDH key pair */\n                if (!(EC_KEY_generate_key(clnt_ecdh))) {\n                    SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,\n                           ERR_R_ECDH_LIB);\n                    goto err;\n                }\n            }\n\n            /*\n             * use the 'p' output buffer for the ECDH key, but make sure to\n             * clear it out afterwards\n             */\n\n            field_size = EC_GROUP_get_degree(srvr_group);\n            if (field_size <= 0) {\n                SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_ECDH_LIB);\n                goto err;\n            }\n            pmslen = (field_size + 7) / 8;\n            pms = OPENSSL_malloc(pmslen);\n            if (!pms)\n                goto memerr;\n            n = ECDH_compute_key(pms, pmslen, srvr_ecpoint, clnt_ecdh, NULL);\n            if (n <= 0 || pmslen != (size_t)n) {\n                SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_ECDH_LIB);\n                goto err;\n            }\n\n            if (ecdh_clnt_cert) {\n                /* Send empty client key exch message */\n                n = 0;\n            } else {\n                /*\n                 * First check the size of encoding and allocate memory\n                 * accordingly.\n                 */\n                encoded_pt_len =\n                    EC_POINT_point2oct(srvr_group,\n                                       EC_KEY_get0_public_key(clnt_ecdh),\n                                       POINT_CONVERSION_UNCOMPRESSED,\n                                       NULL, 0, NULL);\n\n                encodedPoint = (unsigned char *)\n                    OPENSSL_malloc(encoded_pt_len * sizeof(unsigned char));\n                bn_ctx = BN_CTX_new();\n                if ((encodedPoint == NULL) || (bn_ctx == NULL)) {\n                    SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,\n                           ERR_R_MALLOC_FAILURE);\n                    goto err;\n                }\n\n                /* Encode the public key */\n                n = EC_POINT_point2oct(srvr_group,\n                                       EC_KEY_get0_public_key(clnt_ecdh),\n                                       POINT_CONVERSION_UNCOMPRESSED,\n                                       encodedPoint, encoded_pt_len, bn_ctx);\n\n                *p = n;         /* length of encoded point */\n                /* Encoded point will be copied here */\n                p += 1;\n                /* copy the point */\n                memcpy(p, encodedPoint, n);\n                /* increment n to account for length field */\n                n += 1;\n            }\n\n            /* Free allocated memory */\n            BN_CTX_free(bn_ctx);\n            OPENSSL_free(encodedPoint);\n            EC_KEY_free(clnt_ecdh);\n            EVP_PKEY_free(srvr_pub_pkey);\n        }\n#endif                          /* !OPENSSL_NO_EC */\n        else if (alg_k & SSL_kGOST) {\n            /* GOST key exchange message creation */\n            EVP_PKEY_CTX *pkey_ctx;\n            X509 *peer_cert;\n            size_t msglen;\n            unsigned int md_len;\n            int keytype;\n            unsigned char shared_ukm[32], tmp[256];\n            EVP_MD_CTX *ukm_hash;\n            EVP_PKEY *pub_key;\n\n            pmslen = 32;\n            pms = OPENSSL_malloc(pmslen);\n            if (!pms)\n                goto memerr;\n\n            /*\n             * Get server sertificate PKEY and create ctx from it\n             */\n            peer_cert =\n                s->session->\n                sess_cert->peer_pkeys[(keytype = SSL_PKEY_GOST01)].x509;\n            if (!peer_cert)\n                peer_cert =\n                    s->session->\n                    sess_cert->peer_pkeys[(keytype = SSL_PKEY_GOST94)].x509;\n            if (!peer_cert) {\n                SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,\n                       SSL_R_NO_GOST_CERTIFICATE_SENT_BY_PEER);\n                goto err;\n            }\n\n            pkey_ctx = EVP_PKEY_CTX_new(pub_key =\n                                        X509_get_pubkey(peer_cert), NULL);\n            /*\n             * If we have send a certificate, and certificate key\n             *\n             * * parameters match those of server certificate, use\n             * certificate key for key exchange\n             */\n\n            /* Otherwise, generate ephemeral key pair */\n\n            EVP_PKEY_encrypt_init(pkey_ctx);\n            /* Generate session key */\n            if (RAND_bytes(pms, pmslen) <= 0) {\n                EVP_PKEY_CTX_free(pkey_ctx);\n                SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,\n                       ERR_R_INTERNAL_ERROR);\n                goto err;\n            };\n            /*\n             * If we have client certificate, use its secret as peer key\n             */\n            if (s->s3->tmp.cert_req && s->cert->key->privatekey) {\n                if (EVP_PKEY_derive_set_peer\n                    (pkey_ctx, s->cert->key->privatekey) <= 0) {\n                    /*\n                     * If there was an error - just ignore it. Ephemeral key\n                     * * would be used\n                     */\n                    ERR_clear_error();\n                }\n            }\n            /*\n             * Compute shared IV and store it in algorithm-specific context\n             * data\n             */\n            ukm_hash = EVP_MD_CTX_create();\n            EVP_DigestInit(ukm_hash,\n                           EVP_get_digestbynid(NID_id_GostR3411_94));\n            EVP_DigestUpdate(ukm_hash, s->s3->client_random,\n                             SSL3_RANDOM_SIZE);\n            EVP_DigestUpdate(ukm_hash, s->s3->server_random,\n                             SSL3_RANDOM_SIZE);\n            EVP_DigestFinal_ex(ukm_hash, shared_ukm, &md_len);\n            EVP_MD_CTX_destroy(ukm_hash);\n            if (EVP_PKEY_CTX_ctrl\n                (pkey_ctx, -1, EVP_PKEY_OP_ENCRYPT, EVP_PKEY_CTRL_SET_IV, 8,\n                 shared_ukm) < 0) {\n                SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,\n                       SSL_R_LIBRARY_BUG);\n                goto err;\n            }\n            /* Make GOST keytransport blob message */\n            /*\n             * Encapsulate it into sequence\n             */\n            *(p++) = V_ASN1_SEQUENCE | V_ASN1_CONSTRUCTED;\n            msglen = 255;\n            if (EVP_PKEY_encrypt(pkey_ctx, tmp, &msglen, pms, pmslen) < 0) {\n                SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,\n                       SSL_R_LIBRARY_BUG);\n                goto err;\n            }\n            if (msglen >= 0x80) {\n                *(p++) = 0x81;\n                *(p++) = msglen & 0xff;\n                n = msglen + 3;\n            } else {\n                *(p++) = msglen & 0xff;\n                n = msglen + 2;\n            }\n            memcpy(p, tmp, msglen);\n            /* Check if pubkey from client certificate was used */\n            if (EVP_PKEY_CTX_ctrl\n                (pkey_ctx, -1, -1, EVP_PKEY_CTRL_PEER_KEY, 2, NULL) > 0) {\n                /* Set flag \"skip certificate verify\" */\n                s->s3->flags |= TLS1_FLAGS_SKIP_CERT_VERIFY;\n            }\n            EVP_PKEY_CTX_free(pkey_ctx);\n            EVP_PKEY_free(pub_key);\n\n        }\n#ifndef OPENSSL_NO_SRP\n        else if (alg_k & SSL_kSRP) {\n            if (s->srp_ctx.A != NULL) {\n                /* send off the data */\n                n = BN_num_bytes(s->srp_ctx.A);\n                s2n(n, p);\n                BN_bn2bin(s->srp_ctx.A, p);\n                n += 2;\n            } else {\n                SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,\n                       ERR_R_INTERNAL_ERROR);\n                goto err;\n            }\n            OPENSSL_free(s->session->srp_username);\n            s->session->srp_username = BUF_strdup(s->srp_ctx.login);\n            if (s->session->srp_username == NULL) {\n                SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,\n                       ERR_R_MALLOC_FAILURE);\n                goto err;\n            }\n        }\n#endif\n#ifndef OPENSSL_NO_PSK\n        else if (alg_k & SSL_kPSK) {\n            /*\n             * The callback needs PSK_MAX_IDENTITY_LEN + 1 bytes to return a\n             * \\0-terminated identity. The last byte is for us for simulating\n             * strnlen.\n             */\n            char identity[PSK_MAX_IDENTITY_LEN + 2];\n            size_t identity_len;\n            unsigned char *t = NULL;\n            unsigned int psk_len = 0;\n            int psk_err = 1;\n\n            n = 0;\n            if (s->psk_client_callback == NULL) {\n                SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,\n                       SSL_R_PSK_NO_CLIENT_CB);\n                goto err;\n            }\n\n            memset(identity, 0, sizeof(identity));\n            /* Allocate maximum size buffer */\n            pmslen = PSK_MAX_PSK_LEN * 2 + 4;\n            pms = OPENSSL_malloc(pmslen);\n            if (!pms)\n                goto memerr;\n\n            psk_len = s->psk_client_callback(s, s->ctx->psk_identity_hint,\n                                             identity, sizeof(identity) - 1,\n                                             pms, pmslen);\n            if (psk_len > PSK_MAX_PSK_LEN) {\n                SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,\n                       ERR_R_INTERNAL_ERROR);\n                goto psk_err;\n            } else if (psk_len == 0) {\n                SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,\n                       SSL_R_PSK_IDENTITY_NOT_FOUND);\n                goto psk_err;\n            }\n            /* Change pmslen to real length */\n            pmslen = 2 + psk_len + 2 + psk_len;\n            identity[PSK_MAX_IDENTITY_LEN + 1] = '\\0';\n            identity_len = strlen(identity);\n            if (identity_len > PSK_MAX_IDENTITY_LEN) {\n                SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,\n                       ERR_R_INTERNAL_ERROR);\n                goto psk_err;\n            }\n            /* create PSK pre_master_secret */\n            t = pms;\n            memmove(pms + psk_len + 4, pms, psk_len);\n            s2n(psk_len, t);\n            memset(t, 0, psk_len);\n            t += psk_len;\n            s2n(psk_len, t);\n\n            OPENSSL_free(s->session->psk_identity_hint);\n            s->session->psk_identity_hint =\n                BUF_strdup(s->ctx->psk_identity_hint);\n            if (s->ctx->psk_identity_hint != NULL\n                && s->session->psk_identity_hint == NULL) {\n                SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,\n                       ERR_R_MALLOC_FAILURE);\n                goto psk_err;\n            }\n\n            OPENSSL_free(s->session->psk_identity);\n            s->session->psk_identity = BUF_strdup(identity);\n            if (s->session->psk_identity == NULL) {\n                SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,\n                       ERR_R_MALLOC_FAILURE);\n                goto psk_err;\n            }\n\n            s2n(identity_len, p);\n            memcpy(p, identity, identity_len);\n            n = 2 + identity_len;\n            psk_err = 0;\n psk_err:\n            OPENSSL_cleanse(identity, sizeof(identity));\n            if (psk_err != 0) {\n                ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_HANDSHAKE_FAILURE);\n                goto err;\n            }\n        }\n#endif\n        else {\n            ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_HANDSHAKE_FAILURE);\n            SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n\n        if (!ssl_set_handshake_header(s, SSL3_MT_CLIENT_KEY_EXCHANGE, n)) {\n            ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_HANDSHAKE_FAILURE);\n            SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n\n        s->state = SSL3_ST_CW_KEY_EXCH_B;\n    }\n\n    /* SSL3_ST_CW_KEY_EXCH_B */\n    n = ssl_do_write(s);\n#ifndef OPENSSL_NO_SRP\n    /* Check for SRP */\n    if (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kSRP) {\n        /*\n         * If everything written generate master key: no need to save PMS as\n         * SRP_generate_client_master_secret generates it internally.\n         */\n        if (n > 0) {\n            if ((s->session->master_key_length =\n                 SRP_generate_client_master_secret(s,\n                                                   s->session->master_key)) <\n                0) {\n                SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,\n                       ERR_R_INTERNAL_ERROR);\n                goto err;\n            }\n        }\n    } else\n#endif\n        /* If we haven't written everything save PMS */\n    if (n <= 0) {\n        s->s3->tmp.pms = pms;\n        s->s3->tmp.pmslen = pmslen;\n    } else {\n        /* If we don't have a PMS restore */\n        if (pms == NULL) {\n            pms = s->s3->tmp.pms;\n            pmslen = s->s3->tmp.pmslen;\n        }\n        if (pms == NULL) {\n            ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);\n            SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n        s->session->master_key_length =\n            s->method->ssl3_enc->generate_master_secret(s,\n                                                        s->\n                                                        session->master_key,\n                                                        pms, pmslen);\n        OPENSSL_clear_free(pms, pmslen);\n        s->s3->tmp.pms = NULL;\n        if (s->session->master_key_length < 0) {\n            ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);\n            SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n    }\n    return n;\n memerr:\n    ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);\n    SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_MALLOC_FAILURE);\n err:\n    OPENSSL_clear_free(pms, pmslen);\n    s->s3->tmp.pms = NULL;\n#ifndef OPENSSL_NO_EC\n    BN_CTX_free(bn_ctx);\n    OPENSSL_free(encodedPoint);\n    EC_KEY_free(clnt_ecdh);\n    EVP_PKEY_free(srvr_pub_pkey);\n#endif\n    s->state = SSL_ST_ERR;\n    return (-1);\n}",
        "target": 0
    },
    {
        "func": "int ssl3_get_certificate_request(SSL *s)\n{\n    int ok, ret = 0;\n    unsigned long n, nc, l;\n    unsigned int llen, ctype_num, i;\n    X509_NAME *xn = NULL;\n    const unsigned char *p, *q;\n    unsigned char *d;\n    STACK_OF(X509_NAME) *ca_sk = NULL;\n\n    n = s->method->ssl_get_message(s,\n                                   SSL3_ST_CR_CERT_REQ_A,\n                                   SSL3_ST_CR_CERT_REQ_B,\n                                   -1, s->max_cert_list, &ok);\n\n    if (!ok)\n        return ((int)n);\n\n    s->s3->tmp.cert_req = 0;\n\n    if (s->s3->tmp.message_type == SSL3_MT_SERVER_DONE) {\n        s->s3->tmp.reuse_message = 1;\n        /*\n         * If we get here we don't need any cached handshake records as we\n         * wont be doing client auth.\n         */\n        if (s->s3->handshake_buffer) {\n            if (!ssl3_digest_cached_records(s))\n                goto err;\n        }\n        return (1);\n    }\n\n    if (s->s3->tmp.message_type != SSL3_MT_CERTIFICATE_REQUEST) {\n        ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_UNEXPECTED_MESSAGE);\n        SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST, SSL_R_WRONG_MESSAGE_TYPE);\n        goto err;\n    }\n\n    /* TLS does not like anon-DH with client cert */\n    if (s->version > SSL3_VERSION) {\n        if (s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL) {\n            ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_UNEXPECTED_MESSAGE);\n            SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,\n                   SSL_R_TLS_CLIENT_CERT_REQ_WITH_ANON_CIPHER);\n            goto err;\n        }\n    }\n\n    p = d = (unsigned char *)s->init_msg;\n\n    if ((ca_sk = sk_X509_NAME_new(ca_dn_cmp)) == NULL) {\n        SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    /* get the certificate types */\n    ctype_num = *(p++);\n    OPENSSL_free(s->cert->ctypes);\n    s->cert->ctypes = NULL;\n    if (ctype_num > SSL3_CT_NUMBER) {\n        /* If we exceed static buffer copy all to cert structure */\n        s->cert->ctypes = OPENSSL_malloc(ctype_num);\n        if (s->cert->ctypes == NULL) {\n            SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n        memcpy(s->cert->ctypes, p, ctype_num);\n        s->cert->ctype_num = (size_t)ctype_num;\n        ctype_num = SSL3_CT_NUMBER;\n    }\n    for (i = 0; i < ctype_num; i++)\n        s->s3->tmp.ctype[i] = p[i];\n    p += p[-1];\n    if (SSL_USE_SIGALGS(s)) {\n        n2s(p, llen);\n        /*\n         * Check we have enough room for signature algorithms and following\n         * length value.\n         */\n        if ((unsigned long)(p - d + llen + 2) > n) {\n            ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\n            SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,\n                   SSL_R_DATA_LENGTH_TOO_LONG);\n            goto err;\n        }\n        /* Clear certificate digests and validity flags */\n        for (i = 0; i < SSL_PKEY_NUM; i++) {\n            s->s3->tmp.md[i] = NULL;\n            s->s3->tmp.valid_flags[i] = 0;\n        }\n        if ((llen & 1) || !tls1_save_sigalgs(s, p, llen)) {\n            ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\n            SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,\n                   SSL_R_SIGNATURE_ALGORITHMS_ERROR);\n            goto err;\n        }\n        if (!tls1_process_sigalgs(s)) {\n            ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);\n            SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n        p += llen;\n    }\n\n    /* get the CA RDNs */\n    n2s(p, llen);\n\n    if ((unsigned long)(p - d + llen) != n) {\n        ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\n        SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST, SSL_R_LENGTH_MISMATCH);\n        goto err;\n    }\n\n    for (nc = 0; nc < llen;) {\n        n2s(p, l);\n        if ((l + nc + 2) > llen) {\n            ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\n            SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST, SSL_R_CA_DN_TOO_LONG);\n            goto err;\n        }\n\n        q = p;\n\n        if ((xn = d2i_X509_NAME(NULL, &q, l)) == NULL) {\n            ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\n            SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST, ERR_R_ASN1_LIB);\n            goto err;\n        }\n\n        if (q != (p + l)) {\n            ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\n            SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,\n                   SSL_R_CA_DN_LENGTH_MISMATCH);\n            goto err;\n        }\n        if (!sk_X509_NAME_push(ca_sk, xn)) {\n            SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n\n        p += l;\n        nc += l + 2;\n    }\n\n    /* we should setup a certificate to return.... */\n    s->s3->tmp.cert_req = 1;\n    s->s3->tmp.ctype_num = ctype_num;\n    sk_X509_NAME_pop_free(s->s3->tmp.ca_names, X509_NAME_free);\n    s->s3->tmp.ca_names = ca_sk;\n    ca_sk = NULL;\n\n    ret = 1;\n    goto done;\n err:\n    s->state = SSL_ST_ERR;\n done:\n    sk_X509_NAME_pop_free(ca_sk, X509_NAME_free);\n    return (ret);\n}",
        "target": 0
    },
    {
        "func": "int ssl3_client_hello(SSL *s)\n{\n    unsigned char *buf;\n    unsigned char *p, *d;\n    int i;\n    unsigned long l;\n    int al = 0;\n#ifndef OPENSSL_NO_COMP\n    int j;\n    SSL_COMP *comp;\n#endif\n\n    buf = (unsigned char *)s->init_buf->data;\n    if (s->state == SSL3_ST_CW_CLNT_HELLO_A) {\n        SSL_SESSION *sess = s->session;\n\n        /* Work out what SSL/TLS/DTLS version to use */\n        if (ssl_set_version(s) == 0)\n            goto err;\n\n        if ((sess == NULL) || (sess->ssl_version != s->version) ||\n            /*\n             * In the case of EAP-FAST, we can have a pre-shared\n             * \"ticket\" without a session ID.\n             */\n            (!sess->session_id_length && !sess->tlsext_tick) ||\n            (sess->not_resumable)) {\n            if (!ssl_get_new_session(s, 0))\n                goto err;\n        }\n        /* else use the pre-loaded session */\n\n        p = s->s3->client_random;\n\n        /*\n         * for DTLS if client_random is initialized, reuse it, we are\n         * required to use same upon reply to HelloVerify\n         */\n        if (SSL_IS_DTLS(s)) {\n            size_t idx;\n            i = 1;\n            for (idx = 0; idx < sizeof(s->s3->client_random); idx++) {\n                if (p[idx]) {\n                    i = 0;\n                    break;\n                }\n            }\n        } else\n            i = 1;\n\n        if (i && ssl_fill_hello_random(s, 0, p,\n                                       sizeof(s->s3->client_random)) <= 0)\n            goto err;\n\n        /* Do the message type and length last */\n        d = p = ssl_handshake_start(s);\n\n        /*-\n         * version indicates the negotiated version: for example from\n         * an SSLv2/v3 compatible client hello). The client_version\n         * field is the maximum version we permit and it is also\n         * used in RSA encrypted premaster secrets. Some servers can\n         * choke if we initially report a higher version then\n         * renegotiate to a lower one in the premaster secret. This\n         * didn't happen with TLS 1.0 as most servers supported it\n         * but it can with TLS 1.1 or later if the server only supports\n         * 1.0.\n         *\n         * Possible scenario with previous logic:\n         *      1. Client hello indicates TLS 1.2\n         *      2. Server hello says TLS 1.0\n         *      3. RSA encrypted premaster secret uses 1.2.\n         *      4. Handhaked proceeds using TLS 1.0.\n         *      5. Server sends hello request to renegotiate.\n         *      6. Client hello indicates TLS v1.0 as we now\n         *         know that is maximum server supports.\n         *      7. Server chokes on RSA encrypted premaster secret\n         *         containing version 1.0.\n         *\n         * For interoperability it should be OK to always use the\n         * maximum version we support in client hello and then rely\n         * on the checking of version to ensure the servers isn't\n         * being inconsistent: for example initially negotiating with\n         * TLS 1.0 and renegotiating with TLS 1.2. We do this by using\n         * client_version in client hello and not resetting it to\n         * the negotiated version.\n         */\n        *(p++) = s->client_version >> 8;\n        *(p++) = s->client_version & 0xff;\n\n        /* Random stuff */\n        memcpy(p, s->s3->client_random, SSL3_RANDOM_SIZE);\n        p += SSL3_RANDOM_SIZE;\n\n        /* Session ID */\n        if (s->new_session)\n            i = 0;\n        else\n            i = s->session->session_id_length;\n        *(p++) = i;\n        if (i != 0) {\n            if (i > (int)sizeof(s->session->session_id)) {\n                SSLerr(SSL_F_SSL3_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);\n                goto err;\n            }\n            memcpy(p, s->session->session_id, i);\n            p += i;\n        }\n\n        /* cookie stuff for DTLS */\n        if (SSL_IS_DTLS(s)) {\n            if (s->d1->cookie_len > sizeof(s->d1->cookie)) {\n                SSLerr(SSL_F_SSL3_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);\n                goto err;\n            }\n            *(p++) = s->d1->cookie_len;\n            memcpy(p, s->d1->cookie, s->d1->cookie_len);\n            p += s->d1->cookie_len;\n        }\n\n        /* Ciphers supported */\n        i = ssl_cipher_list_to_bytes(s, SSL_get_ciphers(s), &(p[2]), 0);\n        if (i == 0) {\n            SSLerr(SSL_F_SSL3_CLIENT_HELLO, SSL_R_NO_CIPHERS_AVAILABLE);\n            goto err;\n        }\n#ifdef OPENSSL_MAX_TLS1_2_CIPHER_LENGTH\n        /*\n         * Some servers hang if client hello > 256 bytes as hack workaround\n         * chop number of supported ciphers to keep it well below this if we\n         * use TLS v1.2\n         */\n        if (TLS1_get_version(s) >= TLS1_2_VERSION\n            && i > OPENSSL_MAX_TLS1_2_CIPHER_LENGTH)\n            i = OPENSSL_MAX_TLS1_2_CIPHER_LENGTH & ~1;\n#endif\n        s2n(i, p);\n        p += i;\n\n        /* COMPRESSION */\n#ifdef OPENSSL_NO_COMP\n        *(p++) = 1;\n#else\n\n        if (!ssl_allow_compression(s) || !s->ctx->comp_methods)\n            j = 0;\n        else\n            j = sk_SSL_COMP_num(s->ctx->comp_methods);\n        *(p++) = 1 + j;\n        for (i = 0; i < j; i++) {\n            comp = sk_SSL_COMP_value(s->ctx->comp_methods, i);\n            *(p++) = comp->id;\n        }\n#endif\n        *(p++) = 0;             /* Add the NULL method */\n\n        /* TLS extensions */\n        if (ssl_prepare_clienthello_tlsext(s) <= 0) {\n            SSLerr(SSL_F_SSL3_CLIENT_HELLO, SSL_R_CLIENTHELLO_TLSEXT);\n            goto err;\n        }\n        if ((p =\n             ssl_add_clienthello_tlsext(s, p, buf + SSL3_RT_MAX_PLAIN_LENGTH,\n                                        &al)) == NULL) {\n            ssl3_send_alert(s, SSL3_AL_FATAL, al);\n            SSLerr(SSL_F_SSL3_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n\n        l = p - d;\n        if (!ssl_set_handshake_header(s, SSL3_MT_CLIENT_HELLO, l)) {\n            ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_HANDSHAKE_FAILURE);\n            SSLerr(SSL_F_SSL3_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n        s->state = SSL3_ST_CW_CLNT_HELLO_B;\n    }\n\n    /* SSL3_ST_CW_CLNT_HELLO_B */\n    return ssl_do_write(s);\n err:\n    s->state = SSL_ST_ERR;\n    return (-1);\n}",
        "target": 0
    },
    {
        "func": "static int bio_zlib_new(BIO *bi)\n\t{\n\tBIO_ZLIB_CTX *ctx;\n#ifdef ZLIB_SHARED\n\t(void)COMP_zlib();\n\tif (!zlib_loaded)\n\t\t{\n\t\tCOMPerr(COMP_F_BIO_ZLIB_NEW, COMP_R_ZLIB_NOT_SUPPORTED);\n\t\treturn 0;\n\t\t}\n#endif\n\tctx = OPENSSL_malloc(sizeof(BIO_ZLIB_CTX));\n\tif(!ctx)\n\t\t{\n\t\tCOMPerr(COMP_F_BIO_ZLIB_NEW, ERR_R_MALLOC_FAILURE);\n\t\treturn 0;\n\t\t}\n\tctx->ibuf = NULL;\n\tctx->obuf = NULL;\n\tctx->ibufsize = ZLIB_DEFAULT_BUFSIZE;\n\tctx->obufsize = ZLIB_DEFAULT_BUFSIZE;\n\tctx->zin.zalloc = Z_NULL;\n\tctx->zin.zfree = Z_NULL;\n\tctx->zin.next_in = NULL;\n\tctx->zin.avail_in = 0;\n\tctx->zin.next_out = NULL;\n\tctx->zin.avail_out = 0;\n\tctx->zout.zalloc = Z_NULL;\n\tctx->zout.zfree = Z_NULL;\n\tctx->zout.next_in = NULL;\n\tctx->zout.avail_in = 0;\n\tctx->zout.next_out = NULL;\n\tctx->zout.avail_out = 0;\n\tctx->odone = 0;\n\tctx->comp_level = Z_DEFAULT_COMPRESSION;\n\tbi->init = 1;\n\tbi->ptr = (char *)ctx;\n\tbi->flags = 0;\n\treturn 1;\n\t}",
        "target": 0
    },
    {
        "func": "static int bio_zlib_write(BIO *b, const char *in, int inl)\n\t{\n\tBIO_ZLIB_CTX *ctx;\n\tint ret;\n\tz_stream *zout;\n\tif(!in || !inl) return 0;\n\tctx = (BIO_ZLIB_CTX *)b->ptr;\n\tif(ctx->odone) return 0;\n\tzout = &ctx->zout;\n\tBIO_clear_retry_flags(b);\n\tif(!ctx->obuf)\n\t\t{\n\t\tctx->obuf = OPENSSL_malloc(ctx->obufsize);\n\t\t/* Need error here */\n\t\tif(!ctx->obuf)\n\t\t\t{\n\t\t\tCOMPerr(COMP_F_BIO_ZLIB_WRITE, ERR_R_MALLOC_FAILURE);\n\t\t\treturn 0;\n\t\t\t}\n\t\tctx->optr = ctx->obuf;\n\t\tctx->ocount = 0;\n\t\tdeflateInit(zout, ctx->comp_level);\n\t\tzout->next_out = ctx->obuf;\n\t\tzout->avail_out = ctx->obufsize;\n\t\t}\n\t/* Obtain input data directly from supplied buffer */\n\tzout->next_in = (void *)in;\n\tzout->avail_in = inl;\n\tfor(;;)\n\t\t{\n\t\t/* If data in output buffer write it first */\n\t\twhile(ctx->ocount) {\n\t\t\tret = BIO_write(b->next_bio, ctx->optr, ctx->ocount);\n\t\t\tif(ret <= 0)\n\t\t\t\t{\n\t\t\t\t/* Total data written */\n\t\t\t\tint tot = inl - zout->avail_in;\n\t\t\t\tBIO_copy_next_retry(b);\n\t\t\t\tif(ret < 0) return (tot > 0) ? tot : ret;\n\t\t\t\treturn tot;\n\t\t\t\t}\n\t\t\tctx->optr += ret;\n\t\t\tctx->ocount -= ret;\n\t\t}\n\n\t\t/* Have we consumed all supplied data? */\n\t\tif(!zout->avail_in)\n\t\t\treturn inl;\n\n\t\t/* Compress some more */\n\n\t\t/* Reset buffer */\n\t\tctx->optr = ctx->obuf;\n\t\tzout->next_out = ctx->obuf;\n\t\tzout->avail_out = ctx->obufsize;\n\t\t/* Compress some more */\n\t\tret = deflate(zout, 0);\n\t\tif(ret != Z_OK)\n\t\t\t{\n\t\t\tCOMPerr(COMP_F_BIO_ZLIB_WRITE,\n\t\t\t\t\t\tCOMP_R_ZLIB_DEFLATE_ERROR);\n\t\t\tERR_add_error_data(2, \"zlib error:\", zError(ret));\n\t\t\treturn 0;\n\t\t\t}\n\t\tctx->ocount = ctx->obufsize - zout->avail_out;\n\t\t}\n\t}",
        "target": 0
    },
    {
        "func": "static int zlib_stateful_init(COMP_CTX *ctx)\n\t{\n\tint err;\n\tstruct zlib_state *state =\n\t\t(struct zlib_state *)OPENSSL_malloc(sizeof(struct zlib_state));\n\n\tif (state == NULL)\n\t\tgoto err;\n\n\tstate->istream.zalloc = zlib_zalloc;\n\tstate->istream.zfree = zlib_zfree;\n\tstate->istream.opaque = Z_NULL;\n\tstate->istream.next_in = Z_NULL;\n\tstate->istream.next_out = Z_NULL;\n\tstate->istream.avail_in = 0;\n\tstate->istream.avail_out = 0;\n\terr = inflateInit_(&state->istream,\n\t\tZLIB_VERSION, sizeof(z_stream));\n\tif (err != Z_OK)\n\t\tgoto err;\n\n\tstate->ostream.zalloc = zlib_zalloc;\n\tstate->ostream.zfree = zlib_zfree;\n\tstate->ostream.opaque = Z_NULL;\n\tstate->ostream.next_in = Z_NULL;\n\tstate->ostream.next_out = Z_NULL;\n\tstate->ostream.avail_in = 0;\n\tstate->ostream.avail_out = 0;\n\terr = deflateInit_(&state->ostream,Z_DEFAULT_COMPRESSION,\n\t\tZLIB_VERSION, sizeof(z_stream));\n\tif (err != Z_OK)\n\t\tgoto err;\n\n\tCRYPTO_new_ex_data(CRYPTO_EX_INDEX_COMP,ctx,&ctx->ex_data);\n\tCRYPTO_set_ex_data(&ctx->ex_data,zlib_stateful_ex_idx,state);\n\treturn 1;\n err:\n\tif (state) OPENSSL_free(state);\n\treturn 0;\n\t}",
        "target": 0
    },
    {
        "func": "static int bio_zlib_flush(BIO *b)\n\t{\n\tBIO_ZLIB_CTX *ctx;\n\tint ret;\n\tz_stream *zout;\n\tctx = (BIO_ZLIB_CTX *)b->ptr;\n\t/* If no data written or already flush show success */\n\tif(!ctx->obuf || (ctx->odone && !ctx->ocount)) return 1;\n\tzout = &ctx->zout;\n\tBIO_clear_retry_flags(b);\n\t/* No more input data */\n\tzout->next_in = NULL;\n\tzout->avail_in = 0;\n\tfor(;;)\n\t\t{\n\t\t/* If data in output buffer write it first */\n\t\twhile(ctx->ocount)\n\t\t\t{\n\t\t\tret = BIO_write(b->next_bio, ctx->optr, ctx->ocount);\n\t\t\tif(ret <= 0)\n\t\t\t\t{\n\t\t\t\tBIO_copy_next_retry(b);\n\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\tctx->optr += ret;\n\t\t\tctx->ocount -= ret;\n\t\t\t}\n\t\tif(ctx->odone) return 1;\n\n\t\t/* Compress some more */\n\n\t\t/* Reset buffer */\n\t\tctx->optr = ctx->obuf;\n\t\tzout->next_out = ctx->obuf;\n\t\tzout->avail_out = ctx->obufsize;\n\t\t/* Compress some more */\n\t\tret = deflate(zout, Z_FINISH);\n\t\tif(ret == Z_STREAM_END) ctx->odone = 1;\n\t\telse if(ret != Z_OK)\n\t\t\t{\n\t\t\tCOMPerr(COMP_F_BIO_ZLIB_FLUSH,\n\t\t\t\t\t\tCOMP_R_ZLIB_DEFLATE_ERROR);\n\t\t\tERR_add_error_data(2, \"zlib error:\", zError(ret));\n\t\t\treturn 0;\n\t\t\t}\n\t\tctx->ocount = ctx->obufsize - zout->avail_out;\n\t\t}\n\t}",
        "target": 0
    },
    {
        "func": "static int zlib_stateful_compress_block(COMP_CTX *ctx, unsigned char *out,\n\tunsigned int olen, unsigned char *in, unsigned int ilen)\n\t{\n\tint err = Z_OK;\n\tstruct zlib_state *state =\n\t\t(struct zlib_state *)CRYPTO_get_ex_data(&ctx->ex_data,\n\t\t\tzlib_stateful_ex_idx);\n\n\tif (state == NULL)\n\t\treturn -1;\n\n\tstate->ostream.next_in = in;\n\tstate->ostream.avail_in = ilen;\n\tstate->ostream.next_out = out;\n\tstate->ostream.avail_out = olen;\n\tif (ilen > 0)\n\t\terr = deflate(&state->ostream, Z_SYNC_FLUSH);\n\tif (err != Z_OK)\n\t\treturn -1;\n#ifdef DEBUG_ZLIB\n\tfprintf(stderr,\"compress(%4d)->%4d %s\\n\",\n\t\tilen,olen - state->ostream.avail_out,\n\t\t(ilen != olen - state->ostream.avail_out)?\"zlib\":\"clear\");\n#endif\n\treturn olen - state->ostream.avail_out;\n\t}",
        "target": 0
    },
    {
        "func": "static void zlib_zfree(void* opaque, void* address)\n{\n\tOPENSSL_free(address);\n}",
        "target": 0
    },
    {
        "func": "static void zlib_stateful_finish(COMP_CTX *ctx)\n\t{\n\tstruct zlib_state *state =\n\t\t(struct zlib_state *)CRYPTO_get_ex_data(&ctx->ex_data,\n\t\t\tzlib_stateful_ex_idx);\n\tinflateEnd(&state->istream);\n\tdeflateEnd(&state->ostream);\n\tOPENSSL_free(state);\n\tCRYPTO_free_ex_data(CRYPTO_EX_INDEX_COMP,ctx,&ctx->ex_data);\n\t}",
        "target": 0
    },
    {
        "func": "static int bio_zlib_free(BIO *bi)\n\t{\n\tBIO_ZLIB_CTX *ctx;\n\tif(!bi) return 0;\n\tctx = (BIO_ZLIB_CTX *)bi->ptr;\n\tif(ctx->ibuf)\n\t\t{\n\t\t/* Destroy decompress context */\n\t\tinflateEnd(&ctx->zin);\n\t\tOPENSSL_free(ctx->ibuf);\n\t\t}\n\tif(ctx->obuf)\n\t\t{\n\t\t/* Destroy compress context */\n\t\tdeflateEnd(&ctx->zout);\n\t\tOPENSSL_free(ctx->obuf);\n\t\t}\n\tOPENSSL_free(ctx);\n\tbi->ptr = NULL;\n\tbi->init = 0;\n\tbi->flags = 0;\n\treturn 1;\n\t}",
        "target": 0
    },
    {
        "func": "static long bio_zlib_ctrl(BIO *b, int cmd, long num, void *ptr)\n\t{\n\tBIO_ZLIB_CTX *ctx;\n\tint ret, *ip;\n\tint ibs, obs;\n\tif(!b->next_bio) return 0;\n\tctx = (BIO_ZLIB_CTX *)b->ptr;\n\tswitch (cmd)\n\t\t{\n\n\tcase BIO_CTRL_RESET:\n\t\tctx->ocount = 0;\n\t\tctx->odone = 0;\n\t\tret = 1;\n\t\tbreak;\n\n\tcase BIO_CTRL_FLUSH:\n\t\tret = bio_zlib_flush(b);\n\t\tif (ret > 0)\n\t\t\tret = BIO_flush(b->next_bio);\n\t\tbreak;\n\n\tcase BIO_C_SET_BUFF_SIZE:\n\t\tibs = -1;\n\t\tobs = -1;\n\t\tif (ptr != NULL)\n\t\t\t{\n\t\t\tip = ptr;\n\t\t\tif (*ip == 0)\n\t\t\t\tibs = (int) num;\n\t\t\telse \n\t\t\t\tobs = (int) num;\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tibs = (int)num;\n\t\t\tobs = ibs;\n\t\t\t}\n\n\t\tif (ibs != -1)\n\t\t\t{\n\t\t\tif (ctx->ibuf)\n\t\t\t\t{\n\t\t\t\tOPENSSL_free(ctx->ibuf);\n\t\t\t\tctx->ibuf = NULL;\n\t\t\t\t}\n\t\t\tctx->ibufsize = ibs;\n\t\t\t}\n\n\t\tif (obs != -1)\n\t\t\t{\n\t\t\tif (ctx->obuf)\n\t\t\t\t{\n\t\t\t\tOPENSSL_free(ctx->obuf);\n\t\t\t\tctx->obuf = NULL;\n\t\t\t\t}\n\t\t\tctx->obufsize = obs;\n\t\t\t}\n\t\tret = 1;\n\t\tbreak;\n\n\tcase BIO_C_DO_STATE_MACHINE:\n\t\tBIO_clear_retry_flags(b);\n\t\tret = BIO_ctrl(b->next_bio, cmd, num, ptr);\n\t\tBIO_copy_next_retry(b);\n\t\tbreak;\n\n\tdefault:\n\t\tret = BIO_ctrl(b->next_bio, cmd, num, ptr);\n\t\tbreak;\n\n\t\t}\n\n\treturn ret;\n\t}",
        "target": 0
    },
    {
        "func": "static int zlib_stateful_expand_block(COMP_CTX *ctx, unsigned char *out,\n\tunsigned int olen, unsigned char *in, unsigned int ilen)\n\t{\n\tint err = Z_OK;\n\n\tstruct zlib_state *state =\n\t\t(struct zlib_state *)CRYPTO_get_ex_data(&ctx->ex_data,\n\t\t\tzlib_stateful_ex_idx);\n\n\tif (state == NULL)\n\t\treturn 0;\n\n\tstate->istream.next_in = in;\n\tstate->istream.avail_in = ilen;\n\tstate->istream.next_out = out;\n\tstate->istream.avail_out = olen;\n\tif (ilen > 0)\n\t\terr = inflate(&state->istream, Z_SYNC_FLUSH);\n\tif (err != Z_OK)\n\t\treturn -1;\n#ifdef DEBUG_ZLIB\n\tfprintf(stderr,\"expand(%4d)->%4d %s\\n\",\n\t\tilen,olen - state->istream.avail_out,\n\t\t(ilen != olen - state->istream.avail_out)?\"zlib\":\"clear\");\n#endif\n\treturn olen - state->istream.avail_out;\n\t}",
        "target": 0
    },
    {
        "func": "static int bio_zlib_read(BIO *b, char *out, int outl)\n\t{\n\tBIO_ZLIB_CTX *ctx;\n\tint ret;\n\tz_stream *zin;\n\tif(!out || !outl) return 0;\n\tctx = (BIO_ZLIB_CTX *)b->ptr;\n\tzin = &ctx->zin;\n\tBIO_clear_retry_flags(b);\n\tif(!ctx->ibuf)\n\t\t{\n\t\tctx->ibuf = OPENSSL_malloc(ctx->ibufsize);\n\t\tif(!ctx->ibuf)\n\t\t\t{\n\t\t\tCOMPerr(COMP_F_BIO_ZLIB_READ, ERR_R_MALLOC_FAILURE);\n\t\t\treturn 0;\n\t\t\t}\n\t\tinflateInit(zin);\n\t\tzin->next_in = ctx->ibuf;\n\t\tzin->avail_in = 0;\n\t\t}\n\n\t/* Copy output data directly to supplied buffer */\n\tzin->next_out = (unsigned char *)out;\n\tzin->avail_out = (unsigned int)outl;\n\tfor(;;)\n\t\t{\n\t\t/* Decompress while data available */\n\t\twhile(zin->avail_in)\n\t\t\t{\n\t\t\tret = inflate(zin, 0);\n\t\t\tif((ret != Z_OK) && (ret != Z_STREAM_END))\n\t\t\t\t{\n\t\t\t\tCOMPerr(COMP_F_BIO_ZLIB_READ,\n\t\t\t\t\t\tCOMP_R_ZLIB_INFLATE_ERROR);\n\t\t\t\tERR_add_error_data(2, \"zlib error:\",\n\t\t\t\t\t\t\tzError(ret));\n\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t/* If EOF or we've read everything then return */\n\t\t\tif((ret == Z_STREAM_END) || !zin->avail_out)\n\t\t\t\treturn outl - zin->avail_out;\n\t\t\t}\n\n\t\t/* No data in input buffer try to read some in,\n\t\t * if an error then return the total data read.\n\t\t */\n\t\tret = BIO_read(b->next_bio, ctx->ibuf, ctx->ibufsize);\n\t\tif(ret <= 0)\n\t\t\t{\n\t\t\t/* Total data read */\n\t\t\tint tot = outl - zin->avail_out;\n\t\t\tBIO_copy_next_retry(b);\n\t\t\tif(ret < 0) return (tot > 0) ? tot : ret;\n\t\t\treturn tot;\n\t\t\t}\n\t\tzin->avail_in = ret;\n\t\tzin->next_in = ctx->ibuf;\n\t\t}\n\t}",
        "target": 0
    },
    {
        "func": "static int zz_uncompress (Bytef *dest, uLongf *destLen, const Bytef *source,\n\t     uLong sourceLen)\n{\n    z_stream stream;\n    int err;\n\n    stream.next_in = (Bytef*)source;\n    stream.avail_in = (uInt)sourceLen;\n    /* Check for source > 64K on 16-bit machine: */\n    if ((uLong)stream.avail_in != sourceLen) return Z_BUF_ERROR;\n\n    stream.next_out = dest;\n    stream.avail_out = (uInt)*destLen;\n    if ((uLong)stream.avail_out != *destLen) return Z_BUF_ERROR;\n\n    stream.zalloc = (alloc_func)0;\n    stream.zfree = (free_func)0;\n\n    err = inflateInit_(&stream,\n\t    ZLIB_VERSION, sizeof(z_stream));\n    if (err != Z_OK) return err;\n\n    err = inflate(&stream, Z_FINISH);\n    if (err != Z_STREAM_END) {\n        inflateEnd(&stream);\n        return err;\n    }\n    *destLen = stream.total_out;\n\n    err = inflateEnd(&stream);\n    return err;\n}",
        "target": 0
    },
    {
        "func": "static void* zlib_zalloc(void* opaque, unsigned int no, unsigned int size)\n{\n\tvoid *p;\n\t\n\tp=OPENSSL_malloc(no*size);\n\tif (p)\n\t\tmemset(p, 0, no*size);\n\treturn p;\n}",
        "target": 0
    },
    {
        "func": "void COMP_zlib_cleanup(void)\n\t{\n#ifdef ZLIB_SHARED\n\tif (zlib_dso)\n\t\tDSO_free(zlib_dso);\n#endif\n\t}",
        "target": 0
    },
    {
        "func": "static long bio_zlib_callback_ctrl(BIO *b, int cmd, bio_info_cb *fp)\n\t{\n\tif(!b->next_bio)\n\t\treturn 0;\n\treturn\n\t\tBIO_callback_ctrl(b->next_bio, cmd, fp);\n\t}",
        "target": 0
    },
    {
        "func": "BIO_METHOD *BIO_f_zlib(void)\n\t{\n\treturn &bio_meth_zlib;\n\t}",
        "target": 0
    },
    {
        "func": "COMP_METHOD *COMP_zlib(void)\n\t{\n\tCOMP_METHOD *meth = &zlib_method_nozlib;\n\n#ifdef ZLIB_SHARED\n\tif (!zlib_loaded)\n\t\t{\n#if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_WIN32)\n\t\tzlib_dso = DSO_load(NULL, \"ZLIB1\", NULL, 0);\n#else\n\t\tzlib_dso = DSO_load(NULL, \"z\", NULL, 0);\n#endif\n\t\tif (zlib_dso != NULL)\n\t\t\t{\n\t\t\tp_compress\n\t\t\t\t= (compress_ft) DSO_bind_func(zlib_dso,\n\t\t\t\t\t\"compress\");\n\t\t\tp_inflateEnd\n\t\t\t\t= (inflateEnd_ft) DSO_bind_func(zlib_dso,\n\t\t\t\t\t\"inflateEnd\");\n\t\t\tp_inflate\n\t\t\t\t= (inflate_ft) DSO_bind_func(zlib_dso,\n\t\t\t\t\t\"inflate\");\n\t\t\tp_inflateInit_\n\t\t\t\t= (inflateInit__ft) DSO_bind_func(zlib_dso,\n\t\t\t\t\t\"inflateInit_\");\n\t\t\tp_deflateEnd\n\t\t\t\t= (deflateEnd_ft) DSO_bind_func(zlib_dso,\n\t\t\t\t\t\"deflateEnd\");\n\t\t\tp_deflate\n\t\t\t\t= (deflate_ft) DSO_bind_func(zlib_dso,\n\t\t\t\t\t\"deflate\");\n\t\t\tp_deflateInit_\n\t\t\t\t= (deflateInit__ft) DSO_bind_func(zlib_dso,\n\t\t\t\t\t\"deflateInit_\");\n\t\t\tp_zError\n\t\t\t\t= (zError__ft) DSO_bind_func(zlib_dso,\n\t\t\t\t\t\"zError\");\n\n\t\t\tif (p_compress && p_inflateEnd && p_inflate\n\t\t\t\t&& p_inflateInit_ && p_deflateEnd\n\t\t\t\t&& p_deflate && p_deflateInit_ && p_zError)\n\t\t\t\tzlib_loaded++;\n\t\t\t}\n\t\t}\n\n#endif\n#ifdef ZLIB_SHARED\n\tif (zlib_loaded)\n#endif\n#if defined(ZLIB) || defined(ZLIB_SHARED)\n\t\t{\n\t\t/* init zlib_stateful_ex_idx here so that in a multi-process\n\t\t * application it's enough to intialize openssl before forking\n\t\t * (idx will be inherited in all the children) */\n\t\tif (zlib_stateful_ex_idx == -1)\n\t\t\t{\n\t\t\tCRYPTO_w_lock(CRYPTO_LOCK_COMP);\n\t\t\tif (zlib_stateful_ex_idx == -1)\n\t\t\t\tzlib_stateful_ex_idx =\n\t\t\t\t\tCRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_COMP,\n\t\t\t\t\t\t0,NULL,NULL,NULL,NULL);\n\t\t\tCRYPTO_w_unlock(CRYPTO_LOCK_COMP);\n\t\t\tif (zlib_stateful_ex_idx == -1)\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\n\t\tmeth = &zlib_stateful_method;\n\t\t}\nerr:\t\n#endif\n\n\treturn(meth);\n\t}",
        "target": 0
    },
    {
        "func": "static int zlib_compress_block(COMP_CTX *ctx, unsigned char *out,\n\tunsigned int olen, unsigned char *in, unsigned int ilen)\n\t{\n\tunsigned long l;\n\tint i;\n\tint clear=1;\n\n\tif (ilen > 128)\n\t\t{\n\t\tout[0]=1;\n\t\tl=olen-1;\n\t\ti=compress(&(out[1]),&l,in,(unsigned long)ilen);\n\t\tif (i != Z_OK)\n\t\t\treturn(-1);\n\t\tif (ilen > l)\n\t\t\t{\n\t\t\tclear=0;\n\t\t\tl++;\n\t\t\t}\n\t\t}\n\tif (clear)\n\t\t{\n\t\tout[0]=0;\n\t\tmemcpy(&(out[1]),in,ilen);\n\t\tl=ilen+1;\n\t\t}\n#ifdef DEBUG_ZLIB\n\tfprintf(stderr,\"compress(%4d)->%4d %s\\n\",\n\t\tilen,(int)l,(clear)?\"clear\":\"zlib\");\n#endif\n\treturn((int)l);\n\t}",
        "target": 0
    },
    {
        "func": "static int zlib_expand_block(COMP_CTX *ctx, unsigned char *out,\n\tunsigned int olen, unsigned char *in, unsigned int ilen)\n\t{\n\tunsigned long l;\n\tint i;\n\n\tif (in[0])\n\t\t{\n\t\tl=olen;\n\t\ti=zz_uncompress(out,&l,&(in[1]),(unsigned long)ilen-1);\n\t\tif (i != Z_OK)\n\t\t\treturn(-1);\n\t\t}\n\telse\n\t\t{\n\t\tmemcpy(out,&(in[1]),ilen-1);\n\t\tl=ilen-1;\n\t\t}\n#ifdef DEBUG_ZLIB\n        fprintf(stderr,\"expand  (%4d)->%4d %s\\n\",\n\t\tilen,(int)l,in[0]?\"zlib\":\"clear\");\n#endif\n\treturn((int)l);\n\t}",
        "target": 0
    },
    {
        "func": "void bn_init(BIGNUM *a)\n{\n    static BIGNUM nilbn;\n\n    *a = nilbn;\n    bn_check_top(a);\n}",
        "target": 0
    },
    {
        "func": "BIGNUM *BN_new(void)\n{\n    BIGNUM *ret;\n\n    if ((ret = OPENSSL_zalloc(sizeof(*ret))) == NULL) {\n        BNerr(BN_F_BN_NEW, ERR_R_MALLOC_FAILURE);\n        return (NULL);\n    }\n    ret->flags = BN_FLG_MALLOCED;\n    bn_check_top(ret);\n    return (ret);\n}",
        "target": 0
    },
    {
        "func": "int BN_is_negative(const BIGNUM *a)\n{\n    return (a->neg != 0);\n}",
        "target": 0
    },
    {
        "func": "BIGNUM *BN_lebin2bn(const unsigned char *s, int len, BIGNUM *ret)\n{\n    unsigned int i, m;\n    unsigned int n;\n    BN_ULONG l;\n    BIGNUM *bn = NULL;\n\n    if (ret == NULL)\n        ret = bn = BN_new();\n    if (ret == NULL)\n        return (NULL);\n    bn_check_top(ret);\n    s += len;\n    /* Skip trailing zeroes. */\n    for ( ; len > 0 && s[-1] == 0; s--, len--)\n        continue;\n    n = len;\n    if (n == 0) {\n        ret->top = 0;\n        return ret;\n    }\n    i = ((n - 1) / BN_BYTES) + 1;\n    m = ((n - 1) % (BN_BYTES));\n    if (bn_wexpand(ret, (int)i) == NULL) {\n        BN_free(bn);\n        return NULL;\n    }\n    ret->top = i;\n    ret->neg = 0;\n    l = 0;\n    while (n--) {\n        s--;\n        l = (l << 8L) | *s;\n        if (m-- == 0) {\n            ret->d[--i] = l;\n            l = 0;\n            m = BN_BYTES - 1;\n        }\n    }\n    /*\n     * need to call this due to clear byte at top if avoiding having the top\n     * bit set (-ve number)\n     */\n    bn_correct_top(ret);\n    return ret;\n}",
        "target": 0
    },
    {
        "func": "int BN_bn2lebinpad(const BIGNUM *a, unsigned char *to, int tolen)\n{\n    int i;\n    BN_ULONG l;\n    bn_check_top(a);\n    i = BN_num_bytes(a);\n    if (tolen < i)\n        return -1;\n    /* Add trailing zeroes if necessary */\n    if (tolen > i)\n        memset(to + i, 0, tolen - i);\n    to += i;\n    while (i--) {\n        l = a->d[i / BN_BYTES];\n        to--;\n        *to = (unsigned char)(l >> (8 * (i % BN_BYTES))) & 0xff;\n    }\n    return tolen;\n}",
        "target": 0
    },
    {
        "func": "BIGNUM *bn_expand2(BIGNUM *b, int words)\n{\n    bn_check_top(b);\n\n    if (words > b->dmax) {\n        BN_ULONG *a = bn_expand_internal(b, words);\n        if (!a)\n            return NULL;\n        if (b->d) {\n            OPENSSL_cleanse(b->d, b->dmax * sizeof(b->d[0]));\n            bn_free_d(b);\n        }\n        b->d = a;\n        b->dmax = words;\n    }\n\n    bn_check_top(b);\n    return b;\n}",
        "target": 0
    },
    {
        "func": "int BN_security_bits(int L, int N)\n{\n    int secbits, bits;\n    if (L >= 15360)\n        secbits = 256;\n    else if (L >= 7680)\n        secbits = 192;\n    else if (L >= 3072)\n        secbits = 128;\n    else if (L >= 2048)\n        secbits = 112;\n    else if (L >= 1024)\n        secbits = 80;\n    else\n        return 0;\n    if (N == -1)\n        return secbits;\n    bits = N / 2;\n    if (bits < 80)\n        return 0;\n    return bits >= secbits ? secbits : bits;\n}",
        "target": 0
    },
    {
        "func": "void BN_consttime_swap(BN_ULONG condition, BIGNUM *a, BIGNUM *b, int nwords)\n{\n    BN_ULONG t;\n    int i;\n\n    bn_wcheck_size(a, nwords);\n    bn_wcheck_size(b, nwords);\n\n    assert(a != b);\n    assert((condition & (condition - 1)) == 0);\n    assert(sizeof(BN_ULONG) >= sizeof(int));\n\n    condition = ((condition - 1) >> (BN_BITS2 - 1)) - 1;\n\n    t = (a->top ^ b->top) & condition;\n    a->top ^= t;\n    b->top ^= t;\n\n    t = (a->neg ^ b->neg) & condition;\n    a->neg ^= t;\n    b->neg ^= t;\n\n    /*\n     * cannot just arbitrarily swap flags.\n     * The way a->d is allocated etc.\n     * BN_FLG_MALLOCED, BN_FLG_STATIC_DATA, ...\n     */\n    t = (a->flags ^ b->flags) & condition & BN_FLG_CONSTTIME;\n    a->flags ^= t;\n    b->flags ^= t;\n\n#define BN_CONSTTIME_SWAP(ind) \\\n        do { \\\n                t = (a->d[ind] ^ b->d[ind]) & condition; \\\n                a->d[ind] ^= t; \\\n                b->d[ind] ^= t; \\\n        } while (0)\n\n    switch (nwords) {\n    default:\n        for (i = 10; i < nwords; i++)\n            BN_CONSTTIME_SWAP(i);\n        /* Fallthrough */\n    case 10:\n        BN_CONSTTIME_SWAP(9);   /* Fallthrough */\n    case 9:\n        BN_CONSTTIME_SWAP(8);   /* Fallthrough */\n    case 8:\n        BN_CONSTTIME_SWAP(7);   /* Fallthrough */\n    case 7:\n        BN_CONSTTIME_SWAP(6);   /* Fallthrough */\n    case 6:\n        BN_CONSTTIME_SWAP(5);   /* Fallthrough */\n    case 5:\n        BN_CONSTTIME_SWAP(4);   /* Fallthrough */\n    case 4:\n        BN_CONSTTIME_SWAP(3);   /* Fallthrough */\n    case 3:\n        BN_CONSTTIME_SWAP(2);   /* Fallthrough */\n    case 2:\n        BN_CONSTTIME_SWAP(1);   /* Fallthrough */\n    case 1:\n        BN_CONSTTIME_SWAP(0);\n    }\n#undef BN_CONSTTIME_SWAP\n}",
        "target": 0
    },
    {
        "func": "BIGNUM *BN_copy(BIGNUM *a, const BIGNUM *b)\n{\n    int i;\n    BN_ULONG *A;\n    const BN_ULONG *B;\n\n    bn_check_top(b);\n\n    if (a == b)\n        return (a);\n    if (bn_wexpand(a, b->top) == NULL)\n        return (NULL);\n\n#if 1\n    A = a->d;\n    B = b->d;\n    for (i = b->top >> 2; i > 0; i--, A += 4, B += 4) {\n        BN_ULONG a0, a1, a2, a3;\n        a0 = B[0];\n        a1 = B[1];\n        a2 = B[2];\n        a3 = B[3];\n        A[0] = a0;\n        A[1] = a1;\n        A[2] = a2;\n        A[3] = a3;\n    }\n    /* ultrix cc workaround, see comments in bn_expand_internal */\n    switch (b->top & 3) {\n    case 3:\n        A[2] = B[2];\n        /* fall thru */\n    case 2:\n        A[1] = B[1];\n        /* fall thru */\n    case 1:\n        A[0] = B[0];\n        /* fall thru */\n    case 0:;\n    }\n#else\n    memcpy(a->d, b->d, sizeof(b->d[0]) * b->top);\n#endif\n\n    a->top = b->top;\n    a->neg = b->neg;\n    bn_check_top(a);\n    return (a);\n}",
        "target": 0
    },
    {
        "func": "void BN_clear(BIGNUM *a)\n{\n    bn_check_top(a);\n    if (a->d != NULL)\n        OPENSSL_cleanse(a->d, sizeof(*a->d) * a->dmax);\n    a->top = 0;\n    a->neg = 0;\n}",
        "target": 0
    },
    {
        "func": "BIGNUM *BN_bin2bn(const unsigned char *s, int len, BIGNUM *ret)\n{\n    unsigned int i, m;\n    unsigned int n;\n    BN_ULONG l;\n    BIGNUM *bn = NULL;\n\n    if (ret == NULL)\n        ret = bn = BN_new();\n    if (ret == NULL)\n        return (NULL);\n    bn_check_top(ret);\n    /* Skip leading zero's. */\n    for ( ; len > 0 && *s == 0; s++, len--)\n        continue;\n    n = len;\n    if (n == 0) {\n        ret->top = 0;\n        return (ret);\n    }\n    i = ((n - 1) / BN_BYTES) + 1;\n    m = ((n - 1) % (BN_BYTES));\n    if (bn_wexpand(ret, (int)i) == NULL) {\n        BN_free(bn);\n        return NULL;\n    }\n    ret->top = i;\n    ret->neg = 0;\n    l = 0;\n    while (n--) {\n        l = (l << 8L) | *(s++);\n        if (m-- == 0) {\n            ret->d[--i] = l;\n            l = 0;\n            m = BN_BYTES - 1;\n        }\n    }\n    /*\n     * need to call this due to clear byte at top if avoiding having the top\n     * bit set (-ve number)\n     */\n    bn_correct_top(ret);\n    return (ret);\n}",
        "target": 0
    },
    {
        "func": "int BN_is_word(const BIGNUM *a, const BN_ULONG w)\n{\n    return BN_abs_is_word(a, w) && (!w || !a->neg);\n}",
        "target": 0
    },
    {
        "func": "void BN_with_flags(BIGNUM *dest, const BIGNUM *b, int flags)\n{\n    dest->d = b->d;\n    dest->top = b->top;\n    dest->dmax = b->dmax;\n    dest->neg = b->neg;\n    dest->flags = ((dest->flags & BN_FLG_MALLOCED)\n                   | (b->flags & ~BN_FLG_MALLOCED)\n                   | BN_FLG_STATIC_DATA | flags);\n}",
        "target": 0
    },
    {
        "func": "int BN_set_word(BIGNUM *a, BN_ULONG w)\n{\n    bn_check_top(a);\n    if (bn_expand(a, (int)sizeof(BN_ULONG) * 8) == NULL)\n        return (0);\n    a->neg = 0;\n    a->d[0] = w;\n    a->top = (w ? 1 : 0);\n    bn_check_top(a);\n    return (1);\n}",
        "target": 0
    },
    {
        "func": "int ec_wNAF_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *scalar,\n                size_t num, const EC_POINT *points[], const BIGNUM *scalars[],\n                BN_CTX *ctx)\n{\n    if ((scalar != NULL) && (num == 0)) {\n        /* In this case we want to compute scalar * GeneratorPoint:\n         * this codepath is reached most prominently by (ephemeral) key\n         * generation of EC cryptosystems (i.e. ECDSA keygen and sign setup,\n         * ECDH keygen/first half), where the scalar is always secret.\n         * This is why we ignore if BN_FLG_CONSTTIME is actually set and we\n         * always call the constant time version.\n         */\n        return ec_mul_consttime(group, r, scalar, NULL, ctx);\n    }\n\n    if ((scalar == NULL) && (num == 1)) {\n        /* In this case we want to compute scalar * GenericPoint:\n         * this codepath is reached most prominently by the second half of\n         * ECDH, where the secret scalar is multiplied by the peer's public\n         * point.\n         * To protect the secret scalar, we ignore if BN_FLG_CONSTTIME is\n         * actually set and we always call the constant time version.\n         */\n        return ec_mul_consttime(group, r, scalars[0], points[0], ctx);\n    }\n\n    BN_CTX *new_ctx = NULL;\n    const EC_POINT *generator = NULL;\n    EC_POINT *tmp = NULL;\n    size_t totalnum;\n    size_t blocksize = 0, numblocks = 0; /* for wNAF splitting */\n    size_t pre_points_per_block = 0;\n    size_t i, j;\n    int k;\n    int r_is_inverted = 0;\n    int r_is_at_infinity = 1;\n    size_t *wsize = NULL;       /* individual window sizes */\n    signed char **wNAF = NULL;  /* individual wNAFs */\n    size_t *wNAF_len = NULL;\n    size_t max_len = 0;\n    size_t num_val;\n    EC_POINT **val = NULL;      /* precomputation */\n    EC_POINT **v;\n    EC_POINT ***val_sub = NULL; /* pointers to sub-arrays of 'val' or\n                                 * 'pre_comp->points' */\n    const EC_PRE_COMP *pre_comp = NULL;\n    int num_scalar = 0;         /* flag: will be set to 1 if 'scalar' must be\n                                 * treated like other scalars, i.e.\n                                 * precomputation is not available */\n    int ret = 0;\n\n    if (group->meth != r->meth) {\n        ECerr(EC_F_EC_WNAF_MUL, EC_R_INCOMPATIBLE_OBJECTS);\n        return 0;\n    }\n\n    if ((scalar == NULL) && (num == 0)) {\n        return EC_POINT_set_to_infinity(group, r);\n    }\n\n    for (i = 0; i < num; i++) {\n        if (group->meth != points[i]->meth) {\n            ECerr(EC_F_EC_WNAF_MUL, EC_R_INCOMPATIBLE_OBJECTS);\n            return 0;\n        }\n    }\n\n    if (ctx == NULL) {\n        ctx = new_ctx = BN_CTX_new();\n        if (ctx == NULL)\n            goto err;\n    }\n\n    if (scalar != NULL) {\n        generator = EC_GROUP_get0_generator(group);\n        if (generator == NULL) {\n            ECerr(EC_F_EC_WNAF_MUL, EC_R_UNDEFINED_GENERATOR);\n            goto err;\n        }\n\n        /* look if we can use precomputed multiples of generator */\n\n        pre_comp = group->pre_comp.ec;\n        if (pre_comp && pre_comp->numblocks\n            && (EC_POINT_cmp(group, generator, pre_comp->points[0], ctx) ==\n                0)) {\n            blocksize = pre_comp->blocksize;\n\n            /*\n             * determine maximum number of blocks that wNAF splitting may\n             * yield (NB: maximum wNAF length is bit length plus one)\n             */\n            numblocks = (BN_num_bits(scalar) / blocksize) + 1;\n\n            /*\n             * we cannot use more blocks than we have precomputation for\n             */\n            if (numblocks > pre_comp->numblocks)\n                numblocks = pre_comp->numblocks;\n\n            pre_points_per_block = (size_t)1 << (pre_comp->w - 1);\n\n            /* check that pre_comp looks sane */\n            if (pre_comp->num != (pre_comp->numblocks * pre_points_per_block)) {\n                ECerr(EC_F_EC_WNAF_MUL, ERR_R_INTERNAL_ERROR);\n                goto err;\n            }\n        } else {\n            /* can't use precomputation */\n            pre_comp = NULL;\n            numblocks = 1;\n            num_scalar = 1;     /* treat 'scalar' like 'num'-th element of\n                                 * 'scalars' */\n        }\n    }\n\n    totalnum = num + numblocks;\n\n    wsize = OPENSSL_malloc(totalnum * sizeof(wsize[0]));\n    wNAF_len = OPENSSL_malloc(totalnum * sizeof(wNAF_len[0]));\n    /* include space for pivot */\n    wNAF = OPENSSL_malloc((totalnum + 1) * sizeof(wNAF[0]));\n    val_sub = OPENSSL_malloc(totalnum * sizeof(val_sub[0]));\n\n    /* Ensure wNAF is initialised in case we end up going to err */\n    if (wNAF != NULL)\n        wNAF[0] = NULL;         /* preliminary pivot */\n\n    if (wsize == NULL || wNAF_len == NULL || wNAF == NULL || val_sub == NULL) {\n        ECerr(EC_F_EC_WNAF_MUL, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    /*\n     * num_val will be the total number of temporarily precomputed points\n     */\n    num_val = 0;\n\n    for (i = 0; i < num + num_scalar; i++) {\n        size_t bits;\n\n        bits = i < num ? BN_num_bits(scalars[i]) : BN_num_bits(scalar);\n        wsize[i] = EC_window_bits_for_scalar_size(bits);\n        num_val += (size_t)1 << (wsize[i] - 1);\n        wNAF[i + 1] = NULL;     /* make sure we always have a pivot */\n        wNAF[i] =\n            bn_compute_wNAF((i < num ? scalars[i] : scalar), wsize[i],\n                            &wNAF_len[i]);\n        if (wNAF[i] == NULL)\n            goto err;\n        if (wNAF_len[i] > max_len)\n            max_len = wNAF_len[i];\n    }\n\n    if (numblocks) {\n        /* we go here iff scalar != NULL */\n\n        if (pre_comp == NULL) {\n            if (num_scalar != 1) {\n                ECerr(EC_F_EC_WNAF_MUL, ERR_R_INTERNAL_ERROR);\n                goto err;\n            }\n            /* we have already generated a wNAF for 'scalar' */\n        } else {\n            signed char *tmp_wNAF = NULL;\n            size_t tmp_len = 0;\n\n            if (num_scalar != 0) {\n                ECerr(EC_F_EC_WNAF_MUL, ERR_R_INTERNAL_ERROR);\n                goto err;\n            }\n\n            /*\n             * use the window size for which we have precomputation\n             */\n            wsize[num] = pre_comp->w;\n            tmp_wNAF = bn_compute_wNAF(scalar, wsize[num], &tmp_len);\n            if (!tmp_wNAF)\n                goto err;\n\n            if (tmp_len <= max_len) {\n                /*\n                 * One of the other wNAFs is at least as long as the wNAF\n                 * belonging to the generator, so wNAF splitting will not buy\n                 * us anything.\n                 */\n\n                numblocks = 1;\n                totalnum = num + 1; /* don't use wNAF splitting */\n                wNAF[num] = tmp_wNAF;\n                wNAF[num + 1] = NULL;\n                wNAF_len[num] = tmp_len;\n                /*\n                 * pre_comp->points starts with the points that we need here:\n                 */\n                val_sub[num] = pre_comp->points;\n            } else {\n                /*\n                 * don't include tmp_wNAF directly into wNAF array - use wNAF\n                 * splitting and include the blocks\n                 */\n\n                signed char *pp;\n                EC_POINT **tmp_points;\n\n                if (tmp_len < numblocks * blocksize) {\n                    /*\n                     * possibly we can do with fewer blocks than estimated\n                     */\n                    numblocks = (tmp_len + blocksize - 1) / blocksize;\n                    if (numblocks > pre_comp->numblocks) {\n                        ECerr(EC_F_EC_WNAF_MUL, ERR_R_INTERNAL_ERROR);\n                        OPENSSL_free(tmp_wNAF);\n                        goto err;\n                    }\n                    totalnum = num + numblocks;\n                }\n\n                /* split wNAF in 'numblocks' parts */\n                pp = tmp_wNAF;\n                tmp_points = pre_comp->points;\n\n                for (i = num; i < totalnum; i++) {\n                    if (i < totalnum - 1) {\n                        wNAF_len[i] = blocksize;\n                        if (tmp_len < blocksize) {\n                            ECerr(EC_F_EC_WNAF_MUL, ERR_R_INTERNAL_ERROR);\n                            OPENSSL_free(tmp_wNAF);\n                            goto err;\n                        }\n                        tmp_len -= blocksize;\n                    } else\n                        /*\n                         * last block gets whatever is left (this could be\n                         * more or less than 'blocksize'!)\n                         */\n                        wNAF_len[i] = tmp_len;\n\n                    wNAF[i + 1] = NULL;\n                    wNAF[i] = OPENSSL_malloc(wNAF_len[i]);\n                    if (wNAF[i] == NULL) {\n                        ECerr(EC_F_EC_WNAF_MUL, ERR_R_MALLOC_FAILURE);\n                        OPENSSL_free(tmp_wNAF);\n                        goto err;\n                    }\n                    memcpy(wNAF[i], pp, wNAF_len[i]);\n                    if (wNAF_len[i] > max_len)\n                        max_len = wNAF_len[i];\n\n                    if (*tmp_points == NULL) {\n                        ECerr(EC_F_EC_WNAF_MUL, ERR_R_INTERNAL_ERROR);\n                        OPENSSL_free(tmp_wNAF);\n                        goto err;\n                    }\n                    val_sub[i] = tmp_points;\n                    tmp_points += pre_points_per_block;\n                    pp += blocksize;\n                }\n                OPENSSL_free(tmp_wNAF);\n            }\n        }\n    }\n\n    /*\n     * All points we precompute now go into a single array 'val'.\n     * 'val_sub[i]' is a pointer to the subarray for the i-th point, or to a\n     * subarray of 'pre_comp->points' if we already have precomputation.\n     */\n    val = OPENSSL_malloc((num_val + 1) * sizeof(val[0]));\n    if (val == NULL) {\n        ECerr(EC_F_EC_WNAF_MUL, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n    val[num_val] = NULL;        /* pivot element */\n\n    /* allocate points for precomputation */\n    v = val;\n    for (i = 0; i < num + num_scalar; i++) {\n        val_sub[i] = v;\n        for (j = 0; j < ((size_t)1 << (wsize[i] - 1)); j++) {\n            *v = EC_POINT_new(group);\n            if (*v == NULL)\n                goto err;\n            v++;\n        }\n    }\n    if (!(v == val + num_val)) {\n        ECerr(EC_F_EC_WNAF_MUL, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    if ((tmp = EC_POINT_new(group)) == NULL)\n        goto err;\n\n    /*-\n     * prepare precomputed values:\n     *    val_sub[i][0] :=     points[i]\n     *    val_sub[i][1] := 3 * points[i]\n     *    val_sub[i][2] := 5 * points[i]\n     *    ...\n     */\n    for (i = 0; i < num + num_scalar; i++) {\n        if (i < num) {\n            if (!EC_POINT_copy(val_sub[i][0], points[i]))\n                goto err;\n        } else {\n            if (!EC_POINT_copy(val_sub[i][0], generator))\n                goto err;\n        }\n\n        if (wsize[i] > 1) {\n            if (!EC_POINT_dbl(group, tmp, val_sub[i][0], ctx))\n                goto err;\n            for (j = 1; j < ((size_t)1 << (wsize[i] - 1)); j++) {\n                if (!EC_POINT_add\n                    (group, val_sub[i][j], val_sub[i][j - 1], tmp, ctx))\n                    goto err;\n            }\n        }\n    }\n\n    if (!EC_POINTs_make_affine(group, num_val, val, ctx))\n        goto err;\n\n    r_is_at_infinity = 1;\n\n    for (k = max_len - 1; k >= 0; k--) {\n        if (!r_is_at_infinity) {\n            if (!EC_POINT_dbl(group, r, r, ctx))\n                goto err;\n        }\n\n        for (i = 0; i < totalnum; i++) {\n            if (wNAF_len[i] > (size_t)k) {\n                int digit = wNAF[i][k];\n                int is_neg;\n\n                if (digit) {\n                    is_neg = digit < 0;\n\n                    if (is_neg)\n                        digit = -digit;\n\n                    if (is_neg != r_is_inverted) {\n                        if (!r_is_at_infinity) {\n                            if (!EC_POINT_invert(group, r, ctx))\n                                goto err;\n                        }\n                        r_is_inverted = !r_is_inverted;\n                    }\n\n                    /* digit > 0 */\n\n                    if (r_is_at_infinity) {\n                        if (!EC_POINT_copy(r, val_sub[i][digit >> 1]))\n                            goto err;\n                        r_is_at_infinity = 0;\n                    } else {\n                        if (!EC_POINT_add\n                            (group, r, r, val_sub[i][digit >> 1], ctx))\n                            goto err;\n                    }\n                }\n            }\n        }\n    }\n\n    if (r_is_at_infinity) {\n        if (!EC_POINT_set_to_infinity(group, r))\n            goto err;\n    } else {\n        if (r_is_inverted)\n            if (!EC_POINT_invert(group, r, ctx))\n                goto err;\n    }\n\n    ret = 1;\n\n err:\n    BN_CTX_free(new_ctx);\n    EC_POINT_free(tmp);\n    OPENSSL_free(wsize);\n    OPENSSL_free(wNAF_len);\n    if (wNAF != NULL) {\n        signed char **w;\n\n        for (w = wNAF; *w != NULL; w++)\n            OPENSSL_free(*w);\n\n        OPENSSL_free(wNAF);\n    }\n    if (val != NULL) {\n        for (v = val; *v != NULL; v++)\n            EC_POINT_clear_free(*v);\n\n        OPENSSL_free(val);\n    }\n    OPENSSL_free(val_sub);\n    return ret;\n}",
        "target": 0
    },
    {
        "func": "int BN_get_flags(const BIGNUM *b, int n)\n{\n    return b->flags & n;\n}",
        "target": 0
    },
    {
        "func": "static BN_ULONG *bn_expand_internal(const BIGNUM *b, int words)\n{\n    BN_ULONG *A, *a = NULL;\n    const BN_ULONG *B;\n    int i;\n\n    bn_check_top(b);\n\n    if (words > (INT_MAX / (4 * BN_BITS2))) {\n        BNerr(BN_F_BN_EXPAND_INTERNAL, BN_R_BIGNUM_TOO_LONG);\n        return NULL;\n    }\n    if (BN_get_flags(b, BN_FLG_STATIC_DATA)) {\n        BNerr(BN_F_BN_EXPAND_INTERNAL, BN_R_EXPAND_ON_STATIC_BIGNUM_DATA);\n        return (NULL);\n    }\n    if (BN_get_flags(b, BN_FLG_SECURE))\n        a = A = OPENSSL_secure_zalloc(words * sizeof(*a));\n    else\n        a = A = OPENSSL_zalloc(words * sizeof(*a));\n    if (A == NULL) {\n        BNerr(BN_F_BN_EXPAND_INTERNAL, ERR_R_MALLOC_FAILURE);\n        return (NULL);\n    }\n\n#if 1\n    B = b->d;\n    /* Check if the previous number needs to be copied */\n    if (B != NULL) {\n        for (i = b->top >> 2; i > 0; i--, A += 4, B += 4) {\n            /*\n             * The fact that the loop is unrolled\n             * 4-wise is a tribute to Intel. It's\n             * the one that doesn't have enough\n             * registers to accommodate more data.\n             * I'd unroll it 8-wise otherwise:-)\n             *\n             *              <appro@fy.chalmers.se>\n             */\n            BN_ULONG a0, a1, a2, a3;\n            a0 = B[0];\n            a1 = B[1];\n            a2 = B[2];\n            a3 = B[3];\n            A[0] = a0;\n            A[1] = a1;\n            A[2] = a2;\n            A[3] = a3;\n        }\n        switch (b->top & 3) {\n        case 3:\n            A[2] = B[2];\n            /* fall thru */\n        case 2:\n            A[1] = B[1];\n            /* fall thru */\n        case 1:\n            A[0] = B[0];\n            /* fall thru */\n        case 0:\n            /* Without the \"case 0\" some old optimizers got this wrong. */\n            ;\n        }\n    }\n#else\n    memset(A, 0, sizeof(*A) * words);\n    memcpy(A, b->d, sizeof(b->d[0]) * b->top);\n#endif\n\n    return (a);\n}",
        "target": 0
    },
    {
        "func": "int BN_bn2bin(const BIGNUM *a, unsigned char *to)\n{\n    return bn2binpad(a, to, -1);\n}",
        "target": 0
    },
    {
        "func": "static void bn_free_d(BIGNUM *a)\n{\n    if (BN_get_flags(a, BN_FLG_SECURE))\n        OPENSSL_secure_free(a->d);\n    else\n        OPENSSL_free(a->d);\n}",
        "target": 0
    },
    {
        "func": "void BN_free(BIGNUM *a)\n{\n    if (a == NULL)\n        return;\n    bn_check_top(a);\n    if (!BN_get_flags(a, BN_FLG_STATIC_DATA))\n        bn_free_d(a);\n    if (a->flags & BN_FLG_MALLOCED)\n        OPENSSL_free(a);\n    else {\n#if OPENSSL_API_COMPAT < 0x00908000L\n        a->flags |= BN_FLG_FREE;\n#endif\n        a->d = NULL;\n    }\n}",
        "target": 0
    },
    {
        "func": "BIGNUM *BN_dup(const BIGNUM *a)\n{\n    BIGNUM *t;\n\n    if (a == NULL)\n        return NULL;\n    bn_check_top(a);\n\n    t = BN_get_flags(a, BN_FLG_SECURE) ? BN_secure_new() : BN_new();\n    if (t == NULL)\n        return NULL;\n    if (!BN_copy(t, a)) {\n        BN_free(t);\n        return NULL;\n    }\n    bn_check_top(t);\n    return t;\n}",
        "target": 0
    },
    {
        "func": "static int bn2binpad(const BIGNUM *a, unsigned char *to, int tolen)\n{\n    int i;\n    BN_ULONG l;\n\n    bn_check_top(a);\n    i = BN_num_bytes(a);\n    if (tolen == -1)\n        tolen = i;\n    else if (tolen < i)\n        return -1;\n    /* Add leading zeroes if necessary */\n    if (tolen > i) {\n        memset(to, 0, tolen - i);\n        to += tolen - i;\n    }\n    while (i--) {\n        l = a->d[i / BN_BYTES];\n        *(to++) = (unsigned char)(l >> (8 * (i % BN_BYTES))) & 0xff;\n    }\n    return tolen;\n}",
        "target": 0
    },
    {
        "func": "int BN_set_bit(BIGNUM *a, int n)\n{\n    int i, j, k;\n\n    if (n < 0)\n        return 0;\n\n    i = n / BN_BITS2;\n    j = n % BN_BITS2;\n    if (a->top <= i) {\n        if (bn_wexpand(a, i + 1) == NULL)\n            return (0);\n        for (k = a->top; k < i + 1; k++)\n            a->d[k] = 0;\n        a->top = i + 1;\n    }\n\n    a->d[i] |= (((BN_ULONG)1) << j);\n    bn_check_top(a);\n    return (1);\n}",
        "target": 0
    },
    {
        "func": "void BN_zero_ex(BIGNUM *a)\n{\n    a->top = 0;\n    a->neg = 0;\n}",
        "target": 0
    },
    {
        "func": "BN_GENCB *BN_GENCB_new(void)\n{\n    BN_GENCB *ret;\n\n    if ((ret = OPENSSL_malloc(sizeof(*ret))) == NULL) {\n        BNerr(BN_F_BN_GENCB_NEW, ERR_R_MALLOC_FAILURE);\n        return (NULL);\n    }\n\n    return ret;\n}",
        "target": 0
    },
    {
        "func": "void BN_GENCB_free(BN_GENCB *cb)\n{\n    if (cb == NULL)\n        return;\n    OPENSSL_free(cb);\n}",
        "target": 0
    },
    {
        "func": "void BN_GENCB_set(BN_GENCB *gencb, int (*callback) (int, int, BN_GENCB *),\n                  void *cb_arg)\n{\n    BN_GENCB *tmp_gencb = gencb;\n    tmp_gencb->ver = 2;\n    tmp_gencb->arg = cb_arg;\n    tmp_gencb->cb.cb_2 = callback;\n}",
        "target": 0
    },
    {
        "func": "void BN_GENCB_set_old(BN_GENCB *gencb, void (*callback) (int, int, void *),\n                      void *cb_arg)\n{\n    BN_GENCB *tmp_gencb = gencb;\n    tmp_gencb->ver = 1;\n    tmp_gencb->arg = cb_arg;\n    tmp_gencb->cb.cb_1 = callback;\n}",
        "target": 0
    },
    {
        "func": "void bn_correct_top(BIGNUM *a)\n{\n    BN_ULONG *ftl;\n    int tmp_top = a->top;\n\n    if (tmp_top > 0) {\n        for (ftl = &(a->d[tmp_top]); tmp_top > 0; tmp_top--) {\n            ftl--;\n            if (*ftl != 0)\n                break;\n        }\n        a->top = tmp_top;\n    }\n    if (a->top == 0)\n        a->neg = 0;\n    bn_pollute(a);\n}",
        "target": 0
    },
    {
        "func": "void *BN_GENCB_get_arg(BN_GENCB *cb)\n{\n    return cb->arg;\n}",
        "target": 0
    },
    {
        "func": "static int ec_mul_consttime(const EC_GROUP *group, EC_POINT *r, const BIGNUM *scalar,\n                            const EC_POINT *point, BN_CTX *ctx)\n{\n    int i, order_bits, group_top, kbit, pbit, Z_is_one, ret;\n    ret = 0;\n    EC_POINT *s = NULL;\n    BIGNUM *k = NULL;\n    BIGNUM *lambda = NULL;\n    BN_CTX *new_ctx = NULL;\n\n    if (ctx == NULL)\n        if ((ctx = new_ctx = BN_CTX_secure_new()) == NULL)\n            return 0;\n\n    if ((group->order == NULL) || (group->field == NULL))\n        goto err;\n\n    order_bits = BN_num_bits(group->order);\n\n    s = EC_POINT_new(group);\n    if (s == NULL)\n        goto err;\n\n    if (point == NULL) {\n        if (group->generator == NULL)\n            goto err;\n        if (!EC_POINT_copy(s, group->generator))\n            goto err;\n    } else {\n        if (!EC_POINT_copy(s, point))\n            goto err;\n    }\n\n    EC_POINT_set_flags(s, BN_FLG_CONSTTIME);\n\n    BN_CTX_start(ctx);\n    lambda = BN_CTX_get(ctx);\n    k = BN_CTX_get(ctx);\n    if (k == NULL)\n        goto err;\n\n    /*\n     * Group orders are often on a word boundary.\n     * So when we pad the scalar, some timing diff might\n     * pop if it needs to be expanded due to carries.\n     * So expand ahead of time.\n     */\n    group_top = bn_get_top(group->order);\n    if ((bn_wexpand(k, group_top + 1) == NULL)\n        || (bn_wexpand(lambda, group_top + 1) == NULL))\n        goto err;\n\n    if (!BN_copy(k, scalar))\n        goto err;\n\n    BN_set_flags(k, BN_FLG_CONSTTIME);\n\n    if ((BN_num_bits(k) > order_bits) || (BN_is_negative(k))) {\n        /*\n         * this is an unusual input, and we don't guarantee\n         * constant-timeness\n         */\n        if(!BN_nnmod(k, k, group->order, ctx))\n            goto err;\n    }\n\n    if (!BN_add(lambda, k, group->order))\n        goto err;\n    BN_set_flags(lambda, BN_FLG_CONSTTIME);\n    if (!BN_add(k, lambda, group->order))\n        goto err;\n    /*\n     * lambda := scalar + order\n     * k := scalar + 2*order\n     */\n    kbit = BN_is_bit_set(lambda, order_bits);\n    BN_consttime_swap(kbit, k, lambda, group_top + 1);\n\n    group_top = bn_get_top(group->field);\n    if ((bn_wexpand(s->X, group_top) == NULL)\n        || (bn_wexpand(s->Y, group_top) == NULL)\n        || (bn_wexpand(s->Z, group_top) == NULL)\n        || (bn_wexpand(r->X, group_top) == NULL)\n        || (bn_wexpand(r->Y, group_top) == NULL)\n        || (bn_wexpand(r->Z, group_top) == NULL))\n        goto err;\n\n    /* top bit is a 1, in a fixed pos */\n    if (!EC_POINT_copy(r, s))\n        goto err;\n\n    EC_POINT_set_flags(r, BN_FLG_CONSTTIME);\n\n    if (!EC_POINT_dbl(group, s, s, ctx))\n        goto err;\n\n    pbit = 0;\n\n#define EC_POINT_CSWAP(c, a, b, w, t) do {         \\\n        BN_consttime_swap(c, (a)->X, (b)->X, w);   \\\n        BN_consttime_swap(c, (a)->Y, (b)->Y, w);   \\\n        BN_consttime_swap(c, (a)->Z, (b)->Z, w);   \\\n        t = ((a)->Z_is_one ^ (b)->Z_is_one) & (c); \\\n        (a)->Z_is_one ^= (t);                      \\\n        (b)->Z_is_one ^= (t);                      \\\n} while(0)\n\n    for (i = order_bits - 1; i >= 0; i--) {\n        kbit = BN_is_bit_set(k, i) ^ pbit;\n        EC_POINT_CSWAP(kbit, r, s, group_top, Z_is_one);\n        if (!EC_POINT_add(group, s, r, s, ctx))\n            goto err;\n        if (!EC_POINT_dbl(group, r, r, ctx))\n            goto err;\n        /*\n         * pbit logic merges this cswap with that of the\n         * next iteration\n         */\n        pbit ^= kbit;\n    }\n    /* one final cswap to move the right value into r */\n    EC_POINT_CSWAP(pbit, r, s, group_top, Z_is_one);\n#undef EC_POINT_CSWAP\n\n    ret = 1;\n\nerr:\n    EC_POINT_free(s);\n    BN_CTX_end(ctx);\n    BN_CTX_free(new_ctx);\n\n    return ret;\n}",
        "target": 0
    },
    {
        "func": "int BN_bn2binpad(const BIGNUM *a, unsigned char *to, int tolen)\n{\n    if (tolen < 0)\n        return -1;\n    return bn2binpad(a, to, tolen);\n}",
        "target": 0
    },
    {
        "func": "void BN_set_flags(BIGNUM *b, int n)\n{\n    b->flags |= n;\n}",
        "target": 0
    },
    {
        "func": "void BN_swap(BIGNUM *a, BIGNUM *b)\n{\n    int flags_old_a, flags_old_b;\n    BN_ULONG *tmp_d;\n    int tmp_top, tmp_dmax, tmp_neg;\n\n    bn_check_top(a);\n    bn_check_top(b);\n\n    flags_old_a = a->flags;\n    flags_old_b = b->flags;\n\n    tmp_d = a->d;\n    tmp_top = a->top;\n    tmp_dmax = a->dmax;\n    tmp_neg = a->neg;\n\n    a->d = b->d;\n    a->top = b->top;\n    a->dmax = b->dmax;\n    a->neg = b->neg;\n\n    b->d = tmp_d;\n    b->top = tmp_top;\n    b->dmax = tmp_dmax;\n    b->neg = tmp_neg;\n\n    a->flags =\n        (flags_old_a & BN_FLG_MALLOCED) | (flags_old_b & BN_FLG_STATIC_DATA);\n    b->flags =\n        (flags_old_b & BN_FLG_MALLOCED) | (flags_old_a & BN_FLG_STATIC_DATA);\n    bn_check_top(a);\n    bn_check_top(b);\n}",
        "target": 0
    },
    {
        "func": "int BN_is_zero(const BIGNUM *a)\n{\n    return a->top == 0;\n}",
        "target": 0
    },
    {
        "func": " BIGNUM *BN_secure_new(void)\n {\n     BIGNUM *ret = BN_new();\n     if (ret != NULL)\n         ret->flags |= BN_FLG_SECURE;\n     return (ret);\n }",
        "target": 0
    },
    {
        "func": "int BN_abs_is_word(const BIGNUM *a, const BN_ULONG w)\n{\n    return ((a->top == 1) && (a->d[0] == w)) || ((w == 0) && (a->top == 0));\n}",
        "target": 0
    },
    {
        "func": "BIGNUM *bn_wexpand(BIGNUM *a, int words)\n{\n    return (words <= a->dmax) ? a : bn_expand2(a, words);\n}",
        "target": 0
    },
    {
        "func": "int BN_is_one(const BIGNUM *a)\n{\n    return BN_abs_is_word(a, 1) && !a->neg;\n}",
        "target": 0
    },
    {
        "func": "void BN_clear_free(BIGNUM *a)\n{\n    int i;\n\n    if (a == NULL)\n        return;\n    bn_check_top(a);\n    if (a->d != NULL) {\n        OPENSSL_cleanse(a->d, a->dmax * sizeof(a->d[0]));\n        if (!BN_get_flags(a, BN_FLG_STATIC_DATA))\n            bn_free_d(a);\n    }\n    i = BN_get_flags(a, BN_FLG_MALLOCED);\n    OPENSSL_cleanse(a, sizeof(*a));\n    if (i)\n        OPENSSL_free(a);\n}",
        "target": 0
    },
    {
        "func": "int BN_to_montgomery(BIGNUM *r, const BIGNUM *a, BN_MONT_CTX *mont,\n                     BN_CTX *ctx)\n{\n    return BN_mod_mul_montgomery(r, a, &(mont->RR), mont, ctx);\n}",
        "target": 0
    },
    {
        "func": "int BN_is_odd(const BIGNUM *a)\n{\n    return (a->top > 0) && (a->d[0] & 1);\n}",
        "target": 0
    },
    {
        "func": "int BN_GF2m_mod(BIGNUM *r, const BIGNUM *a, const BIGNUM *p)\n{\n    int ret = 0;\n    int arr[6];\n    bn_check_top(a);\n    bn_check_top(p);\n    ret = BN_GF2m_poly2arr(p, arr, OSSL_NELEM(arr));\n    if (!ret || ret > (int)OSSL_NELEM(arr)) {\n        BNerr(BN_F_BN_GF2M_MOD, BN_R_INVALID_LENGTH);\n        return 0;\n    }\n    ret = BN_GF2m_mod_arr(r, a, arr);\n    bn_check_top(r);\n    return ret;\n}",
        "target": 0
    },
    {
        "func": "int BN_GF2m_mod_mul(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,\n                    const BIGNUM *p, BN_CTX *ctx)\n{\n    int ret = 0;\n    const int max = BN_num_bits(p) + 1;\n    int *arr = NULL;\n    bn_check_top(a);\n    bn_check_top(b);\n    bn_check_top(p);\n    if ((arr = OPENSSL_malloc(sizeof(*arr) * max)) == NULL)\n        goto err;\n    ret = BN_GF2m_poly2arr(p, arr, max);\n    if (!ret || ret > max) {\n        BNerr(BN_F_BN_GF2M_MOD_MUL, BN_R_INVALID_LENGTH);\n        goto err;\n    }\n    ret = BN_GF2m_mod_mul_arr(r, a, b, arr, ctx);\n    bn_check_top(r);\n err:\n    OPENSSL_free(arr);\n    return ret;\n}",
        "target": 0
    },
    {
        "func": "int BN_GF2m_mod_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,\n                    const BIGNUM *p, BN_CTX *ctx)\n{\n    int ret = 0;\n    const int max = BN_num_bits(p) + 1;\n    int *arr = NULL;\n    bn_check_top(a);\n    bn_check_top(b);\n    bn_check_top(p);\n    if ((arr = OPENSSL_malloc(sizeof(*arr) * max)) == NULL)\n        goto err;\n    ret = BN_GF2m_poly2arr(p, arr, max);\n    if (!ret || ret > max) {\n        BNerr(BN_F_BN_GF2M_MOD_EXP, BN_R_INVALID_LENGTH);\n        goto err;\n    }\n    ret = BN_GF2m_mod_exp_arr(r, a, b, arr, ctx);\n    bn_check_top(r);\n err:\n    OPENSSL_free(arr);\n    return ret;\n}",
        "target": 0
    },
    {
        "func": "int BN_GF2m_mod_solve_quad(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,\n                           BN_CTX *ctx)\n{\n    int ret = 0;\n    const int max = BN_num_bits(p) + 1;\n    int *arr = NULL;\n    bn_check_top(a);\n    bn_check_top(p);\n    if ((arr = OPENSSL_malloc(sizeof(*arr) * max)) == NULL)\n        goto err;\n    ret = BN_GF2m_poly2arr(p, arr, max);\n    if (!ret || ret > max) {\n        BNerr(BN_F_BN_GF2M_MOD_SOLVE_QUAD, BN_R_INVALID_LENGTH);\n        goto err;\n    }\n    ret = BN_GF2m_mod_solve_quad_arr(r, a, arr, ctx);\n    bn_check_top(r);\n err:\n    OPENSSL_free(arr);\n    return ret;\n}",
        "target": 0
    },
    {
        "func": "int BN_GF2m_mod_sqr(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)\n{\n    int ret = 0;\n    const int max = BN_num_bits(p) + 1;\n    int *arr = NULL;\n\n    bn_check_top(a);\n    bn_check_top(p);\n    if ((arr = OPENSSL_malloc(sizeof(*arr) * max)) == NULL)\n        goto err;\n    ret = BN_GF2m_poly2arr(p, arr, max);\n    if (!ret || ret > max) {\n        BNerr(BN_F_BN_GF2M_MOD_SQR, BN_R_INVALID_LENGTH);\n        goto err;\n    }\n    ret = BN_GF2m_mod_sqr_arr(r, a, arr, ctx);\n    bn_check_top(r);\n err:\n    OPENSSL_free(arr);\n    return ret;\n}",
        "target": 0
    },
    {
        "func": "int BN_GF2m_mod_sqrt(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)\n{\n    int ret = 0;\n    const int max = BN_num_bits(p) + 1;\n    int *arr = NULL;\n    bn_check_top(a);\n    bn_check_top(p);\n    if ((arr = OPENSSL_malloc(sizeof(*arr) * max)) == NULL)\n        goto err;\n    ret = BN_GF2m_poly2arr(p, arr, max);\n    if (!ret || ret > max) {\n        BNerr(BN_F_BN_GF2M_MOD_SQRT, BN_R_INVALID_LENGTH);\n        goto err;\n    }\n    ret = BN_GF2m_mod_sqrt_arr(r, a, arr, ctx);\n    bn_check_top(r);\n err:\n    OPENSSL_free(arr);\n    return ret;\n}",
        "target": 0
    },
    {
        "func": "int BN_GF2m_mod_arr(BIGNUM *r, const BIGNUM *a, const int p[])\n{\n    int j, k;\n    int n, dN, d0, d1;\n    BN_ULONG zz, *z;\n\n    bn_check_top(a);\n\n    if (!p[0]) {\n        /* reduction mod 1 => return 0 */\n        BN_zero(r);\n        return 1;\n    }\n\n    /*\n     * Since the algorithm does reduction in the r value, if a != r, copy the\n     * contents of a into r so we can do reduction in r.\n     */\n    if (a != r) {\n        if (!bn_wexpand(r, a->top))\n            return 0;\n        for (j = 0; j < a->top; j++) {\n            r->d[j] = a->d[j];\n        }\n        r->top = a->top;\n    }\n    z = r->d;\n\n    /* start reduction */\n    dN = p[0] / BN_BITS2;\n    for (j = r->top - 1; j > dN;) {\n        zz = z[j];\n        if (z[j] == 0) {\n            j--;\n            continue;\n        }\n        z[j] = 0;\n\n        for (k = 1; p[k] != 0; k++) {\n            /* reducing component t^p[k] */\n            n = p[0] - p[k];\n            d0 = n % BN_BITS2;\n            d1 = BN_BITS2 - d0;\n            n /= BN_BITS2;\n            z[j - n] ^= (zz >> d0);\n            if (d0)\n                z[j - n - 1] ^= (zz << d1);\n        }\n\n        /* reducing component t^0 */\n        n = dN;\n        d0 = p[0] % BN_BITS2;\n        d1 = BN_BITS2 - d0;\n        z[j - n] ^= (zz >> d0);\n        if (d0)\n            z[j - n - 1] ^= (zz << d1);\n    }\n\n    /* final round of reduction */\n    while (j == dN) {\n\n        d0 = p[0] % BN_BITS2;\n        zz = z[dN] >> d0;\n        if (zz == 0)\n            break;\n        d1 = BN_BITS2 - d0;\n\n        /* clear up the top d1 bits */\n        if (d0)\n            z[dN] = (z[dN] << d1) >> d1;\n        else\n            z[dN] = 0;\n        z[0] ^= zz;             /* reduction t^0 component */\n\n        for (k = 1; p[k] != 0; k++) {\n            BN_ULONG tmp_ulong;\n\n            /* reducing component t^p[k] */\n            n = p[k] / BN_BITS2;\n            d0 = p[k] % BN_BITS2;\n            d1 = BN_BITS2 - d0;\n            z[n] ^= (zz << d0);\n            if (d0 && (tmp_ulong = zz >> d1))\n                z[n + 1] ^= tmp_ulong;\n        }\n\n    }\n\n    bn_correct_top(r);\n    return 1;\n}",
        "target": 0
    },
    {
        "func": "int X509_verify_cert(X509_STORE_CTX *ctx)\n{\n    X509 *x, *xtmp, *xtmp2, *chain_ss = NULL;\n    int bad_chain = 0;\n    X509_VERIFY_PARAM *param = ctx->param;\n    int depth, i, ok = 0;\n    int num, j, retry;\n    int (*cb) (int xok, X509_STORE_CTX *xctx);\n    STACK_OF(X509) *sktmp = NULL;\n    if (ctx->cert == NULL) {\n        X509err(X509_F_X509_VERIFY_CERT, X509_R_NO_CERT_SET_FOR_US_TO_VERIFY);\n        return -1;\n    }\n\n    cb = ctx->verify_cb;\n\n    /*\n     * first we make sure the chain we are going to build is present and that\n     * the first entry is in place\n     */\n    if (ctx->chain == NULL) {\n        if (((ctx->chain = sk_X509_new_null()) == NULL) ||\n            (!sk_X509_push(ctx->chain, ctx->cert))) {\n            X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);\n            goto end;\n        }\n        CRYPTO_add(&ctx->cert->references, 1, CRYPTO_LOCK_X509);\n        ctx->last_untrusted = 1;\n    }\n\n    /* We use a temporary STACK so we can chop and hack at it */\n    if (ctx->untrusted != NULL\n        && (sktmp = sk_X509_dup(ctx->untrusted)) == NULL) {\n        X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);\n        goto end;\n    }\n\n    num = sk_X509_num(ctx->chain);\n    x = sk_X509_value(ctx->chain, num - 1);\n    depth = param->depth;\n\n    for (;;) {\n        /* If we have enough, we break */\n        if (depth < num)\n            break;              /* FIXME: If this happens, we should take\n                                 * note of it and, if appropriate, use the\n                                 * X509_V_ERR_CERT_CHAIN_TOO_LONG error code\n                                 * later. */\n\n        /* If we are self signed, we break */\n        if (cert_self_signed(x))\n            break;\n        /*\n         * If asked see if we can find issuer in trusted store first\n         */\n        if (ctx->param->flags & X509_V_FLAG_TRUSTED_FIRST) {\n            ok = ctx->get_issuer(&xtmp, ctx, x);\n            if (ok < 0)\n                return ok;\n            /*\n             * If successful for now free up cert so it will be picked up\n             * again later.\n             */\n            if (ok > 0) {\n                X509_free(xtmp);\n                break;\n            }\n        }\n\n        /* If we were passed a cert chain, use it first */\n        if (ctx->untrusted != NULL) {\n            xtmp = find_issuer(ctx, sktmp, x);\n            if (xtmp != NULL) {\n                if (!sk_X509_push(ctx->chain, xtmp)) {\n                    X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);\n                    goto end;\n                }\n                CRYPTO_add(&xtmp->references, 1, CRYPTO_LOCK_X509);\n                (void)sk_X509_delete_ptr(sktmp, xtmp);\n                ctx->last_untrusted++;\n                x = xtmp;\n                num++;\n                /*\n                 * reparse the full chain for the next one\n                 */\n                continue;\n            }\n        }\n        break;\n    }\n\n    /* Remember how many untrusted certs we have */\n    j = num;\n    /*\n     * at this point, chain should contain a list of untrusted certificates.\n     * We now need to add at least one trusted one, if possible, otherwise we\n     * complain.\n     */\n\n    do {\n        /*\n         * Examine last certificate in chain and see if it is self signed.\n         */\n        i = sk_X509_num(ctx->chain);\n        x = sk_X509_value(ctx->chain, i - 1);\n        if (cert_self_signed(x)) {\n            /* we have a self signed certificate */\n            if (sk_X509_num(ctx->chain) == 1) {\n                /*\n                 * We have a single self signed certificate: see if we can\n                 * find it in the store. We must have an exact match to avoid\n                 * possible impersonation.\n                 */\n                ok = ctx->get_issuer(&xtmp, ctx, x);\n                if ((ok <= 0) || X509_cmp(x, xtmp)) {\n                    ctx->error = X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT;\n                    ctx->current_cert = x;\n                    ctx->error_depth = i - 1;\n                    if (ok == 1)\n                        X509_free(xtmp);\n                    bad_chain = 1;\n                    ok = cb(0, ctx);\n                    if (!ok)\n                        goto end;\n                } else {\n                    /*\n                     * We have a match: replace certificate with store\n                     * version so we get any trust settings.\n                     */\n                    X509_free(x);\n                    x = xtmp;\n                    (void)sk_X509_set(ctx->chain, i - 1, x);\n                    ctx->last_untrusted = 0;\n                }\n            } else {\n                /*\n                 * extract and save self signed certificate for later use\n                 */\n                chain_ss = sk_X509_pop(ctx->chain);\n                ctx->last_untrusted--;\n                num--;\n                j--;\n                x = sk_X509_value(ctx->chain, num - 1);\n            }\n        }\n        /* We now lookup certs from the certificate store */\n        for (;;) {\n            /* If we have enough, we break */\n            if (depth < num)\n                break;\n            /* If we are self signed, we break */\n            if (cert_self_signed(x))\n                break;\n            ok = ctx->get_issuer(&xtmp, ctx, x);\n\n            if (ok < 0)\n                return ok;\n            if (ok == 0)\n                break;\n            x = xtmp;\n            if (!sk_X509_push(ctx->chain, x)) {\n                X509_free(xtmp);\n                X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);\n                return 0;\n            }\n            num++;\n        }\n\n        /* we now have our chain, lets check it... */\n        i = check_trust(ctx);\n\n        /* If explicitly rejected error */\n        if (i == X509_TRUST_REJECTED)\n            goto end;\n        /*\n         * If it's not explicitly trusted then check if there is an alternative\n         * chain that could be used. We only do this if we haven't already\n         * checked via TRUSTED_FIRST and the user hasn't switched off alternate\n         * chain checking\n         */\n        retry = 0;\n        if (i != X509_TRUST_TRUSTED\n            && !(ctx->param->flags & X509_V_FLAG_TRUSTED_FIRST)\n            && !(ctx->param->flags & X509_V_FLAG_NO_ALT_CHAINS)) {\n            while (j-- > 1) {\n                STACK_OF(X509) *chtmp = ctx->chain;\n                xtmp2 = sk_X509_value(ctx->chain, j - 1);\n                /*\n                 * Temporarily set chain to NULL so we don't discount\n                 * duplicates: the same certificate could be an untrusted\n                 * CA found in the trusted store.\n                 */\n                ctx->chain = NULL;\n                ok = ctx->get_issuer(&xtmp, ctx, xtmp2);\n                ctx->chain = chtmp;\n                if (ok < 0)\n                    goto end;\n                /* Check if we found an alternate chain */\n                if (ok > 0) {\n                    /*\n                     * Free up the found cert we'll add it again later\n                     */\n                    X509_free(xtmp);\n\n                    /*\n                     * Dump all the certs above this point - we've found an\n                     * alternate chain\n                     */\n                    while (num > j) {\n                        xtmp = sk_X509_pop(ctx->chain);\n                        X509_free(xtmp);\n                        num--;\n                        ctx->last_untrusted--;\n                    }\n                    retry = 1;\n                    break;\n                }\n            }\n        }\n    } while (retry);\n\n    /*\n     * If not explicitly trusted then indicate error unless it's a single\n     * self signed certificate in which case we've indicated an error already\n     * and set bad_chain == 1\n     */\n    if (i != X509_TRUST_TRUSTED && !bad_chain) {\n        if ((chain_ss == NULL) || !ctx->check_issued(ctx, x, chain_ss)) {\n            if (ctx->last_untrusted >= num)\n                ctx->error = X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY;\n            else\n                ctx->error = X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT;\n            ctx->current_cert = x;\n        } else {\n\n            sk_X509_push(ctx->chain, chain_ss);\n            num++;\n            ctx->last_untrusted = num;\n            ctx->current_cert = chain_ss;\n            ctx->error = X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN;\n            chain_ss = NULL;\n        }\n\n        ctx->error_depth = num - 1;\n        bad_chain = 1;\n        ok = cb(0, ctx);\n        if (!ok)\n            goto end;\n    }\n\n    /* We have the chain complete: now we need to check its purpose */\n    ok = check_chain_extensions(ctx);\n\n    if (!ok)\n        goto end;\n\n    /* Check name constraints */\n\n    ok = check_name_constraints(ctx);\n\n    if (!ok)\n        goto end;\n\n    ok = check_id(ctx);\n\n    if (!ok)\n        goto end;\n\n    /* We may as well copy down any DSA parameters that are required */\n    X509_get_pubkey_parameters(NULL, ctx->chain);\n\n    /*\n     * Check revocation status: we do this after copying parameters because\n     * they may be needed for CRL signature verification.\n     */\n\n    ok = ctx->check_revocation(ctx);\n    if (!ok)\n        goto end;\n\n    i = X509_chain_check_suiteb(&ctx->error_depth, NULL, ctx->chain,\n                                ctx->param->flags);\n    if (i != X509_V_OK) {\n        ctx->error = i;\n        ctx->current_cert = sk_X509_value(ctx->chain, ctx->error_depth);\n        ok = cb(0, ctx);\n        if (!ok)\n            goto end;\n    }\n\n    /* At this point, we have a chain and need to verify it */\n    if (ctx->verify != NULL)\n        ok = ctx->verify(ctx);\n    else\n        ok = internal_verify(ctx);\n    if (!ok)\n        goto end;\n\n    /* RFC 3779 path validation, now that CRL check has been done */\n    ok = v3_asid_validate_path(ctx);\n    if (!ok)\n        goto end;\n    ok = v3_addr_validate_path(ctx);\n    if (!ok)\n        goto end;\n\n    /* If we get this far evaluate policies */\n    if (!bad_chain && (ctx->param->flags & X509_V_FLAG_POLICY_CHECK))\n        ok = ctx->check_policy(ctx);\n    if (ok)\n        goto done;\n\n end:\n    X509_get_pubkey_parameters(NULL, ctx->chain);\n done:\n    sk_X509_free(sktmp);\n    X509_free(chain_ss);\n    return ok;\n}",
        "target": 0
    },
    {
        "func": "static int check_chain_extensions(X509_STORE_CTX *ctx)\n{\n    int i, ok = 0, must_be_ca, plen = 0;\n    X509 *x;\n    int (*cb) (int xok, X509_STORE_CTX *xctx);\n    int proxy_path_length = 0;\n    int purpose;\n    int allow_proxy_certs;\n    cb = ctx->verify_cb;\n\n    /*-\n     *  must_be_ca can have 1 of 3 values:\n     * -1: we accept both CA and non-CA certificates, to allow direct\n     *     use of self-signed certificates (which are marked as CA).\n     * 0:  we only accept non-CA certificates.  This is currently not\n     *     used, but the possibility is present for future extensions.\n     * 1:  we only accept CA certificates.  This is currently used for\n     *     all certificates in the chain except the leaf certificate.\n     */\n    must_be_ca = -1;\n\n    /* CRL path validation */\n    if (ctx->parent) {\n        allow_proxy_certs = 0;\n        purpose = X509_PURPOSE_CRL_SIGN;\n    } else {\n        allow_proxy_certs =\n            ! !(ctx->param->flags & X509_V_FLAG_ALLOW_PROXY_CERTS);\n        /*\n         * A hack to keep people who don't want to modify their software\n         * happy\n         */\n        if (getenv(\"OPENSSL_ALLOW_PROXY_CERTS\"))\n            allow_proxy_certs = 1;\n        purpose = ctx->param->purpose;\n    }\n\n    /* Check all untrusted certificates */\n    for (i = 0; i < ctx->last_untrusted; i++) {\n        int ret;\n        x = sk_X509_value(ctx->chain, i);\n        if (!(ctx->param->flags & X509_V_FLAG_IGNORE_CRITICAL)\n            && (x->ex_flags & EXFLAG_CRITICAL)) {\n            ctx->error = X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION;\n            ctx->error_depth = i;\n            ctx->current_cert = x;\n            ok = cb(0, ctx);\n            if (!ok)\n                goto end;\n        }\n        if (!allow_proxy_certs && (x->ex_flags & EXFLAG_PROXY)) {\n            ctx->error = X509_V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED;\n            ctx->error_depth = i;\n            ctx->current_cert = x;\n            ok = cb(0, ctx);\n            if (!ok)\n                goto end;\n        }\n        ret = X509_check_ca(x);\n        switch (must_be_ca) {\n        case -1:\n            if ((ctx->param->flags & X509_V_FLAG_X509_STRICT)\n                && (ret != 1) && (ret != 0)) {\n                ret = 0;\n                ctx->error = X509_V_ERR_INVALID_CA;\n            } else\n                ret = 1;\n            break;\n        case 0:\n            if (ret != 0) {\n                ret = 0;\n                ctx->error = X509_V_ERR_INVALID_NON_CA;\n            } else\n                ret = 1;\n            break;\n        default:\n            if ((ret == 0)\n                || ((ctx->param->flags & X509_V_FLAG_X509_STRICT)\n                    && (ret != 1))) {\n                ret = 0;\n                ctx->error = X509_V_ERR_INVALID_CA;\n            } else\n                ret = 1;\n            break;\n        }\n        if (ret == 0) {\n            ctx->error_depth = i;\n            ctx->current_cert = x;\n            ok = cb(0, ctx);\n            if (!ok)\n                goto end;\n        }\n        if (ctx->param->purpose > 0) {\n            ret = X509_check_purpose(x, purpose, must_be_ca > 0);\n            if ((ret == 0)\n                || ((ctx->param->flags & X509_V_FLAG_X509_STRICT)\n                    && (ret != 1))) {\n                ctx->error = X509_V_ERR_INVALID_PURPOSE;\n                ctx->error_depth = i;\n                ctx->current_cert = x;\n                ok = cb(0, ctx);\n                if (!ok)\n                    goto end;\n            }\n        }\n        /* Check pathlen if not self issued */\n        if ((i > 1) && !(x->ex_flags & EXFLAG_SI)\n            && (x->ex_pathlen != -1)\n            && (plen > (x->ex_pathlen + proxy_path_length + 1))) {\n            ctx->error = X509_V_ERR_PATH_LENGTH_EXCEEDED;\n            ctx->error_depth = i;\n            ctx->current_cert = x;\n            ok = cb(0, ctx);\n            if (!ok)\n                goto end;\n        }\n        /* Increment path length if not self issued */\n        if (!(x->ex_flags & EXFLAG_SI))\n            plen++;\n        /*\n         * If this certificate is a proxy certificate, the next certificate\n         * must be another proxy certificate or a EE certificate.  If not,\n         * the next certificate must be a CA certificate.\n         */\n        if (x->ex_flags & EXFLAG_PROXY) {\n            if (x->ex_pcpathlen != -1 && i > x->ex_pcpathlen) {\n                ctx->error = X509_V_ERR_PROXY_PATH_LENGTH_EXCEEDED;\n                ctx->error_depth = i;\n                ctx->current_cert = x;\n                ok = cb(0, ctx);\n                if (!ok)\n                    goto end;\n            }\n            proxy_path_length++;\n            must_be_ca = 0;\n        } else\n            must_be_ca = 1;\n    }\n    ok = 1;\n end:\n    return ok;\n}",
        "target": 0
    },
    {
        "func": "void X509_STORE_CTX_cleanup(X509_STORE_CTX *ctx)\n{\n    if (ctx->cleanup)\n        ctx->cleanup(ctx);\n    if (ctx->param != NULL) {\n        if (ctx->parent == NULL)\n            X509_VERIFY_PARAM_free(ctx->param);\n        ctx->param = NULL;\n    }\n    X509_policy_tree_free(ctx->tree);\n    ctx->tree = NULL;\n    sk_X509_pop_free(ctx->chain, X509_free);\n    ctx->chain = NULL;\n    CRYPTO_free_ex_data(CRYPTO_EX_INDEX_X509_STORE_CTX, ctx, &(ctx->ex_data));\n    memset(&ctx->ex_data, 0, sizeof(ctx->ex_data));\n}",
        "target": 0
    },
    {
        "func": "X509_STORE_CTX *X509_STORE_CTX_new(void)\n{\n    X509_STORE_CTX *ctx = OPENSSL_malloc(sizeof(*ctx));\n\n    if (!ctx) {\n        X509err(X509_F_X509_STORE_CTX_NEW, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n    memset(ctx, 0, sizeof(*ctx));\n    return ctx;\n}",
        "target": 0
    },
    {
        "func": "int X509_get_pubkey_parameters(EVP_PKEY *pkey, STACK_OF(X509) *chain)\n{\n    EVP_PKEY *ktmp = NULL, *ktmp2;\n    int i, j;\n\n    if ((pkey != NULL) && !EVP_PKEY_missing_parameters(pkey))\n        return 1;\n\n    for (i = 0; i < sk_X509_num(chain); i++) {\n        ktmp = X509_get_pubkey(sk_X509_value(chain, i));\n        if (ktmp == NULL) {\n            X509err(X509_F_X509_GET_PUBKEY_PARAMETERS,\n                    X509_R_UNABLE_TO_GET_CERTS_PUBLIC_KEY);\n            return 0;\n        }\n        if (!EVP_PKEY_missing_parameters(ktmp))\n            break;\n        EVP_PKEY_free(ktmp);\n        ktmp = NULL;\n    }\n    if (ktmp == NULL) {\n        X509err(X509_F_X509_GET_PUBKEY_PARAMETERS,\n                X509_R_UNABLE_TO_FIND_PARAMETERS_IN_CHAIN);\n        return 0;\n    }\n\n    /* first, populate the other certs */\n    for (j = i - 1; j >= 0; j--) {\n        ktmp2 = X509_get_pubkey(sk_X509_value(chain, j));\n        EVP_PKEY_copy_parameters(ktmp2, ktmp);\n        EVP_PKEY_free(ktmp2);\n    }\n\n    if (pkey != NULL)\n        EVP_PKEY_copy_parameters(pkey, ktmp);\n    EVP_PKEY_free(ktmp);\n    return 1;\n}",
        "target": 0
    },
    {
        "func": "X509_CRL *X509_CRL_diff(X509_CRL *base, X509_CRL *newer,\n                        EVP_PKEY *skey, const EVP_MD *md, unsigned int flags)\n{\n    X509_CRL *crl = NULL;\n    int i;\n    STACK_OF(X509_REVOKED) *revs = NULL;\n    /* CRLs can't be delta already */\n    if (base->base_crl_number || newer->base_crl_number) {\n        X509err(X509_F_X509_CRL_DIFF, X509_R_CRL_ALREADY_DELTA);\n        return NULL;\n    }\n    /* Base and new CRL must have a CRL number */\n    if (!base->crl_number || !newer->crl_number) {\n        X509err(X509_F_X509_CRL_DIFF, X509_R_NO_CRL_NUMBER);\n        return NULL;\n    }\n    /* Issuer names must match */\n    if (X509_NAME_cmp(X509_CRL_get_issuer(base), X509_CRL_get_issuer(newer))) {\n        X509err(X509_F_X509_CRL_DIFF, X509_R_ISSUER_MISMATCH);\n        return NULL;\n    }\n    /* AKID and IDP must match */\n    if (!crl_extension_match(base, newer, NID_authority_key_identifier)) {\n        X509err(X509_F_X509_CRL_DIFF, X509_R_AKID_MISMATCH);\n        return NULL;\n    }\n    if (!crl_extension_match(base, newer, NID_issuing_distribution_point)) {\n        X509err(X509_F_X509_CRL_DIFF, X509_R_IDP_MISMATCH);\n        return NULL;\n    }\n    /* Newer CRL number must exceed full CRL number */\n    if (ASN1_INTEGER_cmp(newer->crl_number, base->crl_number) <= 0) {\n        X509err(X509_F_X509_CRL_DIFF, X509_R_NEWER_CRL_NOT_NEWER);\n        return NULL;\n    }\n    /* CRLs must verify */\n    if (skey && (X509_CRL_verify(base, skey) <= 0 ||\n                 X509_CRL_verify(newer, skey) <= 0)) {\n        X509err(X509_F_X509_CRL_DIFF, X509_R_CRL_VERIFY_FAILURE);\n        return NULL;\n    }\n    /* Create new CRL */\n    crl = X509_CRL_new();\n    if (!crl || !X509_CRL_set_version(crl, 1))\n        goto memerr;\n    /* Set issuer name */\n    if (!X509_CRL_set_issuer_name(crl, X509_CRL_get_issuer(newer)))\n        goto memerr;\n\n    if (!X509_CRL_set_lastUpdate(crl, X509_CRL_get_lastUpdate(newer)))\n        goto memerr;\n    if (!X509_CRL_set_nextUpdate(crl, X509_CRL_get_nextUpdate(newer)))\n        goto memerr;\n\n    /* Set base CRL number: must be critical */\n\n    if (!X509_CRL_add1_ext_i2d(crl, NID_delta_crl, base->crl_number, 1, 0))\n        goto memerr;\n\n    /*\n     * Copy extensions across from newest CRL to delta: this will set CRL\n     * number to correct value too.\n     */\n\n    for (i = 0; i < X509_CRL_get_ext_count(newer); i++) {\n        X509_EXTENSION *ext;\n        ext = X509_CRL_get_ext(newer, i);\n        if (!X509_CRL_add_ext(crl, ext, -1))\n            goto memerr;\n    }\n\n    /* Go through revoked entries, copying as needed */\n\n    revs = X509_CRL_get_REVOKED(newer);\n\n    for (i = 0; i < sk_X509_REVOKED_num(revs); i++) {\n        X509_REVOKED *rvn, *rvtmp;\n        rvn = sk_X509_REVOKED_value(revs, i);\n        /*\n         * Add only if not also in base. TODO: need something cleverer here\n         * for some more complex CRLs covering multiple CAs.\n         */\n        if (!X509_CRL_get0_by_serial(base, &rvtmp, rvn->serialNumber)) {\n            rvtmp = X509_REVOKED_dup(rvn);\n            if (!rvtmp)\n                goto memerr;\n            if (!X509_CRL_add0_revoked(crl, rvtmp)) {\n                X509_REVOKED_free(rvtmp);\n                goto memerr;\n            }\n        }\n    }\n    /* TODO: optionally prune deleted entries */\n\n    if (skey && md && !X509_CRL_sign(crl, skey, md))\n        goto memerr;\n\n    return crl;\n\n memerr:\n    X509err(X509_F_X509_CRL_DIFF, ERR_R_MALLOC_FAILURE);\n    X509_CRL_free(crl);\n    return NULL;\n}",
        "target": 0
    },
    {
        "func": "int X509_STORE_CTX_init(X509_STORE_CTX *ctx, X509_STORE *store, X509 *x509,\n                        STACK_OF(X509) *chain)\n{\n    int ret = 1;\n    ctx->ctx = store;\n    ctx->current_method = 0;\n    ctx->cert = x509;\n    ctx->untrusted = chain;\n    ctx->crls = NULL;\n    ctx->last_untrusted = 0;\n    ctx->other_ctx = NULL;\n    ctx->valid = 0;\n    ctx->chain = NULL;\n    ctx->error = 0;\n    ctx->explicit_policy = 0;\n    ctx->error_depth = 0;\n    ctx->current_cert = NULL;\n    ctx->current_issuer = NULL;\n    ctx->current_crl = NULL;\n    ctx->current_crl_score = 0;\n    ctx->current_reasons = 0;\n    ctx->tree = NULL;\n    ctx->parent = NULL;\n\n    ctx->param = X509_VERIFY_PARAM_new();\n\n    if (!ctx->param) {\n        X509err(X509_F_X509_STORE_CTX_INIT, ERR_R_MALLOC_FAILURE);\n        return 0;\n    }\n\n    /*\n     * Inherit callbacks and flags from X509_STORE if not set use defaults.\n     */\n\n    if (store)\n        ret = X509_VERIFY_PARAM_inherit(ctx->param, store->param);\n    else\n        ctx->param->inh_flags |= X509_VP_FLAG_DEFAULT | X509_VP_FLAG_ONCE;\n\n    if (store) {\n        ctx->verify_cb = store->verify_cb;\n        ctx->cleanup = store->cleanup;\n    } else\n        ctx->cleanup = 0;\n\n    if (ret)\n        ret = X509_VERIFY_PARAM_inherit(ctx->param,\n                                        X509_VERIFY_PARAM_lookup(\"default\"));\n\n    if (ret == 0) {\n        X509err(X509_F_X509_STORE_CTX_INIT, ERR_R_MALLOC_FAILURE);\n        return 0;\n    }\n\n    if (store && store->check_issued)\n        ctx->check_issued = store->check_issued;\n    else\n        ctx->check_issued = check_issued;\n\n    if (store && store->get_issuer)\n        ctx->get_issuer = store->get_issuer;\n    else\n        ctx->get_issuer = X509_STORE_CTX_get1_issuer;\n\n    if (store && store->verify_cb)\n        ctx->verify_cb = store->verify_cb;\n    else\n        ctx->verify_cb = null_callback;\n\n    if (store && store->verify)\n        ctx->verify = store->verify;\n    else\n        ctx->verify = internal_verify;\n\n    if (store && store->check_revocation)\n        ctx->check_revocation = store->check_revocation;\n    else\n        ctx->check_revocation = check_revocation;\n\n    if (store && store->get_crl)\n        ctx->get_crl = store->get_crl;\n    else\n        ctx->get_crl = NULL;\n\n    if (store && store->check_crl)\n        ctx->check_crl = store->check_crl;\n    else\n        ctx->check_crl = check_crl;\n\n    if (store && store->cert_crl)\n        ctx->cert_crl = store->cert_crl;\n    else\n        ctx->cert_crl = cert_crl;\n\n    if (store && store->lookup_certs)\n        ctx->lookup_certs = store->lookup_certs;\n    else\n        ctx->lookup_certs = X509_STORE_get1_certs;\n\n    if (store && store->lookup_crls)\n        ctx->lookup_crls = store->lookup_crls;\n    else\n        ctx->lookup_crls = X509_STORE_get1_crls;\n\n    ctx->check_policy = check_policy;\n\n    /*\n     * Since X509_STORE_CTX_cleanup does a proper \"free\" on the ex_data, we\n     * put a corresponding \"new\" here.\n     */\n    if (!CRYPTO_new_ex_data(CRYPTO_EX_INDEX_X509_STORE_CTX, ctx,\n                            &(ctx->ex_data))) {\n        OPENSSL_free(ctx);\n        X509err(X509_F_X509_STORE_CTX_INIT, ERR_R_MALLOC_FAILURE);\n        return 0;\n    }\n    return 1;\n}",
        "target": 0
    },
    {
        "func": "static int check_hosts(X509 *x, X509_VERIFY_PARAM_ID *id)\n{\n    int i;\n    int n = sk_OPENSSL_STRING_num(id->hosts);\n    char *name;\n\n    for (i = 0; i < n; ++i) {\n        name = sk_OPENSSL_STRING_value(id->hosts, i);\n        if (X509_check_host(x, name, 0, id->hostflags, &id->peername) > 0)\n            return 1;\n    }\n    return n == 0;\n}",
        "target": 0
    },
    {
        "func": "int x509_check_cert_time(X509_STORE_CTX *ctx, X509 *x, int quiet)\n{\n    time_t *ptime;\n    int i;\n\n    if (ctx->param->flags & X509_V_FLAG_USE_CHECK_TIME)\n        ptime = &ctx->param->check_time;\n    else\n        ptime = NULL;\n\n    i = X509_cmp_time(X509_get_notBefore(x), ptime);\n    if (i == 0) {\n        if (quiet)\n            return 0;\n        ctx->error = X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD;\n        ctx->current_cert = x;\n        if (!ctx->verify_cb(0, ctx))\n            return 0;\n    }\n\n    if (i > 0) {\n        if (quiet)\n            return 0;\n        ctx->error = X509_V_ERR_CERT_NOT_YET_VALID;\n        ctx->current_cert = x;\n        if (!ctx->verify_cb(0, ctx))\n            return 0;\n    }\n\n    i = X509_cmp_time(X509_get_notAfter(x), ptime);\n    if (i == 0) {\n        if (quiet)\n            return 0;\n        ctx->error = X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD;\n        ctx->current_cert = x;\n        if (!ctx->verify_cb(0, ctx))\n            return 0;\n    }\n\n    if (i < 0) {\n        if (quiet)\n            return 0;\n        ctx->error = X509_V_ERR_CERT_HAS_EXPIRED;\n        ctx->current_cert = x;\n        if (!ctx->verify_cb(0, ctx))\n            return 0;\n    }\n\n    return 1;\n}",
        "target": 0
    },
    {
        "func": "static int get_crl_sk(X509_STORE_CTX *ctx, X509_CRL **pcrl, X509_CRL **pdcrl,\n                      X509 **pissuer, int *pscore, unsigned int *preasons,\n                      STACK_OF(X509_CRL) *crls)\n{\n    int i, crl_score, best_score = *pscore;\n    unsigned int reasons, best_reasons = 0;\n    X509 *x = ctx->current_cert;\n    X509_CRL *crl, *best_crl = NULL;\n    X509 *crl_issuer = NULL, *best_crl_issuer = NULL;\n\n    for (i = 0; i < sk_X509_CRL_num(crls); i++) {\n        crl = sk_X509_CRL_value(crls, i);\n        reasons = *preasons;\n        crl_score = get_crl_score(ctx, &crl_issuer, &reasons, crl, x);\n\n        if (crl_score > best_score) {\n            best_crl = crl;\n            best_crl_issuer = crl_issuer;\n            best_score = crl_score;\n            best_reasons = reasons;\n        }\n    }\n\n    if (best_crl) {\n        X509_CRL_free(*pcrl);\n        *pcrl = best_crl;\n        *pissuer = best_crl_issuer;\n        *pscore = best_score;\n        *preasons = best_reasons;\n        CRYPTO_add(&best_crl->references, 1, CRYPTO_LOCK_X509_CRL);\n        X509_CRL_free(*pdcrl);\n        *pdcrl = NULL;\n        get_delta_sk(ctx, pdcrl, pscore, best_crl, crls);\n    }\n\n    if (best_score >= CRL_SCORE_VALID)\n        return 1;\n\n    return 0;\n}",
        "target": 0
    },
    {
        "func": "static int internal_verify(X509_STORE_CTX *ctx)\n{\n    int ok = 0, n;\n    X509 *xs, *xi;\n    EVP_PKEY *pkey = NULL;\n    int (*cb) (int xok, X509_STORE_CTX *xctx);\n\n    cb = ctx->verify_cb;\n\n    n = sk_X509_num(ctx->chain);\n    ctx->error_depth = n - 1;\n    n--;\n    xi = sk_X509_value(ctx->chain, n);\n\n    if (ctx->check_issued(ctx, xi, xi))\n        xs = xi;\n    else {\n        if (ctx->param->flags & X509_V_FLAG_PARTIAL_CHAIN) {\n            xs = xi;\n            goto check_cert;\n        }\n        if (n <= 0) {\n            ctx->error = X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE;\n            ctx->current_cert = xi;\n            ok = cb(0, ctx);\n            goto end;\n        } else {\n            n--;\n            ctx->error_depth = n;\n            xs = sk_X509_value(ctx->chain, n);\n        }\n    }\n\n/*      ctx->error=0;  not needed */\n    while (n >= 0) {\n        ctx->error_depth = n;\n\n        /*\n         * Skip signature check for self signed certificates unless\n         * explicitly asked for. It doesn't add any security and just wastes\n         * time.\n         */\n        if (!xs->valid\n            && (xs != xi\n                || (ctx->param->flags & X509_V_FLAG_CHECK_SS_SIGNATURE))) {\n            if ((pkey = X509_get_pubkey(xi)) == NULL) {\n                ctx->error = X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY;\n                ctx->current_cert = xi;\n                ok = (*cb) (0, ctx);\n                if (!ok)\n                    goto end;\n            } else if (X509_verify(xs, pkey) <= 0) {\n                ctx->error = X509_V_ERR_CERT_SIGNATURE_FAILURE;\n                ctx->current_cert = xs;\n                ok = (*cb) (0, ctx);\n                if (!ok) {\n                    EVP_PKEY_free(pkey);\n                    goto end;\n                }\n            }\n            EVP_PKEY_free(pkey);\n            pkey = NULL;\n        }\n\n        xs->valid = 1;\n\n check_cert:\n        ok = x509_check_cert_time(ctx, xs, 0);\n        if (!ok)\n            goto end;\n\n        /* The last error (if any) is still in the error value */\n        ctx->current_issuer = xi;\n        ctx->current_cert = xs;\n        ok = (*cb) (1, ctx);\n        if (!ok)\n            goto end;\n\n        n--;\n        if (n >= 0) {\n            xi = xs;\n            xs = sk_X509_value(ctx->chain, n);\n        }\n    }\n    ok = 1;\n end:\n    return ok;\n}",
        "target": 0
    },
    {
        "func": "static int i2r_IPAddressOrRanges(BIO *out,\n                                 const int indent,\n                                 const IPAddressOrRanges *aors,\n                                 const unsigned afi)\n{\n    int i;\n    for (i = 0; i < sk_IPAddressOrRange_num(aors); i++) {\n        const IPAddressOrRange *aor = sk_IPAddressOrRange_value(aors, i);\n        BIO_printf(out, \"%*s\", indent, \"\");\n        switch (aor->type) {\n        case IPAddressOrRange_addressPrefix:\n            if (!i2r_address(out, afi, 0x00, aor->u.addressPrefix))\n                return 0;\n            BIO_printf(out, \"/%d\\n\", addr_prefixlen(aor->u.addressPrefix));\n            continue;\n        case IPAddressOrRange_addressRange:\n            if (!i2r_address(out, afi, 0x00, aor->u.addressRange->min))\n                return 0;\n            BIO_puts(out, \"-\");\n            if (!i2r_address(out, afi, 0xFF, aor->u.addressRange->max))\n                return 0;\n            BIO_puts(out, \"\\n\");\n            continue;\n        }\n    }\n    return 1;\n}",
        "target": 0
    },
    {
        "func": "int X509v3_addr_validate_resource_set(STACK_OF(X509) *chain,\n                                  IPAddrBlocks *ext, int allow_inheritance)\n{\n    if (ext == NULL)\n        return 1;\n    if (chain == NULL || sk_X509_num(chain) == 0)\n        return 0;\n    if (!allow_inheritance && X509v3_addr_inherits(ext))\n        return 0;\n    return addr_validate_path_internal(NULL, chain, ext);\n}",
        "target": 0
    },
    {
        "func": "static int make_addressRange(IPAddressOrRange **result,\n                             unsigned char *min,\n                             unsigned char *max, const int length)\n{\n    IPAddressOrRange *aor;\n    int i, prefixlen;\n\n    if ((prefixlen = range_should_be_prefix(min, max, length)) >= 0)\n        return make_addressPrefix(result, min, prefixlen);\n\n    if ((aor = IPAddressOrRange_new()) == NULL)\n        return 0;\n    aor->type = IPAddressOrRange_addressRange;\n    OPENSSL_assert(aor->u.addressRange == NULL);\n    if ((aor->u.addressRange = IPAddressRange_new()) == NULL)\n        goto err;\n    if (aor->u.addressRange->min == NULL &&\n        (aor->u.addressRange->min = ASN1_BIT_STRING_new()) == NULL)\n        goto err;\n    if (aor->u.addressRange->max == NULL &&\n        (aor->u.addressRange->max = ASN1_BIT_STRING_new()) == NULL)\n        goto err;\n\n    for (i = length; i > 0 && min[i - 1] == 0x00; --i) ;\n    if (!ASN1_BIT_STRING_set(aor->u.addressRange->min, min, i))\n        goto err;\n    aor->u.addressRange->min->flags &= ~7;\n    aor->u.addressRange->min->flags |= ASN1_STRING_FLAG_BITS_LEFT;\n    if (i > 0) {\n        unsigned char b = min[i - 1];\n        int j = 1;\n        while ((b & (0xFFU >> j)) != 0)\n            ++j;\n        aor->u.addressRange->min->flags |= 8 - j;\n    }\n\n    for (i = length; i > 0 && max[i - 1] == 0xFF; --i) ;\n    if (!ASN1_BIT_STRING_set(aor->u.addressRange->max, max, i))\n        goto err;\n    aor->u.addressRange->max->flags &= ~7;\n    aor->u.addressRange->max->flags |= ASN1_STRING_FLAG_BITS_LEFT;\n    if (i > 0) {\n        unsigned char b = max[i - 1];\n        int j = 1;\n        while ((b & (0xFFU >> j)) != (0xFFU >> j))\n            ++j;\n        aor->u.addressRange->max->flags |= 8 - j;\n    }\n\n    *result = aor;\n    return 1;\n\n err:\n    IPAddressOrRange_free(aor);\n    return 0;\n}",
        "target": 0
    },
    {
        "func": "static int addr_validate_path_internal(X509_STORE_CTX *ctx,\n                                       STACK_OF(X509) *chain,\n                                       IPAddrBlocks *ext)\n{\n    IPAddrBlocks *child = NULL;\n    int i, j, ret = 1;\n    X509 *x;\n\n    OPENSSL_assert(chain != NULL && sk_X509_num(chain) > 0);\n    OPENSSL_assert(ctx != NULL || ext != NULL);\n    OPENSSL_assert(ctx == NULL || ctx->verify_cb != NULL);\n\n    /*\n     * Figure out where to start.  If we don't have an extension to\n     * check, we're done.  Otherwise, check canonical form and\n     * set up for walking up the chain.\n     */\n    if (ext != NULL) {\n        i = -1;\n        x = NULL;\n    } else {\n        i = 0;\n        x = sk_X509_value(chain, i);\n        OPENSSL_assert(x != NULL);\n        if ((ext = x->rfc3779_addr) == NULL)\n            goto done;\n    }\n    if (!X509v3_addr_is_canonical(ext))\n        validation_err(X509_V_ERR_INVALID_EXTENSION);\n    (void)sk_IPAddressFamily_set_cmp_func(ext, IPAddressFamily_cmp);\n    if ((child = sk_IPAddressFamily_dup(ext)) == NULL) {\n        X509V3err(X509V3_F_ADDR_VALIDATE_PATH_INTERNAL,\n                  ERR_R_MALLOC_FAILURE);\n        ctx->error = X509_V_ERR_OUT_OF_MEM;\n        ret = 0;\n        goto done;\n    }\n\n    /*\n     * Now walk up the chain.  No cert may list resources that its\n     * parent doesn't list.\n     */\n    for (i++; i < sk_X509_num(chain); i++) {\n        x = sk_X509_value(chain, i);\n        OPENSSL_assert(x != NULL);\n        if (!X509v3_addr_is_canonical(x->rfc3779_addr))\n            validation_err(X509_V_ERR_INVALID_EXTENSION);\n        if (x->rfc3779_addr == NULL) {\n            for (j = 0; j < sk_IPAddressFamily_num(child); j++) {\n                IPAddressFamily *fc = sk_IPAddressFamily_value(child, j);\n                if (fc->ipAddressChoice->type != IPAddressChoice_inherit) {\n                    validation_err(X509_V_ERR_UNNESTED_RESOURCE);\n                    break;\n                }\n            }\n            continue;\n        }\n        (void)sk_IPAddressFamily_set_cmp_func(x->rfc3779_addr,\n                                              IPAddressFamily_cmp);\n        for (j = 0; j < sk_IPAddressFamily_num(child); j++) {\n            IPAddressFamily *fc = sk_IPAddressFamily_value(child, j);\n            int k = sk_IPAddressFamily_find(x->rfc3779_addr, fc);\n            IPAddressFamily *fp =\n                sk_IPAddressFamily_value(x->rfc3779_addr, k);\n            if (fp == NULL) {\n                if (fc->ipAddressChoice->type ==\n                    IPAddressChoice_addressesOrRanges) {\n                    validation_err(X509_V_ERR_UNNESTED_RESOURCE);\n                    break;\n                }\n                continue;\n            }\n            if (fp->ipAddressChoice->type ==\n                IPAddressChoice_addressesOrRanges) {\n                if (fc->ipAddressChoice->type == IPAddressChoice_inherit\n                    || addr_contains(fp->ipAddressChoice->u.addressesOrRanges,\n                                     fc->ipAddressChoice->u.addressesOrRanges,\n                                     length_from_afi(X509v3_addr_get_afi(fc))))\n                    sk_IPAddressFamily_set(child, j, fp);\n                else\n                    validation_err(X509_V_ERR_UNNESTED_RESOURCE);\n            }\n        }\n    }\n\n    /*\n     * Trust anchor can't inherit.\n     */\n    OPENSSL_assert(x != NULL);\n    if (x->rfc3779_addr != NULL) {\n        for (j = 0; j < sk_IPAddressFamily_num(x->rfc3779_addr); j++) {\n            IPAddressFamily *fp =\n                sk_IPAddressFamily_value(x->rfc3779_addr, j);\n            if (fp->ipAddressChoice->type == IPAddressChoice_inherit\n                && sk_IPAddressFamily_find(child, fp) >= 0)\n                validation_err(X509_V_ERR_UNNESTED_RESOURCE);\n        }\n    }\n\n done:\n    sk_IPAddressFamily_free(child);\n    return ret;\n}",
        "target": 0
    },
    {
        "func": "int X509v3_addr_add_range(IPAddrBlocks *addr,\n                          const unsigned afi,\n                          const unsigned *safi,\n                          unsigned char *min, unsigned char *max)\n{\n    IPAddressOrRanges *aors = make_prefix_or_range(addr, afi, safi);\n    IPAddressOrRange *aor;\n    int length = length_from_afi(afi);\n    if (aors == NULL)\n        return 0;\n    if (!make_addressRange(&aor, min, max, length))\n        return 0;\n    if (sk_IPAddressOrRange_push(aors, aor))\n        return 1;\n    IPAddressOrRange_free(aor);\n    return 0;\n}",
        "target": 0
    },
    {
        "func": "static int IPAddressOrRanges_canonize(IPAddressOrRanges *aors,\n                                      const unsigned afi)\n{\n    int i, j, length = length_from_afi(afi);\n\n    /*\n     * Sort the IPAddressOrRanges sequence.\n     */\n    sk_IPAddressOrRange_sort(aors);\n\n    /*\n     * Clean up representation issues, punt on duplicates or overlaps.\n     */\n    for (i = 0; i < sk_IPAddressOrRange_num(aors) - 1; i++) {\n        IPAddressOrRange *a = sk_IPAddressOrRange_value(aors, i);\n        IPAddressOrRange *b = sk_IPAddressOrRange_value(aors, i + 1);\n        unsigned char a_min[ADDR_RAW_BUF_LEN], a_max[ADDR_RAW_BUF_LEN];\n        unsigned char b_min[ADDR_RAW_BUF_LEN], b_max[ADDR_RAW_BUF_LEN];\n\n        if (!extract_min_max(a, a_min, a_max, length) ||\n            !extract_min_max(b, b_min, b_max, length))\n            return 0;\n\n        /*\n         * Punt inverted ranges.\n         */\n        if (memcmp(a_min, a_max, length) > 0 ||\n            memcmp(b_min, b_max, length) > 0)\n            return 0;\n\n        /*\n         * Punt overlaps.\n         */\n        if (memcmp(a_max, b_min, length) >= 0)\n            return 0;\n\n        /*\n         * Merge if a and b are adjacent.  We check for\n         * adjacency by subtracting one from b_min first.\n         */\n        for (j = length - 1; j >= 0 && b_min[j]-- == 0x00; j--) ;\n        if (memcmp(a_max, b_min, length) == 0) {\n            IPAddressOrRange *merged;\n            if (!make_addressRange(&merged, a_min, b_max, length))\n                return 0;\n            (void)sk_IPAddressOrRange_set(aors, i, merged);\n            (void)sk_IPAddressOrRange_delete(aors, i + 1);\n            IPAddressOrRange_free(a);\n            IPAddressOrRange_free(b);\n            --i;\n            continue;\n        }\n    }\n\n    /*\n     * Check for inverted final range.\n     */\n    j = sk_IPAddressOrRange_num(aors) - 1;\n    {\n        IPAddressOrRange *a = sk_IPAddressOrRange_value(aors, j);\n        if (a != NULL && a->type == IPAddressOrRange_addressRange) {\n            unsigned char a_min[ADDR_RAW_BUF_LEN], a_max[ADDR_RAW_BUF_LEN];\n            if (!extract_min_max(a, a_min, a_max, length))\n                return 0;\n            if (memcmp(a_min, a_max, length) > 0)\n                return 0;\n        }\n    }\n\n    return 1;\n}",
        "target": 0
    },
    {
        "func": "static int length_from_afi(const unsigned afi)\n{\n    switch (afi) {\n    case IANA_AFI_IPV4:\n        return 4;\n    case IANA_AFI_IPV6:\n        return 16;\n    default:\n        return 0;\n    }\n}",
        "target": 0
    },
    {
        "func": "static int IPAddressOrRange_cmp(const IPAddressOrRange *a,\n                                const IPAddressOrRange *b, const int length)\n{\n    unsigned char addr_a[ADDR_RAW_BUF_LEN], addr_b[ADDR_RAW_BUF_LEN];\n    int prefixlen_a = 0, prefixlen_b = 0;\n    int r;\n\n    switch (a->type) {\n    case IPAddressOrRange_addressPrefix:\n        if (!addr_expand(addr_a, a->u.addressPrefix, length, 0x00))\n            return -1;\n        prefixlen_a = addr_prefixlen(a->u.addressPrefix);\n        break;\n    case IPAddressOrRange_addressRange:\n        if (!addr_expand(addr_a, a->u.addressRange->min, length, 0x00))\n            return -1;\n        prefixlen_a = length * 8;\n        break;\n    }\n\n    switch (b->type) {\n    case IPAddressOrRange_addressPrefix:\n        if (!addr_expand(addr_b, b->u.addressPrefix, length, 0x00))\n            return -1;\n        prefixlen_b = addr_prefixlen(b->u.addressPrefix);\n        break;\n    case IPAddressOrRange_addressRange:\n        if (!addr_expand(addr_b, b->u.addressRange->min, length, 0x00))\n            return -1;\n        prefixlen_b = length * 8;\n        break;\n    }\n\n    if ((r = memcmp(addr_a, addr_b, length)) != 0)\n        return r;\n    else\n        return prefixlen_a - prefixlen_b;\n}",
        "target": 0
    },
    {
        "func": "int X509v3_addr_get_range(IPAddressOrRange *aor,\n                          const unsigned afi,\n                          unsigned char *min,\n                          unsigned char *max, const int length)\n{\n    int afi_length = length_from_afi(afi);\n    if (aor == NULL || min == NULL || max == NULL ||\n        afi_length == 0 || length < afi_length ||\n        (aor->type != IPAddressOrRange_addressPrefix &&\n         aor->type != IPAddressOrRange_addressRange) ||\n        !extract_min_max(aor, min, max, afi_length))\n        return 0;\n\n    return afi_length;\n}",
        "target": 0
    },
    {
        "func": "static int addr_contains(IPAddressOrRanges *parent,\n                         IPAddressOrRanges *child, int length)\n{\n    unsigned char p_min[ADDR_RAW_BUF_LEN], p_max[ADDR_RAW_BUF_LEN];\n    unsigned char c_min[ADDR_RAW_BUF_LEN], c_max[ADDR_RAW_BUF_LEN];\n    int p, c;\n\n    if (child == NULL || parent == child)\n        return 1;\n    if (parent == NULL)\n        return 0;\n\n    p = 0;\n    for (c = 0; c < sk_IPAddressOrRange_num(child); c++) {\n        if (!extract_min_max(sk_IPAddressOrRange_value(child, c),\n                             c_min, c_max, length))\n            return -1;\n        for (;; p++) {\n            if (p >= sk_IPAddressOrRange_num(parent))\n                return 0;\n            if (!extract_min_max(sk_IPAddressOrRange_value(parent, p),\n                                 p_min, p_max, length))\n                return 0;\n            if (memcmp(p_max, c_max, length) < 0)\n                continue;\n            if (memcmp(p_min, c_min, length) > 0)\n                return 0;\n            break;\n        }\n    }\n\n    return 1;\n}",
        "target": 0
    },
    {
        "func": "static int v6IPAddressOrRange_cmp(const IPAddressOrRange *const *a,\n                                  const IPAddressOrRange *const *b)\n{\n    return IPAddressOrRange_cmp(*a, *b, 16);\n}",
        "target": 0
    },
    {
        "func": "static IPAddressFamily *make_IPAddressFamily(IPAddrBlocks *addr,\n                                             const unsigned afi,\n                                             const unsigned *safi)\n{\n    IPAddressFamily *f;\n    unsigned char key[3];\n    int keylen;\n    int i;\n\n    key[0] = (afi >> 8) & 0xFF;\n    key[1] = afi & 0xFF;\n    if (safi != NULL) {\n        key[2] = *safi & 0xFF;\n        keylen = 3;\n    } else {\n        keylen = 2;\n    }\n\n    for (i = 0; i < sk_IPAddressFamily_num(addr); i++) {\n        f = sk_IPAddressFamily_value(addr, i);\n        OPENSSL_assert(f->addressFamily->data != NULL);\n        if (f->addressFamily->length == keylen &&\n            !memcmp(f->addressFamily->data, key, keylen))\n            return f;\n    }\n\n    if ((f = IPAddressFamily_new()) == NULL)\n        goto err;\n    if (f->ipAddressChoice == NULL &&\n        (f->ipAddressChoice = IPAddressChoice_new()) == NULL)\n        goto err;\n    if (f->addressFamily == NULL &&\n        (f->addressFamily = ASN1_OCTET_STRING_new()) == NULL)\n        goto err;\n    if (!ASN1_OCTET_STRING_set(f->addressFamily, key, keylen))\n        goto err;\n    if (!sk_IPAddressFamily_push(addr, f))\n        goto err;\n\n    return f;\n\n err:\n    IPAddressFamily_free(f);\n    return NULL;\n}",
        "target": 0
    },
    {
        "func": "int X509v3_addr_is_canonical(IPAddrBlocks *addr)\n{\n    unsigned char a_min[ADDR_RAW_BUF_LEN], a_max[ADDR_RAW_BUF_LEN];\n    unsigned char b_min[ADDR_RAW_BUF_LEN], b_max[ADDR_RAW_BUF_LEN];\n    IPAddressOrRanges *aors;\n    int i, j, k;\n\n    /*\n     * Empty extension is canonical.\n     */\n    if (addr == NULL)\n        return 1;\n\n    /*\n     * Check whether the top-level list is in order.\n     */\n    for (i = 0; i < sk_IPAddressFamily_num(addr) - 1; i++) {\n        const IPAddressFamily *a = sk_IPAddressFamily_value(addr, i);\n        const IPAddressFamily *b = sk_IPAddressFamily_value(addr, i + 1);\n        if (IPAddressFamily_cmp(&a, &b) >= 0)\n            return 0;\n    }\n\n    /*\n     * Top level's ok, now check each address family.\n     */\n    for (i = 0; i < sk_IPAddressFamily_num(addr); i++) {\n        IPAddressFamily *f = sk_IPAddressFamily_value(addr, i);\n        int length = length_from_afi(X509v3_addr_get_afi(f));\n\n        /*\n         * Inheritance is canonical.  Anything other than inheritance or\n         * a SEQUENCE OF IPAddressOrRange is an ASN.1 error or something.\n         */\n        if (f == NULL || f->ipAddressChoice == NULL)\n            return 0;\n        switch (f->ipAddressChoice->type) {\n        case IPAddressChoice_inherit:\n            continue;\n        case IPAddressChoice_addressesOrRanges:\n            break;\n        default:\n            return 0;\n        }\n\n        /*\n         * It's an IPAddressOrRanges sequence, check it.\n         */\n        aors = f->ipAddressChoice->u.addressesOrRanges;\n        if (sk_IPAddressOrRange_num(aors) == 0)\n            return 0;\n        for (j = 0; j < sk_IPAddressOrRange_num(aors) - 1; j++) {\n            IPAddressOrRange *a = sk_IPAddressOrRange_value(aors, j);\n            IPAddressOrRange *b = sk_IPAddressOrRange_value(aors, j + 1);\n\n            if (!extract_min_max(a, a_min, a_max, length) ||\n                !extract_min_max(b, b_min, b_max, length))\n                return 0;\n\n            /*\n             * Punt misordered list, overlapping start, or inverted range.\n             */\n            if (memcmp(a_min, b_min, length) >= 0 ||\n                memcmp(a_min, a_max, length) > 0 ||\n                memcmp(b_min, b_max, length) > 0)\n                return 0;\n\n            /*\n             * Punt if adjacent or overlapping.  Check for adjacency by\n             * subtracting one from b_min first.\n             */\n            for (k = length - 1; k >= 0 && b_min[k]-- == 0x00; k--) ;\n            if (memcmp(a_max, b_min, length) >= 0)\n                return 0;\n\n            /*\n             * Check for range that should be expressed as a prefix.\n             */\n            if (a->type == IPAddressOrRange_addressRange &&\n                range_should_be_prefix(a_min, a_max, length) >= 0)\n                return 0;\n        }\n\n        /*\n         * Check range to see if it's inverted or should be a\n         * prefix.\n         */\n        j = sk_IPAddressOrRange_num(aors) - 1;\n        {\n            IPAddressOrRange *a = sk_IPAddressOrRange_value(aors, j);\n            if (a != NULL && a->type == IPAddressOrRange_addressRange) {\n                if (!extract_min_max(a, a_min, a_max, length))\n                    return 0;\n                if (memcmp(a_min, a_max, length) > 0 ||\n                    range_should_be_prefix(a_min, a_max, length) >= 0)\n                    return 0;\n            }\n        }\n    }\n\n    /*\n     * If we made it through all that, we're happy.\n     */\n    return 1;\n}",
        "target": 0
    },
    {
        "func": "unsigned int X509v3_addr_get_afi(const IPAddressFamily *f)\n{\n    if (f == NULL\n            || f->addressFamily == NULL\n            || f->addressFamily->data == NULL\n            || f->addressFamily->length < 2)\n        return 0;\n    return (f->addressFamily->data[0] << 8) | f->addressFamily->data[1];\n}",
        "target": 0
    },
    {
        "func": "int X509v3_addr_add_prefix(IPAddrBlocks *addr,\n                           const unsigned afi,\n                           const unsigned *safi,\n                           unsigned char *a, const int prefixlen)\n{\n    IPAddressOrRanges *aors = make_prefix_or_range(addr, afi, safi);\n    IPAddressOrRange *aor;\n    if (aors == NULL || !make_addressPrefix(&aor, a, prefixlen))\n        return 0;\n    if (sk_IPAddressOrRange_push(aors, aor))\n        return 1;\n    IPAddressOrRange_free(aor);\n    return 0;\n}",
        "target": 0
    },
    {
        "func": "static int i2r_IPAddrBlocks(const X509V3_EXT_METHOD *method,\n                            void *ext, BIO *out, int indent)\n{\n    const IPAddrBlocks *addr = ext;\n    int i;\n    for (i = 0; i < sk_IPAddressFamily_num(addr); i++) {\n        IPAddressFamily *f = sk_IPAddressFamily_value(addr, i);\n        const unsigned int afi = X509v3_addr_get_afi(f);\n        switch (afi) {\n        case IANA_AFI_IPV4:\n            BIO_printf(out, \"%*sIPv4\", indent, \"\");\n            break;\n        case IANA_AFI_IPV6:\n            BIO_printf(out, \"%*sIPv6\", indent, \"\");\n            break;\n        default:\n            BIO_printf(out, \"%*sUnknown AFI %u\", indent, \"\", afi);\n            break;\n        }\n        if (f->addressFamily->length > 2) {\n            switch (f->addressFamily->data[2]) {\n            case 1:\n                BIO_puts(out, \" (Unicast)\");\n                break;\n            case 2:\n                BIO_puts(out, \" (Multicast)\");\n                break;\n            case 3:\n                BIO_puts(out, \" (Unicast/Multicast)\");\n                break;\n            case 4:\n                BIO_puts(out, \" (MPLS)\");\n                break;\n            case 64:\n                BIO_puts(out, \" (Tunnel)\");\n                break;\n            case 65:\n                BIO_puts(out, \" (VPLS)\");\n                break;\n            case 66:\n                BIO_puts(out, \" (BGP MDT)\");\n                break;\n            case 128:\n                BIO_puts(out, \" (MPLS-labeled VPN)\");\n                break;\n            default:\n                BIO_printf(out, \" (Unknown SAFI %u)\",\n                           (unsigned)f->addressFamily->data[2]);\n                break;\n            }\n        }\n        switch (f->ipAddressChoice->type) {\n        case IPAddressChoice_inherit:\n            BIO_puts(out, \": inherit\\n\");\n            break;\n        case IPAddressChoice_addressesOrRanges:\n            BIO_puts(out, \":\\n\");\n            if (!i2r_IPAddressOrRanges(out,\n                                       indent + 2,\n                                       f->ipAddressChoice->\n                                       u.addressesOrRanges, afi))\n                return 0;\n            break;\n        }\n    }\n    return 1;\n}",
        "target": 0
    },
    {
        "func": "static int i2r_address(BIO *out,\n                       const unsigned afi,\n                       const unsigned char fill, const ASN1_BIT_STRING *bs)\n{\n    unsigned char addr[ADDR_RAW_BUF_LEN];\n    int i, n;\n\n    if (bs->length < 0)\n        return 0;\n    switch (afi) {\n    case IANA_AFI_IPV4:\n        if (!addr_expand(addr, bs, 4, fill))\n            return 0;\n        BIO_printf(out, \"%d.%d.%d.%d\", addr[0], addr[1], addr[2], addr[3]);\n        break;\n    case IANA_AFI_IPV6:\n        if (!addr_expand(addr, bs, 16, fill))\n            return 0;\n        for (n = 16; n > 1 && addr[n - 1] == 0x00 && addr[n - 2] == 0x00;\n             n -= 2) ;\n        for (i = 0; i < n; i += 2)\n            BIO_printf(out, \"%x%s\", (addr[i] << 8) | addr[i + 1],\n                       (i < 14 ? \":\" : \"\"));\n        if (i < 16)\n            BIO_puts(out, \":\");\n        if (i == 0)\n            BIO_puts(out, \":\");\n        break;\n    default:\n        for (i = 0; i < bs->length; i++)\n            BIO_printf(out, \"%s%02x\", (i > 0 ? \":\" : \"\"), bs->data[i]);\n        BIO_printf(out, \"[%d]\", (int)(bs->flags & 7));\n        break;\n    }\n    return 1;\n}",
        "target": 0
    },
    {
        "func": "int X509v3_addr_canonize(IPAddrBlocks *addr)\n{\n    int i;\n    for (i = 0; i < sk_IPAddressFamily_num(addr); i++) {\n        IPAddressFamily *f = sk_IPAddressFamily_value(addr, i);\n        if (f->ipAddressChoice->type == IPAddressChoice_addressesOrRanges &&\n            !IPAddressOrRanges_canonize(f->ipAddressChoice->\n                                        u.addressesOrRanges,\n                                        X509v3_addr_get_afi(f)))\n            return 0;\n    }\n    (void)sk_IPAddressFamily_set_cmp_func(addr, IPAddressFamily_cmp);\n    sk_IPAddressFamily_sort(addr);\n    OPENSSL_assert(X509v3_addr_is_canonical(addr));\n    return 1;\n}",
        "target": 0
    },
    {
        "func": "static int v4IPAddressOrRange_cmp(const IPAddressOrRange *const *a,\n                                  const IPAddressOrRange *const *b)\n{\n    return IPAddressOrRange_cmp(*a, *b, 4);\n}",
        "target": 0
    },
    {
        "func": "static int range_should_be_prefix(const unsigned char *min,\n                                  const unsigned char *max, const int length)\n{\n    unsigned char mask;\n    int i, j;\n\n    OPENSSL_assert(memcmp(min, max, length) <= 0);\n    for (i = 0; i < length && min[i] == max[i]; i++) ;\n    for (j = length - 1; j >= 0 && min[j] == 0x00 && max[j] == 0xFF; j--) ;\n    if (i < j)\n        return -1;\n    if (i > j)\n        return i * 8;\n    mask = min[i] ^ max[i];\n    switch (mask) {\n    case 0x01:\n        j = 7;\n        break;\n    case 0x03:\n        j = 6;\n        break;\n    case 0x07:\n        j = 5;\n        break;\n    case 0x0F:\n        j = 4;\n        break;\n    case 0x1F:\n        j = 3;\n        break;\n    case 0x3F:\n        j = 2;\n        break;\n    case 0x7F:\n        j = 1;\n        break;\n    default:\n        return -1;\n    }\n    if ((min[i] & mask) != 0 || (max[i] & mask) != mask)\n        return -1;\n    else\n        return i * 8 + j;\n}",
        "target": 0
    },
    {
        "func": "static int extract_min_max(IPAddressOrRange *aor,\n                           unsigned char *min, unsigned char *max, int length)\n{\n    if (aor == NULL || min == NULL || max == NULL)\n        return 0;\n    switch (aor->type) {\n    case IPAddressOrRange_addressPrefix:\n        return (addr_expand(min, aor->u.addressPrefix, length, 0x00) &&\n                addr_expand(max, aor->u.addressPrefix, length, 0xFF));\n    case IPAddressOrRange_addressRange:\n        return (addr_expand(min, aor->u.addressRange->min, length, 0x00) &&\n                addr_expand(max, aor->u.addressRange->max, length, 0xFF));\n    }\n    return 0;\n}",
        "target": 0
    },
    {
        "func": "static int addr_expand(unsigned char *addr,\n                       const ASN1_BIT_STRING *bs,\n                       const int length, const unsigned char fill)\n{\n    if (bs->length < 0 || bs->length > length)\n        return 0;\n    if (bs->length > 0) {\n        memcpy(addr, bs->data, bs->length);\n        if ((bs->flags & 7) != 0) {\n            unsigned char mask = 0xFF >> (8 - (bs->flags & 7));\n            if (fill == 0)\n                addr[bs->length - 1] &= ~mask;\n            else\n                addr[bs->length - 1] |= mask;\n        }\n    }\n    memset(addr + bs->length, fill, length - bs->length);\n    return 1;\n}",
        "target": 0
    },
    {
        "func": "static int IPAddressFamily_cmp(const IPAddressFamily *const *a_,\n                               const IPAddressFamily *const *b_)\n{\n    const ASN1_OCTET_STRING *a = (*a_)->addressFamily;\n    const ASN1_OCTET_STRING *b = (*b_)->addressFamily;\n    int len = ((a->length <= b->length) ? a->length : b->length);\n    int cmp = memcmp(a->data, b->data, len);\n    return cmp ? cmp : a->length - b->length;\n}",
        "target": 0
    },
    {
        "func": "static IPAddressOrRanges *make_prefix_or_range(IPAddrBlocks *addr,\n                                               const unsigned afi,\n                                               const unsigned *safi)\n{\n    IPAddressFamily *f = make_IPAddressFamily(addr, afi, safi);\n    IPAddressOrRanges *aors = NULL;\n\n    if (f == NULL ||\n        f->ipAddressChoice == NULL ||\n        (f->ipAddressChoice->type == IPAddressChoice_inherit &&\n         f->ipAddressChoice->u.inherit != NULL))\n        return NULL;\n    if (f->ipAddressChoice->type == IPAddressChoice_addressesOrRanges)\n        aors = f->ipAddressChoice->u.addressesOrRanges;\n    if (aors != NULL)\n        return aors;\n    if ((aors = sk_IPAddressOrRange_new_null()) == NULL)\n        return NULL;\n    switch (afi) {\n    case IANA_AFI_IPV4:\n        (void)sk_IPAddressOrRange_set_cmp_func(aors, v4IPAddressOrRange_cmp);\n        break;\n    case IANA_AFI_IPV6:\n        (void)sk_IPAddressOrRange_set_cmp_func(aors, v6IPAddressOrRange_cmp);\n        break;\n    }\n    f->ipAddressChoice->type = IPAddressChoice_addressesOrRanges;\n    f->ipAddressChoice->u.addressesOrRanges = aors;\n    return aors;\n}",
        "target": 0
    },
    {
        "func": "int X509v3_addr_add_inherit(IPAddrBlocks *addr,\n                            const unsigned afi, const unsigned *safi)\n{\n    IPAddressFamily *f = make_IPAddressFamily(addr, afi, safi);\n    if (f == NULL ||\n        f->ipAddressChoice == NULL ||\n        (f->ipAddressChoice->type == IPAddressChoice_addressesOrRanges &&\n         f->ipAddressChoice->u.addressesOrRanges != NULL))\n        return 0;\n    if (f->ipAddressChoice->type == IPAddressChoice_inherit &&\n        f->ipAddressChoice->u.inherit != NULL)\n        return 1;\n    if (f->ipAddressChoice->u.inherit == NULL &&\n        (f->ipAddressChoice->u.inherit = ASN1_NULL_new()) == NULL)\n        return 0;\n    f->ipAddressChoice->type = IPAddressChoice_inherit;\n    return 1;\n}",
        "target": 0
    },
    {
        "func": "int X509v3_addr_subset(IPAddrBlocks *a, IPAddrBlocks *b)\n{\n    int i;\n    if (a == NULL || a == b)\n        return 1;\n    if (b == NULL || X509v3_addr_inherits(a) || X509v3_addr_inherits(b))\n        return 0;\n    (void)sk_IPAddressFamily_set_cmp_func(b, IPAddressFamily_cmp);\n    for (i = 0; i < sk_IPAddressFamily_num(a); i++) {\n        IPAddressFamily *fa = sk_IPAddressFamily_value(a, i);\n        int j = sk_IPAddressFamily_find(b, fa);\n        IPAddressFamily *fb;\n        fb = sk_IPAddressFamily_value(b, j);\n        if (fb == NULL)\n            return 0;\n        if (!addr_contains(fb->ipAddressChoice->u.addressesOrRanges,\n                           fa->ipAddressChoice->u.addressesOrRanges,\n                           length_from_afi(X509v3_addr_get_afi(fb))))\n            return 0;\n    }\n    return 1;\n}",
        "target": 0
    },
    {
        "func": "int X509v3_addr_inherits(IPAddrBlocks *addr)\n{\n    int i;\n    if (addr == NULL)\n        return 0;\n    for (i = 0; i < sk_IPAddressFamily_num(addr); i++) {\n        IPAddressFamily *f = sk_IPAddressFamily_value(addr, i);\n        if (f->ipAddressChoice->type == IPAddressChoice_inherit)\n            return 1;\n    }\n    return 0;\n}",
        "target": 0
    },
    {
        "func": "static int make_addressPrefix(IPAddressOrRange **result,\n                              unsigned char *addr, const int prefixlen)\n{\n    int bytelen = (prefixlen + 7) / 8, bitlen = prefixlen % 8;\n    IPAddressOrRange *aor = IPAddressOrRange_new();\n\n    if (aor == NULL)\n        return 0;\n    aor->type = IPAddressOrRange_addressPrefix;\n    if (aor->u.addressPrefix == NULL &&\n        (aor->u.addressPrefix = ASN1_BIT_STRING_new()) == NULL)\n        goto err;\n    if (!ASN1_BIT_STRING_set(aor->u.addressPrefix, addr, bytelen))\n        goto err;\n    aor->u.addressPrefix->flags &= ~7;\n    aor->u.addressPrefix->flags |= ASN1_STRING_FLAG_BITS_LEFT;\n    if (bitlen > 0) {\n        aor->u.addressPrefix->data[bytelen - 1] &= ~(0xFF >> bitlen);\n        aor->u.addressPrefix->flags |= 8 - bitlen;\n    }\n\n    *result = aor;\n    return 1;\n\n err:\n    IPAddressOrRange_free(aor);\n    return 0;\n}",
        "target": 0
    },
    {
        "func": "int X509v3_addr_validate_path(X509_STORE_CTX *ctx)\n{\n    return addr_validate_path_internal(ctx, ctx->chain, NULL);\n}",
        "target": 0
    },
    {
        "func": "static void *v2i_IPAddrBlocks(const struct v3_ext_method *method,\n                              struct v3_ext_ctx *ctx,\n                              STACK_OF(CONF_VALUE) *values)\n{\n    static const char v4addr_chars[] = \"0123456789.\";\n    static const char v6addr_chars[] = \"0123456789.:abcdefABCDEF\";\n    IPAddrBlocks *addr = NULL;\n    char *s = NULL, *t;\n    int i;\n\n    if ((addr = sk_IPAddressFamily_new(IPAddressFamily_cmp)) == NULL) {\n        X509V3err(X509V3_F_V2I_IPADDRBLOCKS, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n\n    for (i = 0; i < sk_CONF_VALUE_num(values); i++) {\n        CONF_VALUE *val = sk_CONF_VALUE_value(values, i);\n        unsigned char min[ADDR_RAW_BUF_LEN], max[ADDR_RAW_BUF_LEN];\n        unsigned afi, *safi = NULL, safi_;\n        const char *addr_chars = NULL;\n        int prefixlen, i1, i2, delim, length;\n\n        if (!name_cmp(val->name, \"IPv4\")) {\n            afi = IANA_AFI_IPV4;\n        } else if (!name_cmp(val->name, \"IPv6\")) {\n            afi = IANA_AFI_IPV6;\n        } else if (!name_cmp(val->name, \"IPv4-SAFI\")) {\n            afi = IANA_AFI_IPV4;\n            safi = &safi_;\n        } else if (!name_cmp(val->name, \"IPv6-SAFI\")) {\n            afi = IANA_AFI_IPV6;\n            safi = &safi_;\n        } else {\n            X509V3err(X509V3_F_V2I_IPADDRBLOCKS,\n                      X509V3_R_EXTENSION_NAME_ERROR);\n            X509V3_conf_err(val);\n            goto err;\n        }\n\n        switch (afi) {\n        case IANA_AFI_IPV4:\n            addr_chars = v4addr_chars;\n            break;\n        case IANA_AFI_IPV6:\n            addr_chars = v6addr_chars;\n            break;\n        }\n\n        length = length_from_afi(afi);\n\n        /*\n         * Handle SAFI, if any, and OPENSSL_strdup() so we can null-terminate\n         * the other input values.\n         */\n        if (safi != NULL) {\n            *safi = strtoul(val->value, &t, 0);\n            t += strspn(t, \" \\t\");\n            if (*safi > 0xFF || *t++ != ':') {\n                X509V3err(X509V3_F_V2I_IPADDRBLOCKS, X509V3_R_INVALID_SAFI);\n                X509V3_conf_err(val);\n                goto err;\n            }\n            t += strspn(t, \" \\t\");\n            s = OPENSSL_strdup(t);\n        } else {\n            s = OPENSSL_strdup(val->value);\n        }\n        if (s == NULL) {\n            X509V3err(X509V3_F_V2I_IPADDRBLOCKS, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n\n        /*\n         * Check for inheritance.  Not worth additional complexity to\n         * optimize this (seldom-used) case.\n         */\n        if (strcmp(s, \"inherit\") == 0) {\n            if (!X509v3_addr_add_inherit(addr, afi, safi)) {\n                X509V3err(X509V3_F_V2I_IPADDRBLOCKS,\n                          X509V3_R_INVALID_INHERITANCE);\n                X509V3_conf_err(val);\n                goto err;\n            }\n            OPENSSL_free(s);\n            s = NULL;\n            continue;\n        }\n\n        i1 = strspn(s, addr_chars);\n        i2 = i1 + strspn(s + i1, \" \\t\");\n        delim = s[i2++];\n        s[i1] = '\\0';\n\n        if (a2i_ipadd(min, s) != length) {\n            X509V3err(X509V3_F_V2I_IPADDRBLOCKS, X509V3_R_INVALID_IPADDRESS);\n            X509V3_conf_err(val);\n            goto err;\n        }\n\n        switch (delim) {\n        case '/':\n            prefixlen = (int)strtoul(s + i2, &t, 10);\n            if (t == s + i2 || *t != '\\0') {\n                X509V3err(X509V3_F_V2I_IPADDRBLOCKS,\n                          X509V3_R_EXTENSION_VALUE_ERROR);\n                X509V3_conf_err(val);\n                goto err;\n            }\n            if (!X509v3_addr_add_prefix(addr, afi, safi, min, prefixlen)) {\n                X509V3err(X509V3_F_V2I_IPADDRBLOCKS, ERR_R_MALLOC_FAILURE);\n                goto err;\n            }\n            break;\n        case '-':\n            i1 = i2 + strspn(s + i2, \" \\t\");\n            i2 = i1 + strspn(s + i1, addr_chars);\n            if (i1 == i2 || s[i2] != '\\0') {\n                X509V3err(X509V3_F_V2I_IPADDRBLOCKS,\n                          X509V3_R_EXTENSION_VALUE_ERROR);\n                X509V3_conf_err(val);\n                goto err;\n            }\n            if (a2i_ipadd(max, s + i1) != length) {\n                X509V3err(X509V3_F_V2I_IPADDRBLOCKS,\n                          X509V3_R_INVALID_IPADDRESS);\n                X509V3_conf_err(val);\n                goto err;\n            }\n            if (memcmp(min, max, length_from_afi(afi)) > 0) {\n                X509V3err(X509V3_F_V2I_IPADDRBLOCKS,\n                          X509V3_R_EXTENSION_VALUE_ERROR);\n                X509V3_conf_err(val);\n                goto err;\n            }\n            if (!X509v3_addr_add_range(addr, afi, safi, min, max)) {\n                X509V3err(X509V3_F_V2I_IPADDRBLOCKS, ERR_R_MALLOC_FAILURE);\n                goto err;\n            }\n            break;\n        case '\\0':\n            if (!X509v3_addr_add_prefix(addr, afi, safi, min, length * 8)) {\n                X509V3err(X509V3_F_V2I_IPADDRBLOCKS, ERR_R_MALLOC_FAILURE);\n                goto err;\n            }\n            break;\n        default:\n            X509V3err(X509V3_F_V2I_IPADDRBLOCKS,\n                      X509V3_R_EXTENSION_VALUE_ERROR);\n            X509V3_conf_err(val);\n            goto err;\n        }\n\n        OPENSSL_free(s);\n        s = NULL;\n    }\n\n    /*\n     * Canonize the result, then we're done.\n     */\n    if (!X509v3_addr_canonize(addr))\n        goto err;\n    return addr;\n\n err:\n    OPENSSL_free(s);\n    sk_IPAddressFamily_pop_free(addr, IPAddressFamily_free);\n    return NULL;\n}",
        "target": 0
    },
    {
        "func": "void bn_mul_part_recursive(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n,\n\t     int tna, int tnb, BN_ULONG *t)\n\t{\n\tint i,j,n2=n*2;\n\tint c1,c2,neg,zero;\n\tBN_ULONG ln,lo,*p;\n\n# ifdef BN_COUNT\n\tfprintf(stderr,\" bn_mul_part_recursive (%d%+d) * (%d%+d)\\n\",\n\t\tn, tna, n, tnb);\n# endif\n\tif (n < 8)\n\t\t{\n\t\tbn_mul_normal(r,a,n+tna,b,n+tnb);\n\t\treturn;\n\t\t}\n\n\t/* r=(a[0]-a[1])*(b[1]-b[0]) */\n\tc1=bn_cmp_part_words(a,&(a[n]),tna,n-tna);\n\tc2=bn_cmp_part_words(&(b[n]),b,tnb,tnb-n);\n\tzero=neg=0;\n\tswitch (c1*3+c2)\n\t\t{\n\tcase -4:\n\t\tbn_sub_part_words(t,      &(a[n]),a,      tna,tna-n); /* - */\n\t\tbn_sub_part_words(&(t[n]),b,      &(b[n]),tnb,n-tnb); /* - */\n\t\tbreak;\n\tcase -3:\n\t\tzero=1;\n\t\t/* break; */\n\tcase -2:\n\t\tbn_sub_part_words(t,      &(a[n]),a,      tna,tna-n); /* - */\n\t\tbn_sub_part_words(&(t[n]),&(b[n]),b,      tnb,tnb-n); /* + */\n\t\tneg=1;\n\t\tbreak;\n\tcase -1:\n\tcase 0:\n\tcase 1:\n\t\tzero=1;\n\t\t/* break; */\n\tcase 2:\n\t\tbn_sub_part_words(t,      a,      &(a[n]),tna,n-tna); /* + */\n\t\tbn_sub_part_words(&(t[n]),b,      &(b[n]),tnb,n-tnb); /* - */\n\t\tneg=1;\n\t\tbreak;\n\tcase 3:\n\t\tzero=1;\n\t\t/* break; */\n\tcase 4:\n\t\tbn_sub_part_words(t,      a,      &(a[n]),tna,n-tna);\n\t\tbn_sub_part_words(&(t[n]),&(b[n]),b,      tnb,tnb-n);\n\t\tbreak;\n\t\t}\n\t\t/* The zero case isn't yet implemented here. The speedup\n\t\t   would probably be negligible. */\n# if 0\n\tif (n == 4)\n\t\t{\n\t\tbn_mul_comba4(&(t[n2]),t,&(t[n]));\n\t\tbn_mul_comba4(r,a,b);\n\t\tbn_mul_normal(&(r[n2]),&(a[n]),tn,&(b[n]),tn);\n\t\tmemset(&(r[n2+tn*2]),0,sizeof(BN_ULONG)*(n2-tn*2));\n\t\t}\n\telse\n# endif\n\tif (n == 8)\n\t\t{\n\t\tbn_mul_comba8(&(t[n2]),t,&(t[n]));\n\t\tbn_mul_comba8(r,a,b);\n\t\tbn_mul_normal(&(r[n2]),&(a[n]),tna,&(b[n]),tnb);\n\t\tmemset(&(r[n2+tna+tnb]),0,sizeof(BN_ULONG)*(n2-tna-tnb));\n\t\t}\n\telse\n\t\t{\n\t\tp= &(t[n2*2]);\n\t\tbn_mul_recursive(&(t[n2]),t,&(t[n]),n,0,0,p);\n\t\tbn_mul_recursive(r,a,b,n,0,0,p);\n\t\ti=n/2;\n\t\t/* If there is only a bottom half to the number,\n\t\t * just do it */\n\t\tif (tna > tnb)\n\t\t\tj = tna - i;\n\t\telse\n\t\t\tj = tnb - i;\n\t\tif (j == 0)\n\t\t\t{\n\t\t\tbn_mul_recursive(&(r[n2]),&(a[n]),&(b[n]),\n\t\t\t\ti,tna-i,tnb-i,p);\n\t\t\tmemset(&(r[n2+i*2]),0,sizeof(BN_ULONG)*(n2-i*2));\n\t\t\t}\n\t\telse if (j > 0) /* eg, n == 16, i == 8 and tn == 11 */\n\t\t\t\t{\n\t\t\t\tbn_mul_part_recursive(&(r[n2]),&(a[n]),&(b[n]),\n\t\t\t\t\ti,tna-i,tnb-i,p);\n\t\t\t\tmemset(&(r[n2+tna+tnb]),0,\n\t\t\t\t\tsizeof(BN_ULONG)*(n2-tna-tnb));\n\t\t\t\t}\n\t\telse /* (j < 0) eg, n == 16, i == 8 and tn == 5 */\n\t\t\t{\n\t\t\tmemset(&(r[n2]),0,sizeof(BN_ULONG)*n2);\n\t\t\tif (tna < BN_MUL_RECURSIVE_SIZE_NORMAL\n\t\t\t\t&& tnb < BN_MUL_RECURSIVE_SIZE_NORMAL)\n\t\t\t\t{\n\t\t\t\tbn_mul_normal(&(r[n2]),&(a[n]),tna,&(b[n]),tnb);\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tfor (;;)\n\t\t\t\t\t{\n\t\t\t\t\ti/=2;\n\t\t\t\t\t/* these simplified conditions work\n\t\t\t\t\t * exclusively because difference\n\t\t\t\t\t * between tna and tnb is 1 or 0 */\n\t\t\t\t\tif (i < tna || i < tnb)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tbn_mul_part_recursive(&(r[n2]),\n\t\t\t\t\t\t\t&(a[n]),&(b[n]),\n\t\t\t\t\t\t\ti,tna-i,tnb-i,p);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (i == tna || i == tnb)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tbn_mul_recursive(&(r[n2]),\n\t\t\t\t\t\t\t&(a[n]),&(b[n]),\n\t\t\t\t\t\t\ti,tna-i,tnb-i,p);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t/* t[32] holds (a[0]-a[1])*(b[1]-b[0]), c1 is the sign\n\t * r[10] holds (a[0]*b[0])\n\t * r[32] holds (b[1]*b[1])\n\t */\n\n\tc1=(int)(bn_add_words(t,r,&(r[n2]),n2));\n\n\tif (neg) /* if t[32] is negative */\n\t\t{\n\t\tc1-=(int)(bn_sub_words(&(t[n2]),t,&(t[n2]),n2));\n\t\t}\n\telse\n\t\t{\n\t\t/* Might have a carry */\n\t\tc1+=(int)(bn_add_words(&(t[n2]),&(t[n2]),t,n2));\n\t\t}\n\n\t/* t[32] holds (a[0]-a[1])*(b[1]-b[0])+(a[0]*b[0])+(a[1]*b[1])\n\t * r[10] holds (a[0]*b[0])\n\t * r[32] holds (b[1]*b[1])\n\t * c1 holds the carry bits\n\t */\n\tc1+=(int)(bn_add_words(&(r[n]),&(r[n]),&(t[n2]),n2));\n\tif (c1)\n\t\t{\n\t\tp= &(r[n+n2]);\n\t\tlo= *p;\n\t\tln=(lo+c1)&BN_MASK2;\n\t\t*p=ln;\n\n\t\t/* The overflow will stop before we over write\n\t\t * words we should not overwrite */\n\t\tif (ln < (BN_ULONG)c1)\n\t\t\t{\n\t\t\tdo\t{\n\t\t\t\tp++;\n\t\t\t\tlo= *p;\n\t\t\t\tln=(lo+1)&BN_MASK2;\n\t\t\t\t*p=ln;\n\t\t\t\t} while (ln == 0);\n\t\t\t}\n\t\t}\n\t}",
        "target": 0
    },
    {
        "func": "BN_ULONG bn_add_part_words(BN_ULONG *r,\n\tconst BN_ULONG *a, const BN_ULONG *b,\n\tint cl, int dl)\n\t{\n\tBN_ULONG c, l, t;\n\n\tassert(cl >= 0);\n\tc = bn_add_words(r, a, b, cl);\n\n\tif (dl == 0)\n\t\treturn c;\n\n\tr += cl;\n\ta += cl;\n\tb += cl;\n\n\tif (dl < 0)\n\t\t{\n\t\tint save_dl = dl;\n#ifdef BN_COUNT\n\t\tfprintf(stderr, \"  bn_add_part_words %d + %d (dl < 0, c = %d)\\n\", cl, dl, c);\n#endif\n\t\twhile (c)\n\t\t\t{\n\t\t\tl=(c+b[0])&BN_MASK2;\n\t\t\tc=(l < c);\n\t\t\tr[0]=l;\n\t\t\tif (++dl >= 0) break;\n\n\t\t\tl=(c+b[1])&BN_MASK2;\n\t\t\tc=(l < c);\n\t\t\tr[1]=l;\n\t\t\tif (++dl >= 0) break;\n\n\t\t\tl=(c+b[2])&BN_MASK2;\n\t\t\tc=(l < c);\n\t\t\tr[2]=l;\n\t\t\tif (++dl >= 0) break;\n\n\t\t\tl=(c+b[3])&BN_MASK2;\n\t\t\tc=(l < c);\n\t\t\tr[3]=l;\n\t\t\tif (++dl >= 0) break;\n\n\t\t\tsave_dl = dl;\n\t\t\tb+=4;\n\t\t\tr+=4;\n\t\t\t}\n\t\tif (dl < 0)\n\t\t\t{\n#ifdef BN_COUNT\n\t\t\tfprintf(stderr, \"  bn_add_part_words %d + %d (dl < 0, c == 0)\\n\", cl, dl);\n#endif\n\t\t\tif (save_dl < dl)\n\t\t\t\t{\n\t\t\t\tswitch (dl - save_dl)\n\t\t\t\t\t{\n\t\t\t\tcase 1:\n\t\t\t\t\tr[1] = b[1];\n\t\t\t\t\tif (++dl >= 0) break;\n\t\t\t\tcase 2:\n\t\t\t\t\tr[2] = b[2];\n\t\t\t\t\tif (++dl >= 0) break;\n\t\t\t\tcase 3:\n\t\t\t\t\tr[3] = b[3];\n\t\t\t\t\tif (++dl >= 0) break;\n\t\t\t\t\t}\n\t\t\t\tb += 4;\n\t\t\t\tr += 4;\n\t\t\t\t}\n\t\t\t}\n\t\tif (dl < 0)\n\t\t\t{\n#ifdef BN_COUNT\n\t\t\tfprintf(stderr, \"  bn_add_part_words %d + %d (dl < 0, copy)\\n\", cl, dl);\n#endif\n\t\t\tfor(;;)\n\t\t\t\t{\n\t\t\t\tr[0] = b[0];\n\t\t\t\tif (++dl >= 0) break;\n\t\t\t\tr[1] = b[1];\n\t\t\t\tif (++dl >= 0) break;\n\t\t\t\tr[2] = b[2];\n\t\t\t\tif (++dl >= 0) break;\n\t\t\t\tr[3] = b[3];\n\t\t\t\tif (++dl >= 0) break;\n\n\t\t\t\tb += 4;\n\t\t\t\tr += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\telse\n\t\t{\n\t\tint save_dl = dl;\n#ifdef BN_COUNT\n\t\tfprintf(stderr, \"  bn_add_part_words %d + %d (dl > 0)\\n\", cl, dl);\n#endif\n\t\twhile (c)\n\t\t\t{\n\t\t\tt=(a[0]+c)&BN_MASK2;\n\t\t\tc=(t < c);\n\t\t\tr[0]=t;\n\t\t\tif (--dl <= 0) break;\n\n\t\t\tt=(a[1]+c)&BN_MASK2;\n\t\t\tc=(t < c);\n\t\t\tr[1]=t;\n\t\t\tif (--dl <= 0) break;\n\n\t\t\tt=(a[2]+c)&BN_MASK2;\n\t\t\tc=(t < c);\n\t\t\tr[2]=t;\n\t\t\tif (--dl <= 0) break;\n\n\t\t\tt=(a[3]+c)&BN_MASK2;\n\t\t\tc=(t < c);\n\t\t\tr[3]=t;\n\t\t\tif (--dl <= 0) break;\n\n\t\t\tsave_dl = dl;\n\t\t\ta+=4;\n\t\t\tr+=4;\n\t\t\t}\n#ifdef BN_COUNT\n\t\tfprintf(stderr, \"  bn_add_part_words %d + %d (dl > 0, c == 0)\\n\", cl, dl);\n#endif\n\t\tif (dl > 0)\n\t\t\t{\n\t\t\tif (save_dl > dl)\n\t\t\t\t{\n\t\t\t\tswitch (save_dl - dl)\n\t\t\t\t\t{\n\t\t\t\tcase 1:\n\t\t\t\t\tr[1] = a[1];\n\t\t\t\t\tif (--dl <= 0) break;\n\t\t\t\tcase 2:\n\t\t\t\t\tr[2] = a[2];\n\t\t\t\t\tif (--dl <= 0) break;\n\t\t\t\tcase 3:\n\t\t\t\t\tr[3] = a[3];\n\t\t\t\t\tif (--dl <= 0) break;\n\t\t\t\t\t}\n\t\t\t\ta += 4;\n\t\t\t\tr += 4;\n\t\t\t\t}\n\t\t\t}\n\t\tif (dl > 0)\n\t\t\t{\n#ifdef BN_COUNT\n\t\t\tfprintf(stderr, \"  bn_add_part_words %d + %d (dl > 0, copy)\\n\", cl, dl);\n#endif\n\t\t\tfor(;;)\n\t\t\t\t{\n\t\t\t\tr[0] = a[0];\n\t\t\t\tif (--dl <= 0) break;\n\t\t\t\tr[1] = a[1];\n\t\t\t\tif (--dl <= 0) break;\n\t\t\t\tr[2] = a[2];\n\t\t\t\tif (--dl <= 0) break;\n\t\t\t\tr[3] = a[3];\n\t\t\t\tif (--dl <= 0) break;\n\n\t\t\t\ta += 4;\n\t\t\t\tr += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\treturn c;\n\t}",
        "target": 0
    },
    {
        "func": "void bn_mul_low_recursive(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n2,\n\t     BN_ULONG *t)\n\t{\n\tint n=n2/2;\n\n# ifdef BN_COUNT\n\tfprintf(stderr,\" bn_mul_low_recursive %d * %d\\n\",n2,n2);\n# endif\n\n\tbn_mul_recursive(r,a,b,n,0,0,&(t[0]));\n\tif (n >= BN_MUL_LOW_RECURSIVE_SIZE_NORMAL)\n\t\t{\n\t\tbn_mul_low_recursive(&(t[0]),&(a[0]),&(b[n]),n,&(t[n2]));\n\t\tbn_add_words(&(r[n]),&(r[n]),&(t[0]),n);\n\t\tbn_mul_low_recursive(&(t[0]),&(a[n]),&(b[0]),n,&(t[n2]));\n\t\tbn_add_words(&(r[n]),&(r[n]),&(t[0]),n);\n\t\t}\n\telse\n\t\t{\n\t\tbn_mul_low_normal(&(t[0]),&(a[0]),&(b[n]),n);\n\t\tbn_mul_low_normal(&(t[n]),&(a[n]),&(b[0]),n);\n\t\tbn_add_words(&(r[n]),&(r[n]),&(t[0]),n);\n\t\tbn_add_words(&(r[n]),&(r[n]),&(t[n]),n);\n\t\t}\n\t}",
        "target": 0
    },
    {
        "func": "int BN_mul(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx)\n\t{\n\tint ret=0;\n\tint top,al,bl;\n\tBIGNUM *rr;\n#if defined(BN_MUL_COMBA) || defined(BN_RECURSION)\n\tint i;\n#endif\n#ifdef BN_RECURSION\n\tBIGNUM *t=NULL;\n\tint j=0,k;\n#endif\n\n#ifdef BN_COUNT\n\tfprintf(stderr,\"BN_mul %d * %d\\n\",a->top,b->top);\n#endif\n\n\tbn_check_top(a);\n\tbn_check_top(b);\n\tbn_check_top(r);\n\n\tal=a->top;\n\tbl=b->top;\n\n\tif ((al == 0) || (bl == 0))\n\t\t{\n\t\tBN_zero(r);\n\t\treturn(1);\n\t\t}\n\ttop=al+bl;\n\n\tBN_CTX_start(ctx);\n\tif ((r == a) || (r == b))\n\t\t{\n\t\tif ((rr = BN_CTX_get(ctx)) == NULL) goto err;\n\t\t}\n\telse\n\t\trr = r;\n\trr->neg=a->neg^b->neg;\n\n#if defined(BN_MUL_COMBA) || defined(BN_RECURSION)\n\ti = al-bl;\n#endif\n#ifdef BN_MUL_COMBA\n\tif (i == 0)\n\t\t{\n# if 0\n\t\tif (al == 4)\n\t\t\t{\n\t\t\tif (bn_wexpand(rr,8) == NULL) goto err;\n\t\t\trr->top=8;\n\t\t\tbn_mul_comba4(rr->d,a->d,b->d);\n\t\t\tgoto end;\n\t\t\t}\n# endif\n\t\tif (al == 8)\n\t\t\t{\n\t\t\tif (bn_wexpand(rr,16) == NULL) goto err;\n\t\t\trr->top=16;\n\t\t\tbn_mul_comba8(rr->d,a->d,b->d);\n\t\t\tgoto end;\n\t\t\t}\n\t\t}\n#endif /* BN_MUL_COMBA */\n#ifdef BN_RECURSION\n\tif ((al >= BN_MULL_SIZE_NORMAL) && (bl >= BN_MULL_SIZE_NORMAL))\n\t\t{\n\t\tif (i >= -1 && i <= 1)\n\t\t\t{\n\t\t\tint sav_j =0;\n\t\t\t/* Find out the power of two lower or equal\n\t\t\t   to the longest of the two numbers */\n\t\t\tif (i >= 0)\n\t\t\t\t{\n\t\t\t\tj = BN_num_bits_word((BN_ULONG)al);\n\t\t\t\t}\n\t\t\tif (i == -1)\n\t\t\t\t{\n\t\t\t\tj = BN_num_bits_word((BN_ULONG)bl);\n\t\t\t\t}\n\t\t\tsav_j = j;\n\t\t\tj = 1<<(j-1);\n\t\t\tassert(j <= al || j <= bl);\n\t\t\tk = j+j;\n\t\t\tt = BN_CTX_get(ctx);\n\t\t\tif (t == NULL)\n\t\t\t\tgoto err;\n\t\t\tif (al > j || bl > j)\n\t\t\t\t{\n\t\t\t\tif (bn_wexpand(t,k*4) == NULL) goto err;\n\t\t\t\tif (bn_wexpand(rr,k*4) == NULL) goto err;\n\t\t\t\tbn_mul_part_recursive(rr->d,a->d,b->d,\n\t\t\t\t\tj,al-j,bl-j,t->d);\n\t\t\t\t}\n\t\t\telse\t/* al <= j || bl <= j */\n\t\t\t\t{\n\t\t\t\tif (bn_wexpand(t,k*2) == NULL) goto err;\n\t\t\t\tif (bn_wexpand(rr,k*2) == NULL) goto err;\n\t\t\t\tbn_mul_recursive(rr->d,a->d,b->d,\n\t\t\t\t\tj,al-j,bl-j,t->d);\n\t\t\t\t}\n\t\t\trr->top=top;\n\t\t\tgoto end;\n\t\t\t}\n#if 0\n\t\tif (i == 1 && !BN_get_flags(b,BN_FLG_STATIC_DATA))\n\t\t\t{\n\t\t\tBIGNUM *tmp_bn = (BIGNUM *)b;\n\t\t\tif (bn_wexpand(tmp_bn,al) == NULL) goto err;\n\t\t\ttmp_bn->d[bl]=0;\n\t\t\tbl++;\n\t\t\ti--;\n\t\t\t}\n\t\telse if (i == -1 && !BN_get_flags(a,BN_FLG_STATIC_DATA))\n\t\t\t{\n\t\t\tBIGNUM *tmp_bn = (BIGNUM *)a;\n\t\t\tif (bn_wexpand(tmp_bn,bl) == NULL) goto err;\n\t\t\ttmp_bn->d[al]=0;\n\t\t\tal++;\n\t\t\ti++;\n\t\t\t}\n\t\tif (i == 0)\n\t\t\t{\n\t\t\t/* symmetric and > 4 */\n\t\t\t/* 16 or larger */\n\t\t\tj=BN_num_bits_word((BN_ULONG)al);\n\t\t\tj=1<<(j-1);\n\t\t\tk=j+j;\n\t\t\tt = BN_CTX_get(ctx);\n\t\t\tif (al == j) /* exact multiple */\n\t\t\t\t{\n\t\t\t\tif (bn_wexpand(t,k*2) == NULL) goto err;\n\t\t\t\tif (bn_wexpand(rr,k*2) == NULL) goto err;\n\t\t\t\tbn_mul_recursive(rr->d,a->d,b->d,al,t->d);\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tif (bn_wexpand(t,k*4) == NULL) goto err;\n\t\t\t\tif (bn_wexpand(rr,k*4) == NULL) goto err;\n\t\t\t\tbn_mul_part_recursive(rr->d,a->d,b->d,al-j,j,t->d);\n\t\t\t\t}\n\t\t\trr->top=top;\n\t\t\tgoto end;\n\t\t\t}\n#endif\n\t\t}\n#endif /* BN_RECURSION */\n\tif (bn_wexpand(rr,top) == NULL) goto err;\n\trr->top=top;\n\tbn_mul_normal(rr->d,a->d,al,b->d,bl);\n\n#if defined(BN_MUL_COMBA) || defined(BN_RECURSION)\nend:\n#endif\n\tbn_correct_top(rr);\n\tif (r != rr) BN_copy(r,rr);\n\tret=1;\nerr:\n\tbn_check_top(r);\n\tBN_CTX_end(ctx);\n\treturn(ret);\n\t}",
        "target": 0
    },
    {
        "func": "void bn_mul_low_normal(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n)\n\t{\n#ifdef BN_COUNT\n\tfprintf(stderr,\" bn_mul_low_normal %d * %d\\n\",n,n);\n#endif\n\tbn_mul_words(r,a,n,b[0]);\n\n\tfor (;;)\n\t\t{\n\t\tif (--n <= 0) return;\n\t\tbn_mul_add_words(&(r[1]),a,n,b[1]);\n\t\tif (--n <= 0) return;\n\t\tbn_mul_add_words(&(r[2]),a,n,b[2]);\n\t\tif (--n <= 0) return;\n\t\tbn_mul_add_words(&(r[3]),a,n,b[3]);\n\t\tif (--n <= 0) return;\n\t\tbn_mul_add_words(&(r[4]),a,n,b[4]);\n\t\tr+=4;\n\t\tb+=4;\n\t\t}\n\t}",
        "target": 0
    },
    {
        "func": "void bn_mul_high(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, BN_ULONG *l, int n2,\n\t     BN_ULONG *t)\n\t{\n\tint i,n;\n\tint c1,c2;\n\tint neg,oneg,zero;\n\tBN_ULONG ll,lc,*lp,*mp;\n\n# ifdef BN_COUNT\n\tfprintf(stderr,\" bn_mul_high %d * %d\\n\",n2,n2);\n# endif\n\tn=n2/2;\n\n\t/* Calculate (al-ah)*(bh-bl) */\n\tneg=zero=0;\n\tc1=bn_cmp_words(&(a[0]),&(a[n]),n);\n\tc2=bn_cmp_words(&(b[n]),&(b[0]),n);\n\tswitch (c1*3+c2)\n\t\t{\n\tcase -4:\n\t\tbn_sub_words(&(r[0]),&(a[n]),&(a[0]),n);\n\t\tbn_sub_words(&(r[n]),&(b[0]),&(b[n]),n);\n\t\tbreak;\n\tcase -3:\n\t\tzero=1;\n\t\tbreak;\n\tcase -2:\n\t\tbn_sub_words(&(r[0]),&(a[n]),&(a[0]),n);\n\t\tbn_sub_words(&(r[n]),&(b[n]),&(b[0]),n);\n\t\tneg=1;\n\t\tbreak;\n\tcase -1:\n\tcase 0:\n\tcase 1:\n\t\tzero=1;\n\t\tbreak;\n\tcase 2:\n\t\tbn_sub_words(&(r[0]),&(a[0]),&(a[n]),n);\n\t\tbn_sub_words(&(r[n]),&(b[0]),&(b[n]),n);\n\t\tneg=1;\n\t\tbreak;\n\tcase 3:\n\t\tzero=1;\n\t\tbreak;\n\tcase 4:\n\t\tbn_sub_words(&(r[0]),&(a[0]),&(a[n]),n);\n\t\tbn_sub_words(&(r[n]),&(b[n]),&(b[0]),n);\n\t\tbreak;\n\t\t}\n\t\t\n\toneg=neg;\n\t/* t[10] = (a[0]-a[1])*(b[1]-b[0]) */\n\t/* r[10] = (a[1]*b[1]) */\n# ifdef BN_MUL_COMBA\n\tif (n == 8)\n\t\t{\n\t\tbn_mul_comba8(&(t[0]),&(r[0]),&(r[n]));\n\t\tbn_mul_comba8(r,&(a[n]),&(b[n]));\n\t\t}\n\telse\n# endif\n\t\t{\n\t\tbn_mul_recursive(&(t[0]),&(r[0]),&(r[n]),n,0,0,&(t[n2]));\n\t\tbn_mul_recursive(r,&(a[n]),&(b[n]),n,0,0,&(t[n2]));\n\t\t}\n\n\t/* s0 == low(al*bl)\n\t * s1 == low(ah*bh)+low((al-ah)*(bh-bl))+low(al*bl)+high(al*bl)\n\t * We know s0 and s1 so the only unknown is high(al*bl)\n\t * high(al*bl) == s1 - low(ah*bh+s0+(al-ah)*(bh-bl))\n\t * high(al*bl) == s1 - (r[0]+l[0]+t[0])\n\t */\n\tif (l != NULL)\n\t\t{\n\t\tlp= &(t[n2+n]);\n\t\tc1=(int)(bn_add_words(lp,&(r[0]),&(l[0]),n));\n\t\t}\n\telse\n\t\t{\n\t\tc1=0;\n\t\tlp= &(r[0]);\n\t\t}\n\n\tif (neg)\n\t\tneg=(int)(bn_sub_words(&(t[n2]),lp,&(t[0]),n));\n\telse\n\t\t{\n\t\tbn_add_words(&(t[n2]),lp,&(t[0]),n);\n\t\tneg=0;\n\t\t}\n\n\tif (l != NULL)\n\t\t{\n\t\tbn_sub_words(&(t[n2+n]),&(l[n]),&(t[n2]),n);\n\t\t}\n\telse\n\t\t{\n\t\tlp= &(t[n2+n]);\n\t\tmp= &(t[n2]);\n\t\tfor (i=0; i<n; i++)\n\t\t\tlp[i]=((~mp[i])+1)&BN_MASK2;\n\t\t}\n\n\t/* s[0] = low(al*bl)\n\t * t[3] = high(al*bl)\n\t * t[10] = (a[0]-a[1])*(b[1]-b[0]) neg is the sign\n\t * r[10] = (a[1]*b[1])\n\t */\n\t/* R[10] = al*bl\n\t * R[21] = al*bl + ah*bh + (a[0]-a[1])*(b[1]-b[0])\n\t * R[32] = ah*bh\n\t */\n\t/* R[1]=t[3]+l[0]+r[0](+-)t[0] (have carry/borrow)\n\t * R[2]=r[0]+t[3]+r[1](+-)t[1] (have carry/borrow)\n\t * R[3]=r[1]+(carry/borrow)\n\t */\n\tif (l != NULL)\n\t\t{\n\t\tlp= &(t[n2]);\n\t\tc1= (int)(bn_add_words(lp,&(t[n2+n]),&(l[0]),n));\n\t\t}\n\telse\n\t\t{\n\t\tlp= &(t[n2+n]);\n\t\tc1=0;\n\t\t}\n\tc1+=(int)(bn_add_words(&(t[n2]),lp,  &(r[0]),n));\n\tif (oneg)\n\t\tc1-=(int)(bn_sub_words(&(t[n2]),&(t[n2]),&(t[0]),n));\n\telse\n\t\tc1+=(int)(bn_add_words(&(t[n2]),&(t[n2]),&(t[0]),n));\n\n\tc2 =(int)(bn_add_words(&(r[0]),&(r[0]),&(t[n2+n]),n));\n\tc2+=(int)(bn_add_words(&(r[0]),&(r[0]),&(r[n]),n));\n\tif (oneg)\n\t\tc2-=(int)(bn_sub_words(&(r[0]),&(r[0]),&(t[n]),n));\n\telse\n\t\tc2+=(int)(bn_add_words(&(r[0]),&(r[0]),&(t[n]),n));\n\t\n\tif (c1 != 0) /* Add starting at r[0], could be +ve or -ve */\n\t\t{\n\t\ti=0;\n\t\tif (c1 > 0)\n\t\t\t{\n\t\t\tlc=c1;\n\t\t\tdo\t{\n\t\t\t\tll=(r[i]+lc)&BN_MASK2;\n\t\t\t\tr[i++]=ll;\n\t\t\t\tlc=(lc > ll);\n\t\t\t\t} while (lc);\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tlc= -c1;\n\t\t\tdo\t{\n\t\t\t\tll=r[i];\n\t\t\t\tr[i++]=(ll-lc)&BN_MASK2;\n\t\t\t\tlc=(lc > ll);\n\t\t\t\t} while (lc);\n\t\t\t}\n\t\t}\n\tif (c2 != 0) /* Add starting at r[1] */\n\t\t{\n\t\ti=n;\n\t\tif (c2 > 0)\n\t\t\t{\n\t\t\tlc=c2;\n\t\t\tdo\t{\n\t\t\t\tll=(r[i]+lc)&BN_MASK2;\n\t\t\t\tr[i++]=ll;\n\t\t\t\tlc=(lc > ll);\n\t\t\t\t} while (lc);\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tlc= -c2;\n\t\t\tdo\t{\n\t\t\t\tll=r[i];\n\t\t\t\tr[i++]=(ll-lc)&BN_MASK2;\n\t\t\t\tlc=(lc > ll);\n\t\t\t\t} while (lc);\n\t\t\t}\n\t\t}\n\t}",
        "target": 0
    },
    {
        "func": "BN_ULONG bn_sub_part_words(BN_ULONG *r,\n\tconst BN_ULONG *a, const BN_ULONG *b,\n\tint cl, int dl)\n\t{\n\tBN_ULONG c, t;\n\n\tassert(cl >= 0);\n\tc = bn_sub_words(r, a, b, cl);\n\n\tif (dl == 0)\n\t\treturn c;\n\n\tr += cl;\n\ta += cl;\n\tb += cl;\n\n\tif (dl < 0)\n\t\t{\n#ifdef BN_COUNT\n\t\tfprintf(stderr, \"  bn_sub_part_words %d + %d (dl < 0, c = %d)\\n\", cl, dl, c);\n#endif\n\t\tfor (;;)\n\t\t\t{\n\t\t\tt = b[0];\n\t\t\tr[0] = (0-t-c)&BN_MASK2;\n\t\t\tif (t != 0) c=1;\n\t\t\tif (++dl >= 0) break;\n\n\t\t\tt = b[1];\n\t\t\tr[1] = (0-t-c)&BN_MASK2;\n\t\t\tif (t != 0) c=1;\n\t\t\tif (++dl >= 0) break;\n\n\t\t\tt = b[2];\n\t\t\tr[2] = (0-t-c)&BN_MASK2;\n\t\t\tif (t != 0) c=1;\n\t\t\tif (++dl >= 0) break;\n\n\t\t\tt = b[3];\n\t\t\tr[3] = (0-t-c)&BN_MASK2;\n\t\t\tif (t != 0) c=1;\n\t\t\tif (++dl >= 0) break;\n\n\t\t\tb += 4;\n\t\t\tr += 4;\n\t\t\t}\n\t\t}\n\telse\n\t\t{\n\t\tint save_dl = dl;\n#ifdef BN_COUNT\n\t\tfprintf(stderr, \"  bn_sub_part_words %d + %d (dl > 0, c = %d)\\n\", cl, dl, c);\n#endif\n\t\twhile(c)\n\t\t\t{\n\t\t\tt = a[0];\n\t\t\tr[0] = (t-c)&BN_MASK2;\n\t\t\tif (t != 0) c=0;\n\t\t\tif (--dl <= 0) break;\n\n\t\t\tt = a[1];\n\t\t\tr[1] = (t-c)&BN_MASK2;\n\t\t\tif (t != 0) c=0;\n\t\t\tif (--dl <= 0) break;\n\n\t\t\tt = a[2];\n\t\t\tr[2] = (t-c)&BN_MASK2;\n\t\t\tif (t != 0) c=0;\n\t\t\tif (--dl <= 0) break;\n\n\t\t\tt = a[3];\n\t\t\tr[3] = (t-c)&BN_MASK2;\n\t\t\tif (t != 0) c=0;\n\t\t\tif (--dl <= 0) break;\n\n\t\t\tsave_dl = dl;\n\t\t\ta += 4;\n\t\t\tr += 4;\n\t\t\t}\n\t\tif (dl > 0)\n\t\t\t{\n#ifdef BN_COUNT\n\t\t\tfprintf(stderr, \"  bn_sub_part_words %d + %d (dl > 0, c == 0)\\n\", cl, dl);\n#endif\n\t\t\tif (save_dl > dl)\n\t\t\t\t{\n\t\t\t\tswitch (save_dl - dl)\n\t\t\t\t\t{\n\t\t\t\tcase 1:\n\t\t\t\t\tr[1] = a[1];\n\t\t\t\t\tif (--dl <= 0) break;\n\t\t\t\tcase 2:\n\t\t\t\t\tr[2] = a[2];\n\t\t\t\t\tif (--dl <= 0) break;\n\t\t\t\tcase 3:\n\t\t\t\t\tr[3] = a[3];\n\t\t\t\t\tif (--dl <= 0) break;\n\t\t\t\t\t}\n\t\t\t\ta += 4;\n\t\t\t\tr += 4;\n\t\t\t\t}\n\t\t\t}\n\t\tif (dl > 0)\n\t\t\t{\n#ifdef BN_COUNT\n\t\t\tfprintf(stderr, \"  bn_sub_part_words %d + %d (dl > 0, copy)\\n\", cl, dl);\n#endif\n\t\t\tfor(;;)\n\t\t\t\t{\n\t\t\t\tr[0] = a[0];\n\t\t\t\tif (--dl <= 0) break;\n\t\t\t\tr[1] = a[1];\n\t\t\t\tif (--dl <= 0) break;\n\t\t\t\tr[2] = a[2];\n\t\t\t\tif (--dl <= 0) break;\n\t\t\t\tr[3] = a[3];\n\t\t\t\tif (--dl <= 0) break;\n\n\t\t\t\ta += 4;\n\t\t\t\tr += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\treturn c;\n\t}",
        "target": 0
    },
    {
        "func": "void bn_mul_recursive(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n2,\n\tint dna, int dnb, BN_ULONG *t)\n\t{\n\tint n=n2/2,c1,c2;\n\tint tna=n+dna, tnb=n+dnb;\n\tunsigned int neg,zero;\n\tBN_ULONG ln,lo,*p;\n\n# ifdef BN_COUNT\n\tfprintf(stderr,\" bn_mul_recursive %d%+d * %d%+d\\n\",n2,dna,n2,dnb);\n# endif\n# ifdef BN_MUL_COMBA\n#  if 0\n\tif (n2 == 4)\n\t\t{\n\t\tbn_mul_comba4(r,a,b);\n\t\treturn;\n\t\t}\n#  endif\n\t/* Only call bn_mul_comba 8 if n2 == 8 and the\n\t * two arrays are complete [steve]\n\t */\n\tif (n2 == 8 && dna == 0 && dnb == 0)\n\t\t{\n\t\tbn_mul_comba8(r,a,b);\n\t\treturn; \n\t\t}\n# endif /* BN_MUL_COMBA */\n\t/* Else do normal multiply */\n\tif (n2 < BN_MUL_RECURSIVE_SIZE_NORMAL)\n\t\t{\n\t\tbn_mul_normal(r,a,n2+dna,b,n2+dnb);\n\t\tif ((dna + dnb) < 0)\n\t\t\tmemset(&r[2*n2 + dna + dnb], 0,\n\t\t\t\tsizeof(BN_ULONG) * -(dna + dnb));\n\t\treturn;\n\t\t}\n\t/* r=(a[0]-a[1])*(b[1]-b[0]) */\n\tc1=bn_cmp_part_words(a,&(a[n]),tna,n-tna);\n\tc2=bn_cmp_part_words(&(b[n]),b,tnb,tnb-n);\n\tzero=neg=0;\n\tswitch (c1*3+c2)\n\t\t{\n\tcase -4:\n\t\tbn_sub_part_words(t,      &(a[n]),a,      tna,tna-n); /* - */\n\t\tbn_sub_part_words(&(t[n]),b,      &(b[n]),tnb,n-tnb); /* - */\n\t\tbreak;\n\tcase -3:\n\t\tzero=1;\n\t\tbreak;\n\tcase -2:\n\t\tbn_sub_part_words(t,      &(a[n]),a,      tna,tna-n); /* - */\n\t\tbn_sub_part_words(&(t[n]),&(b[n]),b,      tnb,tnb-n); /* + */\n\t\tneg=1;\n\t\tbreak;\n\tcase -1:\n\tcase 0:\n\tcase 1:\n\t\tzero=1;\n\t\tbreak;\n\tcase 2:\n\t\tbn_sub_part_words(t,      a,      &(a[n]),tna,n-tna); /* + */\n\t\tbn_sub_part_words(&(t[n]),b,      &(b[n]),tnb,n-tnb); /* - */\n\t\tneg=1;\n\t\tbreak;\n\tcase 3:\n\t\tzero=1;\n\t\tbreak;\n\tcase 4:\n\t\tbn_sub_part_words(t,      a,      &(a[n]),tna,n-tna);\n\t\tbn_sub_part_words(&(t[n]),&(b[n]),b,      tnb,tnb-n);\n\t\tbreak;\n\t\t}\n\n# ifdef BN_MUL_COMBA\n\tif (n == 4 && dna == 0 && dnb == 0) /* XXX: bn_mul_comba4 could take\n\t\t\t\t\t       extra args to do this well */\n\t\t{\n\t\tif (!zero)\n\t\t\tbn_mul_comba4(&(t[n2]),t,&(t[n]));\n\t\telse\n\t\t\tmemset(&(t[n2]),0,8*sizeof(BN_ULONG));\n\t\t\n\t\tbn_mul_comba4(r,a,b);\n\t\tbn_mul_comba4(&(r[n2]),&(a[n]),&(b[n]));\n\t\t}\n\telse if (n == 8 && dna == 0 && dnb == 0) /* XXX: bn_mul_comba8 could\n\t\t\t\t\t\t    take extra args to do this\n\t\t\t\t\t\t    well */\n\t\t{\n\t\tif (!zero)\n\t\t\tbn_mul_comba8(&(t[n2]),t,&(t[n]));\n\t\telse\n\t\t\tmemset(&(t[n2]),0,16*sizeof(BN_ULONG));\n\t\t\n\t\tbn_mul_comba8(r,a,b);\n\t\tbn_mul_comba8(&(r[n2]),&(a[n]),&(b[n]));\n\t\t}\n\telse\n# endif /* BN_MUL_COMBA */\n\t\t{\n\t\tp= &(t[n2*2]);\n\t\tif (!zero)\n\t\t\tbn_mul_recursive(&(t[n2]),t,&(t[n]),n,0,0,p);\n\t\telse\n\t\t\tmemset(&(t[n2]),0,n2*sizeof(BN_ULONG));\n\t\tbn_mul_recursive(r,a,b,n,0,0,p);\n\t\tbn_mul_recursive(&(r[n2]),&(a[n]),&(b[n]),n,dna,dnb,p);\n\t\t}\n\n\t/* t[32] holds (a[0]-a[1])*(b[1]-b[0]), c1 is the sign\n\t * r[10] holds (a[0]*b[0])\n\t * r[32] holds (b[1]*b[1])\n\t */\n\n\tc1=(int)(bn_add_words(t,r,&(r[n2]),n2));\n\n\tif (neg) /* if t[32] is negative */\n\t\t{\n\t\tc1-=(int)(bn_sub_words(&(t[n2]),t,&(t[n2]),n2));\n\t\t}\n\telse\n\t\t{\n\t\t/* Might have a carry */\n\t\tc1+=(int)(bn_add_words(&(t[n2]),&(t[n2]),t,n2));\n\t\t}\n\n\t/* t[32] holds (a[0]-a[1])*(b[1]-b[0])+(a[0]*b[0])+(a[1]*b[1])\n\t * r[10] holds (a[0]*b[0])\n\t * r[32] holds (b[1]*b[1])\n\t * c1 holds the carry bits\n\t */\n\tc1+=(int)(bn_add_words(&(r[n]),&(r[n]),&(t[n2]),n2));\n\tif (c1)\n\t\t{\n\t\tp= &(r[n+n2]);\n\t\tlo= *p;\n\t\tln=(lo+c1)&BN_MASK2;\n\t\t*p=ln;\n\n\t\t/* The overflow will stop before we over write\n\t\t * words we should not overwrite */\n\t\tif (ln < (BN_ULONG)c1)\n\t\t\t{\n\t\t\tdo\t{\n\t\t\t\tp++;\n\t\t\t\tlo= *p;\n\t\t\t\tln=(lo+1)&BN_MASK2;\n\t\t\t\t*p=ln;\n\t\t\t\t} while (ln == 0);\n\t\t\t}\n\t\t}\n\t}",
        "target": 0
    },
    {
        "func": "void bn_mul_normal(BN_ULONG *r, BN_ULONG *a, int na, BN_ULONG *b, int nb)\n\t{\n\tBN_ULONG *rr;\n\n#ifdef BN_COUNT\n\tfprintf(stderr,\" bn_mul_normal %d * %d\\n\",na,nb);\n#endif\n\n\tif (na < nb)\n\t\t{\n\t\tint itmp;\n\t\tBN_ULONG *ltmp;\n\n\t\titmp=na; na=nb; nb=itmp;\n\t\tltmp=a;   a=b;   b=ltmp;\n\n\t\t}\n\trr= &(r[na]);\n\tif (nb <= 0)\n\t\t{\n\t\t(void)bn_mul_words(r,a,na,0);\n\t\treturn;\n\t\t}\n\telse\n\t\trr[0]=bn_mul_words(r,a,na,b[0]);\n\n\tfor (;;)\n\t\t{\n\t\tif (--nb <= 0) return;\n\t\trr[1]=bn_mul_add_words(&(r[1]),a,na,b[1]);\n\t\tif (--nb <= 0) return;\n\t\trr[2]=bn_mul_add_words(&(r[2]),a,na,b[2]);\n\t\tif (--nb <= 0) return;\n\t\trr[3]=bn_mul_add_words(&(r[3]),a,na,b[3]);\n\t\tif (--nb <= 0) return;\n\t\trr[4]=bn_mul_add_words(&(r[4]),a,na,b[4]);\n\t\trr+=4;\n\t\tr+=4;\n\t\tb+=4;\n\t\t}\n\t}",
        "target": 0
    },
    {
        "func": "static int pkcs7_encode_rinfo(PKCS7_RECIP_INFO *ri,\n                              unsigned char *key, int keylen)\n{\n    EVP_PKEY_CTX *pctx = NULL;\n    EVP_PKEY *pkey = NULL;\n    unsigned char *ek = NULL;\n    int ret = 0;\n    size_t eklen;\n\n    pkey = X509_get_pubkey(ri->cert);\n\n    if (!pkey)\n        return 0;\n\n    pctx = EVP_PKEY_CTX_new(pkey, NULL);\n    if (!pctx)\n        return 0;\n\n    if (EVP_PKEY_encrypt_init(pctx) <= 0)\n        goto err;\n\n    if (EVP_PKEY_CTX_ctrl(pctx, -1, EVP_PKEY_OP_ENCRYPT,\n                          EVP_PKEY_CTRL_PKCS7_ENCRYPT, 0, ri) <= 0) {\n        PKCS7err(PKCS7_F_PKCS7_ENCODE_RINFO, PKCS7_R_CTRL_ERROR);\n        goto err;\n    }\n\n    if (EVP_PKEY_encrypt(pctx, NULL, &eklen, key, keylen) <= 0)\n        goto err;\n\n    ek = OPENSSL_malloc(eklen);\n\n    if (ek == NULL) {\n        PKCS7err(PKCS7_F_PKCS7_ENCODE_RINFO, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    if (EVP_PKEY_encrypt(pctx, ek, &eklen, key, keylen) <= 0)\n        goto err;\n\n    ASN1_STRING_set0(ri->enc_key, ek, eklen);\n    ek = NULL;\n\n    ret = 1;\n\n err:\n    EVP_PKEY_free(pkey);\n    EVP_PKEY_CTX_free(pctx);\n    OPENSSL_free(ek);\n    return ret;\n\n}",
        "target": 0
    },
    {
        "func": "static int pkcs7_cmp_ri(PKCS7_RECIP_INFO *ri, X509 *pcert)\n{\n    int ret;\n    ret = X509_NAME_cmp(ri->issuer_and_serial->issuer,\n                        pcert->cert_info->issuer);\n    if (ret)\n        return ret;\n    return ASN1_INTEGER_cmp(pcert->cert_info->serialNumber,\n                              ri->issuer_and_serial->serial);\n}",
        "target": 0
    },
    {
        "func": "int PKCS7_dataFinal(PKCS7 *p7, BIO *bio)\n{\n    int ret = 0;\n    int i, j;\n    BIO *btmp;\n    PKCS7_SIGNER_INFO *si;\n    EVP_MD_CTX *mdc, ctx_tmp;\n    STACK_OF(X509_ATTRIBUTE) *sk;\n    STACK_OF(PKCS7_SIGNER_INFO) *si_sk = NULL;\n    ASN1_OCTET_STRING *os = NULL;\n\n    if (p7 == NULL) {\n        PKCS7err(PKCS7_F_PKCS7_DATAFINAL, PKCS7_R_INVALID_NULL_POINTER);\n        return 0;\n    }\n\n    if (p7->d.ptr == NULL) {\n        PKCS7err(PKCS7_F_PKCS7_DATAFINAL, PKCS7_R_NO_CONTENT);\n        return 0;\n    }\n\n    EVP_MD_CTX_init(&ctx_tmp);\n    i = OBJ_obj2nid(p7->type);\n    p7->state = PKCS7_S_HEADER;\n\n    switch (i) {\n    case NID_pkcs7_data:\n        os = p7->d.data;\n        break;\n    case NID_pkcs7_signedAndEnveloped:\n        /* XXXXXXXXXXXXXXXX */\n        si_sk = p7->d.signed_and_enveloped->signer_info;\n        os = p7->d.signed_and_enveloped->enc_data->enc_data;\n        if (!os) {\n            os = ASN1_OCTET_STRING_new();\n            if (!os) {\n                PKCS7err(PKCS7_F_PKCS7_DATAFINAL, ERR_R_MALLOC_FAILURE);\n                goto err;\n            }\n            p7->d.signed_and_enveloped->enc_data->enc_data = os;\n        }\n        break;\n    case NID_pkcs7_enveloped:\n        /* XXXXXXXXXXXXXXXX */\n        os = p7->d.enveloped->enc_data->enc_data;\n        if (!os) {\n            os = ASN1_OCTET_STRING_new();\n            if (!os) {\n                PKCS7err(PKCS7_F_PKCS7_DATAFINAL, ERR_R_MALLOC_FAILURE);\n                goto err;\n            }\n            p7->d.enveloped->enc_data->enc_data = os;\n        }\n        break;\n    case NID_pkcs7_signed:\n        si_sk = p7->d.sign->signer_info;\n        os = PKCS7_get_octet_string(p7->d.sign->contents);\n        /* If detached data then the content is excluded */\n        if (PKCS7_type_is_data(p7->d.sign->contents) && p7->detached) {\n            ASN1_OCTET_STRING_free(os);\n            os = NULL;\n            p7->d.sign->contents->d.data = NULL;\n        }\n        break;\n\n    case NID_pkcs7_digest:\n        os = PKCS7_get_octet_string(p7->d.digest->contents);\n        /* If detached data then the content is excluded */\n        if (PKCS7_type_is_data(p7->d.digest->contents) && p7->detached) {\n            ASN1_OCTET_STRING_free(os);\n            os = NULL;\n            p7->d.digest->contents->d.data = NULL;\n        }\n        break;\n\n    default:\n        PKCS7err(PKCS7_F_PKCS7_DATAFINAL, PKCS7_R_UNSUPPORTED_CONTENT_TYPE);\n        goto err;\n    }\n\n    if (si_sk != NULL) {\n        for (i = 0; i < sk_PKCS7_SIGNER_INFO_num(si_sk); i++) {\n            si = sk_PKCS7_SIGNER_INFO_value(si_sk, i);\n            if (si->pkey == NULL)\n                continue;\n\n            j = OBJ_obj2nid(si->digest_alg->algorithm);\n\n            btmp = bio;\n\n            btmp = PKCS7_find_digest(&mdc, btmp, j);\n\n            if (btmp == NULL)\n                goto err;\n\n            /*\n             * We now have the EVP_MD_CTX, lets do the signing.\n             */\n            if (!EVP_MD_CTX_copy_ex(&ctx_tmp, mdc))\n                goto err;\n\n            sk = si->auth_attr;\n\n            /*\n             * If there are attributes, we add the digest attribute and only\n             * sign the attributes\n             */\n            if (sk_X509_ATTRIBUTE_num(sk) > 0) {\n                if (!do_pkcs7_signed_attrib(si, &ctx_tmp))\n                    goto err;\n            } else {\n                unsigned char *abuf = NULL;\n                unsigned int abuflen;\n                abuflen = EVP_PKEY_size(si->pkey);\n                abuf = OPENSSL_malloc(abuflen);\n                if (!abuf)\n                    goto err;\n\n                if (!EVP_SignFinal(&ctx_tmp, abuf, &abuflen, si->pkey)) {\n                    PKCS7err(PKCS7_F_PKCS7_DATAFINAL, ERR_R_EVP_LIB);\n                    goto err;\n                }\n                ASN1_STRING_set0(si->enc_digest, abuf, abuflen);\n            }\n        }\n    } else if (i == NID_pkcs7_digest) {\n        unsigned char md_data[EVP_MAX_MD_SIZE];\n        unsigned int md_len;\n        if (!PKCS7_find_digest(&mdc, bio,\n                               OBJ_obj2nid(p7->d.digest->md->algorithm)))\n            goto err;\n        if (!EVP_DigestFinal_ex(mdc, md_data, &md_len))\n            goto err;\n        ASN1_OCTET_STRING_set(p7->d.digest->digest, md_data, md_len);\n    }\n\n    if (!PKCS7_is_detached(p7)) {\n        /*\n         * NOTE(emilia): I think we only reach os == NULL here because detached\n         * digested data support is broken.\n         */\n        if (os == NULL)\n            goto err;\n        if (!(os->flags & ASN1_STRING_FLAG_NDEF)) {\n            char *cont;\n            long contlen;\n            btmp = BIO_find_type(bio, BIO_TYPE_MEM);\n            if (btmp == NULL) {\n                PKCS7err(PKCS7_F_PKCS7_DATAFINAL, PKCS7_R_UNABLE_TO_FIND_MEM_BIO);\n                goto err;\n            }\n            contlen = BIO_get_mem_data(btmp, &cont);\n            /*\n             * Mark the BIO read only then we can use its copy of the data\n             * instead of making an extra copy.\n             */\n            BIO_set_flags(btmp, BIO_FLAGS_MEM_RDONLY);\n            BIO_set_mem_eof_return(btmp, 0);\n            ASN1_STRING_set0(os, (unsigned char *)cont, contlen);\n        }\n    }\n    ret = 1;\n err:\n    EVP_MD_CTX_cleanup(&ctx_tmp);\n    return (ret);\n}",
        "target": 0
    },
    {
        "func": "BIO *PKCS7_dataDecode(PKCS7 *p7, EVP_PKEY *pkey, BIO *in_bio, X509 *pcert)\n{\n    int i, j;\n    BIO *out = NULL, *btmp = NULL, *etmp = NULL, *bio = NULL;\n    X509_ALGOR *xa;\n    ASN1_OCTET_STRING *data_body = NULL;\n    const EVP_MD *evp_md;\n    const EVP_CIPHER *evp_cipher = NULL;\n    EVP_CIPHER_CTX *evp_ctx = NULL;\n    X509_ALGOR *enc_alg = NULL;\n    STACK_OF(X509_ALGOR) *md_sk = NULL;\n    STACK_OF(PKCS7_RECIP_INFO) *rsk = NULL;\n    PKCS7_RECIP_INFO *ri = NULL;\n    unsigned char *ek = NULL, *tkey = NULL;\n    int eklen = 0, tkeylen = 0;\n\n    if (p7 == NULL) {\n        PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_INVALID_NULL_POINTER);\n        return NULL;\n    }\n\n    if (p7->d.ptr == NULL) {\n        PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_NO_CONTENT);\n        return NULL;\n    }\n\n    i = OBJ_obj2nid(p7->type);\n    p7->state = PKCS7_S_HEADER;\n\n    switch (i) {\n    case NID_pkcs7_signed:\n        /*\n         * p7->d.sign->contents is a PKCS7 structure consisting of a contentType\n         * field and optional content.\n         * data_body is NULL if that structure has no (=detached) content\n         * or if the contentType is wrong (i.e., not \"data\").\n         */\n        data_body = PKCS7_get_octet_string(p7->d.sign->contents);\n        if (!PKCS7_is_detached(p7) && data_body == NULL) {\n            PKCS7err(PKCS7_F_PKCS7_DATADECODE,\n                     PKCS7_R_INVALID_SIGNED_DATA_TYPE);\n            goto err;\n        }\n        md_sk = p7->d.sign->md_algs;\n        break;\n    case NID_pkcs7_signedAndEnveloped:\n        rsk = p7->d.signed_and_enveloped->recipientinfo;\n        md_sk = p7->d.signed_and_enveloped->md_algs;\n        /* data_body is NULL if the optional EncryptedContent is missing. */\n        data_body = p7->d.signed_and_enveloped->enc_data->enc_data;\n        enc_alg = p7->d.signed_and_enveloped->enc_data->algorithm;\n        evp_cipher = EVP_get_cipherbyobj(enc_alg->algorithm);\n        if (evp_cipher == NULL) {\n            PKCS7err(PKCS7_F_PKCS7_DATADECODE,\n                     PKCS7_R_UNSUPPORTED_CIPHER_TYPE);\n            goto err;\n        }\n        break;\n    case NID_pkcs7_enveloped:\n        rsk = p7->d.enveloped->recipientinfo;\n        enc_alg = p7->d.enveloped->enc_data->algorithm;\n        /* data_body is NULL if the optional EncryptedContent is missing. */\n        data_body = p7->d.enveloped->enc_data->enc_data;\n        evp_cipher = EVP_get_cipherbyobj(enc_alg->algorithm);\n        if (evp_cipher == NULL) {\n            PKCS7err(PKCS7_F_PKCS7_DATADECODE,\n                     PKCS7_R_UNSUPPORTED_CIPHER_TYPE);\n            goto err;\n        }\n        break;\n    default:\n        PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_UNSUPPORTED_CONTENT_TYPE);\n        goto err;\n    }\n\n    /* Detached content must be supplied via in_bio instead. */\n    if (data_body == NULL && in_bio == NULL) {\n        PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_NO_CONTENT);\n        goto err;\n    }\n\n    /* We will be checking the signature */\n    if (md_sk != NULL) {\n        for (i = 0; i < sk_X509_ALGOR_num(md_sk); i++) {\n            xa = sk_X509_ALGOR_value(md_sk, i);\n            if ((btmp = BIO_new(BIO_f_md())) == NULL) {\n                PKCS7err(PKCS7_F_PKCS7_DATADECODE, ERR_R_BIO_LIB);\n                goto err;\n            }\n\n            j = OBJ_obj2nid(xa->algorithm);\n            evp_md = EVP_get_digestbynid(j);\n            if (evp_md == NULL) {\n                PKCS7err(PKCS7_F_PKCS7_DATADECODE,\n                         PKCS7_R_UNKNOWN_DIGEST_TYPE);\n                goto err;\n            }\n\n            BIO_set_md(btmp, evp_md);\n            if (out == NULL)\n                out = btmp;\n            else\n                BIO_push(out, btmp);\n            btmp = NULL;\n        }\n    }\n\n    if (evp_cipher != NULL) {\n        if ((etmp = BIO_new(BIO_f_cipher())) == NULL) {\n            PKCS7err(PKCS7_F_PKCS7_DATADECODE, ERR_R_BIO_LIB);\n            goto err;\n        }\n\n        /*\n         * It was encrypted, we need to decrypt the secret key with the\n         * private key\n         */\n\n        /*\n         * Find the recipientInfo which matches the passed certificate (if\n         * any)\n         */\n\n        if (pcert) {\n            for (i = 0; i < sk_PKCS7_RECIP_INFO_num(rsk); i++) {\n                ri = sk_PKCS7_RECIP_INFO_value(rsk, i);\n                if (!pkcs7_cmp_ri(ri, pcert))\n                    break;\n                ri = NULL;\n            }\n            if (ri == NULL) {\n                PKCS7err(PKCS7_F_PKCS7_DATADECODE,\n                         PKCS7_R_NO_RECIPIENT_MATCHES_CERTIFICATE);\n                goto err;\n            }\n        }\n\n        /* If we haven't got a certificate try each ri in turn */\n        if (pcert == NULL) {\n            /*\n             * Always attempt to decrypt all rinfo even after success as a\n             * defence against MMA timing attacks.\n             */\n            for (i = 0; i < sk_PKCS7_RECIP_INFO_num(rsk); i++) {\n                ri = sk_PKCS7_RECIP_INFO_value(rsk, i);\n\n                if (pkcs7_decrypt_rinfo(&ek, &eklen, ri, pkey) < 0)\n                    goto err;\n                ERR_clear_error();\n            }\n        } else {\n            /* Only exit on fatal errors, not decrypt failure */\n            if (pkcs7_decrypt_rinfo(&ek, &eklen, ri, pkey) < 0)\n                goto err;\n            ERR_clear_error();\n        }\n\n        evp_ctx = NULL;\n        BIO_get_cipher_ctx(etmp, &evp_ctx);\n        if (EVP_CipherInit_ex(evp_ctx, evp_cipher, NULL, NULL, NULL, 0) <= 0)\n            goto err;\n        if (EVP_CIPHER_asn1_to_param(evp_ctx, enc_alg->parameter) < 0)\n            goto err;\n        /* Generate random key as MMA defence */\n        tkeylen = EVP_CIPHER_CTX_key_length(evp_ctx);\n        tkey = OPENSSL_malloc(tkeylen);\n        if (!tkey)\n            goto err;\n        if (EVP_CIPHER_CTX_rand_key(evp_ctx, tkey) <= 0)\n            goto err;\n        if (ek == NULL) {\n            ek = tkey;\n            eklen = tkeylen;\n            tkey = NULL;\n        }\n\n        if (eklen != EVP_CIPHER_CTX_key_length(evp_ctx)) {\n            /*\n             * Some S/MIME clients don't use the same key and effective key\n             * length. The key length is determined by the size of the\n             * decrypted RSA key.\n             */\n            if (!EVP_CIPHER_CTX_set_key_length(evp_ctx, eklen)) {\n                /* Use random key as MMA defence */\n                OPENSSL_clear_free(ek, eklen);\n                ek = tkey;\n                eklen = tkeylen;\n                tkey = NULL;\n            }\n        }\n        /* Clear errors so we don't leak information useful in MMA */\n        ERR_clear_error();\n        if (EVP_CipherInit_ex(evp_ctx, NULL, NULL, ek, NULL, 0) <= 0)\n            goto err;\n\n        OPENSSL_clear_free(ek, eklen);\n        ek = NULL;\n        OPENSSL_clear_free(tkey, tkeylen);\n        tkey = NULL;\n\n        if (out == NULL)\n            out = etmp;\n        else\n            BIO_push(out, etmp);\n        etmp = NULL;\n    }\n    if (in_bio != NULL) {\n        bio = in_bio;\n    } else {\n        if (data_body->length > 0)\n            bio = BIO_new_mem_buf(data_body->data, data_body->length);\n        else {\n            bio = BIO_new(BIO_s_mem());\n            BIO_set_mem_eof_return(bio, 0);\n        }\n        if (bio == NULL)\n            goto err;\n    }\n    BIO_push(out, bio);\n    bio = NULL;\n    return out;\n\n err:\n    OPENSSL_clear_free(ek, eklen);\n    OPENSSL_clear_free(tkey, tkeylen);\n    BIO_free_all(out);\n    BIO_free_all(btmp);\n    BIO_free_all(etmp);\n    BIO_free_all(bio);\n    return  NULL;\n}",
        "target": 0
    },
    {
        "func": "int PKCS7_SIGNER_INFO_sign(PKCS7_SIGNER_INFO *si)\n{\n    EVP_MD_CTX mctx;\n    EVP_PKEY_CTX *pctx;\n    unsigned char *abuf = NULL;\n    int alen;\n    size_t siglen;\n    const EVP_MD *md = NULL;\n\n    md = EVP_get_digestbyobj(si->digest_alg->algorithm);\n    if (md == NULL)\n        return 0;\n\n    EVP_MD_CTX_init(&mctx);\n    if (EVP_DigestSignInit(&mctx, &pctx, md, NULL, si->pkey) <= 0)\n        goto err;\n\n    if (EVP_PKEY_CTX_ctrl(pctx, -1, EVP_PKEY_OP_SIGN,\n                          EVP_PKEY_CTRL_PKCS7_SIGN, 0, si) <= 0) {\n        PKCS7err(PKCS7_F_PKCS7_SIGNER_INFO_SIGN, PKCS7_R_CTRL_ERROR);\n        goto err;\n    }\n\n    alen = ASN1_item_i2d((ASN1_VALUE *)si->auth_attr, &abuf,\n                         ASN1_ITEM_rptr(PKCS7_ATTR_SIGN));\n    if (!abuf)\n        goto err;\n    if (EVP_DigestSignUpdate(&mctx, abuf, alen) <= 0)\n        goto err;\n    OPENSSL_free(abuf);\n    abuf = NULL;\n    if (EVP_DigestSignFinal(&mctx, NULL, &siglen) <= 0)\n        goto err;\n    abuf = OPENSSL_malloc(siglen);\n    if (!abuf)\n        goto err;\n    if (EVP_DigestSignFinal(&mctx, abuf, &siglen) <= 0)\n        goto err;\n\n    if (EVP_PKEY_CTX_ctrl(pctx, -1, EVP_PKEY_OP_SIGN,\n                          EVP_PKEY_CTRL_PKCS7_SIGN, 1, si) <= 0) {\n        PKCS7err(PKCS7_F_PKCS7_SIGNER_INFO_SIGN, PKCS7_R_CTRL_ERROR);\n        goto err;\n    }\n\n    EVP_MD_CTX_cleanup(&mctx);\n\n    ASN1_STRING_set0(si->enc_digest, abuf, siglen);\n\n    return 1;\n\n err:\n    OPENSSL_free(abuf);\n    EVP_MD_CTX_cleanup(&mctx);\n    return 0;\n\n}",
        "target": 0
    },
    {
        "func": "int PKCS7_signatureVerify(BIO *bio, PKCS7 *p7, PKCS7_SIGNER_INFO *si,\n                          X509 *x509)\n{\n    ASN1_OCTET_STRING *os;\n    EVP_MD_CTX mdc_tmp, *mdc;\n    int ret = 0, i;\n    int md_type;\n    STACK_OF(X509_ATTRIBUTE) *sk;\n    BIO *btmp;\n    EVP_PKEY *pkey;\n\n    EVP_MD_CTX_init(&mdc_tmp);\n\n    if (!PKCS7_type_is_signed(p7) && !PKCS7_type_is_signedAndEnveloped(p7)) {\n        PKCS7err(PKCS7_F_PKCS7_SIGNATUREVERIFY, PKCS7_R_WRONG_PKCS7_TYPE);\n        goto err;\n    }\n\n    md_type = OBJ_obj2nid(si->digest_alg->algorithm);\n\n    btmp = bio;\n    for (;;) {\n        if ((btmp == NULL) ||\n            ((btmp = BIO_find_type(btmp, BIO_TYPE_MD)) == NULL)) {\n            PKCS7err(PKCS7_F_PKCS7_SIGNATUREVERIFY,\n                     PKCS7_R_UNABLE_TO_FIND_MESSAGE_DIGEST);\n            goto err;\n        }\n        BIO_get_md_ctx(btmp, &mdc);\n        if (mdc == NULL) {\n            PKCS7err(PKCS7_F_PKCS7_SIGNATUREVERIFY, ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n        if (EVP_MD_CTX_type(mdc) == md_type)\n            break;\n        /*\n         * Workaround for some broken clients that put the signature OID\n         * instead of the digest OID in digest_alg->algorithm\n         */\n        if (EVP_MD_pkey_type(EVP_MD_CTX_md(mdc)) == md_type)\n            break;\n        btmp = BIO_next(btmp);\n    }\n\n    /*\n     * mdc is the digest ctx that we want, unless there are attributes, in\n     * which case the digest is the signed attributes\n     */\n    if (!EVP_MD_CTX_copy_ex(&mdc_tmp, mdc))\n        goto err;\n\n    sk = si->auth_attr;\n    if ((sk != NULL) && (sk_X509_ATTRIBUTE_num(sk) != 0)) {\n        unsigned char md_dat[EVP_MAX_MD_SIZE], *abuf = NULL;\n        unsigned int md_len;\n        int alen;\n        ASN1_OCTET_STRING *message_digest;\n\n        if (!EVP_DigestFinal_ex(&mdc_tmp, md_dat, &md_len))\n            goto err;\n        message_digest = PKCS7_digest_from_attributes(sk);\n        if (!message_digest) {\n            PKCS7err(PKCS7_F_PKCS7_SIGNATUREVERIFY,\n                     PKCS7_R_UNABLE_TO_FIND_MESSAGE_DIGEST);\n            goto err;\n        }\n        if ((message_digest->length != (int)md_len) ||\n            (memcmp(message_digest->data, md_dat, md_len))) {\n            PKCS7err(PKCS7_F_PKCS7_SIGNATUREVERIFY, PKCS7_R_DIGEST_FAILURE);\n            ret = -1;\n            goto err;\n        }\n\n        if (!EVP_VerifyInit_ex(&mdc_tmp, EVP_get_digestbynid(md_type), NULL))\n            goto err;\n\n        alen = ASN1_item_i2d((ASN1_VALUE *)sk, &abuf,\n                             ASN1_ITEM_rptr(PKCS7_ATTR_VERIFY));\n        if (alen <= 0) {\n            PKCS7err(PKCS7_F_PKCS7_SIGNATUREVERIFY, ERR_R_ASN1_LIB);\n            ret = -1;\n            goto err;\n        }\n        if (!EVP_VerifyUpdate(&mdc_tmp, abuf, alen))\n            goto err;\n\n        OPENSSL_free(abuf);\n    }\n\n    os = si->enc_digest;\n    pkey = X509_get_pubkey(x509);\n    if (!pkey) {\n        ret = -1;\n        goto err;\n    }\n\n    i = EVP_VerifyFinal(&mdc_tmp, os->data, os->length, pkey);\n    EVP_PKEY_free(pkey);\n    if (i <= 0) {\n        PKCS7err(PKCS7_F_PKCS7_SIGNATUREVERIFY, PKCS7_R_SIGNATURE_FAILURE);\n        ret = -1;\n        goto err;\n    }\n    ret = 1;\n err:\n    EVP_MD_CTX_cleanup(&mdc_tmp);\n    return (ret);\n}",
        "target": 0
    },
    {
        "func": "BIO *PKCS7_dataInit(PKCS7 *p7, BIO *bio)\n{\n    int i;\n    BIO *out = NULL, *btmp = NULL;\n    X509_ALGOR *xa = NULL;\n    const EVP_CIPHER *evp_cipher = NULL;\n    STACK_OF(X509_ALGOR) *md_sk = NULL;\n    STACK_OF(PKCS7_RECIP_INFO) *rsk = NULL;\n    X509_ALGOR *xalg = NULL;\n    PKCS7_RECIP_INFO *ri = NULL;\n    ASN1_OCTET_STRING *os = NULL;\n\n    if (p7 == NULL) {\n        PKCS7err(PKCS7_F_PKCS7_DATAINIT, PKCS7_R_INVALID_NULL_POINTER);\n        return NULL;\n    }\n    /*\n     * The content field in the PKCS7 ContentInfo is optional, but that really\n     * only applies to inner content (precisely, detached signatures).\n     *\n     * When reading content, missing outer content is therefore treated as an\n     * error.\n     *\n     * When creating content, PKCS7_content_new() must be called before\n     * calling this method, so a NULL p7->d is always an error.\n     */\n    if (p7->d.ptr == NULL) {\n        PKCS7err(PKCS7_F_PKCS7_DATAINIT, PKCS7_R_NO_CONTENT);\n        return NULL;\n    }\n\n    i = OBJ_obj2nid(p7->type);\n    p7->state = PKCS7_S_HEADER;\n\n    switch (i) {\n    case NID_pkcs7_signed:\n        md_sk = p7->d.sign->md_algs;\n        os = PKCS7_get_octet_string(p7->d.sign->contents);\n        break;\n    case NID_pkcs7_signedAndEnveloped:\n        rsk = p7->d.signed_and_enveloped->recipientinfo;\n        md_sk = p7->d.signed_and_enveloped->md_algs;\n        xalg = p7->d.signed_and_enveloped->enc_data->algorithm;\n        evp_cipher = p7->d.signed_and_enveloped->enc_data->cipher;\n        if (evp_cipher == NULL) {\n            PKCS7err(PKCS7_F_PKCS7_DATAINIT, PKCS7_R_CIPHER_NOT_INITIALIZED);\n            goto err;\n        }\n        break;\n    case NID_pkcs7_enveloped:\n        rsk = p7->d.enveloped->recipientinfo;\n        xalg = p7->d.enveloped->enc_data->algorithm;\n        evp_cipher = p7->d.enveloped->enc_data->cipher;\n        if (evp_cipher == NULL) {\n            PKCS7err(PKCS7_F_PKCS7_DATAINIT, PKCS7_R_CIPHER_NOT_INITIALIZED);\n            goto err;\n        }\n        break;\n    case NID_pkcs7_digest:\n        xa = p7->d.digest->md;\n        os = PKCS7_get_octet_string(p7->d.digest->contents);\n        break;\n    case NID_pkcs7_data:\n        break;\n    default:\n        PKCS7err(PKCS7_F_PKCS7_DATAINIT, PKCS7_R_UNSUPPORTED_CONTENT_TYPE);\n        goto err;\n    }\n\n    for (i = 0; i < sk_X509_ALGOR_num(md_sk); i++)\n        if (!PKCS7_bio_add_digest(&out, sk_X509_ALGOR_value(md_sk, i)))\n            goto err;\n\n    if (xa && !PKCS7_bio_add_digest(&out, xa))\n        goto err;\n\n    if (evp_cipher != NULL) {\n        unsigned char key[EVP_MAX_KEY_LENGTH];\n        unsigned char iv[EVP_MAX_IV_LENGTH];\n        int keylen, ivlen;\n        EVP_CIPHER_CTX *ctx;\n\n        if ((btmp = BIO_new(BIO_f_cipher())) == NULL) {\n            PKCS7err(PKCS7_F_PKCS7_DATAINIT, ERR_R_BIO_LIB);\n            goto err;\n        }\n        BIO_get_cipher_ctx(btmp, &ctx);\n        keylen = EVP_CIPHER_key_length(evp_cipher);\n        ivlen = EVP_CIPHER_iv_length(evp_cipher);\n        xalg->algorithm = OBJ_nid2obj(EVP_CIPHER_type(evp_cipher));\n        if (ivlen > 0)\n            if (RAND_bytes(iv, ivlen) <= 0)\n                goto err;\n        if (EVP_CipherInit_ex(ctx, evp_cipher, NULL, NULL, NULL, 1) <= 0)\n            goto err;\n        if (EVP_CIPHER_CTX_rand_key(ctx, key) <= 0)\n            goto err;\n        if (EVP_CipherInit_ex(ctx, NULL, NULL, key, iv, 1) <= 0)\n            goto err;\n\n        if (ivlen > 0) {\n            if (xalg->parameter == NULL) {\n                xalg->parameter = ASN1_TYPE_new();\n                if (xalg->parameter == NULL)\n                    goto err;\n            }\n            if (EVP_CIPHER_param_to_asn1(ctx, xalg->parameter) < 0)\n                goto err;\n        }\n\n        /* Lets do the pub key stuff :-) */\n        for (i = 0; i < sk_PKCS7_RECIP_INFO_num(rsk); i++) {\n            ri = sk_PKCS7_RECIP_INFO_value(rsk, i);\n            if (pkcs7_encode_rinfo(ri, key, keylen) <= 0)\n                goto err;\n        }\n        OPENSSL_cleanse(key, keylen);\n\n        if (out == NULL)\n            out = btmp;\n        else\n            BIO_push(out, btmp);\n        btmp = NULL;\n    }\n\n    if (bio == NULL) {\n        if (PKCS7_is_detached(p7))\n            bio = BIO_new(BIO_s_null());\n        else if (os && os->length > 0)\n            bio = BIO_new_mem_buf(os->data, os->length);\n        if (bio == NULL) {\n            bio = BIO_new(BIO_s_mem());\n            if (bio == NULL)\n                goto err;\n            BIO_set_mem_eof_return(bio, 0);\n        }\n    }\n    if (out)\n        BIO_push(out, bio);\n    else\n        out = bio;\n    return out;\n\n err:\n    BIO_free_all(out);\n    BIO_free_all(btmp);\n    return NULL;\n}",
        "target": 0
    },
    {
        "func": "static bool auth_request_proxy_is_self(struct auth_request *request)\n{\n\tconst char *port = NULL;\n\n\t/* check if the port is the same */\n\tport = auth_fields_find(request->fields.extra_fields, \"port\");\n\tif (port != NULL && !str_uint_equals(port, request->fields.local_port))\n\t\treturn FALSE;\n\t/* don't check destuser. in some systems destuser is intentionally\n\t   changed to proxied connections, but that shouldn't affect the\n\t   proxying decision.\n\n\t   it's unlikely any systems would actually want to proxy a connection\n\t   to itself only to change the username, since it can already be done\n\t   without proxying by changing the \"user\" field. */\n\treturn TRUE;\n}",
        "target": 0
    },
    {
        "func": "passdb_result_to_string(enum passdb_result result)\n{\n\tswitch (result) {\n\tcase PASSDB_RESULT_INTERNAL_FAILURE:\n\t\treturn \"internal_failure\";\n\tcase PASSDB_RESULT_SCHEME_NOT_AVAILABLE:\n\t\treturn \"scheme_not_available\";\n\tcase PASSDB_RESULT_USER_UNKNOWN:\n\t\treturn \"user_unknown\";\n\tcase PASSDB_RESULT_USER_DISABLED:\n\t\treturn \"user_disabled\";\n\tcase PASSDB_RESULT_PASS_EXPIRED:\n\t\treturn \"pass_expired\";\n\tcase PASSDB_RESULT_NEXT:\n\t\treturn \"next\";\n\tcase PASSDB_RESULT_PASSWORD_MISMATCH:\n\t\treturn \"password_mismatch\";\n\tcase PASSDB_RESULT_OK:\n\t\treturn \"ok\";\n\t}\n\ti_unreached();\n}",
        "target": 0
    },
    {
        "func": "void auth_request_log_password_mismatch(struct auth_request *request,\n\t\t\t\t\tconst char *subsystem)\n{\n\tauth_request_log_login_failure(request, subsystem, AUTH_LOG_MSG_PASSWORD_MISMATCH);\n}",
        "target": 0
    },
    {
        "func": "bool auth_request_username_accepted(const char *const *filter, const char *username)\n{\n\tbool have_includes = FALSE;\n\tbool matched_inc = FALSE;\n\n\tfor(;*filter != NULL; filter++) {\n\t\t/* if filter has ! it means the pattern will be refused */\n\t\tbool exclude = (**filter == '!');\n\t\tif (!exclude)\n\t\t\thave_includes = TRUE;\n\t\tif (wildcard_match(username, (*filter)+(exclude?1:0))) {\n\t\t\tif (exclude) {\n\t\t\t\treturn FALSE;\n\t\t\t} else {\n\t\t\t\tmatched_inc = TRUE;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn matched_inc || !have_includes;\n}",
        "target": 0
    },
    {
        "func": "void auth_request_policy_penalty_finish(void *context)\n{\n\tstruct auth_policy_check_ctx *ctx = context;\n\n\ttimeout_remove(&ctx->request->to_penalty);\n\n\ti_assert(ctx->request->state == AUTH_REQUEST_STATE_MECH_CONTINUE);\n\n\tswitch(ctx->type) {\n\tcase AUTH_POLICY_CHECK_TYPE_PLAIN:\n\t\tctx->request->handler->verify_plain_continue_callback(ctx->request, ctx->callback_plain);\n\t\treturn;\n\tcase AUTH_POLICY_CHECK_TYPE_LOOKUP:\n\t\tauth_request_lookup_credentials_policy_continue(ctx->request, ctx->callback_lookup);\n\t\treturn;\n\tcase AUTH_POLICY_CHECK_TYPE_SUCCESS:\n\t\tauth_request_success_continue(ctx);\n\t\treturn;\n\tdefault:\n\t\ti_unreached();\n\t}\n}",
        "target": 0
    },
    {
        "func": "void auth_request_log_error(struct auth_request *auth_request,\n\t\t\t    const char *subsystem,\n\t\t\t    const char *format, ...)\n{\n\tstruct event *event = get_request_event(auth_request, subsystem);\n\tva_list va;\n\n\tva_start(va, format);\n\tT_BEGIN {\n\t\tstring_t *str = t_str_new(128);\n\t\tstr_vprintfa(str, format, va);\n\t\te_error(event, \"%s\", str_c(str));\n\t} T_END;\n\tva_end(va);\n}",
        "target": 0
    },
    {
        "func": "static bool auth_request_fail_on_nuls(struct auth_request *request,\n\t\t\t       const unsigned char *data, size_t data_size)\n{\n\tif ((request->mech->flags & MECH_SEC_ALLOW_NULS) != 0)\n\t\treturn FALSE;\n\tif (memchr(data, '\\0', data_size) != NULL) {\n\t\te_debug(request->mech_event, \"Unexpected NUL in auth data\");\n\t\tauth_request_fail(request);\n\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}",
        "target": 0
    },
    {
        "func": "void auth_request_unref(struct auth_request **_request)\n{\n\tstruct auth_request *request = *_request;\n\n\t*_request = NULL;\n\ti_assert(request->refcount > 0);\n\tif (--request->refcount > 0)\n\t\treturn;\n\n\ti_assert(array_count(&request->authdb_event) == 0);\n\n\tif (request->handler_pending_reply)\n\t\tauth_request_handler_abort(request);\n\n\tevent_unref(&request->mech_event);\n\tevent_unref(&request->event);\n\tauth_request_state_count[request->state]--;\n\tauth_refresh_proctitle();\n\n\tif (request->mech_password != NULL) {\n\t\tsafe_memset(request->mech_password, 0,\n\t\t\t    strlen(request->mech_password));\n\t}\n\n\tif (request->dns_lookup_ctx != NULL)\n\t\tdns_lookup_abort(&request->dns_lookup_ctx->dns_lookup);\n\ttimeout_remove(&request->to_abort);\n\ttimeout_remove(&request->to_penalty);\n\n\tif (request->mech != NULL)\n\t\trequest->mech->auth_free(request);\n\telse\n\t\tpool_unref(&request->pool);\n}",
        "target": 0
    },
    {
        "func": "auth_request_new(const struct mech_module *mech, struct event *parent_event)\n{\n\tstruct auth_request *request;\n\n\trequest = mech->auth_new();\n\trequest->mech = mech;\n\tauth_request_post_alloc_init(request, parent_event);\n\n\treturn request;\n}",
        "target": 0
    },
    {
        "func": "void auth_request_default_verify_plain_continue(struct auth_request *request,\n\t\t\t\t\t\tverify_plain_callback_t *callback)\n{\n\tstruct auth_passdb *passdb;\n\tenum passdb_result result;\n\tconst char *cache_key, *error;\n\tconst char *password = request->mech_password;\n\n\ti_assert(request->state == AUTH_REQUEST_STATE_MECH_CONTINUE);\n\n\tif (auth_request_is_disabled_master_user(request)) {\n\t\tcallback(PASSDB_RESULT_USER_UNKNOWN, request);\n\t\treturn;\n\t}\n\n\tif (password_has_illegal_chars(password)) {\n\t\te_info(authdb_event(request),\n\t\t       \"Attempted login with password having illegal chars\");\n\t\tcallback(PASSDB_RESULT_USER_UNKNOWN, request);\n\t\treturn;\n\t}\n\n\tpassdb = request->passdb;\n\n\twhile (passdb != NULL && auth_request_want_skip_passdb(request, passdb))\n\t\tpassdb = passdb->next;\n\n\trequest->passdb = passdb;\n\n\tif (passdb == NULL) {\n\t\tauth_request_log_error(request,\n\t\t\trequest->mech != NULL ? AUTH_SUBSYS_MECH : \"none\",\n\t\t\t\"All password databases were skipped\");\n\t\tcallback(PASSDB_RESULT_INTERNAL_FAILURE, request);\n\t\treturn;\n\t}\n\n\tauth_request_passdb_lookup_begin(request);\n\trequest->private_callback.verify_plain = callback;\n\n\tcache_key = passdb_cache == NULL ? NULL : passdb->cache_key;\n\tif (passdb_cache_verify_plain(request, cache_key, password,\n\t\t\t\t      &result, FALSE)) {\n\t\treturn;\n\t}\n\n\tauth_request_set_state(request, AUTH_REQUEST_STATE_PASSDB);\n\t/* In case this request had already done a credentials lookup (is it\n\t   even possible?), make sure wanted_credentials_scheme is cleared\n\t   so passdbs don't think we're doing a credentials lookup. */\n\trequest->wanted_credentials_scheme = NULL;\n\n\tif (passdb->passdb->iface.verify_plain == NULL) {\n\t\t/* we're deinitializing and just want to get rid of this\n\t\t   request */\n\t\tauth_request_verify_plain_callback(\n\t\t\tPASSDB_RESULT_INTERNAL_FAILURE, request);\n\t} else if (passdb->passdb->blocking) {\n\t\tpassdb_blocking_verify_plain(request);\n\t} else if (passdb_template_export(passdb->default_fields_tmpl,\n\t\t\t\t\t  request, &error) < 0) {\n\t\te_error(authdb_event(request),\n\t\t\t\"Failed to expand default_fields: %s\", error);\n\t\tauth_request_verify_plain_callback(\n\t\t\tPASSDB_RESULT_INTERNAL_FAILURE, request);\n\t} else {\n\t\tpassdb->passdb->iface.verify_plain(request, password,\n\t\t\t\t\t   auth_request_verify_plain_callback);\n\t}\n}",
        "target": 0
    },
    {
        "func": "void auth_request_continue(struct auth_request *request,\n\t\t\t   const unsigned char *data, size_t data_size)\n{\n\ti_assert(request->state == AUTH_REQUEST_STATE_MECH_CONTINUE);\n\n\tif (request->fields.successful) {\n\t\tauth_request_success(request, \"\", 0);\n\t\treturn;\n\t}\n\n\tif (auth_request_fail_on_nuls(request, data, data_size))\n\t\treturn;\n\n\tauth_request_refresh_last_access(request);\n\trequest->mech->auth_continue(request, data, data_size);\n}",
        "target": 0
    },
    {
        "func": "passdb_preinit(pool_t pool, const struct auth_passdb_settings *set)\n{\n\tstatic unsigned int auth_passdb_id = 0;\n\tstruct passdb_module_interface *iface;\n\tstruct passdb_module *passdb;\n\tunsigned int idx;\n\n\tiface = passdb_interface_find(set->driver);\n\tif (iface == NULL || iface->verify_plain == NULL) {\n\t\t/* maybe it's a plugin. try to load it. */\n\t\tauth_module_load(t_strconcat(\"authdb_\", set->driver, NULL));\n\t\tiface = passdb_interface_find(set->driver);\n\t}\n\tif (iface == NULL)\n\t\ti_fatal(\"Unknown passdb driver '%s'\", set->driver);\n\tif (iface->verify_plain == NULL) {\n\t\ti_fatal(\"Support not compiled in for passdb driver '%s'\",\n\t\t\tset->driver);\n\t}\n\tif (iface->preinit == NULL && iface->init == NULL &&\n\t    *set->args != '\\0') {\n\t\ti_fatal(\"passdb %s: No args are supported: %s\",\n\t\t\tset->driver, set->args);\n\t}\n\n\tpassdb = passdb_find(set->driver, set->args, &idx);\n\tif (passdb != NULL)\n\t\treturn passdb;\n\n\tif (iface->preinit == NULL)\n\t\tpassdb = p_new(pool, struct passdb_module, 1);\n\telse\n\t\tpassdb = iface->preinit(pool, set->args);\n\tpassdb->id = ++auth_passdb_id;\n\tpassdb->iface = *iface;\n\tpassdb->args = p_strdup(pool, set->args);\n\t/* NOTE: if anything else than driver & args are added here,\n\t   passdb_find() also needs to be updated. */\n\tarray_push_back(&passdb_modules, &passdb);\n\treturn passdb;\n}",
        "target": 0
    },
    {
        "func": "void auth_request_internal_failure(struct auth_request *request)\n{\n\trequest->internal_failure = TRUE;\n\tauth_request_fail(request);\n}",
        "target": 0
    },
    {
        "func": "static void log_password_failure(struct auth_request *request,\n\t\t\t\t const char *plain_password,\n\t\t\t\t const char *crypted_password,\n\t\t\t\t const char *scheme,\n\t\t\t\t const struct password_generate_params *params,\n\t\t\t\t const char *subsystem)\n{\n\tstruct event *event = get_request_event(request, subsystem);\n\tstatic bool scheme_ok = FALSE;\n\tstring_t *str = t_str_new(256);\n\tconst char *working_scheme;\n\n\tstr_printfa(str, \"%s(%s) != '%s'\", scheme,\n\t\t    plain_password, crypted_password);\n\n\tif (!scheme_ok) {\n\t\t/* perhaps the scheme is wrong - see if we can find\n\t\t   a working one */\n\t\tworking_scheme = password_scheme_detect(plain_password,\n\t\t\t\t\t\t\tcrypted_password, params);\n\t\tif (working_scheme != NULL) {\n\t\t\tstr_printfa(str, \", try %s scheme instead\",\n\t\t\t\t    working_scheme);\n\t\t}\n\t}\n\n\te_debug(event, \"%s\", str_c(str));\n}",
        "target": 0
    },
    {
        "func": "auth_request_try_update_username(struct auth_request *request,\n\t\t\t\t const char *name, const char *value)\n{\n\tconst char *new_value;\n\n\tnew_value = get_updated_username(request->fields.user, name, value);\n\tif (new_value == NULL)\n\t\treturn FALSE;\n\tif (new_value[0] == '\\0') {\n\t\te_error(authdb_event(request),\n\t\t\t\"username attempted to be changed to empty\");\n\t\trequest->failed = TRUE;\n\t\treturn TRUE;\n\t}\n\n\tif (strcmp(request->fields.user, new_value) != 0) {\n\t\te_debug(authdb_event(request),\n\t\t\t\"username changed %s -> %s\",\n\t\t\trequest->fields.user, new_value);\n\t\tauth_request_set_username_forced(request, new_value);\n\t\trequest->user_changed_by_lookup = TRUE;\n\t}\n\treturn TRUE;\n}",
        "target": 0
    },
    {
        "func": "void auth_request_userdb_lookup_end(struct auth_request *request,\n\t\t\t\t    enum userdb_result result)\n{\n\ti_assert(array_count(&request->authdb_event) > 0);\n\tstruct event *event = authdb_event(request);\n\tstruct event_passthrough *e =\n\t\tevent_create_passthrough(event)->\n\t\tset_name(\"auth_userdb_request_finished\")->\n\t\tadd_str(\"result\", userdb_result_to_string(result));\n\tif (request->userdb_cache_result != AUTH_REQUEST_CACHE_NONE &&\n\t    request->set->cache_ttl != 0 && request->set->cache_size != 0)\n\t\te->add_str(\"cache\", auth_request_cache_result_to_str(request->userdb_cache_result));\n\te_debug(e->event(), \"Finished userdb lookup\");\n\tevent_unref(&event);\n\tarray_pop_back(&request->authdb_event);\n}",
        "target": 0
    },
    {
        "func": "static enum auth_db_rule auth_db_rule_parse(const char *str)\n{\n\tif (strcmp(str, \"return\") == 0)\n\t\treturn AUTH_DB_RULE_RETURN;\n\tif (strcmp(str, \"return-ok\") == 0)\n\t\treturn AUTH_DB_RULE_RETURN_OK;\n\tif (strcmp(str, \"return-fail\") == 0)\n\t\treturn AUTH_DB_RULE_RETURN_FAIL;\n\tif (strcmp(str, \"continue\") == 0)\n\t\treturn AUTH_DB_RULE_CONTINUE;\n\tif (strcmp(str, \"continue-ok\") == 0)\n\t\treturn AUTH_DB_RULE_CONTINUE_OK;\n\tif (strcmp(str, \"continue-fail\") == 0)\n\t\treturn AUTH_DB_RULE_CONTINUE_FAIL;\n\ti_unreached();\n}",
        "target": 0
    },
    {
        "func": "void auth_request_lookup_credentials_policy_continue(struct auth_request *request,\n\t\t\t\t\t\t     lookup_credentials_callback_t *callback)\n{\n\tstruct auth_passdb *passdb;\n\tconst char *cache_key, *cache_cred, *cache_scheme, *error;\n\tenum passdb_result result;\n\n\ti_assert(request->state == AUTH_REQUEST_STATE_MECH_CONTINUE);\n\tif (auth_request_is_disabled_master_user(request)) {\n\t\tcallback(PASSDB_RESULT_USER_UNKNOWN, NULL, 0, request);\n\t\treturn;\n\t}\n\tpassdb = request->passdb;\n\twhile (passdb != NULL && auth_request_want_skip_passdb(request, passdb))\n\t\tpassdb = passdb->next;\n\trequest->passdb = passdb;\n\n\tif (passdb == NULL) {\n\t\tauth_request_log_error(request,\n\t\t\trequest->mech != NULL ? AUTH_SUBSYS_MECH : \"none\",\n\t\t\t\"All password databases were skipped\");\n\t\tcallback(PASSDB_RESULT_INTERNAL_FAILURE, NULL, 0, request);\n\t\treturn;\n\t}\n\n\tauth_request_passdb_lookup_begin(request);\n\trequest->private_callback.lookup_credentials = callback;\n\n\tcache_key = passdb_cache == NULL ? NULL : passdb->cache_key;\n\tif (cache_key != NULL) {\n\t\tif (passdb_cache_lookup_credentials(request, cache_key,\n\t\t\t\t\t\t    &cache_cred, &cache_scheme,\n\t\t\t\t\t\t    &result, FALSE)) {\n\t\t\trequest->passdb_cache_result = AUTH_REQUEST_CACHE_HIT;\n\t\t\tpassdb_handle_credentials(\n\t\t\t\tresult, cache_cred, cache_scheme,\n\t\t\t\tauth_request_lookup_credentials_finish,\n\t\t\t\trequest);\n\t\t\treturn;\n\t\t} else {\n\t\t\trequest->passdb_cache_result = AUTH_REQUEST_CACHE_MISS;\n\t\t}\n\t}\n\n\tauth_request_set_state(request, AUTH_REQUEST_STATE_PASSDB);\n\n\tif (passdb->passdb->iface.lookup_credentials == NULL) {\n\t\t/* this passdb doesn't support credentials */\n\t\te_debug(authdb_event(request),\n\t\t\t\"passdb doesn't support credential lookups\");\n\t\tauth_request_lookup_credentials_callback(\n\t\t\t\t\tPASSDB_RESULT_SCHEME_NOT_AVAILABLE,\n\t\t\t\t\tuchar_empty_ptr, 0, request);\n\t} else if (passdb->passdb->blocking) {\n\t\tpassdb_blocking_lookup_credentials(request);\n\t} else if (passdb_template_export(passdb->default_fields_tmpl,\n\t\t\t\t\t  request, &error) < 0) {\n\t\te_error(authdb_event(request),\n\t\t\t\"Failed to expand default_fields: %s\", error);\n\t\tauth_request_lookup_credentials_callback(\n\t\t\t\t\tPASSDB_RESULT_INTERNAL_FAILURE,\n\t\t\t\t\tuchar_empty_ptr, 0, request);\n\t} else {\n\t\tpassdb->passdb->iface.lookup_credentials(request,\n\t\t\tauth_request_lookup_credentials_callback);\n\t}\n}",
        "target": 0
    },
    {
        "func": "void auth_request_set_fields(struct auth_request *request,\n\t\t\t     const char *const *fields,\n\t\t\t     const char *default_scheme)\n{\n\tfor (; *fields != NULL; fields++) {\n\t\tif (**fields == '\\0')\n\t\t\tcontinue;\n\t\tauth_request_set_field_keyvalue(request, *fields, default_scheme);\n\t}\n}",
        "target": 0
    },
    {
        "func": "void auth_request_success_continue(struct auth_policy_check_ctx *ctx)\n{\n\tstruct auth_request *request = ctx->request;\n\ti_assert(request->state == AUTH_REQUEST_STATE_MECH_CONTINUE);\n\n\ttimeout_remove(&request->to_penalty);\n\n\tif (request->failed || !request->passdb_success) {\n\t\t/* password was valid, but some other check failed. */\n\t\tauth_request_fail(request);\n\t\treturn;\n\t}\n\tauth_request_set_auth_successful(request);\n\n\t/* log before delay */\n\tauth_request_log_finished(request);\n\n\tif (request->delay_until > ioloop_time) {\n\t\tunsigned int delay_secs = request->delay_until - ioloop_time;\n\t\trequest->to_penalty = timeout_add(delay_secs * 1000,\n\t\t\tauth_request_success_continue, ctx);\n\t\treturn;\n\t}\n\n\tif (ctx->success_data->used > 0 && !request->fields.final_resp_ok) {\n\t\t/* we'll need one more SASL round, since client doesn't support\n\t\t   the final SASL response */\n\t\tauth_request_handler_reply_continue(request,\n\t\t\tctx->success_data->data, ctx->success_data->used);\n\t\treturn;\n\t}\n\n\tauth_request_set_state(request, AUTH_REQUEST_STATE_FINISHED);\n\tauth_request_refresh_last_access(request);\n\tauth_request_handler_reply(request, AUTH_CLIENT_RESULT_SUCCESS,\n\t\tctx->success_data->data, ctx->success_data->used);\n}",
        "target": 0
    },
    {
        "func": "get_updated_username(const char *old_username,\n\t\t     const char *name, const char *value)\n{\n\tconst char *p;\n\n\tif (strcmp(name, \"user\") == 0) {\n\t\t/* replace the whole username */\n\t\treturn value;\n\t}\n\n\tp = strchr(old_username, '@');\n\tif (strcmp(name, \"username\") == 0) {\n\t\tif (strchr(value, '@') != NULL)\n\t\t\treturn value;\n\n\t\t/* preserve the current @domain */\n\t\treturn t_strconcat(value, p, NULL);\n\t}\n\n\tif (strcmp(name, \"domain\") == 0) {\n\t\tif (p == NULL) {\n\t\t\t/* add the domain */\n\t\t\treturn t_strconcat(old_username, \"@\", value, NULL);\n\t\t} else {\n\t\t\t/* replace the existing domain */\n\t\t\tp = t_strdup_until(old_username, p + 1);\n\t\t\treturn t_strconcat(p, value, NULL);\n\t\t}\n\t}\n\treturn NULL;\n}",
        "target": 0
    },
    {
        "func": "auth_request_proxy_ip_is_self(struct auth_request *request,\n\t\t\t      const struct ip_addr *ip)\n{\n\tunsigned int i;\n\n\tif (net_ip_compare(ip, &request->fields.real_local_ip))\n\t\treturn TRUE;\n\n\tfor (i = 0; request->set->proxy_self_ips[i].family != 0; i++) {\n\t\tif (net_ip_compare(ip, &request->set->proxy_self_ips[i]))\n\t\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}",
        "target": 0
    },
    {
        "func": "void auth_request_lookup_credentials(struct auth_request *request,\n\t\t\t\t     const char *scheme,\n\t\t\t\t     lookup_credentials_callback_t *callback)\n{\n\tstruct auth_policy_check_ctx *ctx;\n\n\ti_assert(request->state == AUTH_REQUEST_STATE_MECH_CONTINUE);\n\n\tif (request->wanted_credentials_scheme == NULL)\n\t\trequest->wanted_credentials_scheme =\n\t\t\tp_strdup(request->pool, scheme);\n\trequest->user_changed_by_lookup = FALSE;\n\n\tif (request->policy_processed || !request->set->policy_check_before_auth)\n\t\tauth_request_lookup_credentials_policy_continue(request, callback);\n\telse {\n\t\tctx = p_new(request->pool, struct auth_policy_check_ctx, 1);\n\t\tctx->request = request;\n\t\tctx->callback_lookup = callback;\n\t\tctx->type = AUTH_POLICY_CHECK_TYPE_LOOKUP;\n\t\tauth_policy_check(request, ctx->request->mech_password, auth_request_policy_check_callback, ctx);\n\t}\n}",
        "target": 0
    },
    {
        "func": "void auth_request_log_debug(struct auth_request *auth_request,\n\t\t\t    const char *subsystem,\n\t\t\t    const char *format, ...)\n{\n\tstruct event *event = get_request_event(auth_request, subsystem);\n\tva_list va;\n\n\tva_start(va, format);\n\tT_BEGIN {\n\t\tstring_t *str = t_str_new(128);\n\t\tstr_vprintfa(str, format, va);\n\t\te_debug(event, \"%s\", str_c(str));\n\t} T_END;\n\tva_end(va);\n}",
        "target": 0
    },
    {
        "func": "static void auth_passdb_init(struct auth_passdb *passdb)\n{\n\tpassdb_init(passdb->passdb);\n\n\ti_assert(passdb->passdb->default_pass_scheme != NULL ||\n\t\t passdb->cache_key == NULL);\n}",
        "target": 0
    },
    {
        "func": "void auth_request_verify_plain(struct auth_request *request,\n\t\t\t\tconst char *password,\n\t\t\t\tverify_plain_callback_t *callback)\n{\n\tstruct auth_policy_check_ctx *ctx;\n\n\ti_assert(request->state == AUTH_REQUEST_STATE_MECH_CONTINUE);\n\n\tif (request->mech_password == NULL)\n\t\trequest->mech_password = p_strdup(request->pool, password);\n\telse\n\t\ti_assert(request->mech_password == password);\n\trequest->user_changed_by_lookup = FALSE;\n\n\tif (request->policy_processed || !request->set->policy_check_before_auth) {\n\t\trequest->handler->verify_plain_continue_callback(request,\n\t\t\t\t\t\t\t\t callback);\n\t} else {\n\t\tctx = p_new(request->pool, struct auth_policy_check_ctx, 1);\n\t\tctx->request = request;\n\t\tctx->callback_plain = callback;\n\t\tctx->type = AUTH_POLICY_CHECK_TYPE_PLAIN;\n\t\tauth_policy_check(request, request->mech_password, auth_request_policy_check_callback, ctx);\n\t}\n}",
        "target": 0
    },
    {
        "func": "void auth_request_set_field(struct auth_request *request,\n\t\t\t    const char *name, const char *value,\n\t\t\t    const char *default_scheme)\n{\n\tconst char *suffix;\n\tsize_t name_len = strlen(name);\n\n\ti_assert(*name != '\\0');\n\ti_assert(value != NULL);\n\n\ti_assert(request->passdb != NULL);\n\n\tif (name_len > 10 && strcmp(name+name_len-10, \":protected\") == 0) {\n\t\t/* set this field only if it hasn't been set before */\n\t\tname = t_strndup(name, name_len-10);\n\t\tif (auth_fields_exists(request->fields.extra_fields, name))\n\t\t\treturn;\n\t} else if (name_len > 7 && strcmp(name+name_len-7, \":remove\") == 0) {\n\t\t/* remove this field entirely */\n\t\tname = t_strndup(name, name_len-7);\n\t\tauth_fields_remove(request->fields.extra_fields, name);\n\t\treturn;\n\t}\n\n\tif (strcmp(name, \"password\") == 0) {\n\t\tauth_request_set_password(request, value,\n\t\t\t\t\t  default_scheme, FALSE);\n\t\treturn;\n\t}\n\tif (strcmp(name, \"password_noscheme\") == 0) {\n\t\tauth_request_set_password(request, value, default_scheme, TRUE);\n\t\treturn;\n\t}\n\n\tif (auth_request_try_update_username(request, name, value)) {\n\t\t/* don't change the original value so it gets saved correctly\n\t\t   to cache. */\n\t} else if (strcmp(name, \"login_user\") == 0) {\n\t\tauth_request_set_login_username_forced(request, value);\n\t} else if (strcmp(name, \"allow_nets\") == 0) {\n\t\tauth_request_validate_networks(request, name, value,\n\t\t\t\t\t       &request->fields.remote_ip);\n\t} else if (strcmp(name, \"fail\") == 0) {\n\t\trequest->failed = TRUE;\n\t} else if (strcmp(name, \"delay_until\") == 0) {\n\t\ttime_t timestamp;\n\t\tunsigned int extra_secs = 0;\n\t\tconst char *p;\n\n\t\tp = strchr(value, '+');\n\t\tif (p != NULL) {\n\t\t\tvalue = t_strdup_until(value, p++);\n\t\t\tif (str_to_uint(p, &extra_secs) < 0) {\n\t\t\t\te_error(authdb_event(request),\n\t\t\t\t\t\"Invalid delay_until randomness number '%s'\", p);\n\t\t\t\trequest->failed = TRUE;\n\t\t\t} else {\n\t\t\t\textra_secs = i_rand_limit(extra_secs);\n\t\t\t}\n\t\t}\n\t\tif (str_to_time(value, &timestamp) < 0) {\n\t\t\te_error(authdb_event(request),\n\t\t\t\t\"Invalid delay_until timestamp '%s'\", value);\n\t\t\trequest->failed = TRUE;\n\t\t} else if (timestamp <= ioloop_time) {\n\t\t\t/* no more delays */\n\t\t} else if (timestamp - ioloop_time > AUTH_REQUEST_MAX_DELAY_SECS) {\n\t\t\te_error(authdb_event(request),\n\t\t\t\t\"delay_until timestamp %s is too much in the future, failing\", value);\n\t\t\trequest->failed = TRUE;\n\t\t} else {\n\t\t\t/* add randomness, but not too much of it */\n\t\t\ttimestamp += extra_secs;\n\t\t\tif (timestamp - ioloop_time > AUTH_REQUEST_MAX_DELAY_SECS)\n\t\t\t\ttimestamp = ioloop_time + AUTH_REQUEST_MAX_DELAY_SECS;\n\t\t\trequest->delay_until = timestamp;\n\t\t}\n\t} else if (strcmp(name, \"allow_real_nets\") == 0) {\n\t\tauth_request_validate_networks(request, name, value,\n\t\t\t\t\t       &request->fields.real_remote_ip);\n\t} else if (str_begins(name, \"userdb_\", &suffix)) {\n\t\t/* for prefetch userdb */\n\t\trequest->userdb_prefetch_set = TRUE;\n\t\tif (request->fields.userdb_reply == NULL)\n\t\t\tauth_request_init_userdb_reply(request, TRUE);\n\t\tif (strcmp(name, \"userdb_userdb_import\") == 0) {\n\t\t\t/* we can't put the whole userdb_userdb_import\n\t\t\t   value to extra_cache_fields or it doesn't work\n\t\t\t   properly. so handle this explicitly. */\n\t\t\tauth_request_passdb_import(request, value,\n\t\t\t\t\t\t   \"userdb_\", default_scheme);\n\t\t\treturn;\n\t\t}\n\t\tauth_request_set_userdb_field(request, suffix, value);\n\t} else if (strcmp(name, \"noauthenticate\") == 0) {\n\t\t/* add \"nopassword\" also so that passdbs won't try to verify\n\t\t   the password. */\n\t\tauth_fields_add(request->fields.extra_fields, name, value, 0);\n\t\tauth_fields_add(request->fields.extra_fields, \"nopassword\", NULL, 0);\n\t} else if (strcmp(name, \"nopassword\") == 0) {\n\t\t/* NULL password - anything goes */\n\t\tconst char *password = request->passdb_password;\n\n\t\tif (password != NULL &&\n\t\t    !auth_fields_exists(request->fields.extra_fields, \"noauthenticate\")) {\n\t\t\t(void)password_get_scheme(&password);\n\t\t\tif (*password != '\\0') {\n\t\t\t\te_error(authdb_event(request),\n\t\t\t\t\t\"nopassword set but password is \"\n\t\t\t\t\t\"non-empty\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\trequest->passdb_password = NULL;\n\t\tauth_fields_add(request->fields.extra_fields, name, value, 0);\n\t\treturn;\n\t} else if (strcmp(name, \"passdb_import\") == 0) {\n\t\tauth_request_passdb_import(request, value, \"\", default_scheme);\n\t\treturn;\n\t} else {\n\t\t/* these fields are returned to client */\n\t\tauth_fields_add(request->fields.extra_fields, name, value, 0);\n\t\treturn;\n\t}\n\n\t/* add the field unconditionally to extra_fields. this is required if\n\t   a) auth cache is used, b) if we're a worker and we'll need to send\n\t   this to the main auth process that can store it in the cache,\n\t   c) for easily checking :protected fields' existence. */\n\tauth_fields_add(request->fields.extra_fields, name, value,\n\t\t\tAUTH_FIELD_FLAG_HIDDEN);\n}",
        "target": 0
    },
    {
        "func": "static struct passdb_module_interface *passdb_interface_find(const char *name)\n{\n\tstruct passdb_module_interface *iface;\n\n\tarray_foreach_elem(&passdb_interfaces, iface) {\n\t\tif (strcmp(iface->name, name) == 0)\n\t\t\treturn iface;\n\t}\n\treturn NULL;\n}",
        "target": 0
    },
    {
        "func": "static enum auth_passdb_skip auth_passdb_skip_parse(const char *str)\n{\n\tif (strcmp(str, \"never\") == 0)\n\t\treturn AUTH_PASSDB_SKIP_NEVER;\n\tif (strcmp(str, \"authenticated\") == 0)\n\t\treturn AUTH_PASSDB_SKIP_AUTHENTICATED;\n\tif (strcmp(str, \"unauthenticated\") == 0)\n\t\treturn AUTH_PASSDB_SKIP_UNAUTHENTICATED;\n\ti_unreached();\n}",
        "target": 0
    },
    {
        "func": "void auth_request_lookup_user(struct auth_request *request,\n\t\t\t      userdb_callback_t *callback)\n{\n\tstruct auth_userdb *userdb = request->userdb;\n\tconst char *cache_key, *error;\n\n\trequest->private_callback.userdb = callback;\n\trequest->user_changed_by_lookup = FALSE;\n\trequest->userdb_lookup = TRUE;\n\trequest->userdb_cache_result = AUTH_REQUEST_CACHE_NONE;\n\tif (request->fields.userdb_reply == NULL)\n\t\tauth_request_init_userdb_reply(request, TRUE);\n\telse {\n\t\t/* we still want to set default_fields. these override any\n\t\t   existing fields set by previous userdbs (because if that is\n\t\t   unwanted, \":protected\" can be used). */\n\t\tif (userdb_template_export(userdb->default_fields_tmpl,\n\t\t\t\t\t   request, &error) < 0) {\n\t\t\te_error(authdb_event(request),\n\t\t\t\t\"Failed to expand default_fields: %s\", error);\n\t\t\tauth_request_userdb_callback(\n\t\t\t\tUSERDB_RESULT_INTERNAL_FAILURE, request);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tauth_request_userdb_lookup_begin(request);\n\n\t/* (for now) auth_cache is shared between passdb and userdb */\n\tcache_key = passdb_cache == NULL ? NULL : userdb->cache_key;\n\tif (cache_key != NULL) {\n\t\tenum userdb_result result;\n\n\t\tif (auth_request_lookup_user_cache(request, cache_key,\n\t\t\t\t\t\t   &result, FALSE)) {\n\t\t\trequest->userdb_cache_result = AUTH_REQUEST_CACHE_HIT;\n\t\t\tauth_request_userdb_callback(result, request);\n\t\t\treturn;\n\t\t} else {\n\t\t\trequest->userdb_cache_result = AUTH_REQUEST_CACHE_MISS;\n\t\t}\n\t}\n\n\tif (userdb->userdb->iface->lookup == NULL) {\n\t\t/* we are deinitializing */\n\t\tauth_request_userdb_callback(USERDB_RESULT_INTERNAL_FAILURE,\n\t\t\t\t\t     request);\n\t} else if (userdb->userdb->blocking)\n\t\tuserdb_blocking_lookup(request);\n\telse\n\t\tuserdb->userdb->iface->lookup(request, auth_request_userdb_callback);\n}",
        "target": 0
    },
    {
        "func": "void auth_request_log_unknown_user(struct auth_request *request,\n\t\t\t\t   const char *subsystem)\n{\n\tauth_request_log_login_failure(request, subsystem, \"unknown user\");\n}",
        "target": 0
    },
    {
        "func": "auth_request_passdb_import(struct auth_request *request, const char *args,\n\t\t\t   const char *key_prefix, const char *default_scheme)\n{\n\tconst char *const *arg, *field;\n\n\tfor (arg = t_strsplit(args, \"\\t\"); *arg != NULL; arg++) {\n\t\tfield = t_strconcat(key_prefix, *arg, NULL);\n\t\tauth_request_set_field_keyvalue(request, field, default_scheme);\n\t}\n}",
        "target": 0
    },
    {
        "func": "void passdb_deinit(struct passdb_module *passdb)\n{\n\tunsigned int idx;\n\n\ti_assert(passdb->init_refcount > 0);\n\n\tif (--passdb->init_refcount > 0)\n\t\treturn;\n\n\tif (passdb_find(passdb->iface.name, passdb->args, &idx) == NULL)\n\t\ti_unreached();\n\tarray_delete(&passdb_modules, idx, 1);\n\n\tif (passdb->iface.deinit != NULL)\n\t\tpassdb->iface.deinit(passdb);\n\n\t/* make sure passdb isn't accessed again */\n\tpassdb->iface = passdb_iface_deinit;\n}",
        "target": 0
    },
    {
        "func": "static void auth_init(struct auth *auth)\n{\n\tstruct auth_passdb *passdb;\n\tstruct auth_userdb *userdb;\n\tstruct dns_lookup_settings dns_set;\n\n\tfor (passdb = auth->masterdbs; passdb != NULL; passdb = passdb->next)\n\t\tauth_passdb_init(passdb);\n\tfor (passdb = auth->passdbs; passdb != NULL; passdb = passdb->next)\n\t\tauth_passdb_init(passdb);\n\tfor (userdb = auth->userdbs; userdb != NULL; userdb = userdb->next)\n\t\tuserdb_init(userdb->userdb);\n\n\ti_zero(&dns_set);\n\tdns_set.dns_client_socket_path = AUTH_DNS_SOCKET_PATH;\n\tdns_set.timeout_msecs = AUTH_DNS_DEFAULT_TIMEOUT_MSECS;\n\tdns_set.idle_timeout_msecs = AUTH_DNS_IDLE_TIMEOUT_MSECS;\n\tdns_set.cache_ttl_secs = AUTH_DNS_CACHE_TTL_SECS;\n\n\tauth->dns_client = dns_client_init(&dns_set);\n}",
        "target": 0
    },
    {
        "func": "static bool auth_request_is_disabled_master_user(struct auth_request *request)\n{\n\tif (request->fields.requested_login_user == NULL ||\n\t    request->passdb != NULL)\n\t\treturn FALSE;\n\n\t/* no masterdbs, master logins not supported */\n\te_info(request->mech_event,\n\t       \"Attempted master login with no master passdbs \"\n\t       \"(trying to log in as user: %s)\",\n\t       request->fields.requested_login_user);\n\treturn TRUE;\n}",
        "target": 0
    },
    {
        "func": "void passdb_register_module(struct passdb_module_interface *iface)\n{\n\tstruct passdb_module_interface *old_iface;\n\n\told_iface = passdb_interface_find(iface->name);\n\tif (old_iface != NULL && old_iface->verify_plain == NULL) {\n\t\t/* replacing a \"support not compiled in\" passdb */\n\t\tpassdb_unregister_module(old_iface);\n\t} else if (old_iface != NULL) {\n\t\ti_panic(\"passdb_register_module(%s): Already registered\",\n\t\t\tiface->name);\n\t}\n\tarray_push_back(&passdb_interfaces, &iface);\n}",
        "target": 0
    },
    {
        "func": "int auth_request_password_verify(struct auth_request *request,\n\t\t\t\t const char *plain_password,\n\t\t\t\t const char *crypted_password,\n\t\t\t\t const char *scheme, const char *subsystem)\n{\n\treturn auth_request_password_verify_log(request, plain_password,\n\t\t\tcrypted_password, scheme, subsystem, TRUE);\n}",
        "target": 0
    },
    {
        "func": "void auth_request_ref(struct auth_request *request)\n{\n\trequest->refcount++;\n}",
        "target": 0
    },
    {
        "func": "void auth_request_log_info(struct auth_request *auth_request,\n\t\t\t   const char *subsystem,\n\t\t\t   const char *format, ...)\n{\n\tstruct event *event = get_request_event(auth_request, subsystem);\n\tva_list va;\n\n\tva_start(va, format);\n\tT_BEGIN {\n\t\tstring_t *str = t_str_new(128);\n\t\tstr_vprintfa(str, format, va);\n\t\te_info(event, \"%s\", str_c(str));\n\t} T_END;\n\tva_end(va);\n}",
        "target": 0
    },
    {
        "func": "void auth_request_log_warning(struct auth_request *auth_request,\n\t\t\t      const char *subsystem,\n\t\t\t      const char *format, ...)\n{\n\tstruct event *event = get_request_event(auth_request, subsystem);\n\tva_list va;\n\n\tva_start(va, format);\n\tT_BEGIN {\n\t\tstring_t *str = t_str_new(128);\n\t\tstr_vprintfa(str, format, va);\n\t\te_warning(event, \"%s\", str_c(str));\n\t} T_END;\n\tva_end(va);\n}",
        "target": 0
    },
    {
        "func": "struct auth_request *auth_request_new_dummy(struct event *parent_event)\n{\n\tstruct auth_request *request;\n\tpool_t pool;\n\n\tpool = pool_alloconly_create(MEMPOOL_GROWING\"auth_request\", 1024);\n\trequest = p_new(pool, struct auth_request, 1);\n\trequest->pool = pool;\n\n\tauth_request_post_alloc_init(request, parent_event);\n\treturn request;\n}",
        "target": 0
    },
    {
        "func": "void auth_request_passdb_lookup_end(struct auth_request *request,\n\t\t\t\t    enum passdb_result result)\n{\n\ti_assert(array_count(&request->authdb_event) > 0);\n\tstruct event *event = authdb_event(request);\n\tstruct event_passthrough *e =\n\t\tevent_create_passthrough(event)->\n\t\tset_name(\"auth_passdb_request_finished\")->\n\t\tadd_str(\"result\", passdb_result_to_string(result));\n\tif (request->passdb_cache_result != AUTH_REQUEST_CACHE_NONE &&\n\t    request->set->cache_ttl != 0 && request->set->cache_size != 0)\n\t\te->add_str(\"cache\", auth_request_cache_result_to_str(request->passdb_cache_result));\n\te_debug(e->event(), \"Finished passdb lookup\");\n\tevent_unref(&event);\n\tarray_pop_back(&request->authdb_event);\n}",
        "target": 0
    },
    {
        "func": "static void auth_request_post_alloc_init(struct auth_request *request, struct event *parent_event)\n{\n\tenum log_type level;\n\trequest->state = AUTH_REQUEST_STATE_NEW;\n\tauth_request_state_count[AUTH_REQUEST_STATE_NEW]++;\n\trequest->refcount = 1;\n\trequest->last_access = ioloop_time;\n\trequest->session_pid = (pid_t)-1;\n\trequest->set = global_auth_settings;\n\trequest->event = event_create(parent_event);\n\trequest->mech_event = event_create(request->event);\n\tauth_request_fields_init(request);\n\n\tlevel = request->set->verbose ? LOG_TYPE_INFO : LOG_TYPE_WARNING;\n\tevent_set_min_log_level(request->event, level);\n\tevent_set_min_log_level(request->mech_event, level);\n\n\tp_array_init(&request->authdb_event, request->pool, 2);\n\tevent_set_log_prefix_callback(request->mech_event, FALSE, get_log_prefix_mech,\n\t\t\t\t      request);\n\tevent_set_forced_debug(request->event, request->set->debug);\n\tevent_add_category(request->event, &event_category_auth);\n}",
        "target": 0
    },
    {
        "func": "enum passdb_result auth_request_password_missing(struct auth_request *request)\n{\n\tif (request->fields.skip_password_check) {\n\t\t/* This passdb wasn't used for authentication */\n\t\treturn PASSDB_RESULT_OK;\n\t}\n\te_info(authdb_event(request),\n\t       \"No password returned (and no nopassword)\");\n\treturn PASSDB_RESULT_PASSWORD_MISMATCH;\n}",
        "target": 0
    },
    {
        "func": "void passdb_unregister_module(struct passdb_module_interface *iface)\n{\n\tstruct passdb_module_interface *const *ifaces;\n\tunsigned int idx;\n\n\tarray_foreach(&passdb_interfaces, ifaces) {\n\t\tif (*ifaces == iface) {\n\t\t\tidx = array_foreach_idx(&passdb_interfaces, ifaces);\n\t\t\tarray_delete(&passdb_interfaces, idx, 1);\n\t\t\treturn;\n\t\t}\n\t}\n\ti_panic(\"passdb_unregister_module(%s): Not registered\", iface->name);\n}",
        "target": 0
    },
    {
        "func": "auth_request_want_skip_userdb(struct auth_request *request,\n\t\t\t      struct auth_userdb *userdb)\n{\n\tswitch (userdb->skip) {\n\tcase AUTH_USERDB_SKIP_NEVER:\n\t\treturn FALSE;\n\tcase AUTH_USERDB_SKIP_FOUND:\n\t\treturn request->userdb_success;\n\tcase AUTH_USERDB_SKIP_NOTFOUND:\n\t\treturn !request->userdb_success;\n\t}\n\ti_unreached();\n}",
        "target": 0
    },
    {
        "func": "void auth_request_refresh_last_access(struct auth_request *request)\n{\n\trequest->last_access = ioloop_time;\n\tif (request->to_abort != NULL)\n\t\ttimeout_reset(request->to_abort);\n}",
        "target": 0
    },
    {
        "func": "void auth_request_set_field_keyvalue(struct auth_request *request,\n\t\t\t\t     const char *field,\n\t\t\t\t     const char *default_scheme)\n{\n\tconst char *key, *value;\n\n\tvalue = strchr(field, '=');\n\tif (value == NULL) {\n\t\tkey = field;\n\t\tvalue = \"\";\n\t} else {\n\t\tkey = t_strdup_until(field, value);\n\t\tvalue++;\n\t}\n\tauth_request_set_field(request, key, value, default_scheme);\n}",
        "target": 0
    },
    {
        "func": "auth_request_handle_passdb_callback(enum passdb_result *result,\n\t\t\t\t    struct auth_request *request)\n{\n\tstruct auth_passdb *next_passdb;\n\tenum auth_db_rule result_rule;\n\tbool passdb_continue = FALSE;\n\n\tif (request->passdb_password != NULL) {\n\t\tsafe_memset(request->passdb_password, 0,\n\t\t\t    strlen(request->passdb_password));\n\t}\n\n\tauth_request_passdb_lookup_end(request, *result);\n\n\tif (request->passdb->set->deny &&\n\t    *result != PASSDB_RESULT_USER_UNKNOWN) {\n\t\t/* deny passdb. we can get through this step only if the\n\t\t   lookup returned that user doesn't exist in it. internal\n\t\t   errors are fatal here. */\n\t\tif (*result != PASSDB_RESULT_INTERNAL_FAILURE) {\n\t\t\te_info(authdb_event(request),\n\t\t\t       \"User found from deny passdb\");\n\t\t\t*result = PASSDB_RESULT_USER_DISABLED;\n\t\t}\n\t\treturn TRUE;\n\t}\n\tif (request->failed) {\n\t\t/* The passdb didn't fail, but something inside it failed\n\t\t   (e.g. allow_nets mismatch). Make sure we'll fail this\n\t\t   lookup, but reset the failure so the next passdb can\n\t\t   succeed. */\n\t\tif (*result == PASSDB_RESULT_OK)\n\t\t\t*result = PASSDB_RESULT_USER_UNKNOWN;\n\t\trequest->failed = FALSE;\n\t}\n\n\t/* users that exist but can't log in are special. we don't try to match\n\t   any of the success/failure rules to them. they'll always fail. */\n\tswitch (*result) {\n\tcase PASSDB_RESULT_USER_DISABLED:\n\t\treturn TRUE;\n\tcase PASSDB_RESULT_PASS_EXPIRED:\n\t\tauth_request_set_field(request, \"reason\",\n\t\t\t\t\t\"Password expired\", NULL);\n\t\treturn TRUE;\n\n\tcase PASSDB_RESULT_OK:\n\t\tresult_rule = request->passdb->result_success;\n\t\tbreak;\n\tcase PASSDB_RESULT_INTERNAL_FAILURE:\n\t\tresult_rule = request->passdb->result_internalfail;\n\t\tbreak;\n\tcase PASSDB_RESULT_NEXT:\n\t\te_debug(authdb_event(request),\n\t\t\t\"Not performing authentication (noauthenticate set)\");\n\t\tresult_rule = AUTH_DB_RULE_CONTINUE;\n\t\tbreak;\n\tcase PASSDB_RESULT_SCHEME_NOT_AVAILABLE:\n\tcase PASSDB_RESULT_USER_UNKNOWN:\n\tcase PASSDB_RESULT_PASSWORD_MISMATCH:\n\tdefault:\n\t\tresult_rule = request->passdb->result_failure;\n\t\tbreak;\n\t}\n\n\tswitch (result_rule) {\n\tcase AUTH_DB_RULE_RETURN:\n\t\tbreak;\n\tcase AUTH_DB_RULE_RETURN_OK:\n\t\trequest->passdb_success = TRUE;\n\t\tbreak;\n\tcase AUTH_DB_RULE_RETURN_FAIL:\n\t\trequest->passdb_success = FALSE;\n\t\tbreak;\n\tcase AUTH_DB_RULE_CONTINUE:\n\t\tpassdb_continue = TRUE;\n\t\tif (*result == PASSDB_RESULT_OK) {\n\t\t\t/* password was successfully verified. don't bother\n\t\t\t   checking it again. */\n\t\t\tauth_request_set_password_verified(request);\n\t\t}\n\t\tbreak;\n\tcase AUTH_DB_RULE_CONTINUE_OK:\n\t\tpassdb_continue = TRUE;\n\t\trequest->passdb_success = TRUE;\n\t\t/* password was successfully verified. don't bother\n\t\t   checking it again. */\n\t\tauth_request_set_password_verified(request);\n\t\tbreak;\n\tcase AUTH_DB_RULE_CONTINUE_FAIL:\n\t\tpassdb_continue = TRUE;\n\t\trequest->passdb_success = FALSE;\n\t\tbreak;\n\t}\n\t/* nopassword check is specific to a single passdb and shouldn't leak\n\t   to the next one. we already added it to cache. */\n\tauth_fields_remove(request->fields.extra_fields, \"nopassword\");\n\tauth_fields_remove(request->fields.extra_fields, \"noauthenticate\");\n\n\tif (request->fields.requested_login_user != NULL &&\n\t    *result == PASSDB_RESULT_OK) {\n\t\tauth_request_master_user_login_finish(request);\n\t\t/* if the passdb lookup continues, it continues with non-master\n\t\t   passdbs for the requested_login_user. */\n\t\tnext_passdb = auth_request_get_auth(request)->passdbs;\n\t} else {\n\t\tnext_passdb = request->passdb->next;\n\t}\n\n\twhile (next_passdb != NULL &&\n\t\tauth_request_want_skip_passdb(request, next_passdb))\n\t\tnext_passdb = next_passdb->next;\n\n\tif (*result == PASSDB_RESULT_OK || *result == PASSDB_RESULT_NEXT) {\n\t\t/* this passdb lookup succeeded, preserve its extra fields */\n\t\tauth_fields_snapshot(request->fields.extra_fields);\n\t\trequest->snapshot_have_userdb_prefetch_set =\n\t\t\trequest->userdb_prefetch_set;\n\t\tif (request->fields.userdb_reply != NULL)\n\t\t\tauth_fields_snapshot(request->fields.userdb_reply);\n\t} else {\n\t\t/* this passdb lookup failed, remove any extra fields it set */\n\t\tauth_fields_rollback(request->fields.extra_fields);\n\t\tif (request->fields.userdb_reply != NULL) {\n\t\t\tauth_fields_rollback(request->fields.userdb_reply);\n\t\t\trequest->userdb_prefetch_set =\n\t\t\t\trequest->snapshot_have_userdb_prefetch_set;\n\t\t}\n\t}\n\n\tif (passdb_continue && next_passdb != NULL) {\n\t\t/* try next passdb. */\n\t\t  request->passdb = next_passdb;\n\t\trequest->passdb_password = NULL;\n\n\t\tif (*result == PASSDB_RESULT_USER_UNKNOWN) {\n\t\t\t/* remember that we did at least one successful\n\t\t\t   passdb lookup */\n\t\t\trequest->passdbs_seen_user_unknown = TRUE;\n\t\t} else if (*result == PASSDB_RESULT_INTERNAL_FAILURE) {\n\t\t\t/* remember that we have had an internal failure. at\n\t\t\t   the end return internal failure if we couldn't\n\t\t\t   successfully login. */\n\t\t\trequest->passdbs_seen_internal_failure = TRUE;\n\t\t}\n\t\treturn FALSE;\n\t} else if (*result == PASSDB_RESULT_NEXT) {\n\t\t/* admin forgot to put proper passdb last */\n\t\te_error(request->event,\n\t\t\t\"%sLast passdb had noauthenticate field, cannot authenticate user\",\n\t\t\tauth_request_get_log_prefix_db(request));\n\t\t*result = PASSDB_RESULT_INTERNAL_FAILURE;\n\t} else if (request->passdb_success) {\n\t\t/* either this or a previous passdb lookup succeeded. */\n\t\t*result = PASSDB_RESULT_OK;\n\t} else if (request->passdbs_seen_internal_failure) {\n\t\t/* last passdb lookup returned internal failure. it may have\n\t\t   had the correct password, so return internal failure\n\t\t   instead of plain failure. */\n\t\t*result = PASSDB_RESULT_INTERNAL_FAILURE;\n\t}\n\treturn TRUE;\n}",
        "target": 0
    },
    {
        "func": "void auth_request_log_finished(struct auth_request *request)\n{\n\tif (request->event_finished_sent)\n\t\treturn;\n\trequest->event_finished_sent = TRUE;\n\tstring_t *str = t_str_new(64);\n\tauth_request_get_log_prefix(str, request, \"auth\");\n\tstruct event_passthrough *e =\n\t\tauth_request_finished_event(request, request->event)->\n\t\tset_name(\"auth_request_finished\");\n\te_debug(e->event(), \"%sAuth request finished\", str_c(str));\n}",
        "target": 0
    },
    {
        "func": "void auths_free(void)\n{\n\tstruct auth **auth;\n\tunsigned int i, count;\n\n\t/* deinit in reverse order, because modules have been allocated by\n\t   the first auth pool that used them */\n\tauth = array_get_modifiable(&auths, &count);\n\tfor (i = count; i > 0; i--)\n\t\tpool_unref(&auth[i-1]->pool);\n\tarray_free(&auths);\n}",
        "target": 0
    },
    {
        "func": "static struct event *get_request_event(struct auth_request *request,\n\t\t\t\t       const char *subsystem)\n{\n\tif (subsystem == AUTH_SUBSYS_DB)\n\t\treturn authdb_event(request);\n\telse if (subsystem == AUTH_SUBSYS_MECH)\n\t\treturn request->mech_event;\n\telse\n\t\treturn request->event;\n}",
        "target": 0
    },
    {
        "func": "auth_request_proxy_dns_callback(const struct dns_lookup_result *result,\n\t\t\t\tstruct auth_request_proxy_dns_lookup_ctx *ctx)\n{\n\tstruct auth_request *request = ctx->request;\n\tconst char *host;\n\tunsigned int i;\n\tbool proxy_host_is_self;\n\n\trequest->dns_lookup_ctx = NULL;\n\tctx->dns_lookup = NULL;\n\n\thost = auth_fields_find(request->fields.extra_fields, \"host\");\n\ti_assert(host != NULL);\n\n\tif (result->ret != 0) {\n\t\tauth_request_log_error(request, AUTH_SUBSYS_PROXY,\n\t\t\t\"DNS lookup for %s failed: %s\", host, result->error);\n\t\trequest->internal_failure = TRUE;\n\t\tauth_request_proxy_finish_failure(request);\n\t} else {\n\t\tif (result->msecs > AUTH_DNS_WARN_MSECS) {\n\t\t\tauth_request_log_warning(request, AUTH_SUBSYS_PROXY,\n\t\t\t\t\"DNS lookup for %s took %u.%03u s\",\n\t\t\t\thost, result->msecs/1000, result->msecs % 1000);\n\t\t}\n\t\tauth_fields_add(request->fields.extra_fields, \"hostip\",\n\t\t\t\tnet_ip2addr(&result->ips[0]), 0);\n\t\tproxy_host_is_self = FALSE;\n\t\tfor (i = 0; i < result->ips_count; i++) {\n\t\t\tif (auth_request_proxy_ip_is_self(request,\n\t\t\t\t\t\t\t  &result->ips[i])) {\n\t\t\t\tproxy_host_is_self = TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tauth_request_proxy_finish_ip(request, proxy_host_is_self);\n\t}\n\tif (ctx->callback != NULL)\n\t\tctx->callback(result->ret == 0, request);\n\tauth_request_unref(&request);\n}",
        "target": 0
    },
    {
        "func": "void auth_request_userdb_callback(enum userdb_result result,\n\t\t\t\t  struct auth_request *request)\n{\n\tstruct auth_userdb *userdb = request->userdb;\n\tstruct auth_userdb *next_userdb;\n\tenum auth_db_rule result_rule;\n\tconst char *error;\n\tbool userdb_continue = FALSE;\n\n\tswitch (result) {\n\tcase USERDB_RESULT_OK:\n\t\tresult_rule = userdb->result_success;\n\t\tbreak;\n\tcase USERDB_RESULT_INTERNAL_FAILURE:\n\t\tresult_rule = userdb->result_internalfail;\n\t\tbreak;\n\tcase USERDB_RESULT_USER_UNKNOWN:\n\tdefault:\n\t\tresult_rule = userdb->result_failure;\n\t\tbreak;\n\t}\n\n\tswitch (result_rule) {\n\tcase AUTH_DB_RULE_RETURN:\n\t\tbreak;\n\tcase AUTH_DB_RULE_RETURN_OK:\n\t\trequest->userdb_success = TRUE;\n\t\tbreak;\n\tcase AUTH_DB_RULE_RETURN_FAIL:\n\t\trequest->userdb_success = FALSE;\n\t\tbreak;\n\tcase AUTH_DB_RULE_CONTINUE:\n\t\tuserdb_continue = TRUE;\n\t\tbreak;\n\tcase AUTH_DB_RULE_CONTINUE_OK:\n\t\tuserdb_continue = TRUE;\n\t\trequest->userdb_success = TRUE;\n\t\tbreak;\n\tcase AUTH_DB_RULE_CONTINUE_FAIL:\n\t\tuserdb_continue = TRUE;\n\t\trequest->userdb_success = FALSE;\n\t\tbreak;\n\t}\n\n\tauth_request_userdb_lookup_end(request, result);\n\n\tnext_userdb = userdb->next;\n\twhile (next_userdb != NULL &&\n\t\tauth_request_want_skip_userdb(request, next_userdb))\n\t\tnext_userdb = next_userdb->next;\n\n\tif (userdb_continue && next_userdb != NULL) {\n\t\t/* try next userdb. */\n\t\tif (result == USERDB_RESULT_INTERNAL_FAILURE)\n\t\t\trequest->userdbs_seen_internal_failure = TRUE;\n\n\t\tif (result == USERDB_RESULT_OK) {\n\t\t\t/* this userdb lookup succeeded, preserve its extra\n\t\t\t   fields */\n\t\t\tif (userdb_template_export(userdb->override_fields_tmpl,\n\t\t\t\t\t\t   request, &error) < 0) {\n\t\t\t\te_error(request->event,\n\t\t\t\t\t\"%sFailed to expand override_fields: %s\",\n\t\t\t\t\tauth_request_get_log_prefix_db(request), error);\n\t\t\t\trequest->private_callback.userdb(\n\t\t\t\t\tUSERDB_RESULT_INTERNAL_FAILURE, request);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tauth_fields_snapshot(request->fields.userdb_reply);\n\t\t} else {\n\t\t\t/* this userdb lookup failed, remove any extra fields\n\t\t\t   it set */\n\t\t\tauth_fields_rollback(request->fields.userdb_reply);\n\t\t}\n\t\trequest->user_changed_by_lookup = FALSE;\n\n\t\trequest->userdb = next_userdb;\n\t\tauth_request_lookup_user(request,\n\t\t\t\t\t request->private_callback.userdb);\n\t\treturn;\n\t}\n\n\tif (request->userdb_success) {\n\t\tif (userdb_template_export(userdb->override_fields_tmpl,\n\t\t\t\t\t   request, &error) < 0) {\n\t\t\te_error(request->event,\n\t\t\t\t\"%sFailed to expand override_fields: %s\",\n\t\t\t\tauth_request_get_log_prefix_db(request), error);\n\t\t\tresult = USERDB_RESULT_INTERNAL_FAILURE;\n\t\t} else {\n\t\t\tresult = USERDB_RESULT_OK;\n\t\t}\n\t} else if (request->userdbs_seen_internal_failure ||\n\t\t   result == USERDB_RESULT_INTERNAL_FAILURE) {\n\t\t/* one of the userdb lookups failed. the user might have been\n\t\t   in there, so this is an internal failure */\n\t\tresult = USERDB_RESULT_INTERNAL_FAILURE;\n\t} else if (request->client_pid != 0) {\n\t\t/* this was an actual login attempt, the user should\n\t\t   have been found. */\n\t\tif (auth_request_get_auth(request)->userdbs->next == NULL) {\n\t\t\te_error(request->event,\n\t\t\t\t\"%suser not found from userdb\",\n\t\t\t\tauth_request_get_log_prefix_db(request));\n\t\t} else {\n\t\t\te_error(request->mech_event,\n\t\t\t\t\"user not found from any userdbs\");\n\t\t}\n\t\tresult = USERDB_RESULT_USER_UNKNOWN;\n\t} else {\n\t\tresult = USERDB_RESULT_USER_UNKNOWN;\n\t}\n\n\tif (request->userdb_lookup_tempfailed) {\n\t\t/* no caching */\n\t} else if (result != USERDB_RESULT_INTERNAL_FAILURE) {\n\t\tif (request->userdb_cache_result != AUTH_REQUEST_CACHE_HIT)\n\t\t\tauth_request_userdb_save_cache(request, result);\n\t} else if (passdb_cache != NULL && userdb->cache_key != NULL) {\n\t\t/* lookup failed. if we're looking here only because the\n\t\t   request was expired in cache, fallback to using cached\n\t\t   expired record. */\n\t\tconst char *cache_key = userdb->cache_key;\n\n\t\tif (auth_request_lookup_user_cache(request, cache_key,\n\t\t\t\t\t\t   &result, TRUE)) {\n\t\t\te_info(request->event,\n\t\t\t       \"%sFalling back to expired data from cache\",\n\t\t\t\tauth_request_get_log_prefix_db(request));\n\t\t}\n\t}\n\n\t request->private_callback.userdb(result, request);\n}",
        "target": 0
    },
    {
        "func": "int auth_request_password_verify_log(struct auth_request *request,\n\t\t\t\t const char *plain_password,\n\t\t\t\t const char *crypted_password,\n\t\t\t\t const char *scheme, const char *subsystem,\n\t\t\t\t bool log_password_mismatch)\n{\n\tconst unsigned char *raw_password;\n\tsize_t raw_password_size;\n\tconst char *error;\n\tint ret;\n\tstruct password_generate_params gen_params = {\n\t\t.user = request->fields.original_username,\n\t\t.rounds = 0\n\t};\n\n\tif (request->fields.skip_password_check) {\n\t\t/* passdb continue* rule after a successful authentication */\n\t\treturn 1;\n\t}\n\n\tif (request->passdb->set->deny) {\n\t\t/* this is a deny database, we don't care about the password */\n\t\treturn 0;\n\t}\n\n\tif (auth_fields_exists(request->fields.extra_fields, \"nopassword\")) {\n\t\tauth_request_log_debug(request, subsystem,\n\t\t\t\t\t\"Allowing any password\");\n\t\treturn 1;\n\t}\n\n\tret = password_decode(crypted_password, scheme,\n\t\t\t      &raw_password, &raw_password_size, &error);\n\tif (ret <= 0) {\n\t\tif (ret < 0) {\n\t\t\tauth_request_log_error(request, subsystem,\n\t\t\t\t\"Password data is not valid for scheme %s: %s\",\n\t\t\t\tscheme, error);\n\t\t} else {\n\t\t\tauth_request_log_error(request, subsystem,\n\t\t\t\t\t\t\"Unknown scheme %s\", scheme);\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/* Use original_username since it may be important for some\n\t   password schemes (eg. digest-md5). Otherwise the username is used\n\t   only for logging purposes. */\n\tret = password_verify(plain_password, &gen_params,\n\t\t\t      scheme, raw_password, raw_password_size, &error);\n\tif (ret < 0) {\n\t\tconst char *password_str = request->set->debug_passwords ?\n\t\t\tt_strdup_printf(\" '%s'\", crypted_password) : \"\";\n\t\tauth_request_log_error(request, subsystem,\n\t\t\t\t\t\"Invalid password%s in passdb: %s\",\n\t\t\t\t\tpassword_str, error);\n\t} else if (ret == 0) {\n\t\tif (log_password_mismatch)\n\t\t\tauth_request_log_password_mismatch(request, subsystem);\n\t}\n\tif (ret <= 0 && request->set->debug_passwords) T_BEGIN {\n\t\tlog_password_failure(request, plain_password,\n\t\t\t\t     crypted_password, scheme,\n\t\t\t\t     &gen_params,\n\t\t\t\t     subsystem);\n\t} T_END;\n\treturn ret;\n}",
        "target": 0
    },
    {
        "func": "struct auth *auth_request_get_auth(struct auth_request *request)\n{\n\treturn auth_find_service(request->fields.service);\n}",
        "target": 0
    },
    {
        "func": "static bool auth_request_lookup_user_cache(struct auth_request *request,\n\t\t\t\t\t   const char *key,\n\t\t\t\t\t   enum userdb_result *result_r,\n\t\t\t\t\t   bool use_expired)\n{\n\tconst char *value;\n\tstruct auth_cache_node *node;\n\tbool expired, neg_expired;\n\n\tvalue = auth_cache_lookup(passdb_cache, request, key, &node,\n\t\t\t\t  &expired, &neg_expired);\n\tif (value == NULL || (expired && !use_expired)) {\n\t\trequest->userdb_cache_result = AUTH_REQUEST_CACHE_MISS;\n\t\te_debug(request->event,\n\t\t\tvalue == NULL ? \"%suserdb cache miss\" :\n\t\t\t\"%suserdb cache expired\",\n\t\t\tauth_request_get_log_prefix_db(request));\n\t\treturn FALSE;\n\t}\n\trequest->userdb_cache_result = AUTH_REQUEST_CACHE_HIT;\n\te_debug(request->event,\n\t\t\"%suserdb cache hit: %s\",\n\t\tauth_request_get_log_prefix_db(request), value);\n\n\tif (*value == '\\0') {\n\t\t/* negative cache entry */\n\t\t*result_r = USERDB_RESULT_USER_UNKNOWN;\n\t\tauth_request_init_userdb_reply(request, FALSE);\n\t\treturn TRUE;\n\t}\n\n\t/* We want to preserve any userdb fields set by the earlier passdb\n\t   lookup, so initialize userdb_reply only if it doesn't exist.\n\t   Don't add userdb's default_fields, because the entire userdb part of\n\t   the result comes from the cache. */\n\tif (request->fields.userdb_reply == NULL)\n\t\tauth_request_init_userdb_reply(request, FALSE);\n\tauth_request_userdb_import(request, value);\n\t*result_r = USERDB_RESULT_OK;\n\treturn TRUE;\n}",
        "target": 0
    },
    {
        "func": "auth_mech_verify_passdb(const struct auth *auth, const struct mech_module_list *list)\n{\n\tswitch (list->module.passdb_need) {\n\tcase MECH_PASSDB_NEED_NOTHING:\n\t\tbreak;\n\tcase MECH_PASSDB_NEED_VERIFY_PLAIN:\n\t\tif (!auth_passdb_list_have_verify_plain(auth))\n\t\t\treturn FALSE;\n\t\tbreak;\n\tcase MECH_PASSDB_NEED_VERIFY_RESPONSE:\n\tcase MECH_PASSDB_NEED_LOOKUP_CREDENTIALS:\n\t\tif (!auth_passdb_list_have_lookup_credentials(auth))\n\t\t\treturn FALSE;\n\t\tbreak;\n\tcase MECH_PASSDB_NEED_SET_CREDENTIALS:\n\t\tif (!auth_passdb_list_have_lookup_credentials(auth))\n\t\t\treturn FALSE;\n\t\tif (!auth_passdb_list_have_set_credentials(auth))\n\t\t\treturn FALSE;\n\t\tbreak;\n\t}\n\treturn TRUE;\n}",
        "target": 0
    },
    {
        "func": "static int auth_request_proxy_host_lookup(struct auth_request *request,\n\t\t\t\t\t  const char *host,\n\t\t\t\t\t  auth_request_proxy_cb_t *callback)\n{\n\tstruct auth *auth = auth_default_service();\n\tstruct auth_request_proxy_dns_lookup_ctx *ctx;\n\tconst char *value;\n\tunsigned int secs;\n\n\t/* need to do dns lookup for the host */\n\tvalue = auth_fields_find(request->fields.extra_fields, \"proxy_timeout\");\n\tif (value != NULL) {\n\t\tif (str_to_uint(value, &secs) < 0) {\n\t\t\tauth_request_log_error(request, AUTH_SUBSYS_PROXY,\n\t\t\t\t\"Invalid proxy_timeout value: %s\", value);\n\t\t}\n\t}\n\n\tctx = p_new(request->pool, struct auth_request_proxy_dns_lookup_ctx, 1);\n\tctx->request = request;\n\tauth_request_ref(request);\n\trequest->dns_lookup_ctx = ctx;\n\n\tif (dns_client_lookup(auth->dns_client, host, request->event,\n\t\t\t      auth_request_proxy_dns_callback, ctx,\n\t\t\t      &ctx->dns_lookup) < 0) {\n\t\t/* failed early */\n\t\treturn -1;\n\t}\n\tctx->callback = callback;\n\treturn 0;\n}",
        "target": 0
    },
    {
        "func": "void auths_init(void)\n{\n\tstruct auth *auth;\n\n\t/* sanity checks */\n\ti_assert(auth_request_var_expand_static_tab[AUTH_REQUEST_VAR_TAB_USER_IDX].key == 'u');\n\ti_assert(auth_request_var_expand_static_tab[AUTH_REQUEST_VAR_TAB_USERNAME_IDX].key == 'n');\n\ti_assert(auth_request_var_expand_static_tab[AUTH_REQUEST_VAR_TAB_DOMAIN_IDX].key == 'd');\n\ti_assert(auth_request_var_expand_static_tab[AUTH_REQUEST_VAR_TAB_COUNT].key == '\\0' &&\n\t\t auth_request_var_expand_static_tab[AUTH_REQUEST_VAR_TAB_COUNT].long_key == NULL);\n\ti_assert(auth_request_var_expand_static_tab[AUTH_REQUEST_VAR_TAB_COUNT-1].key != '\\0' ||\n\t\t auth_request_var_expand_static_tab[AUTH_REQUEST_VAR_TAB_COUNT-1].long_key != NULL);\n\n\tarray_foreach_elem(&auths, auth)\n\t\tauth_init(auth);\n}",
        "target": 0
    },
    {
        "func": "void passdbs_init(void)\n{\n\ti_array_init(&passdb_interfaces, 16);\n\ti_array_init(&passdb_modules, 16);\n\tpassdb_register_module(&passdb_passwd);\n\tpassdb_register_module(&passdb_bsdauth);\n\tpassdb_register_module(&passdb_dict);\n#ifdef HAVE_LUA\n\tpassdb_register_module(&passdb_lua);\n#endif\n\tpassdb_register_module(&passdb_passwd_file);\n\tpassdb_register_module(&passdb_pam);\n\tpassdb_register_module(&passdb_ldap);\n\tpassdb_register_module(&passdb_sql);\n\tpassdb_register_module(&passdb_static);\n\tpassdb_register_module(&passdb_oauth2);\n}",
        "target": 0
    },
    {
        "func": "void auths_preinit(const struct auth_settings *set, pool_t pool,\n\t\t   const struct mechanisms_register *reg,\n\t\t   const char *const *services)\n{\n\tstruct master_service_settings_output set_output;\n\tconst struct auth_settings *service_set;\n\tstruct auth *auth;\n\tunsigned int i;\n\tconst char *not_service = NULL;\n\tbool check_default = TRUE;\n\n\tauth_event = event_create(NULL);\n\tevent_set_forced_debug(auth_event, set->debug);\n\tevent_add_category(auth_event, &event_category_auth);\n\ti_array_init(&auths, 8);\n\n\tauth = auth_preinit(set, NULL, pool, reg);\n\tarray_push_back(&auths, &auth);\n\n\tfor (i = 0; services[i] != NULL; i++) {\n\t\tif (services[i][0] == '!') {\n\t\t\tif (not_service != NULL) {\n\t\t\t\ti_fatal(\"Can't have multiple protocol \"\n\t\t\t\t\t\"!services (seen %s and %s)\",\n\t\t\t\t\tnot_service, services[i]);\n\t\t\t}\n\t\t\tnot_service = services[i];\n\t\t}\n\t\tservice_set = auth_settings_read(services[i], pool,\n\t\t\t\t\t\t &set_output);\n\t\tauth = auth_preinit(service_set, services[i], pool, reg);\n\t\tarray_push_back(&auths, &auth);\n\t}\n\n\tif (not_service != NULL && str_array_find(services, not_service+1))\n\t\tcheck_default = FALSE;\n\n\tarray_foreach_elem(&auths, auth) {\n\t\tif (auth->service != NULL || check_default)\n\t\t\tauth_mech_list_verify_passdb(auth);\n\t}\n}",
        "target": 0
    },
    {
        "func": "auth_request_append_password(struct auth_request *request, string_t *str)\n{\n\tconst char *p, *log_type = request->set->verbose_passwords;\n\tunsigned int max_len = 1024;\n\n\tif (request->mech_password == NULL)\n\t\treturn;\n\n\tp = strchr(log_type, ':');\n\tif (p != NULL) {\n\t\tif (str_to_uint(p+1, &max_len) < 0)\n\t\t\ti_unreached();\n\t\tlog_type = t_strdup_until(log_type, p);\n\t}\n\n\tif (strcmp(log_type, \"plain\") == 0) {\n\t\tstr_printfa(str, \"(given password: %s)\",\n\t\t\t    t_strndup(request->mech_password, max_len));\n\t} else if (strcmp(log_type, \"sha1\") == 0) {\n\t\tunsigned char sha1[SHA1_RESULTLEN];\n\n\t\tsha1_get_digest(request->mech_password,\n\t\t\t\tstrlen(request->mech_password), sha1);\n\t\tstr_printfa(str, \"(SHA1 of given password: %s)\",\n\t\t\t    t_strndup(binary_to_hex(sha1, sizeof(sha1)),\n\t\t\t\t      max_len));\n\t} else {\n\t\ti_unreached();\n\t}\n}",
        "target": 0
    },
    {
        "func": "void auth_request_set_credentials(struct auth_request *request,\n\t\t\t\t  const char *scheme, const char *data,\n\t\t\t\t  set_credentials_callback_t *callback)\n{\n\tstruct auth_passdb *passdb = request->passdb;\n\tconst char *cache_key, *new_credentials;\n\n\tcache_key = passdb_cache == NULL ? NULL : passdb->cache_key;\n\tif (cache_key != NULL)\n\t\tauth_cache_remove(passdb_cache, request, cache_key);\n\n\trequest->private_callback.set_credentials = callback;\n\n\tnew_credentials = t_strdup_printf(\"{%s}%s\", scheme, data);\n\tif (passdb->passdb->blocking)\n\t\tpassdb_blocking_set_credentials(request, new_credentials);\n\telse if (passdb->passdb->iface.set_credentials != NULL) {\n\t\tpassdb->passdb->iface.set_credentials(request, new_credentials,\n\t\t\t\t\t\t      callback);\n\t} else {\n\t\t/* this passdb doesn't support credentials update */\n\t\tcallback(FALSE, request);\n\t}\n}",
        "target": 0
    },
    {
        "func": "void auth_request_fail(struct auth_request *request)\n{\n\ti_assert(request->state == AUTH_REQUEST_STATE_MECH_CONTINUE);\n\n\tauth_request_set_state(request, AUTH_REQUEST_STATE_FINISHED);\n\tauth_request_refresh_last_access(request);\n\tauth_request_log_finished(request);\n\tauth_request_handler_reply(request, AUTH_CLIENT_RESULT_FAILURE, \"\", 0);\n}",
        "target": 0
    },
    {
        "func": "void auth_request_set_userdb_field_values(struct auth_request *request,\n\t\t\t\t\t  const char *name,\n\t\t\t\t\t  const char *const *values)\n{\n\tif (*values == NULL)\n\t\treturn;\n\n\tif (strcmp(name, \"gid\") == 0) {\n\t\t/* convert gids to comma separated list */\n\t\tstring_t *value;\n\t\tgid_t gid;\n\n\t\tvalue = t_str_new(128);\n\t\tfor (; *values != NULL; values++) {\n\t\t\tgid = userdb_parse_gid(request, *values);\n\t\t\tif (gid == (gid_t)-1) {\n\t\t\t\trequest->userdb_lookup_tempfailed = TRUE;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (str_len(value) > 0)\n\t\t\t\tstr_append_c(value, ',');\n\t\t\tstr_append(value, dec2str(gid));\n\t\t}\n\t\tauth_fields_add(request->fields.userdb_reply, name, str_c(value), 0);\n\t} else {\n\t\t/* add only one */\n\t\tif (values[1] != NULL) {\n\t\t\te_warning(authdb_event(request),\n\t\t\t\t  \"Multiple values found for '%s', \"\n\t\t\t\t  \"using value '%s'\", name, *values);\n\t\t}\n\t\tauth_request_set_userdb_field(request, name, *values);\n\t}\n}",
        "target": 0
    },
    {
        "func": "auth_request_proxy_finish_ip(struct auth_request *request,\n\t\t\t     bool proxy_host_is_self)\n{\n\tconst struct auth_request_fields *fields = &request->fields;\n\n\tif (!auth_fields_exists(fields->extra_fields, \"proxy_maybe\")) {\n\t\t/* proxying */\n\t} else if (!proxy_host_is_self ||\n\t\t   !auth_request_proxy_is_self(request)) {\n\t\t/* proxy destination isn't ourself - proxy */\n\t\tauth_fields_remove(fields->extra_fields, \"proxy_maybe\");\n\t\tauth_fields_add(fields->extra_fields, \"proxy\", NULL, 0);\n\t} else {\n\t\t/* proxying to ourself - log in without proxying by dropping\n\t\t   all the proxying fields. */\n\t\tbool proxy_always = auth_fields_exists(fields->extra_fields,\n\t\t\t\t\t\t\t\"proxy_always\");\n\n\t\tauth_request_proxy_finish_failure(request);\n\t\tif (proxy_always) {\n\t\t\t/* setup where \"self\" refers to the local director\n\t\t\t   cluster, while \"non-self\" refers to remote clusters.\n\n\t\t\t   we've matched self here, so add proxy field and\n\t\t\t   let director fill the host. */\n\t\t\tauth_fields_add(request->fields.extra_fields,\n\t\t\t\t\t\"proxy\", NULL, 0);\n\t\t}\n\t}\n}",
        "target": 0
    },
    {
        "func": "static bool auth_passdb_list_have_set_credentials(const struct auth *auth)\n{\n\tconst struct auth_passdb *passdb;\n\n\tfor (passdb = auth->masterdbs; passdb != NULL; passdb = passdb->next) {\n\t\tif (passdb->passdb->iface.set_credentials != NULL)\n\t\t\treturn TRUE;\n\t}\n\tfor (passdb = auth->passdbs; passdb != NULL; passdb = passdb->next) {\n\t\tif (passdb->passdb->iface.set_credentials != NULL)\n\t\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}",
        "target": 0
    },
    {
        "func": "struct auth *auth_find_service(const char *name)\n{\n\tstruct auth *const *a;\n\tunsigned int i, count;\n\n\ta = array_get(&auths, &count);\n\tif (name != NULL) {\n\t\tfor (i = 1; i < count; i++) {\n\t\t\tif (strcmp(a[i]->service, name) == 0)\n\t\t\t\treturn a[i];\n\t\t}\n\t\t/* not found. maybe we can instead find a !service */\n\t\tfor (i = 1; i < count; i++) {\n\t\t\tif (a[i]->service[0] == '!' &&\n\t\t\t    strcmp(a[i]->service + 1, name) != 0)\n\t\t\t\treturn a[i];\n\t\t}\n\t}\n\treturn a[0];\n}",
        "target": 0
    },
    {
        "func": "static void auth_deinit(struct auth *auth)\n{\n\tstruct auth_passdb *passdb;\n\tstruct auth_userdb *userdb;\n\n\tfor (passdb = auth->masterdbs; passdb != NULL; passdb = passdb->next)\n\t\tpassdb_deinit(passdb->passdb);\n\tfor (passdb = auth->passdbs; passdb != NULL; passdb = passdb->next)\n\t\tpassdb_deinit(passdb->passdb);\n\tfor (userdb = auth->userdbs; userdb != NULL; userdb = userdb->next)\n\t\tuserdb_deinit(userdb->userdb);\n\n\tdns_client_deinit(&auth->dns_client);\n}",
        "target": 0
    },
    {
        "func": "auth_userdb_preinit(struct auth *auth, const struct auth_userdb_settings *set)\n{\n        struct auth_userdb *auth_userdb, **dest;\n\n\tauth_userdb = p_new(auth->pool, struct auth_userdb, 1);\n\tauth_userdb->set = set;\n\tauth_userdb->skip = auth_userdb_skip_parse(set->skip);\n\tauth_userdb->result_success =\n\t\tauth_db_rule_parse(set->result_success);\n\tauth_userdb->result_failure =\n\t\tauth_db_rule_parse(set->result_failure);\n\tauth_userdb->result_internalfail =\n\t\tauth_db_rule_parse(set->result_internalfail);\n\n\tauth_userdb->default_fields_tmpl =\n\t\tuserdb_template_build(auth->pool, set->driver,\n\t\t\t\t      set->default_fields);\n\tauth_userdb->override_fields_tmpl =\n\t\tuserdb_template_build(auth->pool, set->driver,\n\t\t\t\t      set->override_fields);\n\n\tfor (dest = &auth->userdbs; *dest != NULL; dest = &(*dest)->next) ;\n\t*dest = auth_userdb;\n\n\tauth_userdb->userdb = userdb_preinit(auth->pool, set);\n\t/* make sure any %variables in default_fields exist in cache_key */\n\tif (auth_userdb->userdb->default_cache_key != NULL) {\n\t\tauth_userdb->cache_key =\n\t\t\tp_strconcat(auth->pool, auth_userdb->userdb->default_cache_key,\n\t\t\t\t    set->default_fields, NULL);\n\t}\n\telse {\n\t\tauth_userdb->cache_key = NULL;\n\t}\n}",
        "target": 0
    },
    {
        "func": "static bool auth_passdb_list_have_lookup_credentials(const struct auth *auth)\n{\n\tconst struct auth_passdb *passdb;\n\n\tfor (passdb = auth->passdbs; passdb != NULL; passdb = passdb->next) {\n\t\tif (passdb->passdb->iface.lookup_credentials != NULL)\n\t\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}",
        "target": 0
    },
    {
        "func": "void auth_request_set_state(struct auth_request *request,\n\t\t\t    enum auth_request_state state)\n{\n\tif (request->state == state)\n\t\treturn;\n\n\ti_assert(request->to_penalty == NULL);\n\n\ti_assert(auth_request_state_count[request->state] > 0);\n\tauth_request_state_count[request->state]--;\n\tauth_request_state_count[state]++;\n\n\trequest->state = state;\n\tauth_refresh_proctitle();\n}",
        "target": 0
    },
    {
        "func": "void auth_request_success(struct auth_request *request,\n\t\t\t  const void *data, size_t data_size)\n{\n\ti_assert(request->state == AUTH_REQUEST_STATE_MECH_CONTINUE);\n\n\tif (!request->set->policy_check_after_auth) {\n\t\tstruct auth_policy_check_ctx *ctx =\n\t\t\tp_new(request->pool, struct auth_policy_check_ctx, 1);\n\t\tctx->success_data = buffer_create_dynamic(request->pool, 1);\n\t\tctx->request = request;\n\t\tctx->type = AUTH_POLICY_CHECK_TYPE_SUCCESS;\n\t\tauth_request_policy_check_callback(0, ctx);\n\t\treturn;\n\t}\n\n\t/* perform second policy lookup here */\n\tstruct auth_policy_check_ctx *ctx = p_new(request->pool, struct auth_policy_check_ctx, 1);\n\tctx->request = request;\n\tctx->success_data = buffer_create_dynamic(request->pool, data_size);\n\tbuffer_append(ctx->success_data, data, data_size);\n\t ctx->type = AUTH_POLICY_CHECK_TYPE_SUCCESS;\n\tauth_policy_check(request, request->mech_password, auth_request_policy_check_callback, ctx);\n}",
        "target": 0
    },
    {
        "func": "void auth_request_verify_plain_callback(enum passdb_result result,\n\t\t\t\t\tstruct auth_request *request)\n{\n\tstruct auth_passdb *passdb = request->passdb;\n\n\ti_assert(request->state == AUTH_REQUEST_STATE_PASSDB);\n\n\tauth_request_set_state(request, AUTH_REQUEST_STATE_MECH_CONTINUE);\n\n\tif (result == PASSDB_RESULT_OK &&\n\t    auth_fields_exists(request->fields.extra_fields, \"noauthenticate\"))\n\t\tresult = PASSDB_RESULT_NEXT;\n\n\tif (result != PASSDB_RESULT_INTERNAL_FAILURE)\n\t\tauth_request_save_cache(request, result);\n\telse {\n\t\t/* lookup failed. if we're looking here only because the\n\t\t   request was expired in cache, fallback to using cached\n\t\t   expired record. */\n\t\tconst char *cache_key = passdb->cache_key;\n\n\t\tif (passdb_cache_verify_plain(request, cache_key,\n\t\t\t\t\t      request->mech_password,\n\t\t\t\t\t      &result, TRUE)) {\n\t\t\te_info(authdb_event(request),\n\t\t\t       \"Falling back to expired data from cache\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tauth_request_verify_plain_callback_finish(result, request);\n}",
        "target": 0
    },
    {
        "func": "void auth_request_initial(struct auth_request *request)\n{\n\ti_assert(request->state == AUTH_REQUEST_STATE_NEW);\n\n\tauth_request_set_state(request, AUTH_REQUEST_STATE_MECH_CONTINUE);\n\n\tif (auth_request_fail_on_nuls(request, request->initial_response,\n\t\t\t\t      request->initial_response_len))\n\t\treturn;\n\n\trequest->mech->auth_initial(request, request->initial_response,\n\t\t\t\t    request->initial_response_len);\n}",
        "target": 0
    },
    {
        "func": "void auth_request_log_login_failure(struct auth_request *request,\n\t\t\t\t    const char *subsystem,\n\t\t\t\t    const char *message)\n{\n\tstruct event *event = get_request_event(request, subsystem);\n\tstring_t *str;\n\n\tif (strcmp(request->set->verbose_passwords, \"no\") == 0) {\n\t\te_info(event, \"%s\", message);\n\t\treturn;\n\t}\n\n\t/* make sure this gets logged */\n\tenum log_type orig_level = event_get_min_log_level(event);\n\tevent_set_min_log_level(event, LOG_TYPE_INFO);\n\n\tstr = t_str_new(128);\n\tstr_append(str, message);\n\tstr_append(str, \" \");\n\n\tauth_request_append_password(request, str);\n\n\tif (request->userdb_lookup) {\n\t\tif (request->userdb->next != NULL)\n\t\t\tstr_append(str, \" - trying the next userdb\");\n\t} else {\n\t\tif (request->passdb->next != NULL)\n\t\t\tstr_append(str, \" - trying the next passdb\");\n\t}\n\te_info(event, \"%s\", str_c(str));\n\tevent_set_min_log_level(event, orig_level);\n}",
        "target": 0
    },
    {
        "func": "static enum auth_userdb_skip auth_userdb_skip_parse(const char *str)\n{\n\tif (strcmp(str, \"never\") == 0)\n\t\treturn AUTH_USERDB_SKIP_NEVER;\n\tif (strcmp(str, \"found\") == 0)\n\t\treturn AUTH_USERDB_SKIP_FOUND;\n\tif (strcmp(str, \"notfound\") == 0)\n\t\treturn AUTH_USERDB_SKIP_NOTFOUND;\n\ti_unreached();\n}",
        "target": 0
    },
    {
        "func": "void passdb_init(struct passdb_module *passdb)\n{\n\tif (passdb->iface.init != NULL && passdb->init_refcount == 0)\n\t\tpassdb->iface.init(passdb);\n\tpassdb->init_refcount++;\n}",
        "target": 0
    },
    {
        "func": "const char *auth_request_get_log_prefix_db(struct auth_request *auth_request)\n{\n\tstring_t *str = t_str_new(64);\n\tauth_request_get_log_prefix(str, auth_request, AUTH_SUBSYS_DB);\n\treturn str_c(str);\n}",
        "target": 0
    },
    {
        "func": "auth_request_validate_networks(struct auth_request *request,\n\t\t\t\tconst char *name, const char *networks,\n\t\t\t\tconst struct ip_addr *remote_ip)\n{\n\tconst char *const *net;\n\tstruct ip_addr net_ip;\n\tunsigned int bits;\n\tbool found = FALSE;\n\n\tfor (net = t_strsplit_spaces(networks, \", \"); *net != NULL; net++) {\n\t\te_debug(authdb_event(request),\n\t\t\t\"%s: Matching for network %s\", name, *net);\n\n\t\tif (strcmp(*net, \"local\") == 0) {\n\t\t\tif (remote_ip->family == 0) {\n\t\t\t\tfound = TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (net_parse_range(*net, &net_ip, &bits) < 0) {\n\t\t\te_info(authdb_event(request),\n\t\t\t       \"%s: Invalid network '%s'\", name, *net);\n\t\t} else if (remote_ip->family != 0 &&\n\t\t\t   net_is_in_network(remote_ip, &net_ip, bits)) {\n\t\t\tfound = TRUE;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found)\n\t\t;\n\telse if (remote_ip->family == 0) {\n\t\te_info(authdb_event(request),\n\t\t       \"%s check failed: Remote IP not known and 'local' missing\", name);\n\t} else {\n\t\te_info(authdb_event(request),\n\t\t       \"%s check failed: IP %s not in allowed networks\",\n\t\t       name, net_ip2addr(remote_ip));\n\t}\n\tif (!found)\n\t\trequest->failed = TRUE;\n}",
        "target": 0
    },
    {
        "func": "static void auth_request_set_uidgid_file(struct auth_request *request,\n\t\t\t\t\t const char *path_template)\n{\n\tstring_t *path;\n\tstruct stat st;\n\tconst char *error;\n\n\tpath = t_str_new(256);\n\tif (auth_request_var_expand(path, path_template, request,\n\t\t\t\t    NULL, &error) <= 0) {\n\t\te_error(authdb_event(request),\n\t\t\t\"Failed to expand uidgid_file=%s: %s\", path_template, error);\n\t\trequest->userdb_lookup_tempfailed = TRUE;\n\t} else if (stat(str_c(path), &st) < 0) {\n\t\te_error(authdb_event(request),\n\t\t\t\"stat(%s) failed: %m\", str_c(path));\n\t\trequest->userdb_lookup_tempfailed = TRUE;\n\t} else {\n\t\tauth_fields_add(request->fields.userdb_reply,\n\t\t\t\t\"uid\", dec2str(st.st_uid), 0);\n\t\tauth_fields_add(request->fields.userdb_reply,\n\t\t\t\t\"gid\", dec2str(st.st_gid), 0);\n\t}\n}",
        "target": 0
    },
    {
        "func": "auth_request_verify_plain_callback_finish(enum passdb_result result,\n\t\t\t\t\t  struct auth_request *request)\n{\n\tconst char *error;\n\n\tif (passdb_template_export(request->passdb->override_fields_tmpl,\n\t\t\t\t   request, &error) < 0) {\n\t\te_error(authdb_event(request),\n\t\t\t\"Failed to expand override_fields: %s\", error);\n\t\tresult = PASSDB_RESULT_INTERNAL_FAILURE;\n\t}\n\tif (!auth_request_handle_passdb_callback(&result, request)) {\n\t\t/* try next passdb */\n\t\tauth_request_verify_plain(request, request->mech_password,\n\t\t\trequest->private_callback.verify_plain);\n\t} else {\n\t\tauth_request_ref(request);\n\t\trequest->passdb_result = result;\n\t\trequest->private_callback.verify_plain(request->passdb_result, request);\n\t\tauth_request_unref(&request);\n\t}\n}",
        "target": 0
    },
    {
        "func": "struct auth *auth_default_service(void)\n{\n\tstruct auth *const *a;\n\tunsigned int count;\n\n\ta = array_get(&auths, &count);\n\treturn a[0];\n}",
        "target": 0
    },
    {
        "func": "auth_request_want_skip_passdb(struct auth_request *request,\n\t\t\t      struct auth_passdb *passdb)\n{\n\t/* if mechanism is not supported, skip */\n\tconst char *const *mechs = passdb->mechanisms;\n\tconst char *const *username_filter = passdb->username_filter;\n\tconst char *username;\n\n\tusername = request->fields.user;\n\n\tif (!auth_request_mechanism_accepted(mechs, request->mech)) {\n\t\tauth_request_log_debug(request,\n\t\t\t\t       request->mech != NULL ? AUTH_SUBSYS_MECH\n\t\t\t\t\t\t\t      : \"none\",\n\t\t\t\t       \"skipping passdb: mechanism filtered\");\n\t\treturn TRUE;\n\t}\n\n\tif (passdb->username_filter != NULL &&\n\t    !auth_request_username_accepted(username_filter, username)) {\n\t\tauth_request_log_debug(request,\n\t\t\t\t       request->mech != NULL ? AUTH_SUBSYS_MECH\n\t\t\t\t\t\t\t      : \"none\",\n\t\t\t\t       \"skipping passdb: username filtered\");\n\t\treturn TRUE;\n\t}\n\n\t/* skip_password_check basically specifies if authentication is\n\t   finished */\n\tbool authenticated = request->fields.skip_password_check;\n\n\tswitch (passdb->skip) {\n\tcase AUTH_PASSDB_SKIP_NEVER:\n\t\treturn FALSE;\n\tcase AUTH_PASSDB_SKIP_AUTHENTICATED:\n\t\treturn authenticated;\n\tcase AUTH_PASSDB_SKIP_UNAUTHENTICATED:\n\t\treturn !authenticated;\n\t}\n\ti_unreached();\n}",
        "target": 0
    },
    {
        "func": "bool passdb_get_credentials(struct auth_request *auth_request,\n\t\t\t    const char *input, const char *input_scheme,\n\t\t\t    const unsigned char **credentials_r, size_t *size_r)\n{\n\tconst char *wanted_scheme = auth_request->wanted_credentials_scheme;\n\tconst char *plaintext, *error;\n\tint ret;\n\tstruct password_generate_params pwd_gen_params;\n\n\tif (auth_request->prefer_plain_credentials &&\n\t    password_scheme_is_alias(input_scheme, \"PLAIN\")) {\n\t\t/* we've a plaintext scheme and we prefer to get it instead\n\t\t   of converting it to the fallback scheme */\n\t\twanted_scheme = \"\";\n\t}\n\n\tret = password_decode(input, input_scheme,\n\t\t\t      credentials_r, size_r, &error);\n\tif (ret <= 0) {\n\t\tif (ret < 0) {\n\t\t\te_error(authdb_event(auth_request),\n\t\t\t\t\"Password data is not valid for scheme %s: %s\",\n\t\t\t\tinput_scheme, error);\n\t\t} else {\n\t\t\te_error(authdb_event(auth_request),\n\t\t\t\t\"Unknown scheme %s\", input_scheme);\n\t\t}\n\t\treturn FALSE;\n\t}\n\n\tif (*wanted_scheme == '\\0') {\n\t\t/* anything goes. change the wanted_credentials_scheme to what\n\t\t   we actually got, so blocking passdbs work. */\n\t\tauth_request->wanted_credentials_scheme =\n\t\t\tp_strdup(auth_request->pool, t_strcut(input_scheme, '.'));\n\t\treturn TRUE;\n\t}\n\n\tif (!password_scheme_is_alias(input_scheme, wanted_scheme)) {\n\t\tif (!password_scheme_is_alias(input_scheme, \"PLAIN\")) {\n\t\t\tconst char *error = t_strdup_printf(\n\t\t\t\t\"Requested %s scheme, but we have only %s\",\n\t\t\t\twanted_scheme, input_scheme);\n\t\t\tif (auth_request->set->debug_passwords) {\n\t\t\t\terror = t_strdup_printf(\"%s (input: %s)\",\n\t\t\t\t\t\t\terror, input);\n\t\t\t}\n\t\t\te_info(authdb_event(auth_request),\n\t\t\t       \"%s\", error);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\t/* we can generate anything out of plaintext passwords */\n\t\tplaintext = t_strndup(*credentials_r, *size_r);\n\t\ti_zero(&pwd_gen_params);\n\t\tpwd_gen_params.user = auth_request->fields.original_username;\n\t\tif (!auth_request->domain_is_realm &&\n\t\t    strchr(pwd_gen_params.user, '@') != NULL) {\n\t\t\t/* domain must not be used as realm. add the @realm. */\n\t\t\tpwd_gen_params.user = t_strconcat(pwd_gen_params.user, \"@\",\n\t\t\t\t\t       auth_request->fields.realm, NULL);\n\t\t}\n\t\tif (auth_request->set->debug_passwords) {\n\t\t\te_debug(authdb_event(auth_request),\n\t\t\t\t\"Generating %s from user '%s', password '%s'\",\n\t\t\t\twanted_scheme, pwd_gen_params.user, plaintext);\n\t\t}\n\t\tif (!password_generate(plaintext, &pwd_gen_params,\n\t\t\t\t       wanted_scheme, credentials_r, size_r)) {\n\t\t\te_error(authdb_event(auth_request),\n\t\t\t\t\"Requested unknown scheme %s\", wanted_scheme);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\treturn TRUE;\n}",
        "target": 0
    },
    {
        "func": "auth_preinit(const struct auth_settings *set, const char *service, pool_t pool,\n\t     const struct mechanisms_register *reg)\n{\n\tstruct auth_passdb_settings *const *passdbs;\n\tstruct auth_userdb_settings *const *userdbs;\n\tstruct auth *auth;\n\tunsigned int i, count, db_count, passdb_count, last_passdb = 0;\n\n\tauth = p_new(pool, struct auth, 1);\n\tauth->pool = pool;\n\tauth->service = p_strdup(pool, service);\n\tauth->set = set;\n\tauth->reg = reg;\n\n\tif (array_is_created(&set->passdbs))\n\t\tpassdbs = array_get(&set->passdbs, &db_count);\n\telse {\n\t\tpassdbs = NULL;\n\t\tdb_count = 0;\n\t}\n\n\t/* initialize passdbs first and count them */\n\tfor (passdb_count = 0, i = 0; i < db_count; i++) {\n\t\tif (passdbs[i]->master)\n\t\t\tcontinue;\n\n\t\t/* passdb { skip=unauthenticated } as the first passdb doesn't\n\t\t   make sense, since user is never authenticated at that point.\n\t\t   skip over them silently. */\n\t\tif (auth->passdbs == NULL &&\n\t\t    auth_passdb_skip_parse(passdbs[i]->skip) == AUTH_PASSDB_SKIP_UNAUTHENTICATED)\n\t\t\tcontinue;\n\n\t\tauth_passdb_preinit(auth, passdbs[i], &auth->passdbs);\n\t\tpassdb_count++;\n\t\tlast_passdb = i;\n\t}\n\tif (passdb_count != 0 && passdbs[last_passdb]->pass)\n\t\ti_fatal(\"Last passdb can't have pass=yes\");\n\n\tfor (i = 0; i < db_count; i++) {\n\t\tif (!passdbs[i]->master)\n\t\t\tcontinue;\n\n\t\t/* skip skip=unauthenticated, as explained above */\n\t\tif (auth->masterdbs == NULL &&\n\t\t    auth_passdb_skip_parse(passdbs[i]->skip) == AUTH_PASSDB_SKIP_UNAUTHENTICATED)\n\t\t\tcontinue;\n\n\t\tif (passdbs[i]->deny)\n\t\t\ti_fatal(\"Master passdb can't have deny=yes\");\n\t\tif (passdbs[i]->pass && passdb_count == 0) {\n\t\t\ti_fatal(\"Master passdb can't have pass=yes \"\n\t\t\t\t\"if there are no passdbs\");\n\t\t}\n\t\tauth_passdb_preinit(auth, passdbs[i], &auth->masterdbs);\n\t}\n\n\tif (array_is_created(&set->userdbs)) {\n\t\tuserdbs = array_get(&set->userdbs, &count);\n\t\tfor (i = 0; i < count; i++)\n\t\t\tauth_userdb_preinit(auth, userdbs[i]);\n\t}\n\n\tif (auth->userdbs == NULL) {\n\t\t/* use a dummy userdb static. */\n\t\tauth_userdb_preinit(auth, &userdb_dummy_set);\n\t}\n\treturn auth;\n}",
        "target": 0
    },
    {
        "func": "auth_request_lookup_credentials_finish(enum passdb_result result,\n\t\t\t\t\tconst unsigned char *credentials,\n\t\t\t\t\tsize_t size,\n\t\t\t\t\tstruct auth_request *request)\n{\n\tconst char *error;\n\n\tif (passdb_template_export(request->passdb->override_fields_tmpl,\n\t\t\t\t   request, &error) < 0) {\n\t\te_error(authdb_event(request),\n\t\t\t\"Failed to expand override_fields: %s\", error);\n\t\tresult = PASSDB_RESULT_INTERNAL_FAILURE;\n\t}\n\tif (!auth_request_handle_passdb_callback(&result, request)) {\n\t\t/* try next passdb */\n\t\tif (request->fields.skip_password_check &&\n\t\t    request->fields.delayed_credentials == NULL && size > 0) {\n\t\t\t/* passdb continue* rule after a successful lookup.\n\t\t\t   remember these credentials and use them later on. */\n\t\t\tauth_request_set_delayed_credentials(request,\n\t\t\t\tcredentials, size);\n\t\t}\n\t\tauth_request_lookup_credentials(request,\n\t\t\trequest->wanted_credentials_scheme,\n\t\t  \trequest->private_callback.lookup_credentials);\n\t} else {\n\t\tif (request->fields.delayed_credentials != NULL && size == 0) {\n\t\t\t/* we did multiple passdb lookups, but the last one\n\t\t\t   didn't provide any credentials (e.g. just wanted to\n\t\t\t   add some extra fields). so use the first passdb's\n\t\t\t   credentials instead. */\n\t\t\tcredentials = request->fields.delayed_credentials;\n\t\t\tsize = request->fields.delayed_credentials_size;\n\t\t}\n\t\tif (request->set->debug_passwords &&\n\t\t    result == PASSDB_RESULT_OK) {\n\t\t\te_debug(authdb_event(request),\n\t\t\t\t\"Credentials: %s\",\n\t\t\t\tbinary_to_hex(credentials, size));\n\t\t}\n\t\tif (result == PASSDB_RESULT_SCHEME_NOT_AVAILABLE &&\n\t\t    request->passdbs_seen_user_unknown) {\n\t\t\t/* one of the passdbs accepted the scheme,\n\t\t\t   but the user was unknown there */\n\t\t\tresult = PASSDB_RESULT_USER_UNKNOWN;\n\t\t}\n\t\trequest->passdb_result = result;\n\t\trequest->private_callback.\n\t\t\tlookup_credentials(result, credentials, size, request);\n\t}\n}",
        "target": 0
    },
    {
        "func": "static void get_log_identifier(string_t *str, struct auth_request *auth_request)\n{\n\tconst char *ip;\n\n\tif (auth_request->fields.user == NULL)\n\t        str_append(str, \"?\");\n\telse\n\t\tstr_sanitize_append(str, auth_request->fields.user,\n\t\t\t\t    MAX_LOG_USERNAME_LEN);\n\n\tip = net_ip2addr(&auth_request->fields.remote_ip);\n\tif (ip[0] != '\\0') {\n\t        str_append_c(str, ',');\n\t        str_append(str, ip);\n\t}\n\tif (auth_request->fields.requested_login_user != NULL)\n\t        str_append(str, \",master\");\n\tif (auth_request->fields.session_id != NULL)\n\t        str_printfa(str, \",<%s>\", auth_request->fields.session_id);\n}",
        "target": 0
    },
    {
        "func": "void passdb_handle_credentials(enum passdb_result result,\n\t\t\t       const char *password, const char *scheme,\n\t\t\t       lookup_credentials_callback_t *callback,\n                               struct auth_request *auth_request)\n{\n\tconst unsigned char *credentials = NULL;\n\tsize_t size = 0;\n\n\tif (result != PASSDB_RESULT_OK) {\n\t\tcallback(result, NULL, 0, auth_request);\n\t\treturn;\n\t} else if (auth_fields_exists(auth_request->fields.extra_fields,\n\t\t\t\t      \"noauthenticate\")) {\n\t\tcallback(PASSDB_RESULT_NEXT, NULL, 0, auth_request);\n\t\treturn;\n\t}\n\n\tif (password != NULL) {\n\t\tif (!passdb_get_credentials(auth_request, password, scheme,\n\t\t\t\t\t    &credentials, &size))\n\t\t\tresult = PASSDB_RESULT_SCHEME_NOT_AVAILABLE;\n\t} else if (*auth_request->wanted_credentials_scheme == '\\0') {\n\t\t/* We're doing a passdb lookup (not authenticating).\n\t\t   Pass through a NULL password without an error. */\n\t} else if (auth_request->fields.delayed_credentials != NULL) {\n\t\t/* We already have valid credentials from an earlier\n\t\t   passdb lookup. auth_request_lookup_credentials_finish()\n\t\t   will use them. */\n\t} else {\n\t\te_info(authdb_event(auth_request),\n\t\t       \"Requested %s scheme, but we have a NULL password\",\n\t\t       auth_request->wanted_credentials_scheme);\n\t\tresult = PASSDB_RESULT_SCHEME_NOT_AVAILABLE;\n\t}\n\n\tcallback(result, credentials, size, auth_request);\n}",
        "target": 0
    },
    {
        "func": "void auth_request_get_log_prefix(string_t *str, struct auth_request *auth_request,\n\t\t\t\t const char *subsystem)\n{\n\tconst char *name;\n\n\tif (subsystem == AUTH_SUBSYS_DB) {\n\t\tif (!auth_request->userdb_lookup) {\n\t\t\ti_assert(auth_request->passdb != NULL);\n\t\t\tname = auth_request->passdb->set->name[0] != '\\0' ?\n\t\t\t\tauth_request->passdb->set->name :\n\t\t\t\tauth_request->passdb->passdb->iface.name;\n\t\t} else {\n\t\t\ti_assert(auth_request->userdb != NULL);\n\t\t\tname = auth_request->userdb->set->name[0] != '\\0' ?\n\t\t\t\tauth_request->userdb->set->name :\n\t\t\t\tauth_request->userdb->userdb->iface->name;\n\t\t}\n\t} else if (subsystem == AUTH_SUBSYS_MECH) {\n\t\ti_assert(auth_request->mech != NULL);\n\t\tname = t_str_lcase(auth_request->mech->mech_name);\n\t} else {\n\t\tname = subsystem;\n\t}\n\tstr_append(str, name);\n\tstr_append_c(str, '(');\n\tget_log_identifier(str, auth_request);\n\tstr_append(str, \"): \");\n}",
        "target": 0
    },
    {
        "func": "auth_request_finished_event(struct auth_request *request, struct event *event)\n{\n\tstruct event_passthrough *e = event_create_passthrough(event);\n\n\tif (request->failed) {\n\t\tif (request->internal_failure) {\n\t\t\te->add_str(\"error\", \"internal failure\");\n\t\t} else {\n\t\t\te->add_str(\"error\", \"authentication failed\");\n\t\t}\n\t} else if (request->fields.successful) {\n\t\te->add_str(\"success\", \"yes\");\n\t}\n\tif (request->userdb_lookup) {\n\t\treturn e;\n\t}\n\tif (request->policy_penalty > 0)\n\t\te->add_int(\"policy_penalty\", request->policy_penalty);\n\tif (request->policy_refusal) {\n\t\te->add_str(\"policy_result\", \"refused\");\n\t} else if (request->policy_processed && request->policy_penalty > 0) {\n\t\te->add_str(\"policy_result\", \"delayed\");\n\t\te->add_int(\"policy_penalty\", request->policy_penalty);\n\t} else if (request->policy_processed) {\n\t\te->add_str(\"policy_result\", \"ok\");\n\t}\n\treturn e;\n}",
        "target": 0
    },
    {
        "func": "static void auth_request_userdb_save_cache(struct auth_request *request,\n\t\t\t\t\t   enum userdb_result result)\n{\n\tstruct auth_userdb *userdb = request->userdb;\n\tstring_t *str;\n\tconst char *cache_value;\n\n\tif (passdb_cache == NULL || userdb->cache_key == NULL)\n\t\treturn;\n\n\tif (result == USERDB_RESULT_USER_UNKNOWN)\n\t\tcache_value = \"\";\n\telse {\n\t\tstr = t_str_new(128);\n\t\tauth_fields_append(request->fields.userdb_reply, str,\n\t\t\t\t   AUTH_FIELD_FLAG_CHANGED,\n\t\t\t\t   AUTH_FIELD_FLAG_CHANGED);\n\t\tif (request->user_changed_by_lookup) {\n\t\t\t/* username was changed by passdb or userdb */\n\t\t\tif (str_len(str) > 0)\n\t\t\t\tstr_append_c(str, '\\t');\n\t\t\tstr_append(str, \"user=\");\n\t\t\tstr_append_tabescaped(str, request->fields.user);\n\t\t}\n\t\tif (str_len(str) == 0) {\n\t\t\t/* no userdb fields. but we can't save an empty string,\n\t\t\t   since that means \"user unknown\". */\n\t\t\tstr_append(str, AUTH_REQUEST_USER_KEY_IGNORE);\n\t\t}\n\t\tcache_value = str_c(str);\n\t}\n\t/* last_success has no meaning with userdb */\n\tauth_cache_insert(passdb_cache, request, userdb->cache_key,\n\t\t\t  cache_value, FALSE);\n}",
        "target": 0
    },
    {
        "func": "static const char *get_log_prefix_mech(struct auth_request *auth_request)\n{\n\tstring_t *str = t_str_new(64);\n\tauth_request_get_log_prefix(str, auth_request, AUTH_SUBSYS_MECH);\n\treturn str_c(str);\n}",
        "target": 0
    },
    {
        "func": "void passdbs_deinit(void)\n{\n\tarray_free(&passdb_modules);\n\tarray_free(&passdb_interfaces);\n}",
        "target": 0
    },
    {
        "func": "passdb_find(const char *driver, const char *args, unsigned int *idx_r)\n{\n\tstruct passdb_module *const *passdbs;\n\tunsigned int i, count;\n\n\tpassdbs = array_get(&passdb_modules, &count);\n\tfor (i = 0; i < count; i++) {\n\t\tif (strcmp(passdbs[i]->iface.name, driver) == 0 &&\n\t\t    strcmp(passdbs[i]->args, args) == 0) {\n\t\t\t*idx_r = i;\n\t\t\treturn passdbs[i];\n\t\t}\n\t}\n\treturn NULL;\n}",
        "target": 0
    },
    {
        "func": "void auth_request_init(struct auth_request *request)\n{\n\tstruct auth *auth;\n\n\tauth = auth_request_get_auth(request);\n\trequest->set = auth->set;\n\trequest->passdb = auth->passdbs;\n\trequest->userdb = auth->userdbs;\n}",
        "target": 0
    },
    {
        "func": "static void auth_request_save_cache(struct auth_request *request,\n\t\t\t\t    enum passdb_result result)\n{\n\tstruct auth_passdb *passdb = request->passdb;\n\tconst char *encoded_password;\n\tstring_t *str;\n\tstruct password_generate_params gen_params = {\n\t\t.user = request->fields.user,\n\t\t.rounds = 0\n\t};\n\n\tswitch (result) {\n\tcase PASSDB_RESULT_USER_UNKNOWN:\n\tcase PASSDB_RESULT_PASSWORD_MISMATCH:\n\tcase PASSDB_RESULT_OK:\n\tcase PASSDB_RESULT_SCHEME_NOT_AVAILABLE:\n\t\t/* can be cached */\n\t\tbreak;\n\tcase PASSDB_RESULT_NEXT:\n\tcase PASSDB_RESULT_USER_DISABLED:\n\tcase PASSDB_RESULT_PASS_EXPIRED:\n\t\t/* FIXME: we can't cache this now, or cache lookup would\n\t\t   return success. */\n\t\treturn;\n\tcase PASSDB_RESULT_INTERNAL_FAILURE:\n\t\ti_unreached();\n\t}\n\n\tif (passdb_cache == NULL || passdb->cache_key == NULL)\n\t\treturn;\n\n\tif (result < 0) {\n\t\t/* lookup failed. */\n\t\tif (result == PASSDB_RESULT_USER_UNKNOWN) {\n\t\t\tauth_cache_insert(passdb_cache, request,\n\t\t\t\t\t  passdb->cache_key, \"\", FALSE);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (request->passdb_password == NULL &&\n\t    !auth_fields_exists(request->fields.extra_fields, \"nopassword\")) {\n\t\t/* passdb didn't provide the correct password */\n\t\tif (result != PASSDB_RESULT_OK ||\n\t\t    request->mech_password == NULL)\n\t\t\treturn;\n\n\t\t/* we can still cache valid password lookups though.\n\t\t   strdup() it so that mech_password doesn't get\n\t\t   cleared too early. */\n\t\tif (!password_generate_encoded(request->mech_password,\n\t\t\t\t\t       &gen_params,\n\t\t\t\t\t       CACHED_PASSWORD_SCHEME,\n\t\t\t\t\t       &encoded_password))\n\t\t\ti_unreached();\n\t\trequest->passdb_password =\n\t\t\tp_strconcat(request->pool, \"{\"CACHED_PASSWORD_SCHEME\"}\",\n\t\t\t\t    encoded_password, NULL);\n\t}\n\n\t/* save all except the currently given password in cache */\n\tstr = t_str_new(256);\n\tif (request->passdb_password != NULL) {\n\t\tif (*request->passdb_password != '{') {\n\t\t\t/* cached passwords must have a known scheme */\n\t\t\tstr_append_c(str, '{');\n\t\t\tstr_append(str, passdb->passdb->default_pass_scheme);\n\t\t\tstr_append_c(str, '}');\n\t\t}\n\t\tstr_append_tabescaped(str, request->passdb_password);\n\t}\n\n\tif (!auth_fields_is_empty(request->fields.extra_fields)) {\n\t\tstr_append_c(str, '\\t');\n\t\t/* add only those extra fields to cache that were set by this\n\t\t   passdb lookup. the CHANGED flag does this, because we\n\t\t   snapshotted the extra_fields before the current passdb\n\t\t   lookup. */\n\t\tauth_fields_append(request->fields.extra_fields, str,\n\t\t\t\t   AUTH_FIELD_FLAG_CHANGED,\n\t\t\t\t   AUTH_FIELD_FLAG_CHANGED);\n\t}\n\tauth_cache_insert(passdb_cache, request, passdb->cache_key, str_c(str),\n\t\t\t  result == PASSDB_RESULT_OK);\n}",
        "target": 0
    },
    {
        "func": "void auth_request_proxy_finish_failure(struct auth_request *request)\n{\n\t/* drop all proxying fields */\n\tauth_fields_remove(request->fields.extra_fields, \"proxy\");\n\tauth_fields_remove(request->fields.extra_fields, \"proxy_maybe\");\n\tauth_fields_remove(request->fields.extra_fields, \"proxy_always\");\n\tauth_fields_remove(request->fields.extra_fields, \"host\");\n\tauth_fields_remove(request->fields.extra_fields, \"port\");\n\tauth_fields_remove(request->fields.extra_fields, \"destuser\");\n}",
        "target": 0
    },
    {
        "func": "void auth_request_userdb_lookup_begin(struct auth_request *request)\n{\n\tstruct event *event;\n\tconst char *name;\n\n\ti_assert(request->userdb != NULL);\n\ti_assert(request->userdb_lookup);\n\n\trequest->userdb_cache_result = AUTH_REQUEST_CACHE_NONE;\n\n\tname = (request->userdb->set->name[0] != '\\0' ?\n\t\trequest->userdb->set->name :\n\t\trequest->userdb->userdb->iface->name);\n\n\tevent = event_create(request->event);\n\tevent_add_str(event, \"userdb_id\", dec2str(request->userdb->userdb->id));\n\tevent_add_str(event, \"userdb_name\", name);\n\tevent_add_str(event, \"userdb\", request->userdb->userdb->iface->name);\n\tevent_set_log_prefix_callback(event, FALSE,\n\t\tauth_request_get_log_prefix_db, request);\n\n\t/* check if we should enable verbose logging here*/\n\tif (*request->userdb->set->auth_verbose == 'y')\n\t\tevent_set_min_log_level(event, LOG_TYPE_INFO);\n\telse if (*request->userdb->set->auth_verbose == 'n')\n\t\tevent_set_min_log_level(event, LOG_TYPE_WARNING);\n\n\te_debug(event_create_passthrough(event)->\n\t\t\tset_name(\"auth_userdb_request_started\")->\n\t\t\tevent(),\n\t\t\"Performing userdb lookup\");\n\tarray_push_back(&request->authdb_event, &event);\n}",
        "target": 0
    },
    {
        "func": "static bool password_has_illegal_chars(const char *password)\n{\n\tfor (; *password != '\\0'; password++) {\n\t\tswitch (*password) {\n\t\tcase '\\001':\n\t\tcase '\\t':\n\t\tcase '\\r':\n\t\tcase '\\n':\n\t\t\t/* these characters have a special meaning in internal\n\t\t\t   protocols, make sure the password doesn't\n\t\t\t   accidentally get there unescaped. */\n\t\t\treturn TRUE;\n\t\t}\n\t}\n\treturn FALSE;\n}",
        "target": 0
    },
    {
        "func": "void auth_request_set_null_field(struct auth_request *request, const char *name)\n{\n\tif (str_begins_with(name, \"userdb_\")) {\n\t\t/* make sure userdb prefetch is used even if all the fields\n\t\t   were returned as NULL. */\n\t\trequest->userdb_prefetch_set = TRUE;\n\t}\n}",
        "target": 0
    },
    {
        "func": "static bool auth_passdb_list_have_verify_plain(const struct auth *auth)\n{\n\tconst struct auth_passdb *passdb;\n\n\tfor (passdb = auth->passdbs; passdb != NULL; passdb = passdb->next) {\n\t\tif (passdb->passdb->iface.verify_plain != NULL)\n\t\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}",
        "target": 0
    },
    {
        "func": "auth_request_set_password(struct auth_request *request, const char *value,\n\t\t\t  const char *default_scheme, bool noscheme)\n{\n\tif (request->passdb_password != NULL) {\n\t\te_error(authdb_event(request),\n\t\t\t\"Multiple password values not supported\");\n\t\treturn;\n\t}\n\n\t/* if the password starts with '{' it most likely contains\n\t   also '}'. check it anyway to make sure, because we\n\t   assert-crash later if it doesn't exist. this could happen\n\t   if plaintext passwords are used. */\n\tif (*value == '{' && !noscheme && strchr(value, '}') != NULL)\n\t\trequest->passdb_password = p_strdup(request->pool, value);\n\telse {\n\t\ti_assert(default_scheme != NULL);\n\t\trequest->passdb_password =\n\t\t\tp_strdup_printf(request->pool, \"{%s}%s\",\n\t\t\t\t\tdefault_scheme, value);\n\t}\n}",
        "target": 0
    },
    {
        "func": "void auth_request_set_userdb_field(struct auth_request *request,\n\t\t\t\t   const char *name, const char *value)\n{\n\tsize_t name_len = strlen(name);\n\tuid_t uid;\n\tgid_t gid;\n\n\ti_assert(value != NULL);\n\n\tif (name_len > 10 && strcmp(name+name_len-10, \":protected\") == 0) {\n\t\t/* set this field only if it hasn't been set before */\n\t\tname = t_strndup(name, name_len-10);\n\t\tif (auth_fields_exists(request->fields.userdb_reply, name))\n\t\t\treturn;\n\t} else if (name_len > 7 && strcmp(name+name_len-7, \":remove\") == 0) {\n\t\t/* remove this field entirely */\n\t\tname = t_strndup(name, name_len-7);\n\t\tauth_fields_remove(request->fields.userdb_reply, name);\n\t\treturn;\n\t}\n\n\tif (strcmp(name, \"uid\") == 0) {\n\t\tuid = userdb_parse_uid(request, value);\n\t\tif (uid == (uid_t)-1) {\n\t\t\trequest->userdb_lookup_tempfailed = TRUE;\n\t\t\treturn;\n\t\t}\n\t\tvalue = dec2str(uid);\n\t} else if (strcmp(name, \"gid\") == 0) {\n\t\tgid = userdb_parse_gid(request, value);\n\t\tif (gid == (gid_t)-1) {\n\t\t\trequest->userdb_lookup_tempfailed = TRUE;\n\t\t\treturn;\n\t\t}\n\t\tvalue = dec2str(gid);\n\t} else if (strcmp(name, \"tempfail\") == 0) {\n\t\trequest->userdb_lookup_tempfailed = TRUE;\n\t\treturn;\n\t} else if (auth_request_try_update_username(request, name, value)) {\n\t\treturn;\n\t} else if (strcmp(name, \"uidgid_file\") == 0) {\n\t\tauth_request_set_uidgid_file(request, value);\n\t\treturn;\n\t} else if (strcmp(name, \"userdb_import\") == 0) {\n\t\tauth_request_userdb_import(request, value);\n\t\treturn;\n\t} else if (strcmp(name, \"system_user\") == 0) {\n\t\t/* FIXME: the system_user is for backwards compatibility */\n\t\tstatic bool warned = FALSE;\n\t\tif (!warned) {\n\t\t\te_warning(authdb_event(request),\n\t\t\t\t  \"Replace system_user with system_groups_user\");\n\t\t\twarned = TRUE;\n\t\t}\n\t\tname = \"system_groups_user\";\n\t} else if (strcmp(name, AUTH_REQUEST_USER_KEY_IGNORE) == 0) {\n\t\treturn;\n\t}\n\n\tauth_fields_add(request->fields.userdb_reply, name, value, 0);\n}",
        "target": 0
    },
    {
        "func": "void passdbs_generate_md5(unsigned char md5[STATIC_ARRAY MD5_RESULTLEN])\n{\n\tstruct md5_context ctx;\n\tstruct passdb_module *const *passdbs;\n\tunsigned int i, count;\n\n\tmd5_init(&ctx);\n\tpassdbs = array_get(&passdb_modules, &count);\n\tfor (i = 0; i < count; i++) {\n\t\tmd5_update(&ctx, &passdbs[i]->id, sizeof(passdbs[i]->id));\n\t\tmd5_update(&ctx, passdbs[i]->iface.name,\n\t\t\t   strlen(passdbs[i]->iface.name));\n\t\tmd5_update(&ctx, passdbs[i]->args, strlen(passdbs[i]->args));\n\t}\n\tmd5_final(&ctx, md5);\n}",
        "target": 0
    },
    {
        "func": "auth_request_cache_result_to_str(enum auth_request_cache_result result)\n{\n\tswitch(result) {\n\tcase AUTH_REQUEST_CACHE_NONE:\n\t\treturn \"none\";\n\tcase AUTH_REQUEST_CACHE_HIT:\n\t\treturn \"hit\";\n\tcase AUTH_REQUEST_CACHE_MISS:\n\t\treturn \"miss\";\n\tdefault:\n\t\ti_unreached();\n\t}\n}",
        "target": 0
    },
    {
        "func": "auth_request_mechanism_accepted(const char *const *mechs,\n\t\t\t\tconst struct mech_module *mech)\n{\n\t/* no filter specified, anything goes */\n\tif (mechs == NULL) return TRUE;\n\t/* request has no mechanism, see if none is accepted */\n\tif (mech == NULL)\n\t\treturn str_array_icase_find(mechs, \"none\");\n\t/* check if request mechanism is accepted */\n\treturn str_array_icase_find(mechs, mech->mech_name);\n}",
        "target": 0
    },
    {
        "func": "auth_request_userdb_import(struct auth_request *request, const char *args)\n{\n\tconst char *key, *value, *const *arg;\n\n\tfor (arg = t_strsplit(args, \"\\t\"); *arg != NULL; arg++) {\n\t\tvalue = strchr(*arg, '=');\n\t\tif (value == NULL) {\n\t\t\tkey = *arg;\n\t\t\tvalue = \"\";\n\t\t} else {\n\t\t\tkey = t_strdup_until(*arg, value);\n\t\t\tvalue++;\n\t\t}\n\t\tauth_request_set_userdb_field(request, key, value);\n\t}\n}",
        "target": 0
    },
    {
        "func": "void auth_request_policy_check_callback(int result, void *context)\n{\n\tstruct auth_policy_check_ctx *ctx = context;\n\n\tctx->request->policy_processed = TRUE;\n\t/* It's possible that multiple policy lookups return a penalty.\n\t   Sum them all up to the event. */\n\tctx->request->policy_penalty += result < 0 ? 0 : result;\n\n\tif (ctx->request->set->policy_log_only && result != 0) {\n\t\tauth_request_policy_penalty_finish(context);\n\t\treturn;\n\t}\n\tif (result < 0) {\n\t\t/* fail it right here and now */\n\t\tauth_request_fail(ctx->request);\n\t} else if (ctx->type != AUTH_POLICY_CHECK_TYPE_SUCCESS && result > 0 &&\n\t\t   !ctx->request->fields.no_penalty) {\n\t\tctx->request->to_penalty = timeout_add(result * 1000,\n\t\t\t\tauth_request_policy_penalty_finish,\n\t\t\t\tcontext);\n\t} else {\n\t\tauth_request_policy_penalty_finish(context);\n\t}\n}",
        "target": 0
    },
    {
        "func": "void auth_request_passdb_lookup_begin(struct auth_request *request)\n{\n\tstruct event *event;\n\tconst char *name;\n\n\ti_assert(request->passdb != NULL);\n\ti_assert(!request->userdb_lookup);\n\n\trequest->passdb_cache_result = AUTH_REQUEST_CACHE_NONE;\n\n\tname = (request->passdb->set->name[0] != '\\0' ?\n\t\trequest->passdb->set->name :\n\t\trequest->passdb->passdb->iface.name);\n\n\tevent = event_create(request->event);\n\tevent_add_str(event, \"passdb_id\", dec2str(request->passdb->passdb->id));\n\tevent_add_str(event, \"passdb_name\", name);\n\tevent_add_str(event, \"passdb\", request->passdb->passdb->iface.name);\n\tevent_set_log_prefix_callback(event, FALSE,\n\t\tauth_request_get_log_prefix_db, request);\n\n\t/* check if we should enable verbose logging here */\n\tif (*request->passdb->set->auth_verbose == 'y')\n\t\tevent_set_min_log_level(event, LOG_TYPE_INFO);\n\telse if (*request->passdb->set->auth_verbose == 'n')\n\t\tevent_set_min_log_level(event, LOG_TYPE_WARNING);\n\n\te_debug(event_create_passthrough(event)->\n\t\t\tset_name(\"auth_passdb_request_started\")->\n\t\t\tevent(),\n\t\t\"Performing passdb lookup\");\n\tarray_push_back(&request->authdb_event, &event);\n}",
        "target": 0
    },
    {
        "func": "void auths_deinit(void)\n{\n\tstruct auth *auth;\n\n\tarray_foreach_elem(&auths, auth)\n\t\tauth_deinit(auth);\n\tevent_unref(&auth_event);\n}",
        "target": 0
    },
    {
        "func": "bool auth_request_import_master(struct auth_request *request,\n\t\t\t\tconst char *key, const char *value)\n{\n\tpid_t pid;\n\n\ti_assert(value != NULL);\n\n\t/* master request lookups may set these */\n\tif (strcmp(key, \"session_pid\") == 0) {\n\t\tif (str_to_pid(value, &pid) == 0)\n\t\t\trequest->session_pid = pid;\n\t} else if (strcmp(key, \"request_auth_token\") == 0)\n\t\trequest->request_auth_token = TRUE;\n\telse\n\t\treturn FALSE;\n\treturn TRUE;\n}",
        "target": 0
    },
    {
        "func": "auth_passdb_preinit(struct auth *auth, const struct auth_passdb_settings *set,\n\t\t    struct auth_passdb **passdbs)\n{\n\tstruct auth_passdb *auth_passdb, **dest;\n\n\tauth_passdb = p_new(auth->pool, struct auth_passdb, 1);\n\tauth_passdb->set = set;\n\tauth_passdb->skip = auth_passdb_skip_parse(set->skip);\n\tauth_passdb->result_success =\n\t\tauth_db_rule_parse(set->result_success);\n\tauth_passdb->result_failure =\n\t\tauth_db_rule_parse(set->result_failure);\n\tauth_passdb->result_internalfail =\n\t\tauth_db_rule_parse(set->result_internalfail);\n\n\tauth_passdb->default_fields_tmpl =\n\t\tpassdb_template_build(auth->pool, set->default_fields);\n\tauth_passdb->override_fields_tmpl =\n\t\tpassdb_template_build(auth->pool, set->override_fields);\n\n\tif (*set->mechanisms == '\\0') {\n\t\tauth_passdb->mechanisms = NULL;\n\t} else if (strcasecmp(set->mechanisms, \"none\") == 0) {\n\t\tauth_passdb->mechanisms = (const char *const[]){ NULL };\n\t} else {\n\t\tauth_passdb->mechanisms =\n\t\t\t(const char *const *)p_strsplit_spaces(auth->pool,\n\t\t\t\tset->mechanisms, \" ,\");\n\t}\n\n\tif (*set->username_filter == '\\0') {\n\t\tauth_passdb->username_filter = NULL;\n\t} else {\n\t\tauth_passdb->username_filter =\n\t\t\t(const char *const *)p_strsplit_spaces(auth->pool,\n\t\t\t\tset->username_filter, \" ,\");\n\t}\n\n\t/* for backwards compatibility: */\n\tif (set->pass)\n\t\tauth_passdb->result_success = AUTH_DB_RULE_CONTINUE;\n\n\tfor (dest = passdbs; *dest != NULL; dest = &(*dest)->next) ;\n\t*dest = auth_passdb;\n\n\tauth_passdb->passdb = passdb_preinit(auth->pool, set);\n\t/* make sure any %variables in default_fields exist in cache_key */\n\tif (auth_passdb->passdb->default_cache_key != NULL) {\n\t\tauth_passdb->cache_key =\n\t\t\tp_strconcat(auth->pool, auth_passdb->passdb->default_cache_key,\n\t\t\t\tset->default_fields, NULL);\n\t}\n\telse {\n\t\tauth_passdb->cache_key = NULL;\n\t}\n}",
        "target": 0
    },
    {
        "func": "int auth_request_proxy_finish(struct auth_request *request,\n\t\t\t      auth_request_proxy_cb_t *callback)\n{\n\tconst char *host, *hostip;\n\tstruct ip_addr ip;\n\tbool proxy_host_is_self;\n\n\tif (request->auth_only)\n\t\treturn 1;\n\tif (!auth_fields_exists(request->fields.extra_fields, \"proxy\") &&\n\t    !auth_fields_exists(request->fields.extra_fields, \"proxy_maybe\"))\n\t\treturn 1;\n\n\thost = auth_fields_find(request->fields.extra_fields, \"host\");\n\tif (host == NULL) {\n\t\t/* director can set the host. give it access to lip and lport\n\t\t   so it can also perform proxy_maybe internally */\n\t\tproxy_host_is_self = FALSE;\n\t\tif (request->fields.local_ip.family != 0) {\n\t\t\tauth_fields_add(request->fields.extra_fields, \"lip\",\n\t\t\t\tnet_ip2addr(&request->fields.local_ip), 0);\n\t\t}\n\t\tif (request->fields.local_port != 0) {\n\t\t\tauth_fields_add(request->fields.extra_fields, \"lport\",\n\t\t\t\tdec2str(request->fields.local_port), 0);\n\t\t}\n\t} else if (net_addr2ip(host, &ip) == 0) {\n\t\tproxy_host_is_self =\n\t\t\tauth_request_proxy_ip_is_self(request, &ip);\n\t} else {\n\t\thostip = auth_fields_find(request->fields.extra_fields, \"hostip\");\n\t\tif (hostip != NULL && net_addr2ip(hostip, &ip) < 0) {\n\t\t\tauth_request_log_error(request, AUTH_SUBSYS_PROXY,\n\t\t\t\t\"Invalid hostip in passdb: %s\", hostip);\n\t\t\treturn -1;\n\t\t}\n\t\tif (hostip == NULL) {\n\t\t\t/* asynchronous host lookup */\n\t\t\treturn auth_request_proxy_host_lookup(request, host, callback);\n\t\t}\n\t\tproxy_host_is_self =\n\t\t\tauth_request_proxy_ip_is_self(request, &ip);\n\t}\n\n\tauth_request_proxy_finish_ip(request, proxy_host_is_self);\n\treturn 1;\n}",
        "target": 0
    },
    {
        "func": "void auth_request_lookup_credentials_callback(enum passdb_result result,\n\t\t\t\t\t      const unsigned char *credentials,\n\t\t\t\t\t      size_t size,\n\t\t\t\t\t      struct auth_request *request)\n{\n\tstruct auth_passdb *passdb = request->passdb;\n\tconst char *cache_cred, *cache_scheme;\n\n\ti_assert(request->state == AUTH_REQUEST_STATE_PASSDB);\n\n\tauth_request_set_state(request, AUTH_REQUEST_STATE_MECH_CONTINUE);\n\n\tif (result == PASSDB_RESULT_OK &&\n\t    auth_fields_exists(request->fields.extra_fields, \"noauthenticate\"))\n\t\tresult = PASSDB_RESULT_NEXT;\n\n\tif (result != PASSDB_RESULT_INTERNAL_FAILURE)\n\t\tauth_request_save_cache(request, result);\n\telse {\n\t\t/* lookup failed. if we're looking here only because the\n\t\t   request was expired in cache, fallback to using cached\n\t\t   expired record. */\n\t\tconst char *cache_key = passdb->cache_key;\n\n\t\tif (passdb_cache_lookup_credentials(request, cache_key,\n\t\t\t\t\t\t    &cache_cred, &cache_scheme,\n\t\t\t\t\t\t    &result, TRUE)) {\n\t\t\te_info(authdb_event(request),\n\t\t\t       \"Falling back to expired data from cache\");\n\t\t\tpassdb_handle_credentials(\n\t\t\t\tresult, cache_cred, cache_scheme,\n\t\t\t\tauth_request_lookup_credentials_finish,\n\t\t\t\trequest);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tauth_request_lookup_credentials_finish(result, credentials, size,\n\t\t\t\t\t\trequest);\n}",
        "target": 0
    },
    {
        "func": "static void auth_mech_list_verify_passdb(const struct auth *auth)\n{\n\tconst struct mech_module_list *list;\n\n\tfor (list = auth->reg->modules; list != NULL; list = list->next) {\n\t\tif (!auth_mech_verify_passdb(auth, list))\n\t\t\tbreak;\n\t}\n\n\tif (list != NULL) {\n\t\tif (auth->passdbs == NULL) {\n\t\t\ti_fatal(\"No passdbs specified in configuration file. \"\n\t\t\t\t\"%s mechanism needs one\",\n\t\t\t\tlist->module.mech_name);\n\t\t}\n\t\ti_fatal(\"%s mechanism can't be supported with given passdbs\",\n\t\t\tlist->module.mech_name);\n\t}\n}",
        "target": 0
    },
    {
        "func": "int CMS_data(CMS_ContentInfo *cms, BIO *out, unsigned int flags)\n\t{\n\tBIO *cont;\n\tint r;\n\tif (OBJ_obj2nid(CMS_get0_type(cms)) != NID_pkcs7_data)\n\t\t{\n\t\tCMSerr(CMS_F_CMS_DATA, CMS_R_TYPE_NOT_DATA);\n\t\treturn 0;\n\t\t}\n\tcont = CMS_dataInit(cms, NULL);\n\tif (!cont)\n\t\treturn 0;\n\tr = cms_copy_content(out, cont, flags);\n\tBIO_free_all(cont);\n\treturn r;\n\t}",
        "target": 0
    },
    {
        "func": "CMS_ContentInfo *CMS_digest_create(BIO *in, const EVP_MD *md,\n\t\t\t\t\tunsigned int flags)\n\t{\n\tCMS_ContentInfo *cms;\n\tif (!md)\n\t\tmd = EVP_sha1();\n\tcms = cms_DigestedData_create(md);\n\tif (!cms)\n\t\treturn NULL;\n\n\tif(!(flags & CMS_DETACHED))\n\t\tCMS_set_detached(cms, 0);\n\n\tif ((flags & CMS_STREAM) || CMS_final(cms, in, NULL, flags))\n\t\treturn cms;\n\n\tCMS_ContentInfo_free(cms);\n\treturn NULL;\n\t}",
        "target": 0
    },
    {
        "func": "static BIO *cms_get_text_bio(BIO *out, unsigned int flags)\n\t{\n\tBIO *rbio;\n\tif (out == NULL)\n\t\trbio = BIO_new(BIO_s_null());\n\telse if (flags & CMS_TEXT)\n\t\t{\n\t\trbio = BIO_new(BIO_s_mem());\n\t\tBIO_set_mem_eof_return(rbio, 0);\n\t\t}\n\telse\n\t\trbio = out;\n\treturn rbio;\n\t}",
        "target": 0
    },
    {
        "func": "CMS_ContentInfo *CMS_EncryptedData_encrypt(BIO *in, const EVP_CIPHER *cipher,\n\t\t\t\t\tconst unsigned char *key, size_t keylen,\n\t\t\t\t\tunsigned int flags)\n\t{\n\tCMS_ContentInfo *cms;\n\tif (!cipher)\n\t\t{\n\t\tCMSerr(CMS_F_CMS_ENCRYPTEDDATA_ENCRYPT, CMS_R_NO_CIPHER);\n\t\treturn NULL;\n\t\t}\n\tcms = CMS_ContentInfo_new();\n\tif (!cms)\n\t\treturn NULL;\n\tif (!CMS_EncryptedData_set1_key(cms, cipher, key, keylen))\n\t\treturn NULL;\n\n\tif(!(flags & CMS_DETACHED))\n\t\tCMS_set_detached(cms, 0);\n\n\tif ((flags & (CMS_STREAM|CMS_PARTIAL))\n\t\t|| CMS_final(cms, in, NULL, flags))\n\t\treturn cms;\n\n\tCMS_ContentInfo_free(cms);\n\treturn NULL;\n\t}",
        "target": 0
    },
    {
        "func": "int CMS_decrypt_set1_password(CMS_ContentInfo *cms, \n\t\t\t\tunsigned char *pass, ossl_ssize_t passlen)\n\t{\n\tSTACK_OF(CMS_RecipientInfo) *ris;\n\tCMS_RecipientInfo *ri;\n\tint i, r;\n\tris = CMS_get0_RecipientInfos(cms);\n\tfor (i = 0; i < sk_CMS_RecipientInfo_num(ris); i++)\n\t\t{\n\t\tri = sk_CMS_RecipientInfo_value(ris, i);\n\t\tif (CMS_RecipientInfo_type(ri) != CMS_RECIPINFO_PASS)\n\t\t\t\tcontinue;\n\t\tCMS_RecipientInfo_set0_password(ri, pass, passlen);\n\t\tr = CMS_RecipientInfo_decrypt(cms, ri);\n\t\tCMS_RecipientInfo_set0_password(ri, NULL, 0);\n\t\tif (r > 0)\n\t\t\treturn 1;\n\t\t}\n\n\tCMSerr(CMS_F_CMS_DECRYPT_SET1_PASSWORD, CMS_R_NO_MATCHING_RECIPIENT);\n\treturn 0;\n\n\t}",
        "target": 0
    },
    {
        "func": "CMS_ContentInfo *CMS_data_create(BIO *in, unsigned int flags)\n\t{\n\tCMS_ContentInfo *cms;\n\tcms = cms_Data_create();\n\tif (!cms)\n\t\treturn NULL;\n\n\tif ((flags & CMS_STREAM) || CMS_final(cms, in, NULL, flags))\n\t\treturn cms;\n\n\tCMS_ContentInfo_free(cms);\n\n\treturn NULL;\n\t}",
        "target": 0
    },
    {
        "func": "int CMS_uncompress(CMS_ContentInfo *cms, BIO *dcont, BIO *out,\n\t\t\t\t\t\t\tunsigned int flags)\n\t{\n\tBIO *cont;\n\tint r;\n\tif (OBJ_obj2nid(CMS_get0_type(cms)) != NID_id_smime_ct_compressedData)\n\t\t{\n\t\tCMSerr(CMS_F_CMS_UNCOMPRESS,\n\t\t\t\t\tCMS_R_TYPE_NOT_COMPRESSED_DATA);\n\t\treturn 0;\n\t\t}\n\n\tif (!dcont && !check_content(cms))\n\t\treturn 0;\n\n\tcont = CMS_dataInit(cms, dcont);\n\tif (!cont)\n\t\treturn 0;\n\tr = cms_copy_content(out, cont, flags);\n\tdo_free_upto(cont, dcont);\n\treturn r;\n\t}",
        "target": 0
    },
    {
        "func": "static int check_content(CMS_ContentInfo *cms)\n\t{\n\tASN1_OCTET_STRING **pos = CMS_get0_content(cms);\n\tif (!pos || !*pos)\n\t\t{\n\t\tCMSerr(CMS_F_CHECK_CONTENT, CMS_R_NO_CONTENT);\n\t\treturn 0;\n\t\t}\n\treturn 1;\n\t}",
        "target": 0
    },
    {
        "func": "int CMS_decrypt_set1_pkey(CMS_ContentInfo *cms, EVP_PKEY *pk, X509 *cert)\n\t{\n\tSTACK_OF(CMS_RecipientInfo) *ris;\n\tCMS_RecipientInfo *ri;\n\tint i, r, ri_type;\n\tint debug = 0;\n\tris = CMS_get0_RecipientInfos(cms);\n\tif (ris)\n\t\tdebug = cms->d.envelopedData->encryptedContentInfo->debug;\n\tri_type = cms_pkey_get_ri_type(pk);\n\tif (ri_type == CMS_RECIPINFO_NONE)\n\t\t{\n\t\tCMSerr(CMS_F_CMS_DECRYPT_SET1_PKEY,\n\t\t\t\t\tCMS_R_NOT_SUPPORTED_FOR_THIS_KEY_TYPE);\n\t\treturn 0;\n\t\t}\n\n\tfor (i = 0; i < sk_CMS_RecipientInfo_num(ris); i++)\n\t\t{\n\t\tri = sk_CMS_RecipientInfo_value(ris, i);\n\t\tif (CMS_RecipientInfo_type(ri) != ri_type)\n\t\t\t\tcontinue;\n\t\tif (ri_type == CMS_RECIPINFO_AGREE)\n\t\t\t{\n\t\t\tr = cms_kari_set1_pkey(cms, ri, pk, cert);\n\t\t\tif (r > 0)\n\t\t\t\treturn 1;\n\t\t\tif (r < 0)\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t/* If we have a cert try matching RecipientInfo\n\t\t * otherwise try them all.\n\t\t */\n\t\telse if (!cert || !CMS_RecipientInfo_ktri_cert_cmp(ri, cert))\n\t\t\t{\n\t\t\tCMS_RecipientInfo_set0_pkey(ri, pk);\n\t\t\tr = CMS_RecipientInfo_decrypt(cms, ri);\n\t\t\tCMS_RecipientInfo_set0_pkey(ri, NULL);\n\t\t\tif (cert)\n\t\t\t\t{\n\t\t\t\t/* If not debugging clear any error and\n\t\t\t\t * return success to avoid leaking of\n\t\t\t\t * information useful to MMA\n\t\t\t\t */\n\t\t\t\tif (!debug)\n\t\t\t\t\t{\n\t\t\t\t\tERR_clear_error();\n\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\tif (r > 0)\n\t\t\t\t\treturn 1;\n\t\t\t\tCMSerr(CMS_F_CMS_DECRYPT_SET1_PKEY,\n\t\t\t\t\t\tCMS_R_DECRYPT_ERROR);\n\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t/* If no cert and not debugging don't leave loop\n\t\t\t * after first successful decrypt. Always attempt\n\t\t\t * to decrypt all recipients to avoid leaking timing\n\t\t\t * of a successful decrypt.\n\t\t\t */\n\t\t\telse if (r > 0 && debug)\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t/* If no cert and not debugging always return success */\n\tif (!cert && !debug)\n\t\t{\n\t\tERR_clear_error();\n\t\treturn 1;\n\t\t}\n\n\tCMSerr(CMS_F_CMS_DECRYPT_SET1_PKEY, CMS_R_NO_MATCHING_RECIPIENT);\n\treturn 0;\n\n\t}",
        "target": 0
    },
    {
        "func": "int CMS_decrypt(CMS_ContentInfo *cms, EVP_PKEY *pk, X509 *cert,\n\t\t\t\tBIO *dcont, BIO *out,\n\t\t\t\tunsigned int flags)\n\t{\n\tint r;\n\tBIO *cont;\n\tif (OBJ_obj2nid(CMS_get0_type(cms)) != NID_pkcs7_enveloped)\n\t\t{\n\t\tCMSerr(CMS_F_CMS_DECRYPT, CMS_R_TYPE_NOT_ENVELOPED_DATA);\n\t\treturn 0;\n\t\t}\n\tif (!dcont && !check_content(cms))\n\t\treturn 0;\n\tif (flags & CMS_DEBUG_DECRYPT)\n\t\tcms->d.envelopedData->encryptedContentInfo->debug = 1;\n\telse\n\t\tcms->d.envelopedData->encryptedContentInfo->debug = 0;\n\tif (!pk && !cert && !dcont && !out)\n\t\treturn 1;\n\tif (pk && !CMS_decrypt_set1_pkey(cms, pk, cert))\n\t\treturn 0;\n\tcont = CMS_dataInit(cms, dcont);\n\tif (!cont)\n\t\treturn 0;\n\tr = cms_copy_content(out, cont, flags);\n\tdo_free_upto(cont, dcont);\n\treturn r;\n\t}",
        "target": 0
    },
    {
        "func": "CMS_ContentInfo *CMS_compress(BIO *in, int comp_nid, unsigned int flags)\n\t{\n\tCMS_ContentInfo *cms;\n\tif (comp_nid <= 0)\n\t\tcomp_nid = NID_zlib_compression;\n\tcms = cms_CompressedData_create(comp_nid);\n\tif (!cms)\n\t\treturn NULL;\n\n\tif(!(flags & CMS_DETACHED))\n\t\tCMS_set_detached(cms, 0);\n\n\tif ((flags & CMS_STREAM) || CMS_final(cms, in, NULL, flags))\n\t\treturn cms;\n\n\tCMS_ContentInfo_free(cms);\n\treturn NULL;\n\t}",
        "target": 0
    },
    {
        "func": "int CMS_uncompress(CMS_ContentInfo *cms, BIO *dcont, BIO *out,\n\t\t\t\t\t\t\tunsigned int flags)\n\t{\n\tCMSerr(CMS_F_CMS_UNCOMPRESS, CMS_R_UNSUPPORTED_COMPRESSION_ALGORITHM);\n\treturn 0;\n\t}",
        "target": 0
    },
    {
        "func": "CMS_ContentInfo *CMS_compress(BIO *in, int comp_nid, unsigned int flags)\n\t{\n\tCMSerr(CMS_F_CMS_COMPRESS, CMS_R_UNSUPPORTED_COMPRESSION_ALGORITHM);\n\treturn NULL;\n\t}",
        "target": 0
    },
    {
        "func": "static int cms_kari_set1_pkey(CMS_ContentInfo *cms, CMS_RecipientInfo *ri,\n\t\t\t\t\t\tEVP_PKEY *pk, X509 *cert)\n\t{\n\tint i;\n\tSTACK_OF(CMS_RecipientEncryptedKey) *reks;\n\tCMS_RecipientEncryptedKey *rek;\n\treks = CMS_RecipientInfo_kari_get0_reks(ri);\n\tif (!cert)\n\t\treturn 0;\n\tfor (i = 0; i < sk_CMS_RecipientEncryptedKey_num(reks); i++)\n\t\t{\n\t\tint rv;\n\t\trek = sk_CMS_RecipientEncryptedKey_value(reks, i);\n\t\tif (CMS_RecipientEncryptedKey_cert_cmp(rek, cert))\n\t\t\tcontinue;\n\t\tCMS_RecipientInfo_kari_set0_pkey(ri, pk);\n\t\trv = CMS_RecipientInfo_kari_decrypt(cms, ri, rek);\n\t\tCMS_RecipientInfo_kari_set0_pkey(ri, NULL);\n\t\tif (rv > 0)\n\t\t\treturn 1;\n\t\treturn -1;\n\t\t}\n\treturn 0;\n\t}",
        "target": 0
    },
    {
        "func": "int CMS_EncryptedData_decrypt(CMS_ContentInfo *cms,\n\t\t\t\tconst unsigned char *key, size_t keylen,\n\t\t\t\tBIO *dcont, BIO *out, unsigned int flags)\n\t{\n\tBIO *cont;\n\tint r;\n\tif (OBJ_obj2nid(CMS_get0_type(cms)) != NID_pkcs7_encrypted)\n\t\t{\n\t\tCMSerr(CMS_F_CMS_ENCRYPTEDDATA_DECRYPT,\n\t\t\t\t\tCMS_R_TYPE_NOT_ENCRYPTED_DATA);\n\t\treturn 0;\n\t\t}\n\n\tif (!dcont && !check_content(cms))\n\t\treturn 0;\n\n\tif (CMS_EncryptedData_set1_key(cms, NULL, key, keylen) <= 0)\n\t\treturn 0;\n\tcont = CMS_dataInit(cms, dcont);\n\tif (!cont)\n\t\treturn 0;\n\tr = cms_copy_content(out, cont, flags);\n\tdo_free_upto(cont, dcont);\n\treturn r;\n\t}",
        "target": 0
    },
    {
        "func": "static int cms_signerinfo_verify_cert(CMS_SignerInfo *si,\n\t\t\t\t\tX509_STORE *store,\n\t\t\t\t\tSTACK_OF(X509) *certs,\n\t\t\t\t\tSTACK_OF(X509_CRL) *crls,\n\t\t\t\t\tunsigned int flags)\n\t{\n\tX509_STORE_CTX ctx;\n\tX509 *signer;\n\tint i, j, r = 0;\n\tCMS_SignerInfo_get0_algs(si, NULL, &signer, NULL, NULL);\n\tif (!X509_STORE_CTX_init(&ctx, store, signer, certs))\n\t\t{\n\t\tCMSerr(CMS_F_CMS_SIGNERINFO_VERIFY_CERT,\n\t\t\t\t\t\tCMS_R_STORE_INIT_ERROR);\n\t\tgoto err;\n\t\t}\n\tX509_STORE_CTX_set_default(&ctx, \"smime_sign\");\n\tif (crls)\n\t\tX509_STORE_CTX_set0_crls(&ctx, crls);\n\n\ti = X509_verify_cert(&ctx);\n\tif (i <= 0)\n\t\t{\n\t\tj = X509_STORE_CTX_get_error(&ctx);\n\t\tCMSerr(CMS_F_CMS_SIGNERINFO_VERIFY_CERT,\n\t\t\t\t\t\tCMS_R_CERTIFICATE_VERIFY_ERROR);\n\t\tERR_add_error_data(2, \"Verify error:\",\n\t\t\t\t\t X509_verify_cert_error_string(j));\n\t\tgoto err;\n\t\t}\n\tr = 1;\n\terr:\n\tX509_STORE_CTX_cleanup(&ctx);\n\treturn r;\n\n\t}",
        "target": 0
    },
    {
        "func": "static int cms_copy_content(BIO *out, BIO *in, unsigned int flags)\n\t{\n\tunsigned char buf[4096];\n\tint r = 0, i;\n\tBIO *tmpout;\n\n\ttmpout = cms_get_text_bio(out, flags);\n\n\tif(!tmpout)\n\t\t{\n\t\tCMSerr(CMS_F_CMS_COPY_CONTENT,ERR_R_MALLOC_FAILURE);\n\t\tgoto err;\n\t\t}\n\n\t/* Read all content through chain to process digest, decrypt etc */\n\tfor (;;)\n\t{\n\t\ti=BIO_read(in,buf,sizeof(buf));\n\t\tif (i <= 0)\n\t\t\t{\n\t\t\tif (BIO_method_type(in) == BIO_TYPE_CIPHER)\n\t\t\t\t{\n\t\t\t\tif (!BIO_get_cipher_status(in))\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\tif (i < 0)\n\t\t\t\tgoto err;\n\t\t\tbreak;\n\t\t\t}\n\t\t\t\t\n\t\tif (tmpout && (BIO_write(tmpout, buf, i) != i))\n\t\t\tgoto err;\n\t}\n\n\tif(flags & CMS_TEXT)\n\t\t{\n\t\tif(!SMIME_text(tmpout, out))\n\t\t\t{\n\t\t\tCMSerr(CMS_F_CMS_COPY_CONTENT,CMS_R_SMIME_TEXT_ERROR);\n\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\n\tr = 1;\n\n\terr:\n\tif (tmpout && (tmpout != out))\n\t\tBIO_free(tmpout);\n\treturn r;\n\n\t}",
        "target": 0
    },
    {
        "func": "static void do_free_upto(BIO *f, BIO *upto)\n\t{\n\tif (upto)\n\t\t{\n\t\tBIO *tbio;\n\t\tdo \n\t\t\t{\n\t\t\ttbio = BIO_pop(f);\n\t\t\tBIO_free(f);\n\t\t\tf = tbio;\n\t\t\t}\n\t\twhile (f && f != upto);\n\t\t}\n\telse\n\t\tBIO_free_all(f);\n\t}",
        "target": 0
    },
    {
        "func": "int CMS_final(CMS_ContentInfo *cms, BIO *data, BIO *dcont, unsigned int flags)\n\t{\n\tBIO *cmsbio;\n\tint ret = 0;\n\tif (!(cmsbio = CMS_dataInit(cms, dcont)))\n\t\t{\n\t\tCMSerr(CMS_F_CMS_FINAL,ERR_R_MALLOC_FAILURE);\n\t\treturn 0;\n\t\t}\n\n\tSMIME_crlf_copy(data, cmsbio, flags);\n\n\t(void)BIO_flush(cmsbio);\n\n\n        if (!CMS_dataFinal(cms, cmsbio))\n\t\t{\n\t\tCMSerr(CMS_F_CMS_FINAL,CMS_R_CMS_DATAFINAL_ERROR);\n\t\tgoto err;\n\t\t}\n\n\tret = 1;\n\n\terr:\n\tdo_free_upto(cmsbio, dcont);\n\n\treturn ret;\n\n\t}",
        "target": 0
    },
    {
        "func": "CMS_ContentInfo *CMS_sign(X509 *signcert, EVP_PKEY *pkey, STACK_OF(X509) *certs,\n\t\t\t\t\t\tBIO *data, unsigned int flags)\n\t{\n\tCMS_ContentInfo *cms;\n\tint i;\n\n\tcms = CMS_ContentInfo_new();\n\tif (!cms || !CMS_SignedData_init(cms))\n\t\tgoto merr;\n\n\tif (pkey && !CMS_add1_signer(cms, signcert, pkey, NULL, flags))\n\t\t{\n\t\tCMSerr(CMS_F_CMS_SIGN, CMS_R_ADD_SIGNER_ERROR);\n\t\tgoto err;\n\t\t}\n\n\tfor (i = 0; i < sk_X509_num(certs); i++)\n\t\t{\n\t\tX509 *x = sk_X509_value(certs, i);\n\t\tif (!CMS_add1_cert(cms, x))\n\t\t\tgoto merr;\n\t\t}\n\n\tif(!(flags & CMS_DETACHED))\n\t\tCMS_set_detached(cms, 0);\n\n\tif ((flags & (CMS_STREAM|CMS_PARTIAL))\n\t\t|| CMS_final(cms, data, NULL, flags))\n\t\treturn cms;\n\telse\n\t\tgoto err;\n\n\tmerr:\n\tCMSerr(CMS_F_CMS_SIGN, ERR_R_MALLOC_FAILURE);\n\n\terr:\n\tif (cms)\n\t\tCMS_ContentInfo_free(cms);\n\treturn NULL;\n\t}",
        "target": 0
    },
    {
        "func": "CMS_ContentInfo *CMS_sign_receipt(CMS_SignerInfo *si,\n\t\t\t\t\tX509 *signcert, EVP_PKEY *pkey,\n\t\t\t\t\tSTACK_OF(X509) *certs,\n\t\t\t\t\tunsigned int flags)\n\t{\n\tCMS_SignerInfo *rct_si;\n\tCMS_ContentInfo *cms = NULL;\n\tASN1_OCTET_STRING **pos, *os;\n\tBIO *rct_cont = NULL;\n\tint r = 0;\n\n\tflags &= ~(CMS_STREAM|CMS_TEXT);\n\t/* Not really detached but avoids content being allocated */\n\tflags |= CMS_PARTIAL|CMS_BINARY|CMS_DETACHED;\n\tif (!pkey || !signcert)\n\t\t{\n\t\tCMSerr(CMS_F_CMS_SIGN_RECEIPT, CMS_R_NO_KEY_OR_CERT);\n\t\treturn NULL;\n\t\t}\n\n\t/* Initialize signed data */\n\n\tcms = CMS_sign(NULL, NULL, certs, NULL, flags);\n\tif (!cms)\n\t\tgoto err;\n\n\t/* Set inner content type to signed receipt */\n\tif (!CMS_set1_eContentType(cms, OBJ_nid2obj(NID_id_smime_ct_receipt)))\n\t\tgoto err;\n\n\trct_si = CMS_add1_signer(cms, signcert, pkey, NULL, flags);\n\tif (!rct_si)\n\t\t{\n\t\tCMSerr(CMS_F_CMS_SIGN_RECEIPT, CMS_R_ADD_SIGNER_ERROR);\n\t\tgoto err;\n\t\t}\n\n\tos = cms_encode_Receipt(si);\n\n\tif (!os)\n\t\tgoto err;\n\n\t/* Set content to digest */\n\trct_cont = BIO_new_mem_buf(os->data, os->length);\n\tif (!rct_cont)\n\t\tgoto err;\n\n\t/* Add msgSigDigest attribute */\n\n\tif (!cms_msgSigDigest_add1(rct_si, si))\n\t\tgoto err;\n\n\t/* Finalize structure */\n\tif (!CMS_final(cms, rct_cont, NULL, flags))\n\t\tgoto err;\n\n\t/* Set embedded content */\n\tpos = CMS_get0_content(cms);\n\t*pos = os;\n\n\tr = 1;\n\n\terr:\n\tif (rct_cont)\n\t\tBIO_free(rct_cont);\n\tif (r)\n\t\treturn cms;\n\tCMS_ContentInfo_free(cms);\n\treturn NULL;\n\n\t}",
        "target": 0
    },
    {
        "func": "CMS_ContentInfo *CMS_encrypt(STACK_OF(X509) *certs, BIO *data,\n\t\t\t\tconst EVP_CIPHER *cipher, unsigned int flags)\n\t{\n\tCMS_ContentInfo *cms;\n\tint i;\n\tX509 *recip;\n\tcms = CMS_EnvelopedData_create(cipher);\n\tif (!cms)\n\t\tgoto merr;\n\tfor (i = 0; i < sk_X509_num(certs); i++)\n\t\t{\n\t\trecip = sk_X509_value(certs, i);\n\t\tif (!CMS_add1_recipient_cert(cms, recip, flags))\n\t\t\t{\n\t\t\tCMSerr(CMS_F_CMS_ENCRYPT, CMS_R_RECIPIENT_ERROR);\n\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\n\tif(!(flags & CMS_DETACHED))\n\t\tCMS_set_detached(cms, 0);\n\n\tif ((flags & (CMS_STREAM|CMS_PARTIAL))\n\t\t|| CMS_final(cms, data, NULL, flags))\n\t\treturn cms;\n\telse\n\t\tgoto err;\n\n\tmerr:\n\tCMSerr(CMS_F_CMS_ENCRYPT, ERR_R_MALLOC_FAILURE);\n\terr:\n\tif (cms)\n\t\tCMS_ContentInfo_free(cms);\n\treturn NULL;\n\t}",
        "target": 0
    },
    {
        "func": "int CMS_digest_verify(CMS_ContentInfo *cms, BIO *dcont, BIO *out,\n\t\t\t\t\t\t\tunsigned int flags)\n\t{\n\tBIO *cont;\n\tint r;\n\tif (OBJ_obj2nid(CMS_get0_type(cms)) != NID_pkcs7_digest)\n\t\t{\n\t\tCMSerr(CMS_F_CMS_DIGEST_VERIFY, CMS_R_TYPE_NOT_DIGESTED_DATA);\n\t\treturn 0;\n\t\t}\n\n\tif (!dcont && !check_content(cms))\n\t\treturn 0;\n\n\tcont = CMS_dataInit(cms, dcont);\n\tif (!cont)\n\t\treturn 0;\n\tr = cms_copy_content(out, cont, flags);\n\tif (r)\n\t\tr = cms_DigestedData_do_final(cms, cont, 1);\n\tdo_free_upto(cont, dcont);\n\treturn r;\n\t}",
        "target": 0
    },
    {
        "func": "int CMS_verify_receipt(CMS_ContentInfo *rcms, CMS_ContentInfo *ocms,\n\t\t\tSTACK_OF(X509) *certs,\n\t\t\tX509_STORE *store, unsigned int flags)\n\t{\n\tint r;\n\tflags &= ~(CMS_DETACHED|CMS_TEXT);\n\tr = CMS_verify(rcms, certs, store, NULL, NULL, flags);\n\tif (r <= 0)\n\t\treturn r;\n\treturn cms_Receipt_verify(rcms, ocms);\n\t}",
        "target": 0
    },
    {
        "func": "int CMS_verify(CMS_ContentInfo *cms, STACK_OF(X509) *certs,\n\t\t X509_STORE *store, BIO *dcont, BIO *out, unsigned int flags)\n\t{\n\tCMS_SignerInfo *si;\n\tSTACK_OF(CMS_SignerInfo) *sinfos;\n\tSTACK_OF(X509) *cms_certs = NULL;\n\tSTACK_OF(X509_CRL) *crls = NULL;\n\tX509 *signer;\n\tint i, scount = 0, ret = 0;\n\tBIO *cmsbio = NULL, *tmpin = NULL, *tmpout = NULL;\n\n\tif (!dcont && !check_content(cms))\n\t\treturn 0;\n\n\t/* Attempt to find all signer certificates */\n\n\tsinfos = CMS_get0_SignerInfos(cms);\n\n\tif (sk_CMS_SignerInfo_num(sinfos) <= 0)\n\t\t{\n\t\tCMSerr(CMS_F_CMS_VERIFY, CMS_R_NO_SIGNERS);\n\t\tgoto err;\n\t\t}\n\n\tfor (i = 0; i < sk_CMS_SignerInfo_num(sinfos); i++)\n\t\t{\n\t\tsi = sk_CMS_SignerInfo_value(sinfos, i);\n\t\tCMS_SignerInfo_get0_algs(si, NULL, &signer, NULL, NULL);\n\t\tif (signer)\n\t\t\tscount++;\n\t\t}\n\n\tif (scount != sk_CMS_SignerInfo_num(sinfos))\n\t\tscount += CMS_set1_signers_certs(cms, certs, flags);\n\n\tif (scount != sk_CMS_SignerInfo_num(sinfos))\n\t\t{\n\t\tCMSerr(CMS_F_CMS_VERIFY, CMS_R_SIGNER_CERTIFICATE_NOT_FOUND);\n\t\tgoto err;\n\t\t}\n\n\t/* Attempt to verify all signers certs */\n\n\tif (!(flags & CMS_NO_SIGNER_CERT_VERIFY))\n\t\t{\n\t\tcms_certs = CMS_get1_certs(cms);\n\t\tif (!(flags & CMS_NOCRL))\n\t\t\tcrls = CMS_get1_crls(cms);\n\t\tfor (i = 0; i < sk_CMS_SignerInfo_num(sinfos); i++)\n\t\t\t{\n\t\t\tsi = sk_CMS_SignerInfo_value(sinfos, i);\n\t\t\tif (!cms_signerinfo_verify_cert(si, store,\n\t\t\t\t\t\t\tcms_certs, crls, flags))\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\n\t/* Attempt to verify all SignerInfo signed attribute signatures */\n\n\tif (!(flags & CMS_NO_ATTR_VERIFY))\n\t\t{\n\t\tfor (i = 0; i < sk_CMS_SignerInfo_num(sinfos); i++)\n\t\t\t{\n\t\t\tsi = sk_CMS_SignerInfo_value(sinfos, i);\n\t\t\tif (CMS_signed_get_attr_count(si) < 0)\n\t\t\t\tcontinue;\n\t\t\tif (CMS_SignerInfo_verify(si) <= 0)\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\n\t/* Performance optimization: if the content is a memory BIO then\n\t * store its contents in a temporary read only memory BIO. This\n\t * avoids potentially large numbers of slow copies of data which will\n\t * occur when reading from a read write memory BIO when signatures\n\t * are calculated.\n\t */\n\n\tif (dcont && (BIO_method_type(dcont) == BIO_TYPE_MEM))\n\t\t{\n\t\tchar *ptr;\n\t\tlong len;\n\t\tlen = BIO_get_mem_data(dcont, &ptr);\n\t\ttmpin = BIO_new_mem_buf(ptr, len);\n\t\tif (tmpin == NULL)\n\t\t\t{\n\t\t\tCMSerr(CMS_F_CMS_VERIFY,ERR_R_MALLOC_FAILURE);\n\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\telse\n\t\ttmpin = dcont;\n\t/* If not binary mode and detached generate digests by *writing*\n\t * through the BIO. That makes it possible to canonicalise the\n\t * input.\n\t */\n\tif (!(flags & SMIME_BINARY) && dcont)\n\t\t{\n\t\t/* Create output BIO so we can either handle text or to\n\t\t * ensure included content doesn't override detached content.\n\t\t */\n\t\ttmpout = cms_get_text_bio(out, flags);\n\t\tif(!tmpout)\n\t\t\t{\n\t\t\tCMSerr(CMS_F_CMS_VERIFY,ERR_R_MALLOC_FAILURE);\n\t\t\tgoto err;\n\t\t\t}\n\t\tcmsbio = CMS_dataInit(cms, tmpout);\n\t\tif (!cmsbio)\n\t\t\tgoto err;\n\t\t/* Don't use SMIME_TEXT for verify: it adds headers and\n\t\t * we want to remove them.\n\t\t */\n\t\tSMIME_crlf_copy(dcont, cmsbio, flags & ~SMIME_TEXT);\n\n\t\tif(flags & CMS_TEXT)\n\t\t\t{\n\t\t\tif (!SMIME_text(tmpout, out))\n\t\t\t\t{\n\t\t\t\tCMSerr(CMS_F_CMS_VERIFY,CMS_R_SMIME_TEXT_ERROR);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\telse\n\t\t{\n\t\tcmsbio=CMS_dataInit(cms, tmpin);\n\t\tif (!cmsbio)\n\t\t\tgoto err;\n\n\t\tif (!cms_copy_content(out, cmsbio, flags))\n\t\t\tgoto err;\n\n\t\t}\n\tif (!(flags & CMS_NO_CONTENT_VERIFY))\n\t\t{\n\t\tfor (i = 0; i < sk_CMS_SignerInfo_num(sinfos); i++)\n\t\t\t{\n\t\t\tsi = sk_CMS_SignerInfo_value(sinfos, i);\n\t\t\tif (CMS_SignerInfo_verify_content(si, cmsbio) <= 0)\n\t\t\t\t{\n\t\t\t\tCMSerr(CMS_F_CMS_VERIFY,\n\t\t\t\t\tCMS_R_CONTENT_VERIFY_ERROR);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\tret = 1;\n\n\terr:\n\tif (!(flags & SMIME_BINARY) && dcont)\n\t\t{\n\t\tdo_free_upto(cmsbio, tmpout);\n\t\tif (tmpin != dcont)\n\t\t\tBIO_free(tmpin);\n\t\t}\n\telse\n\t\t{\n\n\t\tif (dcont && (tmpin == dcont))\n\t\t\tdo_free_upto(cmsbio, dcont);\n\t\telse\n\t\t\tBIO_free_all(cmsbio);\n\t\t}\n\n\tif (tmpout && out != tmpout)\n\t\tBIO_free_all(tmpout);\n\n\tif (cms_certs)\n\t\tsk_X509_pop_free(cms_certs, X509_free);\n\tif (crls)\n\t\tsk_X509_CRL_pop_free(crls, X509_CRL_free);\n\n\treturn ret;\n\t}",
        "target": 0
    },
    {
        "func": "int CMS_decrypt_set1_key(CMS_ContentInfo *cms, \n\t\t\t\tunsigned char *key, size_t keylen,\n\t\t\t\tunsigned char *id, size_t idlen)\n\t{\n\tSTACK_OF(CMS_RecipientInfo) *ris;\n\tCMS_RecipientInfo *ri;\n\tint i, r;\n\tris = CMS_get0_RecipientInfos(cms);\n\tfor (i = 0; i < sk_CMS_RecipientInfo_num(ris); i++)\n\t\t{\n\t\tri = sk_CMS_RecipientInfo_value(ris, i);\n\t\tif (CMS_RecipientInfo_type(ri) != CMS_RECIPINFO_KEK)\n\t\t\t\tcontinue;\n\n\t\t/* If we have an id try matching RecipientInfo\n\t\t * otherwise try them all.\n\t\t */\n\t\tif (!id || (CMS_RecipientInfo_kekri_id_cmp(ri, id, idlen) == 0))\n\t\t\t{\n\t\t\tCMS_RecipientInfo_set0_key(ri, key, keylen);\n\t\t\tr = CMS_RecipientInfo_decrypt(cms, ri);\n\t\t\tCMS_RecipientInfo_set0_key(ri, NULL, 0);\n\t\t\tif (r > 0)\n\t\t\t\treturn 1;\n\t\t\tif (id)\n\t\t\t\t{\n\t\t\t\tCMSerr(CMS_F_CMS_DECRYPT_SET1_KEY,\n\t\t\t\t\t\tCMS_R_DECRYPT_ERROR);\n\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\tERR_clear_error();\n\t\t\t}\n\t\t}\n\n\tCMSerr(CMS_F_CMS_DECRYPT_SET1_KEY, CMS_R_NO_MATCHING_RECIPIENT);\n\treturn 0;\n\n\t}",
        "target": 0
    },
    {
        "func": "BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)\n/*\n * Returns 'ret' such that ret^2 == a (mod p), using the Tonelli/Shanks\n * algorithm (cf. Henri Cohen, \"A Course in Algebraic Computational Number\n * Theory\", algorithm 1.5.1). 'p' must be prime, otherwise an error or\n * an incorrect \"result\" will be returned.\n */\n{\n    BIGNUM *ret = in;\n    int err = 1;\n    int r;\n    BIGNUM *A, *b, *q, *t, *x, *y;\n    int e, i, j;\n    int used_ctx = 0;\n\n    if (!BN_is_odd(p) || BN_abs_is_word(p, 1)) {\n        if (BN_abs_is_word(p, 2)) {\n            if (ret == NULL)\n                ret = BN_new();\n            if (ret == NULL)\n                goto end;\n            if (!BN_set_word(ret, BN_is_bit_set(a, 0))) {\n                if (ret != in)\n                    BN_free(ret);\n                return NULL;\n            }\n            bn_check_top(ret);\n            return ret;\n        }\n\n        ERR_raise(ERR_LIB_BN, BN_R_P_IS_NOT_PRIME);\n        return NULL;\n    }\n\n    if (BN_is_zero(a) || BN_is_one(a)) {\n        if (ret == NULL)\n            ret = BN_new();\n        if (ret == NULL)\n            goto end;\n        if (!BN_set_word(ret, BN_is_one(a))) {\n            if (ret != in)\n                BN_free(ret);\n            return NULL;\n        }\n        bn_check_top(ret);\n        return ret;\n    }\n\n    BN_CTX_start(ctx);\n    used_ctx = 1;\n    A = BN_CTX_get(ctx);\n    b = BN_CTX_get(ctx);\n    q = BN_CTX_get(ctx);\n    t = BN_CTX_get(ctx);\n    x = BN_CTX_get(ctx);\n    y = BN_CTX_get(ctx);\n    if (y == NULL)\n        goto end;\n\n    if (ret == NULL)\n        ret = BN_new();\n    if (ret == NULL)\n        goto end;\n\n    /* A = a mod p */\n    if (!BN_nnmod(A, a, p, ctx))\n        goto end;\n\n    /* now write  |p| - 1  as  2^e*q  where  q  is odd */\n    e = 1;\n    while (!BN_is_bit_set(p, e))\n        e++;\n    /* we'll set  q  later (if needed) */\n\n    if (e == 1) {\n        /*-\n         * The easy case:  (|p|-1)/2  is odd, so 2 has an inverse\n         * modulo  (|p|-1)/2,  and square roots can be computed\n         * directly by modular exponentiation.\n         * We have\n         *     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2),\n         * so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1.\n         */\n        if (!BN_rshift(q, p, 2))\n            goto end;\n        q->neg = 0;\n        if (!BN_add_word(q, 1))\n            goto end;\n        if (!BN_mod_exp(ret, A, q, p, ctx))\n            goto end;\n        err = 0;\n        goto vrfy;\n    }\n\n    if (e == 2) {\n        /*-\n         * |p| == 5  (mod 8)\n         *\n         * In this case  2  is always a non-square since\n         * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime.\n         * So if  a  really is a square, then  2*a  is a non-square.\n         * Thus for\n         *      b := (2*a)^((|p|-5)/8),\n         *      i := (2*a)*b^2\n         * we have\n         *     i^2 = (2*a)^((1 + (|p|-5)/4)*2)\n         *         = (2*a)^((p-1)/2)\n         *         = -1;\n         * so if we set\n         *      x := a*b*(i-1),\n         * then\n         *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1)\n         *         = a^2 * b^2 * (-2*i)\n         *         = a*(-i)*(2*a*b^2)\n         *         = a*(-i)*i\n         *         = a.\n         *\n         * (This is due to A.O.L. Atkin,\n         * Subject: Square Roots and Cognate Matters modulo p=8n+5.\n         * URL: https://listserv.nodak.edu/cgi-bin/wa.exe?A2=ind9211&L=NMBRTHRY&P=4026\n         * November 1992.)\n         */\n\n        /* t := 2*a */\n        if (!BN_mod_lshift1_quick(t, A, p))\n            goto end;\n\n        /* b := (2*a)^((|p|-5)/8) */\n        if (!BN_rshift(q, p, 3))\n            goto end;\n        q->neg = 0;\n        if (!BN_mod_exp(b, t, q, p, ctx))\n            goto end;\n\n        /* y := b^2 */\n        if (!BN_mod_sqr(y, b, p, ctx))\n            goto end;\n\n        /* t := (2*a)*b^2 - 1 */\n        if (!BN_mod_mul(t, t, y, p, ctx))\n            goto end;\n        if (!BN_sub_word(t, 1))\n            goto end;\n\n        /* x = a*b*t */\n        if (!BN_mod_mul(x, A, b, p, ctx))\n            goto end;\n        if (!BN_mod_mul(x, x, t, p, ctx))\n            goto end;\n\n        if (!BN_copy(ret, x))\n            goto end;\n        err = 0;\n        goto vrfy;\n    }\n\n    /*\n     * e > 2, so we really have to use the Tonelli/Shanks algorithm. First,\n     * find some y that is not a square.\n     */\n    if (!BN_copy(q, p))\n        goto end;               /* use 'q' as temp */\n    q->neg = 0;\n    i = 2;\n    do {\n        /*\n         * For efficiency, try small numbers first; if this fails, try random\n         * numbers.\n         */\n        if (i < 22) {\n            if (!BN_set_word(y, i))\n                goto end;\n        } else {\n            if (!BN_priv_rand_ex(y, BN_num_bits(p), 0, 0, 0, ctx))\n                goto end;\n            if (BN_ucmp(y, p) >= 0) {\n                if (!(p->neg ? BN_add : BN_sub) (y, y, p))\n                    goto end;\n            }\n            /* now 0 <= y < |p| */\n            if (BN_is_zero(y))\n                if (!BN_set_word(y, i))\n                    goto end;\n        }\n\n        r = BN_kronecker(y, q, ctx); /* here 'q' is |p| */\n        if (r < -1)\n            goto end;\n        if (r == 0) {\n            /* m divides p */\n            ERR_raise(ERR_LIB_BN, BN_R_P_IS_NOT_PRIME);\n            goto end;\n        }\n    }\n    while (r == 1 && ++i < 82);\n\n    if (r != -1) {\n        /*\n         * Many rounds and still no non-square -- this is more likely a bug\n         * than just bad luck. Even if p is not prime, we should have found\n         * some y such that r == -1.\n         */\n        ERR_raise(ERR_LIB_BN, BN_R_TOO_MANY_ITERATIONS);\n        goto end;\n    }\n\n    /* Here's our actual 'q': */\n    if (!BN_rshift(q, q, e))\n        goto end;\n\n    /*\n     * Now that we have some non-square, we can find an element of order 2^e\n     * by computing its q'th power.\n     */\n    if (!BN_mod_exp(y, y, q, p, ctx))\n        goto end;\n    if (BN_is_one(y)) {\n        ERR_raise(ERR_LIB_BN, BN_R_P_IS_NOT_PRIME);\n        goto end;\n    }\n\n    /*-\n     * Now we know that (if  p  is indeed prime) there is an integer\n     * k,  0 <= k < 2^e,  such that\n     *\n     *      a^q * y^k == 1   (mod p).\n     *\n     * As  a^q  is a square and  y  is not,  k  must be even.\n     * q+1  is even, too, so there is an element\n     *\n     *     X := a^((q+1)/2) * y^(k/2),\n     *\n     * and it satisfies\n     *\n     *     X^2 = a^q * a     * y^k\n     *         = a,\n     *\n     * so it is the square root that we are looking for.\n     */\n\n    /* t := (q-1)/2  (note that  q  is odd) */\n    if (!BN_rshift1(t, q))\n        goto end;\n\n    /* x := a^((q-1)/2) */\n    if (BN_is_zero(t)) {        /* special case: p = 2^e + 1 */\n        if (!BN_nnmod(t, A, p, ctx))\n            goto end;\n        if (BN_is_zero(t)) {\n            /* special case: a == 0  (mod p) */\n            BN_zero(ret);\n            err = 0;\n            goto end;\n        } else if (!BN_one(x))\n            goto end;\n    } else {\n        if (!BN_mod_exp(x, A, t, p, ctx))\n            goto end;\n        if (BN_is_zero(x)) {\n            /* special case: a == 0  (mod p) */\n            BN_zero(ret);\n            err = 0;\n            goto end;\n        }\n    }\n\n    /* b := a*x^2  (= a^q) */\n    if (!BN_mod_sqr(b, x, p, ctx))\n        goto end;\n    if (!BN_mod_mul(b, b, A, p, ctx))\n        goto end;\n\n    /* x := a*x    (= a^((q+1)/2)) */\n    if (!BN_mod_mul(x, x, A, p, ctx))\n        goto end;\n\n    while (1) {\n        /*-\n         * Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E\n         * where  E  refers to the original value of  e,  which we\n         * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2).\n         *\n         * We have  a*b = x^2,\n         *    y^2^(e-1) = -1,\n         *    b^2^(e-1) = 1.\n         */\n\n        if (BN_is_one(b)) {\n            if (!BN_copy(ret, x))\n                goto end;\n            err = 0;\n            goto vrfy;\n        }\n\n        /* Find the smallest i, 0 < i < e, such that b^(2^i) = 1. */\n        for (i = 1; i < e; i++) {\n            if (i == 1) {\n                if (!BN_mod_sqr(t, b, p, ctx))\n                    goto end;\n\n            } else {\n                if (!BN_mod_mul(t, t, t, p, ctx))\n                    goto end;\n            }\n            if (BN_is_one(t))\n                break;\n        }\n        /* If not found, a is not a square or p is not prime. */\n        if (i >= e) {\n            ERR_raise(ERR_LIB_BN, BN_R_NOT_A_SQUARE);\n            goto end;\n        }\n\n        /* t := y^2^(e - i - 1) */\n        if (!BN_copy(t, y))\n            goto end;\n        for (j = e - i - 1; j > 0; j--) {\n            if (!BN_mod_sqr(t, t, p, ctx))\n                goto end;\n        }\n        if (!BN_mod_mul(y, t, t, p, ctx))\n            goto end;\n        if (!BN_mod_mul(x, x, t, p, ctx))\n            goto end;\n        if (!BN_mod_mul(b, b, y, p, ctx))\n            goto end;\n        e = i;\n    }\n\n vrfy:\n    if (!err) {\n        /*\n         * verify the result -- the input might have been not a square (test\n         * added in 0.9.8)\n         */\n\n        if (!BN_mod_sqr(x, ret, p, ctx))\n            err = 1;\n\n        if (!err && 0 != BN_cmp(x, A)) {\n            ERR_raise(ERR_LIB_BN, BN_R_NOT_A_SQUARE);\n            err = 1;\n        }\n    }\n\n end:\n    if (err) {\n        if (ret != in)\n            BN_clear_free(ret);\n        ret = NULL;\n    }\n    if (used_ctx)\n        BN_CTX_end(ctx);\n    bn_check_top(ret);\n    return ret;\n}",
        "target": 0
    },
    {
        "func": "void loongarch_cpu_dump_state(CPUState *cs, FILE *f, int flags)\n{\n    LoongArchCPU *cpu = LOONGARCH_CPU(cs);\n    CPULoongArchState *env = &cpu->env;\n    int i;\n\n    qemu_fprintf(f, \" PC=%016\" PRIx64 \" \", env->pc);\n    qemu_fprintf(f, \" FCSR0 0x%08x  fp_status 0x%02x\\n\", env->fcsr0,\n                 get_float_exception_flags(&env->fp_status));\n\n    /* gpr */\n    for (i = 0; i < 32; i++) {\n        if ((i & 3) == 0) {\n            qemu_fprintf(f, \" GPR%02d:\", i);\n        }\n        qemu_fprintf(f, \" %s %016\" PRIx64, regnames[i], env->gpr[i]);\n        if ((i & 3) == 3) {\n            qemu_fprintf(f, \"\\n\");\n        }\n    }\n\n    qemu_fprintf(f, \"CRMD=%016\" PRIx64 \"\\n\", env->CSR_CRMD);\n    qemu_fprintf(f, \"PRMD=%016\" PRIx64 \"\\n\", env->CSR_PRMD);\n    qemu_fprintf(f, \"EUEN=%016\" PRIx64 \"\\n\", env->CSR_EUEN);\n    qemu_fprintf(f, \"ESTAT=%016\" PRIx64 \"\\n\", env->CSR_ESTAT);\n    qemu_fprintf(f, \"ERA=%016\" PRIx64 \"\\n\", env->CSR_ERA);\n    qemu_fprintf(f, \"BADV=%016\" PRIx64 \"\\n\", env->CSR_BADV);\n    qemu_fprintf(f, \"BADI=%016\" PRIx64 \"\\n\", env->CSR_BADI);\n    qemu_fprintf(f, \"EENTRY=%016\" PRIx64 \"\\n\", env->CSR_EENTRY);\n    qemu_fprintf(f, \"PRCFG1=%016\" PRIx64 \", PRCFG2=%016\" PRIx64 \",\"\n                 \" PRCFG3=%016\" PRIx64 \"\\n\",\n                 env->CSR_PRCFG1, env->CSR_PRCFG3, env->CSR_PRCFG3);\n    qemu_fprintf(f, \"TLBRENTRY=%016\" PRIx64 \"\\n\", env->CSR_TLBRENTRY);\n    qemu_fprintf(f, \"TLBRBADV=%016\" PRIx64 \"\\n\", env->CSR_TLBRBADV);\n    qemu_fprintf(f, \"TLBRERA=%016\" PRIx64 \"\\n\", env->CSR_TLBRERA);\n\n    /* fpr */\n    if (flags & CPU_DUMP_FPU) {\n        for (i = 0; i < 32; i++) {\n            qemu_fprintf(f, \" %s %016\" PRIx64, fregnames[i], env->fpr[i]);\n            if ((i & 3) == 3) {\n                qemu_fprintf(f, \"\\n\");\n            }\n        }\n    }\n}",
        "target": 0
    },
    {
        "func": "static void loongarch_cpu_do_interrupt(CPUState *cs)\n{\n    LoongArchCPU *cpu = LOONGARCH_CPU(cs);\n    CPULoongArchState *env = &cpu->env;\n    bool update_badinstr = 1;\n    int cause = -1;\n    const char *name;\n    bool tlbfill = FIELD_EX64(env->CSR_TLBRERA, CSR_TLBRERA, ISTLBR);\n    uint32_t vec_size = FIELD_EX64(env->CSR_ECFG, CSR_ECFG, VS);\n\n    if (cs->exception_index != EXCCODE_INT) {\n        if (cs->exception_index < 0 ||\n            cs->exception_index > ARRAY_SIZE(excp_names)) {\n            name = \"unknown\";\n        } else {\n            name = excp_names[cs->exception_index];\n        }\n\n        qemu_log_mask(CPU_LOG_INT,\n                     \"%s enter: pc \" TARGET_FMT_lx \" ERA \" TARGET_FMT_lx\n                     \" TLBRERA \" TARGET_FMT_lx \" %s exception\\n\", __func__,\n                     env->pc, env->CSR_ERA, env->CSR_TLBRERA, name);\n    }\n\n    switch (cs->exception_index) {\n    case EXCCODE_DBP:\n        env->CSR_DBG = FIELD_DP64(env->CSR_DBG, CSR_DBG, DCL, 1);\n        env->CSR_DBG = FIELD_DP64(env->CSR_DBG, CSR_DBG, ECODE, 0xC);\n        goto set_DERA;\n    set_DERA:\n        env->CSR_DERA = env->pc;\n        env->CSR_DBG = FIELD_DP64(env->CSR_DBG, CSR_DBG, DST, 1);\n        env->pc = env->CSR_EENTRY + 0x480;\n        break;\n    case EXCCODE_INT:\n        if (FIELD_EX64(env->CSR_DBG, CSR_DBG, DST)) {\n            env->CSR_DBG = FIELD_DP64(env->CSR_DBG, CSR_DBG, DEI, 1);\n            goto set_DERA;\n        }\n        QEMU_FALLTHROUGH;\n    case EXCCODE_PIF:\n        cause = cs->exception_index;\n        update_badinstr = 0;\n        break;\n    case EXCCODE_SYS:\n    case EXCCODE_BRK:\n    case EXCCODE_INE:\n    case EXCCODE_IPE:\n    case EXCCODE_FPE:\n    case EXCCODE_BCE:\n        env->CSR_BADV = env->pc;\n        QEMU_FALLTHROUGH;\n    case EXCCODE_ADEM:\n    case EXCCODE_PIL:\n    case EXCCODE_PIS:\n    case EXCCODE_PME:\n    case EXCCODE_PNR:\n    case EXCCODE_PNX:\n    case EXCCODE_PPI:\n        cause = cs->exception_index;\n        break;\n    default:\n        qemu_log(\"Error: exception(%d) '%s' has not been supported\\n\",\n                 cs->exception_index, excp_names[cs->exception_index]);\n        abort();\n    }\n\n    if (update_badinstr) {\n        env->CSR_BADI = cpu_ldl_code(env, env->pc);\n    }\n\n    /* Save PLV and IE */\n    if (tlbfill) {\n        env->CSR_TLBRPRMD = FIELD_DP64(env->CSR_TLBRPRMD, CSR_TLBRPRMD, PPLV,\n                                       FIELD_EX64(env->CSR_CRMD,\n                                       CSR_CRMD, PLV));\n        env->CSR_TLBRPRMD = FIELD_DP64(env->CSR_TLBRPRMD, CSR_TLBRPRMD, PIE,\n                                       FIELD_EX64(env->CSR_CRMD, CSR_CRMD, IE));\n        /* set the DA mode */\n        env->CSR_CRMD = FIELD_DP64(env->CSR_CRMD, CSR_CRMD, DA, 1);\n        env->CSR_CRMD = FIELD_DP64(env->CSR_CRMD, CSR_CRMD, PG, 0);\n        env->CSR_TLBRERA = FIELD_DP64(env->CSR_TLBRERA, CSR_TLBRERA,\n                                      PC, (env->pc >> 2));\n    } else {\n        env->CSR_ESTAT = FIELD_DP64(env->CSR_ESTAT, CSR_ESTAT, ECODE, cause);\n        env->CSR_PRMD = FIELD_DP64(env->CSR_PRMD, CSR_PRMD, PPLV,\n                                   FIELD_EX64(env->CSR_CRMD, CSR_CRMD, PLV));\n        env->CSR_PRMD = FIELD_DP64(env->CSR_PRMD, CSR_PRMD, PIE,\n                                   FIELD_EX64(env->CSR_CRMD, CSR_CRMD, IE));\n        env->CSR_ERA = env->pc;\n    }\n\n    env->CSR_CRMD = FIELD_DP64(env->CSR_CRMD, CSR_CRMD, PLV, 0);\n    env->CSR_CRMD = FIELD_DP64(env->CSR_CRMD, CSR_CRMD, IE, 0);\n\n    if (vec_size) {\n        vec_size = (1 << vec_size) * 4;\n    }\n\n    if  (cs->exception_index == EXCCODE_INT) {\n        /* Interrupt */\n        uint32_t vector = 0;\n        uint32_t pending = FIELD_EX64(env->CSR_ESTAT, CSR_ESTAT, IS);\n        pending &= FIELD_EX64(env->CSR_ECFG, CSR_ECFG, LIE);\n\n        /* Find the highest-priority interrupt. */\n        vector = 31 - clz32(pending);\n        env->pc = env->CSR_EENTRY + (EXCCODE_EXTERNAL_INT + vector) * vec_size;\n        qemu_log_mask(CPU_LOG_INT,\n                      \"%s: PC \" TARGET_FMT_lx \" ERA \" TARGET_FMT_lx\n                      \" cause %d\\n\" \"    A \" TARGET_FMT_lx \" D \"\n                      TARGET_FMT_lx \" vector = %d ExC \" TARGET_FMT_lx \"ExS\"\n                      TARGET_FMT_lx \"\\n\",\n                      __func__, env->pc, env->CSR_ERA,\n                      cause, env->CSR_BADV, env->CSR_DERA, vector,\n                      env->CSR_ECFG, env->CSR_ESTAT);\n    } else {\n        if (tlbfill) {\n            env->pc = env->CSR_TLBRENTRY;\n        } else {\n            env->pc = env->CSR_EENTRY;\n            env->pc += cause * vec_size;\n        }\n        qemu_log_mask(CPU_LOG_INT,\n                      \"%s: PC \" TARGET_FMT_lx \" ERA \" TARGET_FMT_lx\n                      \" cause %d%s\\n, ESTAT \" TARGET_FMT_lx\n                      \" EXCFG \" TARGET_FMT_lx \" BADVA \" TARGET_FMT_lx\n                      \"BADI \" TARGET_FMT_lx \" SYS_NUM \" TARGET_FMT_lu\n                      \" cpu %d asid \" TARGET_FMT_lx \"\\n\", __func__, env->pc,\n                      tlbfill ? env->CSR_TLBRERA : env->CSR_ERA,\n                      cause, tlbfill ? \"(refill)\" : \"\", env->CSR_ESTAT,\n                      env->CSR_ECFG,\n                      tlbfill ? env->CSR_TLBRBADV : env->CSR_BADV,\n                      env->CSR_BADI, env->gpr[11], cs->cpu_index,\n                      env->CSR_ASID);\n    }\n    cs->exception_index = -1;\n}",
        "target": 0
    },
    {
        "func": "static void loongarch_cpu_init(Object *obj)\n{\n    LoongArchCPU *cpu = LOONGARCH_CPU(obj);\n\n    cpu_set_cpustate_pointers(cpu);\n\n#ifndef CONFIG_USER_ONLY\n    CPULoongArchState *env = &cpu->env;\n    qdev_init_gpio_in(DEVICE(cpu), loongarch_cpu_set_irq, N_IRQS);\n    timer_init_ns(&cpu->timer, QEMU_CLOCK_VIRTUAL,\n                  &loongarch_constant_timer_cb, cpu);\n    memory_region_init_io(&env->system_iocsr, OBJECT(cpu), NULL,\n                      env, \"iocsr\", UINT64_MAX);\n    address_space_init(&env->address_space_iocsr, &env->system_iocsr, \"IOCSR\");\n    memory_region_init_io(&env->iocsr_mem, OBJECT(cpu), &loongarch_qemu_ops,\n                          NULL, \"iocsr_misc\", 0x428);\n    memory_region_add_subregion(&env->system_iocsr, 0, &env->iocsr_mem);\n#endif\n}",
        "target": 0
    },
    {
        "func": "static void loongarch_cpu_class_init(ObjectClass *c, void *data)\n{\n    LoongArchCPUClass *lacc = LOONGARCH_CPU_CLASS(c);\n    CPUClass *cc = CPU_CLASS(c);\n    DeviceClass *dc = DEVICE_CLASS(c);\n\n    device_class_set_parent_realize(dc, loongarch_cpu_realizefn,\n                                    &lacc->parent_realize);\n    device_class_set_parent_reset(dc, loongarch_cpu_reset, &lacc->parent_reset);\n\n    cc->class_by_name = loongarch_cpu_class_by_name;\n    cc->has_work = loongarch_cpu_has_work;\n    cc->dump_state = loongarch_cpu_dump_state;\n    cc->set_pc = loongarch_cpu_set_pc;\n#ifndef CONFIG_USER_ONLY\n    dc->vmsd = &vmstate_loongarch_cpu;\n    cc->sysemu_ops = &loongarch_sysemu_ops;\n#endif\n    cc->disas_set_info = loongarch_cpu_disas_set_info;\n    cc->gdb_read_register = loongarch_cpu_gdb_read_register;\n    cc->gdb_write_register = loongarch_cpu_gdb_write_register;\n    cc->disas_set_info = loongarch_cpu_disas_set_info;\n    cc->gdb_num_core_regs = 34;\n    cc->gdb_core_xml_file = \"loongarch-base64.xml\";\n    cc->gdb_stop_before_watchpoint = true;\n\n#ifdef CONFIG_TCG\n    cc->tcg_ops = &loongarch_tcg_ops;\n#endif\n}",
        "target": 0
    },
    {
        "func": "void G_NORETURN do_raise_exception(CPULoongArchState *env,\n                                   uint32_t exception,\n                                   uintptr_t pc)\n{\n    CPUState *cs = env_cpu(env);\n\n    qemu_log_mask(CPU_LOG_INT, \"%s: %d (%s)\\n\",\n                  __func__,\n                  exception,\n                  loongarch_exception_name(exception));\n    cs->exception_index = exception;\n\n    cpu_loop_exit_restore(cs, pc);\n}",
        "target": 0
    },
    {
        "func": "static void loongarch_cpu_list_entry(gpointer data, gpointer user_data)\n{\n    const char *typename = object_class_get_name(OBJECT_CLASS(data));\n\n    qemu_printf(\"%s\\n\", typename);\n}",
        "target": 0
    },
    {
        "func": "const char *loongarch_exception_name(int32_t exception)\n{\n    assert(excp_names[exception]);\n    return excp_names[exception];\n}",
        "target": 0
    },
    {
        "func": "static void loongarch_cpu_disas_set_info(CPUState *s, disassemble_info *info)\n{\n    info->print_insn = print_insn_loongarch;\n}",
        "target": 0
    },
    {
        "func": "void loongarch_cpu_set_irq(void *opaque, int irq, int level)\n{\n    LoongArchCPU *cpu = opaque;\n    CPULoongArchState *env = &cpu->env;\n    CPUState *cs = CPU(cpu);\n\n    if (irq < 0 || irq >= N_IRQS) {\n        return;\n    }\n\n    env->CSR_ESTAT = deposit64(env->CSR_ESTAT, irq, 1, level != 0);\n\n    if (FIELD_EX64(env->CSR_ESTAT, CSR_ESTAT, IS)) {\n        cpu_interrupt(cs, CPU_INTERRUPT_HARD);\n    } else {\n        cpu_reset_interrupt(cs, CPU_INTERRUPT_HARD);\n    }\n}",
        "target": 0
    },
    {
        "func": "static void loongarch_cpu_reset(DeviceState *dev)\n{\n    CPUState *cs = CPU(dev);\n    LoongArchCPU *cpu = LOONGARCH_CPU(cs);\n    LoongArchCPUClass *lacc = LOONGARCH_CPU_GET_CLASS(cpu);\n    CPULoongArchState *env = &cpu->env;\n\n    lacc->parent_reset(dev);\n\n    env->fcsr0_mask = FCSR0_M1 | FCSR0_M2 | FCSR0_M3;\n    env->fcsr0 = 0x0;\n\n    int n;\n    /* Set csr registers value after reset */\n    env->CSR_CRMD = FIELD_DP64(env->CSR_CRMD, CSR_CRMD, PLV, 0);\n    env->CSR_CRMD = FIELD_DP64(env->CSR_CRMD, CSR_CRMD, IE, 0);\n    env->CSR_CRMD = FIELD_DP64(env->CSR_CRMD, CSR_CRMD, DA, 1);\n    env->CSR_CRMD = FIELD_DP64(env->CSR_CRMD, CSR_CRMD, PG, 0);\n    env->CSR_CRMD = FIELD_DP64(env->CSR_CRMD, CSR_CRMD, DATF, 1);\n    env->CSR_CRMD = FIELD_DP64(env->CSR_CRMD, CSR_CRMD, DATM, 1);\n\n    env->CSR_EUEN = FIELD_DP64(env->CSR_EUEN, CSR_EUEN, FPE, 0);\n    env->CSR_EUEN = FIELD_DP64(env->CSR_EUEN, CSR_EUEN, SXE, 0);\n    env->CSR_EUEN = FIELD_DP64(env->CSR_EUEN, CSR_EUEN, ASXE, 0);\n    env->CSR_EUEN = FIELD_DP64(env->CSR_EUEN, CSR_EUEN, BTE, 0);\n\n    env->CSR_MISC = 0;\n\n    env->CSR_ECFG = FIELD_DP64(env->CSR_ECFG, CSR_ECFG, VS, 0);\n    env->CSR_ECFG = FIELD_DP64(env->CSR_ECFG, CSR_ECFG, LIE, 0);\n\n    env->CSR_ESTAT = env->CSR_ESTAT & (~MAKE_64BIT_MASK(0, 2));\n    env->CSR_RVACFG = FIELD_DP64(env->CSR_RVACFG, CSR_RVACFG, RBITS, 0);\n    env->CSR_TCFG = FIELD_DP64(env->CSR_TCFG, CSR_TCFG, EN, 0);\n    env->CSR_LLBCTL = FIELD_DP64(env->CSR_LLBCTL, CSR_LLBCTL, KLO, 0);\n    env->CSR_TLBRERA = FIELD_DP64(env->CSR_TLBRERA, CSR_TLBRERA, ISTLBR, 0);\n    env->CSR_MERRCTL = FIELD_DP64(env->CSR_MERRCTL, CSR_MERRCTL, ISMERR, 0);\n\n    env->CSR_PRCFG3 = FIELD_DP64(env->CSR_PRCFG3, CSR_PRCFG3, TLB_TYPE, 2);\n    env->CSR_PRCFG3 = FIELD_DP64(env->CSR_PRCFG3, CSR_PRCFG3, MTLB_ENTRY, 63);\n    env->CSR_PRCFG3 = FIELD_DP64(env->CSR_PRCFG3, CSR_PRCFG3, STLB_WAYS, 7);\n    env->CSR_PRCFG3 = FIELD_DP64(env->CSR_PRCFG3, CSR_PRCFG3, STLB_SETS, 8);\n\n    for (n = 0; n < 4; n++) {\n        env->CSR_DMW[n] = FIELD_DP64(env->CSR_DMW[n], CSR_DMW, PLV0, 0);\n        env->CSR_DMW[n] = FIELD_DP64(env->CSR_DMW[n], CSR_DMW, PLV1, 0);\n        env->CSR_DMW[n] = FIELD_DP64(env->CSR_DMW[n], CSR_DMW, PLV2, 0);\n        env->CSR_DMW[n] = FIELD_DP64(env->CSR_DMW[n], CSR_DMW, PLV3, 0);\n    }\n\n#ifndef CONFIG_USER_ONLY\n    env->pc = 0x1c000000;\n    memset(env->tlb, 0, sizeof(env->tlb));\n#endif\n\n    restore_fp_status(env);\n    cs->exception_index = -1;\n}",
        "target": 0
    },
    {
        "func": "static void loongarch_cpu_set_pc(CPUState *cs, vaddr value)\n{\n    LoongArchCPU *cpu = LOONGARCH_CPU(cs);\n    CPULoongArchState *env = &cpu->env;\n\n    env->pc = value;\n}",
        "target": 0
    },
    {
        "func": "static void loongarch_cpu_do_transaction_failed(CPUState *cs, hwaddr physaddr,\n                                                vaddr addr, unsigned size,\n                                                MMUAccessType access_type,\n                                                int mmu_idx, MemTxAttrs attrs,\n                                                MemTxResult response,\n                                                uintptr_t retaddr)\n{\n    LoongArchCPU *cpu = LOONGARCH_CPU(cs);\n    CPULoongArchState *env = &cpu->env;\n\n    if (access_type == MMU_INST_FETCH) {\n        do_raise_exception(env, EXCCODE_ADEF, retaddr);\n    } else {\n        do_raise_exception(env, EXCCODE_ADEM, retaddr);\n    }\n}",
        "target": 0
    },
    {
        "func": "static inline bool cpu_loongarch_hw_interrupts_enabled(CPULoongArchState *env)\n{\n    bool ret = 0;\n\n    ret = (FIELD_EX64(env->CSR_CRMD, CSR_CRMD, IE) &&\n          !(FIELD_EX64(env->CSR_DBG, CSR_DBG, DST)));\n\n    return ret;\n}",
        "target": 0
    },
    {
        "func": "static void loongarch_qemu_write(void *opaque, hwaddr addr,\n                                 uint64_t val, unsigned size)\n{\n}",
        "target": 0
    },
    {
        "func": "void loongarch_cpu_list(void)\n{\n    GSList *list;\n    list = object_class_get_list_sorted(TYPE_LOONGARCH_CPU, false);\n    g_slist_foreach(list, loongarch_cpu_list_entry, NULL);\n    g_slist_free(list);\n}",
        "target": 0
    },
    {
        "func": "static void loongarch_cpu_realizefn(DeviceState *dev, Error **errp)\n{\n    CPUState *cs = CPU(dev);\n    LoongArchCPUClass *lacc = LOONGARCH_CPU_GET_CLASS(dev);\n    Error *local_err = NULL;\n\n    cpu_exec_realizefn(cs, &local_err);\n    if (local_err != NULL) {\n        error_propagate(errp, local_err);\n        return;\n    }\n\n    loongarch_cpu_register_gdb_regs_for_features(cs);\n\n    cpu_reset(cs);\n    qemu_init_vcpu(cs);\n\n    lacc->parent_realize(dev, errp);\n}",
        "target": 0
    },
    {
        "func": "static uint64_t loongarch_qemu_read(void *opaque, hwaddr addr, unsigned size)\n{\n    switch (addr) {\n    case FEATURE_REG:\n        return 1ULL << IOCSRF_MSI | 1ULL << IOCSRF_EXTIOI |\n               1ULL << IOCSRF_CSRIPI;\n    case VENDOR_REG:\n        return 0x6e6f73676e6f6f4cULL; /* \"Loongson\" */\n    case CPUNAME_REG:\n        return 0x303030354133ULL;     /* \"3A5000\" */\n    case MISC_FUNC_REG:\n        return 1ULL << IOCSRM_EXTIOI_EN;\n    }\n    return 0ULL;\n}",
        "target": 0
    },
    {
        "func": "static void loongarch_la464_initfn(Object *obj)\n{\n    LoongArchCPU *cpu = LOONGARCH_CPU(obj);\n    CPULoongArchState *env = &cpu->env;\n    int i;\n\n    for (i = 0; i < 21; i++) {\n        env->cpucfg[i] = 0x0;\n    }\n\n    env->cpucfg[0] = 0x14c010;  /* PRID */\n\n    uint32_t data = 0;\n    data = FIELD_DP32(data, CPUCFG1, ARCH, 2);\n    data = FIELD_DP32(data, CPUCFG1, PGMMU, 1);\n    data = FIELD_DP32(data, CPUCFG1, IOCSR, 1);\n    data = FIELD_DP32(data, CPUCFG1, PALEN, 0x2f);\n    data = FIELD_DP32(data, CPUCFG1, VALEN, 0x2f);\n    data = FIELD_DP32(data, CPUCFG1, UAL, 1);\n    data = FIELD_DP32(data, CPUCFG1, RI, 1);\n    data = FIELD_DP32(data, CPUCFG1, EP, 1);\n    data = FIELD_DP32(data, CPUCFG1, RPLV, 1);\n    data = FIELD_DP32(data, CPUCFG1, HP, 1);\n    data = FIELD_DP32(data, CPUCFG1, IOCSR_BRD, 1);\n    env->cpucfg[1] = data;\n\n    data = 0;\n    data = FIELD_DP32(data, CPUCFG2, FP, 1);\n    data = FIELD_DP32(data, CPUCFG2, FP_SP, 1);\n    data = FIELD_DP32(data, CPUCFG2, FP_DP, 1);\n    data = FIELD_DP32(data, CPUCFG2, FP_VER, 1);\n    data = FIELD_DP32(data, CPUCFG2, LLFTP, 1);\n    data = FIELD_DP32(data, CPUCFG2, LLFTP_VER, 1);\n    data = FIELD_DP32(data, CPUCFG2, LAM, 1);\n    env->cpucfg[2] = data;\n\n    env->cpucfg[4] = 100 * 1000 * 1000; /* Crystal frequency */\n\n    data = 0;\n    data = FIELD_DP32(data, CPUCFG5, CC_MUL, 1);\n    data = FIELD_DP32(data, CPUCFG5, CC_DIV, 1);\n    env->cpucfg[5] = data;\n\n    data = 0;\n    data = FIELD_DP32(data, CPUCFG16, L1_IUPRE, 1);\n    data = FIELD_DP32(data, CPUCFG16, L1_DPRE, 1);\n    data = FIELD_DP32(data, CPUCFG16, L2_IUPRE, 1);\n    data = FIELD_DP32(data, CPUCFG16, L2_IUUNIFY, 1);\n    data = FIELD_DP32(data, CPUCFG16, L2_IUPRIV, 1);\n    data = FIELD_DP32(data, CPUCFG16, L3_IUPRE, 1);\n    data = FIELD_DP32(data, CPUCFG16, L3_IUUNIFY, 1);\n    data = FIELD_DP32(data, CPUCFG16, L3_IUINCL, 1);\n    env->cpucfg[16] = data;\n\n    data = 0;\n    data = FIELD_DP32(data, CPUCFG17, L1IU_WAYS, 3);\n    data = FIELD_DP32(data, CPUCFG17, L1IU_SETS, 8);\n    data = FIELD_DP32(data, CPUCFG17, L1IU_SIZE, 6);\n    env->cpucfg[17] = data;\n\n    data = 0;\n    data = FIELD_DP32(data, CPUCFG18, L1D_WAYS, 3);\n    data = FIELD_DP32(data, CPUCFG18, L1D_SETS, 8);\n    data = FIELD_DP32(data, CPUCFG18, L1D_SIZE, 6);\n    env->cpucfg[18] = data;\n\n    data = 0;\n    data = FIELD_DP32(data, CPUCFG19, L2IU_WAYS, 15);\n    data = FIELD_DP32(data, CPUCFG19, L2IU_SETS, 8);\n    data = FIELD_DP32(data, CPUCFG19, L2IU_SIZE, 6);\n    env->cpucfg[19] = data;\n\n    data = 0;\n    data = FIELD_DP32(data, CPUCFG20, L3IU_WAYS, 15);\n    data = FIELD_DP32(data, CPUCFG20, L3IU_SETS, 14);\n    data = FIELD_DP32(data, CPUCFG20, L3IU_SETS, 6);\n    env->cpucfg[20] = data;\n\n    env->CSR_ASID = FIELD_DP64(0, CSR_ASID, ASIDBITS, 0xa);\n}",
        "target": 0
    },
    {
        "func": "static inline bool cpu_loongarch_hw_interrupts_pending(CPULoongArchState *env)\n{\n    uint32_t pending;\n    uint32_t status;\n    bool r;\n\n    pending = FIELD_EX64(env->CSR_ESTAT, CSR_ESTAT, IS);\n    status  = FIELD_EX64(env->CSR_ECFG, CSR_ECFG, LIE);\n\n    r = (pending & status) != 0;\n    return r;\n}",
        "target": 0
    },
    {
        "func": "static ObjectClass *loongarch_cpu_class_by_name(const char *cpu_model)\n{\n    ObjectClass *oc;\n    char *typename;\n\n    typename = g_strdup_printf(LOONGARCH_CPU_TYPE_NAME(\"%s\"), cpu_model);\n    oc = object_class_by_name(typename);\n    g_free(typename);\n    return oc;\n}",
        "target": 0
    },
    {
        "func": "CpuDefinitionInfoList *qmp_query_cpu_definitions(Error **errp)\n{\n    CpuDefinitionInfoList *cpu_list = NULL;\n    GSList *list;\n\n    list = object_class_get_list(TYPE_LOONGARCH_CPU, false);\n    g_slist_foreach(list, loongarch_cpu_add_definition, &cpu_list);\n    g_slist_free(list);\n\n    return cpu_list;\n}",
        "target": 0
    },
    {
        "func": "static bool loongarch_cpu_exec_interrupt(CPUState *cs, int interrupt_request)\n{\n    if (interrupt_request & CPU_INTERRUPT_HARD) {\n        LoongArchCPU *cpu = LOONGARCH_CPU(cs);\n        CPULoongArchState *env = &cpu->env;\n\n        if (cpu_loongarch_hw_interrupts_enabled(env) &&\n            cpu_loongarch_hw_interrupts_pending(env)) {\n            /* Raise it */\n            cs->exception_index = EXCCODE_INT;\n            loongarch_cpu_do_interrupt(cs);\n            return true;\n        }\n    }\n    return false;\n}",
        "target": 0
    },
    {
        "func": "static bool loongarch_cpu_has_work(CPUState *cs)\n{\n#ifdef CONFIG_USER_ONLY\n    return true;\n#else\n    LoongArchCPU *cpu = LOONGARCH_CPU(cs);\n    CPULoongArchState *env = &cpu->env;\n    bool has_work = false;\n\n    if ((cs->interrupt_request & CPU_INTERRUPT_HARD) &&\n        cpu_loongarch_hw_interrupts_pending(env)) {\n        has_work = true;\n    }\n\n    return has_work;\n#endif\n}",
        "target": 0
    },
    {
        "func": "static void loongarch_cpu_add_definition(gpointer data, gpointer user_data)\n{\n    ObjectClass *oc = data;\n    CpuDefinitionInfoList **cpu_list = user_data;\n    CpuDefinitionInfo *info = g_new0(CpuDefinitionInfo, 1);\n    const char *typename = object_class_get_name(oc);\n\n    info->name = g_strndup(typename,\n                           strlen(typename) - strlen(\"-\" TYPE_LOONGARCH_CPU));\n    info->q_typename = g_strdup(typename);\n\n    QAPI_LIST_PREPEND(*cpu_list, info);\n}",
        "target": 0
    },
    {
        "func": "static void loongarch_cpu_synchronize_from_tb(CPUState *cs,\n                                              const TranslationBlock *tb)\n{\n    LoongArchCPU *cpu = LOONGARCH_CPU(cs);\n    CPULoongArchState *env = &cpu->env;\n\n    env->pc = tb->pc;\n}",
        "target": 0
    },
    {
        "func": "int _gnutls_ciphertext2compressed(gnutls_session_t session,\n\t\t\t\t  opaque * compress_data,\n\t\t\t\t  int compress_size,\n\t\t\t\t  gnutls_datum_t ciphertext, uint8 type)\n{\n    uint8 MAC[MAX_HASH_SIZE];\n    uint16 c_length;\n    uint8 pad;\n    int length;\n    mac_hd_t td;\n    uint16 blocksize;\n    int ret, i, pad_failed = 0;\n    uint8 major, minor;\n    gnutls_protocol_t ver;\n    int hash_size =\n\t_gnutls_hash_get_algo_len(session->security_parameters.\n\t\t\t\t  read_mac_algorithm);\n\n    ver = gnutls_protocol_get_version(session);\n    minor = _gnutls_version_get_minor(ver);\n    major = _gnutls_version_get_major(ver);\n\n    blocksize = _gnutls_cipher_get_block_size(session->security_parameters.\n\t\t\t\t\t      read_bulk_cipher_algorithm);\n\n    /* initialize MAC \n     */\n    td = mac_init(session->security_parameters.read_mac_algorithm,\n\t\t  session->connection_state.read_mac_secret.data,\n\t\t  session->connection_state.read_mac_secret.size, ver);\n\n    if (td == GNUTLS_MAC_FAILED\n\t&& session->security_parameters.read_mac_algorithm !=\n\tGNUTLS_MAC_NULL) {\n\tgnutls_assert();\n\treturn GNUTLS_E_INTERNAL_ERROR;\n    }\n\n\n    /* actual decryption (inplace)\n     */\n    switch (_gnutls_cipher_is_block\n\t    (session->security_parameters.read_bulk_cipher_algorithm)) {\n    case CIPHER_STREAM:\n\tif ((ret = _gnutls_cipher_decrypt(session->connection_state.\n\t\t\t\t\t  read_cipher_state,\n\t\t\t\t\t  ciphertext.data,\n\t\t\t\t\t  ciphertext.size)) < 0) {\n\t    gnutls_assert();\n\t    return ret;\n\t}\n\n\tlength = ciphertext.size - hash_size;\n\n\tbreak;\n    case CIPHER_BLOCK:\n\tif ((ciphertext.size < blocksize)\n\t    || (ciphertext.size % blocksize != 0)) {\n\t    gnutls_assert();\n\t    return GNUTLS_E_DECRYPTION_FAILED;\n\t}\n\n\tif ((ret = _gnutls_cipher_decrypt(session->connection_state.\n\t\t\t\t\t  read_cipher_state,\n\t\t\t\t\t  ciphertext.data,\n\t\t\t\t\t  ciphertext.size)) < 0) {\n\t    gnutls_assert();\n\t    return ret;\n\t}\n\n\t/* ignore the IV in TLS 1.1.\n\t */\n\tif (session->security_parameters.version >= GNUTLS_TLS1_1) {\n\t    ciphertext.size -= blocksize;\n\t    ciphertext.data += blocksize;\n\n\t    if (ciphertext.size == 0) {\n\t\tgnutls_assert();\n\t\treturn GNUTLS_E_DECRYPTION_FAILED;\n\t    }\n\t}\n\n\tpad = ciphertext.data[ciphertext.size - 1] + 1;\t/* pad */\n\n\tlength = ciphertext.size - hash_size - pad;\n\n\tif (pad > ciphertext.size - hash_size) {\n\t    gnutls_assert();\n\t    /* We do not fail here. We check below for the\n\t     * the pad_failed. If zero means success.\n\t     */\n\t    pad_failed = GNUTLS_E_DECRYPTION_FAILED;\n\t}\n\n\t/* Check the pading bytes (TLS 1.x)\n\t */\n\tif (ver >= GNUTLS_TLS1)\n\t    for (i = 2; i < pad; i++) {\n\t\tif (ciphertext.data[ciphertext.size - i] !=\n\t\t    ciphertext.data[ciphertext.size - 1])\n\t\t    pad_failed = GNUTLS_E_DECRYPTION_FAILED;\n\t    }\n\n\tbreak;\n    default:\n\tgnutls_assert();\n\treturn GNUTLS_E_INTERNAL_ERROR;\n    }\n\n    if (length < 0)\n\tlength = 0;\n    c_length = _gnutls_conv_uint16((uint16) length);\n\n    /* Pass the type, version, length and compressed through\n     * MAC.\n     */\n    if (td != GNUTLS_MAC_FAILED) {\n\t_gnutls_hmac(td,\n\t\t     UINT64DATA(session->connection_state.\n\t\t\t\tread_sequence_number), 8);\n\n\t_gnutls_hmac(td, &type, 1);\n\tif (ver >= GNUTLS_TLS1) {\t/* TLS 1.x */\n\t    _gnutls_hmac(td, &major, 1);\n\t    _gnutls_hmac(td, &minor, 1);\n\t}\n\t_gnutls_hmac(td, &c_length, 2);\n\n\tif (length > 0)\n\t    _gnutls_hmac(td, ciphertext.data, length);\n\n\tmac_deinit(td, MAC, ver);\n    }\n\n    /* This one was introduced to avoid a timing attack against the TLS\n     * 1.0 protocol.\n     */\n    if (pad_failed != 0)\n\treturn pad_failed;\n\n    /* HMAC was not the same. \n     */\n    if (memcmp(MAC, &ciphertext.data[length], hash_size) != 0) {\n\tgnutls_assert();\n\treturn GNUTLS_E_DECRYPTION_FAILED;\n    }\n\n    /* copy the decrypted stuff to compress_data.\n     */\n    if (compress_size < length) {\n\tgnutls_assert();\n\treturn GNUTLS_E_INTERNAL_ERROR;\n    }\n    memcpy(compress_data, ciphertext.data, length);\n\n    return length;\n}",
        "target": 1
    },
    {
        "func": "int _gnutls_ciphertext2compressed(gnutls_session_t session,\n\t\t\t\t  opaque * compress_data,\n\t\t\t\t  int compress_size,\n\t\t\t\t  gnutls_datum_t ciphertext, uint8 type)\n{\n    uint8 MAC[MAX_HASH_SIZE];\n    uint16 c_length;\n    uint8 pad;\n    int length;\n    mac_hd_t td;\n    uint16 blocksize;\n    int ret, i, pad_failed = 0;\n    uint8 major, minor;\n    gnutls_protocol_t ver;\n    int hash_size =\n\t_gnutls_hash_get_algo_len(session->security_parameters.\n\t\t\t\t  read_mac_algorithm);\n\n    ver = gnutls_protocol_get_version(session);\n    minor = _gnutls_version_get_minor(ver);\n    major = _gnutls_version_get_major(ver);\n\n    blocksize = _gnutls_cipher_get_block_size(session->security_parameters.\n\t\t\t\t\t      read_bulk_cipher_algorithm);\n\n    /* initialize MAC \n     */\n    td = mac_init(session->security_parameters.read_mac_algorithm,\n\t\t  session->connection_state.read_mac_secret.data,\n\t\t  session->connection_state.read_mac_secret.size, ver);\n\n    if (td == GNUTLS_MAC_FAILED\n\t&& session->security_parameters.read_mac_algorithm !=\n\tGNUTLS_MAC_NULL) {\n\tgnutls_assert();\n\treturn GNUTLS_E_INTERNAL_ERROR;\n    }\n\n\n    /* actual decryption (inplace)\n     */\n    switch (_gnutls_cipher_is_block\n\t    (session->security_parameters.read_bulk_cipher_algorithm)) {\n    case CIPHER_STREAM:\n\tif ((ret = _gnutls_cipher_decrypt(session->connection_state.\n\t\t\t\t\t  read_cipher_state,\n\t\t\t\t\t  ciphertext.data,\n\t\t\t\t\t  ciphertext.size)) < 0) {\n\t    gnutls_assert();\n\t    return ret;\n\t}\n\n\tlength = ciphertext.size - hash_size;\n\n\tbreak;\n    case CIPHER_BLOCK:\n\tif ((ciphertext.size < blocksize)\n\t    || (ciphertext.size % blocksize != 0)) {\n\t    gnutls_assert();\n\t    return GNUTLS_E_DECRYPTION_FAILED;\n\t}\n\n\tif ((ret = _gnutls_cipher_decrypt(session->connection_state.\n\t\t\t\t\t  read_cipher_state,\n\t\t\t\t\t  ciphertext.data,\n\t\t\t\t\t  ciphertext.size)) < 0) {\n\t    gnutls_assert();\n\t    return ret;\n\t}\n\n\t/* ignore the IV in TLS 1.1.\n\t */\n\tif (session->security_parameters.version >= GNUTLS_TLS1_1) {\n\t    ciphertext.size -= blocksize;\n\t    ciphertext.data += blocksize;\n\n\t    if (ciphertext.size == 0) {\n\t\tgnutls_assert();\n\t\treturn GNUTLS_E_DECRYPTION_FAILED;\n\t    }\n\t}\n\n\tpad = ciphertext.data[ciphertext.size - 1] + 1;\t/* pad */\n\n\tlength = ciphertext.size - hash_size - pad;\n\n\tif (pad > ciphertext.size - hash_size) {\n\t    gnutls_assert();\n\t    /* We do not fail here. We check below for the\n\t     * the pad_failed. If zero means success.\n\t     */\n\t    pad_failed = GNUTLS_E_DECRYPTION_FAILED;\n\t}\n\n\t/* Check the pading bytes (TLS 1.x)\n\t */\n\tif (ver >= GNUTLS_TLS1)\n\t    for (i = 2; i < pad; i++) {\n\t\tif (ciphertext.data[ciphertext.size - i] !=\n\t\t    ciphertext.data[ciphertext.size - 1])\n\t\t    pad_failed = GNUTLS_E_DECRYPTION_FAILED;\n\t    }\n\n\tbreak;\n    default:\n\tgnutls_assert();\n\treturn GNUTLS_E_INTERNAL_ERROR;\n    }\n\n    if (length < 0)\n\tlength = 0;\n    c_length = _gnutls_conv_uint16((uint16) length);\n\n    /* Pass the type, version, length and compressed through\n     * MAC.\n     */\n    if (td != GNUTLS_MAC_FAILED) {\n\t_gnutls_hmac(td,\n\t\t     UINT64DATA(session->connection_state.\n\t\t\t\tread_sequence_number), 8);\n\n\t_gnutls_hmac(td, &type, 1);\n\tif (ver >= GNUTLS_TLS1) {\t/* TLS 1.x */\n\t    _gnutls_hmac(td, &major, 1);\n\t    _gnutls_hmac(td, &minor, 1);\n\t}\n\t_gnutls_hmac(td, &c_length, 2);\n\n\tif (length > 0)\n\t    _gnutls_hmac(td, ciphertext.data, length);\n\n\tmac_deinit(td, MAC, ver);\n    }\n\n    /* This one was introduced to avoid a timing attack against the TLS\n     * 1.0 protocol.\n     */\n    if (pad_failed != 0)\n\treturn pad_failed;\n\n    /* HMAC was not the same. \n     */\n    if (memcmp(MAC, &ciphertext.data[length], hash_size) != 0) {\n\tgnutls_assert();\n\treturn GNUTLS_E_DECRYPTION_FAILED;\n    }\n\n    /* copy the decrypted stuff to compress_data.\n     */\n    if (compress_size < length) {\n\tgnutls_assert();\n\treturn GNUTLS_E_INTERNAL_ERROR;\n    }\n    memcpy(compress_data, ciphertext.data, length);\n\n    return length;\n}",
        "target": 1
    },
    {
        "func": "static char *make_filename_safe(const char *filename TSRMLS_DC)\n{\n\tif (*filename && strncmp(filename, \":memory:\", sizeof(\":memory:\")-1)) {\n\t\tchar *fullpath = expand_filepath(filename, NULL TSRMLS_CC);\n\n\t\tif (!fullpath) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (PG(safe_mode) && (!php_checkuid(fullpath, NULL, CHECKUID_CHECK_FILE_AND_DIR))) {\n\t\t\tefree(fullpath);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (php_check_open_basedir(fullpath TSRMLS_CC)) {\n\t\t\tefree(fullpath);\n\t\t\treturn NULL;\n\t\t}\n\t\treturn fullpath;\n\t}\n\treturn estrdup(filename);\n}",
        "target": 1
    },
    {
        "func": "unpack_Z_stream(int fd_in, int fd_out)\n{\n\tIF_DESKTOP(long long total_written = 0;)\n\tIF_DESKTOP(long long) int retval = -1;\n\tunsigned char *stackp;\n\tlong code;\n\tint finchar;\n\tlong oldcode;\n\tlong incode;\n\tint inbits;\n\tint posbits;\n\tint outpos;\n\tint insize;\n\tint bitmask;\n\tlong free_ent;\n\tlong maxcode;\n\tlong maxmaxcode;\n\tint n_bits;\n\tint rsize = 0;\n\tunsigned char *inbuf; /* were eating insane amounts of stack - */\n\tunsigned char *outbuf; /* bad for some embedded targets */\n\tunsigned char *htab;\n\tunsigned short *codetab;\n\n\t/* Hmm, these were statics - why?! */\n\t/* user settable max # bits/code */\n\tint maxbits; /* = BITS; */\n\t/* block compress mode -C compatible with 2.0 */\n\tint block_mode; /* = BLOCK_MODE; */\n\n\tinbuf = xzalloc(IBUFSIZ + 64);\n\toutbuf = xzalloc(OBUFSIZ + 2048);\n\thtab = xzalloc(HSIZE);  /* wsn't zeroed out before, maybe can xmalloc? */\n\tcodetab = xzalloc(HSIZE * sizeof(codetab[0]));\n\n\tinsize = 0;\n\n\t/* xread isn't good here, we have to return - caller may want\n\t * to do some cleanup (e.g. delete incomplete unpacked file etc) */\n\tif (full_read(fd_in, inbuf, 1) != 1) {\n\t\tbb_error_msg(\"short read\");\n\t\tgoto err;\n\t}\n\n\tmaxbits = inbuf[0] & BIT_MASK;\n\tblock_mode = inbuf[0] & BLOCK_MODE;\n\tmaxmaxcode = MAXCODE(maxbits);\n\n\tif (maxbits > BITS) {\n\t\tbb_error_msg(\"compressed with %d bits, can only handle \"\n\t\t\t\tBITS_STR\" bits\", maxbits);\n\t\tgoto err;\n\t}\n\n\tn_bits = INIT_BITS;\n\tmaxcode = MAXCODE(INIT_BITS) - 1;\n\tbitmask = (1 << INIT_BITS) - 1;\n\toldcode = -1;\n\tfinchar = 0;\n\toutpos = 0;\n\tposbits = 0 << 3;\n\n\tfree_ent = ((block_mode) ? FIRST : 256);\n\n\t/* As above, initialize the first 256 entries in the table. */\n\t/*clear_tab_prefixof(); - done by xzalloc */\n\n\tfor (code = 255; code >= 0; --code) {\n\t\ttab_suffixof(code) = (unsigned char) code;\n\t}\n\n\tdo {\n resetbuf:\n\t\t{\n\t\t\tint i;\n\t\t\tint e;\n\t\t\tint o;\n\n\t\t\to = posbits >> 3;\n\t\t\te = insize - o;\n\n\t\t\tfor (i = 0; i < e; ++i)\n\t\t\t\tinbuf[i] = inbuf[i + o];\n\n\t\t\tinsize = e;\n\t\t\tposbits = 0;\n\t\t}\n\n\t\tif (insize < (int) (IBUFSIZ + 64) - IBUFSIZ) {\n\t\t\trsize = safe_read(fd_in, inbuf + insize, IBUFSIZ);\n//error check??\n\t\t\tinsize += rsize;\n\t\t}\n\n\t\tinbits = ((rsize > 0) ? (insize - insize % n_bits) << 3 :\n\t\t\t\t  (insize << 3) - (n_bits - 1));\n\n\t\twhile (inbits > posbits) {\n\t\t\tif (free_ent > maxcode) {\n\t\t\t\tposbits =\n\t\t\t\t\t((posbits - 1) +\n\t\t\t\t\t ((n_bits << 3) -\n\t\t\t\t\t  (posbits - 1 + (n_bits << 3)) % (n_bits << 3)));\n\t\t\t\t++n_bits;\n\t\t\t\tif (n_bits == maxbits) {\n\t\t\t\t\tmaxcode = maxmaxcode;\n\t\t\t\t} else {\n\t\t\t\t\tmaxcode = MAXCODE(n_bits) - 1;\n\t\t\t\t}\n\t\t\t\tbitmask = (1 << n_bits) - 1;\n\t\t\t\tgoto resetbuf;\n\t\t\t}\n\t\t\t{\n\t\t\t\tunsigned char *p = &inbuf[posbits >> 3];\n\n\t\t\t\tcode = ((((long) (p[0])) | ((long) (p[1]) << 8) |\n\t\t\t\t         ((long) (p[2]) << 16)) >> (posbits & 0x7)) & bitmask;\n\t\t\t}\n\t\t\tposbits += n_bits;\n\n\n\t\t\tif (oldcode == -1) {\n\t\t\t\toldcode = code;\n\t\t\t\tfinchar = (int) oldcode;\n\t\t\t\toutbuf[outpos++] = (unsigned char) finchar;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (code == CLEAR && block_mode) {\n\t\t\t\tclear_tab_prefixof();\n\t\t\t\tfree_ent = FIRST - 1;\n\t\t\t\tposbits =\n\t\t\t\t\t((posbits - 1) +\n\t\t\t\t\t ((n_bits << 3) -\n\t\t\t\t\t  (posbits - 1 + (n_bits << 3)) % (n_bits << 3)));\n\t\t\t\tn_bits = INIT_BITS;\n\t\t\t\tmaxcode = MAXCODE(INIT_BITS) - 1;\n\t\t\t\tbitmask = (1 << INIT_BITS) - 1;\n\t\t\t\tgoto resetbuf;\n\t\t\t}\n\n\t\t\tincode = code;\n\t\t\tstackp = de_stack;\n\n\t\t\t/* Special case for KwKwK string. */\n\t\t\tif (code >= free_ent) {\n\t\t\t\tif (code > free_ent) {\n\t\t\t\t\tunsigned char *p;\n\n\t\t\t\t\tposbits -= n_bits;\n\t\t\t\t\tp = &inbuf[posbits >> 3];\n\n\t\t\t\t\tbb_error_msg\n\t\t\t\t\t\t(\"insize:%d posbits:%d inbuf:%02X %02X %02X %02X %02X (%d)\",\n\t\t\t\t\t\t insize, posbits, p[-1], p[0], p[1], p[2], p[3],\n\t\t\t\t\t\t (posbits & 07));\n\t\t\t\t\tbb_error_msg(\"corrupted data\");\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\n\t\t\t\t*--stackp = (unsigned char) finchar;\n\t\t\t\tcode = oldcode;\n\t\t\t}\n\n\t\t\t/* Generate output characters in reverse order */\n\t\t\twhile ((long) code >= (long) 256) {\n\t\t\t\t*--stackp = tab_suffixof(code);\n\t\t\t\tcode = tab_prefixof(code);\n\t\t\t}\n\n\t\t\tfinchar = tab_suffixof(code);\n\t\t\t*--stackp = (unsigned char) finchar;\n\n\t\t\t/* And put them out in forward order */\n\t\t\t{\n\t\t\t\tint i;\n\n\t\t\t\ti = de_stack - stackp;\n\t\t\t\tif (outpos + i >= OBUFSIZ) {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (i > OBUFSIZ - outpos) {\n\t\t\t\t\t\t\ti = OBUFSIZ - outpos;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\t\tmemcpy(outbuf + outpos, stackp, i);\n\t\t\t\t\t\t\toutpos += i;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (outpos >= OBUFSIZ) {\n\t\t\t\t\t\t\tfull_write(fd_out, outbuf, outpos);\n//error check??\n\t\t\t\t\t\t\tIF_DESKTOP(total_written += outpos;)\n\t\t\t\t\t\t\toutpos = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstackp += i;\n\t\t\t\t\t\ti = de_stack - stackp;\n\t\t\t\t\t} while (i > 0);\n\t\t\t\t} else {\n\t\t\t\t\tmemcpy(outbuf + outpos, stackp, i);\n\t\t\t\t\toutpos += i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Generate the new entry. */\n\t\t\tcode = free_ent;\n\t\t\tif (code < maxmaxcode) {\n\t\t\t\ttab_prefixof(code) = (unsigned short) oldcode;\n\t\t\t\ttab_suffixof(code) = (unsigned char) finchar;\n\t\t\t\tfree_ent = code + 1;\n\t\t\t}\n\n\t\t\t/* Remember previous code.  */\n\t\t\toldcode = incode;\n\t\t}\n\n\t} while (rsize > 0);\n\n\tif (outpos > 0) {\n\t\tfull_write(fd_out, outbuf, outpos);\n//error check??\n\t\tIF_DESKTOP(total_written += outpos;)\n\t}\n\n\tretval = IF_DESKTOP(total_written) + 0;\n err:\n\tfree(inbuf);\n\tfree(outbuf);\n\tfree(htab);\n\tfree(codetab);\n\treturn retval;\n}",
        "target": 1
    },
    {
        "func": "static void cirrus_do_copy(CirrusVGAState *s, int dst, int src, int w, int h)\n{\n    int sx, sy;\n    int dx, dy;\n    int width, height;\n    int depth;\n    int notify = 0;\n\n    depth = s->get_bpp((VGAState *)s) / 8;\n    s->get_resolution((VGAState *)s, &width, &height);\n\n    /* extra x, y */\n    sx = (src % (width * depth)) / depth;\n    sy = (src / (width * depth));\n    dx = (dst % (width *depth)) / depth;\n    dy = (dst / (width * depth));\n\n    /* normalize width */\n    w /= depth;\n\n    /* if we're doing a backward copy, we have to adjust\n       our x/y to be the upper left corner (instead of the lower\n       right corner) */\n    if (s->cirrus_blt_dstpitch < 0) {\n\tsx -= (s->cirrus_blt_width / depth) - 1;\n\tdx -= (s->cirrus_blt_width / depth) - 1;\n\tsy -= s->cirrus_blt_height - 1;\n\tdy -= s->cirrus_blt_height - 1;\n    }\n\n    /* are we in the visible portion of memory? */\n    if (sx >= 0 && sy >= 0 && dx >= 0 && dy >= 0 &&\n\t(sx + w) <= width && (sy + h) <= height &&\n\t(dx + w) <= width && (dy + h) <= height) {\n\tnotify = 1;\n    }\n\n    /* make to sure only copy if it's a plain copy ROP */\n    if (*s->cirrus_rop != cirrus_bitblt_rop_fwd_src &&\n\t*s->cirrus_rop != cirrus_bitblt_rop_bkwd_src)\n\tnotify = 0;\n\n    /* we have to flush all pending changes so that the copy\n       is generated at the appropriate moment in time */\n    if (notify)\n\tvga_hw_update();\n\n    (*s->cirrus_rop) (s, s->vram_ptr + s->cirrus_blt_dstaddr,\n\t\t      s->vram_ptr + s->cirrus_blt_srcaddr,\n\t\t      s->cirrus_blt_dstpitch, s->cirrus_blt_srcpitch,\n\t\t      s->cirrus_blt_width, s->cirrus_blt_height);\n\n    if (notify)\n\ts->ds->dpy_copy(s->ds,\n\t\t\tsx, sy, dx, dy,\n\t\t\ts->cirrus_blt_width / depth,\n\t\t\ts->cirrus_blt_height);\n\n    /* we don't have to notify the display that this portion has\n       changed since dpy_copy implies this */\n\n    if (!notify)\n\tcirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n\t\t\t\t s->cirrus_blt_dstpitch, s->cirrus_blt_width,\n\t\t\t\t s->cirrus_blt_height);\n}",
        "target": 1
    },
    {
        "func": "glue(cirrus_bitblt_rop_fwd_, ROP_NAME)(CirrusVGAState *s,\n                             uint8_t *dst,const uint8_t *src,\n                             int dstpitch,int srcpitch,\n                             int bltwidth,int bltheight)\n{\n    int x,y;\n    dstpitch -= bltwidth;\n    srcpitch -= bltwidth;\n    for (y = 0; y < bltheight; y++) {\n        for (x = 0; x < bltwidth; x++) {\n            ROP_OP(*dst, *src);\n            dst++;\n            src++;\n        }\n        dst += dstpitch;\n        src += srcpitch;\n    }\n}",
        "target": 1
    },
    {
        "func": "static int cirrus_bitblt_videotovideo_copy(CirrusVGAState * s)\n{\n    if (s->ds->dpy_copy) {\n\tcirrus_do_copy(s, s->cirrus_blt_dstaddr - s->start_addr,\n\t\t       s->cirrus_blt_srcaddr - s->start_addr,\n\t\t       s->cirrus_blt_width, s->cirrus_blt_height);\n    } else {\n\t(*s->cirrus_rop) (s, s->vram_ptr + s->cirrus_blt_dstaddr,\n\t\t\t  s->vram_ptr + s->cirrus_blt_srcaddr,\n\t\t\t  s->cirrus_blt_dstpitch, s->cirrus_blt_srcpitch,\n\t\t\t  s->cirrus_blt_width, s->cirrus_blt_height);\n\n\tcirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n\t\t\t\t s->cirrus_blt_dstpitch, s->cirrus_blt_width,\n\t\t\t\t s->cirrus_blt_height);\n    }\n\n    return 1;\n}",
        "target": 1
    },
    {
        "func": "static void cirrus_mem_writeb_mode4and5_8bpp(CirrusVGAState * s,\n\t\t\t\t\t     unsigned mode,\n\t\t\t\t\t     unsigned offset,\n\t\t\t\t\t     uint32_t mem_value)\n{\n    int x;\n    unsigned val = mem_value;\n    uint8_t *dst;\n\n    dst = s->vram_ptr + offset;\n    for (x = 0; x < 8; x++) {\n\tif (val & 0x80) {\n\t    *dst = s->cirrus_shadow_gr1;\n\t} else if (mode == 5) {\n\t    *dst = s->cirrus_shadow_gr0;\n\t}\n\tval <<= 1;\n\tdst++;\n    }\n    cpu_physical_memory_set_dirty(s->vram_offset + offset);\n    cpu_physical_memory_set_dirty(s->vram_offset + offset + 7);\n}",
        "target": 1
    },
    {
        "func": "static int cirrus_bitblt_common_patterncopy(CirrusVGAState * s,\n\t\t\t\t\t    const uint8_t * src)\n{\n    uint8_t *dst;\n\n    dst = s->vram_ptr + s->cirrus_blt_dstaddr;\n    (*s->cirrus_rop) (s, dst, src,\n                      s->cirrus_blt_dstpitch, 0,\n                      s->cirrus_blt_width, s->cirrus_blt_height);\n    cirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n                             s->cirrus_blt_dstpitch, s->cirrus_blt_width,\n                             s->cirrus_blt_height);\n    return 1;\n}",
        "target": 1
    },
    {
        "func": "static void cirrus_invalidate_region(CirrusVGAState * s, int off_begin,\n\t\t\t\t     int off_pitch, int bytesperline,\n\t\t\t\t     int lines)\n{\n    int y;\n    int off_cur;\n    int off_cur_end;\n\n    for (y = 0; y < lines; y++) {\n\toff_cur = off_begin;\n\toff_cur_end = off_cur + bytesperline;\n\toff_cur &= TARGET_PAGE_MASK;\n\twhile (off_cur < off_cur_end) {\n\t    cpu_physical_memory_set_dirty(s->vram_offset + off_cur);\n\t    off_cur += TARGET_PAGE_SIZE;\n\t}\n\toff_begin += off_pitch;\n    }\n}",
        "target": 1
    },
    {
        "func": "static int cirrus_bitblt_videotovideo_patterncopy(CirrusVGAState * s)\n{\n    return cirrus_bitblt_common_patterncopy(s,\n\t\t\t\t\t    s->vram_ptr +\n                                            (s->cirrus_blt_srcaddr & ~7));\n}",
        "target": 1
    },
    {
        "func": "static int cirrus_bitblt_solidfill(CirrusVGAState *s, int blt_rop)\n{\n    cirrus_fill_t rop_func;\n\n    rop_func = cirrus_fill[rop_to_index[blt_rop]][s->cirrus_blt_pixelwidth - 1];\n    rop_func(s, s->vram_ptr + s->cirrus_blt_dstaddr,\n             s->cirrus_blt_dstpitch,\n             s->cirrus_blt_width, s->cirrus_blt_height);\n    cirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n\t\t\t     s->cirrus_blt_dstpitch, s->cirrus_blt_width,\n\t\t\t     s->cirrus_blt_height);\n    cirrus_bitblt_reset(s);\n    return 1;\n}",
        "target": 1
    },
    {
        "func": "static void cirrus_bitblt_cputovideo_next(CirrusVGAState * s)\n{\n    int copy_count;\n    uint8_t *end_ptr;\n\n    if (s->cirrus_srccounter > 0) {\n        if (s->cirrus_blt_mode & CIRRUS_BLTMODE_PATTERNCOPY) {\n            cirrus_bitblt_common_patterncopy(s, s->cirrus_bltbuf);\n        the_end:\n            s->cirrus_srccounter = 0;\n            cirrus_bitblt_reset(s);\n        } else {\n            /* at least one scan line */\n            do {\n                (*s->cirrus_rop)(s, s->vram_ptr + s->cirrus_blt_dstaddr,\n                                 s->cirrus_bltbuf, 0, 0, s->cirrus_blt_width, 1);\n                cirrus_invalidate_region(s, s->cirrus_blt_dstaddr, 0,\n                                         s->cirrus_blt_width, 1);\n                s->cirrus_blt_dstaddr += s->cirrus_blt_dstpitch;\n                s->cirrus_srccounter -= s->cirrus_blt_srcpitch;\n                if (s->cirrus_srccounter <= 0)\n                    goto the_end;\n                /* more bytes than needed can be transfered because of\n                   word alignment, so we keep them for the next line */\n                /* XXX: keep alignment to speed up transfer */\n                end_ptr = s->cirrus_bltbuf + s->cirrus_blt_srcpitch;\n                copy_count = s->cirrus_srcptr_end - end_ptr;\n                memmove(s->cirrus_bltbuf, end_ptr, copy_count);\n                s->cirrus_srcptr = s->cirrus_bltbuf + copy_count;\n                s->cirrus_srcptr_end = s->cirrus_bltbuf + s->cirrus_blt_srcpitch;\n            } while (s->cirrus_srcptr >= s->cirrus_srcptr_end);\n        }\n    }\n}",
        "target": 1
    },
    {
        "func": "static void cirrus_mem_writeb_mode4and5_16bpp(CirrusVGAState * s,\n\t\t\t\t\t      unsigned mode,\n\t\t\t\t\t      unsigned offset,\n\t\t\t\t\t      uint32_t mem_value)\n{\n    int x;\n    unsigned val = mem_value;\n    uint8_t *dst;\n\n    dst = s->vram_ptr + offset;\n    for (x = 0; x < 8; x++) {\n\tif (val & 0x80) {\n\t    *dst = s->cirrus_shadow_gr1;\n\t    *(dst + 1) = s->gr[0x11];\n\t} else if (mode == 5) {\n\t    *dst = s->cirrus_shadow_gr0;\n\t    *(dst + 1) = s->gr[0x10];\n\t}\n\tval <<= 1;\n\tdst += 2;\n    }\n    cpu_physical_memory_set_dirty(s->vram_offset + offset);\n    cpu_physical_memory_set_dirty(s->vram_offset + offset + 15);\n}",
        "target": 1
    },
    {
        "func": "static int cirrus_bitblt_videotovideo_copy(CirrusVGAState * s)\n{\n    if (s->ds->dpy_copy) {\n\tcirrus_do_copy(s, s->cirrus_blt_dstaddr - s->start_addr,\n\t\t       s->cirrus_blt_srcaddr - s->start_addr,\n\t\t       s->cirrus_blt_width, s->cirrus_blt_height);\n    } else {\n\n    if (BLTUNSAFE(s))\n        return 0;\n\n\t(*s->cirrus_rop) (s, s->vram_ptr +\n                (s->cirrus_blt_dstaddr & s->cirrus_addr_mask),\n\t\t\t  s->vram_ptr +\n                (s->cirrus_blt_srcaddr & s->cirrus_addr_mask),\n\t\t\t  s->cirrus_blt_dstpitch, s->cirrus_blt_srcpitch,\n\t\t\t  s->cirrus_blt_width, s->cirrus_blt_height);\n\n\tcirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n\t\t\t\t s->cirrus_blt_dstpitch, s->cirrus_blt_width,\n\t\t\t\t s->cirrus_blt_height);\n    }\n\n    return 1;\n}",
        "target": 1
    },
    {
        "func": "asmlinkage long compat_sys_mount(char __user * dev_name, char __user * dir_name,\n\t\t\t\t char __user * type, unsigned long flags,\n\t\t\t\t void __user * data)\n{\n\tunsigned long type_page;\n\tunsigned long data_page;\n\tunsigned long dev_page;\n\tchar *dir_page;\n\tint retval;\n\n\tretval = copy_mount_options (type, &type_page);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tdir_page = getname(dir_name);\n\tretval = PTR_ERR(dir_page);\n\tif (IS_ERR(dir_page))\n\t\tgoto out1;\n\n\tretval = copy_mount_options (dev_name, &dev_page);\n\tif (retval < 0)\n\t\tgoto out2;\n\n\tretval = copy_mount_options (data, &data_page);\n\tif (retval < 0)\n\t\tgoto out3;\n\n\tretval = -EINVAL;\n\n\tif (type_page) {\n\t\tif (!strcmp((char *)type_page, SMBFS_NAME)) {\n\t\t\tdo_smb_super_data_conv((void *)data_page);\n\t\t} else if (!strcmp((char *)type_page, NCPFS_NAME)) {\n\t\t\tdo_ncp_super_data_conv((void *)data_page);\n\t\t} else if (!strcmp((char *)type_page, NFS4_NAME)) {\n\t\t\tif (do_nfs4_super_data_conv((void *) data_page))\n\t\t\t\tgoto out4;\n\t\t}\n\t}\n\n\tlock_kernel();\n\tretval = do_mount((char*)dev_page, dir_page, (char*)type_page,\n\t\t\tflags, (void*)data_page);\n\tunlock_kernel();\n\n out4:\n\tfree_page(data_page);\n out3:\n\tfree_page(dev_page);\n out2:\n\tputname(dir_page);\n out1:\n\tfree_page(type_page);\n out:\n\treturn retval;\n}",
        "target": 1
    },
    {
        "func": "unsigned short atalk_checksum(struct ddpehdr *ddp, int len)\n{\n\tunsigned long sum = 0;\t/* Assume unsigned long is >16 bits */\n\tunsigned char *data = (unsigned char *)ddp;\n\n\tlen  -= 4;\t\t/* skip header 4 bytes */\n\tdata += 4;\n\n\t/* This ought to be unwrapped neatly. I'll trust gcc for now */\n\twhile (len--) {\n\t\tsum += *data;\n\t\tsum <<= 1;\n\t\tif (sum & 0x10000) {\n\t\t\tsum++;\n\t\t\tsum &= 0xFFFF;\n\t\t}\n\t\tdata++;\n\t}\n\t/* Use 0xFFFF for 0. 0 itself means none */\n\treturn sum ? htons((unsigned short)sum) : 0xFFFF;\n}",
        "target": 1
    },
    {
        "func": "static int ltalk_rcv(struct sk_buff *skb, struct net_device *dev,\n\t\t\tstruct packet_type *pt)\n{\n\t/* Expand any short form frames */\n\tif (skb->mac.raw[2] == 1) {\n\t\tstruct ddpehdr *ddp;\n\t\t/* Find our address */\n\t\tstruct atalk_addr *ap = atalk_find_dev_addr(dev);\n\n\t\tif (!ap || skb->len < sizeof(struct ddpshdr))\n\t\t\tgoto freeit;\n\t\t/*\n\t\t * The push leaves us with a ddephdr not an shdr, and\n\t\t * handily the port bytes in the right place preset.\n\t\t */\n\n\t\tskb_push(skb, sizeof(*ddp) - 4);\n\t\t/* FIXME: use skb->cb to be able to use shared skbs */\n\t\tddp = (struct ddpehdr *)skb->data;\n\n\t\t/* Now fill in the long header */\n\n\t \t/*\n\t \t * These two first. The mac overlays the new source/dest\n\t \t * network information so we MUST copy these before\n\t \t * we write the network numbers !\n\t \t */\n\n\t\tddp->deh_dnode = skb->mac.raw[0];     /* From physical header */\n\t\tddp->deh_snode = skb->mac.raw[1];     /* From physical header */\n\n\t\tddp->deh_dnet  = ap->s_net;\t/* Network number */\n\t\tddp->deh_snet  = ap->s_net;\n\t\tddp->deh_sum   = 0;\t\t/* No checksum */\n\t\t/*\n\t\t * Not sure about this bit...\n\t\t */\n\t\tddp->deh_len   = skb->len;\n\t\tddp->deh_hops  = DDP_MAXHOPS;\t/* Non routable, so force a drop\n\t\t\t\t\t\t   if we slip up later */\n\t\t/* Mend the byte order */\n\t\t*((__u16 *)ddp) = htons(*((__u16 *)ddp));\n\t}\n\tskb->h.raw = skb->data;\n\n\treturn atalk_rcv(skb, dev, pt);\nfreeit:\n\tkfree_skb(skb);\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static int atalk_rcv(struct sk_buff *skb, struct net_device *dev,\n\t\t     struct packet_type *pt)\n{\n\tstruct ddpehdr *ddp = ddp_hdr(skb);\n\tstruct sock *sock;\n\tstruct atalk_iface *atif;\n\tstruct sockaddr_at tosat;\n        int origlen;\n        struct ddpebits ddphv;\n\n\t/* Size check */\n\tif (skb->len < sizeof(*ddp))\n\t\tgoto freeit;\n\n\t/*\n\t *\tFix up the length field\t[Ok this is horrible but otherwise\n\t *\tI end up with unions of bit fields and messy bit field order\n\t *\tcompiler/endian dependencies..]\n\t *\n\t *\tFIXME: This is a write to a shared object. Granted it\n\t *\thappens to be safe BUT.. (Its safe as user space will not\n\t *\trun until we put it back)\n\t */\n\t*((__u16 *)&ddphv) = ntohs(*((__u16 *)ddp));\n\n\t/* Trim buffer in case of stray trailing data */\n\toriglen = skb->len;\n\tskb_trim(skb, min_t(unsigned int, skb->len, ddphv.deh_len));\n\n\t/*\n\t * Size check to see if ddp->deh_len was crap\n\t * (Otherwise we'll detonate most spectacularly\n\t * in the middle of recvmsg()).\n\t */\n\tif (skb->len < sizeof(*ddp))\n\t\tgoto freeit;\n\n\t/*\n\t * Any checksums. Note we don't do htons() on this == is assumed to be\n\t * valid for net byte orders all over the networking code...\n\t */\n\tif (ddp->deh_sum &&\n\t    atalk_checksum(ddp, ddphv.deh_len) != ddp->deh_sum)\n\t\t/* Not a valid AppleTalk frame - dustbin time */\n\t\tgoto freeit;\n\n\t/* Check the packet is aimed at us */\n\tif (!ddp->deh_dnet)\t/* Net 0 is 'this network' */\n\t\tatif = atalk_find_anynet(ddp->deh_dnode, dev);\n\telse\n\t\tatif = atalk_find_interface(ddp->deh_dnet, ddp->deh_dnode);\n\n\t/* Not ours, so we route the packet via the correct AppleTalk iface */\n\tif (!atif) {\n\t\tatalk_route_packet(skb, dev, ddp, &ddphv, origlen);\n\t\tgoto out;\n\t}\n\n\t/* if IP over DDP is not selected this code will be optimized out */\n\tif (is_ip_over_ddp(skb))\n\t\treturn handle_ip_over_ddp(skb);\n\t/*\n\t * Which socket - atalk_search_socket() looks for a *full match*\n\t * of the <net, node, port> tuple.\n\t */\n\ttosat.sat_addr.s_net  = ddp->deh_dnet;\n\ttosat.sat_addr.s_node = ddp->deh_dnode;\n\ttosat.sat_port\t      = ddp->deh_dport;\n\n\tsock = atalk_search_socket(&tosat, atif);\n\tif (!sock) /* But not one of our sockets */\n\t\tgoto freeit;\n\n\t/* Queue packet (standard) */\n\tskb->sk = sock;\n\n\tif (sock_queue_rcv_skb(sock, skb) < 0)\n\t\tgoto freeit;\nout:\n\treturn 0;\nfreeit:\n\tkfree_skb(skb);\n\tgoto out;\n}",
        "target": 1
    },
    {
        "func": "static int atalk_sendmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,\n\t\t\t int len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct atalk_sock *at = at_sk(sk);\n\tstruct sockaddr_at *usat = (struct sockaddr_at *)msg->msg_name;\n\tint flags = msg->msg_flags;\n\tint loopback = 0;\n\tstruct sockaddr_at local_satalk, gsat;\n\tstruct sk_buff *skb;\n\tstruct net_device *dev;\n\tstruct ddpehdr *ddp;\n\tint size;\n\tstruct atalk_route *rt;\n\tint err;\n\n\tif (flags & ~MSG_DONTWAIT)\n\t\treturn -EINVAL;\n\n\tif (len > DDP_MAXSZ)\n\t\treturn -EMSGSIZE;\n\n\tif (usat) {\n\t\tif (sk->sk_zapped)\n\t\t\tif (atalk_autobind(sk) < 0)\n\t\t\t\treturn -EBUSY;\n\n\t\tif (msg->msg_namelen < sizeof(*usat) ||\n\t\t    usat->sat_family != AF_APPLETALK)\n\t\t\treturn -EINVAL;\n\n\t\t/* netatalk doesn't implement this check */\n\t\tif (usat->sat_addr.s_node == ATADDR_BCAST &&\n\t\t    !sock_flag(sk, SOCK_BROADCAST)) {\n\t\t\tprintk(KERN_INFO \"SO_BROADCAST: Fix your netatalk as \"\n\t\t\t\t\t \"it will break before 2.2\\n\");\n#if 0\n\t\t\treturn -EPERM;\n#endif\n\t\t}\n\t} else {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -ENOTCONN;\n\t\tusat = &local_satalk;\n\t\tusat->sat_family      = AF_APPLETALK;\n\t\tusat->sat_port\t      = at->dest_port;\n\t\tusat->sat_addr.s_node = at->dest_node;\n\t\tusat->sat_addr.s_net  = at->dest_net;\n\t}\n\n\t/* Build a packet */\n\tSOCK_DEBUG(sk, \"SK %p: Got address.\\n\", sk);\n\n\t/* For headers */\n\tsize = sizeof(struct ddpehdr) + len + ddp_dl->header_length;\n\n\tif (usat->sat_addr.s_net || usat->sat_addr.s_node == ATADDR_ANYNODE) {\n\t\trt = atrtr_find(&usat->sat_addr);\n\t\tif (!rt)\n\t\t\treturn -ENETUNREACH;\n\n\t\tdev = rt->dev;\n\t} else {\n\t\tstruct atalk_addr at_hint;\n\n\t\tat_hint.s_node = 0;\n\t\tat_hint.s_net  = at->src_net;\n\n\t\trt = atrtr_find(&at_hint);\n\t\tif (!rt)\n\t\t\treturn -ENETUNREACH;\n\n\t\tdev = rt->dev;\n\t}\n\n\tSOCK_DEBUG(sk, \"SK %p: Size needed %d, device %s\\n\",\n\t\t\tsk, size, dev->name);\n\n\tsize += dev->hard_header_len;\n\tskb = sock_alloc_send_skb(sk, size, (flags & MSG_DONTWAIT), &err);\n\tif (!skb)\n\t\treturn err;\n\t\n\tskb->sk = sk;\n\tskb_reserve(skb, ddp_dl->header_length);\n\tskb_reserve(skb, dev->hard_header_len);\n\tskb->dev = dev;\n\n\tSOCK_DEBUG(sk, \"SK %p: Begin build.\\n\", sk);\n\n\tddp = (struct ddpehdr *)skb_put(skb, sizeof(struct ddpehdr));\n\tddp->deh_pad  = 0;\n\tddp->deh_hops = 0;\n\tddp->deh_len  = len + sizeof(*ddp);\n\t/*\n\t * Fix up the length field [Ok this is horrible but otherwise\n\t * I end up with unions of bit fields and messy bit field order\n\t * compiler/endian dependencies..\n\t */\n\t*((__u16 *)ddp) = ntohs(*((__u16 *)ddp));\n\n\tddp->deh_dnet  = usat->sat_addr.s_net;\n\tddp->deh_snet  = at->src_net;\n\tddp->deh_dnode = usat->sat_addr.s_node;\n\tddp->deh_snode = at->src_node;\n\tddp->deh_dport = usat->sat_port;\n\tddp->deh_sport = at->src_port;\n\n\tSOCK_DEBUG(sk, \"SK %p: Copy user data (%d bytes).\\n\", sk, len);\n\n\terr = memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len);\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\treturn -EFAULT;\n\t}\n\n\tif (sk->sk_no_check == 1)\n\t\tddp->deh_sum = 0;\n\telse\n\t\tddp->deh_sum = atalk_checksum(ddp, len + sizeof(*ddp));\n\n\t/*\n\t * Loopback broadcast packets to non gateway targets (ie routes\n\t * to group we are in)\n\t */\n\tif (ddp->deh_dnode == ATADDR_BCAST &&\n\t    !(rt->flags & RTF_GATEWAY) && !(dev->flags & IFF_LOOPBACK)) {\n\t\tstruct sk_buff *skb2 = skb_copy(skb, GFP_KERNEL);\n\n\t\tif (skb2) {\n\t\t\tloopback = 1;\n\t\t\tSOCK_DEBUG(sk, \"SK %p: send out(copy).\\n\", sk);\n\t\t\tif (aarp_send_ddp(dev, skb2,\n\t\t\t\t\t  &usat->sat_addr, NULL) == -1)\n\t\t\t\tkfree_skb(skb2);\n\t\t\t\t/* else queued/sent above in the aarp queue */\n\t\t}\n\t}\n\n\tif (dev->flags & IFF_LOOPBACK || loopback) {\n\t\tSOCK_DEBUG(sk, \"SK %p: Loop back.\\n\", sk);\n\t\t/* loop back */\n\t\tskb_orphan(skb);\n\t\tddp_dl->request(ddp_dl, skb, dev->dev_addr);\n\t} else {\n\t\tSOCK_DEBUG(sk, \"SK %p: send out.\\n\", sk);\n\t\tif (rt->flags & RTF_GATEWAY) {\n\t\t    gsat.sat_addr = rt->gateway;\n\t\t    usat = &gsat;\n\t\t}\n\n\t\tif (aarp_send_ddp(dev, skb, &usat->sat_addr, NULL) == -1)\n\t\t\tkfree_skb(skb);\n\t\t/* else queued/sent above in the aarp queue */\n\t}\n\tSOCK_DEBUG(sk, \"SK %p: Done write (%d).\\n\", sk, len);\n\n\treturn len;\n}",
        "target": 1
    },
    {
        "func": "static int fat_ioctl_filldir(void *__buf, const char *name, int name_len,\n\t\t\t     loff_t offset, u64 ino, unsigned int d_type)\n{\n\tstruct fat_ioctl_filldir_callback *buf = __buf;\n\tstruct dirent __user *d1 = buf->dirent;\n\tstruct dirent __user *d2 = d1 + 1;\n\n\tif (buf->result)\n\t\treturn -EINVAL;\n\tbuf->result++;\n\n\tif (name != NULL) {\n\t\t/* dirent has only short name */\n\t\tif (name_len >= sizeof(d1->d_name))\n\t\t\tname_len = sizeof(d1->d_name) - 1;\n\n\t\tif (put_user(0, d2->d_name)\t\t\t||\n\t\t    put_user(0, &d2->d_reclen)\t\t\t||\n\t\t    copy_to_user(d1->d_name, name, name_len)\t||\n\t\t    put_user(0, d1->d_name + name_len)\t\t||\n\t\t    put_user(name_len, &d1->d_reclen))\n\t\t\tgoto efault;\n\t} else {\n\t\t/* dirent has short and long name */\n\t\tconst char *longname = buf->longname;\n\t\tint long_len = buf->long_len;\n\t\tconst char *shortname = buf->shortname;\n\t\tint short_len = buf->short_len;\n\n\t\tif (long_len >= sizeof(d1->d_name))\n\t\t\tlong_len = sizeof(d1->d_name) - 1;\n\t\tif (short_len >= sizeof(d1->d_name))\n\t\t\tshort_len = sizeof(d1->d_name) - 1;\n\n\t\tif (copy_to_user(d2->d_name, longname, long_len)\t||\n\t\t    put_user(0, d2->d_name + long_len)\t\t\t||\n\t\t    put_user(long_len, &d2->d_reclen)\t\t\t||\n\t\t    put_user(ino, &d2->d_ino)\t\t\t\t||\n\t\t    put_user(offset, &d2->d_off)\t\t\t||\n\t\t    copy_to_user(d1->d_name, shortname, short_len)\t||\n\t\t    put_user(0, d1->d_name + short_len)\t\t\t||\n\t\t    put_user(short_len, &d1->d_reclen))\n\t\t\tgoto efault;\n\t}\n\treturn 0;\nefault:\n\tbuf->result = -EFAULT;\n\treturn -EFAULT;\n}",
        "target": 1
    },
    {
        "func": "static int fat_dir_ioctl(struct inode * inode, struct file * filp,\n\t\t  unsigned int cmd, unsigned long arg)\n{\n\tstruct fat_ioctl_filldir_callback buf;\n\tstruct dirent __user *d1;\n\tint ret, short_only, both;\n\n\tswitch (cmd) {\n\tcase VFAT_IOCTL_READDIR_SHORT:\n\t\tshort_only = 1;\n\t\tboth = 0;\n\t\tbreak;\n\tcase VFAT_IOCTL_READDIR_BOTH:\n\t\tshort_only = 0;\n\t\tboth = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn fat_generic_ioctl(inode, filp, cmd, arg);\n\t}\n\n\td1 = (struct dirent __user *)arg;\n\tif (!access_ok(VERIFY_WRITE, d1, sizeof(struct dirent[2])))\n\t\treturn -EFAULT;\n\t/*\n\t * Yes, we don't need this put_user() absolutely. However old\n\t * code didn't return the right value. So, app use this value,\n\t * in order to check whether it is EOF.\n\t */\n\tif (put_user(0, &d1->d_reclen))\n\t\treturn -EFAULT;\n\n\tbuf.dirent = d1;\n\tbuf.result = 0;\n\tmutex_lock(&inode->i_mutex);\n\tret = -ENOENT;\n\tif (!IS_DEADDIR(inode)) {\n\t\tret = __fat_readdir(inode, filp, &buf, fat_ioctl_filldir,\n\t\t\t\t    short_only, both);\n\t}\n\tmutex_unlock(&inode->i_mutex);\n\tif (ret >= 0)\n\t\tret = buf.result;\n\treturn ret;\n}",
        "target": 1
    },
    {
        "func": "static long fat_compat_dir_ioctl(struct file *file, unsigned cmd,\n\t\t\t\t unsigned long arg)\n{\n\tstruct compat_dirent __user *p = compat_ptr(arg);\n\tint ret;\n\tmm_segment_t oldfs = get_fs();\n\tstruct dirent d[2];\n\n\tswitch (cmd) {\n\tcase VFAT_IOCTL_READDIR_BOTH32:\n\t\tcmd = VFAT_IOCTL_READDIR_BOTH;\n\t\tbreak;\n\tcase VFAT_IOCTL_READDIR_SHORT32:\n\t\tcmd = VFAT_IOCTL_READDIR_SHORT;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\n\tset_fs(KERNEL_DS);\n\tlock_kernel();\n\tret = fat_dir_ioctl(file->f_path.dentry->d_inode, file,\n\t\t\t    cmd, (unsigned long) &d);\n\tunlock_kernel();\n\tset_fs(oldfs);\n\tif (ret >= 0) {\n\t\tret |= fat_compat_put_dirent32(&d[0], p);\n\t\tret |= fat_compat_put_dirent32(&d[1], p + 1);\n\t}\n\treturn ret;\n}",
        "target": 1
    },
    {
        "func": "static long fat_compat_put_dirent32(struct dirent *d,\n\t\t\t\t    struct compat_dirent __user *d32)\n{\n        if (!access_ok(VERIFY_WRITE, d32, sizeof(struct compat_dirent)))\n                return -EFAULT;\n\n        __put_user(d->d_ino, &d32->d_ino);\n        __put_user(d->d_off, &d32->d_off);\n        __put_user(d->d_reclen, &d32->d_reclen);\n        if (__copy_to_user(d32->d_name, d->d_name, d->d_reclen))\n\t\treturn -EFAULT;\n\n        return 0;\n}",
        "target": 1
    },
    {
        "func": "static int vfat_ioctl32(unsigned fd, unsigned cmd, unsigned long arg)\n{\n\tstruct compat_dirent __user *p = compat_ptr(arg);\n\tint ret;\n\tmm_segment_t oldfs = get_fs();\n\tstruct dirent d[2];\n\n\tswitch(cmd)\n\t{\n        \tcase VFAT_IOCTL_READDIR_BOTH32:\n                \tcmd = VFAT_IOCTL_READDIR_BOTH;\n                \tbreak;\n        \tcase VFAT_IOCTL_READDIR_SHORT32:\n                \tcmd = VFAT_IOCTL_READDIR_SHORT;\n                \tbreak;\n\t}\n\n\tset_fs(KERNEL_DS);\n\tret = sys_ioctl(fd,cmd,(unsigned long)&d);\n\tset_fs(oldfs);\n\tif (ret >= 0) {\n\t\tret |= put_dirent32(&d[0], p);\n\t\tret |= put_dirent32(&d[1], p + 1);\n\t}\n\treturn ret;\n}",
        "target": 1
    },
    {
        "func": "put_dirent32 (struct dirent *d, struct compat_dirent __user *d32)\n{\n        if (!access_ok(VERIFY_WRITE, d32, sizeof(struct compat_dirent)))\n                return -EFAULT;\n\n        __put_user(d->d_ino, &d32->d_ino);\n        __put_user(d->d_off, &d32->d_off);\n        __put_user(d->d_reclen, &d32->d_reclen);\n        if (__copy_to_user(d32->d_name, d->d_name, d->d_reclen))\n\t\treturn -EFAULT;\n\n        return 0;\n}",
        "target": 1
    },
    {
        "func": "unsigned long convert_rip_to_linear(struct task_struct *child, struct pt_regs *regs)\n{\n\tunsigned long addr, seg;\n\n\taddr = regs->rip;\n\tseg = regs->cs & 0xffff;\n\n\t/*\n\t * We'll assume that the code segments in the GDT\n\t * are all zero-based. That is largely true: the\n\t * TLS segments are used for data, and the PNPBIOS\n\t * and APM bios ones we just ignore here.\n\t */\n\tif (seg & LDT_SEGMENT) {\n\t\tu32 *desc;\n\t\tunsigned long base;\n\n\t\tdown(&child->mm->context.sem);\n\t\tdesc = child->mm->context.ldt + (seg & ~7);\n\t\tbase = (desc[0] >> 16) | ((desc[1] & 0xff) << 16) | (desc[1] & 0xff000000);\n\n\t\t/* 16-bit code segment? */\n\t\tif (!((desc[1] >> 22) & 1))\n\t\t\taddr &= 0xffff;\n\t\taddr += base;\n\t\tup(&child->mm->context.sem);\n\t}\n\treturn addr;\n}",
        "target": 1
    },
    {
        "func": "static unsigned long convert_eip_to_linear(struct task_struct *child, struct pt_regs *regs)\n{\n\tunsigned long addr, seg;\n\n\taddr = regs->eip;\n\tseg = regs->xcs & 0xffff;\n\tif (regs->eflags & VM_MASK) {\n\t\taddr = (addr & 0xffff) + (seg << 4);\n\t\treturn addr;\n\t}\n\n\t/*\n\t * We'll assume that the code segments in the GDT\n\t * are all zero-based. That is largely true: the\n\t * TLS segments are used for data, and the PNPBIOS\n\t * and APM bios ones we just ignore here.\n\t */\n\tif (seg & LDT_SEGMENT) {\n\t\tu32 *desc;\n\t\tunsigned long base;\n\n\t\tdown(&child->mm->context.sem);\n\t\tdesc = child->mm->context.ldt + (seg & ~7);\n\t\tbase = (desc[0] >> 16) | ((desc[1] & 0xff) << 16) | (desc[1] & 0xff000000);\n\n\t\t/* 16-bit code segment? */\n\t\tif (!((desc[1] >> 22) & 1))\n\t\t\taddr &= 0xffff;\n\t\taddr += base;\n\t\tup(&child->mm->context.sem);\n\t}\n\treturn addr;\n}",
        "target": 1
    },
    {
        "func": "pfm_smpl_buffer_alloc(struct task_struct *task, pfm_context_t *ctx, unsigned long rsize, void **user_vaddr)\n{\n\tstruct mm_struct *mm = task->mm;\n\tstruct vm_area_struct *vma = NULL;\n\tunsigned long size;\n\tvoid *smpl_buf;\n\n\n\t/*\n\t * the fixed header + requested size and align to page boundary\n\t */\n\tsize = PAGE_ALIGN(rsize);\n\n\tDPRINT((\"sampling buffer rsize=%lu size=%lu bytes\\n\", rsize, size));\n\n\t/*\n\t * check requested size to avoid Denial-of-service attacks\n\t * XXX: may have to refine this test\n\t * Check against address space limit.\n\t *\n\t * if ((mm->total_vm << PAGE_SHIFT) + len> task->rlim[RLIMIT_AS].rlim_cur)\n\t * \treturn -ENOMEM;\n\t */\n\tif (size > task->signal->rlim[RLIMIT_MEMLOCK].rlim_cur)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * We do the easy to undo allocations first.\n \t *\n\t * pfm_rvmalloc(), clears the buffer, so there is no leak\n\t */\n\tsmpl_buf = pfm_rvmalloc(size);\n\tif (smpl_buf == NULL) {\n\t\tDPRINT((\"Can't allocate sampling buffer\\n\"));\n\t\treturn -ENOMEM;\n\t}\n\n\tDPRINT((\"smpl_buf @%p\\n\", smpl_buf));\n\n\t/* allocate vma */\n\tvma = kmem_cache_zalloc(vm_area_cachep, GFP_KERNEL);\n\tif (!vma) {\n\t\tDPRINT((\"Cannot allocate vma\\n\"));\n\t\tgoto error_kmem;\n\t}\n\n\t/*\n\t * partially initialize the vma for the sampling buffer\n\t */\n\tvma->vm_mm\t     = mm;\n\tvma->vm_flags\t     = VM_READ| VM_MAYREAD |VM_RESERVED;\n\tvma->vm_page_prot    = PAGE_READONLY; /* XXX may need to change */\n\n\t/*\n\t * Now we have everything we need and we can initialize\n\t * and connect all the data structures\n\t */\n\n\tctx->ctx_smpl_hdr   = smpl_buf;\n\tctx->ctx_smpl_size  = size; /* aligned size */\n\n\t/*\n\t * Let's do the difficult operations next.\n\t *\n\t * now we atomically find some area in the address space and\n\t * remap the buffer in it.\n\t */\n\tdown_write(&task->mm->mmap_sem);\n\n\t/* find some free area in address space, must have mmap sem held */\n\tvma->vm_start = pfm_get_unmapped_area(NULL, 0, size, 0, MAP_PRIVATE|MAP_ANONYMOUS, 0);\n\tif (vma->vm_start == 0UL) {\n\t\tDPRINT((\"Cannot find unmapped area for size %ld\\n\", size));\n\t\tup_write(&task->mm->mmap_sem);\n\t\tgoto error;\n\t}\n\tvma->vm_end = vma->vm_start + size;\n\tvma->vm_pgoff = vma->vm_start >> PAGE_SHIFT;\n\n\tDPRINT((\"aligned size=%ld, hdr=%p mapped @0x%lx\\n\", size, ctx->ctx_smpl_hdr, vma->vm_start));\n\n\t/* can only be applied to current task, need to have the mm semaphore held when called */\n\tif (pfm_remap_buffer(vma, (unsigned long)smpl_buf, vma->vm_start, size)) {\n\t\tDPRINT((\"Can't remap buffer\\n\"));\n\t\tup_write(&task->mm->mmap_sem);\n\t\tgoto error;\n\t}\n\n\t/*\n\t * now insert the vma in the vm list for the process, must be\n\t * done with mmap lock held\n\t */\n\tinsert_vm_struct(mm, vma);\n\n\tmm->total_vm  += size >> PAGE_SHIFT;\n\tvm_stat_account(vma->vm_mm, vma->vm_flags, vma->vm_file,\n\t\t\t\t\t\t\tvma_pages(vma));\n\tup_write(&task->mm->mmap_sem);\n\n\t/*\n\t * keep track of user level virtual address\n\t */\n\tctx->ctx_smpl_vaddr = (void *)vma->vm_start;\n\t*(unsigned long *)user_vaddr = vma->vm_start;\n\n\treturn 0;\n\nerror:\n\tkmem_cache_free(vm_area_cachep, vma);\nerror_kmem:\n\tpfm_rvfree(smpl_buf, size);\n\n\treturn -ENOMEM;\n}",
        "target": 1
    },
    {
        "func": "pfm_context_create(pfm_context_t *ctx, void *arg, int count, struct pt_regs *regs)\n{\n\tpfarg_context_t *req = (pfarg_context_t *)arg;\n\tstruct file *filp;\n\tint ctx_flags;\n\tint ret;\n\n\t/* let's check the arguments first */\n\tret = pfarg_is_sane(current, req);\n\tif (ret < 0) return ret;\n\n\tctx_flags = req->ctx_flags;\n\n\tret = -ENOMEM;\n\n\tctx = pfm_context_alloc();\n\tif (!ctx) goto error;\n\n\tret = pfm_alloc_fd(&filp);\n\tif (ret < 0) goto error_file;\n\n\treq->ctx_fd = ctx->ctx_fd = ret;\n\n\t/*\n\t * attach context to file\n\t */\n\tfilp->private_data = ctx;\n\n\t/*\n\t * does the user want to sample?\n\t */\n\tif (pfm_uuid_cmp(req->ctx_smpl_buf_id, pfm_null_uuid)) {\n\t\tret = pfm_setup_buffer_fmt(current, ctx, ctx_flags, 0, req);\n\t\tif (ret) goto buffer_error;\n\t}\n\n\t/*\n\t * init context protection lock\n\t */\n\tspin_lock_init(&ctx->ctx_lock);\n\n\t/*\n\t * context is unloaded\n\t */\n\tctx->ctx_state = PFM_CTX_UNLOADED;\n\n\t/*\n\t * initialization of context's flags\n\t */\n\tctx->ctx_fl_block       = (ctx_flags & PFM_FL_NOTIFY_BLOCK) ? 1 : 0;\n\tctx->ctx_fl_system      = (ctx_flags & PFM_FL_SYSTEM_WIDE) ? 1: 0;\n\tctx->ctx_fl_is_sampling = ctx->ctx_buf_fmt ? 1 : 0; /* assume record() is defined */\n\tctx->ctx_fl_no_msg      = (ctx_flags & PFM_FL_OVFL_NO_MSG) ? 1: 0;\n\t/*\n\t * will move to set properties\n\t * ctx->ctx_fl_excl_idle   = (ctx_flags & PFM_FL_EXCL_IDLE) ? 1: 0;\n\t */\n\n\t/*\n\t * init restart semaphore to locked\n\t */\n\tinit_completion(&ctx->ctx_restart_done);\n\n\t/*\n\t * activation is used in SMP only\n\t */\n\tctx->ctx_last_activation = PFM_INVALID_ACTIVATION;\n\tSET_LAST_CPU(ctx, -1);\n\n\t/*\n\t * initialize notification message queue\n\t */\n\tctx->ctx_msgq_head = ctx->ctx_msgq_tail = 0;\n\tinit_waitqueue_head(&ctx->ctx_msgq_wait);\n\tinit_waitqueue_head(&ctx->ctx_zombieq);\n\n\tDPRINT((\"ctx=%p flags=0x%x system=%d notify_block=%d excl_idle=%d no_msg=%d ctx_fd=%d \\n\",\n\t\tctx,\n\t\tctx_flags,\n\t\tctx->ctx_fl_system,\n\t\tctx->ctx_fl_block,\n\t\tctx->ctx_fl_excl_idle,\n\t\tctx->ctx_fl_no_msg,\n\t\tctx->ctx_fd));\n\n\t/*\n\t * initialize soft PMU state\n\t */\n\tpfm_reset_pmu_state(ctx);\n\n\treturn 0;\n\nbuffer_error:\n\tpfm_free_fd(ctx->ctx_fd, filp);\n\n\tif (ctx->ctx_buf_fmt) {\n\t\tpfm_buf_fmt_exit(ctx->ctx_buf_fmt, current, NULL, regs);\n\t}\nerror_file:\n\tpfm_context_free(ctx);\n\nerror:\n\treturn ret;\n}",
        "target": 1
    },
    {
        "func": "pfm_setup_buffer_fmt(struct task_struct *task, pfm_context_t *ctx, unsigned int ctx_flags,\n\t\t     unsigned int cpu, pfarg_context_t *arg)\n{\n\tpfm_buffer_fmt_t *fmt = NULL;\n\tunsigned long size = 0UL;\n\tvoid *uaddr = NULL;\n\tvoid *fmt_arg = NULL;\n\tint ret = 0;\n#define PFM_CTXARG_BUF_ARG(a)\t(pfm_buffer_fmt_t *)(a+1)\n\n\t/* invoke and lock buffer format, if found */\n\tfmt = pfm_find_buffer_fmt(arg->ctx_smpl_buf_id);\n\tif (fmt == NULL) {\n\t\tDPRINT((\"[%d] cannot find buffer format\\n\", task->pid));\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * buffer argument MUST be contiguous to pfarg_context_t\n\t */\n\tif (fmt->fmt_arg_size) fmt_arg = PFM_CTXARG_BUF_ARG(arg);\n\n\tret = pfm_buf_fmt_validate(fmt, task, ctx_flags, cpu, fmt_arg);\n\n\tDPRINT((\"[%d] after validate(0x%x,%d,%p)=%d\\n\", task->pid, ctx_flags, cpu, fmt_arg, ret));\n\n\tif (ret) goto error;\n\n\t/* link buffer format and context */\n\tctx->ctx_buf_fmt = fmt;\n\n\t/*\n\t * check if buffer format wants to use perfmon buffer allocation/mapping service\n\t */\n\tret = pfm_buf_fmt_getsize(fmt, task, ctx_flags, cpu, fmt_arg, &size);\n\tif (ret) goto error;\n\n\tif (size) {\n\t\t/*\n\t\t * buffer is always remapped into the caller's address space\n\t\t */\n\t\tret = pfm_smpl_buffer_alloc(current, ctx, size, &uaddr);\n\t\tif (ret) goto error;\n\n\t\t/* keep track of user address of buffer */\n\t\targ->ctx_smpl_vaddr = uaddr;\n\t}\n\tret = pfm_buf_fmt_init(fmt, task, ctx->ctx_smpl_hdr, ctx_flags, cpu, fmt_arg);\n\nerror:\n\treturn ret;\n}",
        "target": 1
    },
    {
        "func": "static int __init snd_mem_init(void)\n{\n#ifdef CONFIG_PROC_FS\n\tsnd_mem_proc = create_proc_entry(SND_MEM_PROC_FILE, 0644, NULL);\n\tif (snd_mem_proc) {\n\t\tsnd_mem_proc->read_proc = snd_mem_proc_read;\n#ifdef CONFIG_PCI\n\t\tsnd_mem_proc->write_proc = snd_mem_proc_write;\n#endif\n\t}\n#endif\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static int snd_mem_proc_read(char *page, char **start, off_t off,\n\t\t\t     int count, int *eof, void *data)\n{\n\tint len = 0;\n\tlong pages = snd_allocated_pages >> (PAGE_SHIFT-12);\n\tstruct snd_mem_list *mem;\n\tint devno;\n\tstatic char *types[] = { \"UNKNOWN\", \"CONT\", \"DEV\", \"DEV-SG\", \"SBUS\" };\n\n\tmutex_lock(&list_mutex);\n\tlen += snprintf(page + len, count - len,\n\t\t\t\"pages  : %li bytes (%li pages per %likB)\\n\",\n\t\t\tpages * PAGE_SIZE, pages, PAGE_SIZE / 1024);\n\tdevno = 0;\n\tlist_for_each_entry(mem, &mem_list_head, list) {\n\t\tdevno++;\n\t\tlen += snprintf(page + len, count - len,\n\t\t\t\t\"buffer %d : ID %08x : type %s\\n\",\n\t\t\t\tdevno, mem->id, types[mem->buffer.dev.type]);\n\t\tlen += snprintf(page + len, count - len,\n\t\t\t\t\"  addr = 0x%lx, size = %d bytes\\n\",\n\t\t\t\t(unsigned long)mem->buffer.addr, (int)mem->buffer.bytes);\n\t}\n\tmutex_unlock(&list_mutex);\n\treturn len;\n}",
        "target": 1
    },
    {
        "func": "static int snd_mem_proc_write(struct file *file, const char __user *buffer,\n\t\t\t      unsigned long count, void *data)\n{\n\tchar buf[128];\n\tchar *token, *p;\n\n\tif (count > ARRAY_SIZE(buf) - 1)\n\t\tcount = ARRAY_SIZE(buf) - 1;\n\tif (copy_from_user(buf, buffer, count))\n\t\treturn -EFAULT;\n\tbuf[ARRAY_SIZE(buf) - 1] = '\\0';\n\n\tp = buf;\n\ttoken = gettoken(&p);\n\tif (! token || *token == '#')\n\t\treturn (int)count;\n\tif (strcmp(token, \"add\") == 0) {\n\t\tchar *endp;\n\t\tint vendor, device, size, buffers;\n\t\tlong mask;\n\t\tint i, alloced;\n\t\tstruct pci_dev *pci;\n\n\t\tif ((token = gettoken(&p)) == NULL ||\n\t\t    (vendor = simple_strtol(token, NULL, 0)) <= 0 ||\n\t\t    (token = gettoken(&p)) == NULL ||\n\t\t    (device = simple_strtol(token, NULL, 0)) <= 0 ||\n\t\t    (token = gettoken(&p)) == NULL ||\n\t\t    (mask = simple_strtol(token, NULL, 0)) < 0 ||\n\t\t    (token = gettoken(&p)) == NULL ||\n\t\t    (size = memparse(token, &endp)) < 64*1024 ||\n\t\t    size > 16*1024*1024 /* too big */ ||\n\t\t    (token = gettoken(&p)) == NULL ||\n\t\t    (buffers = simple_strtol(token, NULL, 0)) <= 0 ||\n\t\t    buffers > 4) {\n\t\t\tprintk(KERN_ERR \"snd-page-alloc: invalid proc write format\\n\");\n\t\t\treturn (int)count;\n\t\t}\n\t\tvendor &= 0xffff;\n\t\tdevice &= 0xffff;\n\n\t\talloced = 0;\n\t\tpci = NULL;\n\t\twhile ((pci = pci_get_device(vendor, device, pci)) != NULL) {\n\t\t\tif (mask > 0 && mask < 0xffffffff) {\n\t\t\t\tif (pci_set_dma_mask(pci, mask) < 0 ||\n\t\t\t\t    pci_set_consistent_dma_mask(pci, mask) < 0) {\n\t\t\t\t\tprintk(KERN_ERR \"snd-page-alloc: cannot set DMA mask %lx for pci %04x:%04x\\n\", mask, vendor, device);\n\t\t\t\t\treturn (int)count;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i = 0; i < buffers; i++) {\n\t\t\t\tstruct snd_dma_buffer dmab;\n\t\t\t\tmemset(&dmab, 0, sizeof(dmab));\n\t\t\t\tif (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(pci),\n\t\t\t\t\t\t\tsize, &dmab) < 0) {\n\t\t\t\t\tprintk(KERN_ERR \"snd-page-alloc: cannot allocate buffer pages (size = %d)\\n\", size);\n\t\t\t\t\tpci_dev_put(pci);\n\t\t\t\t\treturn (int)count;\n\t\t\t\t}\n\t\t\t\tsnd_dma_reserve_buf(&dmab, snd_dma_pci_buf_id(pci));\n\t\t\t}\n\t\t\talloced++;\n\t\t}\n\t\tif (! alloced) {\n\t\t\tfor (i = 0; i < buffers; i++) {\n\t\t\t\tstruct snd_dma_buffer dmab;\n\t\t\t\tmemset(&dmab, 0, sizeof(dmab));\n\t\t\t\t/* FIXME: We can allocate only in ZONE_DMA\n\t\t\t\t * without a device pointer!\n\t\t\t\t */\n\t\t\t\tif (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, NULL,\n\t\t\t\t\t\t\tsize, &dmab) < 0) {\n\t\t\t\t\tprintk(KERN_ERR \"snd-page-alloc: cannot allocate buffer pages (size = %d)\\n\", size);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsnd_dma_reserve_buf(&dmab, (unsigned int)((vendor << 16) | device));\n\t\t\t}\n\t\t}\n\t} else if (strcmp(token, \"erase\") == 0)\n\t\t/* FIXME: need for releasing each buffer chunk? */\n\t\tfree_all_reserved_pages();\n\telse\n\t\tprintk(KERN_ERR \"snd-page-alloc: invalid proc cmd\\n\");\n\treturn (int)count;\n}",
        "target": 1
    },
    {
        "func": "static int putreg(struct task_struct *child,\n\tunsigned long regno, unsigned long value)\n{\n\tunsigned long tmp; \n\t\n\t/* Some code in the 64bit emulation may not be 64bit clean.\n\t   Don't take any chances. */\n\tif (test_tsk_thread_flag(child, TIF_IA32))\n\t\tvalue &= 0xffffffff;\n\tswitch (regno) {\n\t\tcase offsetof(struct user_regs_struct,fs):\n\t\t\tif (value && (value & 3) != 3)\n\t\t\t\treturn -EIO;\n\t\t\tchild->thread.fsindex = value & 0xffff; \n\t\t\treturn 0;\n\t\tcase offsetof(struct user_regs_struct,gs):\n\t\t\tif (value && (value & 3) != 3)\n\t\t\t\treturn -EIO;\n\t\t\tchild->thread.gsindex = value & 0xffff;\n\t\t\treturn 0;\n\t\tcase offsetof(struct user_regs_struct,ds):\n\t\t\tif (value && (value & 3) != 3)\n\t\t\t\treturn -EIO;\n\t\t\tchild->thread.ds = value & 0xffff;\n\t\t\treturn 0;\n\t\tcase offsetof(struct user_regs_struct,es): \n\t\t\tif (value && (value & 3) != 3)\n\t\t\t\treturn -EIO;\n\t\t\tchild->thread.es = value & 0xffff;\n\t\t\treturn 0;\n\t\tcase offsetof(struct user_regs_struct,ss):\n\t\t\tif ((value & 3) != 3)\n\t\t\t\treturn -EIO;\n\t\t\tvalue &= 0xffff;\n\t\t\treturn 0;\n\t\tcase offsetof(struct user_regs_struct,fs_base):\n\t\t\tif (value >= TASK_SIZE_OF(child))\n\t\t\t\treturn -EIO;\n\t\t\tchild->thread.fs = value;\n\t\t\treturn 0;\n\t\tcase offsetof(struct user_regs_struct,gs_base):\n\t\t\tif (value >= TASK_SIZE_OF(child))\n\t\t\t\treturn -EIO;\n\t\t\tchild->thread.gs = value;\n\t\t\treturn 0;\n\t\tcase offsetof(struct user_regs_struct, eflags):\n\t\t\tvalue &= FLAG_MASK;\n\t\t\ttmp = get_stack_long(child, EFL_OFFSET); \n\t\t\ttmp &= ~FLAG_MASK; \n\t\t\tvalue |= tmp;\n\t\t\tbreak;\n\t\tcase offsetof(struct user_regs_struct,cs): \n\t\t\tif ((value & 3) != 3)\n\t\t\t\treturn -EIO;\n\t\t\tvalue &= 0xffff;\n\t\t\tbreak;\n\t}\n\tput_stack_long(child, regno - sizeof(struct pt_regs), value);\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static int pwc_video_close(struct inode *inode, struct file *file)\n{\n\tstruct video_device *vdev = file->private_data;\n\tstruct pwc_device *pdev;\n\tint i;\n\n\tPWC_DEBUG_OPEN(\">> video_close called(vdev = 0x%p).\\n\", vdev);\n\n\tpdev = (struct pwc_device *)vdev->priv;\n\tif (pdev->vopen == 0)\n\t\tPWC_DEBUG_MODULE(\"video_close() called on closed device?\\n\");\n\n\t/* Dump statistics, but only if a reasonable amount of frames were\n\t   processed (to prevent endless log-entries in case of snap-shot\n\t   programs)\n\t */\n\tif (pdev->vframe_count > 20)\n\t\tPWC_DEBUG_MODULE(\"Closing video device: %d frames received, dumped %d frames, %d frames with errors.\\n\", pdev->vframe_count, pdev->vframes_dumped, pdev->vframes_error);\n\n\tif (DEVICE_USE_CODEC1(pdev->type))\n\t    pwc_dec1_exit();\n\telse\n\t    pwc_dec23_exit();\n\n\tpwc_isoc_cleanup(pdev);\n\tpwc_free_buffers(pdev);\n\n\t/* Turn off LEDS and power down camera, but only when not unplugged */\n\tif (pdev->error_status != EPIPE) {\n\t\t/* Turn LEDs off */\n\t\tif (pwc_set_leds(pdev, 0, 0) < 0)\n\t\t\tPWC_DEBUG_MODULE(\"Failed to set LED on/off time.\\n\");\n\t\tif (power_save) {\n\t\t\ti = pwc_camera_power(pdev, 0);\n\t\t\tif (i < 0)\n\t\t\t\tPWC_ERROR(\"Failed to power down camera (%d)\\n\", i);\n\t\t}\n\t}\n\tpdev->vopen--;\n\tPWC_DEBUG_OPEN(\"<< video_close() vopen=%d\\n\", pdev->vopen);\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static void usb_pwc_disconnect(struct usb_interface *intf)\n{\n\tstruct pwc_device *pdev;\n\tint hint;\n\n\tlock_kernel();\n\tpdev = usb_get_intfdata (intf);\n\tusb_set_intfdata (intf, NULL);\n\tif (pdev == NULL) {\n\t\tPWC_ERROR(\"pwc_disconnect() Called without private pointer.\\n\");\n\t\tgoto disconnect_out;\n\t}\n\tif (pdev->udev == NULL) {\n\t\tPWC_ERROR(\"pwc_disconnect() already called for %p\\n\", pdev);\n\t\tgoto disconnect_out;\n\t}\n\tif (pdev->udev != interface_to_usbdev(intf)) {\n\t\tPWC_ERROR(\"pwc_disconnect() Woops: pointer mismatch udev/pdev.\\n\");\n\t\tgoto disconnect_out;\n\t}\n\n\t/* We got unplugged; this is signalled by an EPIPE error code */\n\tif (pdev->vopen) {\n\t\tPWC_INFO(\"Disconnected while webcam is in use!\\n\");\n\t\tpdev->error_status = EPIPE;\n\t}\n\n\t/* Alert waiting processes */\n\twake_up_interruptible(&pdev->frameq);\n\t/* Wait until device is closed */\n\twhile (pdev->vopen)\n\t\tschedule();\n\t/* Device is now closed, so we can safely unregister it */\n\tPWC_DEBUG_PROBE(\"Unregistering video device in disconnect().\\n\");\n\tpwc_remove_sysfs_files(pdev->vdev);\n\tvideo_unregister_device(pdev->vdev);\n\n\t/* Free memory (don't set pdev to 0 just yet) */\n\tkfree(pdev);\n\ndisconnect_out:\n\t/* search device_hint[] table if we occupy a slot, by any chance */\n\tfor (hint = 0; hint < MAX_DEV_HINTS; hint++)\n\t\tif (device_hint[hint].pdev == pdev)\n\t\t\tdevice_hint[hint].pdev = NULL;\n\n\tunlock_kernel();\n}",
        "target": 1
    },
    {
        "func": "static int return_EIO(void)\n{\n\treturn -EIO;\n}",
        "target": 1
    },
    {
        "func": "void make_bad_inode(struct inode * inode) \n{\n\tremove_inode_hash(inode);\n\n\tinode->i_mode = S_IFREG;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime =\n\t\tcurrent_fs_time(inode->i_sb);\n\tinode->i_op = &bad_inode_ops;\t\n\tinode->i_fop = &bad_file_ops;\t\n}",
        "target": 1
    },
    {
        "func": "int is_bad_inode(struct inode * inode) \n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}",
        "target": 1
    },
    {
        "func": "void hash_preload(struct mm_struct *mm, unsigned long ea,\n\t\t  unsigned long access, unsigned long trap)\n{\n\tunsigned long vsid;\n\tvoid *pgdir;\n\tpte_t *ptep;\n\tcpumask_t mask;\n\tunsigned long flags;\n\tint local = 0;\n\n\t/* We don't want huge pages prefaulted for now\n\t */\n\tif (unlikely(in_hugepage_area(mm->context, ea)))\n\t\treturn;\n\n\tDBG_LOW(\"hash_preload(mm=%p, mm->pgdir=%p, ea=%016lx, access=%lx,\"\n\t\t\" trap=%lx\\n\", mm, mm->pgd, ea, access, trap);\n\n\t/* Get PTE, VSID, access mask */\n\tpgdir = mm->pgd;\n\tif (pgdir == NULL)\n\t\treturn;\n\tptep = find_linux_pte(pgdir, ea);\n\tif (!ptep)\n\t\treturn;\n\tvsid = get_vsid(mm->context.id, ea);\n\n\t/* Hash it in */\n\tlocal_irq_save(flags);\n\tmask = cpumask_of_cpu(smp_processor_id());\n\tif (cpus_equal(mm->cpu_vm_mask, mask))\n\t\tlocal = 1;\n#ifndef CONFIG_PPC_64K_PAGES\n\t__hash_page_4K(ea, access, vsid, ptep, trap, local);\n#else\n\tif (mmu_ci_restrictions) {\n\t\t/* If this PTE is non-cacheable, switch to 4k */\n\t\tif (mm->context.user_psize == MMU_PAGE_64K &&\n\t\t    (pte_val(*ptep) & _PAGE_NO_CACHE)) {\n\t\t\tmm->context.user_psize = MMU_PAGE_4K;\n\t\t\tmm->context.sllp = SLB_VSID_USER |\n\t\t\t\tmmu_psize_defs[MMU_PAGE_4K].sllp;\n\t\t\tget_paca()->context = mm->context;\n\t\t\tslb_flush_and_rebolt();\n#ifdef CONFIG_SPE_BASE\n\t\t\tspu_flush_all_slbs(mm);\n#endif\n\t\t}\n\t}\n\tif (mm->context.user_psize == MMU_PAGE_64K)\n\t\t__hash_page_64K(ea, access, vsid, ptep, trap, local);\n\telse\n\t\t__hash_page_4K(ea, access, vsid, ptep, trap, local);\n#endif /* CONFIG_PPC_64K_PAGES */\n\tlocal_irq_restore(flags);\n}",
        "target": 1
    },
    {
        "func": "int hash_page(unsigned long ea, unsigned long access, unsigned long trap)\n{\n\tvoid *pgdir;\n\tunsigned long vsid;\n\tstruct mm_struct *mm;\n\tpte_t *ptep;\n\tcpumask_t tmp;\n\tint rc, user_region = 0, local = 0;\n\tint psize;\n\n\tDBG_LOW(\"hash_page(ea=%016lx, access=%lx, trap=%lx\\n\",\n\t\tea, access, trap);\n\n\tif ((ea & ~REGION_MASK) >= PGTABLE_RANGE) {\n\t\tDBG_LOW(\" out of pgtable range !\\n\");\n \t\treturn 1;\n\t}\n\n\t/* Get region & vsid */\n \tswitch (REGION_ID(ea)) {\n\tcase USER_REGION_ID:\n\t\tuser_region = 1;\n\t\tmm = current->mm;\n\t\tif (! mm) {\n\t\t\tDBG_LOW(\" user region with no mm !\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\tvsid = get_vsid(mm->context.id, ea);\n\t\tpsize = mm->context.user_psize;\n\t\tbreak;\n\tcase VMALLOC_REGION_ID:\n\t\tmm = &init_mm;\n\t\tvsid = get_kernel_vsid(ea);\n\t\tif (ea < VMALLOC_END)\n\t\t\tpsize = mmu_vmalloc_psize;\n\t\telse\n\t\t\tpsize = mmu_io_psize;\n\t\tbreak;\n\tdefault:\n\t\t/* Not a valid range\n\t\t * Send the problem up to do_page_fault \n\t\t */\n\t\treturn 1;\n\t}\n\tDBG_LOW(\" mm=%p, mm->pgdir=%p, vsid=%016lx\\n\", mm, mm->pgd, vsid);\n\n\t/* Get pgdir */\n\tpgdir = mm->pgd;\n\tif (pgdir == NULL)\n\t\treturn 1;\n\n\t/* Check CPU locality */\n\ttmp = cpumask_of_cpu(smp_processor_id());\n\tif (user_region && cpus_equal(mm->cpu_vm_mask, tmp))\n\t\tlocal = 1;\n\n\t/* Handle hugepage regions */\n\tif (unlikely(in_hugepage_area(mm->context, ea))) {\n\t\tDBG_LOW(\" -> huge page !\\n\");\n\t\treturn hash_huge_page(mm, access, ea, vsid, local, trap);\n\t}\n\n\t/* Get PTE and page size from page tables */\n\tptep = find_linux_pte(pgdir, ea);\n\tif (ptep == NULL || !pte_present(*ptep)) {\n\t\tDBG_LOW(\" no PTE !\\n\");\n\t\treturn 1;\n\t}\n\n#ifndef CONFIG_PPC_64K_PAGES\n\tDBG_LOW(\" i-pte: %016lx\\n\", pte_val(*ptep));\n#else\n\tDBG_LOW(\" i-pte: %016lx %016lx\\n\", pte_val(*ptep),\n\t\tpte_val(*(ptep + PTRS_PER_PTE)));\n#endif\n\t/* Pre-check access permissions (will be re-checked atomically\n\t * in __hash_page_XX but this pre-check is a fast path\n\t */\n\tif (access & ~pte_val(*ptep)) {\n\t\tDBG_LOW(\" no access !\\n\");\n\t\treturn 1;\n\t}\n\n\t/* Do actual hashing */\n#ifndef CONFIG_PPC_64K_PAGES\n\trc = __hash_page_4K(ea, access, vsid, ptep, trap, local);\n#else\n\tif (mmu_ci_restrictions) {\n\t\t/* If this PTE is non-cacheable, switch to 4k */\n\t\tif (psize == MMU_PAGE_64K &&\n\t\t    (pte_val(*ptep) & _PAGE_NO_CACHE)) {\n\t\t\tif (user_region) {\n\t\t\t\tpsize = MMU_PAGE_4K;\n\t\t\t\tmm->context.user_psize = MMU_PAGE_4K;\n\t\t\t\tmm->context.sllp = SLB_VSID_USER |\n\t\t\t\t\tmmu_psize_defs[MMU_PAGE_4K].sllp;\n\t\t\t} else if (ea < VMALLOC_END) {\n\t\t\t\t/*\n\t\t\t\t * some driver did a non-cacheable mapping\n\t\t\t\t * in vmalloc space, so switch vmalloc\n\t\t\t\t * to 4k pages\n\t\t\t\t */\n\t\t\t\tprintk(KERN_ALERT \"Reducing vmalloc segment \"\n\t\t\t\t       \"to 4kB pages because of \"\n\t\t\t\t       \"non-cacheable mapping\\n\");\n\t\t\t\tpsize = mmu_vmalloc_psize = MMU_PAGE_4K;\n\t\t\t}\n#ifdef CONFIG_SPE_BASE\n\t\t\tspu_flush_all_slbs(mm);\n#endif\n\t\t}\n\t\tif (user_region) {\n\t\t\tif (psize != get_paca()->context.user_psize) {\n\t\t\t\tget_paca()->context = mm->context;\n\t\t\t\tslb_flush_and_rebolt();\n\t\t\t}\n\t\t} else if (get_paca()->vmalloc_sllp !=\n\t\t\t   mmu_psize_defs[mmu_vmalloc_psize].sllp) {\n\t\t\tget_paca()->vmalloc_sllp =\n\t\t\t\tmmu_psize_defs[mmu_vmalloc_psize].sllp;\n\t\t\tslb_flush_and_rebolt();\n\t\t}\n\t}\n\tif (psize == MMU_PAGE_64K)\n\t\trc = __hash_page_64K(ea, access, vsid, ptep, trap, local);\n\telse\n\t\trc = __hash_page_4K(ea, access, vsid, ptep, trap, local);\n#endif /* CONFIG_PPC_64K_PAGES */\n\n#ifndef CONFIG_PPC_64K_PAGES\n\tDBG_LOW(\" o-pte: %016lx\\n\", pte_val(*ptep));\n#else\n\tDBG_LOW(\" o-pte: %016lx %016lx\\n\", pte_val(*ptep),\n\t\tpte_val(*(ptep + PTRS_PER_PTE)));\n#endif\n\tDBG_LOW(\" -> rc=%d\\n\", rc);\n\treturn rc;\n}",
        "target": 1
    },
    {
        "func": "int ieee80211_rx(struct ieee80211_device *ieee, struct sk_buff *skb,\n\t\t struct ieee80211_rx_stats *rx_stats)\n{\n\tstruct net_device *dev = ieee->dev;\n\tstruct ieee80211_hdr_4addr *hdr;\n\tsize_t hdrlen;\n\tu16 fc, type, stype, sc;\n\tstruct net_device_stats *stats;\n\tunsigned int frag;\n\tu8 *payload;\n\tu16 ethertype;\n#ifdef NOT_YET\n\tstruct net_device *wds = NULL;\n\tstruct sk_buff *skb2 = NULL;\n\tstruct net_device *wds = NULL;\n\tint frame_authorized = 0;\n\tint from_assoc_ap = 0;\n\tvoid *sta = NULL;\n#endif\n\tu8 dst[ETH_ALEN];\n\tu8 src[ETH_ALEN];\n\tstruct ieee80211_crypt_data *crypt = NULL;\n\tint keyidx = 0;\n\tint can_be_decrypted = 0;\n\n\thdr = (struct ieee80211_hdr_4addr *)skb->data;\n\tstats = &ieee->stats;\n\n\tif (skb->len < 10) {\n\t\tprintk(KERN_INFO \"%s: SKB length < 10\\n\", dev->name);\n\t\tgoto rx_dropped;\n\t}\n\n\tfc = le16_to_cpu(hdr->frame_ctl);\n\ttype = WLAN_FC_GET_TYPE(fc);\n\tstype = WLAN_FC_GET_STYPE(fc);\n\tsc = le16_to_cpu(hdr->seq_ctl);\n\tfrag = WLAN_GET_SEQ_FRAG(sc);\n\thdrlen = ieee80211_get_hdrlen(fc);\n\n\t/* Put this code here so that we avoid duplicating it in all\n\t * Rx paths. - Jean II */\n#ifdef CONFIG_WIRELESS_EXT\n#ifdef IW_WIRELESS_SPY\t\t/* defined in iw_handler.h */\n\t/* If spy monitoring on */\n\tif (ieee->spy_data.spy_number > 0) {\n\t\tstruct iw_quality wstats;\n\n\t\twstats.updated = 0;\n\t\tif (rx_stats->mask & IEEE80211_STATMASK_RSSI) {\n\t\t\twstats.level = rx_stats->rssi;\n\t\t\twstats.updated |= IW_QUAL_LEVEL_UPDATED;\n\t\t} else\n\t\t\twstats.updated |= IW_QUAL_LEVEL_INVALID;\n\n\t\tif (rx_stats->mask & IEEE80211_STATMASK_NOISE) {\n\t\t\twstats.noise = rx_stats->noise;\n\t\t\twstats.updated |= IW_QUAL_NOISE_UPDATED;\n\t\t} else\n\t\t\twstats.updated |= IW_QUAL_NOISE_INVALID;\n\n\t\tif (rx_stats->mask & IEEE80211_STATMASK_SIGNAL) {\n\t\t\twstats.qual = rx_stats->signal;\n\t\t\twstats.updated |= IW_QUAL_QUAL_UPDATED;\n\t\t} else\n\t\t\twstats.updated |= IW_QUAL_QUAL_INVALID;\n\n\t\t/* Update spy records */\n\t\twireless_spy_update(ieee->dev, hdr->addr2, &wstats);\n\t}\n#endif\t\t\t\t/* IW_WIRELESS_SPY */\n#endif\t\t\t\t/* CONFIG_WIRELESS_EXT */\n\n#ifdef NOT_YET\n\thostap_update_rx_stats(local->ap, hdr, rx_stats);\n#endif\n\n\tif (ieee->iw_mode == IW_MODE_MONITOR) {\n\t\tstats->rx_packets++;\n\t\tstats->rx_bytes += skb->len;\n\t\tieee80211_monitor_rx(ieee, skb, rx_stats);\n\t\treturn 1;\n\t}\n\n\tcan_be_decrypted = (is_multicast_ether_addr(hdr->addr1) ||\n\t\t\t    is_broadcast_ether_addr(hdr->addr2)) ?\n\t    ieee->host_mc_decrypt : ieee->host_decrypt;\n\n\tif (can_be_decrypted) {\n\t\tif (skb->len >= hdrlen + 3) {\n\t\t\t/* Top two-bits of byte 3 are the key index */\n\t\t\tkeyidx = skb->data[hdrlen + 3] >> 6;\n\t\t}\n\n\t\t/* ieee->crypt[] is WEP_KEY (4) in length.  Given that keyidx\n\t\t * is only allowed 2-bits of storage, no value of keyidx can\n\t\t * be provided via above code that would result in keyidx\n\t\t * being out of range */\n\t\tcrypt = ieee->crypt[keyidx];\n\n#ifdef NOT_YET\n\t\tsta = NULL;\n\n\t\t/* Use station specific key to override default keys if the\n\t\t * receiver address is a unicast address (\"individual RA\"). If\n\t\t * bcrx_sta_key parameter is set, station specific key is used\n\t\t * even with broad/multicast targets (this is against IEEE\n\t\t * 802.11, but makes it easier to use different keys with\n\t\t * stations that do not support WEP key mapping). */\n\n\t\tif (!(hdr->addr1[0] & 0x01) || local->bcrx_sta_key)\n\t\t\t(void)hostap_handle_sta_crypto(local, hdr, &crypt,\n\t\t\t\t\t\t       &sta);\n#endif\n\n\t\t/* allow NULL decrypt to indicate an station specific override\n\t\t * for default encryption */\n\t\tif (crypt && (crypt->ops == NULL ||\n\t\t\t      crypt->ops->decrypt_mpdu == NULL))\n\t\t\tcrypt = NULL;\n\n\t\tif (!crypt && (fc & IEEE80211_FCTL_PROTECTED)) {\n\t\t\t/* This seems to be triggered by some (multicast?)\n\t\t\t * frames from other than current BSS, so just drop the\n\t\t\t * frames silently instead of filling system log with\n\t\t\t * these reports. */\n\t\t\tIEEE80211_DEBUG_DROP(\"Decryption failed (not set)\"\n\t\t\t\t\t     \" (SA=\" MAC_FMT \")\\n\",\n\t\t\t\t\t     MAC_ARG(hdr->addr2));\n\t\t\tieee->ieee_stats.rx_discards_undecryptable++;\n\t\t\tgoto rx_dropped;\n\t\t}\n\t}\n#ifdef NOT_YET\n\tif (type != WLAN_FC_TYPE_DATA) {\n\t\tif (type == WLAN_FC_TYPE_MGMT && stype == WLAN_FC_STYPE_AUTH &&\n\t\t    fc & IEEE80211_FCTL_PROTECTED && ieee->host_decrypt &&\n\t\t    (keyidx = hostap_rx_frame_decrypt(ieee, skb, crypt)) < 0) {\n\t\t\tprintk(KERN_DEBUG \"%s: failed to decrypt mgmt::auth \"\n\t\t\t       \"from \" MAC_FMT \"\\n\", dev->name,\n\t\t\t       MAC_ARG(hdr->addr2));\n\t\t\t/* TODO: could inform hostapd about this so that it\n\t\t\t * could send auth failure report */\n\t\t\tgoto rx_dropped;\n\t\t}\n\n\t\tif (ieee80211_rx_frame_mgmt(ieee, skb, rx_stats, type, stype))\n\t\t\tgoto rx_dropped;\n\t\telse\n\t\t\tgoto rx_exit;\n\t}\n#endif\n\t/* drop duplicate 802.11 retransmissions (IEEE 802.11 Chap. 9.29) */\n\tif (sc == ieee->prev_seq_ctl)\n\t\tgoto rx_dropped;\n\telse\n\t\tieee->prev_seq_ctl = sc;\n\n\t/* Data frame - extract src/dst addresses */\n\tif (skb->len < IEEE80211_3ADDR_LEN)\n\t\tgoto rx_dropped;\n\n\tswitch (fc & (IEEE80211_FCTL_FROMDS | IEEE80211_FCTL_TODS)) {\n\tcase IEEE80211_FCTL_FROMDS:\n\t\tmemcpy(dst, hdr->addr1, ETH_ALEN);\n\t\tmemcpy(src, hdr->addr3, ETH_ALEN);\n\t\tbreak;\n\tcase IEEE80211_FCTL_TODS:\n\t\tmemcpy(dst, hdr->addr3, ETH_ALEN);\n\t\tmemcpy(src, hdr->addr2, ETH_ALEN);\n\t\tbreak;\n\tcase IEEE80211_FCTL_FROMDS | IEEE80211_FCTL_TODS:\n\t\tif (skb->len < IEEE80211_4ADDR_LEN)\n\t\t\tgoto rx_dropped;\n\t\tmemcpy(dst, hdr->addr3, ETH_ALEN);\n\t\tmemcpy(src, hdr->addr4, ETH_ALEN);\n\t\tbreak;\n\tcase 0:\n\t\tmemcpy(dst, hdr->addr1, ETH_ALEN);\n\t\tmemcpy(src, hdr->addr2, ETH_ALEN);\n\t\tbreak;\n\t}\n\n#ifdef NOT_YET\n\tif (hostap_rx_frame_wds(ieee, hdr, fc, &wds))\n\t\tgoto rx_dropped;\n\tif (wds) {\n\t\tskb->dev = dev = wds;\n\t\tstats = hostap_get_stats(dev);\n\t}\n\n\tif (ieee->iw_mode == IW_MODE_MASTER && !wds &&\n\t    (fc & (IEEE80211_FCTL_TODS | IEEE80211_FCTL_FROMDS)) ==\n\t    IEEE80211_FCTL_FROMDS && ieee->stadev\n\t    && !compare_ether_addr(hdr->addr2, ieee->assoc_ap_addr)) {\n\t\t/* Frame from BSSID of the AP for which we are a client */\n\t\tskb->dev = dev = ieee->stadev;\n\t\tstats = hostap_get_stats(dev);\n\t\tfrom_assoc_ap = 1;\n\t}\n#endif\n\n\tdev->last_rx = jiffies;\n\n#ifdef NOT_YET\n\tif ((ieee->iw_mode == IW_MODE_MASTER ||\n\t     ieee->iw_mode == IW_MODE_REPEAT) && !from_assoc_ap) {\n\t\tswitch (hostap_handle_sta_rx(ieee, dev, skb, rx_stats,\n\t\t\t\t\t     wds != NULL)) {\n\t\tcase AP_RX_CONTINUE_NOT_AUTHORIZED:\n\t\t\tframe_authorized = 0;\n\t\t\tbreak;\n\t\tcase AP_RX_CONTINUE:\n\t\t\tframe_authorized = 1;\n\t\t\tbreak;\n\t\tcase AP_RX_DROP:\n\t\t\tgoto rx_dropped;\n\t\tcase AP_RX_EXIT:\n\t\t\tgoto rx_exit;\n\t\t}\n\t}\n#endif\n\n\t/* Nullfunc frames may have PS-bit set, so they must be passed to\n\t * hostap_handle_sta_rx() before being dropped here. */\n\n\tstype &= ~IEEE80211_STYPE_QOS_DATA;\n\n\tif (stype != IEEE80211_STYPE_DATA &&\n\t    stype != IEEE80211_STYPE_DATA_CFACK &&\n\t    stype != IEEE80211_STYPE_DATA_CFPOLL &&\n\t    stype != IEEE80211_STYPE_DATA_CFACKPOLL) {\n\t\tif (stype != IEEE80211_STYPE_NULLFUNC)\n\t\t\tIEEE80211_DEBUG_DROP(\"RX: dropped data frame \"\n\t\t\t\t\t     \"with no data (type=0x%02x, \"\n\t\t\t\t\t     \"subtype=0x%02x, len=%d)\\n\",\n\t\t\t\t\t     type, stype, skb->len);\n\t\tgoto rx_dropped;\n\t}\n\n\t/* skb: hdr + (possibly fragmented, possibly encrypted) payload */\n\n\tif ((fc & IEEE80211_FCTL_PROTECTED) && can_be_decrypted &&\n\t    (keyidx = ieee80211_rx_frame_decrypt(ieee, skb, crypt)) < 0)\n\t\tgoto rx_dropped;\n\n\thdr = (struct ieee80211_hdr_4addr *)skb->data;\n\n\t/* skb: hdr + (possibly fragmented) plaintext payload */\n\t// PR: FIXME: hostap has additional conditions in the \"if\" below:\n\t// ieee->host_decrypt && (fc & IEEE80211_FCTL_PROTECTED) &&\n\tif ((frag != 0) || (fc & IEEE80211_FCTL_MOREFRAGS)) {\n\t\tint flen;\n\t\tstruct sk_buff *frag_skb = ieee80211_frag_cache_get(ieee, hdr);\n\t\tIEEE80211_DEBUG_FRAG(\"Rx Fragment received (%u)\\n\", frag);\n\n\t\tif (!frag_skb) {\n\t\t\tIEEE80211_DEBUG(IEEE80211_DL_RX | IEEE80211_DL_FRAG,\n\t\t\t\t\t\"Rx cannot get skb from fragment \"\n\t\t\t\t\t\"cache (morefrag=%d seq=%u frag=%u)\\n\",\n\t\t\t\t\t(fc & IEEE80211_FCTL_MOREFRAGS) != 0,\n\t\t\t\t\tWLAN_GET_SEQ_SEQ(sc), frag);\n\t\t\tgoto rx_dropped;\n\t\t}\n\n\t\tflen = skb->len;\n\t\tif (frag != 0)\n\t\t\tflen -= hdrlen;\n\n\t\tif (frag_skb->tail + flen > frag_skb->end) {\n\t\t\tprintk(KERN_WARNING \"%s: host decrypted and \"\n\t\t\t       \"reassembled frame did not fit skb\\n\",\n\t\t\t       dev->name);\n\t\t\tieee80211_frag_cache_invalidate(ieee, hdr);\n\t\t\tgoto rx_dropped;\n\t\t}\n\n\t\tif (frag == 0) {\n\t\t\t/* copy first fragment (including full headers) into\n\t\t\t * beginning of the fragment cache skb */\n\t\t\tskb_copy_from_linear_data(skb, skb_put(frag_skb, flen), flen);\n\t\t} else {\n\t\t\t/* append frame payload to the end of the fragment\n\t\t\t * cache skb */\n\t\t\tskb_copy_from_linear_data_offset(skb, hdrlen,\n\t\t\t\t      skb_put(frag_skb, flen), flen);\n\t\t}\n\t\tdev_kfree_skb_any(skb);\n\t\tskb = NULL;\n\n\t\tif (fc & IEEE80211_FCTL_MOREFRAGS) {\n\t\t\t/* more fragments expected - leave the skb in fragment\n\t\t\t * cache for now; it will be delivered to upper layers\n\t\t\t * after all fragments have been received */\n\t\t\tgoto rx_exit;\n\t\t}\n\n\t\t/* this was the last fragment and the frame will be\n\t\t * delivered, so remove skb from fragment cache */\n\t\tskb = frag_skb;\n\t\thdr = (struct ieee80211_hdr_4addr *)skb->data;\n\t\tieee80211_frag_cache_invalidate(ieee, hdr);\n\t}\n\n\t/* skb: hdr + (possible reassembled) full MSDU payload; possibly still\n\t * encrypted/authenticated */\n\tif ((fc & IEEE80211_FCTL_PROTECTED) && can_be_decrypted &&\n\t    ieee80211_rx_frame_decrypt_msdu(ieee, skb, keyidx, crypt))\n\t\tgoto rx_dropped;\n\n\thdr = (struct ieee80211_hdr_4addr *)skb->data;\n\tif (crypt && !(fc & IEEE80211_FCTL_PROTECTED) && !ieee->open_wep) {\n\t\tif (\t\t/*ieee->ieee802_1x && */\n\t\t\t   ieee80211_is_eapol_frame(ieee, skb)) {\n\t\t\t/* pass unencrypted EAPOL frames even if encryption is\n\t\t\t * configured */\n\t\t} else {\n\t\t\tIEEE80211_DEBUG_DROP(\"encryption configured, but RX \"\n\t\t\t\t\t     \"frame not encrypted (SA=\" MAC_FMT\n\t\t\t\t\t     \")\\n\", MAC_ARG(hdr->addr2));\n\t\t\tgoto rx_dropped;\n\t\t}\n\t}\n\n\tif (crypt && !(fc & IEEE80211_FCTL_PROTECTED) && !ieee->open_wep &&\n\t    !ieee80211_is_eapol_frame(ieee, skb)) {\n\t\tIEEE80211_DEBUG_DROP(\"dropped unencrypted RX data \"\n\t\t\t\t     \"frame from \" MAC_FMT\n\t\t\t\t     \" (drop_unencrypted=1)\\n\",\n\t\t\t\t     MAC_ARG(hdr->addr2));\n\t\tgoto rx_dropped;\n\t}\n\n\t/* If the frame was decrypted in hardware, we may need to strip off\n\t * any security data (IV, ICV, etc) that was left behind */\n\tif (!can_be_decrypted && (fc & IEEE80211_FCTL_PROTECTED) &&\n\t    ieee->host_strip_iv_icv) {\n\t\tint trimlen = 0;\n\n\t\t/* Top two-bits of byte 3 are the key index */\n\t\tif (skb->len >= hdrlen + 3)\n\t\t\tkeyidx = skb->data[hdrlen + 3] >> 6;\n\n\t\t/* To strip off any security data which appears before the\n\t\t * payload, we simply increase hdrlen (as the header gets\n\t\t * chopped off immediately below). For the security data which\n\t\t * appears after the payload, we use skb_trim. */\n\n\t\tswitch (ieee->sec.encode_alg[keyidx]) {\n\t\tcase SEC_ALG_WEP:\n\t\t\t/* 4 byte IV */\n\t\t\thdrlen += 4;\n\t\t\t/* 4 byte ICV */\n\t\t\ttrimlen = 4;\n\t\t\tbreak;\n\t\tcase SEC_ALG_TKIP:\n\t\t\t/* 4 byte IV, 4 byte ExtIV */\n\t\t\thdrlen += 8;\n\t\t\t/* 8 byte MIC, 4 byte ICV */\n\t\t\ttrimlen = 12;\n\t\t\tbreak;\n\t\tcase SEC_ALG_CCMP:\n\t\t\t/* 8 byte CCMP header */\n\t\t\thdrlen += 8;\n\t\t\t/* 8 byte MIC */\n\t\t\ttrimlen = 8;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (skb->len < trimlen)\n\t\t\tgoto rx_dropped;\n\n\t\t__skb_trim(skb, skb->len - trimlen);\n\n\t\tif (skb->len < hdrlen)\n\t\t\tgoto rx_dropped;\n\t}\n\n\t/* skb: hdr + (possible reassembled) full plaintext payload */\n\n\tpayload = skb->data + hdrlen;\n\tethertype = (payload[6] << 8) | payload[7];\n\n#ifdef NOT_YET\n\t/* If IEEE 802.1X is used, check whether the port is authorized to send\n\t * the received frame. */\n\tif (ieee->ieee802_1x && ieee->iw_mode == IW_MODE_MASTER) {\n\t\tif (ethertype == ETH_P_PAE) {\n\t\t\tprintk(KERN_DEBUG \"%s: RX: IEEE 802.1X frame\\n\",\n\t\t\t       dev->name);\n\t\t\tif (ieee->hostapd && ieee->apdev) {\n\t\t\t\t/* Send IEEE 802.1X frames to the user\n\t\t\t\t * space daemon for processing */\n\t\t\t\tprism2_rx_80211(ieee->apdev, skb, rx_stats,\n\t\t\t\t\t\tPRISM2_RX_MGMT);\n\t\t\t\tieee->apdevstats.rx_packets++;\n\t\t\t\tieee->apdevstats.rx_bytes += skb->len;\n\t\t\t\tgoto rx_exit;\n\t\t\t}\n\t\t} else if (!frame_authorized) {\n\t\t\tprintk(KERN_DEBUG \"%s: dropped frame from \"\n\t\t\t       \"unauthorized port (IEEE 802.1X): \"\n\t\t\t       \"ethertype=0x%04x\\n\", dev->name, ethertype);\n\t\t\tgoto rx_dropped;\n\t\t}\n\t}\n#endif\n\n\t/* convert hdr + possible LLC headers into Ethernet header */\n\tif (skb->len - hdrlen >= 8 &&\n\t    ((memcmp(payload, rfc1042_header, SNAP_SIZE) == 0 &&\n\t      ethertype != ETH_P_AARP && ethertype != ETH_P_IPX) ||\n\t     memcmp(payload, bridge_tunnel_header, SNAP_SIZE) == 0)) {\n\t\t/* remove RFC1042 or Bridge-Tunnel encapsulation and\n\t\t * replace EtherType */\n\t\tskb_pull(skb, hdrlen + SNAP_SIZE);\n\t\tmemcpy(skb_push(skb, ETH_ALEN), src, ETH_ALEN);\n\t\tmemcpy(skb_push(skb, ETH_ALEN), dst, ETH_ALEN);\n\t} else {\n\t\tu16 len;\n\t\t/* Leave Ethernet header part of hdr and full payload */\n\t\tskb_pull(skb, hdrlen);\n\t\tlen = htons(skb->len);\n\t\tmemcpy(skb_push(skb, 2), &len, 2);\n\t\tmemcpy(skb_push(skb, ETH_ALEN), src, ETH_ALEN);\n\t\tmemcpy(skb_push(skb, ETH_ALEN), dst, ETH_ALEN);\n\t}\n\n#ifdef NOT_YET\n\tif (wds && ((fc & (IEEE80211_FCTL_TODS | IEEE80211_FCTL_FROMDS)) ==\n\t\t    IEEE80211_FCTL_TODS) && skb->len >= ETH_HLEN + ETH_ALEN) {\n\t\t/* Non-standard frame: get addr4 from its bogus location after\n\t\t * the payload */\n\t\tskb_copy_to_linear_data_offset(skb, ETH_ALEN,\n\t\t\t\t\t       skb->data + skb->len - ETH_ALEN,\n\t\t\t\t\t       ETH_ALEN);\n\t\tskb_trim(skb, skb->len - ETH_ALEN);\n\t}\n#endif\n\n\tstats->rx_packets++;\n\tstats->rx_bytes += skb->len;\n\n#ifdef NOT_YET\n\tif (ieee->iw_mode == IW_MODE_MASTER && !wds && ieee->ap->bridge_packets) {\n\t\tif (dst[0] & 0x01) {\n\t\t\t/* copy multicast frame both to the higher layers and\n\t\t\t * to the wireless media */\n\t\t\tieee->ap->bridged_multicast++;\n\t\t\tskb2 = skb_clone(skb, GFP_ATOMIC);\n\t\t\tif (skb2 == NULL)\n\t\t\t\tprintk(KERN_DEBUG \"%s: skb_clone failed for \"\n\t\t\t\t       \"multicast frame\\n\", dev->name);\n\t\t} else if (hostap_is_sta_assoc(ieee->ap, dst)) {\n\t\t\t/* send frame directly to the associated STA using\n\t\t\t * wireless media and not passing to higher layers */\n\t\t\tieee->ap->bridged_unicast++;\n\t\t\tskb2 = skb;\n\t\t\tskb = NULL;\n\t\t}\n\t}\n\n\tif (skb2 != NULL) {\n\t\t/* send to wireless media */\n\t\tskb2->dev = dev;\n\t\tskb2->protocol = __constant_htons(ETH_P_802_3);\n\t\tskb_reset_mac_header(skb2);\n\t\tskb_reset_network_header(skb2);\n\t\t/* skb2->network_header += ETH_HLEN; */\n\t\tdev_queue_xmit(skb2);\n\t}\n#endif\n\n\tif (skb) {\n\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\tmemset(skb->cb, 0, sizeof(skb->cb));\n\t\tskb->ip_summed = CHECKSUM_NONE;\t/* 802.11 crc not sufficient */\n\t\tif (netif_rx(skb) == NET_RX_DROP) {\n\t\t\t/* netif_rx always succeeds, but it might drop\n\t\t\t * the packet.  If it drops the packet, we log that\n\t\t\t * in our stats. */\n\t\t\tIEEE80211_DEBUG_DROP\n\t\t\t    (\"RX: netif_rx dropped the packet\\n\");\n\t\t\tstats->rx_dropped++;\n\t\t}\n\t}\n\n      rx_exit:\n#ifdef NOT_YET\n\tif (sta)\n\t\thostap_handle_sta_release(sta);\n#endif\n\treturn 1;\n\n      rx_dropped:\n\tstats->rx_dropped++;\n\n\t/* Returning 0 indicates to caller that we have not handled the SKB--\n\t * so it is still allocated and can be used again by underlying\n\t * hardware as a DMA target */\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static int do_dccp_getsockopt(struct sock *sk, int level, int optname,\n\t\t    char __user *optval, int __user *optlen)\n{\n\tstruct dccp_sock *dp;\n\tint val, len;\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tif (len < sizeof(int))\n\t\treturn -EINVAL;\n\n\tdp = dccp_sk(sk);\n\n\tswitch (optname) {\n\tcase DCCP_SOCKOPT_PACKET_SIZE:\n\t\tDCCP_WARN(\"sockopt(PACKET_SIZE) is deprecated: fix your app\\n\");\n\t\treturn 0;\n\tcase DCCP_SOCKOPT_SERVICE:\n\t\treturn dccp_getsockopt_service(sk, len,\n\t\t\t\t\t       (__be32 __user *)optval, optlen);\n\tcase DCCP_SOCKOPT_SEND_CSCOV:\n\t\tval = dp->dccps_pcslen;\n\t\tbreak;\n\tcase DCCP_SOCKOPT_RECV_CSCOV:\n\t\tval = dp->dccps_pcrlen;\n\t\tbreak;\n\tcase 128 ... 191:\n\t\treturn ccid_hc_rx_getsockopt(dp->dccps_hc_rx_ccid, sk, optname,\n\t\t\t\t\t     len, (u32 __user *)optval, optlen);\n\tcase 192 ... 255:\n\t\treturn ccid_hc_tx_getsockopt(dp->dccps_hc_tx_ccid, sk, optname,\n\t\t\t\t\t     len, (u32 __user *)optval, optlen);\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\n\tif (put_user(len, optlen) || copy_to_user(optval, &val, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static int jpc_qcx_getcompparms(jpc_qcxcp_t *compparms, jpc_cstate_t *cstate,\n  jas_stream_t *in, uint_fast16_t len)\n{\n\tuint_fast8_t tmp;\n\tint n;\n\tint i;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tn = 0;\n\tif (jpc_getuint8(in, &tmp)) {\n\t\treturn -1;\n\t}\n\t++n;\n\tcompparms->qntsty = tmp & 0x1f;\n\tcompparms->numguard = (tmp >> 5) & 7;\n\tswitch (compparms->qntsty) {\n\tcase JPC_QCX_SIQNT:\n\t\tcompparms->numstepsizes = 1;\n\t\tbreak;\n\tcase JPC_QCX_NOQNT:\n\t\tcompparms->numstepsizes = (len - n);\n\t\tbreak;\n\tcase JPC_QCX_SEQNT:\n\t\t/* XXX - this is a hack */\n\t\tcompparms->numstepsizes = (len - n) / 2;\n\t\tbreak;\n\t}\n\tif (compparms->numstepsizes > 0) {\n\t\tcompparms->stepsizes = jas_alloc2(compparms->numstepsizes,\n\t\t  sizeof(uint_fast16_t));\n\t\tassert(compparms->stepsizes);\n\t\tfor (i = 0; i < compparms->numstepsizes; ++i) {\n\t\t\tif (compparms->qntsty == JPC_QCX_NOQNT) {\n\t\t\t\tif (jpc_getuint8(in, &tmp)) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tcompparms->stepsizes[i] = JPC_QCX_EXPN(tmp >> 3);\n\t\t\t} else {\n\t\t\t\tif (jpc_getuint16(in, &compparms->stepsizes[i])) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tcompparms->stepsizes = 0;\n\t}\n\tif (jas_stream_error(in) || jas_stream_eof(in)) {\n\t\tjpc_qcx_destroycompparms(compparms);\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "isdn_net_setcfg(isdn_net_ioctl_cfg * cfg)\n{\n\tisdn_net_dev *p = isdn_net_findif(cfg->name);\n\tulong features;\n\tint i;\n\tint drvidx;\n\tint chidx;\n\tchar drvid[25];\n\n\tif (p) {\n\t\tisdn_net_local *lp = p->local;\n\n\t\t/* See if any registered driver supports the features we want */\n\t\tfeatures = ((1 << cfg->l2_proto) << ISDN_FEATURE_L2_SHIFT) |\n\t\t\t((1 << cfg->l3_proto) << ISDN_FEATURE_L3_SHIFT);\n\t\tfor (i = 0; i < ISDN_MAX_DRIVERS; i++)\n\t\t\tif (dev->drv[i])\n\t\t\t\tif ((dev->drv[i]->interface->features & features) == features)\n\t\t\t\t\tbreak;\n\t\tif (i == ISDN_MAX_DRIVERS) {\n\t\t\tprintk(KERN_WARNING \"isdn_net: No driver with selected features\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tif (lp->p_encap != cfg->p_encap){\n#ifdef CONFIG_ISDN_X25\n\t\t\tstruct concap_proto * cprot = p -> cprot;\n#endif\n\t\t\tif (isdn_net_device_started(p)) {\n\t\t\t\tprintk(KERN_WARNING \"%s: cannot change encap when if is up\\n\",\n\t\t\t\t       p->dev->name);\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n#ifdef CONFIG_ISDN_X25\n\t\t\tif( cprot && cprot -> pops )\n\t\t\t\tcprot -> pops -> proto_del ( cprot );\n\t\t\tp -> cprot = NULL;\n\t\t\tlp -> dops = NULL;\n\t\t\t/* ... ,  prepare for configuration of new one ... */\n\t\t\tswitch ( cfg -> p_encap ){\n\t\t\tcase ISDN_NET_ENCAP_X25IFACE:\n\t\t\t\tlp -> dops = &isdn_concap_reliable_dl_dops;\n\t\t\t}\n\t\t\t/* ... and allocate new one ... */\n\t\t\tp -> cprot = isdn_concap_new( cfg -> p_encap );\n\t\t\t/* p -> cprot == NULL now if p_encap is not supported\n\t\t\t   by means of the concap_proto mechanism */\n\t\t\t/* the protocol is not configured yet; this will\n\t\t\t   happen later when isdn_net_reset() is called */\n#endif\n\t\t}\n\t\tswitch ( cfg->p_encap ) {\n\t\tcase ISDN_NET_ENCAP_SYNCPPP:\n#ifndef CONFIG_ISDN_PPP\n\t\t\tprintk(KERN_WARNING \"%s: SyncPPP support not configured\\n\",\n\t\t\t       p->dev->name);\n\t\t\treturn -EINVAL;\n#else\n\t\t\tp->dev->type = ARPHRD_PPP;\t/* change ARP type */\n\t\t\tp->dev->addr_len = 0;\n\t\t\tp->dev->do_ioctl = isdn_ppp_dev_ioctl;\n#endif\n\t\t\tbreak;\n\t\tcase ISDN_NET_ENCAP_X25IFACE:\n#ifndef CONFIG_ISDN_X25\n\t\t\tprintk(KERN_WARNING \"%s: isdn-x25 support not configured\\n\",\n\t\t\t       p->dev->name);\n\t\t\treturn -EINVAL;\n#else\n\t\t\tp->dev->type = ARPHRD_X25;\t/* change ARP type */\n\t\t\tp->dev->addr_len = 0;\n#endif\n\t\t\tbreak;\n\t\tcase ISDN_NET_ENCAP_CISCOHDLCK:\n\t\t\tp->dev->do_ioctl = isdn_ciscohdlck_dev_ioctl;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif( cfg->p_encap >= 0 &&\n\t\t\t    cfg->p_encap <= ISDN_NET_ENCAP_MAX_ENCAP )\n\t\t\t\tbreak;\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"%s: encapsulation protocol %d not supported\\n\",\n\t\t\t       p->dev->name, cfg->p_encap);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (strlen(cfg->drvid)) {\n\t\t\t/* A bind has been requested ... */\n\t\t\tchar *c,\n\t\t\t*e;\n\n\t\t\tdrvidx = -1;\n\t\t\tchidx = -1;\n\t\t\tstrcpy(drvid, cfg->drvid);\n\t\t\tif ((c = strchr(drvid, ','))) {\n\t\t\t\t/* The channel-number is appended to the driver-Id with a comma */\n\t\t\t\tchidx = (int) simple_strtoul(c + 1, &e, 10);\n\t\t\t\tif (e == c)\n\t\t\t\t\tchidx = -1;\n\t\t\t\t*c = '\\0';\n\t\t\t}\n\t\t\tfor (i = 0; i < ISDN_MAX_DRIVERS; i++)\n\t\t\t\t/* Lookup driver-Id in array */\n\t\t\t\tif (!(strcmp(dev->drvid[i], drvid))) {\n\t\t\t\t\tdrvidx = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif ((drvidx == -1) || (chidx == -1))\n\t\t\t\t/* Either driver-Id or channel-number invalid */\n\t\t\t\treturn -ENODEV;\n\t\t} else {\n\t\t\t/* Parameters are valid, so get them */\n\t\t\tdrvidx = lp->pre_device;\n\t\t\tchidx = lp->pre_channel;\n\t\t}\n\t\tif (cfg->exclusive > 0) {\n\t\t\tunsigned long flags;\n\n\t\t\t/* If binding is exclusive, try to grab the channel */\n\t\t\tspin_lock_irqsave(&dev->lock, flags);\n\t\t\tif ((i = isdn_get_free_channel(ISDN_USAGE_NET,\n\t\t\t\tlp->l2_proto, lp->l3_proto, drvidx,\n\t\t\t\tchidx, lp->msn)) < 0) {\n\t\t\t\t/* Grab failed, because desired channel is in use */\n\t\t\t\tlp->exclusive = -1;\n\t\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\t\t\t/* All went ok, so update isdninfo */\n\t\t\tdev->usage[i] = ISDN_USAGE_EXCLUSIVE;\n\t\t\tisdn_info_update();\n\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\tlp->exclusive = i;\n\t\t} else {\n\t\t\t/* Non-exclusive binding or unbind. */\n\t\t\tlp->exclusive = -1;\n\t\t\tif ((lp->pre_device != -1) && (cfg->exclusive == -1)) {\n\t\t\t\tisdn_unexclusive_channel(lp->pre_device, lp->pre_channel);\n\t\t\t\tisdn_free_channel(lp->pre_device, lp->pre_channel, ISDN_USAGE_NET);\n\t\t\t\tdrvidx = -1;\n\t\t\t\tchidx = -1;\n\t\t\t}\n\t\t}\n\t\tstrcpy(lp->msn, cfg->eaz);\n\t\tlp->pre_device = drvidx;\n\t\tlp->pre_channel = chidx;\n\t\tlp->onhtime = cfg->onhtime;\n\t\tlp->charge = cfg->charge;\n\t\tlp->l2_proto = cfg->l2_proto;\n\t\tlp->l3_proto = cfg->l3_proto;\n\t\tlp->cbdelay = cfg->cbdelay;\n\t\tlp->dialmax = cfg->dialmax;\n\t\tlp->triggercps = cfg->triggercps;\n\t\tlp->slavedelay = cfg->slavedelay * HZ;\n\t\tlp->pppbind = cfg->pppbind;\n\t\tlp->dialtimeout = cfg->dialtimeout >= 0 ? cfg->dialtimeout * HZ : -1;\n\t\tlp->dialwait = cfg->dialwait * HZ;\n\t\tif (cfg->secure)\n\t\t\tlp->flags |= ISDN_NET_SECURE;\n\t\telse\n\t\t\tlp->flags &= ~ISDN_NET_SECURE;\n\t\tif (cfg->cbhup)\n\t\t\tlp->flags |= ISDN_NET_CBHUP;\n\t\telse\n\t\t\tlp->flags &= ~ISDN_NET_CBHUP;\n\t\tswitch (cfg->callback) {\n\t\t\tcase 0:\n\t\t\t\tlp->flags &= ~(ISDN_NET_CALLBACK | ISDN_NET_CBOUT);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tlp->flags |= ISDN_NET_CALLBACK;\n\t\t\t\tlp->flags &= ~ISDN_NET_CBOUT;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tlp->flags |= ISDN_NET_CBOUT;\n\t\t\t\tlp->flags &= ~ISDN_NET_CALLBACK;\n\t\t\t\tbreak;\n\t\t}\n\t\tlp->flags &= ~ISDN_NET_DIALMODE_MASK;\t/* first all bits off */\n\t\tif (cfg->dialmode && !(cfg->dialmode & ISDN_NET_DIALMODE_MASK)) {\n\t\t\t/* old isdnctrl version, where only 0 or 1 is given */\n\t\t\tprintk(KERN_WARNING\n\t\t\t     \"Old isdnctrl version detected! Please update.\\n\");\n\t\t\tlp->flags |= ISDN_NET_DM_OFF; /* turn on `off' bit */\n\t\t}\n\t\telse {\n\t\t\tlp->flags |= cfg->dialmode;  /* turn on selected bits */\n\t\t}\n\t\tif (cfg->chargehup)\n\t\t\tlp->hupflags |= ISDN_CHARGEHUP;\n\t\telse\n\t\t\tlp->hupflags &= ~ISDN_CHARGEHUP;\n\t\tif (cfg->ihup)\n\t\t\tlp->hupflags |= ISDN_INHUP;\n\t\telse\n\t\t\tlp->hupflags &= ~ISDN_INHUP;\n\t\tif (cfg->chargeint > 10) {\n\t\t\tlp->hupflags |= ISDN_CHARGEHUP | ISDN_HAVECHARGE | ISDN_MANCHARGE;\n\t\t\tlp->chargeint = cfg->chargeint * HZ;\n\t\t}\n\t\tif (cfg->p_encap != lp->p_encap) {\n\t\t\tif (cfg->p_encap == ISDN_NET_ENCAP_RAWIP) {\n\t\t\t\tp->dev->header_ops = NULL;\n\t\t\t\tp->dev->flags = IFF_NOARP|IFF_POINTOPOINT;\n\t\t\t} else {\n\t\t\t\tp->dev->header_ops = &isdn_header_ops;\n\t\t\t\tif (cfg->p_encap == ISDN_NET_ENCAP_ETHER)\n\t\t\t\t\tp->dev->flags = IFF_BROADCAST | IFF_MULTICAST;\n\t\t\t\telse\n\t\t\t\t\tp->dev->flags = IFF_NOARP|IFF_POINTOPOINT;\n\t\t\t}\n\t\t}\n\t\tlp->p_encap = cfg->p_encap;\n\t\treturn 0;\n\t}\n\treturn -ENODEV;\n}",
        "target": 1
    },
    {
        "func": "isdn_net_addphone(isdn_net_ioctl_phone * phone)\n{\n\tisdn_net_dev *p = isdn_net_findif(phone->name);\n\tisdn_net_phone *n;\n\n\tif (p) {\n\t\tif (!(n = kmalloc(sizeof(isdn_net_phone), GFP_KERNEL)))\n\t\t\treturn -ENOMEM;\n\t\tstrcpy(n->num, phone->phone);\n\t\tn->next = p->local->phone[phone->outgoing & 1];\n\t\tp->local->phone[phone->outgoing & 1] = n;\n\t\treturn 0;\n\t}\n\treturn -ENODEV;\n}",
        "target": 1
    },
    {
        "func": "isdn_net_find_icall(int di, int ch, int idx, setup_parm *setup)\n{\n\tchar *eaz;\n\tint si1;\n\tint si2;\n\tint ematch;\n\tint wret;\n\tint swapped;\n\tint sidx = 0;\n\tu_long flags;\n\tisdn_net_dev *p;\n\tisdn_net_phone *n;\n\tchar nr[32];\n\tchar *my_eaz;\n\n\t/* Search name in netdev-chain */\n\tif (!setup->phone[0]) {\n\t\tnr[0] = '0';\n\t\tnr[1] = '\\0';\n\t\tprintk(KERN_INFO \"isdn_net: Incoming call without OAD, assuming '0'\\n\");\n\t} else\n\t\tstrcpy(nr, setup->phone);\n\tsi1 = (int) setup->si1;\n\tsi2 = (int) setup->si2;\n\tif (!setup->eazmsn[0]) {\n\t\tprintk(KERN_WARNING \"isdn_net: Incoming call without CPN, assuming '0'\\n\");\n\t\teaz = \"0\";\n\t} else\n\t\teaz = setup->eazmsn;\n\tif (dev->net_verbose > 1)\n\t\tprintk(KERN_INFO \"isdn_net: call from %s,%d,%d -> %s\\n\", nr, si1, si2, eaz);\n\t/* Accept DATA and VOICE calls at this stage\n\t * local eaz is checked later for allowed call types\n\t */\n\tif ((si1 != 7) && (si1 != 1)) {\n\t\tif (dev->net_verbose > 1)\n\t\t\tprintk(KERN_INFO \"isdn_net: Service-Indicator not 1 or 7, ignored\\n\");\n\t\treturn 0;\n\t}\n\tn = (isdn_net_phone *) 0;\n\tp = dev->netdev;\n\tematch = wret = swapped = 0;\n#ifdef ISDN_DEBUG_NET_ICALL\n\tprintk(KERN_DEBUG \"n_fi: di=%d ch=%d idx=%d usg=%d\\n\", di, ch, idx,\n\t\tdev->usage[idx]);\n#endif\n\twhile (p) {\n\t\tint matchret;\n\t\tisdn_net_local *lp = p->local;\n\n\t\t/* If last check has triggered as binding-swap, revert it */\n\t\tswitch (swapped) {\n\t\t\tcase 2:\n\t\t\t\tisdn_net_swap_usage(idx, sidx);\n\t\t\t\t/* fall through */\n\t\t\tcase 1:\n\t\t\t\tisdn_net_swapbind(di);\n\t\t\t\tbreak;\n\t\t}\n\t\tswapped = 0;\n                /* check acceptable call types for DOV */\n                my_eaz = isdn_map_eaz2msn(lp->msn, di);\n                if (si1 == 1) { /* it's a DOV call, check if we allow it */\n                        if (*my_eaz == 'v' || *my_eaz == 'V' ||\n\t\t\t    *my_eaz == 'b' || *my_eaz == 'B')\n                                my_eaz++; /* skip to allow a match */\n                        else\n                                my_eaz = NULL; /* force non match */\n                } else { /* it's a DATA call, check if we allow it */\n                        if (*my_eaz == 'b' || *my_eaz == 'B')\n                                my_eaz++; /* skip to allow a match */\n                }\n                if (my_eaz)\n                        matchret = isdn_msncmp(eaz, my_eaz);\n                else\n                        matchret = 1;\n                if (!matchret)\n                        ematch = 1;\n\n\t\t/* Remember if more numbers eventually can match */\n\t\tif (matchret > wret)\n\t\t\twret = matchret;\n#ifdef ISDN_DEBUG_NET_ICALL\n\t\tprintk(KERN_DEBUG \"n_fi: if='%s', l.msn=%s, l.flags=%d, l.dstate=%d\\n\",\n\t\t       p->dev->name, lp->msn, lp->flags, lp->dialstate);\n#endif\n\t\tif ((!matchret) &&                                        /* EAZ is matching   */\n\t\t    (((!(lp->flags & ISDN_NET_CONNECTED)) &&              /* but not connected */\n\t\t      (USG_NONE(dev->usage[idx]))) ||                     /* and ch. unused or */\n\t\t     ((((lp->dialstate == 4) || (lp->dialstate == 12)) && /* if dialing        */\n\t\t       (!(lp->flags & ISDN_NET_CALLBACK)))                /* but no callback   */\n\t\t     )))\n\t\t\t {\n#ifdef ISDN_DEBUG_NET_ICALL\n\t\t\tprintk(KERN_DEBUG \"n_fi: match1, pdev=%d pch=%d\\n\",\n\t\t\t       lp->pre_device, lp->pre_channel);\n#endif\n\t\t\tif (dev->usage[idx] & ISDN_USAGE_EXCLUSIVE) {\n\t\t\t\tif ((lp->pre_channel != ch) ||\n\t\t\t\t    (lp->pre_device != di)) {\n\t\t\t\t\t/* Here we got a problem:\n\t\t\t\t\t * If using an ICN-Card, an incoming call is always signaled on\n\t\t\t\t\t * on the first channel of the card, if both channels are\n\t\t\t\t\t * down. However this channel may be bound exclusive. If the\n\t\t\t\t\t * second channel is free, this call should be accepted.\n\t\t\t\t\t * The solution is horribly but it runs, so what:\n\t\t\t\t\t * We exchange the exclusive bindings of the two channels, the\n\t\t\t\t\t * corresponding variables in the interface-structs.\n\t\t\t\t\t */\n\t\t\t\t\tif (ch == 0) {\n\t\t\t\t\t\tsidx = isdn_dc2minor(di, 1);\n#ifdef ISDN_DEBUG_NET_ICALL\n\t\t\t\t\t\tprintk(KERN_DEBUG \"n_fi: ch is 0\\n\");\n#endif\n\t\t\t\t\t\tif (USG_NONE(dev->usage[sidx])) {\n\t\t\t\t\t\t\t/* Second Channel is free, now see if it is bound\n\t\t\t\t\t\t\t * exclusive too. */\n\t\t\t\t\t\t\tif (dev->usage[sidx] & ISDN_USAGE_EXCLUSIVE) {\n#ifdef ISDN_DEBUG_NET_ICALL\n\t\t\t\t\t\t\t\tprintk(KERN_DEBUG \"n_fi: 2nd channel is down and bound\\n\");\n#endif\n\t\t\t\t\t\t\t\t/* Yes, swap bindings only, if the original\n\t\t\t\t\t\t\t\t * binding is bound to channel 1 of this driver */\n\t\t\t\t\t\t\t\tif ((lp->pre_device == di) &&\n\t\t\t\t\t\t\t\t    (lp->pre_channel == 1)) {\n\t\t\t\t\t\t\t\t\tisdn_net_swapbind(di);\n\t\t\t\t\t\t\t\t\tswapped = 1;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t/* ... else iterate next device */\n\t\t\t\t\t\t\t\t\tp = (isdn_net_dev *) p->next;\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n#ifdef ISDN_DEBUG_NET_ICALL\n\t\t\t\t\t\t\t\tprintk(KERN_DEBUG \"n_fi: 2nd channel is down and unbound\\n\");\n#endif\n\t\t\t\t\t\t\t\t/* No, swap always and swap excl-usage also */\n\t\t\t\t\t\t\t\tisdn_net_swap_usage(idx, sidx);\n\t\t\t\t\t\t\t\tisdn_net_swapbind(di);\n\t\t\t\t\t\t\t\tswapped = 2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t/* Now check for exclusive binding again */\n#ifdef ISDN_DEBUG_NET_ICALL\n\t\t\t\t\t\t\tprintk(KERN_DEBUG \"n_fi: final check\\n\");\n#endif\n\t\t\t\t\t\t\tif ((dev->usage[idx] & ISDN_USAGE_EXCLUSIVE) &&\n\t\t\t\t\t\t\t    ((lp->pre_channel != ch) ||\n\t\t\t\t\t\t\t     (lp->pre_device != di))) {\n#ifdef ISDN_DEBUG_NET_ICALL\n\t\t\t\t\t\t\t\tprintk(KERN_DEBUG \"n_fi: final check failed\\n\");\n#endif\n\t\t\t\t\t\t\t\tp = (isdn_net_dev *) p->next;\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* We are already on the second channel, so nothing to do */\n#ifdef ISDN_DEBUG_NET_ICALL\n\t\t\t\t\t\tprintk(KERN_DEBUG \"n_fi: already on 2nd channel\\n\");\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n#ifdef ISDN_DEBUG_NET_ICALL\n\t\t\tprintk(KERN_DEBUG \"n_fi: match2\\n\");\n#endif\n\t\t\tn = lp->phone[0];\n\t\t\tif (lp->flags & ISDN_NET_SECURE) {\n\t\t\t\twhile (n) {\n\t\t\t\t\tif (!isdn_msncmp(nr, n->num))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tn = (isdn_net_phone *) n->next;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (n || (!(lp->flags & ISDN_NET_SECURE))) {\n#ifdef ISDN_DEBUG_NET_ICALL\n\t\t\t\tprintk(KERN_DEBUG \"n_fi: match3\\n\");\n#endif\n\t\t\t\t/* matching interface found */\n\n\t\t\t\t/*\n\t\t\t\t * Is the state STOPPED?\n\t\t\t\t * If so, no dialin is allowed,\n\t\t\t\t * so reject actively.\n\t\t\t\t * */\n\t\t\t\tif (ISDN_NET_DIALMODE(*lp) == ISDN_NET_DM_OFF) {\n\t\t\t\t\tprintk(KERN_INFO \"incoming call, interface %s `stopped' -> rejected\\n\",\n\t\t\t\t\t       p->dev->name);\n\t\t\t\t\treturn 3;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Is the interface up?\n\t\t\t\t * If not, reject the call actively.\n\t\t\t\t */\n\t\t\t\tif (!isdn_net_device_started(p)) {\n\t\t\t\t\tprintk(KERN_INFO \"%s: incoming call, interface down -> rejected\\n\",\n\t\t\t\t\t       p->dev->name);\n\t\t\t\t\treturn 3;\n\t\t\t\t}\n\t\t\t\t/* Interface is up, now see if it's a slave. If so, see if\n\t\t\t\t * it's master and parent slave is online. If not, reject the call.\n\t\t\t\t */\n\t\t\t\tif (lp->master) {\n\t\t\t\t\tisdn_net_local *mlp = (isdn_net_local *) lp->master->priv;\n\t\t\t\t\tprintk(KERN_DEBUG \"ICALLslv: %s\\n\", p->dev->name);\n\t\t\t\t\tprintk(KERN_DEBUG \"master=%s\\n\", lp->master->name);\n\t\t\t\t\tif (mlp->flags & ISDN_NET_CONNECTED) {\n\t\t\t\t\t\tprintk(KERN_DEBUG \"master online\\n\");\n\t\t\t\t\t\t/* Master is online, find parent-slave (master if first slave) */\n\t\t\t\t\t\twhile (mlp->slave) {\n\t\t\t\t\t\t\tif ((isdn_net_local *) mlp->slave->priv == lp)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tmlp = (isdn_net_local *) mlp->slave->priv;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else\n\t\t\t\t\t\tprintk(KERN_DEBUG \"master offline\\n\");\n\t\t\t\t\t/* Found parent, if it's offline iterate next device */\n\t\t\t\t\tprintk(KERN_DEBUG \"mlpf: %d\\n\", mlp->flags & ISDN_NET_CONNECTED);\n\t\t\t\t\tif (!(mlp->flags & ISDN_NET_CONNECTED)) {\n\t\t\t\t\t\tp = (isdn_net_dev *) p->next;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t} \n\t\t\t\tif (lp->flags & ISDN_NET_CALLBACK) {\n\t\t\t\t\tint chi;\n\t\t\t\t\t/*\n\t\t\t\t\t * Is the state MANUAL?\n\t\t\t\t\t * If so, no callback can be made,\n\t\t\t\t\t * so reject actively.\n\t\t\t\t\t * */\n\t\t\t\t\tif (ISDN_NET_DIALMODE(*lp) == ISDN_NET_DM_OFF) {\n\t\t\t\t\t\tprintk(KERN_INFO \"incoming call for callback, interface %s `off' -> rejected\\n\",\n\t\t\t\t\t\t       p->dev->name);\n\t\t\t\t\t\treturn 3;\n\t\t\t\t\t}\n\t\t\t\t\tprintk(KERN_DEBUG \"%s: call from %s -> %s, start callback\\n\",\n\t\t\t\t\t       p->dev->name, nr, eaz);\n\t\t\t\t\tif (lp->phone[1]) {\n\t\t\t\t\t\t/* Grab a free ISDN-Channel */\n\t\t\t\t\t\tspin_lock_irqsave(&dev->lock, flags);\n\t\t\t\t\t\tif ((chi = \n\t\t\t\t\t\t\tisdn_get_free_channel(\n\t\t\t\t\t\t\t\tISDN_USAGE_NET,\n\t\t\t\t\t\t\t\tlp->l2_proto,\n\t\t\t\t\t\t\t\tlp->l3_proto,\n\t\t\t\t\t\t\t  \tlp->pre_device,\n\t\t\t\t\t\t \t\tlp->pre_channel,\n\t\t\t\t\t\t \t\tlp->msn)\n\t\t\t\t\t\t\t\t) < 0) {\n\n\t\t\t\t\t\t\tprintk(KERN_WARNING \"isdn_net_find_icall: No channel for %s\\n\",\n\t\t\t\t\t\t\t\tp->dev->name);\n\t\t\t\t\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* Setup dialstate. */\n\t\t\t\t\t\tlp->dtimer = 0;\n\t\t\t\t\t\tlp->dialstate = 11;\n\t\t\t\t\t\t/* Connect interface with channel */\n\t\t\t\t\t\tisdn_net_bind_channel(lp, chi);\n#ifdef CONFIG_ISDN_PPP\n\t\t\t\t\t\tif (lp->p_encap == ISDN_NET_ENCAP_SYNCPPP)\n\t\t\t\t\t\t\tif (isdn_ppp_bind(lp) < 0) {\n\t\t\t\t\t\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\t\t\t\t\t\tisdn_net_unbind_channel(lp);\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\t\t\t\t/* Initiate dialing by returning 2 or 4 */\n\t\t\t\t\t\treturn (lp->flags & ISDN_NET_CBHUP) ? 2 : 4;\n\t\t\t\t\t} else\n\t\t\t\t\t\tprintk(KERN_WARNING \"isdn_net: %s: No phone number\\n\",\n\t\t\t\t\t\t\tp->dev->name);\n\t\t\t\t\treturn 0;\n\t\t\t\t} else {\n\t\t\t\t\tprintk(KERN_DEBUG \"%s: call from %s -> %s accepted\\n\",\n\t\t\t\t\t\tp->dev->name, nr, eaz);\n\t\t\t\t\t/* if this interface is dialing, it does it probably on a different\n\t\t\t\t\t   device, so free this device */\n\t\t\t\t\tif ((lp->dialstate == 4) || (lp->dialstate == 12)) {\n#ifdef CONFIG_ISDN_PPP\n\t\t\t\t\t\tif (lp->p_encap == ISDN_NET_ENCAP_SYNCPPP)\n\t\t\t\t\t\t\tisdn_ppp_free(lp);\n#endif\n\t\t\t\t\t\tisdn_net_lp_disconnected(lp);\n\t\t\t\t\t\tisdn_free_channel(lp->isdn_device, lp->isdn_channel,\n\t\t\t\t\t\t\t ISDN_USAGE_NET);\n\t\t\t\t\t}\n\t\t\t\t\tspin_lock_irqsave(&dev->lock, flags);\n\t\t\t\t\tdev->usage[idx] &= ISDN_USAGE_EXCLUSIVE;\n\t\t\t\t\tdev->usage[idx] |= ISDN_USAGE_NET;\n\t\t\t\t\tstrcpy(dev->num[idx], nr);\n\t\t\t\t\tisdn_info_update();\n\t\t\t\t\tdev->st_netdev[idx] = lp->netdev;\n\t\t\t\t\tlp->isdn_device = di;\n\t\t\t\t\tlp->isdn_channel = ch;\n\t\t\t\t\tlp->ppp_slot = -1;\n\t\t\t\t\tlp->flags |= ISDN_NET_CONNECTED;\n\t\t\t\t\tlp->dialstate = 7;\n\t\t\t\t\tlp->dtimer = 0;\n\t\t\t\t\tlp->outgoing = 0;\n\t\t\t\t\tlp->huptimer = 0;\n\t\t\t\t\tlp->hupflags |= ISDN_WAITCHARGE;\n\t\t\t\t\tlp->hupflags &= ~ISDN_HAVECHARGE;\n#ifdef CONFIG_ISDN_PPP\n\t\t\t\t\tif (lp->p_encap == ISDN_NET_ENCAP_SYNCPPP) {\n\t\t\t\t\t\tif (isdn_ppp_bind(lp) < 0) {\n\t\t\t\t\t\t\tisdn_net_unbind_channel(lp);\n\t\t\t\t\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tp = (isdn_net_dev *) p->next;\n\t}\n\t/* If none of configured EAZ/MSN matched and not verbose, be silent */\n\tif (!ematch || dev->net_verbose)\n\t\tprintk(KERN_INFO \"isdn_net: call from %s -> %d %s ignored\\n\", nr, di, eaz);\n\treturn (wret == 2)?5:0;\n}",
        "target": 1
    },
    {
        "func": "static int esp6_input(struct xfrm_state *x, struct sk_buff *skb)\n{\n\tstruct ip_esp_hdr *esph;\n\tstruct esp_data *esp = x->data;\n\tstruct crypto_aead *aead = esp->aead;\n\tstruct aead_request *req;\n\tstruct sk_buff *trailer;\n\tint elen = skb->len - sizeof(*esph) - crypto_aead_ivsize(aead);\n\tint nfrags;\n\tint ret = 0;\n\tvoid *tmp;\n\tu8 *iv;\n\tstruct scatterlist *sg;\n\tstruct scatterlist *asg;\n\n\tif (!pskb_may_pull(skb, sizeof(*esph))) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (elen <= 0) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif ((nfrags = skb_cow_data(skb, 0, &trailer)) < 0) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = -ENOMEM;\n\ttmp = esp_alloc_tmp(aead, nfrags + 1);\n\tif (!tmp)\n\t\tgoto out;\n\n\tESP_SKB_CB(skb)->tmp = tmp;\n\tiv = esp_tmp_iv(aead, tmp);\n\treq = esp_tmp_req(aead, iv);\n\tasg = esp_req_sg(aead, req);\n\tsg = asg + 1;\n\n\tskb->ip_summed = CHECKSUM_NONE;\n\n\tesph = (struct ip_esp_hdr *)skb->data;\n\n\t/* Get ivec. This can be wrong, check against another impls. */\n\tiv = esph->enc_data;\n\n\tsg_init_table(sg, nfrags);\n\tskb_to_sgvec(skb, sg, sizeof(*esph) + crypto_aead_ivsize(aead), elen);\n\tsg_init_one(asg, esph, sizeof(*esph));\n\n\taead_request_set_callback(req, 0, esp_input_done, skb);\n\taead_request_set_crypt(req, sg, sg, elen, iv);\n\taead_request_set_assoc(req, asg, sizeof(*esph));\n\n\tret = crypto_aead_decrypt(req);\n\tif (ret == -EINPROGRESS)\n\t\tgoto out;\n\n\tret = esp_input_done2(skb, ret);\n\nout:\n\treturn ret;\n}",
        "target": 1
    },
    {
        "func": "static int esp_input(struct xfrm_state *x, struct sk_buff *skb)\n{\n\tstruct ip_esp_hdr *esph;\n\tstruct esp_data *esp = x->data;\n\tstruct crypto_aead *aead = esp->aead;\n\tstruct aead_request *req;\n\tstruct sk_buff *trailer;\n\tint elen = skb->len - sizeof(*esph) - crypto_aead_ivsize(aead);\n\tint nfrags;\n\tvoid *tmp;\n\tu8 *iv;\n\tstruct scatterlist *sg;\n\tstruct scatterlist *asg;\n\tint err = -EINVAL;\n\n\tif (!pskb_may_pull(skb, sizeof(*esph)))\n\t\tgoto out;\n\n\tif (elen <= 0)\n\t\tgoto out;\n\n\tif ((err = skb_cow_data(skb, 0, &trailer)) < 0)\n\t\tgoto out;\n\tnfrags = err;\n\n\terr = -ENOMEM;\n\ttmp = esp_alloc_tmp(aead, nfrags + 1);\n\tif (!tmp)\n\t\tgoto out;\n\n\tESP_SKB_CB(skb)->tmp = tmp;\n\tiv = esp_tmp_iv(aead, tmp);\n\treq = esp_tmp_req(aead, iv);\n\tasg = esp_req_sg(aead, req);\n\tsg = asg + 1;\n\n\tskb->ip_summed = CHECKSUM_NONE;\n\n\tesph = (struct ip_esp_hdr *)skb->data;\n\n\t/* Get ivec. This can be wrong, check against another impls. */\n\tiv = esph->enc_data;\n\n\tsg_init_table(sg, nfrags);\n\tskb_to_sgvec(skb, sg, sizeof(*esph) + crypto_aead_ivsize(aead), elen);\n\tsg_init_one(asg, esph, sizeof(*esph));\n\n\taead_request_set_callback(req, 0, esp_input_done, skb);\n\taead_request_set_crypt(req, sg, sg, elen, iv);\n\taead_request_set_assoc(req, asg, sizeof(*esph));\n\n\terr = crypto_aead_decrypt(req);\n\tif (err == -EINPROGRESS)\n\t\tgoto out;\n\n\terr = esp_input_done2(skb, err);\n\nout:\n\treturn err;\n}",
        "target": 1
    },
    {
        "func": "isdn_ioctl(struct inode *inode, struct file *file, uint cmd, ulong arg)\n{\n\tuint minor = iminor(inode);\n\tisdn_ctrl c;\n\tint drvidx;\n\tint chidx;\n\tint ret;\n\tint i;\n\tchar __user *p;\n\tchar *s;\n\tunion iocpar {\n\t\tchar name[10];\n\t\tchar bname[22];\n\t\tisdn_ioctl_struct iocts;\n\t\tisdn_net_ioctl_phone phone;\n\t\tisdn_net_ioctl_cfg cfg;\n\t} iocpar;\n\tvoid __user *argp = (void __user *)arg;\n\n#define name  iocpar.name\n#define bname iocpar.bname\n#define iocts iocpar.iocts\n#define phone iocpar.phone\n#define cfg   iocpar.cfg\n\n\tif (minor == ISDN_MINOR_STATUS) {\n\t\tswitch (cmd) {\n\t\t\tcase IIOCGETDVR:\n\t\t\t\treturn (TTY_DV +\n\t\t\t\t\t(NET_DV << 8) +\n\t\t\t\t\t(INF_DV << 16));\n\t\t\tcase IIOCGETCPS:\n\t\t\t\tif (arg) {\n\t\t\t\t\tulong __user *p = argp;\n\t\t\t\t\tint i;\n\t\t\t\t\tif (!access_ok(VERIFY_WRITE, p,\n\t\t\t\t\t\t\tsizeof(ulong) * ISDN_MAX_CHANNELS * 2))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\n\t\t\t\t\t\tput_user(dev->ibytes[i], p++);\n\t\t\t\t\t\tput_user(dev->obytes[i], p++);\n\t\t\t\t\t}\n\t\t\t\t\treturn 0;\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n#ifdef CONFIG_NETDEVICES\n\t\t\tcase IIOCNETGPN:\n\t\t\t\t/* Get peer phone number of a connected \n\t\t\t\t * isdn network interface */\n\t\t\t\tif (arg) {\n\t\t\t\t\tif (copy_from_user(&phone, argp, sizeof(phone)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\treturn isdn_net_getpeer(&phone, argp);\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n#endif\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (!dev->drivers)\n\t\treturn -ENODEV;\n\tif (minor <= ISDN_MINOR_BMAX) {\n\t\tdrvidx = isdn_minor2drv(minor);\n\t\tif (drvidx < 0)\n\t\t\treturn -ENODEV;\n\t\tchidx = isdn_minor2chan(minor);\n\t\tif (!(dev->drv[drvidx]->flags & DRV_FLAG_RUNNING))\n\t\t\treturn -ENODEV;\n\t\treturn 0;\n\t}\n\tif (minor <= ISDN_MINOR_CTRLMAX) {\n/*\n * isdn net devices manage lots of configuration variables as linked lists.\n * Those lists must only be manipulated from user space. Some of the ioctl's\n * service routines access user space and are not atomic. Therefor, ioctl's\n * manipulating the lists and ioctl's sleeping while accessing the lists\n * are serialized by means of a semaphore.\n */\n\t\tswitch (cmd) {\n\t\t\tcase IIOCNETDWRSET:\n\t\t\t\tprintk(KERN_INFO \"INFO: ISDN_DW_ABC_EXTENSION not enabled\\n\");\n\t\t\t\treturn(-EINVAL);\n\t\t\tcase IIOCNETLCR:\n\t\t\t\tprintk(KERN_INFO \"INFO: ISDN_ABC_LCR_SUPPORT not enabled\\n\");\n\t\t\t\treturn -ENODEV;\n#ifdef CONFIG_NETDEVICES\n\t\t\tcase IIOCNETAIF:\n\t\t\t\t/* Add a network-interface */\n\t\t\t\tif (arg) {\n\t\t\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\ts = name;\n\t\t\t\t} else {\n\t\t\t\t\ts = NULL;\n\t\t\t\t}\n\t\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\t\tif( ret ) return ret;\n\t\t\t\tif ((s = isdn_net_new(s, NULL))) {\n\t\t\t\t\tif (copy_to_user(argp, s, strlen(s) + 1)){\n\t\t\t\t\t\tret = -EFAULT;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tret = 0;\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t\tret = -ENODEV;\n\t\t\t\tmutex_unlock(&dev->mtx);\n\t\t\t\treturn ret;\n\t\t\tcase IIOCNETASL:\n\t\t\t\t/* Add a slave to a network-interface */\n\t\t\t\tif (arg) {\n\t\t\t\t\tif (copy_from_user(bname, argp, sizeof(bname) - 1))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\t\tif( ret ) return ret;\n\t\t\t\tif ((s = isdn_net_newslave(bname))) {\n\t\t\t\t\tif (copy_to_user(argp, s, strlen(s) + 1)){\n\t\t\t\t\t\tret = -EFAULT;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tret = 0;\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t\tret = -ENODEV;\n\t\t\t\tmutex_unlock(&dev->mtx);\n\t\t\t\treturn ret;\n\t\t\tcase IIOCNETDIF:\n\t\t\t\t/* Delete a network-interface */\n\t\t\t\tif (arg) {\n\t\t\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\t\t\tif( ret ) return ret;\n\t\t\t\t\tret = isdn_net_rm(name);\n\t\t\t\t\tmutex_unlock(&dev->mtx);\n\t\t\t\t\treturn ret;\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n\t\t\tcase IIOCNETSCF:\n\t\t\t\t/* Set configurable parameters of a network-interface */\n\t\t\t\tif (arg) {\n\t\t\t\t\tif (copy_from_user(&cfg, argp, sizeof(cfg)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\treturn isdn_net_setcfg(&cfg);\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n\t\t\tcase IIOCNETGCF:\n\t\t\t\t/* Get configurable parameters of a network-interface */\n\t\t\t\tif (arg) {\n\t\t\t\t\tif (copy_from_user(&cfg, argp, sizeof(cfg)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tif (!(ret = isdn_net_getcfg(&cfg))) {\n\t\t\t\t\t\tif (copy_to_user(argp, &cfg, sizeof(cfg)))\n\t\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\t}\n\t\t\t\t\treturn ret;\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n\t\t\tcase IIOCNETANM:\n\t\t\t\t/* Add a phone-number to a network-interface */\n\t\t\t\tif (arg) {\n\t\t\t\t\tif (copy_from_user(&phone, argp, sizeof(phone)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\t\t\tif( ret ) return ret;\n\t\t\t\t\tret = isdn_net_addphone(&phone);\n\t\t\t\t\tmutex_unlock(&dev->mtx);\n\t\t\t\t\treturn ret;\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n\t\t\tcase IIOCNETGNM:\n\t\t\t\t/* Get list of phone-numbers of a network-interface */\n\t\t\t\tif (arg) {\n\t\t\t\t\tif (copy_from_user(&phone, argp, sizeof(phone)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\t\t\tif( ret ) return ret;\n\t\t\t\t\tret = isdn_net_getphones(&phone, argp);\n\t\t\t\t\tmutex_unlock(&dev->mtx);\n\t\t\t\t\treturn ret;\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n\t\t\tcase IIOCNETDNM:\n\t\t\t\t/* Delete a phone-number of a network-interface */\n\t\t\t\tif (arg) {\n\t\t\t\t\tif (copy_from_user(&phone, argp, sizeof(phone)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\t\t\tif( ret ) return ret;\n\t\t\t\t\tret = isdn_net_delphone(&phone);\n\t\t\t\t\tmutex_unlock(&dev->mtx);\n\t\t\t\t\treturn ret;\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n\t\t\tcase IIOCNETDIL:\n\t\t\t\t/* Force dialing of a network-interface */\n\t\t\t\tif (arg) {\n\t\t\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\treturn isdn_net_force_dial(name);\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n#ifdef CONFIG_ISDN_PPP\n\t\t\tcase IIOCNETALN:\n\t\t\t\tif (!arg)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn isdn_ppp_dial_slave(name);\n\t\t\tcase IIOCNETDLN:\n\t\t\t\tif (!arg)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn isdn_ppp_hangup_slave(name);\n#endif\n\t\t\tcase IIOCNETHUP:\n\t\t\t\t/* Force hangup of a network-interface */\n\t\t\t\tif (!arg)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn isdn_net_force_hangup(name);\n\t\t\t\tbreak;\n#endif                          /* CONFIG_NETDEVICES */\n\t\t\tcase IIOCSETVER:\n\t\t\t\tdev->net_verbose = arg;\n\t\t\t\tprintk(KERN_INFO \"isdn: Verbose-Level is %d\\n\", dev->net_verbose);\n\t\t\t\treturn 0;\n\t\t\tcase IIOCSETGST:\n\t\t\t\tif (arg)\n\t\t\t\t\tdev->global_flags |= ISDN_GLOBAL_STOPPED;\n\t\t\t\telse\n\t\t\t\t\tdev->global_flags &= ~ISDN_GLOBAL_STOPPED;\n\t\t\t\tprintk(KERN_INFO \"isdn: Global Mode %s\\n\",\n\t\t\t\t       (dev->global_flags & ISDN_GLOBAL_STOPPED) ? \"stopped\" : \"running\");\n\t\t\t\treturn 0;\n\t\t\tcase IIOCSETBRJ:\n\t\t\t\tdrvidx = -1;\n\t\t\t\tif (arg) {\n\t\t\t\t\tint i;\n\t\t\t\t\tchar *p;\n\t\t\t\t\tif (copy_from_user(&iocts, argp,\n\t\t\t\t\t     sizeof(isdn_ioctl_struct)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tif (strlen(iocts.drvid)) {\n\t\t\t\t\t\tif ((p = strchr(iocts.drvid, ',')))\n\t\t\t\t\t\t\t*p = 0;\n\t\t\t\t\t\tdrvidx = -1;\n\t\t\t\t\t\tfor (i = 0; i < ISDN_MAX_DRIVERS; i++)\n\t\t\t\t\t\t\tif (!(strcmp(dev->drvid[i], iocts.drvid))) {\n\t\t\t\t\t\t\t\tdrvidx = i;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (drvidx == -1)\n\t\t\t\t\treturn -ENODEV;\n\t\t\t\tif (iocts.arg)\n\t\t\t\t\tdev->drv[drvidx]->flags |= DRV_FLAG_REJBUS;\n\t\t\t\telse\n\t\t\t\t\tdev->drv[drvidx]->flags &= ~DRV_FLAG_REJBUS;\n\t\t\t\treturn 0;\n\t\t\tcase IIOCSIGPRF:\n\t\t\t\tdev->profd = current;\n\t\t\t\treturn 0;\n\t\t\t\tbreak;\n\t\t\tcase IIOCGETPRF:\n\t\t\t\t/* Get all Modem-Profiles */\n\t\t\t\tif (arg) {\n\t\t\t\t\tchar __user *p = argp;\n\t\t\t\t\tint i;\n\n\t\t\t\t\tif (!access_ok(VERIFY_WRITE, argp,\n\t\t\t\t\t(ISDN_MODEM_NUMREG + ISDN_MSNLEN + ISDN_LMSNLEN)\n\t\t\t\t\t\t   * ISDN_MAX_CHANNELS))\n\t\t\t\t\t\treturn -EFAULT;\n\n\t\t\t\t\tfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\n\t\t\t\t\t\tif (copy_to_user(p, dev->mdm.info[i].emu.profile,\n\t\t\t\t\t\t      ISDN_MODEM_NUMREG))\n\t\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\t\tp += ISDN_MODEM_NUMREG;\n\t\t\t\t\t\tif (copy_to_user(p, dev->mdm.info[i].emu.pmsn, ISDN_MSNLEN))\n\t\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\t\tp += ISDN_MSNLEN;\n\t\t\t\t\t\tif (copy_to_user(p, dev->mdm.info[i].emu.plmsn, ISDN_LMSNLEN))\n\t\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\t\tp += ISDN_LMSNLEN;\n\t\t\t\t\t}\n\t\t\t\t\treturn (ISDN_MODEM_NUMREG + ISDN_MSNLEN + ISDN_LMSNLEN) * ISDN_MAX_CHANNELS;\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n\t\t\tcase IIOCSETPRF:\n\t\t\t\t/* Set all Modem-Profiles */\n\t\t\t\tif (arg) {\n\t\t\t\t\tchar __user *p = argp;\n\t\t\t\t\tint i;\n\n\t\t\t\t\tif (!access_ok(VERIFY_READ, argp,\n\t\t\t\t\t(ISDN_MODEM_NUMREG + ISDN_MSNLEN + ISDN_LMSNLEN)\n\t\t\t\t\t\t   * ISDN_MAX_CHANNELS))\n\t\t\t\t\t\treturn -EFAULT;\n\n\t\t\t\t\tfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\n\t\t\t\t\t\tif (copy_from_user(dev->mdm.info[i].emu.profile, p,\n\t\t\t\t\t\t     ISDN_MODEM_NUMREG))\n\t\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\t\tp += ISDN_MODEM_NUMREG;\n\t\t\t\t\t\tif (copy_from_user(dev->mdm.info[i].emu.plmsn, p, ISDN_LMSNLEN))\n\t\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\t\tp += ISDN_LMSNLEN;\n\t\t\t\t\t\tif (copy_from_user(dev->mdm.info[i].emu.pmsn, p, ISDN_MSNLEN))\n\t\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\t\tp += ISDN_MSNLEN;\n\t\t\t\t\t}\n\t\t\t\t\treturn 0;\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n\t\t\tcase IIOCSETMAP:\n\t\t\tcase IIOCGETMAP:\n\t\t\t\t/* Set/Get MSN->EAZ-Mapping for a driver */\n\t\t\t\tif (arg) {\n\n\t\t\t\t\tif (copy_from_user(&iocts, argp,\n\t\t\t\t\t     sizeof(isdn_ioctl_struct)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tif (strlen(iocts.drvid)) {\n\t\t\t\t\t\tdrvidx = -1;\n\t\t\t\t\t\tfor (i = 0; i < ISDN_MAX_DRIVERS; i++)\n\t\t\t\t\t\t\tif (!(strcmp(dev->drvid[i], iocts.drvid))) {\n\t\t\t\t\t\t\t\tdrvidx = i;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t} else\n\t\t\t\t\t\tdrvidx = 0;\n\t\t\t\t\tif (drvidx == -1)\n\t\t\t\t\t\treturn -ENODEV;\n\t\t\t\t\tif (cmd == IIOCSETMAP) {\n\t\t\t\t\t\tint loop = 1;\n\n\t\t\t\t\t\tp = (char __user *) iocts.arg;\n\t\t\t\t\t\ti = 0;\n\t\t\t\t\t\twhile (loop) {\n\t\t\t\t\t\t\tint j = 0;\n\n\t\t\t\t\t\t\twhile (1) {\n\t\t\t\t\t\t\t\tif (!access_ok(VERIFY_READ, p, 1))\n\t\t\t\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\t\t\t\tget_user(bname[j], p++);\n\t\t\t\t\t\t\t\tswitch (bname[j]) {\n\t\t\t\t\t\t\t\t\tcase '\\0':\n\t\t\t\t\t\t\t\t\t\tloop = 0;\n\t\t\t\t\t\t\t\t\t\t/* Fall through */\n\t\t\t\t\t\t\t\t\tcase ',':\n\t\t\t\t\t\t\t\t\t\tbname[j] = '\\0';\n\t\t\t\t\t\t\t\t\t\tstrcpy(dev->drv[drvidx]->msn2eaz[i], bname);\n\t\t\t\t\t\t\t\t\t\tj = ISDN_MSNLEN;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (j >= ISDN_MSNLEN)\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (++i > 9)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tp = (char __user *) iocts.arg;\n\t\t\t\t\t\tfor (i = 0; i < 10; i++) {\n\t\t\t\t\t\t\tsprintf(bname, \"%s%s\",\n\t\t\t\t\t\t\t\tstrlen(dev->drv[drvidx]->msn2eaz[i]) ?\n\t\t\t\t\t\t\t\tdev->drv[drvidx]->msn2eaz[i] : \"_\",\n\t\t\t\t\t\t\t\t(i < 9) ? \",\" : \"\\0\");\n\t\t\t\t\t\t\tif (copy_to_user(p, bname, strlen(bname) + 1))\n\t\t\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\t\t\tp += strlen(bname);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn 0;\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n\t\t\tcase IIOCDBGVAR:\n\t\t\t\tif (arg) {\n\t\t\t\t\tif (copy_to_user(argp, &dev, sizeof(ulong)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\treturn 0;\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif ((cmd & IIOCDRVCTL) == IIOCDRVCTL)\n\t\t\t\t\tcmd = ((cmd >> _IOC_NRSHIFT) & _IOC_NRMASK) & ISDN_DRVIOCTL_MASK;\n\t\t\t\telse\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tif (arg) {\n\t\t\t\t\tint i;\n\t\t\t\t\tchar *p;\n\t\t\t\t\tif (copy_from_user(&iocts, argp, sizeof(isdn_ioctl_struct)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tif (strlen(iocts.drvid)) {\n\t\t\t\t\t\tif ((p = strchr(iocts.drvid, ',')))\n\t\t\t\t\t\t\t*p = 0;\n\t\t\t\t\t\tdrvidx = -1;\n\t\t\t\t\t\tfor (i = 0; i < ISDN_MAX_DRIVERS; i++)\n\t\t\t\t\t\t\tif (!(strcmp(dev->drvid[i], iocts.drvid))) {\n\t\t\t\t\t\t\t\tdrvidx = i;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t} else\n\t\t\t\t\t\tdrvidx = 0;\n\t\t\t\t\tif (drvidx == -1)\n\t\t\t\t\t\treturn -ENODEV;\n\t\t\t\t\tif (!access_ok(VERIFY_WRITE, argp,\n\t\t\t\t\t     sizeof(isdn_ioctl_struct)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tc.driver = drvidx;\n\t\t\t\t\tc.command = ISDN_CMD_IOCTL;\n\t\t\t\t\tc.arg = cmd;\n\t\t\t\t\tmemcpy(c.parm.num, &iocts.arg, sizeof(ulong));\n\t\t\t\t\tret = isdn_command(&c);\n\t\t\t\t\tmemcpy(&iocts.arg, c.parm.num, sizeof(ulong));\n\t\t\t\t\tif (copy_to_user(argp, &iocts, sizeof(isdn_ioctl_struct)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\treturn ret;\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n#ifdef CONFIG_ISDN_PPP\n\tif (minor <= ISDN_MINOR_PPPMAX)\n\t\treturn (isdn_ppp_ioctl(minor - ISDN_MINOR_PPP, file, cmd, arg));\n#endif\n\treturn -ENODEV;\n\n#undef name\n#undef bname\n#undef iocts\n#undef phone\n#undef cfg\n}",
        "target": 1
    },
    {
        "func": "shmem_alloc_page(gfp_t gfp,struct shmem_inode_info *info, unsigned long idx)\n{\n\treturn alloc_page(gfp | __GFP_ZERO);\n}",
        "target": 1
    },
    {
        "func": "static int shmem_getpage(struct inode *inode, unsigned long idx,\n\t\t\tstruct page **pagep, enum sgp_type sgp, int *type)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct shmem_inode_info *info = SHMEM_I(inode);\n\tstruct shmem_sb_info *sbinfo;\n\tstruct page *filepage = *pagep;\n\tstruct page *swappage;\n\tswp_entry_t *entry;\n\tswp_entry_t swap;\n\tint error;\n\n\tif (idx >= SHMEM_MAX_INDEX)\n\t\treturn -EFBIG;\n\n\tif (type)\n\t\t*type = 0;\n\n\t/*\n\t * Normally, filepage is NULL on entry, and either found\n\t * uptodate immediately, or allocated and zeroed, or read\n\t * in under swappage, which is then assigned to filepage.\n\t * But shmem_readpage and shmem_write_begin pass in a locked\n\t * filepage, which may be found not uptodate by other callers\n\t * too, and may need to be copied from the swappage read in.\n\t */\nrepeat:\n\tif (!filepage)\n\t\tfilepage = find_lock_page(mapping, idx);\n\tif (filepage && PageUptodate(filepage))\n\t\tgoto done;\n\terror = 0;\n\tif (sgp == SGP_QUICK)\n\t\tgoto failed;\n\n\tspin_lock(&info->lock);\n\tshmem_recalc_inode(inode);\n\tentry = shmem_swp_alloc(info, idx, sgp);\n\tif (IS_ERR(entry)) {\n\t\tspin_unlock(&info->lock);\n\t\terror = PTR_ERR(entry);\n\t\tgoto failed;\n\t}\n\tswap = *entry;\n\n\tif (swap.val) {\n\t\t/* Look it up and read it in.. */\n\t\tswappage = lookup_swap_cache(swap);\n\t\tif (!swappage) {\n\t\t\tshmem_swp_unmap(entry);\n\t\t\t/* here we actually do the io */\n\t\t\tif (type && !(*type & VM_FAULT_MAJOR)) {\n\t\t\t\t__count_vm_event(PGMAJFAULT);\n\t\t\t\t*type |= VM_FAULT_MAJOR;\n\t\t\t}\n\t\t\tspin_unlock(&info->lock);\n\t\t\tswappage = shmem_swapin(info, swap, idx);\n\t\t\tif (!swappage) {\n\t\t\t\tspin_lock(&info->lock);\n\t\t\t\tentry = shmem_swp_alloc(info, idx, sgp);\n\t\t\t\tif (IS_ERR(entry))\n\t\t\t\t\terror = PTR_ERR(entry);\n\t\t\t\telse {\n\t\t\t\t\tif (entry->val == swap.val)\n\t\t\t\t\t\terror = -ENOMEM;\n\t\t\t\t\tshmem_swp_unmap(entry);\n\t\t\t\t}\n\t\t\t\tspin_unlock(&info->lock);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto failed;\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t\twait_on_page_locked(swappage);\n\t\t\tpage_cache_release(swappage);\n\t\t\tgoto repeat;\n\t\t}\n\n\t\t/* We have to do this with page locked to prevent races */\n\t\tif (TestSetPageLocked(swappage)) {\n\t\t\tshmem_swp_unmap(entry);\n\t\t\tspin_unlock(&info->lock);\n\t\t\twait_on_page_locked(swappage);\n\t\t\tpage_cache_release(swappage);\n\t\t\tgoto repeat;\n\t\t}\n\t\tif (PageWriteback(swappage)) {\n\t\t\tshmem_swp_unmap(entry);\n\t\t\tspin_unlock(&info->lock);\n\t\t\twait_on_page_writeback(swappage);\n\t\t\tunlock_page(swappage);\n\t\t\tpage_cache_release(swappage);\n\t\t\tgoto repeat;\n\t\t}\n\t\tif (!PageUptodate(swappage)) {\n\t\t\tshmem_swp_unmap(entry);\n\t\t\tspin_unlock(&info->lock);\n\t\t\tunlock_page(swappage);\n\t\t\tpage_cache_release(swappage);\n\t\t\terror = -EIO;\n\t\t\tgoto failed;\n\t\t}\n\n\t\tif (filepage) {\n\t\t\tshmem_swp_set(info, entry, 0);\n\t\t\tshmem_swp_unmap(entry);\n\t\t\tdelete_from_swap_cache(swappage);\n\t\t\tspin_unlock(&info->lock);\n\t\t\tcopy_highpage(filepage, swappage);\n\t\t\tunlock_page(swappage);\n\t\t\tpage_cache_release(swappage);\n\t\t\tflush_dcache_page(filepage);\n\t\t\tSetPageUptodate(filepage);\n\t\t\tset_page_dirty(filepage);\n\t\t\tswap_free(swap);\n\t\t} else if (!(error = move_from_swap_cache(\n\t\t\t\tswappage, idx, mapping))) {\n\t\t\tinfo->flags |= SHMEM_PAGEIN;\n\t\t\tshmem_swp_set(info, entry, 0);\n\t\t\tshmem_swp_unmap(entry);\n\t\t\tspin_unlock(&info->lock);\n\t\t\tfilepage = swappage;\n\t\t\tswap_free(swap);\n\t\t} else {\n\t\t\tshmem_swp_unmap(entry);\n\t\t\tspin_unlock(&info->lock);\n\t\t\tunlock_page(swappage);\n\t\t\tpage_cache_release(swappage);\n\t\t\tif (error == -ENOMEM) {\n\t\t\t\t/* let kswapd refresh zone for GFP_ATOMICs */\n\t\t\t\tcongestion_wait(WRITE, HZ/50);\n\t\t\t}\n\t\t\tgoto repeat;\n\t\t}\n\t} else if (sgp == SGP_READ && !filepage) {\n\t\tshmem_swp_unmap(entry);\n\t\tfilepage = find_get_page(mapping, idx);\n\t\tif (filepage &&\n\t\t    (!PageUptodate(filepage) || TestSetPageLocked(filepage))) {\n\t\t\tspin_unlock(&info->lock);\n\t\t\twait_on_page_locked(filepage);\n\t\t\tpage_cache_release(filepage);\n\t\t\tfilepage = NULL;\n\t\t\tgoto repeat;\n\t\t}\n\t\tspin_unlock(&info->lock);\n\t} else {\n\t\tshmem_swp_unmap(entry);\n\t\tsbinfo = SHMEM_SB(inode->i_sb);\n\t\tif (sbinfo->max_blocks) {\n\t\t\tspin_lock(&sbinfo->stat_lock);\n\t\t\tif (sbinfo->free_blocks == 0 ||\n\t\t\t    shmem_acct_block(info->flags)) {\n\t\t\t\tspin_unlock(&sbinfo->stat_lock);\n\t\t\t\tspin_unlock(&info->lock);\n\t\t\t\terror = -ENOSPC;\n\t\t\t\tgoto failed;\n\t\t\t}\n\t\t\tsbinfo->free_blocks--;\n\t\t\tinode->i_blocks += BLOCKS_PER_PAGE;\n\t\t\tspin_unlock(&sbinfo->stat_lock);\n\t\t} else if (shmem_acct_block(info->flags)) {\n\t\t\tspin_unlock(&info->lock);\n\t\t\terror = -ENOSPC;\n\t\t\tgoto failed;\n\t\t}\n\n\t\tif (!filepage) {\n\t\t\tspin_unlock(&info->lock);\n\t\t\tfilepage = shmem_alloc_page(mapping_gfp_mask(mapping),\n\t\t\t\t\t\t    info,\n\t\t\t\t\t\t    idx);\n\t\t\tif (!filepage) {\n\t\t\t\tshmem_unacct_blocks(info->flags, 1);\n\t\t\t\tshmem_free_blocks(inode, 1);\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tgoto failed;\n\t\t\t}\n\n\t\t\tspin_lock(&info->lock);\n\t\t\tentry = shmem_swp_alloc(info, idx, sgp);\n\t\t\tif (IS_ERR(entry))\n\t\t\t\terror = PTR_ERR(entry);\n\t\t\telse {\n\t\t\t\tswap = *entry;\n\t\t\t\tshmem_swp_unmap(entry);\n\t\t\t}\n\t\t\tif (error || swap.val || 0 != add_to_page_cache_lru(\n\t\t\t\t\tfilepage, mapping, idx, GFP_ATOMIC)) {\n\t\t\t\tspin_unlock(&info->lock);\n\t\t\t\tpage_cache_release(filepage);\n\t\t\t\tshmem_unacct_blocks(info->flags, 1);\n\t\t\t\tshmem_free_blocks(inode, 1);\n\t\t\t\tfilepage = NULL;\n\t\t\t\tif (error)\n\t\t\t\t\tgoto failed;\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t\tinfo->flags |= SHMEM_PAGEIN;\n\t\t}\n\n\t\tinfo->alloced++;\n\t\tspin_unlock(&info->lock);\n\t\tflush_dcache_page(filepage);\n\t\tSetPageUptodate(filepage);\n\t}\ndone:\n\tif (*pagep != filepage) {\n\t\t*pagep = filepage;\n\t\tif (sgp != SGP_FAULT)\n\t\t\tunlock_page(filepage);\n\n\t}\n\treturn 0;\n\nfailed:\n\tif (*pagep != filepage) {\n\t\tunlock_page(filepage);\n\t\tpage_cache_release(filepage);\n\t}\n\treturn error;\n}",
        "target": 1
    },
    {
        "func": "shmem_alloc_page(gfp_t gfp, struct shmem_inode_info *info,\n\t\t unsigned long idx)\n{\n\tstruct vm_area_struct pvma;\n\tstruct page *page;\n\n\tmemset(&pvma, 0, sizeof(struct vm_area_struct));\n\tpvma.vm_policy = mpol_shared_policy_lookup(&info->policy, idx);\n\tpvma.vm_pgoff = idx;\n\tpvma.vm_end = PAGE_SIZE;\n\tpage = alloc_page_vma(gfp | __GFP_ZERO, &pvma, 0);\n\tmpol_free(pvma.vm_policy);\n\treturn page;\n}",
        "target": 1
    },
    {
        "func": "ProcShmCreatePixmap(client)\n    register ClientPtr client;\n{\n    PixmapPtr pMap;\n    DrawablePtr pDraw;\n    DepthPtr pDepth;\n    register int i, rc;\n    ShmDescPtr shmdesc;\n    REQUEST(xShmCreatePixmapReq);\n    unsigned int width, height, depth;\n    unsigned long size;\n\n    REQUEST_SIZE_MATCH(xShmCreatePixmapReq);\n    client->errorValue = stuff->pid;\n    if (!sharedPixmaps)\n\treturn BadImplementation;\n    LEGAL_NEW_RESOURCE(stuff->pid, client);\n    rc = dixLookupDrawable(&pDraw, stuff->drawable, client, M_ANY,\n\t\t\t   DixGetAttrAccess);\n    if (rc != Success)\n\treturn rc;\n\n    VERIFY_SHMPTR(stuff->shmseg, stuff->offset, TRUE, shmdesc, client);\n    \n    width = stuff->width;\n    height = stuff->height;\n    depth = stuff->depth;\n    if (!width || !height || !depth)\n    {\n\tclient->errorValue = 0;\n        return BadValue;\n    }\n    if (width > 32767 || height > 32767)\n\treturn BadAlloc;\n\n    if (stuff->depth != 1)\n    {\n        pDepth = pDraw->pScreen->allowedDepths;\n        for (i=0; i<pDraw->pScreen->numDepths; i++, pDepth++)\n\t   if (pDepth->depth == stuff->depth)\n               goto CreatePmap;\n\tclient->errorValue = stuff->depth;\n        return BadValue;\n    }\n\nCreatePmap:\n    size = PixmapBytePad(width, depth) * height;\n    if (sizeof(size) == 4 && BitsPerPixel(depth) > 8) {\n\tif (size < width * height)\n\t    return BadAlloc;\n\t/* thankfully, offset is unsigned */\n\tif (stuff->offset + size < size)\n\t    return BadAlloc;\n    }\n\n    VERIFY_SHMSIZE(shmdesc, stuff->offset, size, client);\n    pMap = (*shmFuncs[pDraw->pScreen->myNum]->CreatePixmap)(\n\t\t\t    pDraw->pScreen, stuff->width,\n\t\t\t    stuff->height, stuff->depth,\n\t\t\t    shmdesc->addr + stuff->offset);\n    if (pMap)\n    {\n\trc = XaceHook(XACE_RESOURCE_ACCESS, client, stuff->pid, RT_PIXMAP,\n\t\t      pMap, RT_NONE, NULL, DixCreateAccess);\n\tif (rc != Success) {\n\t    pDraw->pScreen->DestroyPixmap(pMap);\n\t    return rc;\n\t}\n\tdixSetPrivate(&pMap->devPrivates, shmPixmapPrivate, shmdesc);\n\tshmdesc->refcnt++;\n\tpMap->drawable.serialNumber = NEXT_SERIAL_NUMBER;\n\tpMap->drawable.id = stuff->pid;\n\tif (AddResource(stuff->pid, RT_PIXMAP, (pointer)pMap))\n\t{\n\t    return(client->noClientException);\n\t}\n\tpDraw->pScreen->DestroyPixmap(pMap);\n    }\n    return (BadAlloc);\n}",
        "target": 1
    },
    {
        "func": "ProcPanoramiXShmCreatePixmap(\n    register ClientPtr client)\n{\n    ScreenPtr pScreen = NULL;\n    PixmapPtr pMap = NULL;\n    DrawablePtr pDraw;\n    DepthPtr pDepth;\n    int i, j, result, rc;\n    ShmDescPtr shmdesc;\n    REQUEST(xShmCreatePixmapReq);\n    unsigned int width, height, depth;\n    unsigned long size;\n    PanoramiXRes *newPix;\n\n    REQUEST_SIZE_MATCH(xShmCreatePixmapReq);\n    client->errorValue = stuff->pid;\n    if (!sharedPixmaps)\n\treturn BadImplementation;\n    LEGAL_NEW_RESOURCE(stuff->pid, client);\n    rc = dixLookupDrawable(&pDraw, stuff->drawable, client, M_ANY,\n\t\t\t   DixUnknownAccess);\n    if (rc != Success)\n\treturn rc;\n\n    VERIFY_SHMPTR(stuff->shmseg, stuff->offset, TRUE, shmdesc, client);\n\n    width = stuff->width;\n    height = stuff->height;\n    depth = stuff->depth;\n    if (!width || !height || !depth)\n    {\n\tclient->errorValue = 0;\n        return BadValue;\n    }\n    if (width > 32767 || height > 32767)\n        return BadAlloc;\n\n    if (stuff->depth != 1)\n    {\n        pDepth = pDraw->pScreen->allowedDepths;\n        for (i=0; i<pDraw->pScreen->numDepths; i++, pDepth++)\n\t   if (pDepth->depth == stuff->depth)\n               goto CreatePmap;\n\tclient->errorValue = stuff->depth;\n        return BadValue;\n    }\n\nCreatePmap:\n    size = PixmapBytePad(width, depth) * height;\n    if (sizeof(size) == 4 && BitsPerPixel(depth) > 8) {\n        if (size < width * height)\n            return BadAlloc;\n        /* thankfully, offset is unsigned */\n        if (stuff->offset + size < size)\n            return BadAlloc;\n    }\n\n    VERIFY_SHMSIZE(shmdesc, stuff->offset, size, client);\n\n    if(!(newPix = (PanoramiXRes *) xalloc(sizeof(PanoramiXRes))))\n\treturn BadAlloc;\n\n    newPix->type = XRT_PIXMAP;\n    newPix->u.pix.shared = TRUE;\n    newPix->info[0].id = stuff->pid;\n    for(j = 1; j < PanoramiXNumScreens; j++)\n\tnewPix->info[j].id = FakeClientID(client->index);\n\n    result = (client->noClientException);\n\n    FOR_NSCREENS(j) {\n\tpScreen = screenInfo.screens[j];\n\n\tpMap = (*shmFuncs[j]->CreatePixmap)(pScreen, \n\t\t\t\tstuff->width, stuff->height, stuff->depth,\n\t\t\t\tshmdesc->addr + stuff->offset);\n\n\tif (pMap) {\n\t    dixSetPrivate(&pMap->devPrivates, shmPixmapPrivate, shmdesc);\n            shmdesc->refcnt++;\n\t    pMap->drawable.serialNumber = NEXT_SERIAL_NUMBER;\n\t    pMap->drawable.id = newPix->info[j].id;\n\t    if (!AddResource(newPix->info[j].id, RT_PIXMAP, (pointer)pMap)) {\n\t\t(*pScreen->DestroyPixmap)(pMap);\n\t\tresult = BadAlloc;\n\t\tbreak;\n\t    }\n\t} else {\n\t   result = BadAlloc;\n\t   break;\n\t}\n    }\n\n    if(result == BadAlloc) {\n\twhile(j--) {\n\t    (*pScreen->DestroyPixmap)(pMap);\n\t    FreeResource(newPix->info[j].id, RT_NONE);\n\t}\n\txfree(newPix);\n    } else \n\tAddResource(stuff->pid, XRT_PIXMAP, newPix);\n\n    return result;\n}",
        "target": 1
    },
    {
        "func": "static int copy_from_user_mmap_sem(void *dst, const void __user *src, size_t n)\n{\n\tint partial;\n\n\tpagefault_disable();\n\tpartial = __copy_from_user_inatomic(dst, src, n);\n\tpagefault_enable();\n\n\t/*\n\t * Didn't copy everything, drop the mmap_sem and do a faulting copy\n\t */\n\tif (unlikely(partial)) {\n\t\tup_read(&current->mm->mmap_sem);\n\t\tpartial = copy_from_user(dst, src, n);\n\t\tdown_read(&current->mm->mmap_sem);\n\t}\n\n\treturn partial;\n}",
        "target": 1
    },
    {
        "func": "static long vmsplice_to_user(struct file *file, const struct iovec __user *iov,\n\t\t\t     unsigned long nr_segs, unsigned int flags)\n{\n\tstruct pipe_inode_info *pipe;\n\tstruct splice_desc sd;\n\tssize_t size;\n\tint error;\n\tlong ret;\n\n\tpipe = pipe_info(file->f_path.dentry->d_inode);\n\tif (!pipe)\n\t\treturn -EBADF;\n\n\tif (pipe->inode)\n\t\tmutex_lock(&pipe->inode->i_mutex);\n\n\terror = ret = 0;\n\twhile (nr_segs) {\n\t\tvoid __user *base;\n\t\tsize_t len;\n\n\t\t/*\n\t\t * Get user address base and length for this iovec.\n\t\t */\n\t\terror = get_user(base, &iov->iov_base);\n\t\tif (unlikely(error))\n\t\t\tbreak;\n\t\terror = get_user(len, &iov->iov_len);\n\t\tif (unlikely(error))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Sanity check this iovec. 0 read succeeds.\n\t\t */\n\t\tif (unlikely(!len))\n\t\t\tbreak;\n\t\tif (unlikely(!base)) {\n\t\t\terror = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tsd.len = 0;\n\t\tsd.total_len = len;\n\t\tsd.flags = flags;\n\t\tsd.u.userptr = base;\n\t\tsd.pos = 0;\n\n\t\tsize = __splice_from_pipe(pipe, &sd, pipe_to_user);\n\t\tif (size < 0) {\n\t\t\tif (!ret)\n\t\t\t\tret = size;\n\n\t\t\tbreak;\n\t\t}\n\n\t\tret += size;\n\n\t\tif (size < len)\n\t\t\tbreak;\n\n\t\tnr_segs--;\n\t\tiov++;\n\t}\n\n\tif (pipe->inode)\n\t\tmutex_unlock(&pipe->inode->i_mutex);\n\n\tif (!ret)\n\t\tret = error;\n\n\treturn ret;\n}",
        "target": 1
    },
    {
        "func": "static int get_iovec_page_array(const struct iovec __user *iov,\n\t\t\t\tunsigned int nr_vecs, struct page **pages,\n\t\t\t\tstruct partial_page *partial, int aligned)\n{\n\tint buffers = 0, error = 0;\n\n\tdown_read(&current->mm->mmap_sem);\n\n\twhile (nr_vecs) {\n\t\tunsigned long off, npages;\n\t\tstruct iovec entry;\n\t\tvoid __user *base;\n\t\tsize_t len;\n\t\tint i;\n\n\t\terror = -EFAULT;\n\t\tif (copy_from_user_mmap_sem(&entry, iov, sizeof(entry)))\n\t\t\tbreak;\n\n\t\tbase = entry.iov_base;\n\t\tlen = entry.iov_len;\n\n\t\t/*\n\t\t * Sanity check this iovec. 0 read succeeds.\n\t\t */\n\t\terror = 0;\n\t\tif (unlikely(!len))\n\t\t\tbreak;\n\t\terror = -EFAULT;\n\t\tif (unlikely(!base))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Get this base offset and number of pages, then map\n\t\t * in the user pages.\n\t\t */\n\t\toff = (unsigned long) base & ~PAGE_MASK;\n\n\t\t/*\n\t\t * If asked for alignment, the offset must be zero and the\n\t\t * length a multiple of the PAGE_SIZE.\n\t\t */\n\t\terror = -EINVAL;\n\t\tif (aligned && (off || len & ~PAGE_MASK))\n\t\t\tbreak;\n\n\t\tnpages = (off + len + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\t\tif (npages > PIPE_BUFFERS - buffers)\n\t\t\tnpages = PIPE_BUFFERS - buffers;\n\n\t\terror = get_user_pages(current, current->mm,\n\t\t\t\t       (unsigned long) base, npages, 0, 0,\n\t\t\t\t       &pages[buffers], NULL);\n\n\t\tif (unlikely(error <= 0))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Fill this contiguous range into the partial page map.\n\t\t */\n\t\tfor (i = 0; i < error; i++) {\n\t\t\tconst int plen = min_t(size_t, len, PAGE_SIZE - off);\n\n\t\t\tpartial[buffers].offset = off;\n\t\t\tpartial[buffers].len = plen;\n\n\t\t\toff = 0;\n\t\t\tlen -= plen;\n\t\t\tbuffers++;\n\t\t}\n\n\t\t/*\n\t\t * We didn't complete this iov, stop here since it probably\n\t\t * means we have to move some of this into a pipe to\n\t\t * be able to continue.\n\t\t */\n\t\tif (len)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Don't continue if we mapped fewer pages than we asked for,\n\t\t * or if we mapped the max number of pages that we have\n\t\t * room for.\n\t\t */\n\t\tif (error < npages || buffers == PIPE_BUFFERS)\n\t\t\tbreak;\n\n\t\tnr_vecs--;\n\t\tiov++;\n\t}\n\n\tup_read(&current->mm->mmap_sem);\n\n\tif (buffers)\n\t\treturn buffers;\n\n\treturn error;\n}",
        "target": 1
    },
    {
        "func": "asmlinkage long sys_setrlimit(unsigned int resource, struct rlimit __user *rlim)\n{\n\tstruct rlimit new_rlim, *old_rlim;\n\tunsigned long it_prof_secs;\n\tint retval;\n\n\tif (resource >= RLIM_NLIMITS)\n\t\treturn -EINVAL;\n\tif (copy_from_user(&new_rlim, rlim, sizeof(*rlim)))\n\t\treturn -EFAULT;\n\tif (new_rlim.rlim_cur > new_rlim.rlim_max)\n\t\treturn -EINVAL;\n\told_rlim = current->signal->rlim + resource;\n\tif ((new_rlim.rlim_max > old_rlim->rlim_max) &&\n\t    !capable(CAP_SYS_RESOURCE))\n\t\treturn -EPERM;\n\tif (resource == RLIMIT_NOFILE && new_rlim.rlim_max > NR_OPEN)\n\t\treturn -EPERM;\n\n\tretval = security_task_setrlimit(resource, &new_rlim);\n\tif (retval)\n\t\treturn retval;\n\n\ttask_lock(current->group_leader);\n\t*old_rlim = new_rlim;\n\ttask_unlock(current->group_leader);\n\n\tif (resource != RLIMIT_CPU)\n\t\tgoto out;\n\n\t/*\n\t * RLIMIT_CPU handling.   Note that the kernel fails to return an error\n\t * code if it rejected the user's attempt to set RLIMIT_CPU.  This is a\n\t * very long-standing error, and fixing it now risks breakage of\n\t * applications, so we live with it\n\t */\n\tif (new_rlim.rlim_cur == RLIM_INFINITY)\n\t\tgoto out;\n\n\tit_prof_secs = cputime_to_secs(current->signal->it_prof_expires);\n\tif (it_prof_secs == 0 || new_rlim.rlim_cur <= it_prof_secs) {\n\t\tunsigned long rlim_cur = new_rlim.rlim_cur;\n\t\tcputime_t cputime;\n\n\t\tif (rlim_cur == 0) {\n\t\t\t/*\n\t\t\t * The caller is asking for an immediate RLIMIT_CPU\n\t\t\t * expiry.  But we use the zero value to mean \"it was\n\t\t\t * never set\".  So let's cheat and make it one second\n\t\t\t * instead\n\t\t\t */\n\t\t\trlim_cur = 1;\n\t\t}\n\t\tcputime = secs_to_cputime(rlim_cur);\n\t\tread_lock(&tasklist_lock);\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t\tset_process_cpu_timer(current, CPUCLOCK_PROF, &cputime, NULL);\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t\tread_unlock(&tasklist_lock);\n\t}\nout:\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static int setup_rt_frame(int sig, struct k_sigaction *ka, siginfo_t *info,\n\t\t\t   sigset_t *set, struct pt_regs * regs)\n{\n\tvoid __user *restorer;\n\tstruct rt_sigframe __user *frame;\n\tint err = 0;\n\tint usig;\n\n\tframe = get_sigframe(ka, regs, sizeof(*frame));\n\n\tif (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))\n\t\tgoto give_sigsegv;\n\n\tusig = current_thread_info()->exec_domain\n\t\t&& current_thread_info()->exec_domain->signal_invmap\n\t\t&& sig < 32\n\t\t? current_thread_info()->exec_domain->signal_invmap[sig]\n\t\t: sig;\n\n\terr |= __put_user(usig, &frame->sig);\n\terr |= __put_user(&frame->info, &frame->pinfo);\n\terr |= __put_user(&frame->uc, &frame->puc);\n\terr |= copy_siginfo_to_user(&frame->info, info);\n\tif (err)\n\t\tgoto give_sigsegv;\n\n\t/* Create the ucontext.  */\n\terr |= __put_user(0, &frame->uc.uc_flags);\n\terr |= __put_user(0, &frame->uc.uc_link);\n\terr |= __put_user(current->sas_ss_sp, &frame->uc.uc_stack.ss_sp);\n\terr |= __put_user(sas_ss_flags(regs->sp),\n\t\t\t  &frame->uc.uc_stack.ss_flags);\n\terr |= __put_user(current->sas_ss_size, &frame->uc.uc_stack.ss_size);\n\terr |= setup_sigcontext(&frame->uc.uc_mcontext, &frame->fpstate,\n\t\t\t        regs, set->sig[0]);\n\terr |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));\n\tif (err)\n\t\tgoto give_sigsegv;\n\n\t/* Set up to return from userspace.  */\n\trestorer = VDSO32_SYMBOL(current->mm->context.vdso, rt_sigreturn);\n\tif (ka->sa.sa_flags & SA_RESTORER)\n\t\trestorer = ka->sa.sa_restorer;\n\terr |= __put_user(restorer, &frame->pretcode);\n\t \n\t/*\n\t * This is movl $,%ax ; int $0x80\n\t *\n\t * WE DO NOT USE IT ANY MORE! It's only left here for historical\n\t * reasons and because gdb uses it as a signature to notice\n\t * signal handler stack frames.\n\t */\n\terr |= __put_user(0xb8, (char __user *)(frame->retcode+0));\n\terr |= __put_user(__NR_rt_sigreturn, (int __user *)(frame->retcode+1));\n\terr |= __put_user(0x80cd, (short __user *)(frame->retcode+5));\n\n\tif (err)\n\t\tgoto give_sigsegv;\n\n\t/* Set up registers for signal handler */\n\tregs->sp = (unsigned long) frame;\n\tregs->ip = (unsigned long) ka->sa.sa_handler;\n\tregs->ax = (unsigned long) usig;\n\tregs->dx = (unsigned long) &frame->info;\n\tregs->cx = (unsigned long) &frame->uc;\n\n\tregs->ds = __USER_DS;\n\tregs->es = __USER_DS;\n\tregs->ss = __USER_DS;\n\tregs->cs = __USER_CS;\n\n\t/*\n\t * Clear TF when entering the signal handler, but\n\t * notify any tracer that was single-stepping it.\n\t * The tracer may want to single-step inside the\n\t * handler too.\n\t */\n\tregs->flags &= ~TF_MASK;\n\tif (test_thread_flag(TIF_SINGLESTEP))\n\t\tptrace_notify(SIGTRAP);\n\n#if DEBUG_SIG\n\tprintk(\"SIG deliver (%s:%d): sp=%p pc=%p ra=%p\\n\",\n\t\tcurrent->comm, current->pid, frame, regs->ip, frame->pretcode);\n#endif\n\n\treturn 0;\n\ngive_sigsegv:\n\tforce_sigsegv(sig, current);\n\treturn -EFAULT;\n}",
        "target": 1
    },
    {
        "func": "int ia32_setup_rt_frame(int sig, struct k_sigaction *ka, siginfo_t *info,\n\t\t\tcompat_sigset_t *set, struct pt_regs *regs)\n{\n\tstruct rt_sigframe __user *frame;\n\tstruct exec_domain *ed = current_thread_info()->exec_domain;\n\tvoid __user *restorer;\n\tint err = 0;\n\n\t/* __copy_to_user optimizes that into a single 8 byte store */\n\tstatic const struct {\n\t\tu8 movl;\n\t\tu32 val;\n\t\tu16 int80;\n\t\tu16 pad;\n\t\tu8  pad2;\n\t} __attribute__((packed)) code = {\n\t\t0xb8,\n\t\t__NR_ia32_rt_sigreturn,\n\t\t0x80cd,\n\t\t0,\n\t};\n\n\tframe = get_sigframe(ka, regs, sizeof(*frame));\n\n\tif (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))\n\t\tgoto give_sigsegv;\n\n\terr |= __put_user((ed && ed->signal_invmap && sig < 32\n\t\t\t   ? ed->signal_invmap[sig] : sig), &frame->sig);\n\terr |= __put_user(ptr_to_compat(&frame->info), &frame->pinfo);\n\terr |= __put_user(ptr_to_compat(&frame->uc), &frame->puc);\n\terr |= copy_siginfo_to_user32(&frame->info, info);\n\tif (err)\n\t\tgoto give_sigsegv;\n\n\t/* Create the ucontext.  */\n\terr |= __put_user(0, &frame->uc.uc_flags);\n\terr |= __put_user(0, &frame->uc.uc_link);\n\terr |= __put_user(current->sas_ss_sp, &frame->uc.uc_stack.ss_sp);\n\terr |= __put_user(sas_ss_flags(regs->sp),\n\t\t\t  &frame->uc.uc_stack.ss_flags);\n\terr |= __put_user(current->sas_ss_size, &frame->uc.uc_stack.ss_size);\n\terr |= ia32_setup_sigcontext(&frame->uc.uc_mcontext, &frame->fpstate,\n\t\t\t\t     regs, set->sig[0]);\n\terr |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));\n\tif (err)\n\t\tgoto give_sigsegv;\n\n\tif (ka->sa.sa_flags & SA_RESTORER)\n\t\trestorer = ka->sa.sa_restorer;\n\telse\n\t\trestorer = VDSO32_SYMBOL(current->mm->context.vdso,\n\t\t\t\t\t rt_sigreturn);\n\terr |= __put_user(ptr_to_compat(restorer), &frame->pretcode);\n\n\t/*\n\t * Not actually used anymore, but left because some gdb\n\t * versions need it.\n\t */\n\terr |= __copy_to_user(frame->retcode, &code, 8);\n\tif (err)\n\t\tgoto give_sigsegv;\n\n\t/* Set up registers for signal handler */\n\tregs->sp = (unsigned long) frame;\n\tregs->ip = (unsigned long) ka->sa.sa_handler;\n\n\t/* Make -mregparm=3 work */\n\tregs->ax = sig;\n\tregs->dx = (unsigned long) &frame->info;\n\tregs->cx = (unsigned long) &frame->uc;\n\n\t/* Make -mregparm=3 work */\n\tregs->ax = sig;\n\tregs->dx = (unsigned long) &frame->info;\n\tregs->cx = (unsigned long) &frame->uc;\n\n\tasm volatile(\"movl %0,%%ds\" :: \"r\" (__USER32_DS));\n\tasm volatile(\"movl %0,%%es\" :: \"r\" (__USER32_DS));\n\n\tregs->cs = __USER32_CS;\n\tregs->ss = __USER32_DS;\n\n\tset_fs(USER_DS);\n\tregs->flags &= ~X86_EFLAGS_TF;\n\tif (test_thread_flag(TIF_SINGLESTEP))\n\t\tptrace_notify(SIGTRAP);\n\n#if DEBUG_SIG\n\tprintk(KERN_DEBUG \"SIG deliver (%s:%d): sp=%p pc=%lx ra=%u\\n\",\n\t       current->comm, current->pid, frame, regs->ip, frame->pretcode);\n#endif\n\n\treturn 0;\n\ngive_sigsegv:\n\tforce_sigsegv(sig, current);\n\treturn -EFAULT;\n}",
        "target": 1
    },
    {
        "func": "static int setup_rt_frame(int sig, struct k_sigaction *ka, siginfo_t *info,\n\t\t\t   sigset_t *set, struct pt_regs * regs)\n{\n\tstruct rt_sigframe __user *frame;\n\tstruct _fpstate __user *fp = NULL; \n\tint err = 0;\n\tstruct task_struct *me = current;\n\n\tif (used_math()) {\n\t\tfp = get_stack(ka, regs, sizeof(struct _fpstate)); \n\t\tframe = (void __user *)round_down(\n\t\t\t(unsigned long)fp - sizeof(struct rt_sigframe), 16) - 8;\n\n\t\tif (!access_ok(VERIFY_WRITE, fp, sizeof(struct _fpstate)))\n\t\t\tgoto give_sigsegv;\n\n\t\tif (save_i387(fp) < 0) \n\t\t\terr |= -1; \n\t} else\n\t\tframe = get_stack(ka, regs, sizeof(struct rt_sigframe)) - 8;\n\n\tif (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))\n\t\tgoto give_sigsegv;\n\n\tif (ka->sa.sa_flags & SA_SIGINFO) { \n\t\terr |= copy_siginfo_to_user(&frame->info, info);\n\t\tif (err)\n\t\t\tgoto give_sigsegv;\n\t}\n\t\t\n\t/* Create the ucontext.  */\n\terr |= __put_user(0, &frame->uc.uc_flags);\n\terr |= __put_user(0, &frame->uc.uc_link);\n\terr |= __put_user(me->sas_ss_sp, &frame->uc.uc_stack.ss_sp);\n\terr |= __put_user(sas_ss_flags(regs->sp),\n\t\t\t  &frame->uc.uc_stack.ss_flags);\n\terr |= __put_user(me->sas_ss_size, &frame->uc.uc_stack.ss_size);\n\terr |= setup_sigcontext(&frame->uc.uc_mcontext, regs, set->sig[0], me);\n\terr |= __put_user(fp, &frame->uc.uc_mcontext.fpstate);\n\tif (sizeof(*set) == 16) { \n\t\t__put_user(set->sig[0], &frame->uc.uc_sigmask.sig[0]);\n\t\t__put_user(set->sig[1], &frame->uc.uc_sigmask.sig[1]); \n\t} else\n\t\terr |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));\n\n\t/* Set up to return from userspace.  If provided, use a stub\n\t   already in userspace.  */\n\t/* x86-64 should always use SA_RESTORER. */\n\tif (ka->sa.sa_flags & SA_RESTORER) {\n\t\terr |= __put_user(ka->sa.sa_restorer, &frame->pretcode);\n\t} else {\n\t\t/* could use a vstub here */\n\t\tgoto give_sigsegv; \n\t}\n\n\tif (err)\n\t\tgoto give_sigsegv;\n\n#ifdef DEBUG_SIG\n\tprintk(\"%d old ip %lx old sp %lx old ax %lx\\n\", current->pid,regs->ip,regs->sp,regs->ax);\n#endif\n\n\t/* Set up registers for signal handler */\n\tregs->di = sig;\n\t/* In case the signal handler was declared without prototypes */ \n\tregs->ax = 0;\n\n\t/* This also works for non SA_SIGINFO handlers because they expect the\n\t   next argument after the signal number on the stack. */\n\tregs->si = (unsigned long)&frame->info;\n\tregs->dx = (unsigned long)&frame->uc;\n\tregs->ip = (unsigned long) ka->sa.sa_handler;\n\n\tregs->sp = (unsigned long)frame;\n\n\t/* Set up the CS register to run signal handlers in 64-bit mode,\n\t   even if the handler happens to be interrupting 32-bit code. */\n\tregs->cs = __USER_CS;\n\n\t/* This, by contrast, has nothing to do with segment registers -\n\t   see include/asm-x86_64/uaccess.h for details. */\n\tset_fs(USER_DS);\n\n\tregs->flags &= ~X86_EFLAGS_TF;\n\tif (test_thread_flag(TIF_SINGLESTEP))\n\t\tptrace_notify(SIGTRAP);\n#ifdef DEBUG_SIG\n\tprintk(\"SIG deliver (%s:%d): sp=%p pc=%lx ra=%p\\n\",\n\t\tcurrent->comm, current->pid, frame, regs->ip, frame->pretcode);\n#endif\n\n\treturn 0;\n\ngive_sigsegv:\n\tforce_sigsegv(sig, current);\n\treturn -EFAULT;\n}",
        "target": 1
    },
    {
        "func": "static int setup_frame(int sig, struct k_sigaction *ka,\n\t\t       sigset_t *set, struct pt_regs * regs)\n{\n\tvoid __user *restorer;\n\tstruct sigframe __user *frame;\n\tint err = 0;\n\tint usig;\n\n\tframe = get_sigframe(ka, regs, sizeof(*frame));\n\n\tif (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))\n\t\tgoto give_sigsegv;\n\n\tusig = current_thread_info()->exec_domain\n\t\t&& current_thread_info()->exec_domain->signal_invmap\n\t\t&& sig < 32\n\t\t? current_thread_info()->exec_domain->signal_invmap[sig]\n\t\t: sig;\n\n\terr = __put_user(usig, &frame->sig);\n\tif (err)\n\t\tgoto give_sigsegv;\n\n\terr = setup_sigcontext(&frame->sc, &frame->fpstate, regs, set->sig[0]);\n\tif (err)\n\t\tgoto give_sigsegv;\n\n\tif (_NSIG_WORDS > 1) {\n\t\terr = __copy_to_user(&frame->extramask, &set->sig[1],\n\t\t\t\t      sizeof(frame->extramask));\n\t\tif (err)\n\t\t\tgoto give_sigsegv;\n\t}\n\n\tif (current->binfmt->hasvdso)\n\t\trestorer = VDSO32_SYMBOL(current->mm->context.vdso, sigreturn);\n\telse\n\t\trestorer = &frame->retcode;\n\tif (ka->sa.sa_flags & SA_RESTORER)\n\t\trestorer = ka->sa.sa_restorer;\n\n\t/* Set up to return from userspace.  */\n\terr |= __put_user(restorer, &frame->pretcode);\n\t \n\t/*\n\t * This is popl %eax ; movl $,%eax ; int $0x80\n\t *\n\t * WE DO NOT USE IT ANY MORE! It's only left here for historical\n\t * reasons and because gdb uses it as a signature to notice\n\t * signal handler stack frames.\n\t */\n\terr |= __put_user(0xb858, (short __user *)(frame->retcode+0));\n\terr |= __put_user(__NR_sigreturn, (int __user *)(frame->retcode+2));\n\terr |= __put_user(0x80cd, (short __user *)(frame->retcode+6));\n\n\tif (err)\n\t\tgoto give_sigsegv;\n\n\t/* Set up registers for signal handler */\n\tregs->sp = (unsigned long) frame;\n\tregs->ip = (unsigned long) ka->sa.sa_handler;\n\tregs->ax = (unsigned long) sig;\n\tregs->dx = (unsigned long) 0;\n\tregs->cx = (unsigned long) 0;\n\n\tregs->ds = __USER_DS;\n\tregs->es = __USER_DS;\n\tregs->ss = __USER_DS;\n\tregs->cs = __USER_CS;\n\n\t/*\n\t * Clear TF when entering the signal handler, but\n\t * notify any tracer that was single-stepping it.\n\t * The tracer may want to single-step inside the\n\t * handler too.\n\t */\n\tregs->flags &= ~TF_MASK;\n\tif (test_thread_flag(TIF_SINGLESTEP))\n\t\tptrace_notify(SIGTRAP);\n\n#if DEBUG_SIG\n\tprintk(\"SIG deliver (%s:%d): sp=%p pc=%p ra=%p\\n\",\n\t\tcurrent->comm, current->pid, frame, regs->ip, frame->pretcode);\n#endif\n\n\treturn 0;\n\ngive_sigsegv:\n\tforce_sigsegv(sig, current);\n\treturn -EFAULT;\n}",
        "target": 1
    },
    {
        "func": "int ia32_setup_frame(int sig, struct k_sigaction *ka,\n\t\t     compat_sigset_t *set, struct pt_regs *regs)\n{\n\tstruct sigframe __user *frame;\n\tvoid __user *restorer;\n\tint err = 0;\n\n\t/* copy_to_user optimizes that into a single 8 byte store */\n\tstatic const struct {\n\t\tu16 poplmovl;\n\t\tu32 val;\n\t\tu16 int80;\n\t\tu16 pad;\n\t} __attribute__((packed)) code = {\n\t\t0xb858,\t\t /* popl %eax ; movl $...,%eax */\n\t\t__NR_ia32_sigreturn,\n\t\t0x80cd,\t\t/* int $0x80 */\n\t\t0,\n\t};\n\n\tframe = get_sigframe(ka, regs, sizeof(*frame));\n\n\tif (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))\n\t\tgoto give_sigsegv;\n\n\terr |= __put_user(sig, &frame->sig);\n\tif (err)\n\t\tgoto give_sigsegv;\n\n\terr |= ia32_setup_sigcontext(&frame->sc, &frame->fpstate, regs,\n\t\t\t\t\tset->sig[0]);\n\tif (err)\n\t\tgoto give_sigsegv;\n\n\tif (_COMPAT_NSIG_WORDS > 1) {\n\t\terr |= __copy_to_user(frame->extramask, &set->sig[1],\n\t\t\t\t      sizeof(frame->extramask));\n\t\tif (err)\n\t\t\tgoto give_sigsegv;\n\t}\n\n\tif (ka->sa.sa_flags & SA_RESTORER) {\n\t\trestorer = ka->sa.sa_restorer;\n\t} else {\n\t\t/* Return stub is in 32bit vsyscall page */\n\t\tif (current->binfmt->hasvdso)\n\t\t\trestorer = VDSO32_SYMBOL(current->mm->context.vdso,\n\t\t\t\t\t\t sigreturn);\n\t\telse\n\t\t\trestorer = &frame->retcode;\n\t}\n\terr |= __put_user(ptr_to_compat(restorer), &frame->pretcode);\n\n\t/*\n\t * These are actually not used anymore, but left because some\n\t * gdb versions depend on them as a marker.\n\t */\n\terr |= __copy_to_user(frame->retcode, &code, 8);\n\tif (err)\n\t\tgoto give_sigsegv;\n\n\t/* Set up registers for signal handler */\n\tregs->sp = (unsigned long) frame;\n\tregs->ip = (unsigned long) ka->sa.sa_handler;\n\n\t/* Make -mregparm=3 work */\n\tregs->ax = sig;\n\tregs->dx = 0;\n\tregs->cx = 0;\n\n\tasm volatile(\"movl %0,%%ds\" :: \"r\" (__USER32_DS));\n\tasm volatile(\"movl %0,%%es\" :: \"r\" (__USER32_DS));\n\n\tregs->cs = __USER32_CS;\n\tregs->ss = __USER32_DS;\n\n\tset_fs(USER_DS);\n\tregs->flags &= ~X86_EFLAGS_TF;\n\tif (test_thread_flag(TIF_SINGLESTEP))\n\t\tptrace_notify(SIGTRAP);\n\n#if DEBUG_SIG\n\tprintk(KERN_DEBUG \"SIG deliver (%s:%d): sp=%p pc=%lx ra=%u\\n\",\n\t       current->comm, current->pid, frame, regs->ip, frame->pretcode);\n#endif\n\n\treturn 0;\n\ngive_sigsegv:\n\tforce_sigsegv(sig, current);\n\treturn -EFAULT;\n}",
        "target": 1
    },
    {
        "func": "static unsigned long __peek_user(struct task_struct *child, addr_t addr)\n{\n\tstruct user *dummy = NULL;\n\taddr_t offset, tmp;\n\n\tif (addr < (addr_t) &dummy->regs.acrs) {\n\t\t/*\n\t\t * psw and gprs are stored on the stack\n\t\t */\n\t\ttmp = *(addr_t *)((addr_t) &task_pt_regs(child)->psw + addr);\n\t\tif (addr == (addr_t) &dummy->regs.psw.mask)\n\t\t\t/* Remove per bit from user psw. */\n\t\t\ttmp &= ~PSW_MASK_PER;\n\n\t} else if (addr < (addr_t) &dummy->regs.orig_gpr2) {\n\t\t/*\n\t\t * access registers are stored in the thread structure\n\t\t */\n\t\toffset = addr - (addr_t) &dummy->regs.acrs;\n#ifdef CONFIG_64BIT\n\t\t/*\n\t\t * Very special case: old & broken 64 bit gdb reading\n\t\t * from acrs[15]. Result is a 64 bit value. Read the\n\t\t * 32 bit acrs[15] value and shift it by 32. Sick...\n\t\t */\n\t\tif (addr == (addr_t) &dummy->regs.acrs[15])\n\t\t\ttmp = ((unsigned long) child->thread.acrs[15]) << 32;\n\t\telse\n#endif\n\t\ttmp = *(addr_t *)((addr_t) &child->thread.acrs + offset);\n\n\t} else if (addr == (addr_t) &dummy->regs.orig_gpr2) {\n\t\t/*\n\t\t * orig_gpr2 is stored on the kernel stack\n\t\t */\n\t\ttmp = (addr_t) task_pt_regs(child)->orig_gpr2;\n\n\t} else if (addr < (addr_t) (&dummy->regs.fp_regs + 1)) {\n\t\t/* \n\t\t * floating point regs. are stored in the thread structure\n\t\t */\n\t\toffset = addr - (addr_t) &dummy->regs.fp_regs;\n\t\ttmp = *(addr_t *)((addr_t) &child->thread.fp_regs + offset);\n\t\tif (addr == (addr_t) &dummy->regs.fp_regs.fpc)\n\t\t\ttmp &= (unsigned long) FPC_VALID_MASK\n\t\t\t\t<< (BITS_PER_LONG - 32);\n\n\t} else if (addr < (addr_t) (&dummy->regs.per_info + 1)) {\n\t\t/*\n\t\t * per_info is found in the thread structure\n\t\t */\n\t\toffset = addr - (addr_t) &dummy->regs.per_info;\n\t\ttmp = *(addr_t *)((addr_t) &child->thread.per_info + offset);\n\n\t} else\n\t\ttmp = 0;\n\n\treturn tmp;\n}",
        "target": 1
    },
    {
        "func": "static int __poke_user_compat(struct task_struct *child,\n\t\t\t      addr_t addr, addr_t data)\n{\n\tstruct user32 *dummy32 = NULL;\n\tper_struct32 *dummy_per32 = NULL;\n\t__u32 tmp = (__u32) data;\n\taddr_t offset;\n\n\tif (addr < (addr_t) &dummy32->regs.acrs) {\n\t\t/*\n\t\t * psw, gprs, acrs and orig_gpr2 are stored on the stack\n\t\t */\n\t\tif (addr == (addr_t) &dummy32->regs.psw.mask) {\n\t\t\t/* Build a 64 bit psw mask from 31 bit mask. */\n\t\t\tif (tmp != PSW32_MASK_MERGE(psw32_user_bits, tmp))\n\t\t\t\t/* Invalid psw mask. */\n\t\t\t\treturn -EINVAL;\n\t\t\ttask_pt_regs(child)->psw.mask =\n\t\t\t\tPSW_MASK_MERGE(psw_user32_bits, (__u64) tmp << 32);\n\t\t} else if (addr == (addr_t) &dummy32->regs.psw.addr) {\n\t\t\t/* Build a 64 bit psw address from 31 bit address. */\n\t\t\ttask_pt_regs(child)->psw.addr =\n\t\t\t\t(__u64) tmp & PSW32_ADDR_INSN;\n\t\t} else {\n\t\t\t/* gpr 0-15 */\n\t\t\t*(__u32*)((addr_t) &task_pt_regs(child)->psw\n\t\t\t\t  + addr*2 + 4) = tmp;\n\t\t}\n\t} else if (addr < (addr_t) (&dummy32->regs.orig_gpr2)) {\n\t\t/*\n\t\t * access registers are stored in the thread structure\n\t\t */\n\t\toffset = addr - (addr_t) &dummy32->regs.acrs;\n\t\t*(__u32*)((addr_t) &child->thread.acrs + offset) = tmp;\n\n\t} else if (addr == (addr_t) (&dummy32->regs.orig_gpr2)) {\n\t\t/*\n\t\t * orig_gpr2 is stored on the kernel stack\n\t\t */\n\t\t*(__u32*)((addr_t) &task_pt_regs(child)->orig_gpr2 + 4) = tmp;\n\n\t} else if (addr < (addr_t) (&dummy32->regs.fp_regs + 1)) {\n\t\t/*\n\t\t * floating point regs. are stored in the thread structure \n\t\t */\n\t\tif (addr == (addr_t) &dummy32->regs.fp_regs.fpc &&\n\t\t    (tmp & ~FPC_VALID_MASK) != 0)\n\t\t\t/* Invalid floating point control. */\n\t\t\treturn -EINVAL;\n\t        offset = addr - (addr_t) &dummy32->regs.fp_regs;\n\t\t*(__u32 *)((addr_t) &child->thread.fp_regs + offset) = tmp;\n\n\t} else if (addr < (addr_t) (&dummy32->regs.per_info + 1)) {\n\t\t/*\n\t\t * per_info is found in the thread structure.\n\t\t */\n\t\toffset = addr - (addr_t) &dummy32->regs.per_info;\n\t\t/*\n\t\t * This is magic. See per_struct and per_struct32.\n\t\t * By incident the offsets in per_struct are exactly\n\t\t * twice the offsets in per_struct32 for all fields.\n\t\t * The 8 byte fields need special handling though,\n\t\t * because the second half (bytes 4-7) is needed and\n\t\t * not the first half.\n\t\t */\n\t\tif ((offset >= (addr_t) &dummy_per32->control_regs &&\n\t\t     offset < (addr_t) (&dummy_per32->control_regs + 1)) ||\n\t\t    (offset >= (addr_t) &dummy_per32->starting_addr &&\n\t\t     offset <= (addr_t) &dummy_per32->ending_addr) ||\n\t\t    offset == (addr_t) &dummy_per32->lowcore.words.address)\n\t\t\toffset = offset*2 + 4;\n\t\telse\n\t\t\toffset = offset*2;\n\t\t*(__u32 *)((addr_t) &child->thread.per_info + offset) = tmp;\n\n\t}\n\n\tFixPerRegisters(child);\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static int __poke_user(struct task_struct *child, addr_t addr, addr_t data)\n{\n\tstruct user *dummy = NULL;\n\taddr_t offset;\n\n\tif (addr < (addr_t) &dummy->regs.acrs) {\n\t\t/*\n\t\t * psw and gprs are stored on the stack\n\t\t */\n\t\tif (addr == (addr_t) &dummy->regs.psw.mask &&\n#ifdef CONFIG_COMPAT\n\t\t    data != PSW_MASK_MERGE(psw_user32_bits, data) &&\n#endif\n\t\t    data != PSW_MASK_MERGE(psw_user_bits, data))\n\t\t\t/* Invalid psw mask. */\n\t\t\treturn -EINVAL;\n#ifndef CONFIG_64BIT\n\t\tif (addr == (addr_t) &dummy->regs.psw.addr)\n\t\t\t/* I'd like to reject addresses without the\n\t\t\t   high order bit but older gdb's rely on it */\n\t\t\tdata |= PSW_ADDR_AMODE;\n#endif\n\t\t*(addr_t *)((addr_t) &task_pt_regs(child)->psw + addr) = data;\n\n\t} else if (addr < (addr_t) (&dummy->regs.orig_gpr2)) {\n\t\t/*\n\t\t * access registers are stored in the thread structure\n\t\t */\n\t\toffset = addr - (addr_t) &dummy->regs.acrs;\n#ifdef CONFIG_64BIT\n\t\t/*\n\t\t * Very special case: old & broken 64 bit gdb writing\n\t\t * to acrs[15] with a 64 bit value. Ignore the lower\n\t\t * half of the value and write the upper 32 bit to\n\t\t * acrs[15]. Sick...\n\t\t */\n\t\tif (addr == (addr_t) &dummy->regs.acrs[15])\n\t\t\tchild->thread.acrs[15] = (unsigned int) (data >> 32);\n\t\telse\n#endif\n\t\t*(addr_t *)((addr_t) &child->thread.acrs + offset) = data;\n\n\t} else if (addr == (addr_t) &dummy->regs.orig_gpr2) {\n\t\t/*\n\t\t * orig_gpr2 is stored on the kernel stack\n\t\t */\n\t\ttask_pt_regs(child)->orig_gpr2 = data;\n\n\t} else if (addr < (addr_t) (&dummy->regs.fp_regs + 1)) {\n\t\t/*\n\t\t * floating point regs. are stored in the thread structure\n\t\t */\n\t\tif (addr == (addr_t) &dummy->regs.fp_regs.fpc &&\n\t\t    (data & ~((unsigned long) FPC_VALID_MASK\n\t\t\t      << (BITS_PER_LONG - 32))) != 0)\n\t\t\treturn -EINVAL;\n\t\toffset = addr - (addr_t) &dummy->regs.fp_regs;\n\t\t*(addr_t *)((addr_t) &child->thread.fp_regs + offset) = data;\n\n\t} else if (addr < (addr_t) (&dummy->regs.per_info + 1)) {\n\t\t/*\n\t\t * per_info is found in the thread structure \n\t\t */\n\t\toffset = addr - (addr_t) &dummy->regs.per_info;\n\t\t*(addr_t *)((addr_t) &child->thread.per_info + offset) = data;\n\n\t}\n\n\tFixPerRegisters(child);\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static u32 __peek_user_compat(struct task_struct *child, addr_t addr)\n{\n\tstruct user32 *dummy32 = NULL;\n\tper_struct32 *dummy_per32 = NULL;\n\taddr_t offset;\n\t__u32 tmp;\n\n\tif (addr < (addr_t) &dummy32->regs.acrs) {\n\t\t/*\n\t\t * psw and gprs are stored on the stack\n\t\t */\n\t\tif (addr == (addr_t) &dummy32->regs.psw.mask) {\n\t\t\t/* Fake a 31 bit psw mask. */\n\t\t\ttmp = (__u32)(task_pt_regs(child)->psw.mask >> 32);\n\t\t\ttmp = PSW32_MASK_MERGE(psw32_user_bits, tmp);\n\t\t} else if (addr == (addr_t) &dummy32->regs.psw.addr) {\n\t\t\t/* Fake a 31 bit psw address. */\n\t\t\ttmp = (__u32) task_pt_regs(child)->psw.addr |\n\t\t\t\tPSW32_ADDR_AMODE31;\n\t\t} else {\n\t\t\t/* gpr 0-15 */\n\t\t\ttmp = *(__u32 *)((addr_t) &task_pt_regs(child)->psw +\n\t\t\t\t\t addr*2 + 4);\n\t\t}\n\t} else if (addr < (addr_t) (&dummy32->regs.orig_gpr2)) {\n\t\t/*\n\t\t * access registers are stored in the thread structure\n\t\t */\n\t\toffset = addr - (addr_t) &dummy32->regs.acrs;\n\t\ttmp = *(__u32*)((addr_t) &child->thread.acrs + offset);\n\n\t} else if (addr == (addr_t) (&dummy32->regs.orig_gpr2)) {\n\t\t/*\n\t\t * orig_gpr2 is stored on the kernel stack\n\t\t */\n\t\ttmp = *(__u32*)((addr_t) &task_pt_regs(child)->orig_gpr2 + 4);\n\n\t} else if (addr < (addr_t) (&dummy32->regs.fp_regs + 1)) {\n\t\t/*\n\t\t * floating point regs. are stored in the thread structure \n\t\t */\n\t        offset = addr - (addr_t) &dummy32->regs.fp_regs;\n\t\ttmp = *(__u32 *)((addr_t) &child->thread.fp_regs + offset);\n\n\t} else if (addr < (addr_t) (&dummy32->regs.per_info + 1)) {\n\t\t/*\n\t\t * per_info is found in the thread structure\n\t\t */\n\t\toffset = addr - (addr_t) &dummy32->regs.per_info;\n\t\t/* This is magic. See per_struct and per_struct32. */\n\t\tif ((offset >= (addr_t) &dummy_per32->control_regs &&\n\t\t     offset < (addr_t) (&dummy_per32->control_regs + 1)) ||\n\t\t    (offset >= (addr_t) &dummy_per32->starting_addr &&\n\t\t     offset <= (addr_t) &dummy_per32->ending_addr) ||\n\t\t    offset == (addr_t) &dummy_per32->lowcore.words.address)\n\t\t\toffset = offset*2 + 4;\n\t\telse\n\t\t\toffset = offset*2;\n\t\ttmp = *(__u32 *)((addr_t) &child->thread.per_info + offset);\n\n\t} else\n\t\ttmp = 0;\n\n\treturn tmp;\n}",
        "target": 1
    },
    {
        "func": "int fcntl_dirnotify(int fd, struct file *filp, unsigned long arg)\n{\n\tstruct dnotify_struct *dn;\n\tstruct dnotify_struct *odn;\n\tstruct dnotify_struct **prev;\n\tstruct inode *inode;\n\tfl_owner_t id = current->files;\n\tint error = 0;\n\n\tif ((arg & ~DN_MULTISHOT) == 0) {\n\t\tdnotify_flush(filp, id);\n\t\treturn 0;\n\t}\n\tif (!dir_notify_enable)\n\t\treturn -EINVAL;\n\tinode = filp->f_path.dentry->d_inode;\n\tif (!S_ISDIR(inode->i_mode))\n\t\treturn -ENOTDIR;\n\tdn = kmem_cache_alloc(dn_cache, GFP_KERNEL);\n\tif (dn == NULL)\n\t\treturn -ENOMEM;\n\tspin_lock(&inode->i_lock);\n\tprev = &inode->i_dnotify;\n\twhile ((odn = *prev) != NULL) {\n\t\tif ((odn->dn_owner == id) && (odn->dn_filp == filp)) {\n\t\t\todn->dn_fd = fd;\n\t\t\todn->dn_mask |= arg;\n\t\t\tinode->i_dnotify_mask |= arg & ~DN_MULTISHOT;\n\t\t\tgoto out_free;\n\t\t}\n\t\tprev = &odn->dn_next;\n\t}\n\n\terror = __f_setown(filp, task_pid(current), PIDTYPE_PID, 0);\n\tif (error)\n\t\tgoto out_free;\n\n\tdn->dn_mask = arg;\n\tdn->dn_fd = fd;\n\tdn->dn_filp = filp;\n\tdn->dn_owner = id;\n\tinode->i_dnotify_mask |= arg & ~DN_MULTISHOT;\n\tdn->dn_next = inode->i_dnotify;\n\tinode->i_dnotify = dn;\n\tspin_unlock(&inode->i_lock);\n\n\tif (filp->f_op && filp->f_op->dir_notify)\n\t\treturn filp->f_op->dir_notify(filp, arg);\n\treturn 0;\n\nout_free:\n\tspin_unlock(&inode->i_lock);\n\tkmem_cache_free(dn_cache, dn);\n\treturn error;\n}",
        "target": 1
    },
    {
        "func": "hrtimer_forward(struct hrtimer *timer, ktime_t now, ktime_t interval)\n{\n\tunsigned long orun = 1;\n\tktime_t delta;\n\n\tdelta = ktime_sub(now, timer->expires);\n\n\tif (delta.tv64 < 0)\n\t\treturn 0;\n\n\tif (interval.tv64 < timer->base->resolution.tv64)\n\t\tinterval.tv64 = timer->base->resolution.tv64;\n\n\tif (unlikely(delta.tv64 >= interval.tv64)) {\n\t\ts64 incr = ktime_to_ns(interval);\n\n\t\torun = ktime_divns(delta, incr);\n\t\ttimer->expires = ktime_add_ns(timer->expires, incr * orun);\n\t\tif (timer->expires.tv64 > now.tv64)\n\t\t\treturn orun;\n\t\t/*\n\t\t * This (and the ktime_add() below) is the\n\t\t * correction for exact:\n\t\t */\n\t\torun++;\n\t}\n\ttimer->expires = ktime_add(timer->expires, interval);\n\n\treturn orun;\n}",
        "target": 1
    },
    {
        "func": "CairoFont *CairoFont::create(GfxFont *gfxFont, XRef *xref, FT_Library lib, GBool useCIDs) {\n  Ref embRef;\n  Object refObj, strObj;\n  GooString *tmpFileName, *fileName,*tmpFileName2;\n  DisplayFontParam *dfp;\n  FILE *tmpFile;\n  int c, i, n;\n  GfxFontType fontType;\n  char **enc;\n  char *name;\n  FoFiTrueType *ff;\n  FoFiType1C *ff1c;\n  Ref ref;\n  static cairo_user_data_key_t cairo_font_face_key;\n  cairo_font_face_t *cairo_font_face;\n  FT_Face face;\n\n  Gushort *codeToGID;\n  int codeToGIDLen;\n  \n  dfp = NULL;\n  codeToGID = NULL;\n  codeToGIDLen = 0;\n  cairo_font_face = NULL;\n  \n  ref = *gfxFont->getID();\n  fontType = gfxFont->getType();\n\n  tmpFileName = NULL;\n\n  if (gfxFont->getEmbeddedFontID(&embRef)) {\n    if (!openTempFile(&tmpFileName, &tmpFile, \"wb\", NULL)) {\n      error(-1, \"Couldn't create temporary font file\");\n      goto err2;\n    }\n    \n    refObj.initRef(embRef.num, embRef.gen);\n    refObj.fetch(xref, &strObj);\n    refObj.free();\n    strObj.streamReset();\n    while ((c = strObj.streamGetChar()) != EOF) {\n      fputc(c, tmpFile);\n    }\n    strObj.streamClose();\n    strObj.free();\n    fclose(tmpFile);\n    fileName = tmpFileName;\n    \n  } else if (!(fileName = gfxFont->getExtFontFile())) {\n    // look for a display font mapping or a substitute font\n    dfp = NULL;\n    if (gfxFont->getName()) {\n      dfp = globalParams->getDisplayFont(gfxFont);\n    }\n    if (!dfp) {\n      error(-1, \"Couldn't find a font for '%s'\",\n\t    gfxFont->getName() ? gfxFont->getName()->getCString()\n\t    : \"(unnamed)\");\n      goto err2;\n    }\n    switch (dfp->kind) {\n    case displayFontT1:\n      fileName = dfp->t1.fileName;\n      fontType = gfxFont->isCIDFont() ? fontCIDType0 : fontType1;\n      break;\n    case displayFontTT:\n      fileName = dfp->tt.fileName;\n      fontType = gfxFont->isCIDFont() ? fontCIDType2 : fontTrueType;\n      break;\n    }\n  }\n\n  switch (fontType) {\n  case fontType1:\n  case fontType1C:\n    if (FT_New_Face(lib, fileName->getCString(), 0, &face)) {\n      error(-1, \"could not create type1 face\");\n      goto err2;\n    }\n    \n    enc = ((Gfx8BitFont *)gfxFont)->getEncoding();\n    \n    codeToGID = (Gushort *)gmallocn(256, sizeof(int));\n    codeToGIDLen = 256;\n    for (i = 0; i < 256; ++i) {\n      codeToGID[i] = 0;\n      if ((name = enc[i])) {\n\tcodeToGID[i] = (Gushort)FT_Get_Name_Index(face, name);\n      }\n    }\n    break;\n    \n  case fontCIDType2:\n    codeToGID = NULL;\n    n = 0;\n    if (((GfxCIDFont *)gfxFont)->getCIDToGID()) {\n      n = ((GfxCIDFont *)gfxFont)->getCIDToGIDLen();\n      if (n) {\n\tcodeToGID = (Gushort *)gmallocn(n, sizeof(Gushort));\n\tmemcpy(codeToGID, ((GfxCIDFont *)gfxFont)->getCIDToGID(),\n\t\tn * sizeof(Gushort));\n      }\n    } else {\n      ff = FoFiTrueType::load(fileName->getCString());\n      if (! ff)\n\tgoto err2;\n      codeToGID = ((GfxCIDFont *)gfxFont)->getCodeToGIDMap(ff, &n);\n      delete ff;\n    }\n    codeToGIDLen = n;\n    /* Fall through */\n  case fontTrueType:\n    if (!(ff = FoFiTrueType::load(fileName->getCString()))) {\n      error(-1, \"failed to load truetype font\\n\");\n      goto err2;\n    }\n    /* This might be set already for the CIDType2 case */\n    if (fontType == fontTrueType) {\n      codeToGID = ((Gfx8BitFont *)gfxFont)->getCodeToGIDMap(ff);\n      codeToGIDLen = 256;\n    }\n    if (!openTempFile(&tmpFileName2, &tmpFile, \"wb\", NULL)) {\n      delete ff;\n      error(-1, \"failed to open truetype tempfile\\n\");\n      goto err2;\n    }\n    ff->writeTTF(&fileWrite, tmpFile);\n    fclose(tmpFile);\n    delete ff;\n\n    if (FT_New_Face(lib, tmpFileName2->getCString(), 0, &face)) {\n      error(-1, \"could not create truetype face\\n\");\n      goto err2;\n    }\n    unlink (tmpFileName2->getCString());\n    delete tmpFileName2;\n    break;\n    \n  case fontCIDType0:\n  case fontCIDType0C:\n\n    codeToGID = NULL;\n    codeToGIDLen = 0;\n\n    if (!useCIDs)\n    {\n      if ((ff1c = FoFiType1C::load(fileName->getCString()))) {\n        codeToGID = ff1c->getCIDToGIDMap(&codeToGIDLen);\n        delete ff1c;\n      }\n    }\n\n    if (FT_New_Face(lib, fileName->getCString(), 0, &face)) {\n      gfree(codeToGID);\n      codeToGID = NULL;\n      error(-1, \"could not create cid face\\n\");\n      goto err2;\n    }\n    break;\n    \n  default:\n    printf (\"font type not handled\\n\");\n    goto err2;\n    break;\n  }\n\n  // delete the (temporary) font file -- with Unix hard link\n  // semantics, this will remove the last link; otherwise it will\n  // return an error, leaving the file to be deleted later\n  if (fileName == tmpFileName) {\n    unlink (fileName->getCString());\n    delete tmpFileName;\n  }\n\n  cairo_font_face = cairo_ft_font_face_create_for_ft_face (face,\n\t\t\t\t\t\t\t   FT_LOAD_NO_HINTING |\n\t\t\t\t\t\t\t   FT_LOAD_NO_BITMAP);\n  if (cairo_font_face == NULL) {\n    error(-1, \"could not create cairo font\\n\");\n    goto err2; /* this doesn't do anything, but it looks like we're\n\t\t* handling the error */\n  } {\n  CairoFont *ret = new CairoFont(ref, cairo_font_face, face, codeToGID, codeToGIDLen);\n  cairo_font_face_set_user_data (cairo_font_face, \n\t\t\t\t &cairo_font_face_key,\n\t\t\t\t ret,\n\t\t\t\t cairo_font_face_destroy);\n\n  return ret;\n  }\n err2:\n  /* hmm? */\n  printf (\"some font thing failed\\n\");\n  return NULL;\n}",
        "target": 1
    },
    {
        "func": "m4_mkstemp (struct obstack *obs, int argc, token_data **argv)\n{\n  if (bad_argc (argv[0], argc, 2, 2))\n    return;\n  mkstemp_helper (obs, ARG (1));\n}",
        "target": 1
    },
    {
        "func": "mkstemp_helper (struct obstack *obs, const char *name)\n{\n  int fd;\n  int len;\n  int i;\n\n  /* Guarantee that there are six trailing 'X' characters, even if the\n     user forgot to supply them.  */\n  len = strlen (name);\n  obstack_grow (obs, name, len);\n  for (i = 0; len > 0 && i < 6; i++)\n    if (name[--len] != 'X')\n      break;\n  for (; i < 6; i++)\n    obstack_1grow (obs, 'X');\n  obstack_1grow (obs, '\\0');\n\n  errno = 0;\n  fd = mkstemp ((char *) obstack_base (obs));\n  if (fd < 0)\n    {\n      M4ERROR ((0, errno, \"cannot create tempfile `%s'\", name));\n      obstack_free (obs, obstack_finish (obs));\n    }\n  else\n    close (fd);\n}",
        "target": 1
    },
    {
        "func": "m4_maketemp (struct obstack *obs, int argc, token_data **argv)\n{\n  if (bad_argc (argv[0], argc, 2, 2))\n    return;\n  if (no_gnu_extensions)\n    {\n      /* POSIX states \"any trailing 'X' characters [are] replaced with\n\t the current process ID as a string\", without referencing the\n\t file system.  Horribly insecure, but we have to do it when we\n\t are in traditional mode.\n\n\t For reference, Solaris m4 does:\n\t   maketemp() -> `'\n\t   maketemp(X) -> `X'\n\t   maketemp(XX) -> `Xn', where n is last digit of pid\n\t   maketemp(XXXXXXXX) -> `X00nnnnn', where nnnnn is 16-bit pid\n      */\n      const char *str = ARG (1);\n      int len = strlen (str);\n      int i;\n      int len2;\n\n      M4ERROR ((warning_status, 0, \"recommend using mkstemp instead\"));\n      for (i = len; i > 1; i--)\n\tif (str[i - 1] != 'X')\n\t  break;\n      obstack_grow (obs, str, i);\n      str = ntoa ((int32_t) getpid (), 10);\n      len2 = strlen (str);\n      if (len2 > len - i)\n\tobstack_grow0 (obs, str + len2 - (len - i), len - i);\n      else\n\t{\n\t  while (i++ < len - len2)\n\t    obstack_1grow (obs, '0');\n\t  obstack_grow0 (obs, str, len2);\n\t}\n    }\n  else\n    mkstemp_helper (obs, ARG (1));\n}",
        "target": 1
    },
    {
        "func": "produce_frozen_state (const char *name)\n{\n  FILE *file;\n  int h;\n  symbol *sym;\n  const builtin *bp;\n\n  if (file = fopen (name, O_BINARY ? \"wb\" : \"w\"), !file)\n    {\n      M4ERROR ((warning_status, errno, name));\n      return;\n    }\n\n  /* Write a recognizable header.  */\n\n  xfprintf (file, \"# This is a frozen state file generated by %s\\n\",\n\t   PACKAGE_STRING);\n  xfprintf (file, \"V1\\n\");\n\n  /* Dump quote delimiters.  */\n\n  if (strcmp (lquote.string, DEF_LQUOTE) || strcmp (rquote.string, DEF_RQUOTE))\n    {\n      xfprintf (file, \"Q%d,%d\\n\", (int) lquote.length, (int) rquote.length);\n      fputs (lquote.string, file);\n      fputs (rquote.string, file);\n      fputc ('\\n', file);\n    }\n\n  /* Dump comment delimiters.  */\n\n  if (strcmp (bcomm.string, DEF_BCOMM) || strcmp (ecomm.string, DEF_ECOMM))\n    {\n      xfprintf (file, \"C%d,%d\\n\", (int) bcomm.length, (int) ecomm.length);\n      fputs (bcomm.string, file);\n      fputs (ecomm.string, file);\n      fputc ('\\n', file);\n    }\n\n  /* Dump all symbols.  */\n\n  for (h = 0; h < hash_table_size; h++)\n    {\n\n      /* Process all entries in one bucket, from the last to the first.\n\t This order ensures that, at reload time, pushdef's will be\n\t executed with the oldest definitions first.  */\n\n      symtab[h] = reverse_symbol_list (symtab[h]);\n      for (sym = symtab[h]; sym; sym = SYMBOL_NEXT (sym))\n\t{\n\t  switch (SYMBOL_TYPE (sym))\n\t    {\n\t    case TOKEN_TEXT:\n\t      xfprintf (file, \"T%d,%d\\n\",\n\t\t\t(int) strlen (SYMBOL_NAME (sym)),\n\t\t\t(int) strlen (SYMBOL_TEXT (sym)));\n\t      fputs (SYMBOL_NAME (sym), file);\n\t      fputs (SYMBOL_TEXT (sym), file);\n\t      fputc ('\\n', file);\n\t      break;\n\n\t    case TOKEN_FUNC:\n\t      bp = find_builtin_by_addr (SYMBOL_FUNC (sym));\n\t      if (bp == NULL)\n\t\t{\n\t\t  M4ERROR ((warning_status, 0, \"\\\nINTERNAL ERROR: builtin not found in builtin table!\"));\n\t\t  abort ();\n\t\t}\n\t      xfprintf (file, \"F%d,%d\\n\",\n\t\t\t(int) strlen (SYMBOL_NAME (sym)),\n\t\t\t(int) strlen (bp->name));\n\t      fputs (SYMBOL_NAME (sym), file);\n\t      fputs (bp->name, file);\n\t      fputc ('\\n', file);\n\t      break;\n\n\t    case TOKEN_VOID:\n\t      /* Ignore placeholder tokens that exist due to traceon.  */\n\t      break;\n\n\t    default:\n\t      M4ERROR ((warning_status, 0, \"\\\nINTERNAL ERROR: bad token data type in freeze_one_symbol ()\"));\n\t      abort ();\n\t      break;\n\t    }\n\t}\n\n      /* Reverse the bucket once more, putting it back as it was.  */\n\n      symtab[h] = reverse_symbol_list (symtab[h]);\n    }\n\n  /* Let diversions be issued from output.c module, its cleaner to have this\n     piece of code there.  */\n\n  freeze_diversions (file);\n\n  /* All done.  */\n\n  fputs (\"# End of frozen state file\\n\", file);\n  if (close_stream (file) != 0)\n    M4ERROR ((EXIT_FAILURE, errno, \"unable to create frozen state\"));\n}",
        "target": 1
    },
    {
        "func": "static unsigned char asn1_oid_decode(struct asn1_ctx *ctx,\n\t\t\t\t     unsigned char *eoc,\n\t\t\t\t     unsigned long **oid,\n\t\t\t\t     unsigned int *len)\n{\n\tunsigned long subid;\n\tunsigned int  size;\n\tunsigned long *optr;\n\n\tsize = eoc - ctx->pointer + 1;\n\t*oid = kmalloc(size * sizeof(unsigned long), GFP_ATOMIC);\n\tif (*oid == NULL) {\n\t\tif (net_ratelimit())\n\t\t\tprintk(\"OOM in bsalg (%d)\\n\", __LINE__);\n\t\treturn 0;\n\t}\n\n\toptr = *oid;\n\n\tif (!asn1_subid_decode(ctx, &subid)) {\n\t\tkfree(*oid);\n\t\t*oid = NULL;\n\t\treturn 0;\n\t}\n\n\tif (subid < 40) {\n\t\toptr [0] = 0;\n\t\toptr [1] = subid;\n\t} else if (subid < 80) {\n\t\toptr [0] = 1;\n\t\toptr [1] = subid - 40;\n\t} else {\n\t\toptr [0] = 2;\n\t\toptr [1] = subid - 80;\n\t}\n\n\t*len = 2;\n\toptr += 2;\n\n\twhile (ctx->pointer < eoc) {\n\t\tif (++(*len) > size) {\n\t\t\tctx->error = ASN1_ERR_DEC_BADVALUE;\n\t\t\tkfree(*oid);\n\t\t\t*oid = NULL;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (!asn1_subid_decode(ctx, optr++)) {\n\t\t\tkfree(*oid);\n\t\t\t*oid = NULL;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
        "target": 1
    },
    {
        "func": "asn1_oid_decode(struct asn1_ctx *ctx,\n\t\tunsigned char *eoc, unsigned long **oid, unsigned int *len)\n{\n\tunsigned long subid;\n\tunsigned int size;\n\tunsigned long *optr;\n\n\tsize = eoc - ctx->pointer + 1;\n\t*oid = kmalloc(size * sizeof(unsigned long), GFP_ATOMIC);\n\tif (*oid == NULL)\n\t\treturn 0;\n\n\toptr = *oid;\n\n\tif (!asn1_subid_decode(ctx, &subid)) {\n\t\tkfree(*oid);\n\t\t*oid = NULL;\n\t\treturn 0;\n\t}\n\n\tif (subid < 40) {\n\t\toptr[0] = 0;\n\t\toptr[1] = subid;\n\t} else if (subid < 80) {\n\t\toptr[0] = 1;\n\t\toptr[1] = subid - 40;\n\t} else {\n\t\toptr[0] = 2;\n\t\toptr[1] = subid - 80;\n\t}\n\n\t*len = 2;\n\toptr += 2;\n\n\twhile (ctx->pointer < eoc) {\n\t\tif (++(*len) > size) {\n\t\t\tctx->error = ASN1_ERR_DEC_BADVALUE;\n\t\t\tkfree(*oid);\n\t\t\t*oid = NULL;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (!asn1_subid_decode(ctx, optr++)) {\n\t\t\tkfree(*oid);\n\t\t\t*oid = NULL;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
        "target": 1
    },
    {
        "func": "asn1_header_decode(struct asn1_ctx *ctx,\n\t\t   unsigned char **eoc,\n\t\t   unsigned int *cls, unsigned int *con, unsigned int *tag)\n{\n\tunsigned int def = 0;\n\tunsigned int len = 0;\n\n\tif (!asn1_id_decode(ctx, cls, con, tag))\n\t\treturn 0;\n\n\tif (!asn1_length_decode(ctx, &def, &len))\n\t\treturn 0;\n\n\tif (def)\n\t\t*eoc = ctx->pointer + len;\n\telse\n\t\t*eoc = NULL;\n\treturn 1;\n}",
        "target": 1
    },
    {
        "func": "static unsigned char asn1_header_decode(struct asn1_ctx *ctx,\n\t\t\t\t\tunsigned char **eoc,\n\t\t\t\t\tunsigned int *cls,\n\t\t\t\t\tunsigned int *con,\n\t\t\t\t\tunsigned int *tag)\n{\n\tunsigned int def, len;\n\n\tif (!asn1_id_decode(ctx, cls, con, tag))\n\t\treturn 0;\n\n\tdef = len = 0;\n\tif (!asn1_length_decode(ctx, &def, &len))\n\t\treturn 0;\n\n\tif (def)\n\t\t*eoc = ctx->pointer + len;\n\telse\n\t\t*eoc = NULL;\n\treturn 1;\n}",
        "target": 1
    },
    {
        "func": "static unsigned char asn1_length_decode(struct asn1_ctx *ctx,\n\t\t\t\t\tunsigned int *def,\n\t\t\t\t\tunsigned int *len)\n{\n\tunsigned char ch, cnt;\n\n\tif (!asn1_octet_decode(ctx, &ch))\n\t\treturn 0;\n\n\tif (ch == 0x80)\n\t\t*def = 0;\n\telse {\n\t\t*def = 1;\n\n\t\tif (ch < 0x80)\n\t\t\t*len = ch;\n\t\telse {\n\t\t\tcnt = ch & 0x7F;\n\t\t\t*len = 0;\n\n\t\t\twhile (cnt > 0) {\n\t\t\t\tif (!asn1_octet_decode(ctx, &ch))\n\t\t\t\t\treturn 0;\n\t\t\t\t*len <<= 8;\n\t\t\t\t*len |= ch;\n\t\t\t\tcnt--;\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}",
        "target": 1
    },
    {
        "func": "asn1_length_decode(struct asn1_ctx *ctx, unsigned int *def, unsigned int *len)\n{\n\tunsigned char ch, cnt;\n\n\tif (!asn1_octet_decode(ctx, &ch))\n\t\treturn 0;\n\n\tif (ch == 0x80)\n\t\t*def = 0;\n\telse {\n\t\t*def = 1;\n\n\t\tif (ch < 0x80)\n\t\t\t*len = ch;\n\t\telse {\n\t\t\tcnt = (unsigned char) (ch & 0x7F);\n\t\t\t*len = 0;\n\n\t\t\twhile (cnt > 0) {\n\t\t\t\tif (!asn1_octet_decode(ctx, &ch))\n\t\t\t\t\treturn 0;\n\t\t\t\t*len <<= 8;\n\t\t\t\t*len |= ch;\n\t\t\t\tcnt--;\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}",
        "target": 1
    },
    {
        "func": "static int ipip6_rcv(struct sk_buff *skb)\n{\n\tstruct iphdr *iph;\n\tstruct ip_tunnel *tunnel;\n\n\tif (!pskb_may_pull(skb, sizeof(struct ipv6hdr)))\n\t\tgoto out;\n\n\tiph = ip_hdr(skb);\n\n\tread_lock(&ipip6_lock);\n\tif ((tunnel = ipip6_tunnel_lookup(dev_net(skb->dev),\n\t\t\t\t\tiph->saddr, iph->daddr)) != NULL) {\n\t\tsecpath_reset(skb);\n\t\tskb->mac_header = skb->network_header;\n\t\tskb_reset_network_header(skb);\n\t\tIPCB(skb)->flags = 0;\n\t\tskb->protocol = htons(ETH_P_IPV6);\n\t\tskb->pkt_type = PACKET_HOST;\n\n\t\tif ((tunnel->dev->priv_flags & IFF_ISATAP) &&\n\t\t    !isatap_chksrc(skb, iph, tunnel)) {\n\t\t\ttunnel->stat.rx_errors++;\n\t\t\tread_unlock(&ipip6_lock);\n\t\t\tkfree_skb(skb);\n\t\t\treturn 0;\n\t\t}\n\t\ttunnel->stat.rx_packets++;\n\t\ttunnel->stat.rx_bytes += skb->len;\n\t\tskb->dev = tunnel->dev;\n\t\tdst_release(skb->dst);\n\t\tskb->dst = NULL;\n\t\tnf_reset(skb);\n\t\tipip6_ecn_decapsulate(iph, skb);\n\t\tnetif_rx(skb);\n\t\tread_unlock(&ipip6_lock);\n\t\treturn 0;\n\t}\n\n\ticmp_send(skb, ICMP_DEST_UNREACH, ICMP_PORT_UNREACH, 0);\n\tkfree_skb(skb);\n\tread_unlock(&ipip6_lock);\nout:\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static u64 sched_slice(struct cfs_rq *cfs_rq, struct sched_entity *se)\n{\n\tu64 slice = __sched_period(cfs_rq->nr_running);\n\n\tslice *= se->load.weight;\n\tdo_div(slice, cfs_rq->load.weight);\n\n\treturn slice;\n}",
        "target": 1
    },
    {
        "func": "static u64 sched_vslice_add(struct cfs_rq *cfs_rq, struct sched_entity *se)\n{\n\treturn __sched_vslice(cfs_rq->load.weight + se->load.weight,\n\t\t\tcfs_rq->nr_running + 1);\n}",
        "target": 1
    },
    {
        "func": "static u64 __sched_vslice(unsigned long rq_weight, unsigned long nr_running)\n{\n\tu64 vslice = __sched_period(nr_running);\n\n\tvslice *= NICE_0_LOAD;\n\tdo_div(vslice, rq_weight);\n\n\treturn vslice;\n}",
        "target": 1
    },
    {
        "func": "static u64 sched_slice(struct cfs_rq *cfs_rq, struct sched_entity *se)\n{\n\treturn calc_delta_mine(__sched_period(cfs_rq->nr_running),\n\t\t\t       se->load.weight, &cfs_rq->load);\n}",
        "target": 1
    },
    {
        "func": "static u64 sched_vslice_add(struct cfs_rq *cfs_rq, struct sched_entity *se)\n{\n\tunsigned long nr_running = cfs_rq->nr_running;\n\tunsigned long weight;\n\tu64 vslice;\n\n\tif (!se->on_rq)\n\t\tnr_running++;\n\n\tvslice = __sched_period(nr_running);\n\n\tfor_each_sched_entity(se) {\n\t\tcfs_rq = cfs_rq_of(se);\n\n\t\tweight = cfs_rq->load.weight;\n\t\tif (!se->on_rq)\n\t\t\tweight += se->load.weight;\n\n\t\tvslice *= NICE_0_LOAD;\n\t\tdo_div(vslice, weight);\n\t}\n\n\treturn vslice;\n}",
        "target": 1
    },
    {
        "func": "static unsigned long wakeup_gran(struct sched_entity *se)\n{\n\tunsigned long gran = sysctl_sched_wakeup_granularity;\n\n\t/*\n\t * More easily preempt - nice tasks, while not making\n\t * it harder for + nice tasks.\n\t */\n\tif (unlikely(se->load.weight > NICE_0_LOAD))\n\t\tgran = calc_delta_fair(gran, &se->load);\n\n\treturn gran;\n}",
        "target": 1
    },
    {
        "func": "static u64 sched_slice(struct cfs_rq *cfs_rq, struct sched_entity *se)\n{\n\tu64 slice = __sched_period(cfs_rq->nr_running);\n\n\tfor_each_sched_entity(se) {\n\t\tcfs_rq = cfs_rq_of(se);\n\n\t\tslice *= se->load.weight;\n\t\tdo_div(slice, cfs_rq->load.weight);\n\t}\n\n\n\treturn slice;\n}",
        "target": 1
    },
    {
        "func": "calc_delta_fair(unsigned long delta_exec, struct load_weight *lw)\n{\n\treturn calc_delta_mine(delta_exec, NICE_0_LOAD, lw);\n}",
        "target": 1
    },
    {
        "func": "place_entity(struct cfs_rq *cfs_rq, struct sched_entity *se, int initial)\n{\n\tu64 vruntime;\n\n\tif (first_fair(cfs_rq)) {\n\t\tvruntime = min_vruntime(cfs_rq->min_vruntime,\n\t\t\t\t__pick_next_entity(cfs_rq)->vruntime);\n\t} else\n\t\tvruntime = cfs_rq->min_vruntime;\n\n\t/*\n\t * The 'current' period is already promised to the current tasks,\n\t * however the extra weight of the new task will slow them down a\n\t * little, place the new task so that it fits in the slot that\n\t * stays open at the end.\n\t */\n\tif (initial && sched_feat(START_DEBIT))\n\t\tvruntime += sched_vslice_add(cfs_rq, se);\n\n\tif (!initial) {\n\t\t/* sleeps upto a single latency don't count. */\n\t\tif (sched_feat(NEW_FAIR_SLEEPERS)) {\n\t\t\tif (sched_feat(NORMALIZED_SLEEPER))\n\t\t\t\tvruntime -= calc_delta_fair(sysctl_sched_latency,\n\t\t\t\t\t\t&cfs_rq->load);\n\t\t\telse\n\t\t\t\tvruntime -= sysctl_sched_latency;\n\t\t}\n\n\t\t/* ensure we never gain time by being placed backwards. */\n\t\tvruntime = max_vruntime(se->vruntime, vruntime);\n\t}\n\n\tse->vruntime = vruntime;\n}",
        "target": 1
    },
    {
        "func": "__update_curr(struct cfs_rq *cfs_rq, struct sched_entity *curr,\n\t      unsigned long delta_exec)\n{\n\tunsigned long delta_exec_weighted;\n\n\tschedstat_set(curr->exec_max, max((u64)delta_exec, curr->exec_max));\n\n\tcurr->sum_exec_runtime += delta_exec;\n\tschedstat_add(cfs_rq, exec_clock, delta_exec);\n\tdelta_exec_weighted = delta_exec;\n\tif (unlikely(curr->load.weight != NICE_0_LOAD)) {\n\t\tdelta_exec_weighted = calc_delta_fair(delta_exec_weighted,\n\t\t\t\t\t\t\t&curr->load);\n\t}\n\tcurr->vruntime += delta_exec_weighted;\n}",
        "target": 1
    },
    {
        "func": "_gnutls_server_name_recv_params (gnutls_session_t session,\n\t\t\t\t const opaque * data, size_t _data_size)\n{\n  int i;\n  const unsigned char *p;\n  uint16_t len, type;\n  ssize_t data_size = _data_size;\n  int server_names = 0;\n\n  if (session->security_parameters.entity == GNUTLS_SERVER)\n    {\n      DECR_LENGTH_RET (data_size, 2, 0);\n      len = _gnutls_read_uint16 (data);\n\n      if (len != data_size)\n\t{\n\t  /* This is unexpected packet length, but\n\t   * just ignore it, for now.\n\t   */\n\t  gnutls_assert ();\n\t  return 0;\n\t}\n\n      p = data + 2;\n\n      /* Count all server_names in the packet. */\n      while (data_size > 0)\n\t{\n\t  DECR_LENGTH_RET (data_size, 1, 0);\n\t  p++;\n\n\t  DECR_LEN (data_size, 2);\n\t  len = _gnutls_read_uint16 (p);\n\t  p += 2;\n\n\t  DECR_LENGTH_RET (data_size, len, 0);\n\t  server_names++;\n\n\t  p += len;\n\t}\n\n      session->security_parameters.extensions.server_names_size =\n\tserver_names;\n      if (server_names == 0)\n\treturn 0;\t\t/* no names found */\n\n      /* we cannot accept more server names.\n       */\n      if (server_names > MAX_SERVER_NAME_EXTENSIONS)\n\tserver_names = MAX_SERVER_NAME_EXTENSIONS;\n\n      p = data + 2;\n      for (i = 0; i < server_names; i++)\n\t{\n\t  type = *p;\n\t  p++;\n\n\t  len = _gnutls_read_uint16 (p);\n\t  p += 2;\n\n\t  switch (type)\n\t    {\n\t    case 0:\t\t/* NAME_DNS */\n\t      if (len <= MAX_SERVER_NAME_SIZE)\n\t\t{\n\t\t  memcpy (session->security_parameters.extensions.\n\t\t\t  server_names[i].name, p, len);\n\t\t  session->security_parameters.extensions.\n\t\t    server_names[i].name_length = len;\n\t\t  session->security_parameters.extensions.\n\t\t    server_names[i].type = GNUTLS_NAME_DNS;\n\t\t  break;\n\t\t}\n\t    }\n\n\t  /* move to next record */\n\t  p += len;\n\t}\n    }\n  return 0;\n}",
        "target": 1
    },
    {
        "func": "_gnutls_ciphertext2compressed (gnutls_session_t session,\n\t\t\t       opaque * compress_data,\n\t\t\t       int compress_size,\n\t\t\t       gnutls_datum_t ciphertext, uint8_t type)\n{\n  uint8_t MAC[MAX_HASH_SIZE];\n  uint16_t c_length;\n  uint8_t pad;\n  int length;\n  digest_hd_st td;\n  uint16_t blocksize;\n  int ret, i, pad_failed = 0;\n  uint8_t major, minor;\n  gnutls_protocol_t ver;\n  int hash_size =\n    _gnutls_hash_get_algo_len (session->security_parameters.\n\t\t\t       read_mac_algorithm);\n\n  ver = gnutls_protocol_get_version (session);\n  minor = _gnutls_version_get_minor (ver);\n  major = _gnutls_version_get_major (ver);\n\n  blocksize = _gnutls_cipher_get_block_size (session->security_parameters.\n\t\t\t\t\t     read_bulk_cipher_algorithm);\n\n  /* initialize MAC \n   */\n  ret = mac_init (&td, session->security_parameters.read_mac_algorithm,\n\t\t session->connection_state.read_mac_secret.data,\n\t\t session->connection_state.read_mac_secret.size, ver);\n\n  if (ret < 0\n      && session->security_parameters.read_mac_algorithm != GNUTLS_MAC_NULL)\n    {\n      gnutls_assert ();\n      return GNUTLS_E_INTERNAL_ERROR;\n    }\n\n\n  /* actual decryption (inplace)\n   */\n  switch (_gnutls_cipher_is_block\n\t  (session->security_parameters.read_bulk_cipher_algorithm))\n    {\n    case CIPHER_STREAM:\n      if ((ret = _gnutls_cipher_decrypt (&session->connection_state.\n\t\t\t\t\t read_cipher_state,\n\t\t\t\t\t ciphertext.data,\n\t\t\t\t\t ciphertext.size)) < 0)\n\t{\n\t  gnutls_assert ();\n\t  return ret;\n\t}\n\n      length = ciphertext.size - hash_size;\n\n      break;\n    case CIPHER_BLOCK:\n      if ((ciphertext.size < blocksize) || (ciphertext.size % blocksize != 0))\n\t{\n\t  gnutls_assert ();\n\t  return GNUTLS_E_DECRYPTION_FAILED;\n\t}\n\n      if ((ret = _gnutls_cipher_decrypt (&session->connection_state.\n\t\t\t\t\t read_cipher_state,\n\t\t\t\t\t ciphertext.data,\n\t\t\t\t\t ciphertext.size)) < 0)\n\t{\n\t  gnutls_assert ();\n\t  return ret;\n\t}\n\n      /* ignore the IV in TLS 1.1.\n       */\n      if (session->security_parameters.version >= GNUTLS_TLS1_1)\n\t{\n\t  ciphertext.size -= blocksize;\n\t  ciphertext.data += blocksize;\n\n\t  if (ciphertext.size == 0)\n\t    {\n\t      gnutls_assert ();\n\t      return GNUTLS_E_DECRYPTION_FAILED;\n\t    }\n\t}\n\n      pad = ciphertext.data[ciphertext.size - 1] + 1;\t/* pad */\n\n      length = ciphertext.size - hash_size - pad;\n\n      if (pad > ciphertext.size - hash_size)\n\t{\n\t  gnutls_assert ();\n\t  /* We do not fail here. We check below for the\n\t   * the pad_failed. If zero means success.\n\t   */\n\t  pad_failed = GNUTLS_E_DECRYPTION_FAILED;\n\t}\n\n      /* Check the pading bytes (TLS 1.x)\n       */\n      if (ver >= GNUTLS_TLS1 && pad_failed == 0)\n\tfor (i = 2; i < pad; i++)\n\t  {\n\t    if (ciphertext.data[ciphertext.size - i] !=\n\t\tciphertext.data[ciphertext.size - 1])\n\t      pad_failed = GNUTLS_E_DECRYPTION_FAILED;\n\t  }\n      break;\n    default:\n      gnutls_assert ();\n      return GNUTLS_E_INTERNAL_ERROR;\n    }\n\n  if (length < 0)\n    length = 0;\n  c_length = _gnutls_conv_uint16 ((uint16_t) length);\n\n  /* Pass the type, version, length and compressed through\n   * MAC.\n   */\n  if (session->security_parameters.read_mac_algorithm != GNUTLS_MAC_NULL)\n    {\n      _gnutls_hmac (&td,\n\t\t    UINT64DATA (session->connection_state.\n\t\t\t\tread_sequence_number), 8);\n\n      _gnutls_hmac (&td, &type, 1);\n      if (ver >= GNUTLS_TLS1)\n\t{\t\t\t/* TLS 1.x */\n\t  _gnutls_hmac (&td, &major, 1);\n\t  _gnutls_hmac (&td, &minor, 1);\n\t}\n      _gnutls_hmac (&td, &c_length, 2);\n\n      if (length > 0)\n\t_gnutls_hmac (&td, ciphertext.data, length);\n\n      mac_deinit (&td, MAC, ver);\n    }\n\n  /* This one was introduced to avoid a timing attack against the TLS\n   * 1.0 protocol.\n   */\n  if (pad_failed != 0)\n    return pad_failed;\n\n  /* HMAC was not the same. \n   */\n  if (memcmp (MAC, &ciphertext.data[length], hash_size) != 0)\n    {\n      gnutls_assert ();\n      return GNUTLS_E_DECRYPTION_FAILED;\n    }\n\n  /* copy the decrypted stuff to compress_data.\n   */\n  if (compress_size < length)\n    {\n      gnutls_assert ();\n      return GNUTLS_E_DECOMPRESSION_FAILED;\n    }\n  memcpy (compress_data, ciphertext.data, length);\n\n  return length;\n}",
        "target": 1
    },
    {
        "func": "_gnutls_recv_handshake_header (gnutls_session_t session,\n\t\t\t       gnutls_handshake_description_t type,\n\t\t\t       gnutls_handshake_description_t * recv_type)\n{\n  int ret;\n  uint32_t length32 = 0;\n  uint8_t *dataptr = NULL;\t/* for realloc */\n  size_t handshake_header_size = HANDSHAKE_HEADER_SIZE;\n\n  /* if we have data into the buffer then return them, do not read the next packet.\n   * In order to return we need a full TLS handshake header, or in case of a version 2\n   * packet, then we return the first byte.\n   */\n  if (session->internals.handshake_header_buffer.header_size ==\n      handshake_header_size || (session->internals.v2_hello != 0\n\t\t\t\t&& type == GNUTLS_HANDSHAKE_CLIENT_HELLO\n\t\t\t\t&& session->internals.\n\t\t\t\thandshake_header_buffer.packet_length > 0))\n    {\n\n      *recv_type = session->internals.handshake_header_buffer.recv_type;\n\n      return session->internals.handshake_header_buffer.packet_length;\n    }\n\n  /* Note: SSL2_HEADERS == 1 */\n\n  dataptr = session->internals.handshake_header_buffer.header;\n\n  /* If we haven't already read the handshake headers.\n   */\n  if (session->internals.handshake_header_buffer.header_size < SSL2_HEADERS)\n    {\n      ret =\n\t_gnutls_handshake_io_recv_int (session, GNUTLS_HANDSHAKE,\n\t\t\t\t       type, dataptr, SSL2_HEADERS);\n\n      if (ret < 0)\n\t{\n\t  gnutls_assert ();\n\t  return ret;\n\t}\n\n      /* The case ret==0 is caught here.\n       */\n      if (ret != SSL2_HEADERS)\n\t{\n\t  gnutls_assert ();\n\t  return GNUTLS_E_UNEXPECTED_PACKET_LENGTH;\n\t}\n      session->internals.handshake_header_buffer.header_size = SSL2_HEADERS;\n    }\n\n  if (session->internals.v2_hello == 0\n      || type != GNUTLS_HANDSHAKE_CLIENT_HELLO)\n    {\n      ret =\n\t_gnutls_handshake_io_recv_int (session, GNUTLS_HANDSHAKE,\n\t\t\t\t       type,\n\t\t\t\t       &dataptr[session->\n\t\t\t\t\t\tinternals.\n\t\t\t\t\t\thandshake_header_buffer.\n\t\t\t\t\t\theader_size],\n\t\t\t\t       HANDSHAKE_HEADER_SIZE -\n\t\t\t\t       session->internals.\n\t\t\t\t       handshake_header_buffer.header_size);\n      if (ret <= 0)\n\t{\n\t  gnutls_assert ();\n\t  return (ret < 0) ? ret : GNUTLS_E_UNEXPECTED_PACKET_LENGTH;\n\t}\n      if ((size_t) ret !=\n\t  HANDSHAKE_HEADER_SIZE -\n\t  session->internals.handshake_header_buffer.header_size)\n\t{\n\t  gnutls_assert ();\n\t  return GNUTLS_E_UNEXPECTED_PACKET_LENGTH;\n\t}\n      *recv_type = dataptr[0];\n\n      /* we do not use DECR_LEN because we know\n       * that the packet has enough data.\n       */\n      length32 = _gnutls_read_uint24 (&dataptr[1]);\n      handshake_header_size = HANDSHAKE_HEADER_SIZE;\n\n      _gnutls_handshake_log (\"HSK[%x]: %s was received [%ld bytes]\\n\",\n\t\t\t     session, _gnutls_handshake2str (dataptr[0]),\n\t\t\t     length32 + HANDSHAKE_HEADER_SIZE);\n\n    }\n  else\n    {\t\t\t\t/* v2 hello */\n      length32 = session->internals.v2_hello - SSL2_HEADERS;\t/* we've read the first byte */\n\n      handshake_header_size = SSL2_HEADERS;\t/* we've already read one byte */\n\n      *recv_type = dataptr[0];\n\n      _gnutls_handshake_log (\"HSK[%x]: %s(v2) was received [%ld bytes]\\n\",\n\t\t\t     session, _gnutls_handshake2str (*recv_type),\n\t\t\t     length32 + handshake_header_size);\n\n      if (*recv_type != GNUTLS_HANDSHAKE_CLIENT_HELLO)\n\t{\t\t\t/* it should be one or nothing */\n\t  gnutls_assert ();\n\t  return GNUTLS_E_UNEXPECTED_HANDSHAKE_PACKET;\n\t}\n    }\n\n  /* put the packet into the buffer */\n  session->internals.handshake_header_buffer.header_size =\n    handshake_header_size;\n  session->internals.handshake_header_buffer.packet_length = length32;\n  session->internals.handshake_header_buffer.recv_type = *recv_type;\n\n  if (*recv_type != type)\n    {\n      gnutls_assert ();\n      return GNUTLS_E_UNEXPECTED_HANDSHAKE_PACKET;\n    }\n\n  return length32;\n}",
        "target": 1
    },
    {
        "func": "_gnutls_ciphertext2compressed (gnutls_session_t session,\n\t\t\t       opaque * compress_data,\n\t\t\t       int compress_size,\n\t\t\t       gnutls_datum_t ciphertext, uint8_t type)\n{\n  uint8_t MAC[MAX_HASH_SIZE];\n  uint16_t c_length;\n  uint8_t pad;\n  int length;\n  digest_hd_st td;\n  uint16_t blocksize;\n  int ret, i, pad_failed = 0;\n  uint8_t major, minor;\n  gnutls_protocol_t ver;\n  int hash_size =\n    _gnutls_hash_get_algo_len (session->security_parameters.\n\t\t\t       read_mac_algorithm);\n\n  ver = gnutls_protocol_get_version (session);\n  minor = _gnutls_version_get_minor (ver);\n  major = _gnutls_version_get_major (ver);\n\n  blocksize = _gnutls_cipher_get_block_size (session->security_parameters.\n\t\t\t\t\t     read_bulk_cipher_algorithm);\n\n  /* initialize MAC \n   */\n  ret = mac_init (&td, session->security_parameters.read_mac_algorithm,\n\t\t session->connection_state.read_mac_secret.data,\n\t\t session->connection_state.read_mac_secret.size, ver);\n\n  if (ret < 0\n      && session->security_parameters.read_mac_algorithm != GNUTLS_MAC_NULL)\n    {\n      gnutls_assert ();\n      return GNUTLS_E_INTERNAL_ERROR;\n    }\n\n  if (ciphertext.size < (unsigned) blocksize + hash_size)\n    {\n      _gnutls_record_log\n\t(\"REC[%x]: Short record length %d < %d + %d (under attack?)\\n\",\n\t session, ciphertext.size, blocksize, hash_size);\n      gnutls_assert ();\n      return GNUTLS_E_DECRYPTION_FAILED;\n    }\n\n  /* actual decryption (inplace)\n   */\n  switch (_gnutls_cipher_is_block\n\t  (session->security_parameters.read_bulk_cipher_algorithm))\n    {\n    case CIPHER_STREAM:\n      if ((ret = _gnutls_cipher_decrypt (&session->connection_state.\n\t\t\t\t\t read_cipher_state,\n\t\t\t\t\t ciphertext.data,\n\t\t\t\t\t ciphertext.size)) < 0)\n\t{\n\t  gnutls_assert ();\n\t  return ret;\n\t}\n\n      length = ciphertext.size - hash_size;\n\n      break;\n    case CIPHER_BLOCK:\n      if ((ciphertext.size < blocksize) || (ciphertext.size % blocksize != 0))\n\t{\n\t  gnutls_assert ();\n\t  return GNUTLS_E_DECRYPTION_FAILED;\n\t}\n\n      if ((ret = _gnutls_cipher_decrypt (&session->connection_state.\n\t\t\t\t\t read_cipher_state,\n\t\t\t\t\t ciphertext.data,\n\t\t\t\t\t ciphertext.size)) < 0)\n\t{\n\t  gnutls_assert ();\n\t  return ret;\n\t}\n\n      /* ignore the IV in TLS 1.1.\n       */\n      if (session->security_parameters.version >= GNUTLS_TLS1_1)\n\t{\n\t  ciphertext.size -= blocksize;\n\t  ciphertext.data += blocksize;\n\n\t  if (ciphertext.size == 0)\n\t    {\n\t      gnutls_assert ();\n\t      return GNUTLS_E_DECRYPTION_FAILED;\n\t    }\n\t}\n\n      pad = ciphertext.data[ciphertext.size - 1] + 1;\t/* pad */\n\n      if ((int)pad > (int)ciphertext.size - hash_size)\n\t{\n\t  gnutls_assert ();\n\t  /* We do not fail here. We check below for the\n\t   * the pad_failed. If zero means success.\n\t   */\n\t  pad_failed = GNUTLS_E_DECRYPTION_FAILED;\n\t}\n\n      length = ciphertext.size - hash_size - pad;\n\n      /* Check the pading bytes (TLS 1.x)\n       */\n      if (ver >= GNUTLS_TLS1 && pad_failed == 0)\n\tfor (i = 2; i < pad; i++)\n\t  {\n\t    if (ciphertext.data[ciphertext.size - i] !=\n\t\tciphertext.data[ciphertext.size - 1])\n\t      pad_failed = GNUTLS_E_DECRYPTION_FAILED;\n\t  }\n      break;\n    default:\n      gnutls_assert ();\n      return GNUTLS_E_INTERNAL_ERROR;\n    }\n\n  if (length < 0)\n    length = 0;\n  c_length = _gnutls_conv_uint16 ((uint16_t) length);\n\n  /* Pass the type, version, length and compressed through\n   * MAC.\n   */\n  if (session->security_parameters.read_mac_algorithm != GNUTLS_MAC_NULL)\n    {\n      _gnutls_hmac (&td,\n\t\t    UINT64DATA (session->connection_state.\n\t\t\t\tread_sequence_number), 8);\n\n      _gnutls_hmac (&td, &type, 1);\n      if (ver >= GNUTLS_TLS1)\n\t{\t\t\t/* TLS 1.x */\n\t  _gnutls_hmac (&td, &major, 1);\n\t  _gnutls_hmac (&td, &minor, 1);\n\t}\n      _gnutls_hmac (&td, &c_length, 2);\n\n      if (length > 0)\n\t_gnutls_hmac (&td, ciphertext.data, length);\n\n      mac_deinit (&td, MAC, ver);\n    }\n\n  /* This one was introduced to avoid a timing attack against the TLS\n   * 1.0 protocol.\n   */\n  if (pad_failed != 0)\n    return pad_failed;\n\n  /* HMAC was not the same. \n   */\n  if (memcmp (MAC, &ciphertext.data[length], hash_size) != 0)\n    {\n      gnutls_assert ();\n      return GNUTLS_E_DECRYPTION_FAILED;\n    }\n\n  /* copy the decrypted stuff to compress_data.\n   */\n  if (compress_size < length)\n    {\n      gnutls_assert ();\n      return GNUTLS_E_DECOMPRESSION_FAILED;\n    }\n  memcpy (compress_data, ciphertext.data, length);\n\n  return length;\n}",
        "target": 1
    },
    {
        "func": "int get_user_pages(struct task_struct *tsk, struct mm_struct *mm,\n\t\tunsigned long start, int len, int write, int force,\n\t\tstruct page **pages, struct vm_area_struct **vmas)\n{\n\tint i;\n\tunsigned int vm_flags;\n\n\tif (len <= 0)\n\t\treturn 0;\n\t/* \n\t * Require read or write permissions.\n\t * If 'force' is set, we only require the \"MAY\" flags.\n\t */\n\tvm_flags  = write ? (VM_WRITE | VM_MAYWRITE) : (VM_READ | VM_MAYREAD);\n\tvm_flags &= force ? (VM_MAYREAD | VM_MAYWRITE) : (VM_READ | VM_WRITE);\n\ti = 0;\n\n\tdo {\n\t\tstruct vm_area_struct *vma;\n\t\tunsigned int foll_flags;\n\n\t\tvma = find_extend_vma(mm, start);\n\t\tif (!vma && in_gate_area(tsk, start)) {\n\t\t\tunsigned long pg = start & PAGE_MASK;\n\t\t\tstruct vm_area_struct *gate_vma = get_gate_vma(tsk);\n\t\t\tpgd_t *pgd;\n\t\t\tpud_t *pud;\n\t\t\tpmd_t *pmd;\n\t\t\tpte_t *pte;\n\t\t\tif (write) /* user gate pages are read-only */\n\t\t\t\treturn i ? : -EFAULT;\n\t\t\tif (pg > TASK_SIZE)\n\t\t\t\tpgd = pgd_offset_k(pg);\n\t\t\telse\n\t\t\t\tpgd = pgd_offset_gate(mm, pg);\n\t\t\tBUG_ON(pgd_none(*pgd));\n\t\t\tpud = pud_offset(pgd, pg);\n\t\t\tBUG_ON(pud_none(*pud));\n\t\t\tpmd = pmd_offset(pud, pg);\n\t\t\tif (pmd_none(*pmd))\n\t\t\t\treturn i ? : -EFAULT;\n\t\t\tpte = pte_offset_map(pmd, pg);\n\t\t\tif (pte_none(*pte)) {\n\t\t\t\tpte_unmap(pte);\n\t\t\t\treturn i ? : -EFAULT;\n\t\t\t}\n\t\t\tif (pages) {\n\t\t\t\tstruct page *page = vm_normal_page(gate_vma, start, *pte);\n\t\t\t\tpages[i] = page;\n\t\t\t\tif (page)\n\t\t\t\t\tget_page(page);\n\t\t\t}\n\t\t\tpte_unmap(pte);\n\t\t\tif (vmas)\n\t\t\t\tvmas[i] = gate_vma;\n\t\t\ti++;\n\t\t\tstart += PAGE_SIZE;\n\t\t\tlen--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!vma || (vma->vm_flags & (VM_IO | VM_PFNMAP))\n\t\t\t\t|| !(vm_flags & vma->vm_flags))\n\t\t\treturn i ? : -EFAULT;\n\n\t\tif (is_vm_hugetlb_page(vma)) {\n\t\t\ti = follow_hugetlb_page(mm, vma, pages, vmas,\n\t\t\t\t\t\t&start, &len, i, write);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfoll_flags = FOLL_TOUCH;\n\t\tif (pages)\n\t\t\tfoll_flags |= FOLL_GET;\n\t\tif (!write && !(vma->vm_flags & VM_LOCKED) &&\n\t\t    (!vma->vm_ops || !vma->vm_ops->fault))\n\t\t\tfoll_flags |= FOLL_ANON;\n\n\t\tdo {\n\t\t\tstruct page *page;\n\n\t\t\t/*\n\t\t\t * If tsk is ooming, cut off its access to large memory\n\t\t\t * allocations. It has a pending SIGKILL, but it can't\n\t\t\t * be processed until returning to user space.\n\t\t\t */\n\t\t\tif (unlikely(test_tsk_thread_flag(tsk, TIF_MEMDIE)))\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tif (write)\n\t\t\t\tfoll_flags |= FOLL_WRITE;\n\n\t\t\tcond_resched();\n\t\t\twhile (!(page = follow_page(vma, start, foll_flags))) {\n\t\t\t\tint ret;\n\t\t\t\tret = handle_mm_fault(mm, vma, start,\n\t\t\t\t\t\tfoll_flags & FOLL_WRITE);\n\t\t\t\tif (ret & VM_FAULT_ERROR) {\n\t\t\t\t\tif (ret & VM_FAULT_OOM)\n\t\t\t\t\t\treturn i ? i : -ENOMEM;\n\t\t\t\t\telse if (ret & VM_FAULT_SIGBUS)\n\t\t\t\t\t\treturn i ? i : -EFAULT;\n\t\t\t\t\tBUG();\n\t\t\t\t}\n\t\t\t\tif (ret & VM_FAULT_MAJOR)\n\t\t\t\t\ttsk->maj_flt++;\n\t\t\t\telse\n\t\t\t\t\ttsk->min_flt++;\n\n\t\t\t\t/*\n\t\t\t\t * The VM_FAULT_WRITE bit tells us that\n\t\t\t\t * do_wp_page has broken COW when necessary,\n\t\t\t\t * even if maybe_mkwrite decided not to set\n\t\t\t\t * pte_write. We can thus safely do subsequent\n\t\t\t\t * page lookups as if they were reads.\n\t\t\t\t */\n\t\t\t\tif (ret & VM_FAULT_WRITE)\n\t\t\t\t\tfoll_flags &= ~FOLL_WRITE;\n\n\t\t\t\tcond_resched();\n\t\t\t}\n\t\t\tif (pages) {\n\t\t\t\tpages[i] = page;\n\n\t\t\t\tflush_anon_page(vma, page, start);\n\t\t\t\tflush_dcache_page(page);\n\t\t\t}\n\t\t\tif (vmas)\n\t\t\t\tvmas[i] = vma;\n\t\t\ti++;\n\t\t\tstart += PAGE_SIZE;\n\t\t\tlen--;\n\t\t} while (len && start < vma->vm_end);\n\t} while (len);\n\treturn i;\n}",
        "target": 1
    },
    {
        "func": "static int do_pages_stat(struct mm_struct *mm, struct page_to_node *pm)\n{\n\tdown_read(&mm->mmap_sem);\n\n\tfor ( ; pm->node != MAX_NUMNODES; pm++) {\n\t\tstruct vm_area_struct *vma;\n\t\tstruct page *page;\n\t\tint err;\n\n\t\terr = -EFAULT;\n\t\tvma = find_vma(mm, pm->addr);\n\t\tif (!vma)\n\t\t\tgoto set_status;\n\n\t\tpage = follow_page(vma, pm->addr, 0);\n\t\terr = -ENOENT;\n\t\t/* Use PageReserved to check for zero page */\n\t\tif (!page || PageReserved(page))\n\t\t\tgoto set_status;\n\n\t\terr = page_to_nid(page);\nset_status:\n\t\tpm->status = err;\n\t}\n\n\tup_read(&mm->mmap_sem);\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static int do_move_pages(struct mm_struct *mm, struct page_to_node *pm,\n\t\t\t\tint migrate_all)\n{\n\tint err;\n\tstruct page_to_node *pp;\n\tLIST_HEAD(pagelist);\n\n\tdown_read(&mm->mmap_sem);\n\n\t/*\n\t * Build a list of pages to migrate\n\t */\n\tmigrate_prep();\n\tfor (pp = pm; pp->node != MAX_NUMNODES; pp++) {\n\t\tstruct vm_area_struct *vma;\n\t\tstruct page *page;\n\n\t\t/*\n\t\t * A valid page pointer that will not match any of the\n\t\t * pages that will be moved.\n\t\t */\n\t\tpp->page = ZERO_PAGE(0);\n\n\t\terr = -EFAULT;\n\t\tvma = find_vma(mm, pp->addr);\n\t\tif (!vma || !vma_migratable(vma))\n\t\t\tgoto set_status;\n\n\t\tpage = follow_page(vma, pp->addr, FOLL_GET);\n\t\terr = -ENOENT;\n\t\tif (!page)\n\t\t\tgoto set_status;\n\n\t\tif (PageReserved(page))\t\t/* Check for zero page */\n\t\t\tgoto put_and_set;\n\n\t\tpp->page = page;\n\t\terr = page_to_nid(page);\n\n\t\tif (err == pp->node)\n\t\t\t/*\n\t\t\t * Node already in the right place\n\t\t\t */\n\t\t\tgoto put_and_set;\n\n\t\terr = -EACCES;\n\t\tif (page_mapcount(page) > 1 &&\n\t\t\t\t!migrate_all)\n\t\t\tgoto put_and_set;\n\n\t\terr = isolate_lru_page(page, &pagelist);\nput_and_set:\n\t\t/*\n\t\t * Either remove the duplicate refcount from\n\t\t * isolate_lru_page() or drop the page ref if it was\n\t\t * not isolated.\n\t\t */\n\t\tput_page(page);\nset_status:\n\t\tpp->status = err;\n\t}\n\n\tif (!list_empty(&pagelist))\n\t\terr = migrate_pages(&pagelist, new_page_node,\n\t\t\t\t(unsigned long)pm);\n\telse\n\t\terr = -ENOENT;\n\n\tup_read(&mm->mmap_sem);\n\treturn err;\n}",
        "target": 1
    },
    {
        "func": "static void dump_one_vdso_page(struct page *pg, struct page *upg)\n{\n\tprintk(\"kpg: %p (c:%d,f:%08lx)\", __va(page_to_pfn(pg) << PAGE_SHIFT),\n\t       page_count(pg),\n\t       pg->flags);\n\tif (upg/* && pg != upg*/) {\n\t\tprintk(\" upg: %p (c:%d,f:%08lx)\", __va(page_to_pfn(upg)\n\t\t\t\t\t\t       << PAGE_SHIFT),\n\t\t       page_count(upg),\n\t\t       upg->flags);\n\t}\n\tprintk(\"\\n\");\n}",
        "target": 1
    },
    {
        "func": "struct page *follow_page(struct vm_area_struct *vma, unsigned long address,\n\t\t\tunsigned int flags)\n{\n\tpgd_t *pgd;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\tpte_t *ptep, pte;\n\tspinlock_t *ptl;\n\tstruct page *page;\n\tstruct mm_struct *mm = vma->vm_mm;\n\n\tpage = follow_huge_addr(mm, address, flags & FOLL_WRITE);\n\tif (!IS_ERR(page)) {\n\t\tBUG_ON(flags & FOLL_GET);\n\t\tgoto out;\n\t}\n\n\tpage = NULL;\n\tpgd = pgd_offset(mm, address);\n\tif (pgd_none(*pgd) || unlikely(pgd_bad(*pgd)))\n\t\tgoto no_page_table;\n\n\tpud = pud_offset(pgd, address);\n\tif (pud_none(*pud) || unlikely(pud_bad(*pud)))\n\t\tgoto no_page_table;\n\t\n\tpmd = pmd_offset(pud, address);\n\tif (pmd_none(*pmd))\n\t\tgoto no_page_table;\n\n\tif (pmd_huge(*pmd)) {\n\t\tBUG_ON(flags & FOLL_GET);\n\t\tpage = follow_huge_pmd(mm, address, pmd, flags & FOLL_WRITE);\n\t\tgoto out;\n\t}\n\n\tif (unlikely(pmd_bad(*pmd)))\n\t\tgoto no_page_table;\n\n\tptep = pte_offset_map_lock(mm, pmd, address, &ptl);\n\tif (!ptep)\n\t\tgoto out;\n\n\tpte = *ptep;\n\tif (!pte_present(pte))\n\t\tgoto unlock;\n\tif ((flags & FOLL_WRITE) && !pte_write(pte))\n\t\tgoto unlock;\n\tpage = vm_normal_page(vma, address, pte);\n\tif (unlikely(!page))\n\t\tgoto unlock;\n\n\tif (flags & FOLL_GET)\n\t\tget_page(page);\n\tif (flags & FOLL_TOUCH) {\n\t\tif ((flags & FOLL_WRITE) &&\n\t\t    !pte_dirty(pte) && !PageDirty(page))\n\t\t\tset_page_dirty(page);\n\t\tmark_page_accessed(page);\n\t}\nunlock:\n\tpte_unmap_unlock(ptep, ptl);\nout:\n\treturn page;\n\nno_page_table:\n\t/*\n\t * When core dumping an enormous anonymous area that nobody\n\t * has touched so far, we don't want to allocate page tables.\n\t */\n\tif (flags & FOLL_ANON) {\n\t\tpage = ZERO_PAGE(0);\n\t\tif (flags & FOLL_GET)\n\t\t\tget_page(page);\n\t\tBUG_ON(flags & FOLL_WRITE);\n\t}\n\treturn page;\n}",
        "target": 1
    },
    {
        "func": "int get_user_pages(struct task_struct *tsk, struct mm_struct *mm,\n\t\tunsigned long start, int len, int write, int force,\n\t\tstruct page **pages, struct vm_area_struct **vmas)\n{\n\tint i;\n\tunsigned int vm_flags;\n\n\tif (len <= 0)\n\t\treturn 0;\n\t/* \n\t * Require read or write permissions.\n\t * If 'force' is set, we only require the \"MAY\" flags.\n\t */\n\tvm_flags  = write ? (VM_WRITE | VM_MAYWRITE) : (VM_READ | VM_MAYREAD);\n\tvm_flags &= force ? (VM_MAYREAD | VM_MAYWRITE) : (VM_READ | VM_WRITE);\n\ti = 0;\n\n\tdo {\n\t\tstruct vm_area_struct *vma;\n\t\tunsigned int foll_flags;\n\n\t\tvma = find_extend_vma(mm, start);\n\t\tif (!vma && in_gate_area(tsk, start)) {\n\t\t\tunsigned long pg = start & PAGE_MASK;\n\t\t\tstruct vm_area_struct *gate_vma = get_gate_vma(tsk);\n\t\t\tpgd_t *pgd;\n\t\t\tpud_t *pud;\n\t\t\tpmd_t *pmd;\n\t\t\tpte_t *pte;\n\t\t\tif (write) /* user gate pages are read-only */\n\t\t\t\treturn i ? : -EFAULT;\n\t\t\tif (pg > TASK_SIZE)\n\t\t\t\tpgd = pgd_offset_k(pg);\n\t\t\telse\n\t\t\t\tpgd = pgd_offset_gate(mm, pg);\n\t\t\tBUG_ON(pgd_none(*pgd));\n\t\t\tpud = pud_offset(pgd, pg);\n\t\t\tBUG_ON(pud_none(*pud));\n\t\t\tpmd = pmd_offset(pud, pg);\n\t\t\tif (pmd_none(*pmd))\n\t\t\t\treturn i ? : -EFAULT;\n\t\t\tpte = pte_offset_map(pmd, pg);\n\t\t\tif (pte_none(*pte)) {\n\t\t\t\tpte_unmap(pte);\n\t\t\t\treturn i ? : -EFAULT;\n\t\t\t}\n\t\t\tif (pages) {\n\t\t\t\tstruct page *page = vm_normal_page(gate_vma, start, *pte);\n\t\t\t\tpages[i] = page;\n\t\t\t\tif (page)\n\t\t\t\t\tget_page(page);\n\t\t\t}\n\t\t\tpte_unmap(pte);\n\t\t\tif (vmas)\n\t\t\t\tvmas[i] = gate_vma;\n\t\t\ti++;\n\t\t\tstart += PAGE_SIZE;\n\t\t\tlen--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!vma || (vma->vm_flags & (VM_IO | VM_PFNMAP))\n\t\t\t\t|| !(vm_flags & vma->vm_flags))\n\t\t\treturn i ? : -EFAULT;\n\n\t\tif (is_vm_hugetlb_page(vma)) {\n\t\t\ti = follow_hugetlb_page(mm, vma, pages, vmas,\n\t\t\t\t\t\t&start, &len, i, write);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfoll_flags = FOLL_TOUCH;\n\t\tif (pages)\n\t\t\tfoll_flags |= FOLL_GET;\n\t\tif (!write && !(vma->vm_flags & VM_LOCKED) &&\n\t\t    (!vma->vm_ops || !vma->vm_ops->fault))\n\t\t\tfoll_flags |= FOLL_ANON;\n\n\t\tdo {\n\t\t\tstruct page *page;\n\n\t\t\t/*\n\t\t\t * If tsk is ooming, cut off its access to large memory\n\t\t\t * allocations. It has a pending SIGKILL, but it can't\n\t\t\t * be processed until returning to user space.\n\t\t\t */\n\t\t\tif (unlikely(test_tsk_thread_flag(tsk, TIF_MEMDIE)))\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tif (write)\n\t\t\t\tfoll_flags |= FOLL_WRITE;\n\n\t\t\tcond_resched();\n\t\t\twhile (!(page = follow_page(vma, start, foll_flags))) {\n\t\t\t\tint ret;\n\t\t\t\tret = handle_mm_fault(mm, vma, start,\n\t\t\t\t\t\tfoll_flags & FOLL_WRITE);\n\t\t\t\tif (ret & VM_FAULT_ERROR) {\n\t\t\t\t\tif (ret & VM_FAULT_OOM)\n\t\t\t\t\t\treturn i ? i : -ENOMEM;\n\t\t\t\t\telse if (ret & VM_FAULT_SIGBUS)\n\t\t\t\t\t\treturn i ? i : -EFAULT;\n\t\t\t\t\tBUG();\n\t\t\t\t}\n\t\t\t\tif (ret & VM_FAULT_MAJOR)\n\t\t\t\t\ttsk->maj_flt++;\n\t\t\t\telse\n\t\t\t\t\ttsk->min_flt++;\n\n\t\t\t\t/*\n\t\t\t\t * The VM_FAULT_WRITE bit tells us that\n\t\t\t\t * do_wp_page has broken COW when necessary,\n\t\t\t\t * even if maybe_mkwrite decided not to set\n\t\t\t\t * pte_write. We can thus safely do subsequent\n\t\t\t\t * page lookups as if they were reads.\n\t\t\t\t */\n\t\t\t\tif (ret & VM_FAULT_WRITE)\n\t\t\t\t\tfoll_flags &= ~FOLL_WRITE;\n\n\t\t\t\tcond_resched();\n\t\t\t}\n\t\t\tif (IS_ERR(page))\n\t\t\t\treturn i ? i : PTR_ERR(page);\n\t\t\tif (pages) {\n\t\t\t\tpages[i] = page;\n\n\t\t\t\tflush_anon_page(vma, page, start);\n\t\t\t\tflush_dcache_page(page);\n\t\t\t}\n\t\t\tif (vmas)\n\t\t\t\tvmas[i] = vma;\n\t\t\ti++;\n\t\t\tstart += PAGE_SIZE;\n\t\t\tlen--;\n\t\t} while (len && start < vma->vm_end);\n\t} while (len);\n\treturn i;\n}",
        "target": 1
    },
    {
        "func": "static int do_change_type(struct nameidata *nd, int flag)\n{\n\tstruct vfsmount *m, *mnt = nd->mnt;\n\tint recurse = flag & MS_REC;\n\tint type = flag & ~MS_REC;\n\n\tif (nd->dentry != nd->mnt->mnt_root)\n\t\treturn -EINVAL;\n\n\tdown_write(&namespace_sem);\n\tspin_lock(&vfsmount_lock);\n\tfor (m = mnt; m; m = (recurse ? next_mnt(m, mnt) : NULL))\n\t\tchange_mnt_propagation(m, type);\n\tspin_unlock(&vfsmount_lock);\n\tup_write(&namespace_sem);\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "int udp_get_port(struct sock *sk, unsigned short snum,\n\t\t\tint (*scmp)(const struct sock *, const struct sock *))\n{\n\treturn  __udp_lib_get_port(sk, snum, udp_hash, &udp_port_rover, scmp);\n}",
        "target": 1
    },
    {
        "func": "int udplite_get_port(struct sock *sk, unsigned short p,\n\t\t     int (*c)(const struct sock *, const struct sock *))\n{\n\treturn  __udp_lib_get_port(sk, p, udplite_hash, &udplite_port_rover, c);\n}",
        "target": 1
    },
    {
        "func": "int __udp_lib_get_port(struct sock *sk, unsigned short snum,\n\t\t       struct hlist_head udptable[], int *port_rover,\n\t\t       int (*saddr_comp)(const struct sock *sk1,\n\t\t\t\t\t const struct sock *sk2 )    )\n{\n\tstruct hlist_node *node;\n\tstruct hlist_head *head;\n\tstruct sock *sk2;\n\tint    error = 1;\n\n\twrite_lock_bh(&udp_hash_lock);\n\tif (snum == 0) {\n\t\tint best_size_so_far, best, result, i;\n\n\t\tif (*port_rover > sysctl_local_port_range[1] ||\n\t\t    *port_rover < sysctl_local_port_range[0])\n\t\t\t*port_rover = sysctl_local_port_range[0];\n\t\tbest_size_so_far = 32767;\n\t\tbest = result = *port_rover;\n\t\tfor (i = 0; i < UDP_HTABLE_SIZE; i++, result++) {\n\t\t\tint size;\n\n\t\t\thead = &udptable[result & (UDP_HTABLE_SIZE - 1)];\n\t\t\tif (hlist_empty(head)) {\n\t\t\t\tif (result > sysctl_local_port_range[1])\n\t\t\t\t\tresult = sysctl_local_port_range[0] +\n\t\t\t\t\t\t((result - sysctl_local_port_range[0]) &\n\t\t\t\t\t\t (UDP_HTABLE_SIZE - 1));\n\t\t\t\tgoto gotit;\n\t\t\t}\n\t\t\tsize = 0;\n\t\t\tsk_for_each(sk2, node, head) {\n\t\t\t\tif (++size >= best_size_so_far)\n\t\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tbest_size_so_far = size;\n\t\t\tbest = result;\n\t\tnext:\n\t\t\t;\n\t\t}\n\t\tresult = best;\n\t\tfor (i = 0; i < (1 << 16) / UDP_HTABLE_SIZE;\n\t\t     i++, result += UDP_HTABLE_SIZE) {\n\t\t\tif (result > sysctl_local_port_range[1])\n\t\t\t\tresult = sysctl_local_port_range[0]\n\t\t\t\t\t+ ((result - sysctl_local_port_range[0]) &\n\t\t\t\t\t   (UDP_HTABLE_SIZE - 1));\n\t\t\tif (! __udp_lib_lport_inuse(result, udptable))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i >= (1 << 16) / UDP_HTABLE_SIZE)\n\t\t\tgoto fail;\ngotit:\n\t\t*port_rover = snum = result;\n\t} else {\n\t\thead = &udptable[snum & (UDP_HTABLE_SIZE - 1)];\n\n\t\tsk_for_each(sk2, node, head)\n\t\t\tif (sk2->sk_hash == snum                             &&\n\t\t\t    sk2 != sk                                        &&\n\t\t\t    (!sk2->sk_reuse        || !sk->sk_reuse)         &&\n\t\t\t    (!sk2->sk_bound_dev_if || !sk->sk_bound_dev_if\n\t\t\t     || sk2->sk_bound_dev_if == sk->sk_bound_dev_if) &&\n\t\t\t    (*saddr_comp)(sk, sk2)                             )\n\t\t\t\tgoto fail;\n\t}\n\tinet_sk(sk)->num = snum;\n\tsk->sk_hash = snum;\n\tif (sk_unhashed(sk)) {\n\t\thead = &udptable[snum & (UDP_HTABLE_SIZE - 1)];\n\t\tsk_add_node(sk, head);\n\t\tsock_prot_inc_use(sk->sk_prot);\n\t}\n\terror = 0;\nfail:\n\twrite_unlock_bh(&udp_hash_lock);\n\treturn error;\n}",
        "target": 1
    },
    {
        "func": "static inline int __udp_lib_lport_inuse(__u16 num, struct hlist_head udptable[])\n{\n\tstruct sock *sk;\n\tstruct hlist_node *node;\n\n\tsk_for_each(sk, node, &udptable[num & (UDP_HTABLE_SIZE - 1)])\n\t\tif (sk->sk_hash == num)\n\t\t\treturn 1;\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static inline void native_set_ldt(const void *addr, unsigned int entries)\n{\n\tif (likely(entries == 0))\n\t\tasm volatile(\"lldt %w0\"::\"q\" (0));\n\telse {\n\t\tunsigned cpu = smp_processor_id();\n\t\tldt_desc ldt;\n\n\t\tset_tssldt_descriptor(&ldt, (unsigned long)addr,\n\t\t\t\t      DESC_LDT, entries * sizeof(ldt) - 1);\n\t\twrite_gdt_entry(get_cpu_gdt_table(cpu), GDT_ENTRY_LDT,\n\t\t\t\t&ldt, DESC_LDT);\n\t\tasm volatile(\"lldt %w0\"::\"q\" (GDT_ENTRY_LDT*8));\n\t}\n}",
        "target": 1
    },
    {
        "func": "shmem_get_inode(struct super_block *sb, int mode, dev_t dev)\n{\n\tstruct inode *inode;\n\tstruct shmem_inode_info *info;\n\tstruct shmem_sb_info *sbinfo = SHMEM_SB(sb);\n\n\tif (shmem_reserve_inode(sb))\n\t\treturn NULL;\n\n\tinode = new_inode(sb);\n\tif (inode) {\n\t\tinode->i_mode = mode;\n\t\tinode->i_uid = current->fsuid;\n\t\tinode->i_gid = current->fsgid;\n\t\tinode->i_blocks = 0;\n\t\tinode->i_mapping->a_ops = &shmem_aops;\n\t\tinode->i_mapping->backing_dev_info = &shmem_backing_dev_info;\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t\tinode->i_generation = get_seconds();\n\t\tinfo = SHMEM_I(inode);\n\t\tmemset(info, 0, (char *)inode - (char *)info);\n\t\tspin_lock_init(&info->lock);\n\t\tINIT_LIST_HEAD(&info->swaplist);\n\n\t\tswitch (mode & S_IFMT) {\n\t\tdefault:\n\t\t\tinode->i_op = &shmem_special_inode_operations;\n\t\t\tinit_special_inode(inode, mode, dev);\n\t\t\tbreak;\n\t\tcase S_IFREG:\n\t\t\tinode->i_op = &shmem_inode_operations;\n\t\t\tinode->i_fop = &shmem_file_operations;\n\t\t\tmpol_shared_policy_init(&info->policy,\n\t\t\t\t\t\t shmem_get_sbmpol(sbinfo));\n\t\t\tbreak;\n\t\tcase S_IFDIR:\n\t\t\tinc_nlink(inode);\n\t\t\t/* Some things misbehave if size == 0 on a directory */\n\t\t\tinode->i_size = 2 * BOGO_DIRENT_SIZE;\n\t\t\tinode->i_op = &shmem_dir_inode_operations;\n\t\t\tinode->i_fop = &simple_dir_operations;\n\t\t\tbreak;\n\t\tcase S_IFLNK:\n\t\t\t/*\n\t\t\t * Must not load anything in the rbtree,\n\t\t\t * mpol_free_shared_policy will not be called.\n\t\t\t */\n\t\t\tmpol_shared_policy_init(&info->policy, NULL);\n\t\t\tbreak;\n\t\t}\n\t} else\n\t\tshmem_free_inode(sb);\n\treturn inode;\n}",
        "target": 1
    },
    {
        "func": "static int shmem_symlink(struct inode *dir, struct dentry *dentry, const char *symname)\n{\n\tint error;\n\tint len;\n\tstruct inode *inode;\n\tstruct page *page = NULL;\n\tchar *kaddr;\n\tstruct shmem_inode_info *info;\n\n\tlen = strlen(symname) + 1;\n\tif (len > PAGE_CACHE_SIZE)\n\t\treturn -ENAMETOOLONG;\n\n\tinode = shmem_get_inode(dir->i_sb, S_IFLNK|S_IRWXUGO, 0);\n\tif (!inode)\n\t\treturn -ENOSPC;\n\n\terror = security_inode_init_security(inode, dir, NULL, NULL,\n\t\t\t\t\t     NULL);\n\tif (error) {\n\t\tif (error != -EOPNOTSUPP) {\n\t\t\tiput(inode);\n\t\t\treturn error;\n\t\t}\n\t\terror = 0;\n\t}\n\n\tinfo = SHMEM_I(inode);\n\tinode->i_size = len-1;\n\tif (len <= (char *)inode - (char *)info) {\n\t\t/* do it inline */\n\t\tmemcpy(info, symname, len);\n\t\tinode->i_op = &shmem_symlink_inline_operations;\n\t} else {\n\t\terror = shmem_getpage(inode, 0, &page, SGP_WRITE, NULL);\n\t\tif (error) {\n\t\t\tiput(inode);\n\t\t\treturn error;\n\t\t}\n\t\tunlock_page(page);\n\t\tinode->i_op = &shmem_symlink_inode_operations;\n\t\tkaddr = kmap_atomic(page, KM_USER0);\n\t\tmemcpy(kaddr, symname, len);\n\t\tkunmap_atomic(kaddr, KM_USER0);\n\t\tset_page_dirty(page);\n\t\tpage_cache_release(page);\n\t}\n\tif (dir->i_mode & S_ISGID)\n\t\tinode->i_gid = dir->i_gid;\n\tdir->i_size += BOGO_DIRENT_SIZE;\n\tdir->i_ctime = dir->i_mtime = CURRENT_TIME;\n\td_instantiate(dentry, inode);\n\tdget(dentry);\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "void iov_iter_advance(struct iov_iter *i, size_t bytes)\n{\n\tBUG_ON(i->count < bytes);\n\n\tif (likely(i->nr_segs == 1)) {\n\t\ti->iov_offset += bytes;\n\t\ti->count -= bytes;\n\t} else {\n\t\tconst struct iovec *iov = i->iov;\n\t\tsize_t base = i->iov_offset;\n\n\t\t/*\n\t\t * The !iov->iov_len check ensures we skip over unlikely\n\t\t * zero-length segments (without overruning the iovec).\n\t\t */\n\t\twhile (bytes || unlikely(!iov->iov_len && i->count)) {\n\t\t\tint copy;\n\n\t\t\tcopy = min(bytes, iov->iov_len - base);\n\t\t\tBUG_ON(!i->count || i->count < copy);\n\t\t\ti->count -= copy;\n\t\t\tbytes -= copy;\n\t\t\tbase += copy;\n\t\t\tif (iov->iov_len == base) {\n\t\t\t\tiov++;\n\t\t\t\tbase = 0;\n\t\t\t}\n\t\t}\n\t\ti->iov = iov;\n\t\ti->iov_offset = base;\n\t}\n}",
        "target": 1
    },
    {
        "func": "void __cpuinit cpu_init (void)\n{\n\tint cpu = stack_smp_processor_id();\n\tstruct tss_struct *t = &per_cpu(init_tss, cpu);\n\tstruct orig_ist *orig_ist = &per_cpu(orig_ist, cpu);\n\tunsigned long v; \n\tchar *estacks = NULL; \n\tstruct task_struct *me;\n\tint i;\n\n\t/* CPU 0 is initialised in head64.c */\n\tif (cpu != 0) {\n\t\tpda_init(cpu);\n\t\tzap_low_mappings(cpu);\n\t} else \n\t\testacks = boot_exception_stacks; \n\n\tme = current;\n\n\tif (cpu_test_and_set(cpu, cpu_initialized))\n\t\tpanic(\"CPU#%d already initialized!\\n\", cpu);\n\n\tprintk(\"Initializing CPU#%d\\n\", cpu);\n\n\tclear_in_cr4(X86_CR4_VME|X86_CR4_PVI|X86_CR4_TSD|X86_CR4_DE);\n\n\t/*\n\t * Initialize the per-CPU GDT with the boot GDT,\n\t * and set up the GDT descriptor:\n\t */\n\tif (cpu)\n \t\tmemcpy(cpu_gdt(cpu), cpu_gdt_table, GDT_SIZE);\n\n\tcpu_gdt_descr[cpu].size = GDT_SIZE;\n\tasm volatile(\"lgdt %0\" :: \"m\" (cpu_gdt_descr[cpu]));\n\tasm volatile(\"lidt %0\" :: \"m\" (idt_descr));\n\n\tmemset(me->thread.tls_array, 0, GDT_ENTRY_TLS_ENTRIES * 8);\n\tsyscall_init();\n\n\twrmsrl(MSR_FS_BASE, 0);\n\twrmsrl(MSR_KERNEL_GS_BASE, 0);\n\tbarrier(); \n\n\tcheck_efer();\n\n\t/*\n\t * set up and load the per-CPU TSS\n\t */\n\tfor (v = 0; v < N_EXCEPTION_STACKS; v++) {\n\t\tstatic const unsigned int order[N_EXCEPTION_STACKS] = {\n\t\t\t[0 ... N_EXCEPTION_STACKS - 1] = EXCEPTION_STACK_ORDER,\n\t\t\t[DEBUG_STACK - 1] = DEBUG_STACK_ORDER\n\t\t};\n\t\tif (cpu) {\n\t\t\testacks = (char *)__get_free_pages(GFP_ATOMIC, order[v]);\n\t\t\tif (!estacks)\n\t\t\t\tpanic(\"Cannot allocate exception stack %ld %d\\n\",\n\t\t\t\t      v, cpu); \n\t\t}\n\t\testacks += PAGE_SIZE << order[v];\n\t\torig_ist->ist[v] = t->ist[v] = (unsigned long)estacks;\n\t}\n\n\tt->io_bitmap_base = offsetof(struct tss_struct, io_bitmap);\n\t/*\n\t * <= is required because the CPU will access up to\n\t * 8 bits beyond the end of the IO permission bitmap.\n\t */\n\tfor (i = 0; i <= IO_BITMAP_LONGS; i++)\n\t\tt->io_bitmap[i] = ~0UL;\n\n\tatomic_inc(&init_mm.mm_count);\n\tme->active_mm = &init_mm;\n\tif (me->mm)\n\t\tBUG();\n\tenter_lazy_tlb(&init_mm, me);\n\n\tset_tss_desc(cpu, t);\n\tload_TR_desc();\n\tload_LDT(&init_mm.context);\n\n\t/*\n\t * Clear all 6 debug registers:\n\t */\n\n\tset_debugreg(0UL, 0);\n\tset_debugreg(0UL, 1);\n\tset_debugreg(0UL, 2);\n\tset_debugreg(0UL, 3);\n\tset_debugreg(0UL, 6);\n\tset_debugreg(0UL, 7);\n\n\tfpu_init(); \n}",
        "target": 1
    },
    {
        "func": "static struct dentry * real_lookup(struct dentry * parent, struct qstr * name, struct nameidata *nd)\n{\n\tstruct dentry * result;\n\tstruct inode *dir = parent->d_inode;\n\n\tmutex_lock(&dir->i_mutex);\n\t/*\n\t * First re-do the cached lookup just in case it was created\n\t * while we waited for the directory semaphore..\n\t *\n\t * FIXME! This could use version numbering or similar to\n\t * avoid unnecessary cache lookups.\n\t *\n\t * The \"dcache_lock\" is purely to protect the RCU list walker\n\t * from concurrent renames at this point (we mustn't get false\n\t * negatives from the RCU list walk here, unlike the optimistic\n\t * fast walk).\n\t *\n\t * so doing d_lookup() (with seqlock), instead of lockfree __d_lookup\n\t */\n\tresult = d_lookup(parent, name);\n\tif (!result) {\n\t\tstruct dentry * dentry = d_alloc(parent, name);\n\t\tresult = ERR_PTR(-ENOMEM);\n\t\tif (dentry) {\n\t\t\tresult = dir->i_op->lookup(dir, dentry, nd);\n\t\t\tif (result)\n\t\t\t\tdput(dentry);\n\t\t\telse\n\t\t\t\tresult = dentry;\n\t\t}\n\t\tmutex_unlock(&dir->i_mutex);\n\t\treturn result;\n\t}\n\n\t/*\n\t * Uhhuh! Nasty case: the cache was re-populated while\n\t * we waited on the semaphore. Need to revalidate.\n\t */\n\tmutex_unlock(&dir->i_mutex);\n\tif (result->d_op && result->d_op->d_revalidate) {\n\t\tresult = do_revalidate(result, nd);\n\t\tif (!result)\n\t\t\tresult = ERR_PTR(-ENOENT);\n\t}\n\treturn result;\n}",
        "target": 1
    },
    {
        "func": "static struct dentry *__lookup_hash(struct qstr *name,\n\t\tstruct dentry *base, struct nameidata *nd)\n{\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tint err;\n\n\tinode = base->d_inode;\n\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_op && base->d_op->d_hash) {\n\t\terr = base->d_op->d_hash(base, name);\n\t\tdentry = ERR_PTR(err);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\n\tdentry = cached_lookup(base, name, nd);\n\tif (!dentry) {\n\t\tstruct dentry *new = d_alloc(base, name);\n\t\tdentry = ERR_PTR(-ENOMEM);\n\t\tif (!new)\n\t\t\tgoto out;\n\t\tdentry = inode->i_op->lookup(inode, new, nd);\n\t\tif (!dentry)\n\t\t\tdentry = new;\n\t\telse\n\t\t\tdput(new);\n\t}\nout:\n\treturn dentry;\n}",
        "target": 1
    },
    {
        "func": "snd_seq_oss_synth_make_info(struct seq_oss_devinfo *dp, int dev, struct synth_info *inf)\n{\n\tstruct seq_oss_synth *rec;\n\n\tif (dp->synths[dev].is_midi) {\n\t\tstruct midi_info minf;\n\t\tsnd_seq_oss_midi_make_info(dp, dp->synths[dev].midi_mapped, &minf);\n\t\tinf->synth_type = SYNTH_TYPE_MIDI;\n\t\tinf->synth_subtype = 0;\n\t\tinf->nr_voices = 16;\n\t\tinf->device = dev;\n\t\tstrlcpy(inf->name, minf.name, sizeof(inf->name));\n\t} else {\n\t\tif ((rec = get_synthdev(dp, dev)) == NULL)\n\t\t\treturn -ENXIO;\n\t\tinf->synth_type = rec->synth_type;\n\t\tinf->synth_subtype = rec->synth_subtype;\n\t\tinf->nr_voices = rec->nr_voices;\n\t\tinf->device = dev;\n\t\tstrlcpy(inf->name, rec->name, sizeof(inf->name));\n\t\tsnd_use_lock_free(&rec->use_lock);\n\t}\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static void file_add_remove(struct diff_options *options,\n\t\t    int addremove, unsigned mode,\n\t\t    const unsigned char *sha1,\n\t\t    const char *base, const char *path)\n{\n\tint diff = REV_TREE_DIFFERENT;\n\n\t/*\n\t * Is it an add of a new file? It means that the old tree\n\t * didn't have it at all, so we will turn \"REV_TREE_SAME\" ->\n\t * \"REV_TREE_NEW\", but leave any \"REV_TREE_DIFFERENT\" alone\n\t * (and if it already was \"REV_TREE_NEW\", we'll keep it\n\t * \"REV_TREE_NEW\" of course).\n\t */\n\tif (addremove == '+') {\n\t\tdiff = tree_difference;\n\t\tif (diff != REV_TREE_SAME)\n\t\t\treturn;\n\t\tdiff = REV_TREE_NEW;\n\t}\n\ttree_difference = diff;\n\tif (tree_difference == REV_TREE_DIFFERENT)\n\t\tDIFF_OPT_SET(options, HAS_CHANGES);\n}",
        "target": 1
    },
    {
        "func": "static int show_modified(struct oneway_unpack_data *cbdata,\n\t\t\t struct cache_entry *old,\n\t\t\t struct cache_entry *new,\n\t\t\t int report_missing,\n\t\t\t int cached, int match_missing)\n{\n\tunsigned int mode, oldmode;\n\tconst unsigned char *sha1;\n\tstruct rev_info *revs = cbdata->revs;\n\n\tif (get_stat_data(new, &sha1, &mode, cached, match_missing, cbdata) < 0) {\n\t\tif (report_missing)\n\t\t\tdiff_index_show_file(revs, \"-\", old,\n\t\t\t\t\t     old->sha1, old->ce_mode);\n\t\treturn -1;\n\t}\n\n\tif (revs->combine_merges && !cached &&\n\t    (hashcmp(sha1, old->sha1) || hashcmp(old->sha1, new->sha1))) {\n\t\tstruct combine_diff_path *p;\n\t\tint pathlen = ce_namelen(new);\n\n\t\tp = xmalloc(combine_diff_path_size(2, pathlen));\n\t\tp->path = (char *) &p->parent[2];\n\t\tp->next = NULL;\n\t\tp->len = pathlen;\n\t\tmemcpy(p->path, new->name, pathlen);\n\t\tp->path[pathlen] = 0;\n\t\tp->mode = mode;\n\t\thashclr(p->sha1);\n\t\tmemset(p->parent, 0, 2 * sizeof(struct combine_diff_parent));\n\t\tp->parent[0].status = DIFF_STATUS_MODIFIED;\n\t\tp->parent[0].mode = new->ce_mode;\n\t\thashcpy(p->parent[0].sha1, new->sha1);\n\t\tp->parent[1].status = DIFF_STATUS_MODIFIED;\n\t\tp->parent[1].mode = old->ce_mode;\n\t\thashcpy(p->parent[1].sha1, old->sha1);\n\t\tshow_combined_diff(p, 2, revs->dense_combined_merges, revs);\n\t\tfree(p);\n\t\treturn 0;\n\t}\n\n\toldmode = old->ce_mode;\n\tif (mode == oldmode && !hashcmp(sha1, old->sha1) &&\n\t    !DIFF_OPT_TST(&revs->diffopt, FIND_COPIES_HARDER))\n\t\treturn 0;\n\n\tdiff_change(&revs->diffopt, oldmode, mode,\n\t\t    old->sha1, sha1, old->name, NULL);\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static int compare_tree_entry(struct tree_desc *t1, struct tree_desc *t2, const char *base, int baselen, struct diff_options *opt)\n{\n\tunsigned mode1, mode2;\n\tconst char *path1, *path2;\n\tconst unsigned char *sha1, *sha2;\n\tint cmp, pathlen1, pathlen2;\n\n\tsha1 = tree_entry_extract(t1, &path1, &mode1);\n\tsha2 = tree_entry_extract(t2, &path2, &mode2);\n\n\tpathlen1 = tree_entry_len(path1, sha1);\n\tpathlen2 = tree_entry_len(path2, sha2);\n\tcmp = base_name_compare(path1, pathlen1, mode1, path2, pathlen2, mode2);\n\tif (cmp < 0) {\n\t\tshow_entry(opt, \"-\", t1, base, baselen);\n\t\treturn -1;\n\t}\n\tif (cmp > 0) {\n\t\tshow_entry(opt, \"+\", t2, base, baselen);\n\t\treturn 1;\n\t}\n\tif (!DIFF_OPT_TST(opt, FIND_COPIES_HARDER) && !hashcmp(sha1, sha2) && mode1 == mode2)\n\t\treturn 0;\n\n\t/*\n\t * If the filemode has changed to/from a directory from/to a regular\n\t * file, we need to consider it a remove and an add.\n\t */\n\tif (S_ISDIR(mode1) != S_ISDIR(mode2)) {\n\t\tshow_entry(opt, \"-\", t1, base, baselen);\n\t\tshow_entry(opt, \"+\", t2, base, baselen);\n\t\treturn 0;\n\t}\n\n\tif (DIFF_OPT_TST(opt, RECURSIVE) && S_ISDIR(mode1)) {\n\t\tint retval;\n\t\tchar *newbase = malloc_base(base, baselen, path1, pathlen1);\n\t\tif (DIFF_OPT_TST(opt, TREE_IN_RECURSIVE))\n\t\t\topt->change(opt, mode1, mode2,\n\t\t\t\t    sha1, sha2, base, path1);\n\t\tretval = diff_tree_sha1(sha1, sha2, newbase, opt);\n\t\tfree(newbase);\n\t\treturn retval;\n\t}\n\n\topt->change(opt, mode1, mode2, sha1, sha2, base, path1);\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static void diff_index_show_file(struct rev_info *revs,\n\t\t\t\t const char *prefix,\n\t\t\t\t struct cache_entry *ce,\n\t\t\t\t const unsigned char *sha1, unsigned int mode)\n{\n\tdiff_addremove(&revs->diffopt, prefix[0], mode,\n\t\t       sha1, ce->name, NULL);\n}",
        "target": 1
    },
    {
        "func": "void diff_addremove(struct diff_options *options,\n\t\t    int addremove, unsigned mode,\n\t\t    const unsigned char *sha1,\n\t\t    const char *base, const char *path)\n{\n\tchar concatpath[PATH_MAX];\n\tstruct diff_filespec *one, *two;\n\n\tif (DIFF_OPT_TST(options, IGNORE_SUBMODULES) && S_ISGITLINK(mode))\n\t\treturn;\n\n\t/* This may look odd, but it is a preparation for\n\t * feeding \"there are unchanged files which should\n\t * not produce diffs, but when you are doing copy\n\t * detection you would need them, so here they are\"\n\t * entries to the diff-core.  They will be prefixed\n\t * with something like '=' or '*' (I haven't decided\n\t * which but should not make any difference).\n\t * Feeding the same new and old to diff_change()\n\t * also has the same effect.\n\t * Before the final output happens, they are pruned after\n\t * merged into rename/copy pairs as appropriate.\n\t */\n\tif (DIFF_OPT_TST(options, REVERSE_DIFF))\n\t\taddremove = (addremove == '+' ? '-' :\n\t\t\t     addremove == '-' ? '+' : addremove);\n\n\tif (!path) path = \"\";\n\tsprintf(concatpath, \"%s%s\", base, path);\n\n\tif (options->prefix &&\n\t    strncmp(concatpath, options->prefix, options->prefix_length))\n\t\treturn;\n\n\tone = alloc_filespec(concatpath);\n\ttwo = alloc_filespec(concatpath);\n\n\tif (addremove != '+')\n\t\tfill_filespec(one, sha1, mode);\n\tif (addremove != '-')\n\t\tfill_filespec(two, sha1, mode);\n\n\tdiff_queue(&diff_queued_diff, one, two);\n\tDIFF_OPT_SET(options, HAS_CHANGES);\n}",
        "target": 1
    },
    {
        "func": "static void show_entry(struct diff_options *opt, const char *prefix, struct tree_desc *desc,\n\t\t       const char *base, int baselen)\n{\n\tunsigned mode;\n\tconst char *path;\n\tconst unsigned char *sha1 = tree_entry_extract(desc, &path, &mode);\n\n\tif (DIFF_OPT_TST(opt, RECURSIVE) && S_ISDIR(mode)) {\n\t\tenum object_type type;\n\t\tint pathlen = tree_entry_len(path, sha1);\n\t\tchar *newbase = malloc_base(base, baselen, path, pathlen);\n\t\tstruct tree_desc inner;\n\t\tvoid *tree;\n\t\tunsigned long size;\n\n\t\ttree = read_sha1_file(sha1, &type, &size);\n\t\tif (!tree || type != OBJ_TREE)\n\t\t\tdie(\"corrupt tree sha %s\", sha1_to_hex(sha1));\n\n\t\tinit_tree_desc(&inner, tree, size);\n\t\tshow_tree(opt, prefix, &inner, newbase, baselen + 1 + pathlen);\n\n\t\tfree(tree);\n\t\tfree(newbase);\n\t} else {\n\t\topt->add_remove(opt, prefix[0], mode, sha1, base, path);\n\t}\n}",
        "target": 1
    },
    {
        "func": "void diff_change(struct diff_options *options,\n\t\t unsigned old_mode, unsigned new_mode,\n\t\t const unsigned char *old_sha1,\n\t\t const unsigned char *new_sha1,\n\t\t const char *base, const char *path)\n{\n\tchar concatpath[PATH_MAX];\n\tstruct diff_filespec *one, *two;\n\n\tif (DIFF_OPT_TST(options, IGNORE_SUBMODULES) && S_ISGITLINK(old_mode)\n\t\t\t&& S_ISGITLINK(new_mode))\n\t\treturn;\n\n\tif (DIFF_OPT_TST(options, REVERSE_DIFF)) {\n\t\tunsigned tmp;\n\t\tconst unsigned char *tmp_c;\n\t\ttmp = old_mode; old_mode = new_mode; new_mode = tmp;\n\t\ttmp_c = old_sha1; old_sha1 = new_sha1; new_sha1 = tmp_c;\n\t}\n\tif (!path) path = \"\";\n\tsprintf(concatpath, \"%s%s\", base, path);\n\n\tif (options->prefix &&\n\t    strncmp(concatpath, options->prefix, options->prefix_length))\n\t\treturn;\n\n\tone = alloc_filespec(concatpath);\n\ttwo = alloc_filespec(concatpath);\n\tfill_filespec(one, old_sha1, old_mode);\n\tfill_filespec(two, new_sha1, new_mode);\n\n\tdiff_queue(&diff_queued_diff, one, two);\n\tDIFF_OPT_SET(options, HAS_CHANGES);\n}",
        "target": 1
    },
    {
        "func": "static void file_change(struct diff_options *options,\n\t\t unsigned old_mode, unsigned new_mode,\n\t\t const unsigned char *old_sha1,\n\t\t const unsigned char *new_sha1,\n\t\t const char *base, const char *path)\n{\n\ttree_difference = REV_TREE_DIFFERENT;\n\tDIFF_OPT_SET(options, HAS_CHANGES);\n}",
        "target": 1
    },
    {
        "func": "int run_diff_files(struct rev_info *revs, unsigned int option)\n{\n\tint entries, i;\n\tint diff_unmerged_stage = revs->max_count;\n\tint silent_on_removed = option & DIFF_SILENT_ON_REMOVED;\n\tunsigned ce_option = ((option & DIFF_RACY_IS_MODIFIED)\n\t\t\t      ? CE_MATCH_RACY_IS_DIRTY : 0);\n\tchar symcache[PATH_MAX];\n\n\tif (diff_unmerged_stage < 0)\n\t\tdiff_unmerged_stage = 2;\n\tentries = active_nr;\n\tsymcache[0] = '\\0';\n\tfor (i = 0; i < entries; i++) {\n\t\tstruct stat st;\n\t\tunsigned int oldmode, newmode;\n\t\tstruct cache_entry *ce = active_cache[i];\n\t\tint changed;\n\n\t\tif (DIFF_OPT_TST(&revs->diffopt, QUIET) &&\n\t\t\tDIFF_OPT_TST(&revs->diffopt, HAS_CHANGES))\n\t\t\tbreak;\n\n\t\tif (!ce_path_match(ce, revs->prune_data))\n\t\t\tcontinue;\n\n\t\tif (ce_stage(ce)) {\n\t\t\tstruct combine_diff_path *dpath;\n\t\t\tint num_compare_stages = 0;\n\t\t\tsize_t path_len;\n\n\t\t\tpath_len = ce_namelen(ce);\n\n\t\t\tdpath = xmalloc(combine_diff_path_size(5, path_len));\n\t\t\tdpath->path = (char *) &(dpath->parent[5]);\n\n\t\t\tdpath->next = NULL;\n\t\t\tdpath->len = path_len;\n\t\t\tmemcpy(dpath->path, ce->name, path_len);\n\t\t\tdpath->path[path_len] = '\\0';\n\t\t\thashclr(dpath->sha1);\n\t\t\tmemset(&(dpath->parent[0]), 0,\n\t\t\t       sizeof(struct combine_diff_parent)*5);\n\n\t\t\tchanged = check_removed(ce, &st);\n\t\t\tif (!changed)\n\t\t\t\tdpath->mode = ce_mode_from_stat(ce, st.st_mode);\n\t\t\telse {\n\t\t\t\tif (changed < 0) {\n\t\t\t\t\tperror(ce->name);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (silent_on_removed)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\twhile (i < entries) {\n\t\t\t\tstruct cache_entry *nce = active_cache[i];\n\t\t\t\tint stage;\n\n\t\t\t\tif (strcmp(ce->name, nce->name))\n\t\t\t\t\tbreak;\n\n\t\t\t\t/* Stage #2 (ours) is the first parent,\n\t\t\t\t * stage #3 (theirs) is the second.\n\t\t\t\t */\n\t\t\t\tstage = ce_stage(nce);\n\t\t\t\tif (2 <= stage) {\n\t\t\t\t\tint mode = nce->ce_mode;\n\t\t\t\t\tnum_compare_stages++;\n\t\t\t\t\thashcpy(dpath->parent[stage-2].sha1, nce->sha1);\n\t\t\t\t\tdpath->parent[stage-2].mode = ce_mode_from_stat(nce, mode);\n\t\t\t\t\tdpath->parent[stage-2].status =\n\t\t\t\t\t\tDIFF_STATUS_MODIFIED;\n\t\t\t\t}\n\n\t\t\t\t/* diff against the proper unmerged stage */\n\t\t\t\tif (stage == diff_unmerged_stage)\n\t\t\t\t\tce = nce;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Compensate for loop update\n\t\t\t */\n\t\t\ti--;\n\n\t\t\tif (revs->combine_merges && num_compare_stages == 2) {\n\t\t\t\tshow_combined_diff(dpath, 2,\n\t\t\t\t\t\t   revs->dense_combined_merges,\n\t\t\t\t\t\t   revs);\n\t\t\t\tfree(dpath);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfree(dpath);\n\t\t\tdpath = NULL;\n\n\t\t\t/*\n\t\t\t * Show the diff for the 'ce' if we found the one\n\t\t\t * from the desired stage.\n\t\t\t */\n\t\t\tdiff_unmerge(&revs->diffopt, ce->name, 0, null_sha1);\n\t\t\tif (ce_stage(ce) != diff_unmerged_stage)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (ce_uptodate(ce))\n\t\t\tcontinue;\n\n\t\tchanged = check_removed(ce, &st);\n\t\tif (changed) {\n\t\t\tif (changed < 0) {\n\t\t\t\tperror(ce->name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (silent_on_removed)\n\t\t\t\tcontinue;\n\t\t\tdiff_addremove(&revs->diffopt, '-', ce->ce_mode,\n\t\t\t\t       ce->sha1, ce->name, NULL);\n\t\t\tcontinue;\n\t\t}\n\t\tchanged = ce_match_stat(ce, &st, ce_option);\n\t\tif (!changed) {\n\t\t\tce_mark_uptodate(ce);\n\t\t\tif (!DIFF_OPT_TST(&revs->diffopt, FIND_COPIES_HARDER))\n\t\t\t\tcontinue;\n\t\t}\n\t\toldmode = ce->ce_mode;\n\t\tnewmode = ce_mode_from_stat(ce, st.st_mode);\n\t\tdiff_change(&revs->diffopt, oldmode, newmode,\n\t\t\t    ce->sha1, (changed ? null_sha1 : ce->sha1),\n\t\t\t    ce->name, NULL);\n\n\t}\n\tdiffcore_std(&revs->diffopt);\n\tdiff_flush(&revs->diffopt);\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static void prepare_attr_stack(const char *path, int dirlen)\n{\n\tstruct attr_stack *elem, *info;\n\tint len;\n\tchar pathbuf[PATH_MAX];\n\n\t/*\n\t * At the bottom of the attribute stack is the built-in\n\t * set of attribute definitions.  Then, contents from\n\t * .gitattribute files from directories closer to the\n\t * root to the ones in deeper directories are pushed\n\t * to the stack.  Finally, at the very top of the stack\n\t * we always keep the contents of $GIT_DIR/info/attributes.\n\t *\n\t * When checking, we use entries from near the top of the\n\t * stack, preferring $GIT_DIR/info/attributes, then\n\t * .gitattributes in deeper directories to shallower ones,\n\t * and finally use the built-in set as the default.\n\t */\n\tif (!attr_stack)\n\t\tbootstrap_attr_stack();\n\n\t/*\n\t * Pop the \"info\" one that is always at the top of the stack.\n\t */\n\tinfo = attr_stack;\n\tattr_stack = info->prev;\n\n\t/*\n\t * Pop the ones from directories that are not the prefix of\n\t * the path we are checking.\n\t */\n\twhile (attr_stack && attr_stack->origin) {\n\t\tint namelen = strlen(attr_stack->origin);\n\n\t\telem = attr_stack;\n\t\tif (namelen <= dirlen &&\n\t\t    !strncmp(elem->origin, path, namelen))\n\t\t\tbreak;\n\n\t\tdebug_pop(elem);\n\t\tattr_stack = elem->prev;\n\t\tfree_attr_elem(elem);\n\t}\n\n\t/*\n\t * Read from parent directories and push them down\n\t */\n\tif (!is_bare_repository()) {\n\t\twhile (1) {\n\t\t\tchar *cp;\n\n\t\t\tlen = strlen(attr_stack->origin);\n\t\t\tif (dirlen <= len)\n\t\t\t\tbreak;\n\t\t\tmemcpy(pathbuf, path, dirlen);\n\t\t\tmemcpy(pathbuf + dirlen, \"/\", 2);\n\t\t\tcp = strchr(pathbuf + len + 1, '/');\n\t\t\tstrcpy(cp + 1, GITATTRIBUTES_FILE);\n\t\t\telem = read_attr(pathbuf, 0);\n\t\t\t*cp = '\\0';\n\t\t\telem->origin = strdup(pathbuf);\n\t\t\telem->prev = attr_stack;\n\t\t\tattr_stack = elem;\n\t\t\tdebug_push(elem);\n\t\t}\n\t}\n\n\t/*\n\t * Finally push the \"info\" one at the top of the stack.\n\t */\n\tinfo->prev = attr_stack;\n\tattr_stack = info;\n}",
        "target": 1
    },
    {
        "func": "static int grep_tree(struct grep_opt *opt, const char **paths,\n\t\t     struct tree_desc *tree,\n\t\t     const char *tree_name, const char *base)\n{\n\tint len;\n\tint hit = 0;\n\tstruct name_entry entry;\n\tchar *down;\n\tint tn_len = strlen(tree_name);\n\tchar *path_buf = xmalloc(PATH_MAX + tn_len + 100);\n\n\tif (tn_len) {\n\t\ttn_len = sprintf(path_buf, \"%s:\", tree_name);\n\t\tdown = path_buf + tn_len;\n\t\tstrcat(down, base);\n\t}\n\telse {\n\t\tdown = path_buf;\n\t\tstrcpy(down, base);\n\t}\n\tlen = strlen(path_buf);\n\n\twhile (tree_entry(tree, &entry)) {\n\t\tstrcpy(path_buf + len, entry.path);\n\n\t\tif (S_ISDIR(entry.mode))\n\t\t\t/* Match \"abc/\" against pathspec to\n\t\t\t * decide if we want to descend into \"abc\"\n\t\t\t * directory.\n\t\t\t */\n\t\t\tstrcpy(path_buf + len + tree_entry_len(entry.path, entry.sha1), \"/\");\n\n\t\tif (!pathspec_matches(paths, down))\n\t\t\t;\n\t\telse if (S_ISREG(entry.mode))\n\t\t\thit |= grep_sha1(opt, entry.sha1, path_buf, tn_len);\n\t\telse if (S_ISDIR(entry.mode)) {\n\t\t\tenum object_type type;\n\t\t\tstruct tree_desc sub;\n\t\t\tvoid *data;\n\t\t\tunsigned long size;\n\n\t\t\tdata = read_sha1_file(entry.sha1, &type, &size);\n\t\t\tif (!data)\n\t\t\t\tdie(\"unable to read tree (%s)\",\n\t\t\t\t    sha1_to_hex(entry.sha1));\n\t\t\tinit_tree_desc(&sub, data, size);\n\t\t\thit |= grep_tree(opt, paths, &sub, tree_name, down);\n\t\t\tfree(data);\n\t\t}\n\t}\n\treturn hit;\n}",
        "target": 1
    },
    {
        "func": "static int dccp_setsockopt_change(struct sock *sk, int type,\n\t\t\t\t  struct dccp_so_feat __user *optval)\n{\n\tstruct dccp_so_feat opt;\n\tu8 *val;\n\tint rc;\n\n\tif (copy_from_user(&opt, optval, sizeof(opt)))\n\t\treturn -EFAULT;\n\n\tval = kmalloc(opt.dccpsf_len, GFP_KERNEL);\n\tif (!val)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(val, opt.dccpsf_val, opt.dccpsf_len)) {\n\t\trc = -EFAULT;\n\t\tgoto out_free_val;\n\t}\n\n\trc = dccp_feat_change(dccp_msk(sk), type, opt.dccpsf_feat,\n\t\t\t      val, opt.dccpsf_len, GFP_KERNEL);\n\tif (rc)\n\t\tgoto out_free_val;\n\nout:\n\treturn rc;\n\nout_free_val:\n\tkfree(val);\n\tgoto out;\n}",
        "target": 1
    },
    {
        "func": "static int sctp_setsockopt_auth_chunk(struct sock *sk,\n\t\t\t\t    char __user *optval,\n\t\t\t\t    int optlen)\n{\n\tstruct sctp_authchunk val;\n\n\tif (optlen != sizeof(struct sctp_authchunk))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&val, optval, optlen))\n\t\treturn -EFAULT;\n\n\tswitch (val.sauth_chunk) {\n\t\tcase SCTP_CID_INIT:\n\t\tcase SCTP_CID_INIT_ACK:\n\t\tcase SCTP_CID_SHUTDOWN_COMPLETE:\n\t\tcase SCTP_CID_AUTH:\n\t\t\treturn -EINVAL;\n\t}\n\n\t/* add this chunk id to the endpoint */\n\treturn sctp_auth_ep_add_chunkid(sctp_sk(sk)->ep, val.sauth_chunk);\n}",
        "target": 1
    },
    {
        "func": "static int sctp_setsockopt_auth_key(struct sock *sk,\n\t\t\t\t    char __user *optval,\n\t\t\t\t    int optlen)\n{\n\tstruct sctp_authkey *authkey;\n\tstruct sctp_association *asoc;\n\tint ret;\n\n\tif (optlen <= sizeof(struct sctp_authkey))\n\t\treturn -EINVAL;\n\n\tauthkey = kmalloc(optlen, GFP_KERNEL);\n\tif (!authkey)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(authkey, optval, optlen)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tasoc = sctp_id2assoc(sk, authkey->sca_assoc_id);\n\tif (!asoc && authkey->sca_assoc_id && sctp_style(sk, UDP)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = sctp_auth_set_key(sctp_sk(sk)->ep, asoc, authkey);\nout:\n\tkfree(authkey);\n\treturn ret;\n}",
        "target": 1
    },
    {
        "func": "static int sctp_setsockopt_del_key(struct sock *sk,\n\t\t\t\t\tchar __user *optval,\n\t\t\t\t\tint optlen)\n{\n\tstruct sctp_authkeyid val;\n\tstruct sctp_association *asoc;\n\n\tif (optlen != sizeof(struct sctp_authkeyid))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&val, optval, optlen))\n\t\treturn -EFAULT;\n\n\tasoc = sctp_id2assoc(sk, val.scact_assoc_id);\n\tif (!asoc && val.scact_assoc_id && sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\treturn sctp_auth_del_key_id(sctp_sk(sk)->ep, asoc,\n\t\t\t\t    val.scact_keynumber);\n\n}",
        "target": 1
    },
    {
        "func": "static int sctp_getsockopt_local_auth_chunks(struct sock *sk, int len,\n\t\t\t\t    char __user *optval, int __user *optlen)\n{\n\tstruct sctp_authchunks __user *p = (void __user *)optval;\n\tstruct sctp_authchunks val;\n\tstruct sctp_association *asoc;\n\tstruct sctp_chunks_param *ch;\n\tu32    num_chunks;\n\tchar __user *to;\n\n\tif (len <= sizeof(struct sctp_authchunks))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&val, p, sizeof(struct sctp_authchunks)))\n\t\treturn -EFAULT;\n\n\tto = p->gauth_chunks;\n\tasoc = sctp_id2assoc(sk, val.gauth_assoc_id);\n\tif (!asoc && val.gauth_assoc_id && sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tif (asoc)\n\t\tch = (struct sctp_chunks_param*)asoc->c.auth_chunks;\n\telse\n\t\tch = sctp_sk(sk)->ep->auth_chunk_list;\n\n\tnum_chunks = ntohs(ch->param_hdr.length) - sizeof(sctp_paramhdr_t);\n\tif (len < num_chunks)\n\t\treturn -EINVAL;\n\n\tlen = num_chunks;\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (put_user(num_chunks, &p->gauth_number_of_chunks))\n\t\treturn -EFAULT;\n\tif (copy_to_user(to, ch->chunks, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static struct sctp_endpoint *sctp_endpoint_init(struct sctp_endpoint *ep,\n\t\t\t\t\t\tstruct sock *sk,\n\t\t\t\t\t\tgfp_t gfp)\n{\n\tstruct sctp_hmac_algo_param *auth_hmacs = NULL;\n\tstruct sctp_chunks_param *auth_chunks = NULL;\n\tstruct sctp_shared_key *null_key;\n\tint err;\n\n\tmemset(ep, 0, sizeof(struct sctp_endpoint));\n\n\tep->digest = kzalloc(SCTP_SIGNATURE_SIZE, gfp);\n\tif (!ep->digest)\n\t\treturn NULL;\n\n\tif (sctp_auth_enable) {\n\t\t/* Allocate space for HMACS and CHUNKS authentication\n\t\t * variables.  There are arrays that we encode directly\n\t\t * into parameters to make the rest of the operations easier.\n\t\t */\n\t\tauth_hmacs = kzalloc(sizeof(sctp_hmac_algo_param_t) +\n\t\t\t\tsizeof(__u16) * SCTP_AUTH_NUM_HMACS, gfp);\n\t\tif (!auth_hmacs)\n\t\t\tgoto nomem;\n\n\t\tauth_chunks = kzalloc(sizeof(sctp_chunks_param_t) +\n\t\t\t\t\tSCTP_NUM_CHUNK_TYPES, gfp);\n\t\tif (!auth_chunks)\n\t\t\tgoto nomem;\n\n\t\t/* Initialize the HMACS parameter.\n\t\t * SCTP-AUTH: Section 3.3\n\t\t *    Every endpoint supporting SCTP chunk authentication MUST\n\t\t *    support the HMAC based on the SHA-1 algorithm.\n\t\t */\n\t\tauth_hmacs->param_hdr.type = SCTP_PARAM_HMAC_ALGO;\n\t\tauth_hmacs->param_hdr.length =\n\t\t\t\t\thtons(sizeof(sctp_paramhdr_t) + 2);\n\t\tauth_hmacs->hmac_ids[0] = htons(SCTP_AUTH_HMAC_ID_SHA1);\n\n\t\t/* Initialize the CHUNKS parameter */\n\t\tauth_chunks->param_hdr.type = SCTP_PARAM_CHUNKS;\n\n\t\t/* If the Add-IP functionality is enabled, we must\n\t\t * authenticate, ASCONF and ASCONF-ACK chunks\n\t\t */\n\t\tif (sctp_addip_enable) {\n\t\t\tauth_chunks->chunks[0] = SCTP_CID_ASCONF;\n\t\t\tauth_chunks->chunks[1] = SCTP_CID_ASCONF_ACK;\n\t\t\tauth_chunks->param_hdr.length =\n\t\t\t\t\thtons(sizeof(sctp_paramhdr_t) + 2);\n\t\t}\n\t}\n\n\t/* Initialize the base structure. */\n\t/* What type of endpoint are we?  */\n\tep->base.type = SCTP_EP_TYPE_SOCKET;\n\n\t/* Initialize the basic object fields. */\n\tatomic_set(&ep->base.refcnt, 1);\n\tep->base.dead = 0;\n\tep->base.malloced = 1;\n\n\t/* Create an input queue.  */\n\tsctp_inq_init(&ep->base.inqueue);\n\n\t/* Set its top-half handler */\n\tsctp_inq_set_th_handler(&ep->base.inqueue, sctp_endpoint_bh_rcv);\n\n\t/* Initialize the bind addr area */\n\tsctp_bind_addr_init(&ep->base.bind_addr, 0);\n\n\t/* Remember who we are attached to.  */\n\tep->base.sk = sk;\n\tsock_hold(ep->base.sk);\n\n\t/* Create the lists of associations.  */\n\tINIT_LIST_HEAD(&ep->asocs);\n\n\t/* Use SCTP specific send buffer space queues.  */\n\tep->sndbuf_policy = sctp_sndbuf_policy;\n\n\tsk->sk_write_space = sctp_write_space;\n\tsock_set_flag(sk, SOCK_USE_WRITE_QUEUE);\n\n\t/* Get the receive buffer policy for this endpoint */\n\tep->rcvbuf_policy = sctp_rcvbuf_policy;\n\n\t/* Initialize the secret key used with cookie. */\n\tget_random_bytes(&ep->secret_key[0], SCTP_SECRET_SIZE);\n\tep->last_key = ep->current_key = 0;\n\tep->key_changed_at = jiffies;\n\n\t/* SCTP-AUTH extensions*/\n\tINIT_LIST_HEAD(&ep->endpoint_shared_keys);\n\tnull_key = sctp_auth_shkey_create(0, GFP_KERNEL);\n\tif (!null_key)\n\t\tgoto nomem;\n\n\tlist_add(&null_key->key_list, &ep->endpoint_shared_keys);\n\n\t/* Allocate and initialize transorms arrays for suported HMACs. */\n\terr = sctp_auth_init_hmacs(ep, gfp);\n\tif (err)\n\t\tgoto nomem_hmacs;\n\n\t/* Add the null key to the endpoint shared keys list and\n\t * set the hmcas and chunks pointers.\n\t */\n\tep->auth_hmacs_list = auth_hmacs;\n\tep->auth_chunk_list = auth_chunks;\n\n\treturn ep;\n\nnomem_hmacs:\n\tsctp_auth_destroy_keys(&ep->endpoint_shared_keys);\nnomem:\n\t/* Free all allocations */\n\tkfree(auth_hmacs);\n\tkfree(auth_chunks);\n\tkfree(ep->digest);\n\treturn NULL;\n\n}",
        "target": 1
    },
    {
        "func": "static int sctp_setsockopt_hmac_ident(struct sock *sk,\n\t\t\t\t    char __user *optval,\n\t\t\t\t    int optlen)\n{\n\tstruct sctp_hmacalgo *hmacs;\n\tint err;\n\n\tif (optlen < sizeof(struct sctp_hmacalgo))\n\t\treturn -EINVAL;\n\n\thmacs = kmalloc(optlen, GFP_KERNEL);\n\tif (!hmacs)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(hmacs, optval, optlen)) {\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (hmacs->shmac_num_idents == 0 ||\n\t    hmacs->shmac_num_idents > SCTP_AUTH_NUM_HMACS) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\terr = sctp_auth_ep_set_hmacs(sctp_sk(sk)->ep, hmacs);\nout:\n\tkfree(hmacs);\n\treturn err;\n}",
        "target": 1
    },
    {
        "func": "static int sctp_getsockopt_active_key(struct sock *sk, int len,\n\t\t\t\t    char __user *optval, int __user *optlen)\n{\n\tstruct sctp_authkeyid val;\n\tstruct sctp_association *asoc;\n\n\tif (len < sizeof(struct sctp_authkeyid))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&val, optval, sizeof(struct sctp_authkeyid)))\n\t\treturn -EFAULT;\n\n\tasoc = sctp_id2assoc(sk, val.scact_assoc_id);\n\tif (!asoc && val.scact_assoc_id && sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tif (asoc)\n\t\tval.scact_keynumber = asoc->active_key_id;\n\telse\n\t\tval.scact_keynumber = sctp_sk(sk)->ep->active_key_id;\n\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static int sctp_getsockopt_hmac_ident(struct sock *sk, int len,\n\t\t\t\t    char __user *optval, int __user *optlen)\n{\n\tstruct sctp_hmac_algo_param *hmacs;\n\t__u16 param_len;\n\n\thmacs = sctp_sk(sk)->ep->auth_hmacs_list;\n\tparam_len = ntohs(hmacs->param_hdr.length);\n\n\tif (len < param_len)\n\t\treturn -EINVAL;\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, hmacs->hmac_ids, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static int sctp_setsockopt_active_key(struct sock *sk,\n\t\t\t\t\tchar __user *optval,\n\t\t\t\t\tint optlen)\n{\n\tstruct sctp_authkeyid val;\n\tstruct sctp_association *asoc;\n\n\tif (optlen != sizeof(struct sctp_authkeyid))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&val, optval, optlen))\n\t\treturn -EFAULT;\n\n\tasoc = sctp_id2assoc(sk, val.scact_assoc_id);\n\tif (!asoc && val.scact_assoc_id && sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\treturn sctp_auth_set_active_key(sctp_sk(sk)->ep, asoc,\n\t\t\t\t\tval.scact_keynumber);\n}",
        "target": 1
    },
    {
        "func": "static int sctp_getsockopt_peer_auth_chunks(struct sock *sk, int len,\n\t\t\t\t    char __user *optval, int __user *optlen)\n{\n\tstruct sctp_authchunks __user *p = (void __user *)optval;\n\tstruct sctp_authchunks val;\n\tstruct sctp_association *asoc;\n\tstruct sctp_chunks_param *ch;\n\tu32    num_chunks;\n\tchar __user *to;\n\n\tif (len <= sizeof(struct sctp_authchunks))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&val, p, sizeof(struct sctp_authchunks)))\n\t\treturn -EFAULT;\n\n\tto = p->gauth_chunks;\n\tasoc = sctp_id2assoc(sk, val.gauth_assoc_id);\n\tif (!asoc)\n\t\treturn -EINVAL;\n\n\tch = asoc->peer.peer_chunks;\n\n\t/* See if the user provided enough room for all the data */\n\tnum_chunks = ntohs(ch->param_hdr.length) - sizeof(sctp_paramhdr_t);\n\tif (len < num_chunks)\n\t\treturn -EINVAL;\n\n\tlen = num_chunks;\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (put_user(num_chunks, &p->gauth_number_of_chunks))\n\t\treturn -EFAULT;\n\tif (copy_to_user(to, ch->chunks, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static int sctp_setsockopt_auth_key(struct sock *sk,\n\t\t\t\t    char __user *optval,\n\t\t\t\t    int optlen)\n{\n\tstruct sctp_authkey *authkey;\n\tstruct sctp_association *asoc;\n\tint ret;\n\n\tif (!sctp_auth_enable)\n\t\treturn -EACCES;\n\n\tif (optlen <= sizeof(struct sctp_authkey))\n\t\treturn -EINVAL;\n\n\tauthkey = kmalloc(optlen, GFP_KERNEL);\n\tif (!authkey)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(authkey, optval, optlen)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tasoc = sctp_id2assoc(sk, authkey->sca_assoc_id);\n\tif (!asoc && authkey->sca_assoc_id && sctp_style(sk, UDP)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = sctp_auth_set_key(sctp_sk(sk)->ep, asoc, authkey);\nout:\n\tkfree(authkey);\n\treturn ret;\n}",
        "target": 1
    },
    {
        "func": "static struct sctp_auth_bytes *sctp_auth_create_key(__u32 key_len, gfp_t gfp)\n{\n\tstruct sctp_auth_bytes *key;\n\n\t/* Allocate the shared key */\n\tkey = kmalloc(sizeof(struct sctp_auth_bytes) + key_len, gfp);\n\tif (!key)\n\t\treturn NULL;\n\n\tkey->len = key_len;\n\tatomic_set(&key->refcnt, 1);\n\tSCTP_DBG_OBJCNT_INC(keys);\n\n\treturn key;\n}",
        "target": 1
    },
    {
        "func": "static int sctp_setsockopt_auth_key(struct sock *sk,\n\t\t\t\t    char __user *optval,\n\t\t\t\t    int optlen)\n{\n\tstruct sctp_authkey *authkey;\n\tstruct sctp_association *asoc;\n\tint ret;\n\n\tif (!sctp_auth_enable)\n\t\treturn -EACCES;\n\n\tif (optlen <= sizeof(struct sctp_authkey))\n\t\treturn -EINVAL;\n\n\tauthkey = kmalloc(optlen, GFP_KERNEL);\n\tif (!authkey)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(authkey, optval, optlen)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (authkey->sca_keylength > optlen) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tasoc = sctp_id2assoc(sk, authkey->sca_assoc_id);\n\tif (!asoc && authkey->sca_assoc_id && sctp_style(sk, UDP)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = sctp_auth_set_key(sctp_sk(sk)->ep, asoc, authkey);\nout:\n\tkfree(authkey);\n\treturn ret;\n}",
        "target": 1
    },
    {
        "func": "int __init sysenter_setup(void)\n{\n\tsyscall_page = (void *)get_zeroed_page(GFP_ATOMIC);\n\n#ifdef CONFIG_COMPAT_VDSO\n\t__set_fixmap(FIX_VDSO, __pa(syscall_page), PAGE_READONLY);\n\tprintk(\"Compat vDSO mapped to %08lx.\\n\", __fix_to_virt(FIX_VDSO));\n#endif\n\n\tif (!boot_cpu_has(X86_FEATURE_SEP)) {\n\t\tmemcpy(syscall_page,\n\t\t       &vsyscall_int80_start,\n\t\t       &vsyscall_int80_end - &vsyscall_int80_start);\n\t\treturn 0;\n\t}\n\n\tmemcpy(syscall_page,\n\t       &vsyscall_sysenter_start,\n\t       &vsyscall_sysenter_end - &vsyscall_sysenter_start);\n\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static void syscall_vma_close(struct vm_area_struct *vma)\n{\n}",
        "target": 1
    },
    {
        "func": "static struct page *syscall_nopage(struct vm_area_struct *vma,\n\t\t\t\tunsigned long adr, int *type)\n{\n\tstruct page *p = virt_to_page(adr - vma->vm_start + syscall_page);\n\tget_page(p);\n\treturn p;\n}",
        "target": 1
    },
    {
        "func": "int arch_setup_additional_pages(struct linux_binprm *bprm, int exstack)\n{\n\tstruct vm_area_struct *vma;\n\tstruct mm_struct *mm = current->mm;\n\tunsigned long addr;\n\tint ret;\n\n\tdown_write(&mm->mmap_sem);\n\taddr = get_unmapped_area(NULL, 0, PAGE_SIZE, 0, 0);\n\tif (IS_ERR_VALUE(addr)) {\n\t\tret = addr;\n\t\tgoto up_fail;\n\t}\n\n\tvma = kmem_cache_zalloc(vm_area_cachep, GFP_KERNEL);\n\tif (!vma) {\n\t\tret = -ENOMEM;\n\t\tgoto up_fail;\n\t}\n\n\tvma->vm_start = addr;\n\tvma->vm_end = addr + PAGE_SIZE;\n\t/* MAYWRITE to allow gdb to COW and set breakpoints */\n\tvma->vm_flags = VM_READ|VM_EXEC|VM_MAYREAD|VM_MAYEXEC|VM_MAYWRITE;\n\t/*\n\t * Make sure the vDSO gets into every core dump.\n\t * Dumping its contents makes post-mortem fully interpretable later\n\t * without matching up the same kernel and hardware config to see\n\t * what PC values meant.\n\t */\n\tvma->vm_flags |= VM_ALWAYSDUMP;\n\tvma->vm_flags |= mm->def_flags;\n\tvma->vm_page_prot = protection_map[vma->vm_flags & 7];\n\tvma->vm_ops = &syscall_vm_ops;\n\tvma->vm_mm = mm;\n\n\tret = insert_vm_struct(mm, vma);\n\tif (unlikely(ret)) {\n\t\tkmem_cache_free(vm_area_cachep, vma);\n\t\tgoto up_fail;\n\t}\n\n\tcurrent->mm->context.vdso = (void *)addr;\n\tcurrent_thread_info()->sysenter_return =\n\t\t\t\t    (void *)VDSO_SYM(&SYSENTER_RETURN);\n\tmm->total_vm++;\nup_fail:\n\tup_write(&mm->mmap_sem);\n\treturn ret;\n}",
        "target": 1
    },
    {
        "func": "sbni_ioctl( struct net_device  *dev,  struct ifreq  *ifr,  int  cmd )\n{\n\tstruct net_local  *nl = (struct net_local *) dev->priv; \n\tstruct sbni_flags  flags;\n\tint  error = 0;\n\n#ifdef CONFIG_SBNI_MULTILINE\n\tstruct net_device  *slave_dev;\n\tchar  slave_name[ 8 ];\n#endif\n  \n\tswitch( cmd ) {\n\tcase  SIOCDEVGETINSTATS :\n\t\tif (copy_to_user( ifr->ifr_data, &nl->in_stats,\n\t\t\t\t\tsizeof(struct sbni_in_stats) ))\n\t\t\terror = -EFAULT;\n\t\tbreak;\n\n\tcase  SIOCDEVRESINSTATS :\n\t\tif( current->euid != 0 )\t/* root only */\n\t\t\treturn  -EPERM;\n\t\tmemset( &nl->in_stats, 0, sizeof(struct sbni_in_stats) );\n\t\tbreak;\n\n\tcase  SIOCDEVGHWSTATE :\n\t\tflags.mac_addr\t= *(u32 *)(dev->dev_addr + 3);\n\t\tflags.rate\t= nl->csr1.rate;\n\t\tflags.slow_mode\t= (nl->state & FL_SLOW_MODE) != 0;\n\t\tflags.rxl\t= nl->cur_rxl_index;\n\t\tflags.fixed_rxl\t= nl->delta_rxl == 0;\n\n\t\tif (copy_to_user( ifr->ifr_data, &flags, sizeof flags ))\n\t\t\terror = -EFAULT;\n\t\tbreak;\n\n\tcase  SIOCDEVSHWSTATE :\n\t\tif( current->euid != 0 )\t/* root only */\n\t\t\treturn  -EPERM;\n\n\t\tspin_lock( &nl->lock );\n\t\tflags = *(struct sbni_flags*) &ifr->ifr_ifru;\n\t\tif( flags.fixed_rxl )\n\t\t\tnl->delta_rxl = 0,\n\t\t\tnl->cur_rxl_index = flags.rxl;\n\t\telse\n\t\t\tnl->delta_rxl = DEF_RXL_DELTA,\n\t\t\tnl->cur_rxl_index = DEF_RXL;\n\n\t\tnl->csr1.rxl = rxl_tab[ nl->cur_rxl_index ];\n\t\tnl->csr1.rate = flags.rate;\n\t\toutb( *(u8 *)&nl->csr1 | PR_RES, dev->base_addr + CSR1 );\n\t\tspin_unlock( &nl->lock );\n\t\tbreak;\n\n#ifdef CONFIG_SBNI_MULTILINE\n\n\tcase  SIOCDEVENSLAVE :\n\t\tif( current->euid != 0 )\t/* root only */\n\t\t\treturn  -EPERM;\n\n\t\tif (copy_from_user( slave_name, ifr->ifr_data, sizeof slave_name ))\n\t\t\treturn -EFAULT;\n\t\tslave_dev = dev_get_by_name(&init_net, slave_name );\n\t\tif( !slave_dev  ||  !(slave_dev->flags & IFF_UP) ) {\n\t\t\tprintk( KERN_ERR \"%s: trying to enslave non-active \"\n\t\t\t\t\"device %s\\n\", dev->name, slave_name );\n\t\t\treturn  -EPERM;\n\t\t}\n\n\t\treturn  enslave( dev, slave_dev );\n\n\tcase  SIOCDEVEMANSIPATE :\n\t\tif( current->euid != 0 )\t/* root only */\n\t\t\treturn  -EPERM;\n\n\t\treturn  emancipate( dev );\n\n#endif\t/* CONFIG_SBNI_MULTILINE */\n\n\tdefault :\n\t\treturn  -EOPNOTSUPP;\n\t}\n\n\treturn  error;\n}",
        "target": 1
    },
    {
        "func": "__blockdev_direct_IO(int rw, struct kiocb *iocb, struct inode *inode,\n\tstruct block_device *bdev, const struct iovec *iov, loff_t offset, \n\tunsigned long nr_segs, get_block_t get_block, dio_iodone_t end_io,\n\tint dio_lock_type)\n{\n\tint seg;\n\tsize_t size;\n\tunsigned long addr;\n\tunsigned blkbits = inode->i_blkbits;\n\tunsigned bdev_blkbits = 0;\n\tunsigned blocksize_mask = (1 << blkbits) - 1;\n\tssize_t retval = -EINVAL;\n\tloff_t end = offset;\n\tstruct dio *dio;\n\tint release_i_mutex = 0;\n\tint acquire_i_mutex = 0;\n\n\tif (rw & WRITE)\n\t\trw = WRITE_SYNC;\n\n\tif (bdev)\n\t\tbdev_blkbits = blksize_bits(bdev_hardsect_size(bdev));\n\n\tif (offset & blocksize_mask) {\n\t\tif (bdev)\n\t\t\t blkbits = bdev_blkbits;\n\t\tblocksize_mask = (1 << blkbits) - 1;\n\t\tif (offset & blocksize_mask)\n\t\t\tgoto out;\n\t}\n\n\t/* Check the memory alignment.  Blocks cannot straddle pages */\n\tfor (seg = 0; seg < nr_segs; seg++) {\n\t\taddr = (unsigned long)iov[seg].iov_base;\n\t\tsize = iov[seg].iov_len;\n\t\tend += size;\n\t\tif ((addr & blocksize_mask) || (size & blocksize_mask))  {\n\t\t\tif (bdev)\n\t\t\t\t blkbits = bdev_blkbits;\n\t\t\tblocksize_mask = (1 << blkbits) - 1;\n\t\t\tif ((addr & blocksize_mask) || (size & blocksize_mask))  \n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tdio = kmalloc(sizeof(*dio), GFP_KERNEL);\n\tretval = -ENOMEM;\n\tif (!dio)\n\t\tgoto out;\n\n\t/*\n\t * For block device access DIO_NO_LOCKING is used,\n\t *\tneither readers nor writers do any locking at all\n\t * For regular files using DIO_LOCKING,\n\t *\treaders need to grab i_mutex and i_alloc_sem\n\t *\twriters need to grab i_alloc_sem only (i_mutex is already held)\n\t * For regular files using DIO_OWN_LOCKING,\n\t *\tneither readers nor writers take any locks here\n\t */\n\tdio->lock_type = dio_lock_type;\n\tif (dio_lock_type != DIO_NO_LOCKING) {\n\t\t/* watch out for a 0 len io from a tricksy fs */\n\t\tif (rw == READ && end > offset) {\n\t\t\tstruct address_space *mapping;\n\n\t\t\tmapping = iocb->ki_filp->f_mapping;\n\t\t\tif (dio_lock_type != DIO_OWN_LOCKING) {\n\t\t\t\tmutex_lock(&inode->i_mutex);\n\t\t\t\trelease_i_mutex = 1;\n\t\t\t}\n\n\t\t\tretval = filemap_write_and_wait_range(mapping, offset,\n\t\t\t\t\t\t\t      end - 1);\n\t\t\tif (retval) {\n\t\t\t\tkfree(dio);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (dio_lock_type == DIO_OWN_LOCKING) {\n\t\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t\t\tacquire_i_mutex = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (dio_lock_type == DIO_LOCKING)\n\t\t\t/* lockdep: not the owner will release it */\n\t\t\tdown_read_non_owner(&inode->i_alloc_sem);\n\t}\n\n\t/*\n\t * For file extending writes updating i_size before data\n\t * writeouts complete can expose uninitialized blocks. So\n\t * even for AIO, we need to wait for i/o to complete before\n\t * returning in this case.\n\t */\n\tdio->is_async = !is_sync_kiocb(iocb) && !((rw & WRITE) &&\n\t\t(end > i_size_read(inode)));\n\n\tretval = direct_io_worker(rw, iocb, inode, iov, offset,\n\t\t\t\tnr_segs, blkbits, get_block, end_io, dio);\n\n\tif (rw == READ && dio_lock_type == DIO_LOCKING)\n\t\trelease_i_mutex = 0;\n\nout:\n\tif (release_i_mutex)\n\t\tmutex_unlock(&inode->i_mutex);\n\telse if (acquire_i_mutex)\n\t\tmutex_lock(&inode->i_mutex);\n\treturn retval;\n}",
        "target": 1
    },
    {
        "func": "direct_io_worker(int rw, struct kiocb *iocb, struct inode *inode, \n\tconst struct iovec *iov, loff_t offset, unsigned long nr_segs, \n\tunsigned blkbits, get_block_t get_block, dio_iodone_t end_io,\n\tstruct dio *dio)\n{\n\tunsigned long user_addr; \n\tunsigned long flags;\n\tint seg;\n\tssize_t ret = 0;\n\tssize_t ret2;\n\tsize_t bytes;\n\n\tdio->bio = NULL;\n\tdio->inode = inode;\n\tdio->rw = rw;\n\tdio->blkbits = blkbits;\n\tdio->blkfactor = inode->i_blkbits - blkbits;\n\tdio->start_zero_done = 0;\n\tdio->size = 0;\n\tdio->block_in_file = offset >> blkbits;\n\tdio->blocks_available = 0;\n\tdio->cur_page = NULL;\n\n\tdio->boundary = 0;\n\tdio->reap_counter = 0;\n\tdio->get_block = get_block;\n\tdio->end_io = end_io;\n\tdio->map_bh.b_private = NULL;\n\tdio->map_bh.b_state = 0;\n\tdio->final_block_in_bio = -1;\n\tdio->next_block_for_io = -1;\n\n\tdio->page_errors = 0;\n\tdio->io_error = 0;\n\tdio->result = 0;\n\tdio->iocb = iocb;\n\tdio->i_size = i_size_read(inode);\n\n\tspin_lock_init(&dio->bio_lock);\n\tdio->refcount = 1;\n\tdio->bio_list = NULL;\n\tdio->waiter = NULL;\n\n\t/*\n\t * In case of non-aligned buffers, we may need 2 more\n\t * pages since we need to zero out first and last block.\n\t */\n\tif (unlikely(dio->blkfactor))\n\t\tdio->pages_in_io = 2;\n\telse\n\t\tdio->pages_in_io = 0;\n\n\tfor (seg = 0; seg < nr_segs; seg++) {\n\t\tuser_addr = (unsigned long)iov[seg].iov_base;\n\t\tdio->pages_in_io +=\n\t\t\t((user_addr+iov[seg].iov_len +PAGE_SIZE-1)/PAGE_SIZE\n\t\t\t\t- user_addr/PAGE_SIZE);\n\t}\n\n\tfor (seg = 0; seg < nr_segs; seg++) {\n\t\tuser_addr = (unsigned long)iov[seg].iov_base;\n\t\tdio->size += bytes = iov[seg].iov_len;\n\n\t\t/* Index into the first page of the first block */\n\t\tdio->first_block_in_page = (user_addr & ~PAGE_MASK) >> blkbits;\n\t\tdio->final_block_in_request = dio->block_in_file +\n\t\t\t\t\t\t(bytes >> blkbits);\n\t\t/* Page fetching state */\n\t\tdio->head = 0;\n\t\tdio->tail = 0;\n\t\tdio->curr_page = 0;\n\n\t\tdio->total_pages = 0;\n\t\tif (user_addr & (PAGE_SIZE-1)) {\n\t\t\tdio->total_pages++;\n\t\t\tbytes -= PAGE_SIZE - (user_addr & (PAGE_SIZE - 1));\n\t\t}\n\t\tdio->total_pages += (bytes + PAGE_SIZE - 1) / PAGE_SIZE;\n\t\tdio->curr_user_address = user_addr;\n\t\n\t\tret = do_direct_IO(dio);\n\n\t\tdio->result += iov[seg].iov_len -\n\t\t\t((dio->final_block_in_request - dio->block_in_file) <<\n\t\t\t\t\tblkbits);\n\n\t\tif (ret) {\n\t\t\tdio_cleanup(dio);\n\t\t\tbreak;\n\t\t}\n\t} /* end iovec loop */\n\n\tif (ret == -ENOTBLK && (rw & WRITE)) {\n\t\t/*\n\t\t * The remaining part of the request will be\n\t\t * be handled by buffered I/O when we return\n\t\t */\n\t\tret = 0;\n\t}\n\t/*\n\t * There may be some unwritten disk at the end of a part-written\n\t * fs-block-sized block.  Go zero that now.\n\t */\n\tdio_zero_block(dio, 1);\n\n\tif (dio->cur_page) {\n\t\tret2 = dio_send_cur_page(dio);\n\t\tif (ret == 0)\n\t\t\tret = ret2;\n\t\tpage_cache_release(dio->cur_page);\n\t\tdio->cur_page = NULL;\n\t}\n\tif (dio->bio)\n\t\tdio_bio_submit(dio);\n\n\t/* All IO is now issued, send it on its way */\n\tblk_run_address_space(inode->i_mapping);\n\n\t/*\n\t * It is possible that, we return short IO due to end of file.\n\t * In that case, we need to release all the pages we got hold on.\n\t */\n\tdio_cleanup(dio);\n\n\t/*\n\t * All block lookups have been performed. For READ requests\n\t * we can let i_mutex go now that its achieved its purpose\n\t * of protecting us from looking up uninitialized blocks.\n\t */\n\tif ((rw == READ) && (dio->lock_type == DIO_LOCKING))\n\t\tmutex_unlock(&dio->inode->i_mutex);\n\n\t/*\n\t * The only time we want to leave bios in flight is when a successful\n\t * partial aio read or full aio write have been setup.  In that case\n\t * bio completion will call aio_complete.  The only time it's safe to\n\t * call aio_complete is when we return -EIOCBQUEUED, so we key on that.\n\t * This had *better* be the only place that raises -EIOCBQUEUED.\n\t */\n\tBUG_ON(ret == -EIOCBQUEUED);\n\tif (dio->is_async && ret == 0 && dio->result &&\n\t    ((rw & READ) || (dio->result == dio->size)))\n\t\tret = -EIOCBQUEUED;\n\n\tif (ret != -EIOCBQUEUED)\n\t\tdio_await_completion(dio);\n\n\t/*\n\t * Sync will always be dropping the final ref and completing the\n\t * operation.  AIO can if it was a broken operation described above or\n\t * in fact if all the bios race to complete before we get here.  In\n\t * that case dio_complete() translates the EIOCBQUEUED into the proper\n\t * return code that the caller will hand to aio_complete().\n\t *\n\t * This is managed by the bio_lock instead of being an atomic_t so that\n\t * completion paths can drop their ref and use the remaining count to\n\t * decide to wake the submission path atomically.\n\t */\n\tspin_lock_irqsave(&dio->bio_lock, flags);\n\tret2 = --dio->refcount;\n\tspin_unlock_irqrestore(&dio->bio_lock, flags);\n\n\tif (ret2 == 0) {\n\t\tret = dio_complete(dio, offset, ret);\n\t\tkfree(dio);\n\t} else\n\t\tBUG_ON(ret != -EIOCBQUEUED);\n\n\treturn ret;\n}",
        "target": 1
    },
    {
        "func": "init_state(struct posix_acl_state *state, int cnt)\n{\n\tint alloc;\n\n\tmemset(state, 0, sizeof(struct posix_acl_state));\n\tstate->empty = 1;\n\t/*\n\t * In the worst case, each individual acl could be for a distinct\n\t * named user or group, but we don't no which, so we allocate\n\t * enough space for either:\n\t */\n\talloc = sizeof(struct posix_ace_state_array)\n\t\t+ cnt*sizeof(struct posix_ace_state);\n\tstate->users = kzalloc(alloc, GFP_KERNEL);\n\tif (!state->users)\n\t\treturn -ENOMEM;\n\tstate->groups = kzalloc(alloc, GFP_KERNEL);\n\tif (!state->groups) {\n\t\tkfree(state->users);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static int jas_icctxtdesc_input(jas_iccattrval_t *attrval, jas_stream_t *in,\n  int cnt)\n{\n\tint n;\n\tint c;\n\tjas_icctxtdesc_t *txtdesc = &attrval->data.txtdesc;\n\ttxtdesc->ascdata = 0;\n\ttxtdesc->ucdata = 0;\n\tif (jas_iccgetuint32(in, &txtdesc->asclen))\n\t\tgoto error;\n\tif (!(txtdesc->ascdata = jas_malloc(txtdesc->asclen)))\n\t\tgoto error;\n\tif (jas_stream_read(in, txtdesc->ascdata, txtdesc->asclen) !=\n\t  JAS_CAST(int, txtdesc->asclen))\n\t\tgoto error;\n\ttxtdesc->ascdata[txtdesc->asclen - 1] = '\\0';\n\tif (jas_iccgetuint32(in, &txtdesc->uclangcode) ||\n\t  jas_iccgetuint32(in, &txtdesc->uclen))\n\t\tgoto error;\n\tif (!(txtdesc->ucdata = jas_malloc(txtdesc->uclen * 2)))\n\t\tgoto error;\n\tif (jas_stream_read(in, txtdesc->ucdata, txtdesc->uclen * 2) !=\n\t  JAS_CAST(int, txtdesc->uclen * 2))\n\t\tgoto error;\n\tif (jas_iccgetuint16(in, &txtdesc->sccode))\n\t\tgoto error;\n\tif ((c = jas_stream_getc(in)) == EOF)\n\t\tgoto error;\n\ttxtdesc->maclen = c;\n\tif (jas_stream_read(in, txtdesc->macdata, 67) != 67)\n\t\tgoto error;\n\ttxtdesc->asclen = strlen(txtdesc->ascdata) + 1;\n#define WORKAROUND_BAD_PROFILES\n#ifdef WORKAROUND_BAD_PROFILES\n\tn = txtdesc->asclen + txtdesc->uclen * 2 + 15 + 67;\n\tif (n > cnt) {\n\t\treturn -1;\n\t}\n\tif (n < cnt) {\n\t\tif (jas_stream_gobble(in, cnt - n) != cnt - n)\n\t\t\tgoto error;\n\t}\n#else\n\tif (txtdesc->asclen + txtdesc->uclen * 2 + 15 + 67 != cnt)\n\t\treturn -1;\n#endif\n\treturn 0;\nerror:\n\tjas_icctxtdesc_destroy(attrval);\n\treturn -1;\n}",
        "target": 1
    },
    {
        "func": "void jpc_qmfb_split_row(jpc_fix_t *a, int numcols, int parity)\n{\n\n\tint bufsize = JPC_CEILDIVPOW2(numcols, 1);\n\tjpc_fix_t splitbuf[QMFB_SPLITBUFSIZE];\n\tjpc_fix_t *buf = splitbuf;\n\tregister jpc_fix_t *srcptr;\n\tregister jpc_fix_t *dstptr;\n\tregister int n;\n\tregister int m;\n\tint hstartcol;\n\n\t/* Get a buffer. */\n\tif (bufsize > QMFB_SPLITBUFSIZE) {\n\t\tif (!(buf = jas_malloc(bufsize * sizeof(jpc_fix_t)))) {\n\t\t\t/* We have no choice but to commit suicide in this case. */\n\t\t\tabort();\n\t\t}\n\t}\n\n\tif (numcols >= 2) {\n\t\thstartcol = (numcols + 1 - parity) >> 1;\n\t\tm = (parity) ? hstartcol : (numcols - hstartcol);\n\t\t/* Save the samples destined for the highpass channel. */\n\t\tn = m;\n\t\tdstptr = buf;\n\t\tsrcptr = &a[1 - parity];\n\t\twhile (n-- > 0) {\n\t\t\t*dstptr = *srcptr;\n\t\t\t++dstptr;\n\t\t\tsrcptr += 2;\n\t\t}\n\t\t/* Copy the appropriate samples into the lowpass channel. */\n\t\tdstptr = &a[1 - parity];\n\t\tsrcptr = &a[2 - parity];\n\t\tn = numcols - m - (!parity);\n\t\twhile (n-- > 0) {\n\t\t\t*dstptr = *srcptr;\n\t\t\t++dstptr;\n\t\t\tsrcptr += 2;\n\t\t}\n\t\t/* Copy the saved samples into the highpass channel. */\n\t\tdstptr = &a[hstartcol];\n\t\tsrcptr = buf;\n\t\tn = m;\n\t\twhile (n-- > 0) {\n\t\t\t*dstptr = *srcptr;\n\t\t\t++dstptr;\n\t\t\t++srcptr;\n\t\t}\n\t}\n\n\t/* If the split buffer was allocated on the heap, free this memory. */\n\tif (buf != splitbuf) {\n\t\tjas_free(buf);\n\t}\n\n}",
        "target": 1
    },
    {
        "func": "static int jas_image_growcmpts(jas_image_t *image, int maxcmpts)\n{\n\tjas_image_cmpt_t **newcmpts;\n\tint cmptno;\n\n\tnewcmpts = (!image->cmpts_) ? jas_malloc(maxcmpts * sizeof(jas_image_cmpt_t *)) :\n\t  jas_realloc(image->cmpts_, maxcmpts * sizeof(jas_image_cmpt_t *));\n\tif (!newcmpts) {\n\t\treturn -1;\n\t}\n\timage->cmpts_ = newcmpts;\n\timage->maxcmpts_ = maxcmpts;\n\tfor (cmptno = image->numcmpts_; cmptno < image->maxcmpts_; ++cmptno) {\n\t\timage->cmpts_[cmptno] = 0;\n\t}\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static int jas_iccprof_gettagtab(jas_stream_t *in, jas_icctagtab_t *tagtab)\n{\n\tint i;\n\tjas_icctagtabent_t *tagtabent;\n\n\tif (tagtab->ents) {\n\t\tjas_free(tagtab->ents);\n\t\ttagtab->ents = 0;\n\t}\n\tif (jas_iccgetuint32(in, &tagtab->numents))\n\t\tgoto error;\n\tif (!(tagtab->ents = jas_malloc(tagtab->numents *\n\t  sizeof(jas_icctagtabent_t))))\n\t\tgoto error;\n\ttagtabent = tagtab->ents;\n\tfor (i = 0; i < JAS_CAST(long, tagtab->numents); ++i) {\n\t\tif (jas_iccgetuint32(in, &tagtabent->tag) ||\n\t\tjas_iccgetuint32(in, &tagtabent->off) ||\n\t\tjas_iccgetuint32(in, &tagtabent->len))\n\t\t\tgoto error;\n\t\t++tagtabent;\n\t}\n\treturn 0;\nerror:\n\tif (tagtab->ents) {\n\t\tjas_free(tagtab->ents);\n\t\ttagtab->ents = 0;\n\t}\n\treturn -1;\n}",
        "target": 1
    },
    {
        "func": "static int jp2_cmap_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_cmap_t *cmap = &box->data.cmap;\n\tjp2_cmapent_t *ent;\n\tunsigned int i;\n\n\tcmap->numchans = (box->datalen) / 4;\n\tif (!(cmap->ents = jas_malloc(cmap->numchans * sizeof(jp2_cmapent_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < cmap->numchans; ++i) {\n\t\tent = &cmap->ents[i];\n\t\tif (jp2_getuint16(in, &ent->cmptno) ||\n\t\t  jp2_getuint8(in, &ent->map) ||\n\t\t  jp2_getuint8(in, &ent->pcol)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\t\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "jpc_mqdec_t *jpc_mqdec_create(int maxctxs, jas_stream_t *in)\n{\n\tjpc_mqdec_t *mqdec;\n\n\t/* There must be at least one context. */\n\tassert(maxctxs > 0);\n\n\t/* Allocate memory for the MQ decoder. */\n\tif (!(mqdec = jas_malloc(sizeof(jpc_mqdec_t)))) {\n\t\tgoto error;\n\t}\n\tmqdec->in = in;\n\tmqdec->maxctxs = maxctxs;\n\t/* Allocate memory for the per-context state information. */\n\tif (!(mqdec->ctxs = jas_malloc(mqdec->maxctxs * sizeof(jpc_mqstate_t *)))) {\n\t\tgoto error;\n\t}\n\t/* Set the current context to the first context. */\n\tmqdec->curctx = mqdec->ctxs;\n\n\t/* If an input stream has been associated with the MQ decoder,\n\t  initialize the decoder state from the stream. */\n\tif (mqdec->in) {\n\t\tjpc_mqdec_init(mqdec);\n\t}\n\t/* Initialize the per-context state information. */\n\tjpc_mqdec_setctxs(mqdec, 0, 0);\n\n\treturn mqdec;\n\nerror:\n\t/* Oops...  Something has gone wrong. */\n\tif (mqdec) {\n\t\tjpc_mqdec_destroy(mqdec);\n\t}\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static bmp_info_t *bmp_getinfo(jas_stream_t *in)\n{\n\tbmp_info_t *info;\n\tint i;\n\tbmp_palent_t *palent;\n\n\tif (!(info = bmp_info_create())) {\n\t\treturn 0;\n\t}\n\n\tif (bmp_getint32(in, &info->len) || info->len != 40 ||\n\t  bmp_getint32(in, &info->width) || bmp_getint32(in, &info->height) ||\n\t  bmp_getint16(in, &info->numplanes) ||\n\t  bmp_getint16(in, &info->depth) || bmp_getint32(in, &info->enctype) ||\n\t  bmp_getint32(in, &info->siz) ||\n\t  bmp_getint32(in, &info->hres) || bmp_getint32(in, &info->vres) ||\n\t  bmp_getint32(in, &info->numcolors) ||\n\t  bmp_getint32(in, &info->mincolors)) {\n\t\tbmp_info_destroy(info);\n\t\treturn 0;\n\t}\n\n\tif (info->height < 0) {\n\t\tinfo->topdown = 1;\n\t\tinfo->height = -info->height;\n\t} else {\n\t\tinfo->topdown = 0;\n\t}\n\n\tif (info->width <= 0 || info->height <= 0 || info->numplanes <= 0 ||\n\t  info->depth <= 0  || info->numcolors < 0 || info->mincolors < 0) {\n\t\tbmp_info_destroy(info);\n\t\treturn 0;\n\t}\n\n\tif (info->enctype != BMP_ENC_RGB) {\n\t\tjas_eprintf(\"unsupported BMP encoding\\n\");\n\t\tbmp_info_destroy(info);\n\t\treturn 0;\n\t}\n\n\tif (info->numcolors > 0) {\n\t\tif (!(info->palents = jas_malloc(info->numcolors *\n\t\t  sizeof(bmp_palent_t)))) {\n\t\t\tbmp_info_destroy(info);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tinfo->palents = 0;\n\t}\n\n\tfor (i = 0; i < info->numcolors; ++i) {\n\t\tpalent = &info->palents[i];\n\t\tif ((palent->blu = jas_stream_getc(in)) == EOF ||\n\t\t  (palent->grn = jas_stream_getc(in)) == EOF ||\n\t\t  (palent->red = jas_stream_getc(in)) == EOF ||\n\t\t  (palent->res = jas_stream_getc(in)) == EOF) {\n\t\t\tbmp_info_destroy(info);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn info;\n}",
        "target": 1
    },
    {
        "func": "void *jas_realloc(void *ptr, size_t size)\n{\n\treturn realloc(ptr, size);\n}",
        "target": 1
    },
    {
        "func": "static int jas_icclut8_input(jas_iccattrval_t *attrval, jas_stream_t *in,\n  int cnt)\n{\n\tint i;\n\tint j;\n\tint clutsize;\n\tjas_icclut8_t *lut8 = &attrval->data.lut8;\n\tlut8->clut = 0;\n\tlut8->intabs = 0;\n\tlut8->intabsbuf = 0;\n\tlut8->outtabs = 0;\n\tlut8->outtabsbuf = 0;\n\tif (jas_iccgetuint8(in, &lut8->numinchans) ||\n\t  jas_iccgetuint8(in, &lut8->numoutchans) ||\n\t  jas_iccgetuint8(in, &lut8->clutlen) ||\n\t  jas_stream_getc(in) == EOF)\n\t\tgoto error;\n\tfor (i = 0; i < 3; ++i) {\n\t\tfor (j = 0; j < 3; ++j) {\n\t\t\tif (jas_iccgetsint32(in, &lut8->e[i][j]))\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\tif (jas_iccgetuint16(in, &lut8->numintabents) ||\n\t  jas_iccgetuint16(in, &lut8->numouttabents))\n\t\tgoto error;\n\tclutsize = jas_iccpowi(lut8->clutlen, lut8->numinchans) * lut8->numoutchans;\n\tif (!(lut8->clut = jas_malloc(clutsize * sizeof(jas_iccuint8_t))) ||\n\t  !(lut8->intabsbuf = jas_malloc(lut8->numinchans *\n\t  lut8->numintabents * sizeof(jas_iccuint8_t))) ||\n\t  !(lut8->intabs = jas_malloc(lut8->numinchans *\n\t  sizeof(jas_iccuint8_t *))))\n\t\tgoto error;\n\tfor (i = 0; i < lut8->numinchans; ++i)\n\t\tlut8->intabs[i] = &lut8->intabsbuf[i * lut8->numintabents];\n\tif (!(lut8->outtabsbuf = jas_malloc(lut8->numoutchans *\n\t  lut8->numouttabents * sizeof(jas_iccuint8_t))) ||\n\t  !(lut8->outtabs = jas_malloc(lut8->numoutchans *\n\t  sizeof(jas_iccuint8_t *))))\n\t\tgoto error;\n\tfor (i = 0; i < lut8->numoutchans; ++i)\n\t\tlut8->outtabs[i] = &lut8->outtabsbuf[i * lut8->numouttabents];\n\tfor (i = 0; i < lut8->numinchans; ++i) {\n\t\tfor (j = 0; j < JAS_CAST(int, lut8->numintabents); ++j) {\n\t\t\tif (jas_iccgetuint8(in, &lut8->intabs[i][j]))\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\tfor (i = 0; i < lut8->numoutchans; ++i) {\n\t\tfor (j = 0; j < JAS_CAST(int, lut8->numouttabents); ++j) {\n\t\t\tif (jas_iccgetuint8(in, &lut8->outtabs[i][j]))\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\tfor (i = 0; i < clutsize; ++i) {\n\t\tif (jas_iccgetuint8(in, &lut8->clut[i]))\n\t\t\tgoto error;\n\t}\n\tif (JAS_CAST(int, 44 + lut8->numinchans * lut8->numintabents +\n\t  lut8->numoutchans * lut8->numouttabents +\n\t  jas_iccpowi(lut8->clutlen, lut8->numinchans) * lut8->numoutchans) !=\n\t  cnt)\n\t\tgoto error;\n\treturn 0;\nerror:\n\tjas_icclut8_destroy(attrval);\n\treturn -1;\n}",
        "target": 1
    },
    {
        "func": "static int jpc_enc_encodemainhdr(jpc_enc_t *enc)\n{\n\tjpc_siz_t *siz;\n\tjpc_cod_t *cod;\n\tjpc_qcd_t *qcd;\n\tint i;\nlong startoff;\nlong mainhdrlen;\n\tjpc_enc_cp_t *cp;\n\tjpc_qcc_t *qcc;\n\tjpc_enc_tccp_t *tccp;\n\tuint_fast16_t cmptno;\n\tjpc_tsfb_band_t bandinfos[JPC_MAXBANDS];\n\tjpc_fix_t mctsynweight;\n\tjpc_enc_tcp_t *tcp;\n\tjpc_tsfb_t *tsfb;\n\tjpc_tsfb_band_t *bandinfo;\n\tuint_fast16_t numbands;\n\tuint_fast16_t bandno;\n\tuint_fast16_t rlvlno;\n\tuint_fast16_t analgain;\n\tjpc_fix_t absstepsize;\n\tchar buf[1024];\n\tjpc_com_t *com;\n\n\tcp = enc->cp;\n\nstartoff = jas_stream_getrwcount(enc->out);\n\n\t/* Write SOC marker segment. */\n\tif (!(enc->mrk = jpc_ms_create(JPC_MS_SOC))) {\n\t\treturn -1;\n\t}\n\tif (jpc_putms(enc->out, enc->cstate, enc->mrk)) {\n\t\tjas_eprintf(\"cannot write SOC marker\\n\");\n\t\treturn -1;\n\t}\n\tjpc_ms_destroy(enc->mrk);\n\tenc->mrk = 0;\n\n\t/* Write SIZ marker segment. */\n\tif (!(enc->mrk = jpc_ms_create(JPC_MS_SIZ))) {\n\t\treturn -1;\n\t}\n\tsiz = &enc->mrk->parms.siz;\n\tsiz->caps = 0;\n\tsiz->xoff = cp->imgareatlx;\n\tsiz->yoff = cp->imgareatly;\n\tsiz->width = cp->refgrdwidth;\n\tsiz->height = cp->refgrdheight;\n\tsiz->tilexoff = cp->tilegrdoffx;\n\tsiz->tileyoff = cp->tilegrdoffy;\n\tsiz->tilewidth = cp->tilewidth;\n\tsiz->tileheight = cp->tileheight;\n\tsiz->numcomps = cp->numcmpts;\n\tsiz->comps = jas_malloc(siz->numcomps * sizeof(jpc_sizcomp_t));\n\tassert(siz->comps);\n\tfor (i = 0; i < JAS_CAST(int, cp->numcmpts); ++i) {\n\t\tsiz->comps[i].prec = cp->ccps[i].prec;\n\t\tsiz->comps[i].sgnd = cp->ccps[i].sgnd;\n\t\tsiz->comps[i].hsamp = cp->ccps[i].sampgrdstepx;\n\t\tsiz->comps[i].vsamp = cp->ccps[i].sampgrdstepy;\n\t}\n\tif (jpc_putms(enc->out, enc->cstate, enc->mrk)) {\n\t\tjas_eprintf(\"cannot write SIZ marker\\n\");\n\t\treturn -1;\n\t}\n\tjpc_ms_destroy(enc->mrk);\n\tenc->mrk = 0;\n\n\tif (!(enc->mrk = jpc_ms_create(JPC_MS_COM))) {\n\t\treturn -1;\n\t}\n\tsprintf(buf, \"Creator: JasPer Version %s\", jas_getversion());\n\tcom = &enc->mrk->parms.com;\n\tcom->len = strlen(buf);\n\tcom->regid = JPC_COM_LATIN;\n\tif (!(com->data = JAS_CAST(uchar *, jas_strdup(buf)))) {\n\t\tabort();\n\t}\n\tif (jpc_putms(enc->out, enc->cstate, enc->mrk)) {\n\t\tjas_eprintf(\"cannot write COM marker\\n\");\n\t\treturn -1;\n\t}\n\tjpc_ms_destroy(enc->mrk);\n\tenc->mrk = 0;\n\n#if 0\n\tif (!(enc->mrk = jpc_ms_create(JPC_MS_CRG))) {\n\t\treturn -1;\n\t}\n\tcrg = &enc->mrk->parms.crg;\n\tcrg->comps = jas_malloc(crg->numcomps * sizeof(jpc_crgcomp_t));\n\tif (jpc_putms(enc->out, enc->cstate, enc->mrk)) {\n\t\tjas_eprintf(\"cannot write CRG marker\\n\");\n\t\treturn -1;\n\t}\n\tjpc_ms_destroy(enc->mrk);\n\tenc->mrk = 0;\n#endif\n\n\ttcp = &cp->tcp;\n\ttccp = &cp->tccp;\n\tfor (cmptno = 0; cmptno < cp->numcmpts; ++cmptno) {\n\t\ttsfb = jpc_cod_gettsfb(tccp->qmfbid, tccp->maxrlvls - 1);\n\t\tjpc_tsfb_getbands(tsfb, 0, 0, 1 << tccp->maxrlvls, 1 << tccp->maxrlvls,\n\t\t  bandinfos);\n\t\tjpc_tsfb_destroy(tsfb);\n\t\tmctsynweight = jpc_mct_getsynweight(tcp->mctid, cmptno);\n\t\tnumbands = 3 * tccp->maxrlvls - 2;\n\t\tfor (bandno = 0, bandinfo = bandinfos; bandno < numbands;\n\t\t  ++bandno, ++bandinfo) {\n\t\t\trlvlno = (bandno) ? ((bandno - 1) / 3 + 1) : 0;\n\t\t\tanalgain = JPC_NOMINALGAIN(tccp->qmfbid, tccp->maxrlvls,\n\t\t\t  rlvlno, bandinfo->orient);\n\t\t\tif (!tcp->intmode) {\n\t\t\t\tabsstepsize = jpc_fix_div(jpc_inttofix(1 <<\n\t\t\t\t  (analgain + 1)), bandinfo->synenergywt);\n\t\t\t} else {\n\t\t\t\tabsstepsize = jpc_inttofix(1);\n\t\t\t}\t\n\t\t\tcp->ccps[cmptno].stepsizes[bandno] =\n\t\t\t  jpc_abstorelstepsize(absstepsize,\n\t\t\t  cp->ccps[cmptno].prec + analgain);\n\t\t}\n\t\tcp->ccps[cmptno].numstepsizes = numbands;\n\t}\n\n\tif (!(enc->mrk = jpc_ms_create(JPC_MS_COD))) {\n\t\treturn -1;\n\t}\n\tcod = &enc->mrk->parms.cod;\n\tcod->csty = cp->tccp.csty | cp->tcp.csty;\n\tcod->compparms.csty = cp->tccp.csty | cp->tcp.csty;\n\tcod->compparms.numdlvls = cp->tccp.maxrlvls - 1;\n\tcod->compparms.numrlvls = cp->tccp.maxrlvls;\n\tcod->prg = cp->tcp.prg;\n\tcod->numlyrs = cp->tcp.numlyrs;\n\tcod->compparms.cblkwidthval = JPC_COX_CBLKSIZEEXPN(cp->tccp.cblkwidthexpn);\n\tcod->compparms.cblkheightval = JPC_COX_CBLKSIZEEXPN(cp->tccp.cblkheightexpn);\n\tcod->compparms.cblksty = cp->tccp.cblksty;\n\tcod->compparms.qmfbid = cp->tccp.qmfbid;\n\tcod->mctrans = (cp->tcp.mctid != JPC_MCT_NONE);\n\tif (tccp->csty & JPC_COX_PRT) {\n\t\tfor (rlvlno = 0; rlvlno < tccp->maxrlvls; ++rlvlno) {\n\t\t\tcod->compparms.rlvls[rlvlno].parwidthval = tccp->prcwidthexpns[rlvlno];\n\t\t\tcod->compparms.rlvls[rlvlno].parheightval = tccp->prcheightexpns[rlvlno];\n\t\t}\n\t}\n\tif (jpc_putms(enc->out, enc->cstate, enc->mrk)) {\n\t\tjas_eprintf(\"cannot write COD marker\\n\");\n\t\treturn -1;\n\t}\n\tjpc_ms_destroy(enc->mrk);\n\tenc->mrk = 0;\n\n\tif (!(enc->mrk = jpc_ms_create(JPC_MS_QCD))) {\n\t\treturn -1;\n\t}\n\tqcd = &enc->mrk->parms.qcd;\n\tqcd->compparms.qntsty = (tccp->qmfbid == JPC_COX_INS) ?\n\t  JPC_QCX_SEQNT : JPC_QCX_NOQNT;\n\tqcd->compparms.numstepsizes = cp->ccps[0].numstepsizes;\n\tqcd->compparms.numguard = cp->tccp.numgbits;\n\tqcd->compparms.stepsizes = cp->ccps[0].stepsizes;\n\tif (jpc_putms(enc->out, enc->cstate, enc->mrk)) {\n\t\treturn -1;\n\t}\n\t/* We do not want the step size array to be freed! */\n\tqcd->compparms.stepsizes = 0;\n\tjpc_ms_destroy(enc->mrk);\n\tenc->mrk = 0;\n\n\ttccp = &cp->tccp;\n\tfor (cmptno = 1; cmptno < cp->numcmpts; ++cmptno) {\n\t\tif (!(enc->mrk = jpc_ms_create(JPC_MS_QCC))) {\n\t\t\treturn -1;\n\t\t}\n\t\tqcc = &enc->mrk->parms.qcc;\n\t\tqcc->compno = cmptno;\n\t\tqcc->compparms.qntsty = (tccp->qmfbid == JPC_COX_INS) ?\n\t\t  JPC_QCX_SEQNT : JPC_QCX_NOQNT;\n\t\tqcc->compparms.numstepsizes = cp->ccps[cmptno].numstepsizes;\n\t\tqcc->compparms.numguard = cp->tccp.numgbits;\n\t\tqcc->compparms.stepsizes = cp->ccps[cmptno].stepsizes;\n\t\tif (jpc_putms(enc->out, enc->cstate, enc->mrk)) {\n\t\t\treturn -1;\n\t\t}\n\t\t/* We do not want the step size array to be freed! */\n\t\tqcc->compparms.stepsizes = 0;\n\t\tjpc_ms_destroy(enc->mrk);\n\t\tenc->mrk = 0;\n\t}\n\n#define MAINTLRLEN\t2\n\tmainhdrlen = jas_stream_getrwcount(enc->out) - startoff;\n\tenc->len += mainhdrlen;\n\tif (enc->cp->totalsize != UINT_FAST32_MAX) {\n\t\tuint_fast32_t overhead;\n\t\toverhead = mainhdrlen + MAINTLRLEN;\n\t\tenc->mainbodysize = (enc->cp->totalsize >= overhead) ?\n\t\t  (enc->cp->totalsize - overhead) : 0;\n\t} else {\n\t\tenc->mainbodysize = UINT_FAST32_MAX;\n\t}\n\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "int jas_iccprof_save(jas_iccprof_t *prof, jas_stream_t *out)\n{\n\tlong curoff;\n\tlong reloff;\n\tlong newoff;\n\tint i;\n\tint j;\n\tjas_icctagtabent_t *tagtabent;\n\tjas_icctagtabent_t *sharedtagtabent;\n\tjas_icctagtabent_t *tmptagtabent;\n\tjas_iccuint32_t attrname;\n\tjas_iccattrval_t *attrval;\n\tjas_icctagtab_t *tagtab;\n\n\ttagtab = &prof->tagtab;\n\tif (!(tagtab->ents = jas_malloc(prof->attrtab->numattrs *\n\t  sizeof(jas_icctagtabent_t))))\n\t\tgoto error;\n\ttagtab->numents = prof->attrtab->numattrs;\n\tcuroff = JAS_ICC_HDRLEN + 4 + 12 * tagtab->numents;\n\tfor (i = 0; i < JAS_CAST(int, tagtab->numents); ++i) {\n\t\ttagtabent = &tagtab->ents[i];\n\t\tif (jas_iccattrtab_get(prof->attrtab, i, &attrname, &attrval))\n\t\t\tgoto error;\n\t\tassert(attrval->ops->output);\n\t\ttagtabent->tag = attrname;\n\t\ttagtabent->data = &attrval->data;\n\t\tsharedtagtabent = 0;\n\t\tfor (j = 0; j < i; ++j) {\n\t\t\ttmptagtabent = &tagtab->ents[j];\n\t\t\tif (tagtabent->data == tmptagtabent->data) {\n\t\t\t\tsharedtagtabent = tmptagtabent;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (sharedtagtabent) {\n\t\t\ttagtabent->off = sharedtagtabent->off;\n\t\t\ttagtabent->len = sharedtagtabent->len;\n\t\t\ttagtabent->first = sharedtagtabent;\n\t\t} else {\n\t\t\ttagtabent->off = curoff;\n\t\t\ttagtabent->len = (*attrval->ops->getsize)(attrval) + 8;\n\t\t\ttagtabent->first = 0;\n\t\t\tif (i < JAS_CAST(int, tagtab->numents - 1)) {\n\t\t\t\tcuroff = jas_iccpadtomult(curoff + tagtabent->len, 4);\n\t\t\t} else {\n\t\t\t\tcuroff += tagtabent->len;\n\t\t\t}\n\t\t}\n\t\tjas_iccattrval_destroy(attrval);\n\t}\n\tprof->hdr.size = curoff;\n\tif (jas_iccprof_writehdr(out, &prof->hdr))\n\t\tgoto error;\n\tif (jas_iccprof_puttagtab(out, &prof->tagtab))\n\t\tgoto error;\n\tcuroff = JAS_ICC_HDRLEN + 4 + 12 * tagtab->numents;\n\tfor (i = 0; i < JAS_CAST(int, tagtab->numents);) {\n\t\ttagtabent = &tagtab->ents[i];\n\t\tassert(curoff == JAS_CAST(long, tagtabent->off));\n\t\tif (jas_iccattrtab_get(prof->attrtab, i, &attrname, &attrval))\n\t\t\tgoto error;\n\t\tif (jas_iccputuint32(out, attrval->type) || jas_stream_pad(out,\n\t\t  4, 0) != 4)\n\t\t\tgoto error;\n\t\tif ((*attrval->ops->output)(attrval, out))\n\t\t\tgoto error;\n\t\tjas_iccattrval_destroy(attrval);\n\t\tcuroff += tagtabent->len;\n\t\t++i;\n\t\twhile (i < JAS_CAST(int, tagtab->numents) &&\n\t\t  tagtab->ents[i].first)\n\t\t\t++i;\n\t\tnewoff = (i < JAS_CAST(int, tagtab->numents)) ?\n\t\t  tagtab->ents[i].off : prof->hdr.size;\n\t\treloff = newoff - curoff;\n\t\tassert(reloff >= 0);\n\t\tif (reloff > 0) {\n\t\t\tif (jas_stream_pad(out, reloff, 0) != reloff)\n\t\t\t\tgoto error;\n\t\t\tcuroff += reloff;\n\t\t}\n\t}\t\n\treturn 0;\nerror:\n\t/* XXX - need to free some resources here */\n\treturn -1;\n}",
        "target": 1
    },
    {
        "func": "void jpc_qmfb_split_colgrp(jpc_fix_t *a, int numrows, int stride,\n  int parity)\n{\n\n\tint bufsize = JPC_CEILDIVPOW2(numrows, 1);\n\tjpc_fix_t splitbuf[QMFB_SPLITBUFSIZE * JPC_QMFB_COLGRPSIZE];\n\tjpc_fix_t *buf = splitbuf;\n\tjpc_fix_t *srcptr;\n\tjpc_fix_t *dstptr;\n\tregister jpc_fix_t *srcptr2;\n\tregister jpc_fix_t *dstptr2;\n\tregister int n;\n\tregister int i;\n\tint m;\n\tint hstartcol;\n\n\t/* Get a buffer. */\n\tif (bufsize > QMFB_SPLITBUFSIZE) {\n\t\tif (!(buf = jas_malloc(bufsize * sizeof(jpc_fix_t)))) {\n\t\t\t/* We have no choice but to commit suicide in this case. */\n\t\t\tabort();\n\t\t}\n\t}\n\n\tif (numrows >= 2) {\n\t\thstartcol = (numrows + 1 - parity) >> 1;\n\t\tm = (parity) ? hstartcol : (numrows - hstartcol);\n\t\t/* Save the samples destined for the highpass channel. */\n\t\tn = m;\n\t\tdstptr = buf;\n\t\tsrcptr = &a[(1 - parity) * stride];\n\t\twhile (n-- > 0) {\n\t\t\tdstptr2 = dstptr;\n\t\t\tsrcptr2 = srcptr;\n\t\t\tfor (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {\n\t\t\t\t*dstptr2 = *srcptr2;\n\t\t\t\t++dstptr2;\n\t\t\t\t++srcptr2;\n\t\t\t}\n\t\t\tdstptr += JPC_QMFB_COLGRPSIZE;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\t/* Copy the appropriate samples into the lowpass channel. */\n\t\tdstptr = &a[(1 - parity) * stride];\n\t\tsrcptr = &a[(2 - parity) * stride];\n\t\tn = numrows - m - (!parity);\n\t\twhile (n-- > 0) {\n\t\t\tdstptr2 = dstptr;\n\t\t\tsrcptr2 = srcptr;\n\t\t\tfor (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {\n\t\t\t\t*dstptr2 = *srcptr2;\n\t\t\t\t++dstptr2;\n\t\t\t\t++srcptr2;\n\t\t\t}\n\t\t\tdstptr += stride;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\t/* Copy the saved samples into the highpass channel. */\n\t\tdstptr = &a[hstartcol * stride];\n\t\tsrcptr = buf;\n\t\tn = m;\n\t\twhile (n-- > 0) {\n\t\t\tdstptr2 = dstptr;\n\t\t\tsrcptr2 = srcptr;\n\t\t\tfor (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {\n\t\t\t\t*dstptr2 = *srcptr2;\n\t\t\t\t++dstptr2;\n\t\t\t\t++srcptr2;\n\t\t\t}\n\t\t\tdstptr += stride;\n\t\t\tsrcptr += JPC_QMFB_COLGRPSIZE;\n\t\t}\n\t}\n\n\t/* If the split buffer was allocated on the heap, free this memory. */\n\tif (buf != splitbuf) {\n\t\tjas_free(buf);\n\t}\n\n}",
        "target": 1
    },
    {
        "func": "static int jas_cmshapmatlut_set(jas_cmshapmatlut_t *lut, jas_icccurv_t *curv)\n{\n\tjas_cmreal_t gamma;\n\tint i;\n\tgamma = 0;\n\tjas_cmshapmatlut_cleanup(lut);\n\tif (curv->numents == 0) {\n\t\tlut->size = 2;\n\t\tif (!(lut->data = jas_malloc(lut->size * sizeof(jas_cmreal_t))))\n\t\t\tgoto error;\n\t\tlut->data[0] = 0.0;\n\t\tlut->data[1] = 1.0;\n\t} else if (curv->numents == 1) {\n\t\tlut->size = 256;\n\t\tif (!(lut->data = jas_malloc(lut->size * sizeof(jas_cmreal_t))))\n\t\t\tgoto error;\n\t\tgamma = curv->ents[0] / 256.0;\n\t\tfor (i = 0; i < lut->size; ++i) {\n\t\t\tlut->data[i] = gammafn(i / (double) (lut->size - 1), gamma);\n\t\t}\n\t} else {\n\t\tlut->size = curv->numents;\n\t\tif (!(lut->data = jas_malloc(lut->size * sizeof(jas_cmreal_t))))\n\t\t\tgoto error;\n\t\tfor (i = 0; i < lut->size; ++i) {\n\t\t\tlut->data[i] = curv->ents[i] / 65535.0;\n\t\t}\n\t}\n\treturn 0;\nerror:\n\treturn -1;\n}",
        "target": 1
    },
    {
        "func": "static int mem_resize(jas_stream_memobj_t *m, int bufsize)\n{\n\tunsigned char *buf;\n\n\tassert(m->buf_);\n\tif (!(buf = jas_realloc(m->buf_, bufsize * sizeof(unsigned char)))) {\n\t\treturn -1;\n\t}\n\tm->buf_ = buf;\n\tm->bufsize_ = bufsize;\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static int jp2_colr_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_colr_t *colr = &box->data.colr;\n\tcolr->csid = 0;\n\tcolr->iccp = 0;\n\tcolr->iccplen = 0;\n\n\tif (jp2_getuint8(in, &colr->method) || jp2_getuint8(in, &colr->pri) ||\n\t  jp2_getuint8(in, &colr->approx)) {\n\t\treturn -1;\n\t}\n\tswitch (colr->method) {\n\tcase JP2_COLR_ENUM:\n\t\tif (jp2_getuint32(in, &colr->csid)) {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tcase JP2_COLR_ICC:\n\t\tcolr->iccplen = box->datalen - 3;\n\t\tif (!(colr->iccp = jas_malloc(colr->iccplen * sizeof(uint_fast8_t)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (jas_stream_read(in, colr->iccp, colr->iccplen) != colr->iccplen) {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\t}\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "jpc_mqenc_t *jpc_mqenc_create(int maxctxs, jas_stream_t *out)\n{\n\tjpc_mqenc_t *mqenc;\n\n\t/* Allocate memory for the MQ encoder. */\n\tif (!(mqenc = jas_malloc(sizeof(jpc_mqenc_t)))) {\n\t\tgoto error;\n\t}\n\tmqenc->out = out;\n\tmqenc->maxctxs = maxctxs;\n\n\t/* Allocate memory for the per-context state information. */\n\tif (!(mqenc->ctxs = jas_malloc(mqenc->maxctxs * sizeof(jpc_mqstate_t *)))) {\n\t\tgoto error;\n\t}\n\n\t/* Set the current context to the first one. */\n\tmqenc->curctx = mqenc->ctxs;\n\n\tjpc_mqenc_init(mqenc);\n\n\t/* Initialize the per-context state information to something sane. */\n\tjpc_mqenc_setctxs(mqenc, 0, 0);\n\n\treturn mqenc;\n\nerror:\n\tif (mqenc) {\n\t\tjpc_mqenc_destroy(mqenc);\n\t}\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static jpc_enc_rlvl_t *rlvl_create(jpc_enc_rlvl_t *rlvl, jpc_enc_cp_t *cp,\n  jpc_enc_tcmpt_t *tcmpt, jpc_tsfb_band_t *bandinfos)\n{\n\tuint_fast16_t rlvlno;\n\tuint_fast32_t tlprctlx;\n\tuint_fast32_t tlprctly;\n\tuint_fast32_t brprcbrx;\n\tuint_fast32_t brprcbry;\n\tuint_fast16_t bandno;\n\tjpc_enc_band_t *band;\n\n\t/* Deduce the resolution level. */\n\trlvlno = rlvl - tcmpt->rlvls;\n\n\t/* Initialize members required for error recovery. */\n\trlvl->bands = 0;\n\trlvl->tcmpt = tcmpt;\n\n\t/* Compute the coordinates of the top-left and bottom-right\n\t  corners of the tile-component at this resolution. */\n\trlvl->tlx = JPC_CEILDIVPOW2(jas_seq2d_xstart(tcmpt->data), tcmpt->numrlvls -\n\t  1 - rlvlno);\n\trlvl->tly = JPC_CEILDIVPOW2(jas_seq2d_ystart(tcmpt->data), tcmpt->numrlvls -\n\t  1 - rlvlno);\n\trlvl->brx = JPC_CEILDIVPOW2(jas_seq2d_xend(tcmpt->data), tcmpt->numrlvls -\n\t  1 - rlvlno);\n\trlvl->bry = JPC_CEILDIVPOW2(jas_seq2d_yend(tcmpt->data), tcmpt->numrlvls -\n\t  1 - rlvlno);\n\n\tif (rlvl->tlx >= rlvl->brx || rlvl->tly >= rlvl->bry) {\n\t\trlvl->numhprcs = 0;\n\t\trlvl->numvprcs = 0;\n\t\trlvl->numprcs = 0;\n\t\treturn rlvl;\n\t}\n\n\trlvl->numbands = (!rlvlno) ? 1 : 3;\n\trlvl->prcwidthexpn = cp->tccp.prcwidthexpns[rlvlno];\n\trlvl->prcheightexpn = cp->tccp.prcheightexpns[rlvlno];\n\tif (!rlvlno) {\n\t\trlvl->cbgwidthexpn = rlvl->prcwidthexpn;\n\t\trlvl->cbgheightexpn = rlvl->prcheightexpn;\n\t} else {\n\t\trlvl->cbgwidthexpn = rlvl->prcwidthexpn - 1;\n\t\trlvl->cbgheightexpn = rlvl->prcheightexpn - 1;\n\t}\n\trlvl->cblkwidthexpn = JAS_MIN(cp->tccp.cblkwidthexpn, rlvl->cbgwidthexpn);\n\trlvl->cblkheightexpn = JAS_MIN(cp->tccp.cblkheightexpn, rlvl->cbgheightexpn);\n\n\t/* Compute the number of precincts. */\n\ttlprctlx = JPC_FLOORTOMULTPOW2(rlvl->tlx, rlvl->prcwidthexpn);\n\ttlprctly = JPC_FLOORTOMULTPOW2(rlvl->tly, rlvl->prcheightexpn);\n\tbrprcbrx = JPC_CEILTOMULTPOW2(rlvl->brx, rlvl->prcwidthexpn);\n\tbrprcbry = JPC_CEILTOMULTPOW2(rlvl->bry, rlvl->prcheightexpn);\n\trlvl->numhprcs = JPC_FLOORDIVPOW2(brprcbrx - tlprctlx, rlvl->prcwidthexpn);\n\trlvl->numvprcs = JPC_FLOORDIVPOW2(brprcbry - tlprctly, rlvl->prcheightexpn);\n\trlvl->numprcs = rlvl->numhprcs * rlvl->numvprcs;\n\n\tif (!(rlvl->bands = jas_malloc(rlvl->numbands * sizeof(jpc_enc_band_t)))) {\n\t\tgoto error;\n\t}\n\tfor (bandno = 0, band = rlvl->bands; bandno < rlvl->numbands;\n\t  ++bandno, ++band) {\n\t\tband->prcs = 0;\n\t\tband->data = 0;\n\t\tband->rlvl = rlvl;\n\t}\n\tfor (bandno = 0, band = rlvl->bands; bandno < rlvl->numbands;\n\t  ++bandno, ++band) {\n\t\tif (!band_create(band, cp, rlvl, bandinfos)) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\treturn rlvl;\nerror:\n\n\trlvl_destroy(rlvl);\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "void *jas_malloc(size_t size)\n{\n#if defined(MEMALLOC_ALIGN2)\n\tvoid *ptr;\nabort();\n\tif (posix_memalign(&ptr, MEMALLOC_ALIGNMENT, size)) {\n\t\treturn 0;\n\t}\n\treturn ptr;\n#endif\n\treturn malloc(size);\n}",
        "target": 1
    },
    {
        "func": "jpc_pi_t *jpc_enc_pi_create(jpc_enc_cp_t *cp, jpc_enc_tile_t *tile)\n{\n\tjpc_pi_t *pi;\n\tint compno;\n\tjpc_picomp_t *picomp;\n\tjpc_pirlvl_t *pirlvl;\n\tjpc_enc_tcmpt_t *tcomp;\n\tint rlvlno;\n\tjpc_enc_rlvl_t *rlvl;\n\tint prcno;\n\tint *prclyrno;\n\n\tif (!(pi = jpc_pi_create0())) {\n\t\treturn 0;\n\t}\n\tpi->pktno = -1;\n\tpi->numcomps = cp->numcmpts;\n\tif (!(pi->picomps = jas_malloc(pi->numcomps * sizeof(jpc_picomp_t)))) {\n\t\tjpc_pi_destroy(pi);\n\t\treturn 0;\n\t}\n\tfor (compno = 0, picomp = pi->picomps; compno < pi->numcomps; ++compno,\n\t  ++picomp) {\n\t\tpicomp->pirlvls = 0;\n\t}\n\n\tfor (compno = 0, tcomp = tile->tcmpts, picomp = pi->picomps;\n\t  compno < pi->numcomps; ++compno, ++tcomp, ++picomp) {\n\t\tpicomp->numrlvls = tcomp->numrlvls;\n\t\tif (!(picomp->pirlvls = jas_malloc(picomp->numrlvls *\n\t\t  sizeof(jpc_pirlvl_t)))) {\n\t\t\tjpc_pi_destroy(pi);\n\t\t\treturn 0;\n\t\t}\n\t\tfor (rlvlno = 0, pirlvl = picomp->pirlvls; rlvlno <\n\t\t  picomp->numrlvls; ++rlvlno, ++pirlvl) {\n\t\t\tpirlvl->prclyrnos = 0;\n\t\t}\n\t\tfor (rlvlno = 0, pirlvl = picomp->pirlvls, rlvl = tcomp->rlvls;\n\t\t  rlvlno < picomp->numrlvls; ++rlvlno, ++pirlvl, ++rlvl) {\n/* XXX sizeof(long) should be sizeof different type */\n\t\t\tpirlvl->numprcs = rlvl->numprcs;\n\t\t\tif (rlvl->numprcs) {\n\t\t\t\tif (!(pirlvl->prclyrnos = jas_malloc(pirlvl->numprcs *\n\t\t\t\t  sizeof(long)))) {\n\t\t\t\t\tjpc_pi_destroy(pi);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpirlvl->prclyrnos = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tpi->maxrlvls = 0;\n\tfor (compno = 0, tcomp = tile->tcmpts, picomp = pi->picomps;\n\t  compno < pi->numcomps; ++compno, ++tcomp, ++picomp) {\n\t\tpicomp->hsamp = cp->ccps[compno].sampgrdstepx;\n\t\tpicomp->vsamp = cp->ccps[compno].sampgrdstepy;\n\t\tfor (rlvlno = 0, pirlvl = picomp->pirlvls, rlvl = tcomp->rlvls;\n\t\t  rlvlno < picomp->numrlvls; ++rlvlno, ++pirlvl, ++rlvl) {\n\t\t\tpirlvl->prcwidthexpn = rlvl->prcwidthexpn;\n\t\t\tpirlvl->prcheightexpn = rlvl->prcheightexpn;\n\t\t\tfor (prcno = 0, prclyrno = pirlvl->prclyrnos;\n\t\t\t  prcno < pirlvl->numprcs; ++prcno, ++prclyrno) {\n\t\t\t\t*prclyrno = 0;\n\t\t\t}\n\t\t\tpirlvl->numhprcs = rlvl->numhprcs;\n\t\t}\n\t\tif (pi->maxrlvls < tcomp->numrlvls) {\n\t\t\tpi->maxrlvls = tcomp->numrlvls;\n\t\t}\n\t}\n\n\tpi->numlyrs = tile->numlyrs;\n\tpi->xstart = tile->tlx;\n\tpi->ystart = tile->tly;\n\tpi->xend = tile->brx;\n\tpi->yend = tile->bry;\n\n\tpi->picomp = 0;\n\tpi->pirlvl = 0;\n\tpi->x = 0;\n\tpi->y = 0;\n\tpi->compno = 0;\n\tpi->rlvlno = 0;\n\tpi->prcno = 0;\n\tpi->lyrno = 0;\n\tpi->xstep = 0;\n\tpi->ystep = 0;\n\n\tpi->pchgno = -1;\n\n\tpi->defaultpchg.prgord = tile->prg;\n\tpi->defaultpchg.compnostart = 0;\n\tpi->defaultpchg.compnoend = pi->numcomps;\n\tpi->defaultpchg.rlvlnostart = 0;\n\tpi->defaultpchg.rlvlnoend = pi->maxrlvls;\n\tpi->defaultpchg.lyrnoend = pi->numlyrs;\n\tpi->pchg = 0;\n\n\tpi->valid = 0;\n\n\treturn pi;\n}",
        "target": 1
    },
    {
        "func": "int jpc_atoaf(char *s, int *numvalues, double **values)\n{\n\tstatic char delim[] = \", \\t\\n\";\n\tchar buf[4096];\n\tint n;\n\tdouble *vs;\n\tchar *cp;\n\n\tstrncpy(buf, s, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = '\\0';\n\tn = 0;\n\tif ((cp = strtok(buf, delim))) {\n\t\t++n;\n\t\twhile ((cp = strtok(0, delim))) {\n\t\t\tif (cp != '\\0') {\n\t\t\t\t++n;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (n) {\n\t\tif (!(vs = jas_malloc(n * sizeof(double)))) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tstrncpy(buf, s, sizeof(buf));\n\t\tbuf[sizeof(buf) - 1] = '\\0';\n\t\tn = 0;\n\t\tif ((cp = strtok(buf, delim))) {\n\t\t\tvs[n] = atof(cp);\n\t\t\t++n;\n\t\t\twhile ((cp = strtok(0, delim))) {\n\t\t\t\tif (cp != '\\0') {\n\t\t\t\t\tvs[n] = atof(cp);\n\t\t\t\t\t++n;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tvs = 0;\n\t}\n\n\t*numvalues = n;\n\t*values = vs;\n\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "void jpc_qmfb_join_colres(jpc_fix_t *a, int numrows, int numcols,\n  int stride, int parity)\n{\n\n\tint bufsize = JPC_CEILDIVPOW2(numrows, 1);\n\tjpc_fix_t joinbuf[QMFB_JOINBUFSIZE * JPC_QMFB_COLGRPSIZE];\n\tjpc_fix_t *buf = joinbuf;\n\tjpc_fix_t *srcptr;\n\tjpc_fix_t *dstptr;\n\tregister jpc_fix_t *srcptr2;\n\tregister jpc_fix_t *dstptr2;\n\tregister int n;\n\tregister int i;\n\tint hstartcol;\n\n\t/* Allocate memory for the join buffer from the heap. */\n\tif (bufsize > QMFB_JOINBUFSIZE) {\n\t\tif (!(buf = jas_malloc(bufsize * numcols * sizeof(jpc_fix_t)))) {\n\t\t\t/* We have no choice but to commit suicide. */\n\t\t\tabort();\n\t\t}\n\t}\n\n\thstartcol = (numrows + 1 - parity) >> 1;\n\n\t/* Save the samples from the lowpass channel. */\n\tn = hstartcol;\n\tsrcptr = &a[0];\n\tdstptr = buf;\n\twhile (n-- > 0) {\n\t\tdstptr2 = dstptr;\n\t\tsrcptr2 = srcptr;\n\t\tfor (i = 0; i < numcols; ++i) {\n\t\t\t*dstptr2 = *srcptr2;\n\t\t\t++dstptr2;\n\t\t\t++srcptr2;\n\t\t}\n\t\tsrcptr += stride;\n\t\tdstptr += numcols;\n\t}\n\t/* Copy the samples from the highpass channel into place. */\n\tsrcptr = &a[hstartcol * stride];\n\tdstptr = &a[(1 - parity) * stride];\n\tn = numrows - hstartcol;\n\twhile (n-- > 0) {\n\t\tdstptr2 = dstptr;\n\t\tsrcptr2 = srcptr;\n\t\tfor (i = 0; i < numcols; ++i) {\n\t\t\t*dstptr2 = *srcptr2;\n\t\t\t++dstptr2;\n\t\t\t++srcptr2;\n\t\t}\n\t\tdstptr += 2 * stride;\n\t\tsrcptr += stride;\n\t}\n\t/* Copy the samples from the lowpass channel into place. */\n\tsrcptr = buf;\n\tdstptr = &a[parity * stride];\n\tn = hstartcol;\n\twhile (n-- > 0) {\n\t\tdstptr2 = dstptr;\n\t\tsrcptr2 = srcptr;\n\t\tfor (i = 0; i < numcols; ++i) {\n\t\t\t*dstptr2 = *srcptr2;\n\t\t\t++dstptr2;\n\t\t\t++srcptr2;\n\t\t}\n\t\tdstptr += 2 * stride;\n\t\tsrcptr += numcols;\n\t}\n\n\t/* If the join buffer was allocated on the heap, free this memory. */\n\tif (buf != joinbuf) {\n\t\tjas_free(buf);\n\t}\n\n}",
        "target": 1
    },
    {
        "func": "static int mif_hdr_growcmpts(mif_hdr_t *hdr, int maxcmpts)\n{\n\tint cmptno;\n\tmif_cmpt_t **newcmpts;\n\tassert(maxcmpts >= hdr->numcmpts);\n\tnewcmpts = (!hdr->cmpts) ? jas_malloc(maxcmpts * sizeof(mif_cmpt_t *)) :\n\t  jas_realloc(hdr->cmpts, maxcmpts * sizeof(mif_cmpt_t *));\n\tif (!newcmpts) {\n\t\treturn -1;\n\t}\n\thdr->maxcmpts = maxcmpts;\n\thdr->cmpts = newcmpts;\n\tfor (cmptno = hdr->numcmpts; cmptno < hdr->maxcmpts; ++cmptno) {\n\t\thdr->cmpts[cmptno] = 0;\n\t}\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static int jas_icccurv_input(jas_iccattrval_t *attrval, jas_stream_t *in,\n  int cnt)\n{\n\tjas_icccurv_t *curv = &attrval->data.curv;\n\tunsigned int i;\n\n\tcurv->numents = 0;\n\tcurv->ents = 0;\n\n\tif (jas_iccgetuint32(in, &curv->numents))\n\t\tgoto error;\n\tif (!(curv->ents = jas_malloc(curv->numents * sizeof(jas_iccuint16_t))))\n\t\tgoto error;\n\tfor (i = 0; i < curv->numents; ++i) {\n\t\tif (jas_iccgetuint16(in, &curv->ents[i]))\n\t\t\tgoto error;\n\t}\n\n\tif (JAS_CAST(int, 4 + 2 * curv->numents) != cnt)\n\t\tgoto error;\n\treturn 0;\n\nerror:\n\tjas_icccurv_destroy(attrval);\n\treturn -1;\n}",
        "target": 1
    },
    {
        "func": "static int jpc_dec_tileinit(jpc_dec_t *dec, jpc_dec_tile_t *tile)\n{\n\tjpc_dec_tcomp_t *tcomp;\n\tint compno;\n\tint rlvlno;\n\tjpc_dec_rlvl_t *rlvl;\n\tjpc_dec_band_t *band;\n\tjpc_dec_prc_t *prc;\n\tint bndno;\n\tjpc_tsfb_band_t *bnd;\n\tint bandno;\n\tjpc_dec_ccp_t *ccp;\n\tint prccnt;\n\tjpc_dec_cblk_t *cblk;\n\tint cblkcnt;\n\tuint_fast32_t tlprcxstart;\n\tuint_fast32_t tlprcystart;\n\tuint_fast32_t brprcxend;\n\tuint_fast32_t brprcyend;\n\tuint_fast32_t tlcbgxstart;\n\tuint_fast32_t tlcbgystart;\n\tuint_fast32_t brcbgxend;\n\tuint_fast32_t brcbgyend;\n\tuint_fast32_t cbgxstart;\n\tuint_fast32_t cbgystart;\n\tuint_fast32_t cbgxend;\n\tuint_fast32_t cbgyend;\n\tuint_fast32_t tlcblkxstart;\n\tuint_fast32_t tlcblkystart;\n\tuint_fast32_t brcblkxend;\n\tuint_fast32_t brcblkyend;\n\tuint_fast32_t cblkxstart;\n\tuint_fast32_t cblkystart;\n\tuint_fast32_t cblkxend;\n\tuint_fast32_t cblkyend;\n\tuint_fast32_t tmpxstart;\n\tuint_fast32_t tmpystart;\n\tuint_fast32_t tmpxend;\n\tuint_fast32_t tmpyend;\n\tjpc_dec_cp_t *cp;\n\tjpc_tsfb_band_t bnds[64];\n\tjpc_pchg_t *pchg;\n\tint pchgno;\n\tjpc_dec_cmpt_t *cmpt;\n\n\tcp = tile->cp;\n\ttile->realmode = 0;\n\tif (cp->mctid == JPC_MCT_ICT) {\n\t\ttile->realmode = 1;\n\t}\n\n\tfor (compno = 0, tcomp = tile->tcomps, cmpt = dec->cmpts; compno <\n\t  dec->numcomps; ++compno, ++tcomp, ++cmpt) {\n\t\tccp = &tile->cp->ccps[compno];\n\t\tif (ccp->qmfbid == JPC_COX_INS) {\n\t\t\ttile->realmode = 1;\n\t\t}\n\t\ttcomp->numrlvls = ccp->numrlvls;\n\t\tif (!(tcomp->rlvls = jas_malloc(tcomp->numrlvls *\n\t\t  sizeof(jpc_dec_rlvl_t)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (!(tcomp->data = jas_seq2d_create(JPC_CEILDIV(tile->xstart,\n\t\t  cmpt->hstep), JPC_CEILDIV(tile->ystart, cmpt->vstep),\n\t\t  JPC_CEILDIV(tile->xend, cmpt->hstep), JPC_CEILDIV(tile->yend,\n\t\t  cmpt->vstep)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (!(tcomp->tsfb = jpc_cod_gettsfb(ccp->qmfbid,\n\t\t  tcomp->numrlvls - 1))) {\n\t\t\treturn -1;\n\t\t}\n{\n\tjpc_tsfb_getbands(tcomp->tsfb, jas_seq2d_xstart(tcomp->data), jas_seq2d_ystart(tcomp->data), jas_seq2d_xend(tcomp->data), jas_seq2d_yend(tcomp->data), bnds);\n}\n\t\tfor (rlvlno = 0, rlvl = tcomp->rlvls; rlvlno < tcomp->numrlvls;\n\t\t  ++rlvlno, ++rlvl) {\nrlvl->bands = 0;\n\t\t\trlvl->xstart = JPC_CEILDIVPOW2(tcomp->xstart,\n\t\t\t  tcomp->numrlvls - 1 - rlvlno);\n\t\t\trlvl->ystart = JPC_CEILDIVPOW2(tcomp->ystart,\n\t\t\t  tcomp->numrlvls - 1 - rlvlno);\n\t\t\trlvl->xend = JPC_CEILDIVPOW2(tcomp->xend,\n\t\t\t  tcomp->numrlvls - 1 - rlvlno);\n\t\t\trlvl->yend = JPC_CEILDIVPOW2(tcomp->yend,\n\t\t\t  tcomp->numrlvls - 1 - rlvlno);\n\t\t\trlvl->prcwidthexpn = ccp->prcwidthexpns[rlvlno];\n\t\t\trlvl->prcheightexpn = ccp->prcheightexpns[rlvlno];\n\t\t\ttlprcxstart = JPC_FLOORDIVPOW2(rlvl->xstart,\n\t\t\t  rlvl->prcwidthexpn) << rlvl->prcwidthexpn;\n\t\t\ttlprcystart = JPC_FLOORDIVPOW2(rlvl->ystart,\n\t\t\t  rlvl->prcheightexpn) << rlvl->prcheightexpn;\n\t\t\tbrprcxend = JPC_CEILDIVPOW2(rlvl->xend,\n\t\t\t  rlvl->prcwidthexpn) << rlvl->prcwidthexpn;\n\t\t\tbrprcyend = JPC_CEILDIVPOW2(rlvl->yend,\n\t\t\t  rlvl->prcheightexpn) << rlvl->prcheightexpn;\n\t\t\trlvl->numhprcs = (brprcxend - tlprcxstart) >>\n\t\t\t  rlvl->prcwidthexpn;\n\t\t\trlvl->numvprcs = (brprcyend - tlprcystart) >>\n\t\t\t  rlvl->prcheightexpn;\n\t\t\trlvl->numprcs = rlvl->numhprcs * rlvl->numvprcs;\n\n\t\t\tif (rlvl->xstart >= rlvl->xend || rlvl->ystart >= rlvl->yend) {\n\t\t\t\trlvl->bands = 0;\n\t\t\t\trlvl->numprcs = 0;\n\t\t\t\trlvl->numhprcs = 0;\n\t\t\t\trlvl->numvprcs = 0;\n\t\t\t\tcontinue;\n\t\t\t}\t\n\t\t\tif (!rlvlno) {\n\t\t\t\ttlcbgxstart = tlprcxstart;\n\t\t\t\ttlcbgystart = tlprcystart;\n\t\t\t\tbrcbgxend = brprcxend;\n\t\t\t\tbrcbgyend = brprcyend;\n\t\t\t\trlvl->cbgwidthexpn = rlvl->prcwidthexpn;\n\t\t\t\trlvl->cbgheightexpn = rlvl->prcheightexpn;\n\t\t\t} else {\n\t\t\t\ttlcbgxstart = JPC_CEILDIVPOW2(tlprcxstart, 1);\n\t\t\t\ttlcbgystart = JPC_CEILDIVPOW2(tlprcystart, 1);\n\t\t\t\tbrcbgxend = JPC_CEILDIVPOW2(brprcxend, 1);\n\t\t\t\tbrcbgyend = JPC_CEILDIVPOW2(brprcyend, 1);\n\t\t\t\trlvl->cbgwidthexpn = rlvl->prcwidthexpn - 1;\n\t\t\t\trlvl->cbgheightexpn = rlvl->prcheightexpn - 1;\n\t\t\t}\n\t\t\trlvl->cblkwidthexpn = JAS_MIN(ccp->cblkwidthexpn,\n\t\t\t  rlvl->cbgwidthexpn);\n\t\t\trlvl->cblkheightexpn = JAS_MIN(ccp->cblkheightexpn,\n\t\t\t  rlvl->cbgheightexpn);\n\n\t\t\trlvl->numbands = (!rlvlno) ? 1 : 3;\n\t\t\tif (!(rlvl->bands = jas_malloc(rlvl->numbands *\n\t\t\t  sizeof(jpc_dec_band_t)))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (bandno = 0, band = rlvl->bands;\n\t\t\t  bandno < rlvl->numbands; ++bandno, ++band) {\n\t\t\t\tbndno = (!rlvlno) ? 0 : (3 * (rlvlno - 1) +\n\t\t\t\t  bandno + 1);\n\t\t\t\tbnd = &bnds[bndno];\n\n\t\t\t\tband->orient = bnd->orient;\n\t\t\t\tband->stepsize = ccp->stepsizes[bndno];\n\t\t\t\tband->analgain = JPC_NOMINALGAIN(ccp->qmfbid,\n\t\t\t\t  tcomp->numrlvls - 1, rlvlno, band->orient);\n\t\t\t\tband->absstepsize = jpc_calcabsstepsize(band->stepsize,\n\t\t\t\t  cmpt->prec + band->analgain);\n\t\t\t\tband->numbps = ccp->numguardbits +\n\t\t\t\t  JPC_QCX_GETEXPN(band->stepsize) - 1;\n\t\t\t\tband->roishift = (ccp->roishift + band->numbps >= JPC_PREC) ?\n\t\t\t\t  (JPC_PREC - 1 - band->numbps) : ccp->roishift;\n\t\t\t\tband->data = 0;\n\t\t\t\tband->prcs = 0;\n\t\t\t\tif (bnd->xstart == bnd->xend || bnd->ystart == bnd->yend) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!(band->data = jas_seq2d_create(0, 0, 0, 0))) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tjas_seq2d_bindsub(band->data, tcomp->data, bnd->locxstart, bnd->locystart, bnd->locxend, bnd->locyend);\n\t\t\t\tjas_seq2d_setshift(band->data, bnd->xstart, bnd->ystart);\n\n\t\t\t\tassert(rlvl->numprcs);\n\n\t\t\t\tif (!(band->prcs = jas_malloc(rlvl->numprcs * sizeof(jpc_dec_prc_t)))) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n/************************************************/\n\tcbgxstart = tlcbgxstart;\n\tcbgystart = tlcbgystart;\n\tfor (prccnt = rlvl->numprcs, prc = band->prcs;\n\t  prccnt > 0; --prccnt, ++prc) {\n\t\tcbgxend = cbgxstart + (1 << rlvl->cbgwidthexpn);\n\t\tcbgyend = cbgystart + (1 << rlvl->cbgheightexpn);\n\t\tprc->xstart = JAS_MAX(cbgxstart, JAS_CAST(uint_fast32_t, jas_seq2d_xstart(band->data)));\n\t\tprc->ystart = JAS_MAX(cbgystart, JAS_CAST(uint_fast32_t, jas_seq2d_ystart(band->data)));\n\t\tprc->xend = JAS_MIN(cbgxend, JAS_CAST(uint_fast32_t, jas_seq2d_xend(band->data)));\n\t\tprc->yend = JAS_MIN(cbgyend, JAS_CAST(uint_fast32_t, jas_seq2d_yend(band->data)));\n\t\tif (prc->xend > prc->xstart && prc->yend > prc->ystart) {\n\t\t\ttlcblkxstart = JPC_FLOORDIVPOW2(prc->xstart,\n\t\t\t  rlvl->cblkwidthexpn) << rlvl->cblkwidthexpn;\n\t\t\ttlcblkystart = JPC_FLOORDIVPOW2(prc->ystart,\n\t\t\t  rlvl->cblkheightexpn) << rlvl->cblkheightexpn;\n\t\t\tbrcblkxend = JPC_CEILDIVPOW2(prc->xend,\n\t\t\t  rlvl->cblkwidthexpn) << rlvl->cblkwidthexpn;\n\t\t\tbrcblkyend = JPC_CEILDIVPOW2(prc->yend,\n\t\t\t  rlvl->cblkheightexpn) << rlvl->cblkheightexpn;\n\t\t\tprc->numhcblks = (brcblkxend - tlcblkxstart) >>\n\t\t\t  rlvl->cblkwidthexpn;\n\t\t\tprc->numvcblks = (brcblkyend - tlcblkystart) >>\n\t\t\t  rlvl->cblkheightexpn;\n\t\t\tprc->numcblks = prc->numhcblks * prc->numvcblks;\n\t\t\tassert(prc->numcblks > 0);\n\n\t\t\tif (!(prc->incltagtree = jpc_tagtree_create(prc->numhcblks, prc->numvcblks))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (!(prc->numimsbstagtree = jpc_tagtree_create(prc->numhcblks, prc->numvcblks))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (!(prc->cblks = jas_malloc(prc->numcblks * sizeof(jpc_dec_cblk_t)))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tcblkxstart = cbgxstart;\n\t\t\tcblkystart = cbgystart;\n\t\t\tfor (cblkcnt = prc->numcblks, cblk = prc->cblks; cblkcnt > 0;) {\n\t\t\t\tcblkxend = cblkxstart + (1 << rlvl->cblkwidthexpn);\n\t\t\t\tcblkyend = cblkystart + (1 << rlvl->cblkheightexpn);\n\t\t\t\ttmpxstart = JAS_MAX(cblkxstart, prc->xstart);\n\t\t\t\ttmpystart = JAS_MAX(cblkystart, prc->ystart);\n\t\t\t\ttmpxend = JAS_MIN(cblkxend, prc->xend);\n\t\t\t\ttmpyend = JAS_MIN(cblkyend, prc->yend);\n\t\t\t\tif (tmpxend > tmpxstart && tmpyend > tmpystart) {\n\t\t\t\t\tcblk->firstpassno = -1;\n\t\t\t\t\tcblk->mqdec = 0;\n\t\t\t\t\tcblk->nulldec = 0;\n\t\t\t\t\tcblk->flags = 0;\n\t\t\t\t\tcblk->numpasses = 0;\n\t\t\t\t\tcblk->segs.head = 0;\n\t\t\t\t\tcblk->segs.tail = 0;\n\t\t\t\t\tcblk->curseg = 0;\n\t\t\t\t\tcblk->numimsbs = 0;\n\t\t\t\t\tcblk->numlenbits = 3;\n\t\t\t\t\tcblk->flags = 0;\n\t\t\t\t\tif (!(cblk->data = jas_seq2d_create(0, 0, 0, 0))) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\tjas_seq2d_bindsub(cblk->data, band->data, tmpxstart, tmpystart, tmpxend, tmpyend);\n\t\t\t\t\t++cblk;\n\t\t\t\t\t--cblkcnt;\n\t\t\t\t}\n\t\t\t\tcblkxstart += 1 << rlvl->cblkwidthexpn;\n\t\t\t\tif (cblkxstart >= cbgxend) {\n\t\t\t\t\tcblkxstart = cbgxstart;\n\t\t\t\t\tcblkystart += 1 << rlvl->cblkheightexpn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\t\t\tprc->cblks = 0;\n\t\t\tprc->incltagtree = 0;\n\t\t\tprc->numimsbstagtree = 0;\n\t\t}\n\t\tcbgxstart += 1 << rlvl->cbgwidthexpn;\n\t\tif (cbgxstart >= brcbgxend) {\n\t\t\tcbgxstart = tlcbgxstart;\n\t\t\tcbgystart += 1 << rlvl->cbgheightexpn;\n\t\t}\n\n\t}\n/********************************************/\n\t\t\t}\n\t\t}\n\t}\n\nif (!(tile->pi = jpc_dec_pi_create(dec, tile)))\n{\n\treturn -1;\n}\n\n\tfor (pchgno = 0; pchgno < jpc_pchglist_numpchgs(tile->cp->pchglist);\n\t  ++pchgno) {\n\t\tpchg = jpc_pchg_copy(jpc_pchglist_get(tile->cp->pchglist, pchgno));\n\t\tassert(pchg);\n\t\tjpc_pi_addpchg(tile->pi, pchg);\n\t}\n\tjpc_pi_init(tile->pi);\n\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static int jpc_qcx_getcompparms(jpc_qcxcp_t *compparms, jpc_cstate_t *cstate,\n  jas_stream_t *in, uint_fast16_t len)\n{\n\tuint_fast8_t tmp;\n\tint n;\n\tint i;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tn = 0;\n\tif (jpc_getuint8(in, &tmp)) {\n\t\treturn -1;\n\t}\n\t++n;\n\tcompparms->qntsty = tmp & 0x1f;\n\tcompparms->numguard = (tmp >> 5) & 7;\n\tswitch (compparms->qntsty) {\n\tcase JPC_QCX_SIQNT:\n\t\tcompparms->numstepsizes = 1;\n\t\tbreak;\n\tcase JPC_QCX_NOQNT:\n\t\tcompparms->numstepsizes = (len - n);\n\t\tbreak;\n\tcase JPC_QCX_SEQNT:\n\t\t/* XXX - this is a hack */\n\t\tcompparms->numstepsizes = (len - n) / 2;\n\t\tbreak;\n\t}\n\tif (compparms->numstepsizes > 0) {\n\t\tcompparms->stepsizes = jas_malloc(compparms->numstepsizes *\n\t\t  sizeof(uint_fast16_t));\n\t\tassert(compparms->stepsizes);\n\t\tfor (i = 0; i < compparms->numstepsizes; ++i) {\n\t\t\tif (compparms->qntsty == JPC_QCX_NOQNT) {\n\t\t\t\tif (jpc_getuint8(in, &tmp)) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tcompparms->stepsizes[i] = JPC_QCX_EXPN(tmp >> 3);\n\t\t\t} else {\n\t\t\t\tif (jpc_getuint16(in, &compparms->stepsizes[i])) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tcompparms->stepsizes = 0;\n\t}\n\tif (jas_stream_error(in) || jas_stream_eof(in)) {\n\t\tjpc_qcx_destroycompparms(compparms);\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "void jpc_qmfb_split_col(jpc_fix_t *a, int numrows, int stride,\n  int parity)\n{\n\n\tint bufsize = JPC_CEILDIVPOW2(numrows, 1);\n\tjpc_fix_t splitbuf[QMFB_SPLITBUFSIZE];\n\tjpc_fix_t *buf = splitbuf;\n\tregister jpc_fix_t *srcptr;\n\tregister jpc_fix_t *dstptr;\n\tregister int n;\n\tregister int m;\n\tint hstartcol;\n\n\t/* Get a buffer. */\n\tif (bufsize > QMFB_SPLITBUFSIZE) {\n\t\tif (!(buf = jas_malloc(bufsize * sizeof(jpc_fix_t)))) {\n\t\t\t/* We have no choice but to commit suicide in this case. */\n\t\t\tabort();\n\t\t}\n\t}\n\n\tif (numrows >= 2) {\n\t\thstartcol = (numrows + 1 - parity) >> 1;\n\t\tm = (parity) ? hstartcol : (numrows - hstartcol);\n\t\t/* Save the samples destined for the highpass channel. */\n\t\tn = m;\n\t\tdstptr = buf;\n\t\tsrcptr = &a[(1 - parity) * stride];\n\t\twhile (n-- > 0) {\n\t\t\t*dstptr = *srcptr;\n\t\t\t++dstptr;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\t/* Copy the appropriate samples into the lowpass channel. */\n\t\tdstptr = &a[(1 - parity) * stride];\n\t\tsrcptr = &a[(2 - parity) * stride];\n\t\tn = numrows - m - (!parity);\n\t\twhile (n-- > 0) {\n\t\t\t*dstptr = *srcptr;\n\t\t\tdstptr += stride;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\t/* Copy the saved samples into the highpass channel. */\n\t\tdstptr = &a[hstartcol * stride];\n\t\tsrcptr = buf;\n\t\tn = m;\n\t\twhile (n-- > 0) {\n\t\t\t*dstptr = *srcptr;\n\t\t\tdstptr += stride;\n\t\t\t++srcptr;\n\t\t}\n\t}\n\n\t/* If the split buffer was allocated on the heap, free this memory. */\n\tif (buf != splitbuf) {\n\t\tjas_free(buf);\n\t}\n\n}",
        "target": 1
    },
    {
        "func": "void jas_matrix_bindsub(jas_matrix_t *mat0, jas_matrix_t *mat1, int r0, int c0,\n  int r1, int c1)\n{\n\tint i;\n\n\tif (mat0->data_) {\n\t\tif (!(mat0->flags_ & JAS_MATRIX_REF)) {\n\t\t\tjas_free(mat0->data_);\n\t\t}\n\t\tmat0->data_ = 0;\n\t\tmat0->datasize_ = 0;\n\t}\n\tif (mat0->rows_) {\n\t\tjas_free(mat0->rows_);\n\t\tmat0->rows_ = 0;\n\t}\n\tmat0->flags_ |= JAS_MATRIX_REF;\n\tmat0->numrows_ = r1 - r0 + 1;\n\tmat0->numcols_ = c1 - c0 + 1;\n\tmat0->maxrows_ = mat0->numrows_;\n\tmat0->rows_ = jas_malloc(mat0->maxrows_ * sizeof(jas_seqent_t *));\n\tfor (i = 0; i < mat0->numrows_; ++i) {\n\t\tmat0->rows_[i] = mat1->rows_[r0 + i] + c0;\n\t}\n\n\tmat0->xstart_ = mat1->xstart_ + c0;\n\tmat0->ystart_ = mat1->ystart_ + r0;\n\tmat0->xend_ = mat0->xstart_ + mat0->numcols_;\n\tmat0->yend_ = mat0->ystart_ + mat0->numrows_;\n}",
        "target": 1
    },
    {
        "func": "static int jas_cmpxformseq_resize(jas_cmpxformseq_t *pxformseq, int n)\n{\n\tjas_cmpxform_t **p;\n\tassert(n >= pxformseq->numpxforms);\n\tp = (!pxformseq->pxforms) ? jas_malloc(n * sizeof(jas_cmpxform_t *)) :\n\t  jas_realloc(pxformseq->pxforms, n * sizeof(jas_cmpxform_t *));\n\tif (!p) {\n\t\treturn -1;\n\t}\n\tpxformseq->pxforms = p;\n\tpxformseq->maxpxforms = n;\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static int jpc_ppt_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_ppt_t *ppt = &ms->parms.ppt;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tppt->data = 0;\n\n\tif (ms->len < 1) {\n\t\tgoto error;\n\t}\n\tif (jpc_getuint8(in, &ppt->ind)) {\n\t\tgoto error;\n\t}\n\tppt->len = ms->len - 1;\n\tif (ppt->len > 0) {\n\t\tif (!(ppt->data = jas_malloc(ppt->len * sizeof(unsigned char)))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (jas_stream_read(in, (char *) ppt->data, ppt->len) != JAS_CAST(int, ppt->len)) {\n\t\t\tgoto error;\n\t\t}\n\t} else {\n\t\tppt->data = 0;\n\t}\n\treturn 0;\n\nerror:\n\tjpc_ppt_destroyparms(ms);\n\treturn -1;\n}",
        "target": 1
    },
    {
        "func": "jas_image_t *jas_image_create(int numcmpts, jas_image_cmptparm_t *cmptparms,\n  int clrspc)\n{\n\tjas_image_t *image;\n\tuint_fast32_t rawsize;\n\tuint_fast32_t inmem;\n\tint cmptno;\n\tjas_image_cmptparm_t *cmptparm;\n\n\tif (!(image = jas_image_create0())) {\n\t\treturn 0;\n\t}\n\n\timage->clrspc_ = clrspc;\n\timage->maxcmpts_ = numcmpts;\n\timage->inmem_ = true;\n\n\t/* Allocate memory for the per-component information. */\n\tif (!(image->cmpts_ = jas_malloc(image->maxcmpts_ *\n\t  sizeof(jas_image_cmpt_t *)))) {\n\t\tjas_image_destroy(image);\n\t\treturn 0;\n\t}\n\t/* Initialize in case of failure. */\n\tfor (cmptno = 0; cmptno < image->maxcmpts_; ++cmptno) {\n\t\timage->cmpts_[cmptno] = 0;\n\t}\n\n\t/* Compute the approximate raw size of the image. */\n\trawsize = 0;\n\tfor (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,\n\t  ++cmptparm) {\n\t\trawsize += cmptparm->width * cmptparm->height *\n\t\t  (cmptparm->prec + 7) / 8;\n\t}\n\t/* Decide whether to buffer the image data in memory, based on the\n\t  raw size of the image. */\n\tinmem = (rawsize < JAS_IMAGE_INMEMTHRESH);\n\n\t/* Create the individual image components. */\n\tfor (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,\n\t  ++cmptparm) {\n\t\tif (!(image->cmpts_[cmptno] = jas_image_cmpt_create(cmptparm->tlx,\n\t\t  cmptparm->tly, cmptparm->hstep, cmptparm->vstep,\n\t\t  cmptparm->width, cmptparm->height, cmptparm->prec,\n\t\t  cmptparm->sgnd, inmem))) {\n\t\t\tjas_image_destroy(image);\n\t\t\treturn 0;\n\t\t}\n\t\t++image->numcmpts_;\n\t}\n\n\t/* Determine the bounding box for all of the components on the\n\t  reference grid (i.e., the image area) */\n\tjas_image_setbbox(image);\n\n\treturn image;\n}",
        "target": 1
    },
    {
        "func": "static int jpc_ppm_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_ppm_t *ppm = &ms->parms.ppm;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tppm->data = 0;\n\n\tif (ms->len < 1) {\n\t\tgoto error;\n\t}\n\tif (jpc_getuint8(in, &ppm->ind)) {\n\t\tgoto error;\n\t}\n\n\tppm->len = ms->len - 1;\n\tif (ppm->len > 0) {\n\t\tif (!(ppm->data = jas_malloc(ppm->len * sizeof(unsigned char)))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (JAS_CAST(uint, jas_stream_read(in, ppm->data, ppm->len)) != ppm->len) {\n\t\t\tgoto error;\n\t\t}\n\t} else {\n\t\tppm->data = 0;\n\t}\n\treturn 0;\n\nerror:\n\tjpc_ppm_destroyparms(ms);\n\treturn -1;\n}",
        "target": 1
    },
    {
        "func": "static int jpc_poc_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_poc_t *poc = &ms->parms.poc;\n\tjpc_pocpchg_t *pchg;\n\tint pchgno;\n\tuint_fast8_t tmp;\n\tpoc->numpchgs = (cstate->numcomps > 256) ? (ms->len / 9) :\n\t  (ms->len / 7);\n\tif (!(poc->pchgs = jas_malloc(poc->numpchgs * sizeof(jpc_pocpchg_t)))) {\n\t\tgoto error;\n\t}\n\tfor (pchgno = 0, pchg = poc->pchgs; pchgno < poc->numpchgs; ++pchgno,\n\t  ++pchg) {\n\t\tif (jpc_getuint8(in, &pchg->rlvlnostart)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (cstate->numcomps > 256) {\n\t\t\tif (jpc_getuint16(in, &pchg->compnostart)) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t} else {\n\t\t\tif (jpc_getuint8(in, &tmp)) {\n\t\t\t\tgoto error;\n\t\t\t};\n\t\t\tpchg->compnostart = tmp;\n\t\t}\n\t\tif (jpc_getuint16(in, &pchg->lyrnoend) ||\n\t\t  jpc_getuint8(in, &pchg->rlvlnoend)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (cstate->numcomps > 256) {\n\t\t\tif (jpc_getuint16(in, &pchg->compnoend)) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t} else {\n\t\t\tif (jpc_getuint8(in, &tmp)) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tpchg->compnoend = tmp;\n\t\t}\n\t\tif (jpc_getuint8(in, &pchg->prgord)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (pchg->rlvlnostart > pchg->rlvlnoend ||\n\t\t  pchg->compnostart > pchg->compnoend) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\treturn 0;\n\nerror:\n\tjpc_poc_destroyparms(ms);\n\treturn -1;\n}",
        "target": 1
    },
    {
        "func": "jpc_streamlist_t *jpc_streamlist_create()\n{\n\tjpc_streamlist_t *streamlist;\n\tint i;\n\n\tif (!(streamlist = jas_malloc(sizeof(jpc_streamlist_t)))) {\n\t\treturn 0;\n\t}\n\tstreamlist->numstreams = 0;\n\tstreamlist->maxstreams = 100;\n\tif (!(streamlist->streams = jas_malloc(streamlist->maxstreams *\n\t  sizeof(jas_stream_t *)))) {\n\t\tjas_free(streamlist);\n\t\treturn 0;\n\t}\n\tfor (i = 0; i < streamlist->maxstreams; ++i) {\n\t\tstreamlist->streams[i] = 0;\n\t}\n\treturn streamlist;\n}",
        "target": 1
    },
    {
        "func": "static jpc_enc_band_t *band_create(jpc_enc_band_t *band, jpc_enc_cp_t *cp,\n  jpc_enc_rlvl_t *rlvl, jpc_tsfb_band_t *bandinfos)\n{\n\tuint_fast16_t bandno;\n\tuint_fast16_t gblbandno;\n\tuint_fast16_t rlvlno;\n\tjpc_tsfb_band_t *bandinfo;\n\tjpc_enc_tcmpt_t *tcmpt;\n\tuint_fast32_t prcno;\n\tjpc_enc_prc_t *prc;\n\n\ttcmpt = rlvl->tcmpt;\n\tband->data = 0;\n\tband->prcs = 0;\n\tband->rlvl = rlvl;\n\n\t/* Deduce the resolution level and band number. */\n\trlvlno = rlvl - rlvl->tcmpt->rlvls;\n\tbandno = band - rlvl->bands;\n\tgblbandno = (!rlvlno) ? 0 : (3 * (rlvlno - 1) + bandno + 1);\n\n\tbandinfo = &bandinfos[gblbandno];\n\nif (bandinfo->xstart != bandinfo->xend && bandinfo->ystart != bandinfo->yend) {\n\tif (!(band->data = jas_seq2d_create(0, 0, 0, 0))) {\n\t\tgoto error;\n\t}\n\tjas_seq2d_bindsub(band->data, tcmpt->data, bandinfo->locxstart,\n\t  bandinfo->locystart, bandinfo->locxend, bandinfo->locyend);\n\tjas_seq2d_setshift(band->data, bandinfo->xstart, bandinfo->ystart);\n}\n\tband->orient = bandinfo->orient;\n\tband->analgain = JPC_NOMINALGAIN(cp->tccp.qmfbid, tcmpt->numrlvls, rlvlno,\n\t  band->orient);\n\tband->numbps = 0;\n\tband->absstepsize = 0;\n\tband->stepsize = 0;\n\tband->synweight = bandinfo->synenergywt;\n\nif (band->data) {\n\tif (!(band->prcs = jas_malloc(rlvl->numprcs * sizeof(jpc_enc_prc_t)))) {\n\t\tgoto error;\n\t}\n\tfor (prcno = 0, prc = band->prcs; prcno < rlvl->numprcs; ++prcno,\n\t  ++prc) {\n\t\tprc->cblks = 0;\n\t\tprc->incltree = 0;\n\t\tprc->nlibtree = 0;\n\t\tprc->savincltree = 0;\n\t\tprc->savnlibtree = 0;\n\t\tprc->band = band;\n\t}\n\tfor (prcno = 0, prc = band->prcs; prcno < rlvl->numprcs; ++prcno,\n\t  ++prc) {\n\t\tif (!prc_create(prc, cp, band)) {\n\t\t\tgoto error;\n\t\t}\n\t}\n}\n\n\treturn band;\n\nerror:\n\tband_destroy(band);\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "jas_image_t *jp2_decode(jas_stream_t *in, char *optstr)\n{\n\tjp2_box_t *box;\n\tint found;\n\tjas_image_t *image;\n\tjp2_dec_t *dec;\n\tbool samedtype;\n\tint dtype;\n\tunsigned int i;\n\tjp2_cmap_t *cmapd;\n\tjp2_pclr_t *pclrd;\n\tjp2_cdef_t *cdefd;\n\tunsigned int channo;\n\tint newcmptno;\n\tint_fast32_t *lutents;\n#if 0\n\tjp2_cdefchan_t *cdefent;\n\tint cmptno;\n#endif\n\tjp2_cmapent_t *cmapent;\n\tjas_icchdr_t icchdr;\n\tjas_iccprof_t *iccprof;\n\n\tdec = 0;\n\tbox = 0;\n\timage = 0;\n\n\tif (!(dec = jp2_dec_create())) {\n\t\tgoto error;\n\t}\n\n\t/* Get the first box.  This should be a JP box. */\n\tif (!(box = jp2_box_get(in))) {\n\t\tjas_eprintf(\"error: cannot get box\\n\");\n\t\tgoto error;\n\t}\n\tif (box->type != JP2_BOX_JP) {\n\t\tjas_eprintf(\"error: expecting signature box\\n\");\n\t\tgoto error;\n\t}\n\tif (box->data.jp.magic != JP2_JP_MAGIC) {\n\t\tjas_eprintf(\"incorrect magic number\\n\");\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/* Get the second box.  This should be a FTYP box. */\n\tif (!(box = jp2_box_get(in))) {\n\t\tgoto error;\n\t}\n\tif (box->type != JP2_BOX_FTYP) {\n\t\tjas_eprintf(\"expecting file type box\\n\");\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/* Get more boxes... */\n\tfound = 0;\n\twhile ((box = jp2_box_get(in))) {\n\t\tif (jas_getdbglevel() >= 1) {\n\t\t\tjas_eprintf(\"box type %s\\n\", box->info->name);\n\t\t}\n\t\tswitch (box->type) {\n\t\tcase JP2_BOX_JP2C:\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\tcase JP2_BOX_IHDR:\n\t\t\tif (!dec->ihdr) {\n\t\t\t\tdec->ihdr = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_BPCC:\n\t\t\tif (!dec->bpcc) {\n\t\t\t\tdec->bpcc = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_CDEF:\n\t\t\tif (!dec->cdef) {\n\t\t\t\tdec->cdef = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_PCLR:\n\t\t\tif (!dec->pclr) {\n\t\t\t\tdec->pclr = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_CMAP:\n\t\t\tif (!dec->cmap) {\n\t\t\t\tdec->cmap = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_COLR:\n\t\t\tif (!dec->colr) {\n\t\t\t\tdec->colr = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (box) {\n\t\t\tjp2_box_destroy(box);\n\t\t\tbox = 0;\n\t\t}\n\t\tif (found) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tjas_eprintf(\"error: no code stream found\\n\");\n\t\tgoto error;\n\t}\n\n\tif (!(dec->image = jpc_decode(in, optstr))) {\n\t\tjas_eprintf(\"error: cannot decode code stream\\n\");\n\t\tgoto error;\n\t}\n\n\t/* An IHDR box must be present. */\n\tif (!dec->ihdr) {\n\t\tjas_eprintf(\"error: missing IHDR box\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Does the number of components indicated in the IHDR box match\n\t  the value specified in the code stream? */\n\tif (dec->ihdr->data.ihdr.numcmpts != JAS_CAST(uint, jas_image_numcmpts(dec->image))) {\n\t\tjas_eprintf(\"warning: number of components mismatch\\n\");\n\t}\n\n\t/* At least one component must be present. */\n\tif (!jas_image_numcmpts(dec->image)) {\n\t\tjas_eprintf(\"error: no components\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Determine if all components have the same data type. */\n\tsamedtype = true;\n\tdtype = jas_image_cmptdtype(dec->image, 0);\n\tfor (i = 1; i < JAS_CAST(uint, jas_image_numcmpts(dec->image)); ++i) {\n\t\tif (jas_image_cmptdtype(dec->image, i) != dtype) {\n\t\t\tsamedtype = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Is the component data type indicated in the IHDR box consistent\n\t  with the data in the code stream? */\n\tif ((samedtype && dec->ihdr->data.ihdr.bpc != JP2_DTYPETOBPC(dtype)) ||\n\t  (!samedtype && dec->ihdr->data.ihdr.bpc != JP2_IHDR_BPCNULL)) {\n\t\tjas_eprintf(\"warning: component data type mismatch\\n\");\n\t}\n\n\t/* Is the compression type supported? */\n\tif (dec->ihdr->data.ihdr.comptype != JP2_IHDR_COMPTYPE) {\n\t\tjas_eprintf(\"error: unsupported compression type\\n\");\n\t\tgoto error;\n\t}\n\n\tif (dec->bpcc) {\n\t\t/* Is the number of components indicated in the BPCC box\n\t\t  consistent with the code stream data? */\n\t\tif (dec->bpcc->data.bpcc.numcmpts != JAS_CAST(uint, jas_image_numcmpts(\n\t\t  dec->image))) {\n\t\t\tjas_eprintf(\"warning: number of components mismatch\\n\");\n\t\t}\n\t\t/* Is the component data type information indicated in the BPCC\n\t\t  box consistent with the code stream data? */\n\t\tif (!samedtype) {\n\t\t\tfor (i = 0; i < JAS_CAST(uint, jas_image_numcmpts(dec->image)); ++i) {\n\t\t\t\tif (jas_image_cmptdtype(dec->image, i) != JP2_BPCTODTYPE(dec->bpcc->data.bpcc.bpcs[i])) {\n\t\t\t\t\tjas_eprintf(\"warning: component data type mismatch\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tjas_eprintf(\"warning: superfluous BPCC box\\n\");\n\t\t}\n\t}\n\n\t/* A COLR box must be present. */\n\tif (!dec->colr) {\n\t\tjas_eprintf(\"error: no COLR box\\n\");\n\t\tgoto error;\n\t}\n\n\tswitch (dec->colr->data.colr.method) {\n\tcase JP2_COLR_ENUM:\n\t\tjas_image_setclrspc(dec->image, jp2_getcs(&dec->colr->data.colr));\n\t\tbreak;\n\tcase JP2_COLR_ICC:\n\t\ticcprof = jas_iccprof_createfrombuf(dec->colr->data.colr.iccp,\n\t\t  dec->colr->data.colr.iccplen);\n\t\tif (!iccprof) {\n\t\t\tjas_eprintf(\"error: failed to parse ICC profile\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tjas_iccprof_gethdr(iccprof, &icchdr);\n\t\tjas_eprintf(\"ICC Profile CS %08x\\n\", icchdr.colorspc);\n\t\tjas_image_setclrspc(dec->image, fromiccpcs(icchdr.colorspc));\n\t\tdec->image->cmprof_ = jas_cmprof_createfromiccprof(iccprof);\n\t\tassert(dec->image->cmprof_);\n\t\tjas_iccprof_destroy(iccprof);\n\t\tbreak;\n\t}\n\n\t/* If a CMAP box is present, a PCLR box must also be present. */\n\tif (dec->cmap && !dec->pclr) {\n\t\tjas_eprintf(\"warning: missing PCLR box or superfluous CMAP box\\n\");\n\t\tjp2_box_destroy(dec->cmap);\n\t\tdec->cmap = 0;\n\t}\n\n\t/* If a CMAP box is not present, a PCLR box must not be present. */\n\tif (!dec->cmap && dec->pclr) {\n\t\tjas_eprintf(\"warning: missing CMAP box or superfluous PCLR box\\n\");\n\t\tjp2_box_destroy(dec->pclr);\n\t\tdec->pclr = 0;\n\t}\n\n\t/* Determine the number of channels (which is essentially the number\n\t  of components after any palette mappings have been applied). */\n\tdec->numchans = dec->cmap ? dec->cmap->data.cmap.numchans : JAS_CAST(uint, jas_image_numcmpts(dec->image));\n\n\t/* Perform a basic sanity check on the CMAP box if present. */\n\tif (dec->cmap) {\n\t\tfor (i = 0; i < dec->numchans; ++i) {\n\t\t\t/* Is the component number reasonable? */\n\t\t\tif (dec->cmap->data.cmap.ents[i].cmptno >= JAS_CAST(uint, jas_image_numcmpts(dec->image))) {\n\t\t\t\tjas_eprintf(\"error: invalid component number in CMAP box\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\t/* Is the LUT index reasonable? */\n\t\t\tif (dec->cmap->data.cmap.ents[i].pcol >= dec->pclr->data.pclr.numchans) {\n\t\t\t\tjas_eprintf(\"error: invalid CMAP LUT index\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Allocate space for the channel-number to component-number LUT. */\n\tif (!(dec->chantocmptlut = jas_malloc(dec->numchans * sizeof(uint_fast16_t)))) {\n\t\tjas_eprintf(\"error: no memory\\n\");\n\t\tgoto error;\n\t}\n\n\tif (!dec->cmap) {\n\t\tfor (i = 0; i < dec->numchans; ++i) {\n\t\t\tdec->chantocmptlut[i] = i;\n\t\t}\n\t} else {\n\t\tcmapd = &dec->cmap->data.cmap;\n\t\tpclrd = &dec->pclr->data.pclr;\n\t\tcdefd = &dec->cdef->data.cdef;\n\t\tfor (channo = 0; channo < cmapd->numchans; ++channo) {\n\t\t\tcmapent = &cmapd->ents[channo];\n\t\t\tif (cmapent->map == JP2_CMAP_DIRECT) {\n\t\t\t\tdec->chantocmptlut[channo] = channo;\n\t\t\t} else if (cmapent->map == JP2_CMAP_PALETTE) {\n\t\t\t\tlutents = jas_malloc(pclrd->numlutents * sizeof(int_fast32_t));\n\t\t\t\tfor (i = 0; i < pclrd->numlutents; ++i) {\n\t\t\t\t\tlutents[i] = pclrd->lutdata[cmapent->pcol + i * pclrd->numchans];\n\t\t\t\t}\n\t\t\t\tnewcmptno = jas_image_numcmpts(dec->image);\n\t\t\t\tjas_image_depalettize(dec->image, cmapent->cmptno, pclrd->numlutents, lutents, JP2_BPCTODTYPE(pclrd->bpc[cmapent->pcol]), newcmptno);\n\t\t\t\tdec->chantocmptlut[channo] = newcmptno;\n\t\t\t\tjas_free(lutents);\n#if 0\n\t\t\t\tif (dec->cdef) {\n\t\t\t\t\tcdefent = jp2_cdef_lookup(cdefd, channo);\n\t\t\t\t\tif (!cdefent) {\n\t\t\t\t\t\tabort();\n\t\t\t\t\t}\n\t\t\t\tjas_image_setcmpttype(dec->image, newcmptno, jp2_getct(jas_image_clrspc(dec->image), cdefent->type, cdefent->assoc));\n\t\t\t\t} else {\n\t\t\t\tjas_image_setcmpttype(dec->image, newcmptno, jp2_getct(jas_image_clrspc(dec->image), 0, channo + 1));\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Mark all components as being of unknown type. */\n\n\tfor (i = 0; i < JAS_CAST(uint, jas_image_numcmpts(dec->image)); ++i) {\n\t\tjas_image_setcmpttype(dec->image, i, JAS_IMAGE_CT_UNKNOWN);\n\t}\n\n\t/* Determine the type of each component. */\n\tif (dec->cdef) {\n\t\tfor (i = 0; i < dec->numchans; ++i) {\n\t\t\t/* Is the channel number reasonable? */\n\t\t\tif (dec->cdef->data.cdef.ents[i].channo >= dec->numchans) {\n\t\t\t\tjas_eprintf(\"error: invalid channel number in CDEF box\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tjas_image_setcmpttype(dec->image,\n\t\t\t  dec->chantocmptlut[dec->cdef->data.cdef.ents[i].channo],\n\t\t\t  jp2_getct(jas_image_clrspc(dec->image),\n\t\t\t  dec->cdef->data.cdef.ents[i].type, dec->cdef->data.cdef.ents[i].assoc));\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < dec->numchans; ++i) {\n\t\t\tjas_image_setcmpttype(dec->image, dec->chantocmptlut[i],\n\t\t\t  jp2_getct(jas_image_clrspc(dec->image), 0, i + 1));\n\t\t}\n\t}\n\n\t/* Delete any components that are not of interest. */\n\tfor (i = jas_image_numcmpts(dec->image); i > 0; --i) {\n\t\tif (jas_image_cmpttype(dec->image, i - 1) == JAS_IMAGE_CT_UNKNOWN) {\n\t\t\tjas_image_delcmpt(dec->image, i - 1);\n\t\t}\n\t}\n\n\t/* Ensure that some components survived. */\n\tif (!jas_image_numcmpts(dec->image)) {\n\t\tjas_eprintf(\"error: no components\\n\");\n\t\tgoto error;\n\t}\n#if 0\njas_eprintf(\"no of components is %d\\n\", jas_image_numcmpts(dec->image));\n#endif\n\n\t/* Prevent the image from being destroyed later. */\n\timage = dec->image;\n\tdec->image = 0;\n\n\tjp2_dec_destroy(dec);\n\n\treturn image;\n\nerror:\n\tif (box) {\n\t\tjp2_box_destroy(box);\n\t}\n\tif (dec) {\n\t\tjp2_dec_destroy(dec);\n\t}\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static int jas_cmshapmatlut_invert(jas_cmshapmatlut_t *invlut,\n  jas_cmshapmatlut_t *lut, int n)\n{\n\tint i;\n\tint j;\n\tint k;\n\tjas_cmreal_t ax;\n\tjas_cmreal_t ay;\n\tjas_cmreal_t bx;\n\tjas_cmreal_t by;\n\tjas_cmreal_t sx;\n\tjas_cmreal_t sy;\n\tassert(n >= 2);\n\tif (invlut->data) {\n\t\tjas_free(invlut->data);\n\t\tinvlut->data = 0;\n\t}\n\t/* The sample values should be nondecreasing. */\n\tfor (i = 1; i < lut->size; ++i) {\n\t\tif (lut->data[i - 1] > lut->data[i]) {\n\t\t\tassert(0);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (!(invlut->data = jas_malloc(n * sizeof(jas_cmreal_t))))\n\t\treturn -1;\n\tinvlut->size = n;\n\tfor (i = 0; i < invlut->size; ++i) {\n\t\tsy = ((double) i) / (invlut->size - 1);\n\t\tsx = 1.0;\n\t\tfor (j = 0; j < lut->size; ++j) {\n\t\t\tay = lut->data[j];\n\t\t\tif (sy == ay) {\n\t\t\t\tfor (k = j + 1; k < lut->size; ++k) {\n\t\t\t\t\tby = lut->data[k];\n\t\t\t\t\tif (by != sy)\n\t\t\t\t\t\tbreak;\n#if 0\nassert(0);\n#endif\n\t\t\t\t}\n\t\t\t\tif (k < lut->size) {\n\t\t\t\t\t--k;\n\t\t\t\t\tax = ((double) j) / (lut->size - 1);\n\t\t\t\t\tbx = ((double) k) / (lut->size - 1);\n\t\t\t\t\tsx = (ax + bx) / 2.0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (j < lut->size - 1) {\n\t\t\t\tby = lut->data[j + 1];\n\t\t\t\tif (sy > ay && sy < by) {\n\t\t\t\t\tax = ((double) j) / (lut->size - 1);\n\t\t\t\t\tbx = ((double) j + 1) / (lut->size - 1);\n\t\t\t\t\tsx = ax +\n\t\t\t\t\t  (sy - ay) / (by - ay) * (bx - ax);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tinvlut->data[i] = sx;\n\t}\n#if 0\nfor (i=0;i<lut->size;++i)\n\tjas_eprintf(\"lut[%d]=%f \", i, lut->data[i]);\nfor (i=0;i<invlut->size;++i)\n\tjas_eprintf(\"invlut[%d]=%f \", i, invlut->data[i]);\n#endif\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static int jpc_crg_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_crg_t *crg = &ms->parms.crg;\n\tjpc_crgcomp_t *comp;\n\tuint_fast16_t compno;\n\tcrg->numcomps = cstate->numcomps;\n\tif (!(crg->comps = jas_malloc(cstate->numcomps * sizeof(uint_fast16_t)))) {\n\t\treturn -1;\n\t}\n\tfor (compno = 0, comp = crg->comps; compno < cstate->numcomps;\n\t  ++compno, ++comp) {\n\t\tif (jpc_getuint16(in, &comp->hoff) ||\n\t\t  jpc_getuint16(in, &comp->voff)) {\n\t\t\tjpc_crg_destroyparms(ms);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "int jp2_encode(jas_image_t *image, jas_stream_t *out, char *optstr)\n{\n\tjp2_box_t *box;\n\tjp2_ftyp_t *ftyp;\n\tjp2_ihdr_t *ihdr;\n\tjas_stream_t *tmpstream;\n\tint allcmptssame;\n\tjp2_bpcc_t *bpcc;\n\tlong len;\n\tuint_fast16_t cmptno;\n\tjp2_colr_t *colr;\n\tchar buf[4096];\n\tuint_fast32_t overhead;\n\tjp2_cdefchan_t *cdefchanent;\n\tjp2_cdef_t *cdef;\n\tint i;\n\tuint_fast32_t typeasoc;\njas_iccprof_t *iccprof;\njas_stream_t *iccstream;\nint pos;\nint needcdef;\nint prec;\nint sgnd;\n\n\tbox = 0;\n\ttmpstream = 0;\n\n\tallcmptssame = 1;\n\tsgnd = jas_image_cmptsgnd(image, 0);\n\tprec = jas_image_cmptprec(image, 0);\n\tfor (i = 1; i < jas_image_numcmpts(image); ++i) {\n\t\tif (jas_image_cmptsgnd(image, i) != sgnd ||\n\t\t  jas_image_cmptprec(image, i) != prec) {\n\t\t\tallcmptssame = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Output the signature box. */\n\n\tif (!(box = jp2_box_create(JP2_BOX_JP))) {\n\t\tgoto error;\n\t}\n\tbox->data.jp.magic = JP2_JP_MAGIC;\n\tif (jp2_box_put(box, out)) {\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/* Output the file type box. */\n\n\tif (!(box = jp2_box_create(JP2_BOX_FTYP))) {\n\t\tgoto error;\n\t}\n\tftyp = &box->data.ftyp;\n\tftyp->majver = JP2_FTYP_MAJVER;\n\tftyp->minver = JP2_FTYP_MINVER;\n\tftyp->numcompatcodes = 1;\n\tftyp->compatcodes[0] = JP2_FTYP_COMPATCODE;\n\tif (jp2_box_put(box, out)) {\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/*\n\t * Generate the data portion of the JP2 header box.\n\t * We cannot simply output the header for this box\n\t * since we do not yet know the correct value for the length\n\t * field.\n\t */\n\n\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n\t\tgoto error;\n\t}\n\n\t/* Generate image header box. */\n\n\tif (!(box = jp2_box_create(JP2_BOX_IHDR))) {\n\t\tgoto error;\n\t}\n\tihdr = &box->data.ihdr;\n\tihdr->width = jas_image_width(image);\n\tihdr->height = jas_image_height(image);\n\tihdr->numcmpts = jas_image_numcmpts(image);\n\tihdr->bpc = allcmptssame ? JP2_SPTOBPC(jas_image_cmptsgnd(image, 0),\n\t  jas_image_cmptprec(image, 0)) : JP2_IHDR_BPCNULL;\n\tihdr->comptype = JP2_IHDR_COMPTYPE;\n\tihdr->csunk = 0;\n\tihdr->ipr = 0;\n\tif (jp2_box_put(box, tmpstream)) {\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/* Generate bits per component box. */\n\n\tif (!allcmptssame) {\n\t\tif (!(box = jp2_box_create(JP2_BOX_BPCC))) {\n\t\t\tgoto error;\n\t\t}\n\t\tbpcc = &box->data.bpcc;\n\t\tbpcc->numcmpts = jas_image_numcmpts(image);\n\t\tif (!(bpcc->bpcs = jas_malloc(bpcc->numcmpts *\n\t\t  sizeof(uint_fast8_t)))) {\n\t\t\tgoto error;\n\t\t}\n\t\tfor (cmptno = 0; cmptno < bpcc->numcmpts; ++cmptno) {\n\t\t\tbpcc->bpcs[cmptno] = JP2_SPTOBPC(jas_image_cmptsgnd(image,\n\t\t\t  cmptno), jas_image_cmptprec(image, cmptno));\n\t\t}\n\t\tif (jp2_box_put(box, tmpstream)) {\n\t\t\tgoto error;\n\t\t}\n\t\tjp2_box_destroy(box);\n\t\tbox = 0;\n\t}\n\n\t/* Generate color specification box. */\n\n\tif (!(box = jp2_box_create(JP2_BOX_COLR))) {\n\t\tgoto error;\n\t}\n\tcolr = &box->data.colr;\n\tswitch (jas_image_clrspc(image)) {\n\tcase JAS_CLRSPC_SRGB:\n\tcase JAS_CLRSPC_SYCBCR:\n\tcase JAS_CLRSPC_SGRAY:\n\t\tcolr->method = JP2_COLR_ENUM;\n\t\tcolr->csid = clrspctojp2(jas_image_clrspc(image));\n\t\tcolr->pri = JP2_COLR_PRI;\n\t\tcolr->approx = 0;\n\t\tbreak;\n\tdefault:\n\t\tcolr->method = JP2_COLR_ICC;\n\t\tcolr->pri = JP2_COLR_PRI;\n\t\tcolr->approx = 0;\n\t\ticcprof = jas_iccprof_createfromcmprof(jas_image_cmprof(image));\n\t\tassert(iccprof);\n\t\ticcstream = jas_stream_memopen(0, 0);\n\t\tassert(iccstream);\n\t\tif (jas_iccprof_save(iccprof, iccstream))\n\t\t\tabort();\n\t\tif ((pos = jas_stream_tell(iccstream)) < 0)\n\t\t\tabort();\n\t\tcolr->iccplen = pos;\n\t\tcolr->iccp = jas_malloc(pos);\n\t\tassert(colr->iccp);\n\t\tjas_stream_rewind(iccstream);\n\t\tif (jas_stream_read(iccstream, colr->iccp, colr->iccplen) != colr->iccplen)\n\t\t\tabort();\n\t\tjas_stream_close(iccstream);\n\t\tjas_iccprof_destroy(iccprof);\n\t\tbreak;\n\t}\n\tif (jp2_box_put(box, tmpstream)) {\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\tneedcdef = 1;\n\tswitch (jas_clrspc_fam(jas_image_clrspc(image))) {\n\tcase JAS_CLRSPC_FAM_RGB:\n\t\tif (jas_image_cmpttype(image, 0) ==\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R) &&\n\t\t  jas_image_cmpttype(image, 1) ==\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G) &&\n\t\t  jas_image_cmpttype(image, 2) ==\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B))\n\t\t\tneedcdef = 0;\n\t\tbreak;\n\tcase JAS_CLRSPC_FAM_YCBCR:\n\t\tif (jas_image_cmpttype(image, 0) ==\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_YCBCR_Y) &&\n\t\t  jas_image_cmpttype(image, 1) ==\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_YCBCR_CB) &&\n\t\t  jas_image_cmpttype(image, 2) ==\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_YCBCR_CR))\n\t\t\tneedcdef = 0;\n\t\tbreak;\n\tcase JAS_CLRSPC_FAM_GRAY:\n\t\tif (jas_image_cmpttype(image, 0) ==\n\t\t  JAS_IMAGE_CT_COLOR(JAS_IMAGE_CT_GRAY_Y))\n\t\t\tneedcdef = 0;\n\t\tbreak;\n\tdefault:\n\t\tabort();\n\t\tbreak;\n\t}\n\n\tif (needcdef) {\n\t\tif (!(box = jp2_box_create(JP2_BOX_CDEF))) {\n\t\t\tgoto error;\n\t\t}\n\t\tcdef = &box->data.cdef;\n\t\tcdef->numchans = jas_image_numcmpts(image);\n\t\tcdef->ents = jas_malloc(cdef->numchans * sizeof(jp2_cdefchan_t));\n\t\tfor (i = 0; i < jas_image_numcmpts(image); ++i) {\n\t\t\tcdefchanent = &cdef->ents[i];\n\t\t\tcdefchanent->channo = i;\n\t\t\ttypeasoc = jp2_gettypeasoc(jas_image_clrspc(image), jas_image_cmpttype(image, i));\n\t\t\tcdefchanent->type = typeasoc >> 16;\n\t\t\tcdefchanent->assoc = typeasoc & 0x7fff;\n\t\t}\n\t\tif (jp2_box_put(box, tmpstream)) {\n\t\t\tgoto error;\n\t\t}\n\t\tjp2_box_destroy(box);\n\t\tbox = 0;\n\t}\n\n\t/* Determine the total length of the JP2 header box. */\n\n\tlen = jas_stream_tell(tmpstream);\n\tjas_stream_rewind(tmpstream);\n\n\t/*\n\t * Output the JP2 header box and all of the boxes which it contains.\n\t */\n\n\tif (!(box = jp2_box_create(JP2_BOX_JP2H))) {\n\t\tgoto error;\n\t}\n\tbox->len = len + JP2_BOX_HDRLEN(false);\n\tif (jp2_box_put(box, out)) {\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\tif (jas_stream_copy(out, tmpstream, len)) {\n\t\tgoto error;\n\t}\n\n\tjas_stream_close(tmpstream);\n\ttmpstream = 0;\n\n\t/*\n\t * Output the contiguous code stream box.\n\t */\n\n\tif (!(box = jp2_box_create(JP2_BOX_JP2C))) {\n\t\tgoto error;\n\t}\n\tbox->len = 0;\n\tif (jp2_box_put(box, out)) {\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/* Output the JPEG-2000 code stream. */\n\n\toverhead = jas_stream_getrwcount(out);\n\tsprintf(buf, \"%s\\n_jp2overhead=%lu\\n\", (optstr ? optstr : \"\"),\n\t  (unsigned long) overhead);\n\n\tif (jpc_encode(image, out, buf)) {\n\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\n\tif (box) {\n\t\tjp2_box_destroy(box);\n\t}\n\tif (tmpstream) {\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn -1;\n}",
        "target": 1
    },
    {
        "func": "void jpc_qmfb_join_row(jpc_fix_t *a, int numcols, int parity)\n{\n\n\tint bufsize = JPC_CEILDIVPOW2(numcols, 1);\n\tjpc_fix_t joinbuf[QMFB_JOINBUFSIZE];\n\tjpc_fix_t *buf = joinbuf;\n\tregister jpc_fix_t *srcptr;\n\tregister jpc_fix_t *dstptr;\n\tregister int n;\n\tint hstartcol;\n\n\t/* Allocate memory for the join buffer from the heap. */\n\tif (bufsize > QMFB_JOINBUFSIZE) {\n\t\tif (!(buf = jas_malloc(bufsize * sizeof(jpc_fix_t)))) {\n\t\t\t/* We have no choice but to commit suicide. */\n\t\t\tabort();\n\t\t}\n\t}\n\n\thstartcol = (numcols + 1 - parity) >> 1;\n\n\t/* Save the samples from the lowpass channel. */\n\tn = hstartcol;\n\tsrcptr = &a[0];\n\tdstptr = buf;\n\twhile (n-- > 0) {\n\t\t*dstptr = *srcptr;\n\t\t++srcptr;\n\t\t++dstptr;\n\t}\n\t/* Copy the samples from the highpass channel into place. */\n\tsrcptr = &a[hstartcol];\n\tdstptr = &a[1 - parity];\n\tn = numcols - hstartcol;\n\twhile (n-- > 0) {\n\t\t*dstptr = *srcptr;\n\t\tdstptr += 2;\n\t\t++srcptr;\n\t}\n\t/* Copy the samples from the lowpass channel into place. */\n\tsrcptr = buf;\n\tdstptr = &a[parity];\n\tn = hstartcol;\n\twhile (n-- > 0) {\n\t\t*dstptr = *srcptr;\n\t\tdstptr += 2;\n\t\t++srcptr;\n\t}\n\n\t/* If the join buffer was allocated on the heap, free this memory. */\n\tif (buf != joinbuf) {\n\t\tjas_free(buf);\n\t}\n\n}",
        "target": 1
    },
    {
        "func": "int jpc_streamlist_insert(jpc_streamlist_t *streamlist, int streamno,\n  jas_stream_t *stream)\n{\n\tjas_stream_t **newstreams;\n\tint newmaxstreams;\n\tint i;\n\t/* Grow the array of streams if necessary. */\n\tif (streamlist->numstreams >= streamlist->maxstreams) {\n\t\tnewmaxstreams = streamlist->maxstreams + 1024;\n\t\tif (!(newstreams = jas_realloc(streamlist->streams,\n\t\t  (newmaxstreams + 1024) * sizeof(jas_stream_t *)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (i = streamlist->numstreams; i < streamlist->maxstreams; ++i) {\n\t\t\tstreamlist->streams[i] = 0;\n\t\t}\n\t\tstreamlist->maxstreams = newmaxstreams;\n\t\tstreamlist->streams = newstreams;\n\t}\n\tif (streamno != streamlist->numstreams) {\n\t\t/* Can only handle insertion at start of list. */\n\t\treturn -1;\n\t}\n\tstreamlist->streams[streamno] = stream;\n\t++streamlist->numstreams;\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "jpc_enc_tile_t *jpc_enc_tile_create(jpc_enc_cp_t *cp, jas_image_t *image, int tileno)\n{\n\tjpc_enc_tile_t *tile;\n\tuint_fast32_t htileno;\n\tuint_fast32_t vtileno;\n\tuint_fast16_t lyrno;\n\tuint_fast16_t cmptno;\n\tjpc_enc_tcmpt_t *tcmpt;\n\n\tif (!(tile = jas_malloc(sizeof(jpc_enc_tile_t)))) {\n\t\tgoto error;\n\t}\n\n\t/* Initialize a few members used in error recovery. */\n\ttile->tcmpts = 0;\n\ttile->lyrsizes = 0;\n\ttile->numtcmpts = cp->numcmpts;\n\ttile->pi = 0;\n\n\ttile->tileno = tileno;\n\thtileno = tileno % cp->numhtiles;\n\tvtileno = tileno / cp->numhtiles;\n\n\t/* Calculate the coordinates of the top-left and bottom-right\n\t  corners of the tile. */\n\ttile->tlx = JAS_MAX(cp->tilegrdoffx + htileno * cp->tilewidth,\n\t  cp->imgareatlx);\n\ttile->tly = JAS_MAX(cp->tilegrdoffy + vtileno * cp->tileheight,\n\t  cp->imgareatly);\n\ttile->brx = JAS_MIN(cp->tilegrdoffx + (htileno + 1) * cp->tilewidth,\n\t  cp->refgrdwidth);\n\ttile->bry = JAS_MIN(cp->tilegrdoffy + (vtileno + 1) * cp->tileheight,\n\t  cp->refgrdheight);\n\n\t/* Initialize some tile coding parameters. */\n\ttile->intmode = cp->tcp.intmode;\n\ttile->csty = cp->tcp.csty;\n\ttile->prg = cp->tcp.prg;\n\ttile->mctid = cp->tcp.mctid;\n\n\ttile->numlyrs = cp->tcp.numlyrs;\n\tif (!(tile->lyrsizes = jas_malloc(tile->numlyrs *\n\t  sizeof(uint_fast32_t)))) {\n\t\tgoto error;\n\t}\n\tfor (lyrno = 0; lyrno < tile->numlyrs; ++lyrno) {\n\t\ttile->lyrsizes[lyrno] = 0;\n\t}\n\n\t/* Allocate an array for the per-tile-component information. */\n\tif (!(tile->tcmpts = jas_malloc(cp->numcmpts * sizeof(jpc_enc_tcmpt_t)))) {\n\t\tgoto error;\n\t}\n\t/* Initialize a few members critical for error recovery. */\n\tfor (cmptno = 0, tcmpt = tile->tcmpts; cmptno < cp->numcmpts;\n\t  ++cmptno, ++tcmpt) {\n\t\ttcmpt->rlvls = 0;\n\t\ttcmpt->tsfb = 0;\n\t\ttcmpt->data = 0;\n\t}\n\t/* Initialize the per-tile-component information. */\n\tfor (cmptno = 0, tcmpt = tile->tcmpts; cmptno < cp->numcmpts;\n\t  ++cmptno, ++tcmpt) {\n\t\tif (!tcmpt_create(tcmpt, cp, image, tile)) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t/* Initialize the synthesis weights for the MCT. */\n\tswitch (tile->mctid) {\n\tcase JPC_MCT_RCT:\n\t\ttile->tcmpts[0].synweight = jpc_dbltofix(sqrt(3.0));\n\t\ttile->tcmpts[1].synweight = jpc_dbltofix(sqrt(0.6875));\n\t\ttile->tcmpts[2].synweight = jpc_dbltofix(sqrt(0.6875));\n\t\tbreak;\n\tcase JPC_MCT_ICT:\n\t\ttile->tcmpts[0].synweight = jpc_dbltofix(sqrt(3.0000));\n\t\ttile->tcmpts[1].synweight = jpc_dbltofix(sqrt(3.2584));\n\t\ttile->tcmpts[2].synweight = jpc_dbltofix(sqrt(2.4755));\n\t\tbreak;\n\tdefault:\n\tcase JPC_MCT_NONE:\n\t\tfor (cmptno = 0, tcmpt = tile->tcmpts; cmptno < cp->numcmpts;\n\t\t  ++cmptno, ++tcmpt) {\n\t\t\ttcmpt->synweight = JPC_FIX_ONE;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (!(tile->pi = jpc_enc_pi_create(cp, tile))) {\n\t\tgoto error;\n\t}\n\n\treturn tile;\n\nerror:\n\n\tif (tile) {\n\t\tjpc_enc_tile_destroy(tile);\n\t}\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "jpc_tagtree_t *jpc_tagtree_create(int numleafsh, int numleafsv)\n{\n\tint nplh[JPC_TAGTREE_MAXDEPTH];\n\tint nplv[JPC_TAGTREE_MAXDEPTH];\n\tjpc_tagtreenode_t *node;\n\tjpc_tagtreenode_t *parentnode;\n\tjpc_tagtreenode_t *parentnode0;\n\tjpc_tagtree_t *tree;\n\tint i;\n\tint j;\n\tint k;\n\tint numlvls;\n\tint n;\n\n\tassert(numleafsh > 0 && numleafsv > 0);\n\n\tif (!(tree = jpc_tagtree_alloc())) {\n\t\treturn 0;\n\t}\n\ttree->numleafsh_ = numleafsh;\n\ttree->numleafsv_ = numleafsv;\n\n\tnumlvls = 0;\n\tnplh[0] = numleafsh;\n\tnplv[0] = numleafsv;\n\tdo {\n\t\tn = nplh[numlvls] * nplv[numlvls];\n\t\tnplh[numlvls + 1] = (nplh[numlvls] + 1) / 2;\n\t\tnplv[numlvls + 1] = (nplv[numlvls] + 1) / 2;\n\t\ttree->numnodes_ += n;\n\t\t++numlvls;\n\t} while (n > 1);\n\n\tif (!(tree->nodes_ = jas_malloc(tree->numnodes_ * sizeof(jpc_tagtreenode_t)))) {\n\t\treturn 0;\n\t}\n\n\t/* Initialize the parent links for all nodes in the tree. */\n\n\tnode = tree->nodes_;\n\tparentnode = &tree->nodes_[tree->numleafsh_ * tree->numleafsv_];\n\tparentnode0 = parentnode;\n\n\tfor (i = 0; i < numlvls - 1; ++i) {\n\t\tfor (j = 0; j < nplv[i]; ++j) {\n\t\t\tk = nplh[i];\n\t\t\twhile (--k >= 0) {\n\t\t\t\tnode->parent_ = parentnode;\n\t\t\t\t++node;\n\t\t\t\tif (--k >= 0) {\n\t\t\t\t\tnode->parent_ = parentnode;\n\t\t\t\t\t++node;\n\t\t\t\t}\n\t\t\t\t++parentnode;\n\t\t\t}\n\t\t\tif ((j & 1) || j == nplv[i] - 1) {\n\t\t\t\tparentnode0 = parentnode;\n\t\t\t} else {\n\t\t\t\tparentnode = parentnode0;\n\t\t\t\tparentnode0 += nplh[i];\n\t\t\t}\n\t\t}\n\t}\n\tnode->parent_ = 0;\n\n\t/* Initialize the data values to something sane. */\n\n\tjpc_tagtree_reset(tree);\n\n\treturn tree;\n}",
        "target": 1
    },
    {
        "func": "static jpc_dec_cp_t *jpc_dec_cp_create(uint_fast16_t numcomps)\n{\n\tjpc_dec_cp_t *cp;\n\tjpc_dec_ccp_t *ccp;\n\tint compno;\n\n\tif (!(cp = jas_malloc(sizeof(jpc_dec_cp_t)))) {\n\t\treturn 0;\n\t}\n\tcp->flags = 0;\n\tcp->numcomps = numcomps;\n\tcp->prgord = 0;\n\tcp->numlyrs = 0;\n\tcp->mctid = 0;\n\tcp->csty = 0;\n\tif (!(cp->ccps = jas_malloc(cp->numcomps * sizeof(jpc_dec_ccp_t)))) {\n\t\treturn 0;\n\t}\n\tif (!(cp->pchglist = jpc_pchglist_create())) {\n\t\tjas_free(cp->ccps);\n\t\treturn 0;\n\t}\n\tfor (compno = 0, ccp = cp->ccps; compno < cp->numcomps;\n\t  ++compno, ++ccp) {\n\t\tccp->flags = 0;\n\t\tccp->numrlvls = 0;\n\t\tccp->cblkwidthexpn = 0;\n\t\tccp->cblkheightexpn = 0;\n\t\tccp->qmfbid = 0;\n\t\tccp->numstepsizes = 0;\n\t\tccp->numguardbits = 0;\n\t\tccp->roishift = 0;\n\t\tccp->cblkctx = 0;\n\t}\n\treturn cp;\n}",
        "target": 1
    },
    {
        "func": "int jpc_pchglist_insert(jpc_pchglist_t *pchglist, int pchgno, jpc_pchg_t *pchg)\n{\n\tint i;\n\tint newmaxpchgs;\n\tjpc_pchg_t **newpchgs;\n\tif (pchgno < 0) {\n\t\tpchgno = pchglist->numpchgs;\n\t}\n\tif (pchglist->numpchgs >= pchglist->maxpchgs) {\n\t\tnewmaxpchgs = pchglist->maxpchgs + 128;\n\t\tif (!(newpchgs = jas_realloc(pchglist->pchgs, newmaxpchgs * sizeof(jpc_pchg_t *)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tpchglist->maxpchgs = newmaxpchgs;\n\t\tpchglist->pchgs = newpchgs;\n\t}\n\tfor (i = pchglist->numpchgs; i > pchgno; --i) {\n\t\tpchglist->pchgs[i] = pchglist->pchgs[i - 1];\n\t}\n\tpchglist->pchgs[pchgno] = pchg;\n\t++pchglist->numpchgs;\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static int jpc_unk_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_unk_t *unk = &ms->parms.unk;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tif (ms->len > 0) {\n\t\tif (!(unk->data = jas_malloc(ms->len * sizeof(unsigned char)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (jas_stream_read(in, (char *) unk->data, ms->len) != JAS_CAST(int, ms->len)) {\n\t\t\tjas_free(unk->data);\n\t\t\treturn -1;\n\t\t}\n\t\tunk->len = ms->len;\n\t} else {\n\t\tunk->data = 0;\n\t\tunk->len = 0;\n\t}\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "int jpc_enc_enccblk(jpc_enc_t *enc, jas_stream_t *out, jpc_enc_tcmpt_t *tcmpt, jpc_enc_band_t *band, jpc_enc_cblk_t *cblk)\n{\n\tjpc_enc_pass_t *pass;\n\tjpc_enc_pass_t *endpasses;\n\tint bitpos;\n\tint n;\n\tint adjust;\n\tint ret;\n\tint passtype;\n\tint t;\n\tjpc_bitstream_t *bout;\n\tjpc_enc_pass_t *termpass;\n\tjpc_enc_rlvl_t *rlvl;\n\tint vcausal;\n\tint segsym;\n\tint termmode;\n\tint c;\n\n\tbout = 0;\n\trlvl = band->rlvl;\n\n\tcblk->stream = jas_stream_memopen(0, 0);\n\tassert(cblk->stream);\n\tcblk->mqenc = jpc_mqenc_create(JPC_NUMCTXS, cblk->stream);\n\tassert(cblk->mqenc);\n\tjpc_mqenc_setctxs(cblk->mqenc, JPC_NUMCTXS, jpc_mqctxs);\n\n\tcblk->numpasses = (cblk->numbps > 0) ? (3 * cblk->numbps - 2) : 0;\n\tif (cblk->numpasses > 0) {\n\t\tcblk->passes = jas_malloc(cblk->numpasses * sizeof(jpc_enc_pass_t));\n\t\tassert(cblk->passes);\n\t} else {\n\t\tcblk->passes = 0;\n\t}\n\tendpasses = (cblk->passes) ? &cblk->passes[cblk->numpasses] : 0;\n\tfor (pass = cblk->passes; pass != endpasses; ++pass) {\n\t\tpass->start = 0;\n\t\tpass->end = 0;\n\t\tpass->term = JPC_ISTERMINATED(pass - cblk->passes, 0, cblk->numpasses, (tcmpt->cblksty & JPC_COX_TERMALL) != 0, (tcmpt->cblksty & JPC_COX_LAZY) != 0);\n\t\tpass->type = JPC_SEGTYPE(pass - cblk->passes, 0, (tcmpt->cblksty & JPC_COX_LAZY) != 0);\n\t\tpass->lyrno = -1;\nif (pass == endpasses - 1) {\nassert(pass->term == 1);\n\tpass->term = 1;\n}\n\t}\n\n\tcblk->flags = jas_matrix_create(jas_matrix_numrows(cblk->data) + 2,\n\t  jas_matrix_numcols(cblk->data) + 2);\n\tassert(cblk->flags);\n\n\n\tbitpos = cblk->numbps - 1;\n\tpass = cblk->passes;\n\tn = cblk->numpasses;\n\twhile (--n >= 0) {\n\n\t\tif (pass->type == JPC_SEG_MQ) {\n\t\t\t/* NOP */\n\t\t} else {\n\t\t\tassert(pass->type == JPC_SEG_RAW);\n\t\t\tif (!bout) {\n\t\t\t\tbout = jpc_bitstream_sopen(cblk->stream, \"w\");\n\t\t\t\tassert(bout);\n\t\t\t}\n\t\t}\n\n#if 1\n\t\tpasstype = (pass - cblk->passes + 2) % 3;\n#else\n\t\tpasstype = JPC_PASSTYPE(pass - cblk->passes + 2);\n#endif\n\t\tpass->start = jas_stream_tell(cblk->stream);\n#if 0\nassert(jas_stream_tell(cblk->stream) == jas_stream_getrwcount(cblk->stream));\n#endif\n\t\tassert(bitpos >= 0);\n\t\tvcausal = (tcmpt->cblksty & JPC_COX_VSC) != 0;\n\t\tsegsym = (tcmpt->cblksty & JPC_COX_SEGSYM) != 0;\n\t\tif (pass->term) {\n\t\t\ttermmode = ((tcmpt->cblksty & JPC_COX_PTERM) ?\n\t\t\t  JPC_MQENC_PTERM : JPC_MQENC_DEFTERM) + 1;\n\t\t} else {\n\t\t\ttermmode = 0;\n\t\t}\n\t\tswitch (passtype) {\n\t\tcase JPC_SIGPASS:\n\t\t\tret = (pass->type == JPC_SEG_MQ) ? jpc_encsigpass(cblk->mqenc,\n\t\t\t  bitpos, band->orient, vcausal, cblk->flags,\n\t\t\t  cblk->data, termmode, &pass->nmsedec) :\n\t\t\t  jpc_encrawsigpass(bout, bitpos, vcausal, cblk->flags,\n\t\t\t  cblk->data, termmode, &pass->nmsedec);\n\t\t\tbreak;\n\t\tcase JPC_REFPASS:\n\t\t\tret = (pass->type == JPC_SEG_MQ) ? jpc_encrefpass(cblk->mqenc,\n\t\t\t  bitpos, vcausal, cblk->flags, cblk->data, termmode,\n\t\t\t  &pass->nmsedec) : jpc_encrawrefpass(bout, bitpos,\n\t\t\t  vcausal, cblk->flags, cblk->data, termmode,\n\t\t\t  &pass->nmsedec);\n\t\t\tbreak;\n\t\tcase JPC_CLNPASS:\n\t\t\tassert(pass->type == JPC_SEG_MQ);\n\t\t\tret = jpc_encclnpass(cblk->mqenc, bitpos, band->orient,\n\t\t\t  vcausal, segsym, cblk->flags, cblk->data, termmode,\n\t\t\t  &pass->nmsedec);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(0);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (pass->type == JPC_SEG_MQ) {\n\t\t\tif (pass->term) {\n\t\t\t\tjpc_mqenc_init(cblk->mqenc);\n\t\t\t}\n\t\t\tjpc_mqenc_getstate(cblk->mqenc, &pass->mqencstate);\n\t\t\tpass->end = jas_stream_tell(cblk->stream);\n\t\t\tif (tcmpt->cblksty & JPC_COX_RESET) {\n\t\t\t\tjpc_mqenc_setctxs(cblk->mqenc, JPC_NUMCTXS, jpc_mqctxs);\n\t\t\t}\n\t\t} else {\n\t\t\tif (pass->term) {\n\t\t\t\tif (jpc_bitstream_pending(bout)) {\n\t\t\t\t\tjpc_bitstream_outalign(bout, 0x2a);\n\t\t\t\t}\n\t\t\t\tjpc_bitstream_close(bout);\n\t\t\t\tbout = 0;\n\t\t\t\tpass->end = jas_stream_tell(cblk->stream);\n\t\t\t} else {\n\t\t\t\tpass->end = jas_stream_tell(cblk->stream) +\n\t\t\t\t  jpc_bitstream_pending(bout);\n/* NOTE - This will not work.  need to adjust by # of pending output bytes */\n\t\t\t}\n\t\t}\n#if 0\n/* XXX - This assertion fails sometimes when various coding modes are used.\nThis seems to be harmless, but why does it happen at all? */\nassert(jas_stream_tell(cblk->stream) == jas_stream_getrwcount(cblk->stream));\n#endif\n\n\t\tpass->wmsedec = jpc_fixtodbl(band->rlvl->tcmpt->synweight) *\n\t\t  jpc_fixtodbl(band->rlvl->tcmpt->synweight) *\n\t\t  jpc_fixtodbl(band->synweight) *\n\t\t  jpc_fixtodbl(band->synweight) *\n\t\t  jpc_fixtodbl(band->absstepsize) * jpc_fixtodbl(band->absstepsize) *\n\t\t  ((double) (1 << bitpos)) * ((double)(1 << bitpos)) *\n\t\t  jpc_fixtodbl(pass->nmsedec);\n\t\tpass->cumwmsedec = pass->wmsedec;\n\t\tif (pass != cblk->passes) {\n\t\t\tpass->cumwmsedec += pass[-1].cumwmsedec;\n\t\t}\n\t\tif (passtype == JPC_CLNPASS) {\n\t\t\t--bitpos;\n\t\t}\n\t\t++pass;\n\t}\n\n#if 0\ndump_passes(cblk->passes, cblk->numpasses, cblk);\n#endif\n\n\tn = 0;\n\tendpasses = (cblk->passes) ? &cblk->passes[cblk->numpasses] : 0;\n\tfor (pass = cblk->passes; pass != endpasses; ++pass) {\n\t\tif (pass->start < n) {\n\t\t\tpass->start = n;\n\t\t}\n\t\tif (pass->end < n) {\n\t\t\tpass->end = n;\n\t\t}\n\t\tif (!pass->term) {\n\t\t\ttermpass = pass;\n\t\t\twhile (termpass - pass < cblk->numpasses &&\n\t\t\t  !termpass->term) {\n\t\t\t\t++termpass;\n\t\t\t}\n\t\t\tif (pass->type == JPC_SEG_MQ) {\n\t\t\t\tt = (pass->mqencstate.lastbyte == 0xff) ? 1 : 0;\n\t\t\t\tif (pass->mqencstate.ctreg >= 5) {\n\t\t\t\t\tadjust = 4 + t;\n\t\t\t\t} else {\n\t\t\t\t\tadjust = 5 + t;\n\t\t\t\t}\n\t\t\t\tpass->end += adjust;\n\t\t\t}\n\t\t\tif (pass->end > termpass->end) {\n\t\t\t\tpass->end = termpass->end;\n\t\t\t}\n\t\t\tif ((c = getthebyte(cblk->stream, pass->end - 1)) == EOF) {\n\t\t\t\tabort();\n\t\t\t}\n\t\t\tif (c == 0xff) {\n\t\t\t\t++pass->end;\n\t\t\t}\n\t\t\tn = JAS_MAX(n, pass->end);\n\t\t} else {\n\t\t\tn = JAS_MAX(n, pass->end);\n\t\t}\n\t}\n\n#if 0\ndump_passes(cblk->passes, cblk->numpasses, cblk);\n#endif\n\n\tif (bout) {\n\t\tjpc_bitstream_close(bout);\n\t}\n\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static jpc_enc_cp_t *cp_create(char *optstr, jas_image_t *image)\n{\n\tjpc_enc_cp_t *cp;\n\tjas_tvparser_t *tvp;\n\tint ret;\n\tint numilyrrates;\n\tdouble *ilyrrates;\n\tint i;\n\tint tagid;\n\tjpc_enc_tcp_t *tcp;\n\tjpc_enc_tccp_t *tccp;\n\tjpc_enc_ccp_t *ccp;\n\tint cmptno;\n\tuint_fast16_t rlvlno;\n\tuint_fast16_t prcwidthexpn;\n\tuint_fast16_t prcheightexpn;\n\tbool enablemct;\n\tuint_fast32_t jp2overhead;\n\tuint_fast16_t lyrno;\n\tuint_fast32_t hsteplcm;\n\tuint_fast32_t vsteplcm;\n\tbool mctvalid;\n\n\ttvp = 0;\n\tcp = 0;\n\tilyrrates = 0;\n\tnumilyrrates = 0;\n\n\tif (!(cp = jas_malloc(sizeof(jpc_enc_cp_t)))) {\n\t\tgoto error;\n\t}\n\n\tprcwidthexpn = 15;\n\tprcheightexpn = 15;\n\tenablemct = true;\n\tjp2overhead = 0;\n\n\tcp->ccps = 0;\n\tcp->debug = 0;\n\tcp->imgareatlx = UINT_FAST32_MAX;\n\tcp->imgareatly = UINT_FAST32_MAX;\n\tcp->refgrdwidth = 0;\n\tcp->refgrdheight = 0;\n\tcp->tilegrdoffx = UINT_FAST32_MAX;\n\tcp->tilegrdoffy = UINT_FAST32_MAX;\n\tcp->tilewidth = 0;\n\tcp->tileheight = 0;\n\tcp->numcmpts = jas_image_numcmpts(image);\n\n\thsteplcm = 1;\n\tvsteplcm = 1;\n\tfor (cmptno = 0; cmptno < jas_image_numcmpts(image); ++cmptno) {\n\t\tif (jas_image_cmptbrx(image, cmptno) + jas_image_cmpthstep(image, cmptno) <=\n\t\t  jas_image_brx(image) || jas_image_cmptbry(image, cmptno) +\n\t\t  jas_image_cmptvstep(image, cmptno) <= jas_image_bry(image)) {\n\t\t\tjas_eprintf(\"unsupported image type\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\t/* Note: We ought to be calculating the LCMs here.  Fix some day. */\n\t\thsteplcm *= jas_image_cmpthstep(image, cmptno);\n\t\tvsteplcm *= jas_image_cmptvstep(image, cmptno);\n\t}\n\n\tif (!(cp->ccps = jas_malloc(cp->numcmpts * sizeof(jpc_enc_ccp_t)))) {\n\t\tgoto error;\n\t}\n\tfor (cmptno = 0, ccp = cp->ccps; cmptno < JAS_CAST(int, cp->numcmpts); ++cmptno,\n\t  ++ccp) {\n\t\tccp->sampgrdstepx = jas_image_cmpthstep(image, cmptno);\n\t\tccp->sampgrdstepy = jas_image_cmptvstep(image, cmptno);\n\t\t/* XXX - this isn't quite correct for more general image */\n\t\tccp->sampgrdsubstepx = 0;\n\t\tccp->sampgrdsubstepx = 0;\n\t\tccp->prec = jas_image_cmptprec(image, cmptno);\n\t\tccp->sgnd = jas_image_cmptsgnd(image, cmptno);\n\t\tccp->numstepsizes = 0;\n\t\tmemset(ccp->stepsizes, 0, sizeof(ccp->stepsizes));\n\t}\n\n\tcp->rawsize = jas_image_rawsize(image);\n\tcp->totalsize = UINT_FAST32_MAX;\n\n\ttcp = &cp->tcp;\n\ttcp->csty = 0;\n\ttcp->intmode = true;\n\ttcp->prg = JPC_COD_LRCPPRG;\n\ttcp->numlyrs = 1;\n\ttcp->ilyrrates = 0;\n\n\ttccp = &cp->tccp;\n\ttccp->csty = 0;\n\ttccp->maxrlvls = 6;\n\ttccp->cblkwidthexpn = 6;\n\ttccp->cblkheightexpn = 6;\n\ttccp->cblksty = 0;\n\ttccp->numgbits = 2;\n\n\tif (!(tvp = jas_tvparser_create(optstr ? optstr : \"\"))) {\n\t\tgoto error;\n\t}\n\n\twhile (!(ret = jas_tvparser_next(tvp))) {\n\t\tswitch (jas_taginfo_nonull(jas_taginfos_lookup(encopts,\n\t\t  jas_tvparser_gettag(tvp)))->id) {\n\t\tcase OPT_DEBUG:\n\t\t\tcp->debug = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_IMGAREAOFFX:\n\t\t\tcp->imgareatlx = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_IMGAREAOFFY:\n\t\t\tcp->imgareatly = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEGRDOFFX:\n\t\t\tcp->tilegrdoffx = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEGRDOFFY:\n\t\t\tcp->tilegrdoffy = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEWIDTH:\n\t\t\tcp->tilewidth = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEHEIGHT:\n\t\t\tcp->tileheight = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_PRCWIDTH:\n\t\t\tprcwidthexpn = jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_PRCHEIGHT:\n\t\t\tprcheightexpn = jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_CBLKWIDTH:\n\t\t\ttccp->cblkwidthexpn =\n\t\t\t  jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_CBLKHEIGHT:\n\t\t\ttccp->cblkheightexpn =\n\t\t\t  jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_MODE:\n\t\t\tif ((tagid = jas_taginfo_nonull(jas_taginfos_lookup(modetab,\n\t\t\t  jas_tvparser_getval(tvp)))->id) < 0) {\n\t\t\t\tjas_eprintf(\"ignoring invalid mode %s\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t} else {\n\t\t\t\ttcp->intmode = (tagid == MODE_INT);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OPT_PRG:\n\t\t\tif ((tagid = jas_taginfo_nonull(jas_taginfos_lookup(prgordtab,\n\t\t\t  jas_tvparser_getval(tvp)))->id) < 0) {\n\t\t\t\tjas_eprintf(\"ignoring invalid progression order %s\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t} else {\n\t\t\t\ttcp->prg = tagid;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OPT_NOMCT:\n\t\t\tenablemct = false;\n\t\t\tbreak;\n\t\tcase OPT_MAXRLVLS:\n\t\t\ttccp->maxrlvls = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_SOP:\n\t\t\tcp->tcp.csty |= JPC_COD_SOP;\n\t\t\tbreak;\n\t\tcase OPT_EPH:\n\t\t\tcp->tcp.csty |= JPC_COD_EPH;\n\t\t\tbreak;\n\t\tcase OPT_LAZY:\n\t\t\ttccp->cblksty |= JPC_COX_LAZY;\n\t\t\tbreak;\n\t\tcase OPT_TERMALL:\n\t\t\ttccp->cblksty |= JPC_COX_TERMALL;\n\t\t\tbreak;\n\t\tcase OPT_SEGSYM:\n\t\t\ttccp->cblksty |= JPC_COX_SEGSYM;\n\t\t\tbreak;\n\t\tcase OPT_VCAUSAL:\n\t\t\ttccp->cblksty |= JPC_COX_VSC;\n\t\t\tbreak;\n\t\tcase OPT_RESET:\n\t\t\ttccp->cblksty |= JPC_COX_RESET;\n\t\t\tbreak;\n\t\tcase OPT_PTERM:\n\t\t\ttccp->cblksty |= JPC_COX_PTERM;\n\t\t\tbreak;\n\t\tcase OPT_NUMGBITS:\n\t\t\tcp->tccp.numgbits = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_RATE:\n\t\t\tif (ratestrtosize(jas_tvparser_getval(tvp), cp->rawsize,\n\t\t\t  &cp->totalsize)) {\n\t\t\t\tjas_eprintf(\"ignoring bad rate specifier %s\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OPT_ILYRRATES:\n\t\t\tif (jpc_atoaf(jas_tvparser_getval(tvp), &numilyrrates,\n\t\t\t  &ilyrrates)) {\n\t\t\t\tjas_eprintf(\"warning: invalid intermediate layer rates specifier ignored (%s)\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase OPT_JP2OVERHEAD:\n\t\t\tjp2overhead = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tjas_eprintf(\"warning: ignoring invalid option %s\\n\",\n\t\t\t jas_tvparser_gettag(tvp));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tjas_tvparser_destroy(tvp);\n\ttvp = 0;\n\n\tif (cp->totalsize != UINT_FAST32_MAX) {\n\t\tcp->totalsize = (cp->totalsize > jp2overhead) ?\n\t\t  (cp->totalsize - jp2overhead) : 0;\n\t}\n\n\tif (cp->imgareatlx == UINT_FAST32_MAX) {\n\t\tcp->imgareatlx = 0;\n\t} else {\n\t\tif (hsteplcm != 1) {\n\t\t\tjas_eprintf(\"warning: overriding imgareatlx value\\n\");\n\t\t}\n\t\tcp->imgareatlx *= hsteplcm;\n\t}\n\tif (cp->imgareatly == UINT_FAST32_MAX) {\n\t\tcp->imgareatly = 0;\n\t} else {\n\t\tif (vsteplcm != 1) {\n\t\t\tjas_eprintf(\"warning: overriding imgareatly value\\n\");\n\t\t}\n\t\tcp->imgareatly *= vsteplcm;\n\t}\n\tcp->refgrdwidth = cp->imgareatlx + jas_image_width(image);\n\tcp->refgrdheight = cp->imgareatly + jas_image_height(image);\n\tif (cp->tilegrdoffx == UINT_FAST32_MAX) {\n\t\tcp->tilegrdoffx = cp->imgareatlx;\n\t}\n\tif (cp->tilegrdoffy == UINT_FAST32_MAX) {\n\t\tcp->tilegrdoffy = cp->imgareatly;\n\t}\n\tif (!cp->tilewidth) {\n\t\tcp->tilewidth = cp->refgrdwidth - cp->tilegrdoffx;\n\t}\n\tif (!cp->tileheight) {\n\t\tcp->tileheight = cp->refgrdheight - cp->tilegrdoffy;\n\t}\n\n\tif (cp->numcmpts == 3) {\n\t\tmctvalid = true;\n\t\tfor (cmptno = 0; cmptno < jas_image_numcmpts(image); ++cmptno) {\n\t\t\tif (jas_image_cmptprec(image, cmptno) != jas_image_cmptprec(image, 0) ||\n\t\t\t  jas_image_cmptsgnd(image, cmptno) != jas_image_cmptsgnd(image, 0) ||\n\t\t\t  jas_image_cmptwidth(image, cmptno) != jas_image_cmptwidth(image, 0) ||\n\t\t\t  jas_image_cmptheight(image, cmptno) != jas_image_cmptheight(image, 0)) {\n\t\t\t\tmctvalid = false;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tmctvalid = false;\n\t}\n\tif (mctvalid && enablemct && jas_clrspc_fam(jas_image_clrspc(image)) != JAS_CLRSPC_FAM_RGB) {\n\t\tjas_eprintf(\"warning: color space apparently not RGB\\n\");\n\t}\n\tif (mctvalid && enablemct && jas_clrspc_fam(jas_image_clrspc(image)) == JAS_CLRSPC_FAM_RGB) {\n\t\ttcp->mctid = (tcp->intmode) ? (JPC_MCT_RCT) : (JPC_MCT_ICT);\n\t} else {\n\t\ttcp->mctid = JPC_MCT_NONE;\n\t}\n\ttccp->qmfbid = (tcp->intmode) ? (JPC_COX_RFT) : (JPC_COX_INS);\n\n\tfor (rlvlno = 0; rlvlno < tccp->maxrlvls; ++rlvlno) {\n\t\ttccp->prcwidthexpns[rlvlno] = prcwidthexpn;\n\t\ttccp->prcheightexpns[rlvlno] = prcheightexpn;\n\t}\n\tif (prcwidthexpn != 15 || prcheightexpn != 15) {\n\t\ttccp->csty |= JPC_COX_PRT;\n\t}\n\n\t/* Ensure that the tile width and height is valid. */\n\tif (!cp->tilewidth) {\n\t\tjas_eprintf(\"invalid tile width %lu\\n\", (unsigned long)\n\t\t  cp->tilewidth);\n\t\tgoto error;\n\t}\n\tif (!cp->tileheight) {\n\t\tjas_eprintf(\"invalid tile height %lu\\n\", (unsigned long)\n\t\t  cp->tileheight);\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the tile grid offset is valid. */\n\tif (cp->tilegrdoffx > cp->imgareatlx ||\n\t  cp->tilegrdoffy > cp->imgareatly ||\n\t  cp->tilegrdoffx + cp->tilewidth < cp->imgareatlx ||\n\t  cp->tilegrdoffy + cp->tileheight < cp->imgareatly) {\n\t\tjas_eprintf(\"invalid tile grid offset (%lu, %lu)\\n\",\n\t\t  (unsigned long) cp->tilegrdoffx, (unsigned long)\n\t\t  cp->tilegrdoffy);\n\t\tgoto error;\n\t}\n\n\tcp->numhtiles = JPC_CEILDIV(cp->refgrdwidth - cp->tilegrdoffx,\n\t  cp->tilewidth);\n\tcp->numvtiles = JPC_CEILDIV(cp->refgrdheight - cp->tilegrdoffy,\n\t  cp->tileheight);\n\tcp->numtiles = cp->numhtiles * cp->numvtiles;\n\n\tif (ilyrrates && numilyrrates > 0) {\n\t\ttcp->numlyrs = numilyrrates + 1;\n\t\tif (!(tcp->ilyrrates = jas_malloc((tcp->numlyrs - 1) *\n\t\t  sizeof(jpc_fix_t)))) {\n\t\t\tgoto error;\n\t\t}\n\t\tfor (i = 0; i < JAS_CAST(int, tcp->numlyrs - 1); ++i) {\n\t\t\ttcp->ilyrrates[i] = jpc_dbltofix(ilyrrates[i]);\n\t\t}\n\t}\n\n\t/* Ensure that the integer mode is used in the case of lossless\n\t  coding. */\n\tif (cp->totalsize == UINT_FAST32_MAX && (!cp->tcp.intmode)) {\n\t\tjas_eprintf(\"cannot use real mode for lossless coding\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the precinct width is valid. */\n\tif (prcwidthexpn > 15) {\n\t\tjas_eprintf(\"invalid precinct width\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the precinct height is valid. */\n\tif (prcheightexpn > 15) {\n\t\tjas_eprintf(\"invalid precinct height\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the code block width is valid. */\n\tif (cp->tccp.cblkwidthexpn < 2 || cp->tccp.cblkwidthexpn > 12) {\n\t\tjas_eprintf(\"invalid code block width %d\\n\",\n\t\t  JPC_POW2(cp->tccp.cblkwidthexpn));\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the code block height is valid. */\n\tif (cp->tccp.cblkheightexpn < 2 || cp->tccp.cblkheightexpn > 12) {\n\t\tjas_eprintf(\"invalid code block height %d\\n\",\n\t\t  JPC_POW2(cp->tccp.cblkheightexpn));\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the code block size is not too large. */\n\tif (cp->tccp.cblkwidthexpn + cp->tccp.cblkheightexpn > 12) {\n\t\tjas_eprintf(\"code block size too large\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the number of layers is valid. */\n\tif (cp->tcp.numlyrs > 16384) {\n\t\tjas_eprintf(\"too many layers\\n\");\n\t\tgoto error;\n\t}\n\n\t/* There must be at least one resolution level. */\n\tif (cp->tccp.maxrlvls < 1) {\n\t\tjas_eprintf(\"must be at least one resolution level\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the number of guard bits is valid. */\n\tif (cp->tccp.numgbits > 8) {\n\t\tjas_eprintf(\"invalid number of guard bits\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the rate is within the legal range. */\n\tif (cp->totalsize != UINT_FAST32_MAX && cp->totalsize > cp->rawsize) {\n\t\tjas_eprintf(\"warning: specified rate is unreasonably large (%lu > %lu)\\n\", (unsigned long) cp->totalsize, (unsigned long) cp->rawsize);\n\t}\n\n\t/* Ensure that the intermediate layer rates are valid. */\n\tif (tcp->numlyrs > 1) {\n\t\t/* The intermediate layers rates must increase monotonically. */\n\t\tfor (lyrno = 0; lyrno + 2 < tcp->numlyrs; ++lyrno) {\n\t\t\tif (tcp->ilyrrates[lyrno] >= tcp->ilyrrates[lyrno + 1]) {\n\t\t\t\tjas_eprintf(\"intermediate layer rates must increase monotonically\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\t/* The intermediate layer rates must be less than the overall rate. */\n\t\tif (cp->totalsize != UINT_FAST32_MAX) {\n\t\t\tfor (lyrno = 0; lyrno < tcp->numlyrs - 1; ++lyrno) {\n\t\t\t\tif (jpc_fixtodbl(tcp->ilyrrates[lyrno]) > ((double) cp->totalsize)\n\t\t\t\t  / cp->rawsize) {\n\t\t\t\t\tjas_eprintf(\"warning: intermediate layer rates must be less than overall rate\\n\");\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ilyrrates) {\n\t\tjas_free(ilyrrates);\n\t}\n\n\treturn cp;\n\nerror:\n\n\tif (ilyrrates) {\n\t\tjas_free(ilyrrates);\n\t}\n\tif (tvp) {\n\t\tjas_tvparser_destroy(tvp);\n\t}\n\tif (cp) {\n\t\tjpc_enc_cp_destroy(cp);\n\t}\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "int jpc_ppxstab_grow(jpc_ppxstab_t *tab, int maxents)\n{\n\tjpc_ppxstabent_t **newents;\n\tif (tab->maxents < maxents) {\n\t\tnewents = (tab->ents) ? jas_realloc(tab->ents, maxents *\n\t\t  sizeof(jpc_ppxstabent_t *)) : jas_malloc(maxents * sizeof(jpc_ppxstabent_t *));\n\t\tif (!newents) {\n\t\t\treturn -1;\n\t\t}\n\t\ttab->ents = newents;\n\t\ttab->maxents = maxents;\n\t}\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static int jp2_cdef_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_cdef_t *cdef = &box->data.cdef;\n\tjp2_cdefchan_t *chan;\n\tunsigned int channo;\n\tif (jp2_getuint16(in, &cdef->numchans)) {\n\t\treturn -1;\n\t}\n\tif (!(cdef->ents = jas_malloc(cdef->numchans * sizeof(jp2_cdefchan_t)))) {\n\t\treturn -1;\n\t}\n\tfor (channo = 0; channo < cdef->numchans; ++channo) {\n\t\tchan = &cdef->ents[channo];\n\t\tif (jp2_getuint16(in, &chan->channo) || jp2_getuint16(in, &chan->type) ||\n\t\t  jp2_getuint16(in, &chan->assoc)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static int jas_iccattrtab_resize(jas_iccattrtab_t *tab, int maxents)\n{\n\tjas_iccattr_t *newattrs;\n\tassert(maxents >= tab->numattrs);\n\tnewattrs = tab->attrs ? jas_realloc(tab->attrs, maxents *\n\t  sizeof(jas_iccattr_t)) : jas_malloc(maxents * sizeof(jas_iccattr_t));\n\tif (!newattrs)\n\t\treturn -1;\n\ttab->attrs = newattrs;\n\ttab->maxattrs = maxents;\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static int jpc_dec_process_sot(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_dec_tile_t *tile;\n\tjpc_sot_t *sot = &ms->parms.sot;\n\tjas_image_cmptparm_t *compinfos;\n\tjas_image_cmptparm_t *compinfo;\n\tjpc_dec_cmpt_t *cmpt;\n\tint cmptno;\n\n\tif (dec->state == JPC_MH) {\n\n\t\tcompinfos = jas_malloc(dec->numcomps * sizeof(jas_image_cmptparm_t));\n\t\tassert(compinfos);\n\t\tfor (cmptno = 0, cmpt = dec->cmpts, compinfo = compinfos;\n\t\t  cmptno < dec->numcomps; ++cmptno, ++cmpt, ++compinfo) {\n\t\t\tcompinfo->tlx = 0;\n\t\t\tcompinfo->tly = 0;\n\t\t\tcompinfo->prec = cmpt->prec;\n\t\t\tcompinfo->sgnd = cmpt->sgnd;\n\t\t\tcompinfo->width = cmpt->width;\n\t\t\tcompinfo->height = cmpt->height;\n\t\t\tcompinfo->hstep = cmpt->hstep;\n\t\t\tcompinfo->vstep = cmpt->vstep;\n\t\t}\n\n\t\tif (!(dec->image = jas_image_create(dec->numcomps, compinfos,\n\t\t  JAS_CLRSPC_UNKNOWN))) {\n\t\t\treturn -1;\n\t\t}\n\t\tjas_free(compinfos);\n\n\t\t/* Is the packet header information stored in PPM marker segments in\n\t\t  the main header? */\n\t\tif (dec->ppmstab) {\n\t\t\t/* Convert the PPM marker segment data into a collection of streams\n\t\t\t  (one stream per tile-part). */\n\t\t\tif (!(dec->pkthdrstreams = jpc_ppmstabtostreams(dec->ppmstab))) {\n\t\t\t\tabort();\n\t\t\t}\n\t\t\tjpc_ppxstab_destroy(dec->ppmstab);\n\t\t\tdec->ppmstab = 0;\n\t\t}\n\t}\n\n\tif (sot->len > 0) {\n\t\tdec->curtileendoff = jas_stream_getrwcount(dec->in) - ms->len -\n\t\t  4 + sot->len;\n\t} else {\n\t\tdec->curtileendoff = 0;\n\t}\n\n\tif (JAS_CAST(int, sot->tileno) >= dec->numtiles) {\n\t\tjas_eprintf(\"invalid tile number in SOT marker segment\\n\");\n\t\treturn -1;\n\t}\n\t/* Set the current tile. */\n\tdec->curtile = &dec->tiles[sot->tileno];\n\ttile = dec->curtile;\n\t/* Ensure that this is the expected part number. */\n\tif (sot->partno != tile->partno) {\n\t\treturn -1;\n\t}\n\tif (tile->numparts > 0 && sot->partno >= tile->numparts) {\n\t\treturn -1;\n\t}\n\tif (!tile->numparts && sot->numparts > 0) {\n\t\ttile->numparts = sot->numparts;\n\t}\n\n\ttile->pptstab = 0;\n\n\tswitch (tile->state) {\n\tcase JPC_TILE_INIT:\n\t\t/* This is the first tile-part for this tile. */\n\t\ttile->state = JPC_TILE_ACTIVE;\n\t\tassert(!tile->cp);\n\t\tif (!(tile->cp = jpc_dec_cp_copy(dec->cp))) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_resetflags(dec->cp);\n\t\tbreak;\n\tdefault:\n\t\tif (sot->numparts == sot->partno - 1) {\n\t\t\ttile->state = JPC_TILE_ACTIVELAST;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* Note: We do not increment the expected tile-part number until\n\t  all processing for this tile-part is complete. */\n\n\t/* We should expect to encounter other tile-part header marker\n\t  segments next. */\n\tdec->state = JPC_TPH;\n\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static int jpc_dec_process_siz(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_siz_t *siz = &ms->parms.siz;\n\tint compno;\n\tint tileno;\n\tjpc_dec_tile_t *tile;\n\tjpc_dec_tcomp_t *tcomp;\n\tint htileno;\n\tint vtileno;\n\tjpc_dec_cmpt_t *cmpt;\n\n\tdec->xstart = siz->xoff;\n\tdec->ystart = siz->yoff;\n\tdec->xend = siz->width;\n\tdec->yend = siz->height;\n\tdec->tilewidth = siz->tilewidth;\n\tdec->tileheight = siz->tileheight;\n\tdec->tilexoff = siz->tilexoff;\n\tdec->tileyoff = siz->tileyoff;\n\tdec->numcomps = siz->numcomps;\n\tif (!(dec->cp = jpc_dec_cp_create(dec->numcomps))) {\n\t\treturn -1;\n\t}\n\n\tif (!(dec->cmpts = jas_malloc(dec->numcomps * sizeof(jpc_dec_cmpt_t)))) {\n\t\treturn -1;\n\t}\n\n\tfor (compno = 0, cmpt = dec->cmpts; compno < dec->numcomps; ++compno,\n\t  ++cmpt) {\n\t\tcmpt->prec = siz->comps[compno].prec;\n\t\tcmpt->sgnd = siz->comps[compno].sgnd;\n\t\tcmpt->hstep = siz->comps[compno].hsamp;\n\t\tcmpt->vstep = siz->comps[compno].vsamp;\n\t\tcmpt->width = JPC_CEILDIV(dec->xend, cmpt->hstep) -\n\t\t  JPC_CEILDIV(dec->xstart, cmpt->hstep);\n\t\tcmpt->height = JPC_CEILDIV(dec->yend, cmpt->vstep) -\n\t\t  JPC_CEILDIV(dec->ystart, cmpt->vstep);\n\t\tcmpt->hsubstep = 0;\n\t\tcmpt->vsubstep = 0;\n\t}\n\n\tdec->image = 0;\n\n\tdec->numhtiles = JPC_CEILDIV(dec->xend - dec->tilexoff, dec->tilewidth);\n\tdec->numvtiles = JPC_CEILDIV(dec->yend - dec->tileyoff, dec->tileheight);\n\tdec->numtiles = dec->numhtiles * dec->numvtiles;\n\tif (!(dec->tiles = jas_malloc(dec->numtiles * sizeof(jpc_dec_tile_t)))) {\n\t\treturn -1;\n\t}\n\n\tfor (tileno = 0, tile = dec->tiles; tileno < dec->numtiles; ++tileno,\n\t  ++tile) {\n\t\thtileno = tileno % dec->numhtiles;\n\t\tvtileno = tileno / dec->numhtiles;\n\t\ttile->realmode = 0;\n\t\ttile->state = JPC_TILE_INIT;\n\t\ttile->xstart = JAS_MAX(dec->tilexoff + htileno * dec->tilewidth,\n\t\t  dec->xstart);\n\t\ttile->ystart = JAS_MAX(dec->tileyoff + vtileno * dec->tileheight,\n\t\t  dec->ystart);\n\t\ttile->xend = JAS_MIN(dec->tilexoff + (htileno + 1) *\n\t\t  dec->tilewidth, dec->xend);\n\t\ttile->yend = JAS_MIN(dec->tileyoff + (vtileno + 1) *\n\t\t  dec->tileheight, dec->yend);\n\t\ttile->numparts = 0;\n\t\ttile->partno = 0;\n\t\ttile->pkthdrstream = 0;\n\t\ttile->pkthdrstreampos = 0;\n\t\ttile->pptstab = 0;\n\t\ttile->cp = 0;\n\t\tif (!(tile->tcomps = jas_malloc(dec->numcomps *\n\t\t  sizeof(jpc_dec_tcomp_t)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (compno = 0, cmpt = dec->cmpts, tcomp = tile->tcomps;\n\t\t  compno < dec->numcomps; ++compno, ++cmpt, ++tcomp) {\n\t\t\ttcomp->rlvls = 0;\n\t\t\ttcomp->data = 0;\n\t\t\ttcomp->xstart = JPC_CEILDIV(tile->xstart, cmpt->hstep);\n\t\t\ttcomp->ystart = JPC_CEILDIV(tile->ystart, cmpt->vstep);\n\t\t\ttcomp->xend = JPC_CEILDIV(tile->xend, cmpt->hstep);\n\t\t\ttcomp->yend = JPC_CEILDIV(tile->yend, cmpt->vstep);\n\t\t\ttcomp->tsfb = 0;\n\t\t}\n\t}\n\n\tdec->pkthdrstreams = 0;\n\n\t/* We should expect to encounter other main header marker segments\n\t  or an SOT marker segment next. */\n\tdec->state = JPC_MH;\n\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "jas_matrix_t *jas_matrix_create(int numrows, int numcols)\n{\n\tjas_matrix_t *matrix;\n\tint i;\n\n\tif (!(matrix = jas_malloc(sizeof(jas_matrix_t)))) {\n\t\treturn 0;\n\t}\n\tmatrix->flags_ = 0;\n\tmatrix->numrows_ = numrows;\n\tmatrix->numcols_ = numcols;\n\tmatrix->rows_ = 0;\n\tmatrix->maxrows_ = numrows;\n\tmatrix->data_ = 0;\n\tmatrix->datasize_ = numrows * numcols;\n\n\tif (matrix->maxrows_ > 0) {\n\t\tif (!(matrix->rows_ = jas_malloc(matrix->maxrows_ *\n\t\t  sizeof(jas_seqent_t *)))) {\n\t\t\tjas_matrix_destroy(matrix);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (matrix->datasize_ > 0) {\n\t\tif (!(matrix->data_ = jas_malloc(matrix->datasize_ *\n\t\t  sizeof(jas_seqent_t)))) {\n\t\t\tjas_matrix_destroy(matrix);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tfor (i = 0; i < numrows; ++i) {\n\t\tmatrix->rows_[i] = &matrix->data_[i * matrix->numcols_];\n\t}\n\n\tfor (i = 0; i < matrix->datasize_; ++i) {\n\t\tmatrix->data_[i] = 0;\n\t}\n\n\tmatrix->xstart_ = 0;\n\tmatrix->ystart_ = 0;\n\tmatrix->xend_ = matrix->numcols_;\n\tmatrix->yend_ = matrix->numrows_;\n\n\treturn matrix;\n}",
        "target": 1
    },
    {
        "func": "void *jas_calloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\tsize_t n;\n\tn = nmemb * size;\n\tif (!(ptr = jas_malloc(n * sizeof(char)))) {\n\t\treturn 0;\n\t}\n\tmemset(ptr, 0, n);\n\treturn ptr;\n}",
        "target": 1
    },
    {
        "func": "char *jas_strdup(const char *s)\n{\n\tint n;\n\tchar *p;\n\tn = strlen(s) + 1;\n\tif (!(p = jas_malloc(n * sizeof(char)))) {\n\t\treturn 0;\n\t}\n\tstrcpy(p, s);\n\treturn p;\n}",
        "target": 1
    },
    {
        "func": "static int jpc_siz_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate,\n  jas_stream_t *in)\n{\n\tjpc_siz_t *siz = &ms->parms.siz;\n\tunsigned int i;\n\tuint_fast8_t tmp;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tif (jpc_getuint16(in, &siz->caps) ||\n\t  jpc_getuint32(in, &siz->width) ||\n\t  jpc_getuint32(in, &siz->height) ||\n\t  jpc_getuint32(in, &siz->xoff) ||\n\t  jpc_getuint32(in, &siz->yoff) ||\n\t  jpc_getuint32(in, &siz->tilewidth) ||\n\t  jpc_getuint32(in, &siz->tileheight) ||\n\t  jpc_getuint32(in, &siz->tilexoff) ||\n\t  jpc_getuint32(in, &siz->tileyoff) ||\n\t  jpc_getuint16(in, &siz->numcomps)) {\n\t\treturn -1;\n\t}\n\tif (!siz->width || !siz->height || !siz->tilewidth ||\n\t  !siz->tileheight || !siz->numcomps) {\n\t\treturn -1;\n\t}\n\tif (!(siz->comps = jas_malloc(siz->numcomps * sizeof(jpc_sizcomp_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < siz->numcomps; ++i) {\n\t\tif (jpc_getuint8(in, &tmp) ||\n\t\t  jpc_getuint8(in, &siz->comps[i].hsamp) ||\n\t\t  jpc_getuint8(in, &siz->comps[i].vsamp)) {\n\t\t\tjas_free(siz->comps);\n\t\t\treturn -1;\n\t\t}\n\t\tsiz->comps[i].sgnd = (tmp >> 7) & 1;\n\t\tsiz->comps[i].prec = (tmp & 0x7f) + 1;\n\t}\n\tif (jas_stream_eof(in)) {\n\t\tjas_free(siz->comps);\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "void jpc_qmfb_join_col(jpc_fix_t *a, int numrows, int stride,\n  int parity)\n{\n\n\tint bufsize = JPC_CEILDIVPOW2(numrows, 1);\n\tjpc_fix_t joinbuf[QMFB_JOINBUFSIZE];\n\tjpc_fix_t *buf = joinbuf;\n\tregister jpc_fix_t *srcptr;\n\tregister jpc_fix_t *dstptr;\n\tregister int n;\n\tint hstartcol;\n\n\t/* Allocate memory for the join buffer from the heap. */\n\tif (bufsize > QMFB_JOINBUFSIZE) {\n\t\tif (!(buf = jas_malloc(bufsize * sizeof(jpc_fix_t)))) {\n\t\t\t/* We have no choice but to commit suicide. */\n\t\t\tabort();\n\t\t}\n\t}\n\n\thstartcol = (numrows + 1 - parity) >> 1;\n\n\t/* Save the samples from the lowpass channel. */\n\tn = hstartcol;\n\tsrcptr = &a[0];\n\tdstptr = buf;\n\twhile (n-- > 0) {\n\t\t*dstptr = *srcptr;\n\t\tsrcptr += stride;\n\t\t++dstptr;\n\t}\n\t/* Copy the samples from the highpass channel into place. */\n\tsrcptr = &a[hstartcol * stride];\n\tdstptr = &a[(1 - parity) * stride];\n\tn = numrows - hstartcol;\n\twhile (n-- > 0) {\n\t\t*dstptr = *srcptr;\n\t\tdstptr += 2 * stride;\n\t\tsrcptr += stride;\n\t}\n\t/* Copy the samples from the lowpass channel into place. */\n\tsrcptr = buf;\n\tdstptr = &a[parity * stride];\n\tn = hstartcol;\n\twhile (n-- > 0) {\n\t\t*dstptr = *srcptr;\n\t\tdstptr += 2 * stride;\n\t\t++srcptr;\n\t}\n\n\t/* If the join buffer was allocated on the heap, free this memory. */\n\tif (buf != joinbuf) {\n\t\tjas_free(buf);\n\t}\n\n}",
        "target": 1
    },
    {
        "func": "static int jas_icclut16_input(jas_iccattrval_t *attrval, jas_stream_t *in,\n  int cnt)\n{\n\tint i;\n\tint j;\n\tint clutsize;\n\tjas_icclut16_t *lut16 = &attrval->data.lut16;\n\tlut16->clut = 0;\n\tlut16->intabs = 0;\n\tlut16->intabsbuf = 0;\n\tlut16->outtabs = 0;\n\tlut16->outtabsbuf = 0;\n\tif (jas_iccgetuint8(in, &lut16->numinchans) ||\n\t  jas_iccgetuint8(in, &lut16->numoutchans) ||\n\t  jas_iccgetuint8(in, &lut16->clutlen) ||\n\t  jas_stream_getc(in) == EOF)\n\t\tgoto error;\n\tfor (i = 0; i < 3; ++i) {\n\t\tfor (j = 0; j < 3; ++j) {\n\t\t\tif (jas_iccgetsint32(in, &lut16->e[i][j]))\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\tif (jas_iccgetuint16(in, &lut16->numintabents) ||\n\t  jas_iccgetuint16(in, &lut16->numouttabents))\n\t\tgoto error;\n\tclutsize = jas_iccpowi(lut16->clutlen, lut16->numinchans) * lut16->numoutchans;\n\tif (!(lut16->clut = jas_malloc(clutsize * sizeof(jas_iccuint16_t))) ||\n\t  !(lut16->intabsbuf = jas_malloc(lut16->numinchans *\n\t  lut16->numintabents * sizeof(jas_iccuint16_t))) ||\n\t  !(lut16->intabs = jas_malloc(lut16->numinchans *\n\t  sizeof(jas_iccuint16_t *))))\n\t\tgoto error;\n\tfor (i = 0; i < lut16->numinchans; ++i)\n\t\tlut16->intabs[i] = &lut16->intabsbuf[i * lut16->numintabents];\n\tif (!(lut16->outtabsbuf = jas_malloc(lut16->numoutchans *\n\t  lut16->numouttabents * sizeof(jas_iccuint16_t))) ||\n\t  !(lut16->outtabs = jas_malloc(lut16->numoutchans *\n\t  sizeof(jas_iccuint16_t *))))\n\t\tgoto error;\n\tfor (i = 0; i < lut16->numoutchans; ++i)\n\t\tlut16->outtabs[i] = &lut16->outtabsbuf[i * lut16->numouttabents];\n\tfor (i = 0; i < lut16->numinchans; ++i) {\n\t\tfor (j = 0; j < JAS_CAST(int, lut16->numintabents); ++j) {\n\t\t\tif (jas_iccgetuint16(in, &lut16->intabs[i][j]))\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\tfor (i = 0; i < lut16->numoutchans; ++i) {\n\t\tfor (j = 0; j < JAS_CAST(int, lut16->numouttabents); ++j) {\n\t\t\tif (jas_iccgetuint16(in, &lut16->outtabs[i][j]))\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\tfor (i = 0; i < clutsize; ++i) {\n\t\tif (jas_iccgetuint16(in, &lut16->clut[i]))\n\t\t\tgoto error;\n\t}\n\tif (JAS_CAST(int, 44 + 2 * (lut16->numinchans * lut16->numintabents +\n          lut16->numoutchans * lut16->numouttabents +\n          jas_iccpowi(lut16->clutlen, lut16->numinchans) *\n\t  lut16->numoutchans)) != cnt)\n\t\tgoto error;\n\treturn 0;\nerror:\n\tjas_icclut16_destroy(attrval);\n\treturn -1;\n}",
        "target": 1
    },
    {
        "func": "static jpc_enc_prc_t *prc_create(jpc_enc_prc_t *prc, jpc_enc_cp_t *cp, jpc_enc_band_t *band)\n{\n\tuint_fast32_t prcno;\n\tuint_fast32_t prcxind;\n\tuint_fast32_t prcyind;\n\tuint_fast32_t cbgtlx;\n\tuint_fast32_t cbgtly;\n\tuint_fast32_t tlprctlx;\n\tuint_fast32_t tlprctly;\n\tuint_fast32_t tlcbgtlx;\n\tuint_fast32_t tlcbgtly;\n\tuint_fast16_t rlvlno;\n\tjpc_enc_rlvl_t *rlvl;\n\tuint_fast32_t tlcblktlx;\n\tuint_fast32_t tlcblktly;\n\tuint_fast32_t brcblkbrx;\n\tuint_fast32_t brcblkbry;\n\tuint_fast32_t cblkno;\n\tjpc_enc_cblk_t *cblk;\n\tjpc_enc_tcmpt_t *tcmpt;\n\n\tprc->cblks = 0;\n\tprc->incltree = 0;\n\tprc->savincltree = 0;\n\tprc->nlibtree = 0;\n\tprc->savnlibtree = 0;\n\n\trlvl = band->rlvl;\n\ttcmpt = rlvl->tcmpt;\nrlvlno = rlvl - tcmpt->rlvls;\n\tprcno = prc - band->prcs;\n\tprcxind = prcno % rlvl->numhprcs;\n\tprcyind = prcno / rlvl->numhprcs;\n\tprc->band = band;\n\ntlprctlx = JPC_FLOORTOMULTPOW2(rlvl->tlx, rlvl->prcwidthexpn);\ntlprctly = JPC_FLOORTOMULTPOW2(rlvl->tly, rlvl->prcheightexpn);\nif (!rlvlno) {\n\ttlcbgtlx = tlprctlx;\n\ttlcbgtly = tlprctly;\n} else {\n\ttlcbgtlx = JPC_CEILDIVPOW2(tlprctlx, 1);\n\ttlcbgtly = JPC_CEILDIVPOW2(tlprctly, 1);\n}\n\n\t/* Compute the coordinates of the top-left and bottom-right\n\t  corners of the precinct. */\n\tcbgtlx = tlcbgtlx + (prcxind << rlvl->cbgwidthexpn);\n\tcbgtly = tlcbgtly + (prcyind << rlvl->cbgheightexpn);\n\tprc->tlx = JAS_MAX(jas_seq2d_xstart(band->data), cbgtlx);\n\tprc->tly = JAS_MAX(jas_seq2d_ystart(band->data), cbgtly);\n\tprc->brx = JAS_MIN(jas_seq2d_xend(band->data), cbgtlx +\n\t  (1 << rlvl->cbgwidthexpn));\n\tprc->bry = JAS_MIN(jas_seq2d_yend(band->data), cbgtly +\n\t  (1 << rlvl->cbgheightexpn));\n\n\tif (prc->tlx < prc->brx && prc->tly < prc->bry) {\n\t\t/* The precinct contains at least one code block. */\n\n\t\ttlcblktlx = JPC_FLOORTOMULTPOW2(prc->tlx, rlvl->cblkwidthexpn);\n\t\ttlcblktly = JPC_FLOORTOMULTPOW2(prc->tly, rlvl->cblkheightexpn);\n\t\tbrcblkbrx = JPC_CEILTOMULTPOW2(prc->brx, rlvl->cblkwidthexpn);\n\t\tbrcblkbry = JPC_CEILTOMULTPOW2(prc->bry, rlvl->cblkheightexpn);\n\t\tprc->numhcblks = JPC_FLOORDIVPOW2(brcblkbrx - tlcblktlx,\n\t\t  rlvl->cblkwidthexpn);\n\t\tprc->numvcblks = JPC_FLOORDIVPOW2(brcblkbry - tlcblktly,\n\t\t  rlvl->cblkheightexpn);\n\t\tprc->numcblks = prc->numhcblks * prc->numvcblks;\n\n\t\tif (!(prc->incltree = jpc_tagtree_create(prc->numhcblks,\n\t\t  prc->numvcblks))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (!(prc->nlibtree = jpc_tagtree_create(prc->numhcblks,\n\t\t  prc->numvcblks))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (!(prc->savincltree = jpc_tagtree_create(prc->numhcblks,\n\t\t  prc->numvcblks))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (!(prc->savnlibtree = jpc_tagtree_create(prc->numhcblks,\n\t\t  prc->numvcblks))) {\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (!(prc->cblks = jas_malloc(prc->numcblks * sizeof(jpc_enc_cblk_t)))) {\n\t\t\tgoto error;\n\t\t}\n\t\tfor (cblkno = 0, cblk = prc->cblks; cblkno < prc->numcblks;\n\t\t  ++cblkno, ++cblk) {\n\t\t\tcblk->passes = 0;\n\t\t\tcblk->stream = 0;\n\t\t\tcblk->mqenc = 0;\n\t\t\tcblk->data = 0;\n\t\t\tcblk->flags = 0;\n\t\t\tcblk->prc = prc;\n\t\t}\n\t\tfor (cblkno = 0, cblk = prc->cblks; cblkno < prc->numcblks;\n\t\t  ++cblkno, ++cblk) {\n\t\t\tif (!cblk_create(cblk, cp, prc)) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* The precinct does not contain any code blocks. */\n\t\tprc->tlx = prc->brx;\n\t\tprc->tly = prc->bry;\n\t\tprc->numcblks = 0;\n\t\tprc->numhcblks = 0;\n\t\tprc->numvcblks = 0;\n\t\tprc->cblks = 0;\n\t\tprc->incltree = 0;\n\t\tprc->nlibtree = 0;\n\t\tprc->savincltree = 0;\n\t\tprc->savnlibtree = 0;\n\t}\n\n\treturn prc;\n\nerror:\n\tprc_destroy(prc);\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "void jpc_qmfb_join_colgrp(jpc_fix_t *a, int numrows, int stride,\n  int parity)\n{\n\n\tint bufsize = JPC_CEILDIVPOW2(numrows, 1);\n\tjpc_fix_t joinbuf[QMFB_JOINBUFSIZE * JPC_QMFB_COLGRPSIZE];\n\tjpc_fix_t *buf = joinbuf;\n\tjpc_fix_t *srcptr;\n\tjpc_fix_t *dstptr;\n\tregister jpc_fix_t *srcptr2;\n\tregister jpc_fix_t *dstptr2;\n\tregister int n;\n\tregister int i;\n\tint hstartcol;\n\n\t/* Allocate memory for the join buffer from the heap. */\n\tif (bufsize > QMFB_JOINBUFSIZE) {\n\t\tif (!(buf = jas_malloc(bufsize * JPC_QMFB_COLGRPSIZE * sizeof(jpc_fix_t)))) {\n\t\t\t/* We have no choice but to commit suicide. */\n\t\t\tabort();\n\t\t}\n\t}\n\n\thstartcol = (numrows + 1 - parity) >> 1;\n\n\t/* Save the samples from the lowpass channel. */\n\tn = hstartcol;\n\tsrcptr = &a[0];\n\tdstptr = buf;\n\twhile (n-- > 0) {\n\t\tdstptr2 = dstptr;\n\t\tsrcptr2 = srcptr;\n\t\tfor (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {\n\t\t\t*dstptr2 = *srcptr2;\n\t\t\t++dstptr2;\n\t\t\t++srcptr2;\n\t\t}\n\t\tsrcptr += stride;\n\t\tdstptr += JPC_QMFB_COLGRPSIZE;\n\t}\n\t/* Copy the samples from the highpass channel into place. */\n\tsrcptr = &a[hstartcol * stride];\n\tdstptr = &a[(1 - parity) * stride];\n\tn = numrows - hstartcol;\n\twhile (n-- > 0) {\n\t\tdstptr2 = dstptr;\n\t\tsrcptr2 = srcptr;\n\t\tfor (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {\n\t\t\t*dstptr2 = *srcptr2;\n\t\t\t++dstptr2;\n\t\t\t++srcptr2;\n\t\t}\n\t\tdstptr += 2 * stride;\n\t\tsrcptr += stride;\n\t}\n\t/* Copy the samples from the lowpass channel into place. */\n\tsrcptr = buf;\n\tdstptr = &a[parity * stride];\n\tn = hstartcol;\n\twhile (n-- > 0) {\n\t\tdstptr2 = dstptr;\n\t\tsrcptr2 = srcptr;\n\t\tfor (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {\n\t\t\t*dstptr2 = *srcptr2;\n\t\t\t++dstptr2;\n\t\t\t++srcptr2;\n\t\t}\n\t\tdstptr += 2 * stride;\n\t\tsrcptr += JPC_QMFB_COLGRPSIZE;\n\t}\n\n\t/* If the join buffer was allocated on the heap, free this memory. */\n\tif (buf != joinbuf) {\n\t\tjas_free(buf);\n\t}\n\n}",
        "target": 1
    },
    {
        "func": "jpc_pi_t *jpc_dec_pi_create(jpc_dec_t *dec, jpc_dec_tile_t *tile)\n{\n\tjpc_pi_t *pi;\n\tint compno;\n\tjpc_picomp_t *picomp;\n\tjpc_pirlvl_t *pirlvl;\n\tjpc_dec_tcomp_t *tcomp;\n\tint rlvlno;\n\tjpc_dec_rlvl_t *rlvl;\n\tint prcno;\n\tint *prclyrno;\n\tjpc_dec_cmpt_t *cmpt;\n\n\tif (!(pi = jpc_pi_create0())) {\n\t\treturn 0;\n\t}\n\tpi->numcomps = dec->numcomps;\n\tif (!(pi->picomps = jas_malloc(pi->numcomps * sizeof(jpc_picomp_t)))) {\n\t\tjpc_pi_destroy(pi);\n\t\treturn 0;\n\t}\n\tfor (compno = 0, picomp = pi->picomps; compno < pi->numcomps; ++compno,\n\t  ++picomp) {\n\t\tpicomp->pirlvls = 0;\n\t}\n\n\tfor (compno = 0, tcomp = tile->tcomps, picomp = pi->picomps;\n\t  compno < pi->numcomps; ++compno, ++tcomp, ++picomp) {\n\t\tpicomp->numrlvls = tcomp->numrlvls;\n\t\tif (!(picomp->pirlvls = jas_malloc(picomp->numrlvls *\n\t\t  sizeof(jpc_pirlvl_t)))) {\n\t\t\tjpc_pi_destroy(pi);\n\t\t\treturn 0;\n\t\t}\n\t\tfor (rlvlno = 0, pirlvl = picomp->pirlvls; rlvlno <\n\t\t  picomp->numrlvls; ++rlvlno, ++pirlvl) {\n\t\t\tpirlvl->prclyrnos = 0;\n\t\t}\n\t\tfor (rlvlno = 0, pirlvl = picomp->pirlvls, rlvl = tcomp->rlvls;\n\t\t  rlvlno < picomp->numrlvls; ++rlvlno, ++pirlvl, ++rlvl) {\n/* XXX sizeof(long) should be sizeof different type */\n\t\t\tpirlvl->numprcs = rlvl->numprcs;\n\t\t\tif (!(pirlvl->prclyrnos = jas_malloc(pirlvl->numprcs *\n\t\t\t  sizeof(long)))) {\n\t\t\t\tjpc_pi_destroy(pi);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tpi->maxrlvls = 0;\n\tfor (compno = 0, tcomp = tile->tcomps, picomp = pi->picomps, cmpt =\n\t  dec->cmpts; compno < pi->numcomps; ++compno, ++tcomp, ++picomp,\n\t  ++cmpt) {\n\t\tpicomp->hsamp = cmpt->hstep;\n\t\tpicomp->vsamp = cmpt->vstep;\n\t\tfor (rlvlno = 0, pirlvl = picomp->pirlvls, rlvl = tcomp->rlvls;\n\t\t  rlvlno < picomp->numrlvls; ++rlvlno, ++pirlvl, ++rlvl) {\n\t\t\tpirlvl->prcwidthexpn = rlvl->prcwidthexpn;\n\t\t\tpirlvl->prcheightexpn = rlvl->prcheightexpn;\n\t\t\tfor (prcno = 0, prclyrno = pirlvl->prclyrnos;\n\t\t\t  prcno < pirlvl->numprcs; ++prcno, ++prclyrno) {\n\t\t\t\t*prclyrno = 0;\n\t\t\t}\n\t\t\tpirlvl->numhprcs = rlvl->numhprcs;\n\t\t}\n\t\tif (pi->maxrlvls < tcomp->numrlvls) {\n\t\t\tpi->maxrlvls = tcomp->numrlvls;\n\t\t}\n\t}\n\n\tpi->numlyrs = tile->cp->numlyrs;\n\tpi->xstart = tile->xstart;\n\tpi->ystart = tile->ystart;\n\tpi->xend = tile->xend;\n\tpi->yend = tile->yend;\n\n\tpi->picomp = 0;\n\tpi->pirlvl = 0;\n\tpi->x = 0;\n\tpi->y = 0;\n\tpi->compno = 0;\n\tpi->rlvlno = 0;\n\tpi->prcno = 0;\n\tpi->lyrno = 0;\n\tpi->xstep = 0;\n\tpi->ystep = 0;\n\n\tpi->pchgno = -1;\n\n\tpi->defaultpchg.prgord = tile->cp->prgord;\n\tpi->defaultpchg.compnostart = 0;\n\tpi->defaultpchg.compnoend = pi->numcomps;\n\tpi->defaultpchg.rlvlnostart = 0;\n\tpi->defaultpchg.rlvlnoend = pi->maxrlvls;\n\tpi->defaultpchg.lyrnoend = pi->numlyrs;\n\tpi->pchg = 0;\n\n\tpi->valid = 0;\n\n\treturn pi;\n}",
        "target": 1
    },
    {
        "func": "static int jp2_bpcc_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_bpcc_t *bpcc = &box->data.bpcc;\n\tunsigned int i;\n\tbpcc->numcmpts = box->datalen;\n\tif (!(bpcc->bpcs = jas_malloc(bpcc->numcmpts * sizeof(uint_fast8_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < bpcc->numcmpts; ++i) {\n\t\tif (jp2_getuint8(in, &bpcc->bpcs[i])) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static jpc_enc_tcmpt_t *tcmpt_create(jpc_enc_tcmpt_t *tcmpt, jpc_enc_cp_t *cp,\n  jas_image_t *image, jpc_enc_tile_t *tile)\n{\n\tuint_fast16_t cmptno;\n\tuint_fast16_t rlvlno;\n\tjpc_enc_rlvl_t *rlvl;\n\tuint_fast32_t tlx;\n\tuint_fast32_t tly;\n\tuint_fast32_t brx;\n\tuint_fast32_t bry;\n\tuint_fast32_t cmpttlx;\n\tuint_fast32_t cmpttly;\n\tjpc_enc_ccp_t *ccp;\n\tjpc_tsfb_band_t bandinfos[JPC_MAXBANDS];\n\n\ttcmpt->tile = tile;\n\ttcmpt->tsfb = 0;\n\ttcmpt->data = 0;\n\ttcmpt->rlvls = 0;\n\n\t/* Deduce the component number. */\n\tcmptno = tcmpt - tile->tcmpts;\n\n\tccp = &cp->ccps[cmptno];\n\n\t/* Compute the coordinates of the top-left and bottom-right\n\t  corners of this tile-component. */\n\ttlx = JPC_CEILDIV(tile->tlx, ccp->sampgrdstepx);\n\ttly = JPC_CEILDIV(tile->tly, ccp->sampgrdstepy);\n\tbrx = JPC_CEILDIV(tile->brx, ccp->sampgrdstepx);\n\tbry = JPC_CEILDIV(tile->bry, ccp->sampgrdstepy);\n\n\t/* Create a sequence to hold the tile-component sample data. */\n\tif (!(tcmpt->data = jas_seq2d_create(tlx, tly, brx, bry))) {\n\t\tgoto error;\n\t}\n\n\t/* Get the image data associated with this tile-component. */\n\tcmpttlx = JPC_CEILDIV(cp->imgareatlx, ccp->sampgrdstepx);\n\tcmpttly = JPC_CEILDIV(cp->imgareatly, ccp->sampgrdstepy);\n\tif (jas_image_readcmpt(image, cmptno, tlx - cmpttlx, tly - cmpttly,\n\t  brx - tlx, bry - tly, tcmpt->data)) {\n\t\tgoto error;\n\t}\n\n\ttcmpt->synweight = 0;\n\ttcmpt->qmfbid = cp->tccp.qmfbid;\n\ttcmpt->numrlvls = cp->tccp.maxrlvls;\n\ttcmpt->numbands = 3 * tcmpt->numrlvls - 2;\n\tif (!(tcmpt->tsfb = jpc_cod_gettsfb(tcmpt->qmfbid, tcmpt->numrlvls - 1))) {\n\t\tgoto error;\n\t}\n\n\tfor (rlvlno = 0; rlvlno < tcmpt->numrlvls; ++rlvlno) {\n\t\ttcmpt->prcwidthexpns[rlvlno] = cp->tccp.prcwidthexpns[rlvlno];\n\t\ttcmpt->prcheightexpns[rlvlno] = cp->tccp.prcheightexpns[rlvlno];\n\t}\n\ttcmpt->cblkwidthexpn = cp->tccp.cblkwidthexpn;\n\ttcmpt->cblkheightexpn = cp->tccp.cblkheightexpn;\n\ttcmpt->cblksty = cp->tccp.cblksty;\n\ttcmpt->csty = cp->tccp.csty;\n\n\ttcmpt->numstepsizes = tcmpt->numbands;\n\tassert(tcmpt->numstepsizes <= JPC_MAXBANDS);\n\tmemset(tcmpt->stepsizes, 0, tcmpt->numstepsizes * sizeof(uint_fast16_t));\n\n\t/* Retrieve information about the various bands. */\n\tjpc_tsfb_getbands(tcmpt->tsfb, jas_seq2d_xstart(tcmpt->data),\n\t  jas_seq2d_ystart(tcmpt->data), jas_seq2d_xend(tcmpt->data),\n\t  jas_seq2d_yend(tcmpt->data), bandinfos);\n\n\tif (!(tcmpt->rlvls = jas_malloc(tcmpt->numrlvls * sizeof(jpc_enc_rlvl_t)))) {\n\t\tgoto error;\n\t}\n\tfor (rlvlno = 0, rlvl = tcmpt->rlvls; rlvlno < tcmpt->numrlvls;\n\t  ++rlvlno, ++rlvl) {\n\t\trlvl->bands = 0;\n\t\trlvl->tcmpt = tcmpt;\n\t}\n\tfor (rlvlno = 0, rlvl = tcmpt->rlvls; rlvlno < tcmpt->numrlvls;\n\t  ++rlvlno, ++rlvl) {\n\t\tif (!rlvl_create(rlvl, cp, tcmpt, bandinfos)) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\treturn tcmpt;\n\nerror:\n\n\ttcmpt_destroy(tcmpt);\n\treturn 0;\n\n}",
        "target": 1
    },
    {
        "func": "jas_stream_t *jas_stream_memopen(char *buf, int bufsize)\n{\n\tjas_stream_t *stream;\n\tjas_stream_memobj_t *obj;\n\n\tif (!(stream = jas_stream_create())) {\n\t\treturn 0;\n\t}\n\n\t/* A stream associated with a memory buffer is always opened\n\tfor both reading and writing in binary mode. */\n\tstream->openmode_ = JAS_STREAM_READ | JAS_STREAM_WRITE | JAS_STREAM_BINARY;\n\n\t/* Since the stream data is already resident in memory, buffering\n\tis not necessary. */\n\t/* But... It still may be faster to use buffering anyways. */\n\tjas_stream_initbuf(stream, JAS_STREAM_FULLBUF, 0, 0);\n\n\t/* Select the operations for a memory stream. */\n\tstream->ops_ = &jas_stream_memops;\n\n\t/* Allocate memory for the underlying memory stream object. */\n\tif (!(obj = jas_malloc(sizeof(jas_stream_memobj_t)))) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\tstream->obj_ = (void *) obj;\n\n\t/* Initialize a few important members of the memory stream object. */\n\tobj->myalloc_ = 0;\n\tobj->buf_ = 0;\n\n\t/* If the buffer size specified is nonpositive, then the buffer\n\tis allocated internally and automatically grown as needed. */\n\tif (bufsize <= 0) {\n\t\tobj->bufsize_ = 1024;\n\t\tobj->growable_ = 1;\n\t} else {\n\t\tobj->bufsize_ = bufsize;\n\t\tobj->growable_ = 0;\n\t}\n\tif (buf) {\n\t\tobj->buf_ = (unsigned char *) buf;\n\t} else {\n\t\tobj->buf_ = jas_malloc(obj->bufsize_ * sizeof(char));\n\t\tobj->myalloc_ = 1;\n\t}\n\tif (!obj->buf_) {\n\t\tjas_stream_close(stream);\n\t\treturn 0;\n\t}\n\n\tif (bufsize > 0 && buf) {\n\t\t/* If a buffer was supplied by the caller and its length is positive,\n\t\t  make the associated buffer data appear in the stream initially. */\n\t\tobj->len_ = bufsize;\n\t} else {\n\t\t/* The stream is initially empty. */\n\t\tobj->len_ = 0;\n\t}\n\tobj->pos_ = 0;\n\t\n\treturn stream;\n}",
        "target": 1
    },
    {
        "func": "void jpc_qmfb_split_colres(jpc_fix_t *a, int numrows, int numcols,\n  int stride, int parity)\n{\n\n\tint bufsize = JPC_CEILDIVPOW2(numrows, 1);\n\tjpc_fix_t splitbuf[QMFB_SPLITBUFSIZE * JPC_QMFB_COLGRPSIZE];\n\tjpc_fix_t *buf = splitbuf;\n\tjpc_fix_t *srcptr;\n\tjpc_fix_t *dstptr;\n\tregister jpc_fix_t *srcptr2;\n\tregister jpc_fix_t *dstptr2;\n\tregister int n;\n\tregister int i;\n\tint m;\n\tint hstartcol;\n\n\t/* Get a buffer. */\n\tif (bufsize > QMFB_SPLITBUFSIZE) {\n\t\tif (!(buf = jas_malloc(bufsize * sizeof(jpc_fix_t)))) {\n\t\t\t/* We have no choice but to commit suicide in this case. */\n\t\t\tabort();\n\t\t}\n\t}\n\n\tif (numrows >= 2) {\n\t\thstartcol = (numrows + 1 - parity) >> 1;\n\t\tm = (parity) ? hstartcol : (numrows - hstartcol);\n\t\t/* Save the samples destined for the highpass channel. */\n\t\tn = m;\n\t\tdstptr = buf;\n\t\tsrcptr = &a[(1 - parity) * stride];\n\t\twhile (n-- > 0) {\n\t\t\tdstptr2 = dstptr;\n\t\t\tsrcptr2 = srcptr;\n\t\t\tfor (i = 0; i < numcols; ++i) {\n\t\t\t\t*dstptr2 = *srcptr2;\n\t\t\t\t++dstptr2;\n\t\t\t\t++srcptr2;\n\t\t\t}\n\t\t\tdstptr += numcols;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\t/* Copy the appropriate samples into the lowpass channel. */\n\t\tdstptr = &a[(1 - parity) * stride];\n\t\tsrcptr = &a[(2 - parity) * stride];\n\t\tn = numrows - m - (!parity);\n\t\twhile (n-- > 0) {\n\t\t\tdstptr2 = dstptr;\n\t\t\tsrcptr2 = srcptr;\n\t\t\tfor (i = 0; i < numcols; ++i) {\n\t\t\t\t*dstptr2 = *srcptr2;\n\t\t\t\t++dstptr2;\n\t\t\t\t++srcptr2;\n\t\t\t}\n\t\t\tdstptr += stride;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\t/* Copy the saved samples into the highpass channel. */\n\t\tdstptr = &a[hstartcol * stride];\n\t\tsrcptr = buf;\n\t\tn = m;\n\t\twhile (n-- > 0) {\n\t\t\tdstptr2 = dstptr;\n\t\t\tsrcptr2 = srcptr;\n\t\t\tfor (i = 0; i < numcols; ++i) {\n\t\t\t\t*dstptr2 = *srcptr2;\n\t\t\t\t++dstptr2;\n\t\t\t\t++srcptr2;\n\t\t\t}\n\t\t\tdstptr += stride;\n\t\t\tsrcptr += numcols;\n\t\t}\n\t}\n\n\t/* If the split buffer was allocated on the heap, free this memory. */\n\tif (buf != splitbuf) {\n\t\tjas_free(buf);\n\t}\n\n}",
        "target": 1
    },
    {
        "func": "static int jp2_pclr_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_pclr_t *pclr = &box->data.pclr;\n\tint lutsize;\n\tunsigned int i;\n\tunsigned int j;\n\tint_fast32_t x;\n\n\tpclr->lutdata = 0;\n\n\tif (jp2_getuint16(in, &pclr->numlutents) ||\n\t  jp2_getuint8(in, &pclr->numchans)) {\n\t\treturn -1;\n\t}\n\tlutsize = pclr->numlutents * pclr->numchans;\n\tif (!(pclr->lutdata = jas_malloc(lutsize * sizeof(int_fast32_t)))) {\n\t\treturn -1;\n\t}\n\tif (!(pclr->bpc = jas_malloc(pclr->numchans * sizeof(uint_fast8_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < pclr->numchans; ++i) {\n\t\tif (jp2_getuint8(in, &pclr->bpc[i])) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tfor (i = 0; i < pclr->numlutents; ++i) {\n\t\tfor (j = 0; j < pclr->numchans; ++j) {\n\t\t\tif (jp2_getint(in, (pclr->bpc[j] & 0x80) != 0,\n\t\t\t  (pclr->bpc[j] & 0x7f) + 1, &x)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tpclr->lutdata[i * pclr->numchans + j] = x;\n\t\t}\n\t}\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "int jas_stream_printf(jas_stream_t *stream, const char *fmt, ...)\n{\n\tva_list ap;\n\tchar buf[4096];\n\tint ret;\n\n\tva_start(ap, fmt);\n\tret = vsprintf(buf, fmt, ap);\n\tjas_stream_puts(stream, buf);\n\tva_end(ap);\n\treturn ret;\n}",
        "target": 1
    },
    {
        "func": "static inline int nla_ok(const struct nlattr *nla, int remaining)\n{\n\treturn remaining >= sizeof(*nla) &&\n\t       nla->nla_len >= sizeof(*nla) &&\n\t       nla->nla_len <= remaining;\n}",
        "target": 1
    },
    {
        "func": "static int pipe_to_file(struct pipe_inode_info *pipe, struct pipe_buffer *buf,\n\t\t\tstruct splice_desc *sd)\n{\n\tstruct file *file = sd->u.file;\n\tstruct address_space *mapping = file->f_mapping;\n\tunsigned int offset, this_len;\n\tstruct page *page;\n\tpgoff_t index;\n\tint ret;\n\n\t/*\n\t * make sure the data in this buffer is uptodate\n\t */\n\tret = buf->ops->confirm(pipe, buf);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tindex = sd->pos >> PAGE_CACHE_SHIFT;\n\toffset = sd->pos & ~PAGE_CACHE_MASK;\n\n\tthis_len = sd->len;\n\tif (this_len + offset > PAGE_CACHE_SIZE)\n\t\tthis_len = PAGE_CACHE_SIZE - offset;\n\nfind_page:\n\tpage = find_lock_page(mapping, index);\n\tif (!page) {\n\t\tret = -ENOMEM;\n\t\tpage = page_cache_alloc_cold(mapping);\n\t\tif (unlikely(!page))\n\t\t\tgoto out_ret;\n\n\t\t/*\n\t\t * This will also lock the page\n\t\t */\n\t\tret = add_to_page_cache_lru(page, mapping, index,\n\t\t\t\t\t    GFP_KERNEL);\n\t\tif (unlikely(ret))\n\t\t\tgoto out;\n\t}\n\n\tret = mapping->a_ops->prepare_write(file, page, offset, offset+this_len);\n\tif (unlikely(ret)) {\n\t\tloff_t isize = i_size_read(mapping->host);\n\n\t\tif (ret != AOP_TRUNCATED_PAGE)\n\t\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tif (ret == AOP_TRUNCATED_PAGE)\n\t\t\tgoto find_page;\n\n\t\t/*\n\t\t * prepare_write() may have instantiated a few blocks\n\t\t * outside i_size.  Trim these off again.\n\t\t */\n\t\tif (sd->pos + this_len > isize)\n\t\t\tvmtruncate(mapping->host, isize);\n\n\t\tgoto out_ret;\n\t}\n\n\tif (buf->page != page) {\n\t\t/*\n\t\t * Careful, ->map() uses KM_USER0!\n\t\t */\n\t\tchar *src = buf->ops->map(pipe, buf, 1);\n\t\tchar *dst = kmap_atomic(page, KM_USER1);\n\n\t\tmemcpy(dst + offset, src + buf->offset, this_len);\n\t\tflush_dcache_page(page);\n\t\tkunmap_atomic(dst, KM_USER1);\n\t\tbuf->ops->unmap(pipe, buf, src);\n\t}\n\n\tret = mapping->a_ops->commit_write(file, page, offset, offset+this_len);\n\tif (ret) {\n\t\tif (ret == AOP_TRUNCATED_PAGE) {\n\t\t\tpage_cache_release(page);\n\t\t\tgoto find_page;\n\t\t}\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\t/*\n\t\t * Partial write has happened, so 'ret' already initialized by\n\t\t * number of bytes written, Where is nothing we have to do here.\n\t\t */\n\t} else\n\t\tret = this_len;\n\t/*\n\t * Return the number of bytes written and mark page as\n\t * accessed, we are now done!\n\t */\n\tmark_page_accessed(page);\nout:\n\tpage_cache_release(page);\n\tunlock_page(page);\nout_ret:\n\treturn ret;\n}",
        "target": 1
    },
    {
        "func": "static int sctp_setsockopt_hmac_ident(struct sock *sk,\n\t\t\t\t    char __user *optval,\n\t\t\t\t    int optlen)\n{\n\tstruct sctp_hmacalgo *hmacs;\n\tint err;\n\n\tif (!sctp_auth_enable)\n\t\treturn -EACCES;\n\n\tif (optlen < sizeof(struct sctp_hmacalgo))\n\t\treturn -EINVAL;\n\n\thmacs = kmalloc(optlen, GFP_KERNEL);\n\tif (!hmacs)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(hmacs, optval, optlen)) {\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (hmacs->shmac_num_idents == 0 ||\n\t    hmacs->shmac_num_idents > SCTP_AUTH_NUM_HMACS) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\terr = sctp_auth_ep_set_hmacs(sctp_sk(sk)->ep, hmacs);\nout:\n\tkfree(hmacs);\n\treturn err;\n}",
        "target": 1
    },
    {
        "func": "int sctp_auth_ep_set_hmacs(struct sctp_endpoint *ep,\n\t\t\t   struct sctp_hmacalgo *hmacs)\n{\n\tint has_sha1 = 0;\n\t__u16 id;\n\tint i;\n\n\t/* Scan the list looking for unsupported id.  Also make sure that\n\t * SHA1 is specified.\n\t */\n\tfor (i = 0; i < hmacs->shmac_num_idents; i++) {\n\t\tid = hmacs->shmac_idents[i];\n\n\t\tif (SCTP_AUTH_HMAC_ID_SHA1 == id)\n\t\t\thas_sha1 = 1;\n\n\t\tif (!sctp_hmac_list[id].hmac_name)\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!has_sha1)\n\t\treturn -EINVAL;\n\n\tmemcpy(ep->auth_hmacs_list->hmac_ids, &hmacs->shmac_idents[0],\n\t\thmacs->shmac_num_idents * sizeof(__u16));\n\tep->auth_hmacs_list->param_hdr.length = htons(sizeof(sctp_paramhdr_t) +\n\t\t\t\thmacs->shmac_num_idents * sizeof(__u16));\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "int do_truncate(struct dentry *dentry, loff_t length, unsigned int time_attrs,\n\tstruct file *filp)\n{\n\tint err;\n\tstruct iattr newattrs;\n\n\t/* Not pretty: \"inode->i_size\" shouldn't really be signed. But it is. */\n\tif (length < 0)\n\t\treturn -EINVAL;\n\n\tnewattrs.ia_size = length;\n\tnewattrs.ia_valid = ATTR_SIZE | time_attrs;\n\tif (filp) {\n\t\tnewattrs.ia_file = filp;\n\t\tnewattrs.ia_valid |= ATTR_FILE;\n\t}\n\n\tmutex_lock(&dentry->d_inode->i_mutex);\n\terr = notify_change(dentry, &newattrs);\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\treturn err;\n}",
        "target": 1
    },
    {
        "func": "generic_file_splice_write(struct pipe_inode_info *pipe, struct file *out,\n\t\t\t  loff_t *ppos, size_t len, unsigned int flags)\n{\n\tstruct address_space *mapping = out->f_mapping;\n\tssize_t ret;\n\n\tret = splice_from_pipe(pipe, out, ppos, len, flags, pipe_to_file);\n\tif (ret > 0) {\n\t\tstruct inode *inode = mapping->host;\n\n\t\t*ppos += ret;\n\n\t\t/*\n\t\t * If file or inode is SYNC and we actually wrote some data,\n\t\t * sync it.\n\t\t */\n\t\tif (unlikely((out->f_flags & O_SYNC) || IS_SYNC(inode))) {\n\t\t\tint err;\n\n\t\t\tmutex_lock(&inode->i_mutex);\n\t\t\terr = generic_osync_inode(inode, mapping,\n\t\t\t\t\t\t  OSYNC_METADATA|OSYNC_DATA);\n\t\t\tmutex_unlock(&inode->i_mutex);\n\n\t\t\tif (err)\n\t\t\t\tret = err;\n\t\t}\n\t}\n\n\treturn ret;\n}",
        "target": 1
    },
    {
        "func": "generic_file_splice_write_nolock(struct pipe_inode_info *pipe, struct file *out,\n\t\t\t\t loff_t *ppos, size_t len, unsigned int flags)\n{\n\tstruct address_space *mapping = out->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tssize_t ret;\n\tint err;\n\n\tret = __splice_from_pipe(pipe, out, ppos, len, flags, pipe_to_file);\n\tif (ret > 0) {\n\t\t*ppos += ret;\n\n\t\t/*\n\t\t * If file or inode is SYNC and we actually wrote some data,\n\t\t * sync it.\n\t\t */\n\t\tif (unlikely((out->f_flags & O_SYNC) || IS_SYNC(inode))) {\n\t\t\terr = generic_osync_inode(inode, mapping,\n\t\t\t\t\t\t  OSYNC_METADATA|OSYNC_DATA);\n\n\t\t\tif (err)\n\t\t\t\tret = err;\n\t\t}\n\t}\n\n\treturn ret;\n}",
        "target": 1
    },
    {
        "func": "_dbus_validate_signature_with_reason (const DBusString *type_str,\n                                      int               type_pos,\n                                      int               len)\n{\n  const unsigned char *p;\n  const unsigned char *end;\n  int last;\n  int struct_depth;\n  int array_depth;\n  int dict_entry_depth;\n  DBusValidity result;\n\n  int element_count;\n  DBusList *element_count_stack;\n\n  result = DBUS_VALID;\n  element_count_stack = NULL;\n\n  if (!_dbus_list_append (&element_count_stack, _DBUS_INT_TO_POINTER (0)))\n    {\n      result = DBUS_VALIDITY_UNKNOWN_OOM_ERROR;\n      goto out;\n    }\n\n  _dbus_assert (type_str != NULL);\n  _dbus_assert (type_pos < _DBUS_INT32_MAX - len);\n  _dbus_assert (len >= 0);\n  _dbus_assert (type_pos >= 0);\n\n  if (len > DBUS_MAXIMUM_SIGNATURE_LENGTH)\n    {\n      result = DBUS_INVALID_SIGNATURE_TOO_LONG;\n      goto out;\n    }\n\n  p = _dbus_string_get_const_data_len (type_str, type_pos, 0);\n\n  end = _dbus_string_get_const_data_len (type_str, type_pos + len, 0);\n  struct_depth = 0;\n  array_depth = 0;\n  dict_entry_depth = 0;\n  last = DBUS_TYPE_INVALID;\n\n  while (p != end)\n    {\n      switch (*p)\n        {\n        case DBUS_TYPE_BYTE:\n        case DBUS_TYPE_BOOLEAN:\n        case DBUS_TYPE_INT16:\n        case DBUS_TYPE_UINT16:\n        case DBUS_TYPE_INT32:\n        case DBUS_TYPE_UINT32:\n        case DBUS_TYPE_INT64:\n        case DBUS_TYPE_UINT64:\n        case DBUS_TYPE_DOUBLE:\n        case DBUS_TYPE_STRING:\n        case DBUS_TYPE_OBJECT_PATH:\n        case DBUS_TYPE_SIGNATURE:\n        case DBUS_TYPE_VARIANT:\n          break;\n\n        case DBUS_TYPE_ARRAY:\n          array_depth += 1;\n          if (array_depth > DBUS_MAXIMUM_TYPE_RECURSION_DEPTH)\n            {\n              result = DBUS_INVALID_EXCEEDED_MAXIMUM_ARRAY_RECURSION;\n              goto out;\n            }\n          break;\n\n        case DBUS_STRUCT_BEGIN_CHAR:\n          struct_depth += 1;\n\n          if (struct_depth > DBUS_MAXIMUM_TYPE_RECURSION_DEPTH)\n            {\n              result = DBUS_INVALID_EXCEEDED_MAXIMUM_STRUCT_RECURSION;\n              goto out;\n            }\n          \n          if (!_dbus_list_append (&element_count_stack, \n                             _DBUS_INT_TO_POINTER (0)))\n            {\n              result = DBUS_VALIDITY_UNKNOWN_OOM_ERROR;\n              goto out;\n            }\n\n          break;\n\n        case DBUS_STRUCT_END_CHAR:\n          if (struct_depth == 0)\n            {\n              result = DBUS_INVALID_STRUCT_ENDED_BUT_NOT_STARTED;\n              goto out;\n            }\n\n          if (last == DBUS_STRUCT_BEGIN_CHAR)\n            {\n              result = DBUS_INVALID_STRUCT_HAS_NO_FIELDS;\n              goto out;\n            }\n\n          _dbus_list_pop_last (&element_count_stack);\n\n          struct_depth -= 1;\n          break;\n\n        case DBUS_DICT_ENTRY_BEGIN_CHAR:\n          if (last != DBUS_TYPE_ARRAY)\n            {\n              result = DBUS_INVALID_DICT_ENTRY_NOT_INSIDE_ARRAY;\n              goto out;\n            }\n            \n          dict_entry_depth += 1;\n\n          if (dict_entry_depth > DBUS_MAXIMUM_TYPE_RECURSION_DEPTH)\n            {\n              result = DBUS_INVALID_EXCEEDED_MAXIMUM_DICT_ENTRY_RECURSION;\n              goto out;\n            }\n\n          if (!_dbus_list_append (&element_count_stack, \n                             _DBUS_INT_TO_POINTER (0)))\n            {\n              result = DBUS_VALIDITY_UNKNOWN_OOM_ERROR;\n              goto out;\n            }\n\n          break;\n\n        case DBUS_DICT_ENTRY_END_CHAR:\n          if (dict_entry_depth == 0)\n            {\n              result = DBUS_INVALID_DICT_ENTRY_ENDED_BUT_NOT_STARTED;\n              goto out;\n            }\n            \n          dict_entry_depth -= 1;\n\n          element_count = \n            _DBUS_POINTER_TO_INT (_dbus_list_pop_last (&element_count_stack));\n\n          if (element_count != 2)\n            {\n              if (element_count == 0)\n                result = DBUS_INVALID_DICT_ENTRY_HAS_NO_FIELDS;\n              else if (element_count == 1)\n                result = DBUS_INVALID_DICT_ENTRY_HAS_ONLY_ONE_FIELD;\n              else\n                result = DBUS_INVALID_DICT_ENTRY_HAS_TOO_MANY_FIELDS;\n              \n              goto out;\n            }\n          break;\n          \n        case DBUS_TYPE_STRUCT:     /* doesn't appear in signatures */\n        case DBUS_TYPE_DICT_ENTRY: /* ditto */\n        default:\n          result = DBUS_INVALID_UNKNOWN_TYPECODE;\n\t  goto out;\n        }\n\n      if (*p != DBUS_TYPE_ARRAY && \n          *p != DBUS_DICT_ENTRY_BEGIN_CHAR && \n\t  *p != DBUS_STRUCT_BEGIN_CHAR) \n        {\n          element_count = \n            _DBUS_POINTER_TO_INT (_dbus_list_pop_last (&element_count_stack));\n\n          ++element_count;\n\n          if (!_dbus_list_append (&element_count_stack, \n                             _DBUS_INT_TO_POINTER (element_count)))\n            {\n              result = DBUS_VALIDITY_UNKNOWN_OOM_ERROR;\n              goto out;\n            }\n        }\n      \n      if (array_depth > 0)\n        {\n          if (*p == DBUS_TYPE_ARRAY && p != end)\n            {\n\t       const char *p1;\n\t       p1 = p + 1;\n               if (*p1 == DBUS_STRUCT_END_CHAR ||\n                   *p1 == DBUS_DICT_ENTRY_END_CHAR)\n                 {\n                   result = DBUS_INVALID_MISSING_ARRAY_ELEMENT_TYPE;\n                   goto out;\n                 }\n            }\n          else\n\t    {\n              array_depth = 0;\n\t    }\n        }\n\n      if (last == DBUS_DICT_ENTRY_BEGIN_CHAR &&\n          !dbus_type_is_basic (*p))\n        {\n          result = DBUS_INVALID_DICT_KEY_MUST_BE_BASIC_TYPE;\n          goto out;\n        }\n        \n      last = *p;\n      ++p;\n    }\n\n\n  if (array_depth > 0)\n    {\n      result = DBUS_INVALID_MISSING_ARRAY_ELEMENT_TYPE;\n      goto out;\n    }\n    \n  if (struct_depth > 0)\n    {\n       result = DBUS_INVALID_STRUCT_STARTED_BUT_NOT_ENDED;\n       goto out;\n    }\n    \n  if (dict_entry_depth > 0)\n    {\n      result =  DBUS_INVALID_DICT_ENTRY_STARTED_BUT_NOT_ENDED;\n      goto out;\n    }\n    \n  _dbus_assert (last != DBUS_TYPE_ARRAY);\n  _dbus_assert (last != DBUS_STRUCT_BEGIN_CHAR);\n  _dbus_assert (last != DBUS_DICT_ENTRY_BEGIN_CHAR);\n\n  result = DBUS_VALID;\n\nout:\n  _dbus_list_clear (&element_count_stack);\n  return result;\n}",
        "target": 1
    },
    {
        "func": "_dbus_marshal_validate_test (void)\n{\n  DBusString str;\n  int i;\n\n  const char *valid_paths[] = {\n    \"/\",\n    \"/foo/bar\",\n    \"/foo\",\n    \"/foo/bar/baz\"\n  };\n  const char *invalid_paths[] = {\n    \"bar\",\n    \"bar/baz\",\n    \"/foo/bar/\",\n    \"/foo/\"\n    \"foo/\",\n    \"boo//blah\",\n    \"//\",\n    \"///\",\n    \"foo///blah/\",\n    \"Hello World\",\n    \"\",\n    \"   \",\n    \"foo bar\"\n  };\n\n  const char *valid_interfaces[] = {\n    \"org.freedesktop.Foo\",\n    \"Bar.Baz\",\n    \"Blah.Blah.Blah.Blah.Blah\",\n    \"a.b\",\n    \"a.b.c.d.e.f.g\",\n    \"a0.b1.c2.d3.e4.f5.g6\",\n    \"abc123.foo27\"\n  };\n  const char *invalid_interfaces[] = {\n    \".\",\n    \"\",\n    \"..\",\n    \".Foo.Bar\",\n    \"..Foo.Bar\",\n    \"Foo.Bar.\",\n    \"Foo.Bar..\",\n    \"Foo\",\n    \"9foo.bar.baz\",\n    \"foo.bar..baz\",\n    \"foo.bar...baz\",\n    \"foo.bar.b..blah\",\n    \":\",\n    \":0-1\",\n    \"10\",\n    \":11.34324\",\n    \"0.0.0\",\n    \"0..0\",\n    \"foo.Bar.%\",\n    \"foo.Bar!!\",\n    \"!Foo.bar.bz\",\n    \"foo.$.blah\",\n    \"\",\n    \"   \",\n    \"foo bar\"\n  };\n\n  const char *valid_unique_names[] = {\n    \":0\",\n    \":a\",\n    \":\",\n    \":.a\",\n    \":.1\",\n    \":0.1\",\n    \":000.2222\",\n    \":.blah\",\n    \":abce.freedesktop.blah\"\n  };\n  const char *invalid_unique_names[] = {\n    //\":-\",\n    \":!\",\n    //\":0-10\",\n    \":blah.\",\n    \":blah.\",\n    \":blah..org\",\n    \":blah.org..\",\n    \":..blah.org\",\n    \"\",\n    \"   \",\n    \"foo bar\"\n  };\n\n  const char *valid_members[] = {\n    \"Hello\",\n    \"Bar\",\n    \"foobar\",\n    \"_foobar\",\n    \"foo89\"\n  };\n\n  const char *invalid_members[] = {\n    \"9Hello\",\n    \"10\",\n    \"1\",\n    \"foo-bar\",\n    \"blah.org\",\n    \".blah\",\n    \"blah.\",\n    \"Hello.\",\n    \"!foo\",\n    \"\",\n    \"   \",\n    \"foo bar\"\n  };\n\n  const char *valid_signatures[] = {\n    \"\",\n    \"sss\",\n    \"i\",\n    \"b\"\n  };\n\n  const char *invalid_signatures[] = {\n    \" \",\n    \"not a valid signature\",\n    \"123\",\n    \".\",\n    \"(\"\n  };\n\n  /* Signature with reason */\n\n  run_validity_tests (signature_tests, _DBUS_N_ELEMENTS (signature_tests),\n                      _dbus_validate_signature_with_reason);\n\n  /* Path validation */\n  i = 0;\n  while (i < (int) _DBUS_N_ELEMENTS (valid_paths))\n    {\n      _dbus_string_init_const (&str, valid_paths[i]);\n\n      if (!_dbus_validate_path (&str, 0,\n                                _dbus_string_get_length (&str)))\n        {\n          _dbus_warn (\"Path \\\"%s\\\" should have been valid\\n\", valid_paths[i]);\n          _dbus_assert_not_reached (\"invalid path\");\n        }\n\n      ++i;\n    }\n\n  i = 0;\n  while (i < (int) _DBUS_N_ELEMENTS (invalid_paths))\n    {\n      _dbus_string_init_const (&str, invalid_paths[i]);\n\n      if (_dbus_validate_path (&str, 0,\n                               _dbus_string_get_length (&str)))\n        {\n          _dbus_warn (\"Path \\\"%s\\\" should have been invalid\\n\", invalid_paths[i]);\n          _dbus_assert_not_reached (\"valid path\");\n        }\n\n      ++i;\n    }\n\n  /* Interface validation */\n  i = 0;\n  while (i < (int) _DBUS_N_ELEMENTS (valid_interfaces))\n    {\n      _dbus_string_init_const (&str, valid_interfaces[i]);\n\n      if (!_dbus_validate_interface (&str, 0,\n                                     _dbus_string_get_length (&str)))\n        {\n          _dbus_warn (\"Interface \\\"%s\\\" should have been valid\\n\", valid_interfaces[i]);\n          _dbus_assert_not_reached (\"invalid interface\");\n        }\n\n      ++i;\n    }\n\n  i = 0;\n  while (i < (int) _DBUS_N_ELEMENTS (invalid_interfaces))\n    {\n      _dbus_string_init_const (&str, invalid_interfaces[i]);\n\n      if (_dbus_validate_interface (&str, 0,\n                                    _dbus_string_get_length (&str)))\n        {\n          _dbus_warn (\"Interface \\\"%s\\\" should have been invalid\\n\", invalid_interfaces[i]);\n          _dbus_assert_not_reached (\"valid interface\");\n        }\n\n      ++i;\n    }\n\n  /* Bus name validation (check that valid interfaces are valid bus names,\n   * and invalid interfaces are invalid services except if they start with ':')\n   */\n  i = 0;\n  while (i < (int) _DBUS_N_ELEMENTS (valid_interfaces))\n    {\n      _dbus_string_init_const (&str, valid_interfaces[i]);\n\n      if (!_dbus_validate_bus_name (&str, 0,\n                                   _dbus_string_get_length (&str)))\n        {\n          _dbus_warn (\"Bus name \\\"%s\\\" should have been valid\\n\", valid_interfaces[i]);\n          _dbus_assert_not_reached (\"invalid bus name\");\n        }\n\n      ++i;\n    }\n\n  i = 0;\n  while (i < (int) _DBUS_N_ELEMENTS (invalid_interfaces))\n    {\n      if (invalid_interfaces[i][0] != ':')\n        {\n          _dbus_string_init_const (&str, invalid_interfaces[i]);\n\n          if (_dbus_validate_bus_name (&str, 0,\n                                       _dbus_string_get_length (&str)))\n            {\n              _dbus_warn (\"Bus name \\\"%s\\\" should have been invalid\\n\", invalid_interfaces[i]);\n              _dbus_assert_not_reached (\"valid bus name\");\n            }\n        }\n\n      ++i;\n    }\n\n  /* unique name validation */\n  i = 0;\n  while (i < (int) _DBUS_N_ELEMENTS (valid_unique_names))\n    {\n      _dbus_string_init_const (&str, valid_unique_names[i]);\n\n      if (!_dbus_validate_bus_name (&str, 0,\n                                    _dbus_string_get_length (&str)))\n        {\n          _dbus_warn (\"Bus name \\\"%s\\\" should have been valid\\n\", valid_unique_names[i]);\n          _dbus_assert_not_reached (\"invalid unique name\");\n        }\n\n      ++i;\n    }\n\n  i = 0;\n  while (i < (int) _DBUS_N_ELEMENTS (invalid_unique_names))\n    {\n      _dbus_string_init_const (&str, invalid_unique_names[i]);\n\n      if (_dbus_validate_bus_name (&str, 0,\n                                   _dbus_string_get_length (&str)))\n        {\n          _dbus_warn (\"Bus name \\\"%s\\\" should have been invalid\\n\", invalid_unique_names[i]);\n          _dbus_assert_not_reached (\"valid unique name\");\n        }\n\n      ++i;\n    }\n\n\n  /* Error name validation (currently identical to interfaces)\n   */\n  i = 0;\n  while (i < (int) _DBUS_N_ELEMENTS (valid_interfaces))\n    {\n      _dbus_string_init_const (&str, valid_interfaces[i]);\n\n      if (!_dbus_validate_error_name (&str, 0,\n                                      _dbus_string_get_length (&str)))\n        {\n          _dbus_warn (\"Error name \\\"%s\\\" should have been valid\\n\", valid_interfaces[i]);\n          _dbus_assert_not_reached (\"invalid error name\");\n        }\n\n      ++i;\n    }\n\n  i = 0;\n  while (i < (int) _DBUS_N_ELEMENTS (invalid_interfaces))\n    {\n      if (invalid_interfaces[i][0] != ':')\n        {\n          _dbus_string_init_const (&str, invalid_interfaces[i]);\n\n          if (_dbus_validate_error_name (&str, 0,\n                                         _dbus_string_get_length (&str)))\n            {\n              _dbus_warn (\"Error name \\\"%s\\\" should have been invalid\\n\", invalid_interfaces[i]);\n              _dbus_assert_not_reached (\"valid error name\");\n            }\n        }\n\n      ++i;\n    }\n\n  /* Member validation */\n  i = 0;\n  while (i < (int) _DBUS_N_ELEMENTS (valid_members))\n    {\n      _dbus_string_init_const (&str, valid_members[i]);\n\n      if (!_dbus_validate_member (&str, 0,\n                                  _dbus_string_get_length (&str)))\n        {\n          _dbus_warn (\"Member \\\"%s\\\" should have been valid\\n\", valid_members[i]);\n          _dbus_assert_not_reached (\"invalid member\");\n        }\n\n      ++i;\n    }\n\n  i = 0;\n  while (i < (int) _DBUS_N_ELEMENTS (invalid_members))\n    {\n      _dbus_string_init_const (&str, invalid_members[i]);\n\n      if (_dbus_validate_member (&str, 0,\n                                 _dbus_string_get_length (&str)))\n        {\n          _dbus_warn (\"Member \\\"%s\\\" should have been invalid\\n\", invalid_members[i]);\n          _dbus_assert_not_reached (\"valid member\");\n        }\n\n      ++i;\n    }\n\n  /* Signature validation */\n  i = 0;\n  while (i < (int) _DBUS_N_ELEMENTS (valid_signatures))\n    {\n      _dbus_string_init_const (&str, valid_signatures[i]);\n\n      if (!_dbus_validate_signature (&str, 0,\n                                     _dbus_string_get_length (&str)))\n        {\n          _dbus_warn (\"Signature \\\"%s\\\" should have been valid\\n\", valid_signatures[i]);\n          _dbus_assert_not_reached (\"invalid signature\");\n        }\n\n      ++i;\n    }\n\n  i = 0;\n  while (i < (int) _DBUS_N_ELEMENTS (invalid_signatures))\n    {\n      _dbus_string_init_const (&str, invalid_signatures[i]);\n\n      if (_dbus_validate_signature (&str, 0,\n                                    _dbus_string_get_length (&str)))\n        {\n          _dbus_warn (\"Signature \\\"%s\\\" should have been invalid\\n\", invalid_signatures[i]);\n          _dbus_assert_not_reached (\"valid signature\");\n        }\n\n      ++i;\n    }\n\n  /* Validate claimed length longer than real length */\n  _dbus_string_init_const (&str, \"abc.efg\");\n  if (_dbus_validate_bus_name (&str, 0, 8))\n    _dbus_assert_not_reached (\"validated too-long string\");\n  if (_dbus_validate_interface (&str, 0, 8))\n    _dbus_assert_not_reached (\"validated too-long string\");\n  if (_dbus_validate_error_name (&str, 0, 8))\n    _dbus_assert_not_reached (\"validated too-long string\");\n\n  _dbus_string_init_const (&str, \"abc\");\n  if (_dbus_validate_member (&str, 0, 4))\n    _dbus_assert_not_reached (\"validated too-long string\");\n\n  _dbus_string_init_const (&str, \"sss\");\n  if (_dbus_validate_signature (&str, 0, 4))\n    _dbus_assert_not_reached (\"validated too-long signature\");\n\n  /* Validate string exceeding max name length */\n  if (!_dbus_string_init (&str))\n    _dbus_assert_not_reached (\"no memory\");\n\n  while (_dbus_string_get_length (&str) <= DBUS_MAXIMUM_NAME_LENGTH)\n    if (!_dbus_string_append (&str, \"abc.def\"))\n      _dbus_assert_not_reached (\"no memory\");\n\n  if (_dbus_validate_bus_name (&str, 0, _dbus_string_get_length (&str)))\n    _dbus_assert_not_reached (\"validated overmax string\");\n  if (_dbus_validate_interface (&str, 0, _dbus_string_get_length (&str)))\n    _dbus_assert_not_reached (\"validated overmax string\");\n  if (_dbus_validate_error_name (&str, 0, _dbus_string_get_length (&str)))\n    _dbus_assert_not_reached (\"validated overmax string\");\n\n  /* overlong member */\n  _dbus_string_set_length (&str, 0);\n  while (_dbus_string_get_length (&str) <= DBUS_MAXIMUM_NAME_LENGTH)\n    if (!_dbus_string_append (&str, \"abc\"))\n      _dbus_assert_not_reached (\"no memory\");\n\n  if (_dbus_validate_member (&str, 0, _dbus_string_get_length (&str)))\n    _dbus_assert_not_reached (\"validated overmax string\");\n\n  /* overlong unique name */\n  _dbus_string_set_length (&str, 0);\n  _dbus_string_append (&str, \":\");\n  while (_dbus_string_get_length (&str) <= DBUS_MAXIMUM_NAME_LENGTH)\n    if (!_dbus_string_append (&str, \"abc\"))\n      _dbus_assert_not_reached (\"no memory\");\n\n  if (_dbus_validate_bus_name (&str, 0, _dbus_string_get_length (&str)))\n    _dbus_assert_not_reached (\"validated overmax string\");\n\n  _dbus_string_free (&str);\n\n  /* Body validation; test basic validation of valid bodies for both endian */\n  \n  {\n    int sequence;\n    DBusString signature;\n    DBusString body;\n\n    if (!_dbus_string_init (&signature) || !_dbus_string_init (&body))\n      _dbus_assert_not_reached (\"oom\");\n\n    sequence = 0;\n    while (dbus_internal_do_not_use_generate_bodies (sequence,\n                                                     DBUS_LITTLE_ENDIAN,\n                                                     &signature, &body))\n      {\n        DBusValidity validity;\n\n        validity = _dbus_validate_body_with_reason (&signature, 0,\n                                                    DBUS_LITTLE_ENDIAN,\n                                                    NULL, &body, 0,\n                                                    _dbus_string_get_length (&body));\n        if (validity != DBUS_VALID)\n          {\n            _dbus_warn (\"invalid code %d expected valid on sequence %d little endian\\n\",\n                        validity, sequence);\n            _dbus_verbose_bytes_of_string (&signature, 0, _dbus_string_get_length (&signature));\n            _dbus_verbose_bytes_of_string (&body, 0, _dbus_string_get_length (&body));\n            _dbus_assert_not_reached (\"test failed\");\n          }\n\n        _dbus_string_set_length (&signature, 0);\n        _dbus_string_set_length (&body, 0);\n        ++sequence;\n      }\n                                                     \n    sequence = 0;\n    while (dbus_internal_do_not_use_generate_bodies (sequence,\n                                                     DBUS_BIG_ENDIAN,\n                                                     &signature, &body))\n      {\n        DBusValidity validity;\n\n        validity = _dbus_validate_body_with_reason (&signature, 0,\n                                                    DBUS_BIG_ENDIAN,\n                                                    NULL, &body, 0,\n                                                    _dbus_string_get_length (&body));\n        if (validity != DBUS_VALID)\n          {\n            _dbus_warn (\"invalid code %d expected valid on sequence %d big endian\\n\",\n                        validity, sequence);\n            _dbus_verbose_bytes_of_string (&signature, 0, _dbus_string_get_length (&signature));\n            _dbus_verbose_bytes_of_string (&body, 0, _dbus_string_get_length (&body));\n            _dbus_assert_not_reached (\"test failed\");\n          }\n\n        _dbus_string_set_length (&signature, 0);\n        _dbus_string_set_length (&body, 0);\n        ++sequence;\n      }\n\n    _dbus_string_free (&signature);\n    _dbus_string_free (&body);\n  }\n  \n  return TRUE;\n}",
        "target": 1
    },
    {
        "func": "sctp_disposition_t sctp_sf_do_asconf_ack(const struct sctp_endpoint *ep,\n\t\t\t\t\t const struct sctp_association *asoc,\n\t\t\t\t\t const sctp_subtype_t type, void *arg,\n\t\t\t\t\t sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk\t*asconf_ack = arg;\n\tstruct sctp_chunk\t*last_asconf = asoc->addip_last_asconf;\n\tstruct sctp_chunk\t*abort;\n\tstruct sctp_paramhdr\t*err_param = NULL;\n\tsctp_addiphdr_t\t\t*addip_hdr;\n\t__u32\t\t\tsent_serial, rcvd_serial;\n\n\tif (!sctp_vtag_verify(asconf_ack, asoc)) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n\t\t\t\tSCTP_NULL());\n\t\treturn sctp_sf_pdiscard(ep, asoc, type, arg, commands);\n\t}\n\n\t/* ADD-IP, Section 4.1.2:\n\t * This chunk MUST be sent in an authenticated way by using\n\t * the mechanism defined in [I-D.ietf-tsvwg-sctp-auth]. If this chunk\n\t * is received unauthenticated it MUST be silently discarded as\n\t * described in [I-D.ietf-tsvwg-sctp-auth].\n\t */\n\tif (!sctp_addip_noauth && !asconf_ack->auth)\n\t\treturn sctp_sf_discard_chunk(ep, asoc, type, arg, commands);\n\n\t/* Make sure that the ADDIP chunk has a valid length.  */\n\tif (!sctp_chunk_length_valid(asconf_ack, sizeof(sctp_addip_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\taddip_hdr = (sctp_addiphdr_t *)asconf_ack->skb->data;\n\trcvd_serial = ntohl(addip_hdr->serial);\n\n\t/* Verify the ASCONF-ACK chunk before processing it. */\n\tif (!sctp_verify_asconf(asoc,\n\t    (sctp_paramhdr_t *)addip_hdr->params,\n\t    (void *)asconf_ack->chunk_end,\n\t    &err_param))\n\t\treturn sctp_sf_violation_paramlen(ep, asoc, type,\n\t\t\t   (void *)&err_param, commands);\n\n\tif (last_asconf) {\n\t\taddip_hdr = (sctp_addiphdr_t *)last_asconf->subh.addip_hdr;\n\t\tsent_serial = ntohl(addip_hdr->serial);\n\t} else {\n\t\tsent_serial = asoc->addip_serial - 1;\n\t}\n\n\t/* D0) If an endpoint receives an ASCONF-ACK that is greater than or\n\t * equal to the next serial number to be used but no ASCONF chunk is\n\t * outstanding the endpoint MUST ABORT the association. Note that a\n\t * sequence number is greater than if it is no more than 2^^31-1\n\t * larger than the current sequence number (using serial arithmetic).\n\t */\n\tif (ADDIP_SERIAL_gte(rcvd_serial, sent_serial + 1) &&\n\t    !(asoc->addip_last_asconf)) {\n\t\tabort = sctp_make_abort(asoc, asconf_ack,\n\t\t\t\t\tsizeof(sctp_errhdr_t));\n\t\tif (abort) {\n\t\t\tsctp_init_cause(abort, SCTP_ERROR_ASCONF_ACK, 0);\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(abort));\n\t\t}\n\t\t/* We are going to ABORT, so we might as well stop\n\t\t * processing the rest of the chunks in the packet.\n\t\t */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T4_RTO));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_DISCARD_PACKET,SCTP_NULL());\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ECONNABORTED));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_ASCONF_ACK));\n\t\tSCTP_INC_STATS(SCTP_MIB_ABORTEDS);\n\t\tSCTP_DEC_STATS(SCTP_MIB_CURRESTAB);\n\t\treturn SCTP_DISPOSITION_ABORT;\n\t}\n\n\tif ((rcvd_serial == sent_serial) && asoc->addip_last_asconf) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T4_RTO));\n\n\t\tif (!sctp_process_asconf_ack((struct sctp_association *)asoc,\n\t\t\t\t\t     asconf_ack))\n\t\t\treturn SCTP_DISPOSITION_CONSUME;\n\n\t\tabort = sctp_make_abort(asoc, asconf_ack,\n\t\t\t\t\tsizeof(sctp_errhdr_t));\n\t\tif (abort) {\n\t\t\tsctp_init_cause(abort, SCTP_ERROR_RSRC_LOW, 0);\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(abort));\n\t\t}\n\t\t/* We are going to ABORT, so we might as well stop\n\t\t * processing the rest of the chunks in the packet.\n\t\t */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_DISCARD_PACKET,SCTP_NULL());\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ECONNABORTED));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_ASCONF_ACK));\n\t\tSCTP_INC_STATS(SCTP_MIB_ABORTEDS);\n\t\tSCTP_DEC_STATS(SCTP_MIB_CURRESTAB);\n\t\treturn SCTP_DISPOSITION_ABORT;\n\t}\n\n\treturn SCTP_DISPOSITION_DISCARD;\n}",
        "target": 1
    },
    {
        "func": "static sctp_disposition_t sctp_sf_violation_paramlen(\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t     void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands) {\n\tstatic const char err_str[] = \"The following parameter had invalid length:\";\n\n\treturn sctp_sf_abort_violation(ep, asoc, arg, commands, err_str,\n\t\t\t\t\tsizeof(err_str));\n}",
        "target": 1
    },
    {
        "func": "static int sctp_process_inv_paramlength(const struct sctp_association *asoc,\n\t\t\t\t\tstruct sctp_paramhdr *param,\n\t\t\t\t\tconst struct sctp_chunk *chunk,\n\t\t\t\t\tstruct sctp_chunk **errp)\n{\n\tstatic const char error[] = \"The following parameter had invalid length:\";\n\tsize_t\t\tpayload_len = WORD_ROUND(sizeof(error)) +\n\t\t\t\t\t\tsizeof(sctp_paramhdr_t);\n\n\n\t/* This is a fatal error.  Any accumulated non-fatal errors are\n\t * not reported.\n\t */\n\tif (*errp)\n\t\tsctp_chunk_free(*errp);\n\n\t/* Create an error chunk and fill it in with our payload. */\n\t*errp = sctp_make_op_error_space(asoc, chunk, payload_len);\n\n\tif (*errp) {\n\t\tsctp_init_cause(*errp, SCTP_ERROR_PROTO_VIOLATION,\n\t\t\t\tsizeof(error) + sizeof(sctp_paramhdr_t));\n\t\tsctp_addto_chunk(*errp, sizeof(error), error);\n\t\tsctp_addto_param(*errp, sizeof(sctp_paramhdr_t), param);\n\t}\n\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "sctp_disposition_t sctp_sf_do_asconf(const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type, void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk\t*chunk = arg;\n\tstruct sctp_chunk\t*asconf_ack = NULL;\n\tstruct sctp_paramhdr\t*err_param = NULL;\n\tsctp_addiphdr_t\t\t*hdr;\n\tunion sctp_addr_param\t*addr_param;\n\t__u32\t\t\tserial;\n\tint\t\t\tlength;\n\n\tif (!sctp_vtag_verify(chunk, asoc)) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n\t\t\t\tSCTP_NULL());\n\t\treturn sctp_sf_pdiscard(ep, asoc, type, arg, commands);\n\t}\n\n\t/* ADD-IP: Section 4.1.1\n\t * This chunk MUST be sent in an authenticated way by using\n\t * the mechanism defined in [I-D.ietf-tsvwg-sctp-auth]. If this chunk\n\t * is received unauthenticated it MUST be silently discarded as\n\t * described in [I-D.ietf-tsvwg-sctp-auth].\n\t */\n\tif (!sctp_addip_noauth && !chunk->auth)\n\t\treturn sctp_sf_discard_chunk(ep, asoc, type, arg, commands);\n\n\t/* Make sure that the ASCONF ADDIP chunk has a valid length.  */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_addip_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\thdr = (sctp_addiphdr_t *)chunk->skb->data;\n\tserial = ntohl(hdr->serial);\n\n\taddr_param = (union sctp_addr_param *)hdr->params;\n\tlength = ntohs(addr_param->p.length);\n\tif (length < sizeof(sctp_paramhdr_t))\n\t\treturn sctp_sf_violation_paramlen(ep, asoc, type,\n\t\t\t   (void *)addr_param, commands);\n\n\t/* Verify the ASCONF chunk before processing it. */\n\tif (!sctp_verify_asconf(asoc,\n\t\t\t    (sctp_paramhdr_t *)((void *)addr_param + length),\n\t\t\t    (void *)chunk->chunk_end,\n\t\t\t    &err_param))\n\t\treturn sctp_sf_violation_paramlen(ep, asoc, type,\n\t\t\t\t\t\t  (void *)&err_param, commands);\n\n\t/* ADDIP 5.2 E1) Compare the value of the serial number to the value\n\t * the endpoint stored in a new association variable\n\t * 'Peer-Serial-Number'.\n\t */\n\tif (serial == asoc->peer.addip_serial + 1) {\n\t\t/* If this is the first instance of ASCONF in the packet,\n\t\t * we can clean our old ASCONF-ACKs.\n\t\t */\n\t\tif (!chunk->has_asconf)\n\t\t\tsctp_assoc_clean_asconf_ack_cache(asoc);\n\n\t\t/* ADDIP 5.2 E4) When the Sequence Number matches the next one\n\t\t * expected, process the ASCONF as described below and after\n\t\t * processing the ASCONF Chunk, append an ASCONF-ACK Chunk to\n\t\t * the response packet and cache a copy of it (in the event it\n\t\t * later needs to be retransmitted).\n\t\t *\n\t\t * Essentially, do V1-V5.\n\t\t */\n\t\tasconf_ack = sctp_process_asconf((struct sctp_association *)\n\t\t\t\t\t\t asoc, chunk);\n\t\tif (!asconf_ack)\n\t\t\treturn SCTP_DISPOSITION_NOMEM;\n\t} else if (serial < asoc->peer.addip_serial + 1) {\n\t\t/* ADDIP 5.2 E2)\n\t\t * If the value found in the Sequence Number is less than the\n\t\t * ('Peer- Sequence-Number' + 1), simply skip to the next\n\t\t * ASCONF, and include in the outbound response packet\n\t\t * any previously cached ASCONF-ACK response that was\n\t\t * sent and saved that matches the Sequence Number of the\n\t\t * ASCONF.  Note: It is possible that no cached ASCONF-ACK\n\t\t * Chunk exists.  This will occur when an older ASCONF\n\t\t * arrives out of order.  In such a case, the receiver\n\t\t * should skip the ASCONF Chunk and not include ASCONF-ACK\n\t\t * Chunk for that chunk.\n\t\t */\n\t\tasconf_ack = sctp_assoc_lookup_asconf_ack(asoc, hdr->serial);\n\t\tif (!asconf_ack)\n\t\t\treturn SCTP_DISPOSITION_DISCARD;\n\t} else {\n\t\t/* ADDIP 5.2 E5) Otherwise, the ASCONF Chunk is discarded since\n\t\t * it must be either a stale packet or from an attacker.\n\t\t */\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\t}\n\n\t/* ADDIP 5.2 E6)  The destination address of the SCTP packet\n\t * containing the ASCONF-ACK Chunks MUST be the source address of\n\t * the SCTP packet that held the ASCONF Chunks.\n\t *\n\t * To do this properly, we'll set the destination address of the chunk\n\t * and at the transmit time, will try look up the transport to use.\n\t * Since ASCONFs may be bundled, the correct transport may not be\n\t * created untill we process the entire packet, thus this workaround.\n\t */\n\tasconf_ack->dest = chunk->source;\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(asconf_ack));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}",
        "target": 1
    },
    {
        "func": "static int rtc_dev_release(struct inode *inode, struct file *file)\n{\n\tstruct rtc_device *rtc = file->private_data;\n\n#ifdef CONFIG_RTC_INTF_DEV_UIE_EMUL\n\tclear_uie(rtc);\n#endif\n\trtc_irq_set_state(rtc, NULL, 0);\n\n\tif (rtc->ops->release)\n\t\trtc->ops->release(rtc->dev.parent);\n\n\tclear_bit_unlock(RTC_DEV_BUSY, &rtc->flags);\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static int rtc_dev_fasync(int fd, struct file *file, int on)\n{\n\tstruct rtc_device *rtc = file->private_data;\n\treturn fasync_helper(fd, file, on, &rtc->async_queue);\n}",
        "target": 1
    },
    {
        "func": "struct sctp_transport *sctp_assoc_add_peer(struct sctp_association *asoc,\n\t\t\t\t\t   const union sctp_addr *addr,\n\t\t\t\t\t   const gfp_t gfp,\n\t\t\t\t\t   const int peer_state)\n{\n\tstruct sctp_transport *peer;\n\tstruct sctp_sock *sp;\n\tunsigned short port;\n\n\tsp = sctp_sk(asoc->base.sk);\n\n\t/* AF_INET and AF_INET6 share common port field. */\n\tport = ntohs(addr->v4.sin_port);\n\n\tSCTP_DEBUG_PRINTK_IPADDR(\"sctp_assoc_add_peer:association %p addr: \",\n\t\t\t\t \" port: %d state:%d\\n\",\n\t\t\t\t asoc,\n\t\t\t\t addr,\n\t\t\t\t port,\n\t\t\t\t peer_state);\n\n\t/* Set the port if it has not been set yet.  */\n\tif (0 == asoc->peer.port)\n\t\tasoc->peer.port = port;\n\n\t/* Check to see if this is a duplicate. */\n\tpeer = sctp_assoc_lookup_paddr(asoc, addr);\n\tif (peer) {\n\t\tif (peer->state == SCTP_UNKNOWN) {\n\t\t\tif (peer_state == SCTP_ACTIVE)\n\t\t\t\tpeer->state = SCTP_ACTIVE;\n\t\t\tif (peer_state == SCTP_UNCONFIRMED)\n\t\t\t\tpeer->state = SCTP_UNCONFIRMED;\n\t\t}\n\t\treturn peer;\n\t}\n\n\tpeer = sctp_transport_new(addr, gfp);\n\tif (!peer)\n\t\treturn NULL;\n\n\tsctp_transport_set_owner(peer, asoc);\n\n\t/* Initialize the peer's heartbeat interval based on the\n\t * association configured value.\n\t */\n\tpeer->hbinterval = asoc->hbinterval;\n\n\t/* Set the path max_retrans.  */\n\tpeer->pathmaxrxt = asoc->pathmaxrxt;\n\n\t/* Initialize the peer's SACK delay timeout based on the\n\t * association configured value.\n\t */\n\tpeer->sackdelay = asoc->sackdelay;\n\tpeer->sackfreq = asoc->sackfreq;\n\n\t/* Enable/disable heartbeat, SACK delay, and path MTU discovery\n\t * based on association setting.\n\t */\n\tpeer->param_flags = asoc->param_flags;\n\n\t/* Initialize the pmtu of the transport. */\n\tif (peer->param_flags & SPP_PMTUD_ENABLE)\n\t\tsctp_transport_pmtu(peer);\n\telse if (asoc->pathmtu)\n\t\tpeer->pathmtu = asoc->pathmtu;\n\telse\n\t\tpeer->pathmtu = SCTP_DEFAULT_MAXSEGMENT;\n\n\t/* If this is the first transport addr on this association,\n\t * initialize the association PMTU to the peer's PMTU.\n\t * If not and the current association PMTU is higher than the new\n\t * peer's PMTU, reset the association PMTU to the new peer's PMTU.\n\t */\n\tif (asoc->pathmtu)\n\t\tasoc->pathmtu = min_t(int, peer->pathmtu, asoc->pathmtu);\n\telse\n\t\tasoc->pathmtu = peer->pathmtu;\n\n\tSCTP_DEBUG_PRINTK(\"sctp_assoc_add_peer:association %p PMTU set to \"\n\t\t\t  \"%d\\n\", asoc, asoc->pathmtu);\n\tpeer->pmtu_pending = 0;\n\n\tasoc->frag_point = sctp_frag_point(sp, asoc->pathmtu);\n\n\t/* The asoc->peer.port might not be meaningful yet, but\n\t * initialize the packet structure anyway.\n\t */\n\tsctp_packet_init(&peer->packet, peer, asoc->base.bind_addr.port,\n\t\t\t asoc->peer.port);\n\n\t/* 7.2.1 Slow-Start\n\t *\n\t * o The initial cwnd before DATA transmission or after a sufficiently\n\t *   long idle period MUST be set to\n\t *      min(4*MTU, max(2*MTU, 4380 bytes))\n\t *\n\t * o The initial value of ssthresh MAY be arbitrarily high\n\t *   (for example, implementations MAY use the size of the\n\t *   receiver advertised window).\n\t */\n\tpeer->cwnd = min(4*asoc->pathmtu, max_t(__u32, 2*asoc->pathmtu, 4380));\n\n\t/* At this point, we may not have the receiver's advertised window,\n\t * so initialize ssthresh to the default value and it will be set\n\t * later when we process the INIT.\n\t */\n\tpeer->ssthresh = SCTP_DEFAULT_MAXWINDOW;\n\n\tpeer->partial_bytes_acked = 0;\n\tpeer->flight_size = 0;\n\n\t/* Set the transport's RTO.initial value */\n\tpeer->rto = asoc->rto_initial;\n\n\t/* Set the peer's active state. */\n\tpeer->state = peer_state;\n\n\t/* Attach the remote transport to our asoc.  */\n\tlist_add_tail(&peer->transports, &asoc->peer.transport_addr_list);\n\tasoc->peer.transport_count++;\n\n\t/* If we do not yet have a primary path, set one.  */\n\tif (!asoc->peer.primary_path) {\n\t\tsctp_assoc_set_primary(asoc, peer);\n\t\tasoc->peer.retran_path = peer;\n\t}\n\n\tif (asoc->peer.active_path == asoc->peer.retran_path) {\n\t\tasoc->peer.retran_path = peer;\n\t}\n\n\treturn peer;\n}",
        "target": 1
    },
    {
        "func": "int sctp_process_init(struct sctp_association *asoc, sctp_cid_t cid,\n\t\t      const union sctp_addr *peer_addr,\n\t\t      sctp_init_chunk_t *peer_init, gfp_t gfp)\n{\n\tunion sctp_params param;\n\tstruct sctp_transport *transport;\n\tstruct list_head *pos, *temp;\n\tchar *cookie;\n\n\t/* We must include the address that the INIT packet came from.\n\t * This is the only address that matters for an INIT packet.\n\t * When processing a COOKIE ECHO, we retrieve the from address\n\t * of the INIT from the cookie.\n\t */\n\n\t/* This implementation defaults to making the first transport\n\t * added as the primary transport.  The source address seems to\n\t * be a a better choice than any of the embedded addresses.\n\t */\n\tif (peer_addr) {\n\t\tif(!sctp_assoc_add_peer(asoc, peer_addr, gfp, SCTP_ACTIVE))\n\t\t\tgoto nomem;\n\t}\n\n\t/* Process the initialization parameters.  */\n\tsctp_walk_params(param, peer_init, init_hdr.params) {\n\n\t\tif (!sctp_process_param(asoc, param, peer_addr, gfp))\n\t\t\tgoto clean_up;\n\t}\n\n\t/* AUTH: After processing the parameters, make sure that we\n\t * have all the required info to potentially do authentications.\n\t */\n\tif (asoc->peer.auth_capable && (!asoc->peer.peer_random ||\n\t\t\t\t\t!asoc->peer.peer_hmacs))\n\t\tasoc->peer.auth_capable = 0;\n\n\t/* In a non-backward compatible mode, if the peer claims\n\t * support for ADD-IP but not AUTH,  the ADD-IP spec states\n\t * that we MUST ABORT the association. Section 6.  The section\n\t * also give us an option to silently ignore the packet, which\n\t * is what we'll do here.\n\t */\n\tif (!sctp_addip_noauth &&\n\t     (asoc->peer.asconf_capable && !asoc->peer.auth_capable)) {\n\t\tasoc->peer.addip_disabled_mask |= (SCTP_PARAM_ADD_IP |\n\t\t\t\t\t\t  SCTP_PARAM_DEL_IP |\n\t\t\t\t\t\t  SCTP_PARAM_SET_PRIMARY);\n\t\tasoc->peer.asconf_capable = 0;\n\t\tgoto clean_up;\n\t}\n\n\t/* Walk list of transports, removing transports in the UNKNOWN state. */\n\tlist_for_each_safe(pos, temp, &asoc->peer.transport_addr_list) {\n\t\ttransport = list_entry(pos, struct sctp_transport, transports);\n\t\tif (transport->state == SCTP_UNKNOWN) {\n\t\t\tsctp_assoc_rm_peer(asoc, transport);\n\t\t}\n\t}\n\n\t/* The fixed INIT headers are always in network byte\n\t * order.\n\t */\n\tasoc->peer.i.init_tag =\n\t\tntohl(peer_init->init_hdr.init_tag);\n\tasoc->peer.i.a_rwnd =\n\t\tntohl(peer_init->init_hdr.a_rwnd);\n\tasoc->peer.i.num_outbound_streams =\n\t\tntohs(peer_init->init_hdr.num_outbound_streams);\n\tasoc->peer.i.num_inbound_streams =\n\t\tntohs(peer_init->init_hdr.num_inbound_streams);\n\tasoc->peer.i.initial_tsn =\n\t\tntohl(peer_init->init_hdr.initial_tsn);\n\n\t/* Apply the upper bounds for output streams based on peer's\n\t * number of inbound streams.\n\t */\n\tif (asoc->c.sinit_num_ostreams  >\n\t    ntohs(peer_init->init_hdr.num_inbound_streams)) {\n\t\tasoc->c.sinit_num_ostreams =\n\t\t\tntohs(peer_init->init_hdr.num_inbound_streams);\n\t}\n\n\tif (asoc->c.sinit_max_instreams >\n\t    ntohs(peer_init->init_hdr.num_outbound_streams)) {\n\t\tasoc->c.sinit_max_instreams =\n\t\t\tntohs(peer_init->init_hdr.num_outbound_streams);\n\t}\n\n\t/* Copy Initiation tag from INIT to VT_peer in cookie.   */\n\tasoc->c.peer_vtag = asoc->peer.i.init_tag;\n\n\t/* Peer Rwnd   : Current calculated value of the peer's rwnd.  */\n\tasoc->peer.rwnd = asoc->peer.i.a_rwnd;\n\n\t/* Copy cookie in case we need to resend COOKIE-ECHO. */\n\tcookie = asoc->peer.cookie;\n\tif (cookie) {\n\t\tasoc->peer.cookie = kmemdup(cookie, asoc->peer.cookie_len, gfp);\n\t\tif (!asoc->peer.cookie)\n\t\t\tgoto clean_up;\n\t}\n\n\t/* RFC 2960 7.2.1 The initial value of ssthresh MAY be arbitrarily\n\t * high (for example, implementations MAY use the size of the receiver\n\t * advertised window).\n\t */\n\tlist_for_each_entry(transport, &asoc->peer.transport_addr_list,\n\t\t\ttransports) {\n\t\ttransport->ssthresh = asoc->peer.i.a_rwnd;\n\t}\n\n\t/* Set up the TSN tracking pieces.  */\n\tsctp_tsnmap_init(&asoc->peer.tsn_map, SCTP_TSN_MAP_SIZE,\n\t\t\t asoc->peer.i.initial_tsn);\n\n\t/* RFC 2960 6.5 Stream Identifier and Stream Sequence Number\n\t *\n\t * The stream sequence number in all the streams shall start\n\t * from 0 when the association is established.  Also, when the\n\t * stream sequence number reaches the value 65535 the next\n\t * stream sequence number shall be set to 0.\n\t */\n\n\t/* Allocate storage for the negotiated streams if it is not a temporary\n\t * association.\n\t */\n\tif (!asoc->temp) {\n\t\tint error;\n\n\t\tasoc->ssnmap = sctp_ssnmap_new(asoc->c.sinit_max_instreams,\n\t\t\t\t\t       asoc->c.sinit_num_ostreams, gfp);\n\t\tif (!asoc->ssnmap)\n\t\t\tgoto clean_up;\n\n\t\terror = sctp_assoc_set_id(asoc, gfp);\n\t\tif (error)\n\t\t\tgoto clean_up;\n\t}\n\n\t/* ADDIP Section 4.1 ASCONF Chunk Procedures\n\t *\n\t * When an endpoint has an ASCONF signaled change to be sent to the\n\t * remote endpoint it should do the following:\n\t * ...\n\t * A2) A serial number should be assigned to the Chunk. The serial\n\t * number should be a monotonically increasing number. All serial\n\t * numbers are defined to be initialized at the start of the\n\t * association to the same value as the Initial TSN.\n\t */\n\tasoc->peer.addip_serial = asoc->peer.i.initial_tsn - 1;\n\treturn 1;\n\nclean_up:\n\t/* Release the transport structures. */\n\tlist_for_each_safe(pos, temp, &asoc->peer.transport_addr_list) {\n\t\ttransport = list_entry(pos, struct sctp_transport, transports);\n\t\tlist_del_init(pos);\n\t\tsctp_transport_free(transport);\n\t}\n\n\tasoc->peer.transport_count = 0;\n\nnomem:\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static long do_splice_from(struct pipe_inode_info *pipe, struct file *out,\n\t\t\t   loff_t *ppos, size_t len, unsigned int flags)\n{\n\tint ret;\n\n\tif (unlikely(!out->f_op || !out->f_op->splice_write))\n\t\treturn -EINVAL;\n\n\tif (unlikely(!(out->f_mode & FMODE_WRITE)))\n\t\treturn -EBADF;\n\n\tret = rw_verify_area(WRITE, out, ppos, len);\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\n\treturn out->f_op->splice_write(pipe, out, ppos, len, flags);\n}",
        "target": 1
    },
    {
        "func": "int hfsplus_find_cat(struct super_block *sb, u32 cnid,\n\t\t     struct hfs_find_data *fd)\n{\n\thfsplus_cat_entry tmp;\n\tint err;\n\tu16 type;\n\n\thfsplus_cat_build_key(sb, fd->search_key, cnid, NULL);\n\terr = hfs_brec_read(fd, &tmp, sizeof(hfsplus_cat_entry));\n\tif (err)\n\t\treturn err;\n\n\ttype = be16_to_cpu(tmp.type);\n\tif (type != HFSPLUS_FOLDER_THREAD && type != HFSPLUS_FILE_THREAD) {\n\t\tprintk(KERN_ERR \"hfs: found bad thread record in catalog\\n\");\n\t\treturn -EIO;\n\t}\n\n\thfsplus_cat_build_key_uni(fd->search_key, be32_to_cpu(tmp.thread.parentID),\n\t\t\t\t &tmp.thread.nodeName);\n\treturn hfs_brec_find(fd);\n}",
        "target": 1
    },
    {
        "func": "int hfsplus_block_allocate(struct super_block *sb, u32 size, u32 offset, u32 *max)\n{\n\tstruct page *page;\n\tstruct address_space *mapping;\n\t__be32 *pptr, *curr, *end;\n\tu32 mask, start, len, n;\n\t__be32 val;\n\tint i;\n\n\tlen = *max;\n\tif (!len)\n\t\treturn size;\n\n\tdprint(DBG_BITMAP, \"block_allocate: %u,%u,%u\\n\", size, offset, len);\n\tmutex_lock(&HFSPLUS_SB(sb).alloc_file->i_mutex);\n\tmapping = HFSPLUS_SB(sb).alloc_file->i_mapping;\n\tpage = read_mapping_page(mapping, offset / PAGE_CACHE_BITS, NULL);\n\tpptr = kmap(page);\n\tcurr = pptr + (offset & (PAGE_CACHE_BITS - 1)) / 32;\n\ti = offset % 32;\n\toffset &= ~(PAGE_CACHE_BITS - 1);\n\tif ((size ^ offset) / PAGE_CACHE_BITS)\n\t\tend = pptr + PAGE_CACHE_BITS / 32;\n\telse\n\t\tend = pptr + ((size + 31) & (PAGE_CACHE_BITS - 1)) / 32;\n\n\t/* scan the first partial u32 for zero bits */\n\tval = *curr;\n\tif (~val) {\n\t\tn = be32_to_cpu(val);\n\t\tmask = (1U << 31) >> i;\n\t\tfor (; i < 32; mask >>= 1, i++) {\n\t\t\tif (!(n & mask))\n\t\t\t\tgoto found;\n\t\t}\n\t}\n\tcurr++;\n\n\t/* scan complete u32s for the first zero bit */\n\twhile (1) {\n\t\twhile (curr < end) {\n\t\t\tval = *curr;\n\t\t\tif (~val) {\n\t\t\t\tn = be32_to_cpu(val);\n\t\t\t\tmask = 1 << 31;\n\t\t\t\tfor (i = 0; i < 32; mask >>= 1, i++) {\n\t\t\t\t\tif (!(n & mask))\n\t\t\t\t\t\tgoto found;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurr++;\n\t\t}\n\t\tkunmap(page);\n\t\toffset += PAGE_CACHE_BITS;\n\t\tif (offset >= size)\n\t\t\tbreak;\n\t\tpage = read_mapping_page(mapping, offset / PAGE_CACHE_BITS,\n\t\t\t\t\t NULL);\n\t\tcurr = pptr = kmap(page);\n\t\tif ((size ^ offset) / PAGE_CACHE_BITS)\n\t\t\tend = pptr + PAGE_CACHE_BITS / 32;\n\t\telse\n\t\t\tend = pptr + ((size + 31) & (PAGE_CACHE_BITS - 1)) / 32;\n\t}\n\tdprint(DBG_BITMAP, \"bitmap full\\n\");\n\tstart = size;\n\tgoto out;\n\nfound:\n\tstart = offset + (curr - pptr) * 32 + i;\n\tif (start >= size) {\n\t\tdprint(DBG_BITMAP, \"bitmap full\\n\");\n\t\tgoto out;\n\t}\n\t/* do any partial u32 at the start */\n\tlen = min(size - start, len);\n\twhile (1) {\n\t\tn |= mask;\n\t\tif (++i >= 32)\n\t\t\tbreak;\n\t\tmask >>= 1;\n\t\tif (!--len || n & mask)\n\t\t\tgoto done;\n\t}\n\tif (!--len)\n\t\tgoto done;\n\t*curr++ = cpu_to_be32(n);\n\t/* do full u32s */\n\twhile (1) {\n\t\twhile (curr < end) {\n\t\t\tn = be32_to_cpu(*curr);\n\t\t\tif (len < 32)\n\t\t\t\tgoto last;\n\t\t\tif (n) {\n\t\t\t\tlen = 32;\n\t\t\t\tgoto last;\n\t\t\t}\n\t\t\t*curr++ = cpu_to_be32(0xffffffff);\n\t\t\tlen -= 32;\n\t\t}\n\t\tset_page_dirty(page);\n\t\tkunmap(page);\n\t\toffset += PAGE_CACHE_BITS;\n\t\tpage = read_mapping_page(mapping, offset / PAGE_CACHE_BITS,\n\t\t\t\t\t NULL);\n\t\tpptr = kmap(page);\n\t\tcurr = pptr;\n\t\tend = pptr + PAGE_CACHE_BITS / 32;\n\t}\nlast:\n\t/* do any partial u32 at end */\n\tmask = 1U << 31;\n\tfor (i = 0; i < len; i++) {\n\t\tif (n & mask)\n\t\t\tbreak;\n\t\tn |= mask;\n\t\tmask >>= 1;\n\t}\ndone:\n\t*curr = cpu_to_be32(n);\n\tset_page_dirty(page);\n\tkunmap(page);\n\t*max = offset + (curr - pptr) * 32 + i - start;\n\tHFSPLUS_SB(sb).free_blocks -= *max;\n\tsb->s_dirt = 1;\n\tdprint(DBG_BITMAP, \"-> %u,%u\\n\", start, *max);\nout:\n\tmutex_unlock(&HFSPLUS_SB(sb).alloc_file->i_mutex);\n\treturn start;\n}",
        "target": 1
    },
    {
        "func": "int hfs_cat_find_brec(struct super_block *sb, u32 cnid,\n\t\t      struct hfs_find_data *fd)\n{\n\thfs_cat_rec rec;\n\tint res, len, type;\n\n\thfs_cat_build_key(sb, fd->search_key, cnid, NULL);\n\tres = hfs_brec_read(fd, &rec, sizeof(rec));\n\tif (res)\n\t\treturn res;\n\n\ttype = rec.type;\n\tif (type != HFS_CDR_THD && type != HFS_CDR_FTH) {\n\t\tprintk(KERN_ERR \"hfs: found bad thread record in catalog\\n\");\n\t\treturn -EIO;\n\t}\n\n\tfd->search_key->cat.ParID = rec.thread.ParID;\n\tlen = fd->search_key->cat.CName.len = rec.thread.CName.len;\n\tmemcpy(fd->search_key->cat.CName.name, rec.thread.CName.name, len);\n\treturn hfs_brec_find(fd);\n}",
        "target": 1
    },
    {
        "func": "void __scm_destroy(struct scm_cookie *scm)\n{\n\tstruct scm_fp_list *fpl = scm->fp;\n\tint i;\n\n\tif (fpl) {\n\t\tscm->fp = NULL;\n\t\tfor (i=fpl->count-1; i>=0; i--)\n\t\t\tfput(fpl->fp[i]);\n\t\tkfree(fpl);\n\t}\n}",
        "target": 1
    },
    {
        "func": "static int scm_fp_copy(struct cmsghdr *cmsg, struct scm_fp_list **fplp)\n{\n\tint *fdp = (int*)CMSG_DATA(cmsg);\n\tstruct scm_fp_list *fpl = *fplp;\n\tstruct file **fpp;\n\tint i, num;\n\n\tnum = (cmsg->cmsg_len - CMSG_ALIGN(sizeof(struct cmsghdr)))/sizeof(int);\n\n\tif (num <= 0)\n\t\treturn 0;\n\n\tif (num > SCM_MAX_FD)\n\t\treturn -EINVAL;\n\n\tif (!fpl)\n\t{\n\t\tfpl = kmalloc(sizeof(struct scm_fp_list), GFP_KERNEL);\n\t\tif (!fpl)\n\t\t\treturn -ENOMEM;\n\t\t*fplp = fpl;\n\t\tfpl->count = 0;\n\t}\n\tfpp = &fpl->fp[fpl->count];\n\n\tif (fpl->count + num > SCM_MAX_FD)\n\t\treturn -EINVAL;\n\n\t/*\n\t *\tVerify the descriptors and increment the usage count.\n\t */\n\n\tfor (i=0; i< num; i++)\n\t{\n\t\tint fd = fdp[i];\n\t\tstruct file *file;\n\n\t\tif (fd < 0 || !(file = fget(fd)))\n\t\t\treturn -EBADF;\n\t\t*fpp++ = file;\n\t\tfpl->count++;\n\t}\n\treturn num;\n}",
        "target": 1
    },
    {
        "func": "struct scm_fp_list *scm_fp_dup(struct scm_fp_list *fpl)\n{\n\tstruct scm_fp_list *new_fpl;\n\tint i;\n\n\tif (!fpl)\n\t\treturn NULL;\n\n\tnew_fpl = kmalloc(sizeof(*fpl), GFP_KERNEL);\n\tif (new_fpl) {\n\t\tfor (i=fpl->count-1; i>=0; i--)\n\t\t\tget_file(fpl->fp[i]);\n\t\tmemcpy(new_fpl, fpl, sizeof(*fpl));\n\t}\n\treturn new_fpl;\n}",
        "target": 1
    },
    {
        "func": "static void inc_inflight_move_tail(struct unix_sock *u)\n{\n\tatomic_long_inc(&u->inflight);\n\t/*\n\t * If this is still a candidate, move it to the end of the\n\t * list, so that it's checked even if it was already passed\n\t * over\n\t */\n\tif (u->gc_candidate)\n\t\tlist_move_tail(&u->link, &gc_candidates);\n}",
        "target": 1
    },
    {
        "func": "static void unix_attach_fds(struct scm_cookie *scm, struct sk_buff *skb)\n{\n\tint i;\n\tfor (i=scm->fp->count-1; i>=0; i--)\n\t\tunix_inflight(scm->fp->fp[i]);\n\tUNIXCB(skb).fp = scm->fp;\n\tskb->destructor = unix_destruct_fds;\n\tscm->fp = NULL;\n}",
        "target": 1
    },
    {
        "func": "static void scan_inflight(struct sock *x, void (*func)(struct unix_sock *),\n\t\t\t  struct sk_buff_head *hitlist)\n{\n\tstruct sk_buff *skb;\n\tstruct sk_buff *next;\n\n\tspin_lock(&x->sk_receive_queue.lock);\n\treceive_queue_for_each_skb(x, next, skb) {\n\t\t/*\n\t\t *\tDo we have file descriptors ?\n\t\t */\n\t\tif (UNIXCB(skb).fp) {\n\t\t\tbool hit = false;\n\t\t\t/*\n\t\t\t *\tProcess the descriptors of this socket\n\t\t\t */\n\t\t\tint nfd = UNIXCB(skb).fp->count;\n\t\t\tstruct file **fp = UNIXCB(skb).fp->fp;\n\t\t\twhile (nfd--) {\n\t\t\t\t/*\n\t\t\t\t *\tGet the socket the fd matches\n\t\t\t\t *\tif it indeed does so\n\t\t\t\t */\n\t\t\t\tstruct sock *sk = unix_get_socket(*fp++);\n\t\t\t\tif (sk) {\n\t\t\t\t\thit = true;\n\t\t\t\t\tfunc(unix_sk(sk));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hit && hitlist != NULL) {\n\t\t\t\t__skb_unlink(skb, &x->sk_receive_queue);\n\t\t\t\t__skb_queue_tail(hitlist, skb);\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock(&x->sk_receive_queue.lock);\n}",
        "target": 1
    },
    {
        "func": "void unix_gc(void)\n{\n\tstatic bool gc_in_progress = false;\n\n\tstruct unix_sock *u;\n\tstruct unix_sock *next;\n\tstruct sk_buff_head hitlist;\n\tstruct list_head cursor;\n\n\tspin_lock(&unix_gc_lock);\n\n\t/* Avoid a recursive GC. */\n\tif (gc_in_progress)\n\t\tgoto out;\n\n\tgc_in_progress = true;\n\t/*\n\t * First, select candidates for garbage collection.  Only\n\t * in-flight sockets are considered, and from those only ones\n\t * which don't have any external reference.\n\t *\n\t * Holding unix_gc_lock will protect these candidates from\n\t * being detached, and hence from gaining an external\n\t * reference.  This also means, that since there are no\n\t * possible receivers, the receive queues of these sockets are\n\t * static during the GC, even though the dequeue is done\n\t * before the detach without atomicity guarantees.\n\t */\n\tlist_for_each_entry_safe(u, next, &gc_inflight_list, link) {\n\t\tlong total_refs;\n\t\tlong inflight_refs;\n\n\t\ttotal_refs = file_count(u->sk.sk_socket->file);\n\t\tinflight_refs = atomic_long_read(&u->inflight);\n\n\t\tBUG_ON(inflight_refs < 1);\n\t\tBUG_ON(total_refs < inflight_refs);\n\t\tif (total_refs == inflight_refs) {\n\t\t\tlist_move_tail(&u->link, &gc_candidates);\n\t\t\tu->gc_candidate = 1;\n\t\t}\n\t}\n\n\t/*\n\t * Now remove all internal in-flight reference to children of\n\t * the candidates.\n\t */\n\tlist_for_each_entry(u, &gc_candidates, link)\n\t\tscan_children(&u->sk, dec_inflight, NULL);\n\n\t/*\n\t * Restore the references for children of all candidates,\n\t * which have remaining references.  Do this recursively, so\n\t * only those remain, which form cyclic references.\n\t *\n\t * Use a \"cursor\" link, to make the list traversal safe, even\n\t * though elements might be moved about.\n\t */\n\tlist_add(&cursor, &gc_candidates);\n\twhile (cursor.next != &gc_candidates) {\n\t\tu = list_entry(cursor.next, struct unix_sock, link);\n\n\t\t/* Move cursor to after the current position. */\n\t\tlist_move(&cursor, &u->link);\n\n\t\tif (atomic_long_read(&u->inflight) > 0) {\n\t\t\tlist_move_tail(&u->link, &gc_inflight_list);\n\t\t\tu->gc_candidate = 0;\n\t\t\tscan_children(&u->sk, inc_inflight_move_tail, NULL);\n\t\t}\n\t}\n\tlist_del(&cursor);\n\n\t/*\n\t * Now gc_candidates contains only garbage.  Restore original\n\t * inflight counters for these as well, and remove the skbuffs\n\t * which are creating the cycle(s).\n\t */\n\tskb_queue_head_init(&hitlist);\n\tlist_for_each_entry(u, &gc_candidates, link)\n\t\tscan_children(&u->sk, inc_inflight, &hitlist);\n\n\tspin_unlock(&unix_gc_lock);\n\n\t/* Here we are. Hitlist is filled. Die. */\n\t__skb_queue_purge(&hitlist);\n\n\tspin_lock(&unix_gc_lock);\n\n\t/* All candidates should have been detached by now. */\n\tBUG_ON(!list_empty(&gc_candidates));\n\tgc_in_progress = false;\n\n out:\n\tspin_unlock(&unix_gc_lock);\n}",
        "target": 1
    },
    {
        "func": "static int unix_dgram_sendmsg(struct kiocb *kiocb, struct socket *sock,\n\t\t\t      struct msghdr *msg, size_t len)\n{\n\tstruct sock_iocb *siocb = kiocb_to_siocb(kiocb);\n\tstruct sock *sk = sock->sk;\n\tstruct net *net = sock_net(sk);\n\tstruct unix_sock *u = unix_sk(sk);\n\tstruct sockaddr_un *sunaddr=msg->msg_name;\n\tstruct sock *other = NULL;\n\tint namelen = 0; /* fake GCC */\n\tint err;\n\tunsigned hash;\n\tstruct sk_buff *skb;\n\tlong timeo;\n\tstruct scm_cookie tmp_scm;\n\n\tif (NULL == siocb->scm)\n\t\tsiocb->scm = &tmp_scm;\n\terr = scm_send(sock, msg, siocb->scm);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = -EOPNOTSUPP;\n\tif (msg->msg_flags&MSG_OOB)\n\t\tgoto out;\n\n\tif (msg->msg_namelen) {\n\t\terr = unix_mkname(sunaddr, msg->msg_namelen, &hash);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\tnamelen = err;\n\t} else {\n\t\tsunaddr = NULL;\n\t\terr = -ENOTCONN;\n\t\tother = unix_peer_get(sk);\n\t\tif (!other)\n\t\t\tgoto out;\n\t}\n\n\tif (test_bit(SOCK_PASSCRED, &sock->flags)\n\t\t&& !u->addr && (err = unix_autobind(sock)) != 0)\n\t\tgoto out;\n\n\terr = -EMSGSIZE;\n\tif (len > sk->sk_sndbuf - 32)\n\t\tgoto out;\n\n\tskb = sock_alloc_send_skb(sk, len, msg->msg_flags&MSG_DONTWAIT, &err);\n\tif (skb==NULL)\n\t\tgoto out;\n\n\tmemcpy(UNIXCREDS(skb), &siocb->scm->creds, sizeof(struct ucred));\n\tif (siocb->scm->fp)\n\t\tunix_attach_fds(siocb->scm, skb);\n\tunix_get_secdata(siocb->scm, skb);\n\n\tskb_reset_transport_header(skb);\n\terr = memcpy_fromiovec(skb_put(skb,len), msg->msg_iov, len);\n\tif (err)\n\t\tgoto out_free;\n\n\ttimeo = sock_sndtimeo(sk, msg->msg_flags & MSG_DONTWAIT);\n\nrestart:\n\tif (!other) {\n\t\terr = -ECONNRESET;\n\t\tif (sunaddr == NULL)\n\t\t\tgoto out_free;\n\n\t\tother = unix_find_other(net, sunaddr, namelen, sk->sk_type,\n\t\t\t\t\thash, &err);\n\t\tif (other==NULL)\n\t\t\tgoto out_free;\n\t}\n\n\tunix_state_lock(other);\n\terr = -EPERM;\n\tif (!unix_may_send(sk, other))\n\t\tgoto out_unlock;\n\n\tif (sock_flag(other, SOCK_DEAD)) {\n\t\t/*\n\t\t *\tCheck with 1003.1g - what should\n\t\t *\tdatagram error\n\t\t */\n\t\tunix_state_unlock(other);\n\t\tsock_put(other);\n\n\t\terr = 0;\n\t\tunix_state_lock(sk);\n\t\tif (unix_peer(sk) == other) {\n\t\t\tunix_peer(sk)=NULL;\n\t\t\tunix_state_unlock(sk);\n\n\t\t\tunix_dgram_disconnected(sk, other);\n\t\t\tsock_put(other);\n\t\t\terr = -ECONNREFUSED;\n\t\t} else {\n\t\t\tunix_state_unlock(sk);\n\t\t}\n\n\t\tother = NULL;\n\t\tif (err)\n\t\t\tgoto out_free;\n\t\tgoto restart;\n\t}\n\n\terr = -EPIPE;\n\tif (other->sk_shutdown & RCV_SHUTDOWN)\n\t\tgoto out_unlock;\n\n\tif (sk->sk_type != SOCK_SEQPACKET) {\n\t\terr = security_unix_may_send(sk->sk_socket, other->sk_socket);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\t}\n\n\tif (unix_peer(other) != sk && unix_recvq_full(other)) {\n\t\tif (!timeo) {\n\t\t\terr = -EAGAIN;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\ttimeo = unix_wait_for_peer(other, timeo);\n\n\t\terr = sock_intr_errno(timeo);\n\t\tif (signal_pending(current))\n\t\t\tgoto out_free;\n\n\t\tgoto restart;\n\t}\n\n\tskb_queue_tail(&other->sk_receive_queue, skb);\n\tunix_state_unlock(other);\n\tother->sk_data_ready(other, len);\n\tsock_put(other);\n\tscm_destroy(siocb->scm);\n\treturn len;\n\nout_unlock:\n\tunix_state_unlock(other);\nout_free:\n\tkfree_skb(skb);\nout:\n\tif (other)\n\t\tsock_put(other);\n\tscm_destroy(siocb->scm);\n\treturn err;\n}",
        "target": 1
    },
    {
        "func": "static int unix_stream_sendmsg(struct kiocb *kiocb, struct socket *sock,\n\t\t\t       struct msghdr *msg, size_t len)\n{\n\tstruct sock_iocb *siocb = kiocb_to_siocb(kiocb);\n\tstruct sock *sk = sock->sk;\n\tstruct sock *other = NULL;\n\tstruct sockaddr_un *sunaddr=msg->msg_name;\n\tint err,size;\n\tstruct sk_buff *skb;\n\tint sent=0;\n\tstruct scm_cookie tmp_scm;\n\n\tif (NULL == siocb->scm)\n\t\tsiocb->scm = &tmp_scm;\n\terr = scm_send(sock, msg, siocb->scm);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = -EOPNOTSUPP;\n\tif (msg->msg_flags&MSG_OOB)\n\t\tgoto out_err;\n\n\tif (msg->msg_namelen) {\n\t\terr = sk->sk_state == TCP_ESTABLISHED ? -EISCONN : -EOPNOTSUPP;\n\t\tgoto out_err;\n\t} else {\n\t\tsunaddr = NULL;\n\t\terr = -ENOTCONN;\n\t\tother = unix_peer(sk);\n\t\tif (!other)\n\t\t\tgoto out_err;\n\t}\n\n\tif (sk->sk_shutdown & SEND_SHUTDOWN)\n\t\tgoto pipe_err;\n\n\twhile(sent < len)\n\t{\n\t\t/*\n\t\t *\tOptimisation for the fact that under 0.01% of X\n\t\t *\tmessages typically need breaking up.\n\t\t */\n\n\t\tsize = len-sent;\n\n\t\t/* Keep two messages in the pipe so it schedules better */\n\t\tif (size > ((sk->sk_sndbuf >> 1) - 64))\n\t\t\tsize = (sk->sk_sndbuf >> 1) - 64;\n\n\t\tif (size > SKB_MAX_ALLOC)\n\t\t\tsize = SKB_MAX_ALLOC;\n\n\t\t/*\n\t\t *\tGrab a buffer\n\t\t */\n\n\t\tskb=sock_alloc_send_skb(sk,size,msg->msg_flags&MSG_DONTWAIT, &err);\n\n\t\tif (skb==NULL)\n\t\t\tgoto out_err;\n\n\t\t/*\n\t\t *\tIf you pass two values to the sock_alloc_send_skb\n\t\t *\tit tries to grab the large buffer with GFP_NOFS\n\t\t *\t(which can fail easily), and if it fails grab the\n\t\t *\tfallback size buffer which is under a page and will\n\t\t *\tsucceed. [Alan]\n\t\t */\n\t\tsize = min_t(int, size, skb_tailroom(skb));\n\n\t\tmemcpy(UNIXCREDS(skb), &siocb->scm->creds, sizeof(struct ucred));\n\t\tif (siocb->scm->fp)\n\t\t\tunix_attach_fds(siocb->scm, skb);\n\n\t\tif ((err = memcpy_fromiovec(skb_put(skb,size), msg->msg_iov, size)) != 0) {\n\t\t\tkfree_skb(skb);\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tunix_state_lock(other);\n\n\t\tif (sock_flag(other, SOCK_DEAD) ||\n\t\t    (other->sk_shutdown & RCV_SHUTDOWN))\n\t\t\tgoto pipe_err_free;\n\n\t\tskb_queue_tail(&other->sk_receive_queue, skb);\n\t\tunix_state_unlock(other);\n\t\tother->sk_data_ready(other, size);\n\t\tsent+=size;\n\t}\n\n\tscm_destroy(siocb->scm);\n\tsiocb->scm = NULL;\n\n\treturn sent;\n\npipe_err_free:\n\tunix_state_unlock(other);\n\tkfree_skb(skb);\npipe_err:\n\tif (sent==0 && !(msg->msg_flags&MSG_NOSIGNAL))\n\t\tsend_sig(SIGPIPE,current,0);\n\terr = -EPIPE;\nout_err:\n\tscm_destroy(siocb->scm);\n\tsiocb->scm = NULL;\n\treturn sent ? : err;\n}",
        "target": 1
    },
    {
        "func": "static int unix_stream_connect(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t       int addr_len, int flags)\n{\n\tstruct sockaddr_un *sunaddr=(struct sockaddr_un *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct unix_sock *u = unix_sk(sk), *newu, *otheru;\n\tstruct sock *newsk = NULL;\n\tstruct sock *other = NULL;\n\tstruct sk_buff *skb = NULL;\n\tunsigned hash;\n\tint st;\n\tint err;\n\tlong timeo;\n\n\terr = unix_mkname(sunaddr, addr_len, &hash);\n\tif (err < 0)\n\t\tgoto out;\n\taddr_len = err;\n\n\tif (test_bit(SOCK_PASSCRED, &sock->flags)\n\t\t&& !u->addr && (err = unix_autobind(sock)) != 0)\n\t\tgoto out;\n\n\ttimeo = sock_sndtimeo(sk, flags & O_NONBLOCK);\n\n\t/* First of all allocate resources.\n\t   If we will make it after state is locked,\n\t   we will have to recheck all again in any case.\n\t */\n\n\terr = -ENOMEM;\n\n\t/* create new sock for complete connection */\n\tnewsk = unix_create1(NULL);\n\tif (newsk == NULL)\n\t\tgoto out;\n\n\t/* Allocate skb for sending to listening sock */\n\tskb = sock_wmalloc(newsk, 1, 0, GFP_KERNEL);\n\tif (skb == NULL)\n\t\tgoto out;\n\nrestart:\n\t/*  Find listening sock. */\n\tother = unix_find_other(sunaddr, addr_len, sk->sk_type, hash, &err);\n\tif (!other)\n\t\tgoto out;\n\n\t/* Latch state of peer */\n\tunix_state_lock(other);\n\n\t/* Apparently VFS overslept socket death. Retry. */\n\tif (sock_flag(other, SOCK_DEAD)) {\n\t\tunix_state_unlock(other);\n\t\tsock_put(other);\n\t\tgoto restart;\n\t}\n\n\terr = -ECONNREFUSED;\n\tif (other->sk_state != TCP_LISTEN)\n\t\tgoto out_unlock;\n\n\tif (skb_queue_len(&other->sk_receive_queue) >\n\t    other->sk_max_ack_backlog) {\n\t\terr = -EAGAIN;\n\t\tif (!timeo)\n\t\t\tgoto out_unlock;\n\n\t\ttimeo = unix_wait_for_peer(other, timeo);\n\n\t\terr = sock_intr_errno(timeo);\n\t\tif (signal_pending(current))\n\t\t\tgoto out;\n\t\tsock_put(other);\n\t\tgoto restart;\n\t}\n\n\t/* Latch our state.\n\n\t   It is tricky place. We need to grab write lock and cannot\n\t   drop lock on peer. It is dangerous because deadlock is\n\t   possible. Connect to self case and simultaneous\n\t   attempt to connect are eliminated by checking socket\n\t   state. other is TCP_LISTEN, if sk is TCP_LISTEN we\n\t   check this before attempt to grab lock.\n\n\t   Well, and we have to recheck the state after socket locked.\n\t */\n\tst = sk->sk_state;\n\n\tswitch (st) {\n\tcase TCP_CLOSE:\n\t\t/* This is ok... continue with connect */\n\t\tbreak;\n\tcase TCP_ESTABLISHED:\n\t\t/* Socket is already connected */\n\t\terr = -EISCONN;\n\t\tgoto out_unlock;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tunix_state_lock_nested(sk);\n\n\tif (sk->sk_state != st) {\n\t\tunix_state_unlock(sk);\n\t\tunix_state_unlock(other);\n\t\tsock_put(other);\n\t\tgoto restart;\n\t}\n\n\terr = security_unix_stream_connect(sock, other->sk_socket, newsk);\n\tif (err) {\n\t\tunix_state_unlock(sk);\n\t\tgoto out_unlock;\n\t}\n\n\t/* The way is open! Fastly set all the necessary fields... */\n\n\tsock_hold(sk);\n\tunix_peer(newsk)\t= sk;\n\tnewsk->sk_state\t\t= TCP_ESTABLISHED;\n\tnewsk->sk_type\t\t= sk->sk_type;\n\tnewsk->sk_peercred.pid\t= current->tgid;\n\tnewsk->sk_peercred.uid\t= current->euid;\n\tnewsk->sk_peercred.gid\t= current->egid;\n\tnewu = unix_sk(newsk);\n\tnewsk->sk_sleep\t\t= &newu->peer_wait;\n\totheru = unix_sk(other);\n\n\t/* copy address information from listening to new sock*/\n\tif (otheru->addr) {\n\t\tatomic_inc(&otheru->addr->refcnt);\n\t\tnewu->addr = otheru->addr;\n\t}\n\tif (otheru->dentry) {\n\t\tnewu->dentry\t= dget(otheru->dentry);\n\t\tnewu->mnt\t= mntget(otheru->mnt);\n\t}\n\n\t/* Set credentials */\n\tsk->sk_peercred = other->sk_peercred;\n\n\tsock->state\t= SS_CONNECTED;\n\tsk->sk_state\t= TCP_ESTABLISHED;\n\tsock_hold(newsk);\n\n\tsmp_mb__after_atomic_inc();\t/* sock_hold() does an atomic_inc() */\n\tunix_peer(sk)\t= newsk;\n\n\tunix_state_unlock(sk);\n\n\t/* take ten and and send info to listening sock */\n\tspin_lock(&other->sk_receive_queue.lock);\n\t__skb_queue_tail(&other->sk_receive_queue, skb);\n\t/* Undo artificially decreased inflight after embrion\n\t * is installed to listening socket. */\n\tatomic_inc(&newu->inflight);\n\tspin_unlock(&other->sk_receive_queue.lock);\n\tunix_state_unlock(other);\n\tother->sk_data_ready(other, 0);\n\tsock_put(other);\n\treturn 0;\n\nout_unlock:\n\tif (other)\n\t\tunix_state_unlock(other);\n\nout:\n\tif (skb)\n\t\tkfree_skb(skb);\n\tif (newsk)\n\t\tunix_release_sock(newsk, 0);\n\tif (other)\n\t\tsock_put(other);\n\treturn err;\n}",
        "target": 1
    },
    {
        "func": "static inline int empty_stack(void)\n{\n\treturn gc_current == GC_HEAD;\n}",
        "target": 1
    },
    {
        "func": "static void maybe_unmark_and_push(struct sock *x)\n{\n\tstruct unix_sock *u = unix_sk(x);\n\n\tif (u->gc_tree != GC_ORPHAN)\n\t\treturn;\n\tsock_hold(x);\n\tu->gc_tree = gc_current;\n\tgc_current = x;\n}",
        "target": 1
    },
    {
        "func": "void unix_gc(void)\n{\n\tstatic DEFINE_MUTEX(unix_gc_sem);\n\tint i;\n\tstruct sock *s;\n\tstruct sk_buff_head hitlist;\n\tstruct sk_buff *skb;\n\n\t/*\n\t *\tAvoid a recursive GC.\n\t */\n\n\tif (!mutex_trylock(&unix_gc_sem))\n\t\treturn;\n\n\tspin_lock(&unix_table_lock);\n\n\tforall_unix_sockets(i, s)\n\t{\n\t\tunix_sk(s)->gc_tree = GC_ORPHAN;\n\t}\n\t/*\n\t *\tEverything is now marked\n\t */\n\n\t/* Invariant to be maintained:\n\t\t- everything unmarked is either:\n\t\t-- (a) on the stack, or\n\t\t-- (b) has all of its children unmarked\n\t\t- everything on the stack is always unmarked\n\t\t- nothing is ever pushed onto the stack twice, because:\n\t\t-- nothing previously unmarked is ever pushed on the stack\n\t */\n\n\t/*\n\t *\tPush root set\n\t */\n\n\tforall_unix_sockets(i, s)\n\t{\n\t\tint open_count = 0;\n\n\t\t/*\n\t\t *\tIf all instances of the descriptor are not\n\t\t *\tin flight we are in use.\n\t\t *\n\t\t *\tSpecial case: when socket s is embrion, it may be\n\t\t *\thashed but still not in queue of listening socket.\n\t\t *\tIn this case (see unix_create1()) we set artificial\n\t\t *\tnegative inflight counter to close race window.\n\t\t *\tIt is trick of course and dirty one.\n\t\t */\n\t\tif (s->sk_socket && s->sk_socket->file)\n\t\t\topen_count = file_count(s->sk_socket->file);\n\t\tif (open_count > atomic_read(&unix_sk(s)->inflight))\n\t\t\tmaybe_unmark_and_push(s);\n\t}\n\n\t/*\n\t *\tMark phase\n\t */\n\n\twhile (!empty_stack())\n\t{\n\t\tstruct sock *x = pop_stack();\n\t\tstruct sock *sk;\n\n\t\tspin_lock(&x->sk_receive_queue.lock);\n\t\tskb = skb_peek(&x->sk_receive_queue);\n\n\t\t/*\n\t\t *\tLoop through all but first born\n\t\t */\n\n\t\twhile (skb && skb != (struct sk_buff *)&x->sk_receive_queue) {\n\t\t\t/*\n\t\t\t *\tDo we have file descriptors ?\n\t\t\t */\n\t\t\tif(UNIXCB(skb).fp)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t *\tProcess the descriptors of this socket\n\t\t\t\t */\n\t\t\t\tint nfd=UNIXCB(skb).fp->count;\n\t\t\t\tstruct file **fp = UNIXCB(skb).fp->fp;\n\t\t\t\twhile(nfd--)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t *\tGet the socket the fd matches if\n\t\t\t\t\t *\tit indeed does so\n\t\t\t\t\t */\n\t\t\t\t\tif((sk=unix_get_socket(*fp++))!=NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tmaybe_unmark_and_push(sk);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* We have to scan not-yet-accepted ones too */\n\t\t\tif (x->sk_state == TCP_LISTEN)\n\t\t\t\tmaybe_unmark_and_push(skb->sk);\n\t\t\tskb=skb->next;\n\t\t}\n\t\tspin_unlock(&x->sk_receive_queue.lock);\n\t\tsock_put(x);\n\t}\n\n\tskb_queue_head_init(&hitlist);\n\n\tforall_unix_sockets(i, s)\n\t{\n\t\tstruct unix_sock *u = unix_sk(s);\n\n\t\tif (u->gc_tree == GC_ORPHAN) {\n\t\t\tstruct sk_buff *nextsk;\n\n\t\t\tspin_lock(&s->sk_receive_queue.lock);\n\t\t\tskb = skb_peek(&s->sk_receive_queue);\n\t\t\twhile (skb &&\n\t\t\t       skb != (struct sk_buff *)&s->sk_receive_queue) {\n\t\t\t\tnextsk = skb->next;\n\t\t\t\t/*\n\t\t\t\t *\tDo we have file descriptors ?\n\t\t\t\t */\n\t\t\t\tif (UNIXCB(skb).fp) {\n\t\t\t\t\t__skb_unlink(skb,\n\t\t\t\t\t\t     &s->sk_receive_queue);\n\t\t\t\t\t__skb_queue_tail(&hitlist, skb);\n\t\t\t\t}\n\t\t\t\tskb = nextsk;\n\t\t\t}\n\t\t\tspin_unlock(&s->sk_receive_queue.lock);\n\t\t}\n\t\tu->gc_tree = GC_ORPHAN;\n\t}\n\tspin_unlock(&unix_table_lock);\n\n\t/*\n\t *\tHere we are. Hitlist is filled. Die.\n\t */\n\n\t__skb_queue_purge(&hitlist);\n\tmutex_unlock(&unix_gc_sem);\n}",
        "target": 1
    },
    {
        "func": "void unix_inflight(struct file *fp)\n{\n\tstruct sock *s = unix_get_socket(fp);\n\tif(s) {\n\t\tatomic_inc(&unix_sk(s)->inflight);\n\t\tatomic_inc(&unix_tot_inflight);\n\t}\n}",
        "target": 1
    },
    {
        "func": "static inline struct sock *pop_stack(void)\n{\n\tstruct sock *p = gc_current;\n\tgc_current = unix_sk(p)->gc_tree;\n\treturn p;\n}",
        "target": 1
    },
    {
        "func": "static struct sock * unix_create1(struct socket *sock)\n{\n\tstruct sock *sk = NULL;\n\tstruct unix_sock *u;\n\n\tif (atomic_read(&unix_nr_socks) >= 2*get_max_files())\n\t\tgoto out;\n\n\tsk = sk_alloc(PF_UNIX, GFP_KERNEL, &unix_proto, 1);\n\tif (!sk)\n\t\tgoto out;\n\n\tatomic_inc(&unix_nr_socks);\n\n\tsock_init_data(sock,sk);\n\tlockdep_set_class(&sk->sk_receive_queue.lock,\n\t\t\t\t&af_unix_sk_receive_queue_lock_key);\n\n\tsk->sk_write_space\t= unix_write_space;\n\tsk->sk_max_ack_backlog\t= sysctl_unix_max_dgram_qlen;\n\tsk->sk_destruct\t\t= unix_sock_destructor;\n\tu\t  = unix_sk(sk);\n\tu->dentry = NULL;\n\tu->mnt\t  = NULL;\n\tspin_lock_init(&u->lock);\n\tatomic_set(&u->inflight, sock ? 0 : -1);\n\tmutex_init(&u->readlock); /* single task reading lock */\n\tinit_waitqueue_head(&u->peer_wait);\n\tunix_insert_socket(unix_sockets_unbound, sk);\nout:\n\treturn sk;\n}",
        "target": 1
    },
    {
        "func": "void unix_notinflight(struct file *fp)\n{\n\tstruct sock *s = unix_get_socket(fp);\n\tif(s) {\n\t\tatomic_dec(&unix_sk(s)->inflight);\n\t\tatomic_dec(&unix_tot_inflight);\n\t}\n}",
        "target": 1
    },
    {
        "func": "static int uvc_parse_format(struct uvc_device *dev,\n\tstruct uvc_streaming *streaming, struct uvc_format *format,\n\t__u32 **intervals, unsigned char *buffer, int buflen)\n{\n\tstruct usb_interface *intf = streaming->intf;\n\tstruct usb_host_interface *alts = intf->cur_altsetting;\n\tstruct uvc_format_desc *fmtdesc;\n\tstruct uvc_frame *frame;\n\tconst unsigned char *start = buffer;\n\tunsigned int interval;\n\tunsigned int i, n;\n\t__u8 ftype;\n\n\tformat->type = buffer[2];\n\tformat->index = buffer[3];\n\n\tswitch (buffer[2]) {\n\tcase VS_FORMAT_UNCOMPRESSED:\n\tcase VS_FORMAT_FRAME_BASED:\n\t\tif (buflen < 27) {\n\t\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d videostreaming\"\n\t\t\t       \"interface %d FORMAT error\\n\",\n\t\t\t       dev->udev->devnum,\n\t\t\t       alts->desc.bInterfaceNumber);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* Find the format descriptor from its GUID. */\n\t\tfmtdesc = uvc_format_by_guid(&buffer[5]);\n\n\t\tif (fmtdesc != NULL) {\n\t\t\tstrncpy(format->name, fmtdesc->name,\n\t\t\t\tsizeof format->name);\n\t\t\tformat->fcc = fmtdesc->fcc;\n\t\t} else {\n\t\t\tuvc_printk(KERN_INFO, \"Unknown video format \"\n\t\t\t\tUVC_GUID_FORMAT \"\\n\",\n\t\t\t\tUVC_GUID_ARGS(&buffer[5]));\n\t\t\tsnprintf(format->name, sizeof format->name,\n\t\t\t\tUVC_GUID_FORMAT, UVC_GUID_ARGS(&buffer[5]));\n\t\t\tformat->fcc = 0;\n\t\t}\n\n\t\tformat->bpp = buffer[21];\n\t\tif (buffer[2] == VS_FORMAT_UNCOMPRESSED) {\n\t\t\tftype = VS_FRAME_UNCOMPRESSED;\n\t\t} else {\n\t\t\tftype = VS_FRAME_FRAME_BASED;\n\t\t\tif (buffer[27])\n\t\t\t\tformat->flags = UVC_FMT_FLAG_COMPRESSED;\n\t\t}\n\t\tbreak;\n\n\tcase VS_FORMAT_MJPEG:\n\t\tif (buflen < 11) {\n\t\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d videostreaming\"\n\t\t\t       \"interface %d FORMAT error\\n\",\n\t\t\t       dev->udev->devnum,\n\t\t\t       alts->desc.bInterfaceNumber);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tstrncpy(format->name, \"MJPEG\", sizeof format->name);\n\t\tformat->fcc = V4L2_PIX_FMT_MJPEG;\n\t\tformat->flags = UVC_FMT_FLAG_COMPRESSED;\n\t\tformat->bpp = 0;\n\t\tftype = VS_FRAME_MJPEG;\n\t\tbreak;\n\n\tcase VS_FORMAT_DV:\n\t\tif (buflen < 9) {\n\t\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d videostreaming\"\n\t\t\t       \"interface %d FORMAT error\\n\",\n\t\t\t       dev->udev->devnum,\n\t\t\t       alts->desc.bInterfaceNumber);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tswitch (buffer[8] & 0x7f) {\n\t\tcase 0:\n\t\t\tstrncpy(format->name, \"SD-DV\", sizeof format->name);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tstrncpy(format->name, \"SDL-DV\", sizeof format->name);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tstrncpy(format->name, \"HD-DV\", sizeof format->name);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d videostreaming\"\n\t\t\t       \"interface %d: unknown DV format %u\\n\",\n\t\t\t       dev->udev->devnum,\n\t\t\t       alts->desc.bInterfaceNumber, buffer[8]);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tstrncat(format->name, buffer[8] & (1 << 7) ? \" 60Hz\" : \" 50Hz\",\n\t\t\tsizeof format->name);\n\n\t\tformat->fcc = V4L2_PIX_FMT_DV;\n\t\tformat->flags = UVC_FMT_FLAG_COMPRESSED | UVC_FMT_FLAG_STREAM;\n\t\tformat->bpp = 0;\n\t\tftype = 0;\n\n\t\t/* Create a dummy frame descriptor. */\n\t\tframe = &format->frame[0];\n\t\tmemset(&format->frame[0], 0, sizeof format->frame[0]);\n\t\tframe->bFrameIntervalType = 1;\n\t\tframe->dwDefaultFrameInterval = 1;\n\t\tframe->dwFrameInterval = *intervals;\n\t\t*(*intervals)++ = 1;\n\t\tformat->nframes = 1;\n\t\tbreak;\n\n\tcase VS_FORMAT_MPEG2TS:\n\tcase VS_FORMAT_STREAM_BASED:\n\t\t/* Not supported yet. */\n\tdefault:\n\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d videostreaming\"\n\t\t       \"interface %d unsupported format %u\\n\",\n\t\t       dev->udev->devnum, alts->desc.bInterfaceNumber,\n\t\t       buffer[2]);\n\t\treturn -EINVAL;\n\t}\n\n\tuvc_trace(UVC_TRACE_DESCR, \"Found format %s.\\n\", format->name);\n\n\tbuflen -= buffer[0];\n\tbuffer += buffer[0];\n\n\t/* Parse the frame descriptors. Only uncompressed, MJPEG and frame\n\t * based formats have frame descriptors.\n\t */\n\twhile (buflen > 2 && buffer[2] == ftype) {\n\t\tframe = &format->frame[format->nframes];\n\n\t\tif (ftype != VS_FRAME_FRAME_BASED)\n\t\t\tn = buflen > 25 ? buffer[25] : 0;\n\t\telse\n\t\t\tn = buflen > 21 ? buffer[21] : 0;\n\n\t\tn = n ? n : 3;\n\n\t\tif (buflen < 26 + 4*n) {\n\t\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d videostreaming\"\n\t\t\t       \"interface %d FRAME error\\n\", dev->udev->devnum,\n\t\t\t       alts->desc.bInterfaceNumber);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tframe->bFrameIndex = buffer[3];\n\t\tframe->bmCapabilities = buffer[4];\n\t\tframe->wWidth = le16_to_cpup((__le16 *)&buffer[5]);\n\t\tframe->wHeight = le16_to_cpup((__le16 *)&buffer[7]);\n\t\tframe->dwMinBitRate = le32_to_cpup((__le32 *)&buffer[9]);\n\t\tframe->dwMaxBitRate = le32_to_cpup((__le32 *)&buffer[13]);\n\t\tif (ftype != VS_FRAME_FRAME_BASED) {\n\t\t\tframe->dwMaxVideoFrameBufferSize =\n\t\t\t\tle32_to_cpup((__le32 *)&buffer[17]);\n\t\t\tframe->dwDefaultFrameInterval =\n\t\t\t\tle32_to_cpup((__le32 *)&buffer[21]);\n\t\t\tframe->bFrameIntervalType = buffer[25];\n\t\t} else {\n\t\t\tframe->dwMaxVideoFrameBufferSize = 0;\n\t\t\tframe->dwDefaultFrameInterval =\n\t\t\t\tle32_to_cpup((__le32 *)&buffer[17]);\n\t\t\tframe->bFrameIntervalType = buffer[21];\n\t\t}\n\t\tframe->dwFrameInterval = *intervals;\n\n\t\t/* Several UVC chipsets screw up dwMaxVideoFrameBufferSize\n\t\t * completely. Observed behaviours range from setting the\n\t\t * value to 1.1x the actual frame size of hardwiring the\n\t\t * 16 low bits to 0. This results in a higher than necessary\n\t\t * memory usage as well as a wrong image size information. For\n\t\t * uncompressed formats this can be fixed by computing the\n\t\t * value from the frame size.\n\t\t */\n\t\tif (!(format->flags & UVC_FMT_FLAG_COMPRESSED))\n\t\t\tframe->dwMaxVideoFrameBufferSize = format->bpp\n\t\t\t\t* frame->wWidth * frame->wHeight / 8;\n\n\t\t/* Some bogus devices report dwMinFrameInterval equal to\n\t\t * dwMaxFrameInterval and have dwFrameIntervalStep set to\n\t\t * zero. Setting all null intervals to 1 fixes the problem and\n\t\t * some other divisions by zero which could happen.\n\t\t */\n\t\tfor (i = 0; i < n; ++i) {\n\t\t\tinterval = le32_to_cpup((__le32 *)&buffer[26+4*i]);\n\t\t\t*(*intervals)++ = interval ? interval : 1;\n\t\t}\n\n\t\t/* Make sure that the default frame interval stays between\n\t\t * the boundaries.\n\t\t */\n\t\tn -= frame->bFrameIntervalType ? 1 : 2;\n\t\tframe->dwDefaultFrameInterval =\n\t\t\tmin(frame->dwFrameInterval[n],\n\t\t\t    max(frame->dwFrameInterval[0],\n\t\t\t\tframe->dwDefaultFrameInterval));\n\n\t\tuvc_trace(UVC_TRACE_DESCR, \"- %ux%u (%u.%u fps)\\n\",\n\t\t\tframe->wWidth, frame->wHeight,\n\t\t\t10000000/frame->dwDefaultFrameInterval,\n\t\t\t(100000000/frame->dwDefaultFrameInterval)%10);\n\n\t\tformat->nframes++;\n\t\tbuflen -= buffer[0];\n\t\tbuffer += buffer[0];\n\t}\n\n\tif (buflen > 2 && buffer[2] == VS_STILL_IMAGE_FRAME) {\n\t\tbuflen -= buffer[0];\n\t\tbuffer += buffer[0];\n\t}\n\n\tif (buflen > 2 && buffer[2] == VS_COLORFORMAT) {\n\t\tif (buflen < 6) {\n\t\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d videostreaming\"\n\t\t\t       \"interface %d COLORFORMAT error\\n\",\n\t\t\t       dev->udev->devnum,\n\t\t\t       alts->desc.bInterfaceNumber);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tformat->colorspace = uvc_colorspace(buffer[3]);\n\n\t\tbuflen -= buffer[0];\n\t\tbuffer += buffer[0];\n\t}\n\n\treturn buffer - start;\n}",
        "target": 1
    },
    {
        "func": "static int get_file_caps(struct linux_binprm *bprm)\n{\n\tstruct dentry *dentry;\n\tint rc = 0;\n\tstruct vfs_cap_data vcaps;\n\tstruct inode *inode;\n\n\tif (bprm->file->f_vfsmnt->mnt_flags & MNT_NOSUID) {\n\t\tbprm_clear_caps(bprm);\n\t\treturn 0;\n\t}\n\n\tdentry = dget(bprm->file->f_dentry);\n\tinode = dentry->d_inode;\n\tif (!inode->i_op || !inode->i_op->getxattr)\n\t\tgoto out;\n\n\trc = inode->i_op->getxattr(dentry, XATTR_NAME_CAPS, &vcaps,\n\t\t\t\t   XATTR_CAPS_SZ);\n\tif (rc == -ENODATA || rc == -EOPNOTSUPP) {\n\t\t/* no data, that's ok */\n\t\trc = 0;\n\t\tgoto out;\n\t}\n\tif (rc < 0)\n\t\tgoto out;\n\n\trc = cap_from_disk(&vcaps, bprm, rc);\n\tif (rc == -EINVAL)\n\t\tprintk(KERN_NOTICE \"%s: cap_from_disk returned %d for %s\\n\",\n\t\t       __func__, rc, bprm->filename);\n\nout:\n\tdput(dentry);\n\tif (rc)\n\t\tbprm_clear_caps(bprm);\n\n\treturn rc;\n}",
        "target": 1
    },
    {
        "func": "static inline int get_file_caps(struct linux_binprm *bprm)\n{\n\tbprm_clear_caps(bprm);\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static int lbs_process_bss(struct bss_descriptor *bss,\n\t\t\t   uint8_t **pbeaconinfo, int *bytesleft)\n{\n\tstruct ieeetypes_fhparamset *pFH;\n\tstruct ieeetypes_dsparamset *pDS;\n\tstruct ieeetypes_cfparamset *pCF;\n\tstruct ieeetypes_ibssparamset *pibss;\n\tDECLARE_MAC_BUF(mac);\n\tstruct ieeetypes_countryinfoset *pcountryinfo;\n\tuint8_t *pos, *end, *p;\n\tuint8_t n_ex_rates = 0, got_basic_rates = 0, n_basic_rates = 0;\n\tuint16_t beaconsize = 0;\n\tint ret;\n\n\tlbs_deb_enter(LBS_DEB_SCAN);\n\n\tif (*bytesleft >= sizeof(beaconsize)) {\n\t\t/* Extract & convert beacon size from the command buffer */\n\t\tbeaconsize = get_unaligned_le16(*pbeaconinfo);\n\t\t*bytesleft -= sizeof(beaconsize);\n\t\t*pbeaconinfo += sizeof(beaconsize);\n\t}\n\n\tif (beaconsize == 0 || beaconsize > *bytesleft) {\n\t\t*pbeaconinfo += *bytesleft;\n\t\t*bytesleft = 0;\n\t\tret = -1;\n\t\tgoto done;\n\t}\n\n\t/* Initialize the current working beacon pointer for this BSS iteration */\n\tpos = *pbeaconinfo;\n\tend = pos + beaconsize;\n\n\t/* Advance the return beacon pointer past the current beacon */\n\t*pbeaconinfo += beaconsize;\n\t*bytesleft -= beaconsize;\n\n\tmemcpy(bss->bssid, pos, ETH_ALEN);\n\tlbs_deb_scan(\"process_bss: BSSID %s\\n\", print_mac(mac, bss->bssid));\n\tpos += ETH_ALEN;\n\n\tif ((end - pos) < 12) {\n\t\tlbs_deb_scan(\"process_bss: Not enough bytes left\\n\");\n\t\tret = -1;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * next 4 fields are RSSI, time stamp, beacon interval,\n\t *   and capability information\n\t */\n\n\t/* RSSI is 1 byte long */\n\tbss->rssi = *pos;\n\tlbs_deb_scan(\"process_bss: RSSI %d\\n\", *pos);\n\tpos++;\n\n\t/* time stamp is 8 bytes long */\n\tpos += 8;\n\n\t/* beacon interval is 2 bytes long */\n\tbss->beaconperiod = get_unaligned_le16(pos);\n\tpos += 2;\n\n\t/* capability information is 2 bytes long */\n\tbss->capability = get_unaligned_le16(pos);\n\tlbs_deb_scan(\"process_bss: capabilities 0x%04x\\n\", bss->capability);\n\tpos += 2;\n\n\tif (bss->capability & WLAN_CAPABILITY_PRIVACY)\n\t\tlbs_deb_scan(\"process_bss: WEP enabled\\n\");\n\tif (bss->capability & WLAN_CAPABILITY_IBSS)\n\t\tbss->mode = IW_MODE_ADHOC;\n\telse\n\t\tbss->mode = IW_MODE_INFRA;\n\n\t/* rest of the current buffer are IE's */\n\tlbs_deb_scan(\"process_bss: IE len %zd\\n\", end - pos);\n\tlbs_deb_hex(LBS_DEB_SCAN, \"process_bss: IE info\", pos, end - pos);\n\n\t/* process variable IE */\n\twhile (pos <= end - 2) {\n\t\tstruct ieee80211_info_element * elem = (void *)pos;\n\n\t\tif (pos + elem->len > end) {\n\t\t\tlbs_deb_scan(\"process_bss: error in processing IE, \"\n\t\t\t\t     \"bytes left < IE length\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (elem->id) {\n\t\tcase MFIE_TYPE_SSID:\n\t\t\tbss->ssid_len = elem->len;\n\t\t\tmemcpy(bss->ssid, elem->data, elem->len);\n\t\t\tlbs_deb_scan(\"got SSID IE: '%s', len %u\\n\",\n\t\t\t             escape_essid(bss->ssid, bss->ssid_len),\n\t\t\t             bss->ssid_len);\n\t\t\tbreak;\n\n\t\tcase MFIE_TYPE_RATES:\n\t\t\tn_basic_rates = min_t(uint8_t, MAX_RATES, elem->len);\n\t\t\tmemcpy(bss->rates, elem->data, n_basic_rates);\n\t\t\tgot_basic_rates = 1;\n\t\t\tlbs_deb_scan(\"got RATES IE\\n\");\n\t\t\tbreak;\n\n\t\tcase MFIE_TYPE_FH_SET:\n\t\t\tpFH = (struct ieeetypes_fhparamset *) pos;\n\t\t\tmemmove(&bss->phyparamset.fhparamset, pFH,\n\t\t\t\tsizeof(struct ieeetypes_fhparamset));\n\t\t\tlbs_deb_scan(\"got FH IE\\n\");\n\t\t\tbreak;\n\n\t\tcase MFIE_TYPE_DS_SET:\n\t\t\tpDS = (struct ieeetypes_dsparamset *) pos;\n\t\t\tbss->channel = pDS->currentchan;\n\t\t\tmemcpy(&bss->phyparamset.dsparamset, pDS,\n\t\t\t       sizeof(struct ieeetypes_dsparamset));\n\t\t\tlbs_deb_scan(\"got DS IE, channel %d\\n\", bss->channel);\n\t\t\tbreak;\n\n\t\tcase MFIE_TYPE_CF_SET:\n\t\t\tpCF = (struct ieeetypes_cfparamset *) pos;\n\t\t\tmemcpy(&bss->ssparamset.cfparamset, pCF,\n\t\t\t       sizeof(struct ieeetypes_cfparamset));\n\t\t\tlbs_deb_scan(\"got CF IE\\n\");\n\t\t\tbreak;\n\n\t\tcase MFIE_TYPE_IBSS_SET:\n\t\t\tpibss = (struct ieeetypes_ibssparamset *) pos;\n\t\t\tbss->atimwindow = le16_to_cpu(pibss->atimwindow);\n\t\t\tmemmove(&bss->ssparamset.ibssparamset, pibss,\n\t\t\t\tsizeof(struct ieeetypes_ibssparamset));\n\t\t\tlbs_deb_scan(\"got IBSS IE\\n\");\n\t\t\tbreak;\n\n\t\tcase MFIE_TYPE_COUNTRY:\n\t\t\tpcountryinfo = (struct ieeetypes_countryinfoset *) pos;\n\t\t\tlbs_deb_scan(\"got COUNTRY IE\\n\");\n\t\t\tif (pcountryinfo->len < sizeof(pcountryinfo->countrycode)\n\t\t\t    || pcountryinfo->len > 254) {\n\t\t\t\tlbs_deb_scan(\"process_bss: 11D- Err CountryInfo len %d, min %zd, max 254\\n\",\n\t\t\t\t\t     pcountryinfo->len, sizeof(pcountryinfo->countrycode));\n\t\t\t\tret = -1;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tmemcpy(&bss->countryinfo, pcountryinfo, pcountryinfo->len + 2);\n\t\t\tlbs_deb_hex(LBS_DEB_SCAN, \"process_bss: 11d countryinfo\",\n\t\t\t\t    (uint8_t *) pcountryinfo,\n\t\t\t\t    (int) (pcountryinfo->len + 2));\n\t\t\tbreak;\n\n\t\tcase MFIE_TYPE_RATES_EX:\n\t\t\t/* only process extended supported rate if data rate is\n\t\t\t * already found. Data rate IE should come before\n\t\t\t * extended supported rate IE\n\t\t\t */\n\t\t\tlbs_deb_scan(\"got RATESEX IE\\n\");\n\t\t\tif (!got_basic_rates) {\n\t\t\t\tlbs_deb_scan(\"... but ignoring it\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tn_ex_rates = elem->len;\n\t\t\tif (n_basic_rates + n_ex_rates > MAX_RATES)\n\t\t\t\tn_ex_rates = MAX_RATES - n_basic_rates;\n\n\t\t\tp = bss->rates + n_basic_rates;\n\t\t\tmemcpy(p, elem->data, n_ex_rates);\n\t\t\tbreak;\n\n\t\tcase MFIE_TYPE_GENERIC:\n\t\t\tif (elem->len >= 4 &&\n\t\t\t    elem->data[0] == 0x00 && elem->data[1] == 0x50 &&\n\t\t\t    elem->data[2] == 0xf2 && elem->data[3] == 0x01) {\n\t\t\t\tbss->wpa_ie_len = min(elem->len + 2, MAX_WPA_IE_LEN);\n\t\t\t\tmemcpy(bss->wpa_ie, elem, bss->wpa_ie_len);\n\t\t\t\tlbs_deb_scan(\"got WPA IE\\n\");\n\t\t\t\tlbs_deb_hex(LBS_DEB_SCAN, \"WPA IE\", bss->wpa_ie, elem->len);\n\t\t\t} else if (elem->len >= MARVELL_MESH_IE_LENGTH &&\n\t\t\t\t   elem->data[0] == 0x00 && elem->data[1] == 0x50 &&\n\t\t\t\t   elem->data[2] == 0x43 && elem->data[3] == 0x04) {\n\t\t\t\tlbs_deb_scan(\"got mesh IE\\n\");\n\t\t\t\tbss->mesh = 1;\n\t\t\t} else {\n\t\t\t\tlbs_deb_scan(\"got generic IE: %02x:%02x:%02x:%02x, len %d\\n\",\n\t\t\t\t\telem->data[0], elem->data[1],\n\t\t\t\t\telem->data[2], elem->data[3],\n\t\t\t\t\telem->len);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase MFIE_TYPE_RSN:\n\t\t\tlbs_deb_scan(\"got RSN IE\\n\");\n\t\t\tbss->rsn_ie_len = min(elem->len + 2, MAX_WPA_IE_LEN);\n\t\t\tmemcpy(bss->rsn_ie, elem, bss->rsn_ie_len);\n\t\t\tlbs_deb_hex(LBS_DEB_SCAN, \"process_bss: RSN_IE\",\n\t\t\t\t    bss->rsn_ie, elem->len);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tlbs_deb_scan(\"got IE 0x%04x, len %d\\n\",\n\t\t\t\t     elem->id, elem->len);\n\t\t\tbreak;\n\t\t}\n\n\t\tpos += elem->len + 2;\n\t}\n\n\t/* Timestamp */\n\tbss->last_scanned = jiffies;\n\tlbs_unset_basic_rate_flags(bss->rates, sizeof(bss->rates));\n\n\tret = 0;\n\ndone:\n\tlbs_deb_leave_args(LBS_DEB_SCAN, \"ret %d\", ret);\n\treturn ret;\n}",
        "target": 1
    },
    {
        "func": "static int tvaudio_get_ctrl(struct CHIPSTATE *chip,\n\t\t\t    struct v4l2_control *ctrl)\n{\n\tstruct CHIPDESC *desc = chip->desc;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_AUDIO_MUTE:\n\t\tctrl->value=chip->muted;\n\t\treturn 0;\n\tcase V4L2_CID_AUDIO_VOLUME:\n\t\tif (!(desc->flags & CHIP_HAS_VOLUME))\n\t\t\tbreak;\n\t\tctrl->value = max(chip->left,chip->right);\n\t\treturn 0;\n\tcase V4L2_CID_AUDIO_BALANCE:\n\t{\n\t\tint volume;\n\t\tif (!(desc->flags & CHIP_HAS_VOLUME))\n\t\t\tbreak;\n\t\tvolume = max(chip->left,chip->right);\n\t\tif (volume)\n\t\t\tctrl->value=(32768*min(chip->left,chip->right))/volume;\n\t\telse\n\t\t\tctrl->value=32768;\n\t\treturn 0;\n\t}\n\tcase V4L2_CID_AUDIO_BASS:\n\t\tif (desc->flags & CHIP_HAS_BASSTREBLE)\n\t\t\tbreak;\n\t\tctrl->value = chip->bass;\n\t\treturn 0;\n\tcase V4L2_CID_AUDIO_TREBLE:\n\t\tif (desc->flags & CHIP_HAS_BASSTREBLE)\n\t\t\treturn -EINVAL;\n\t\tctrl->value = chip->treble;\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}",
        "target": 1
    },
    {
        "func": "static int chip_command(struct i2c_client *client,\n\t\t\tunsigned int cmd, void *arg)\n{\n\tstruct CHIPSTATE *chip = i2c_get_clientdata(client);\n\tstruct CHIPDESC  *desc = chip->desc;\n\n\tif (debug > 0) {\n\t\tv4l_i2c_print_ioctl(chip->c, cmd);\n\t\tprintk(\"\\n\");\n\t}\n\n\tswitch (cmd) {\n\tcase AUDC_SET_RADIO:\n\t\tchip->radio = 1;\n\t\tchip->watch_stereo = 0;\n\t\t/* del_timer(&chip->wt); */\n\t\tbreak;\n\t/* --- v4l ioctls --- */\n\t/* take care: bttv does userspace copying, we'll get a\n\tkernel pointer here... */\n\tcase VIDIOC_QUERYCTRL:\n\t{\n\t\tstruct v4l2_queryctrl *qc = arg;\n\n\t\tswitch (qc->id) {\n\t\t\tcase V4L2_CID_AUDIO_MUTE:\n\t\t\t\tbreak;\n\t\t\tcase V4L2_CID_AUDIO_VOLUME:\n\t\t\tcase V4L2_CID_AUDIO_BALANCE:\n\t\t\t\tif (!(desc->flags & CHIP_HAS_VOLUME))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n\t\t\tcase V4L2_CID_AUDIO_BASS:\n\t\t\tcase V4L2_CID_AUDIO_TREBLE:\n\t\t\t\tif (desc->flags & CHIP_HAS_BASSTREBLE)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn v4l2_ctrl_query_fill_std(qc);\n\t}\n\tcase VIDIOC_S_CTRL:\n\t\treturn tvaudio_set_ctrl(chip, arg);\n\n\tcase VIDIOC_G_CTRL:\n\t\treturn tvaudio_get_ctrl(chip, arg);\n\tcase VIDIOC_INT_G_AUDIO_ROUTING:\n\t{\n\t\tstruct v4l2_routing *rt = arg;\n\n\t\trt->input = chip->input;\n\t\trt->output = 0;\n\t\tbreak;\n\t}\n\tcase VIDIOC_INT_S_AUDIO_ROUTING:\n\t{\n\t\tstruct v4l2_routing *rt = arg;\n\n\t\tif (!(desc->flags & CHIP_HAS_INPUTSEL) || rt->input >= 4)\n\t\t\t\treturn -EINVAL;\n\t\t/* There are four inputs: tuner, radio, extern and intern. */\n\t\tchip->input = rt->input;\n\t\tif (chip->muted)\n\t\t\tbreak;\n\t\tchip_write_masked(chip, desc->inputreg,\n\t\t\t\tdesc->inputmap[chip->input], desc->inputmask);\n\t\tbreak;\n\t}\n\tcase VIDIOC_S_TUNER:\n\t{\n\t\tstruct v4l2_tuner *vt = arg;\n\t\tint mode = 0;\n\n\t\tif (chip->radio)\n\t\t\tbreak;\n\t\tswitch (vt->audmode) {\n\t\tcase V4L2_TUNER_MODE_MONO:\n\t\tcase V4L2_TUNER_MODE_STEREO:\n\t\tcase V4L2_TUNER_MODE_LANG1:\n\t\tcase V4L2_TUNER_MODE_LANG2:\n\t\t\tmode = vt->audmode;\n\t\t\tbreak;\n\t\tcase V4L2_TUNER_MODE_LANG1_LANG2:\n\t\t\tmode = V4L2_TUNER_MODE_STEREO;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tchip->audmode = vt->audmode;\n\n\t\tif (desc->setmode && mode) {\n\t\t\tchip->watch_stereo = 0;\n\t\t\t/* del_timer(&chip->wt); */\n\t\t\tchip->mode = mode;\n\t\t\tdesc->setmode(chip, mode);\n\t\t}\n\t\tbreak;\n\t}\n\tcase VIDIOC_G_TUNER:\n\t{\n\t\tstruct v4l2_tuner *vt = arg;\n\t\tint mode = V4L2_TUNER_MODE_MONO;\n\n\t\tif (chip->radio)\n\t\t\tbreak;\n\t\tvt->audmode = chip->audmode;\n\t\tvt->rxsubchans = 0;\n\t\tvt->capability = V4L2_TUNER_CAP_STEREO |\n\t\t\tV4L2_TUNER_CAP_LANG1 | V4L2_TUNER_CAP_LANG2;\n\n\t\tif (desc->getmode)\n\t\t\tmode = desc->getmode(chip);\n\n\t\tif (mode & V4L2_TUNER_MODE_MONO)\n\t\t\tvt->rxsubchans |= V4L2_TUNER_SUB_MONO;\n\t\tif (mode & V4L2_TUNER_MODE_STEREO)\n\t\t\tvt->rxsubchans |= V4L2_TUNER_SUB_STEREO;\n\t\t/* Note: for SAP it should be mono/lang2 or stereo/lang2.\n\t\t   When this module is converted fully to v4l2, then this\n\t\t   should change for those chips that can detect SAP. */\n\t\tif (mode & V4L2_TUNER_MODE_LANG1)\n\t\t\tvt->rxsubchans = V4L2_TUNER_SUB_LANG1 |\n\t\t\t\t\t V4L2_TUNER_SUB_LANG2;\n\t\tbreak;\n\t}\n\tcase VIDIOC_S_STD:\n\t\tchip->radio = 0;\n\t\tbreak;\n\tcase VIDIOC_S_FREQUENCY:\n\t\tchip->mode = 0; /* automatic */\n\n\t\t/* For chips that provide getmode and setmode, and doesn't\n\t\t   automatically follows the stereo carrier, a kthread is\n\t\t   created to set the audio standard. In this case, when then\n\t\t   the video channel is changed, tvaudio starts on MONO mode.\n\t\t   After waiting for 2 seconds, the kernel thread is called,\n\t\t   to follow whatever audio standard is pointed by the\n\t\t   audio carrier.\n\t\t */\n\t\tif (chip->thread) {\n\t\t\tdesc->setmode(chip,V4L2_TUNER_MODE_MONO);\n\t\t\tif (chip->prevmode != V4L2_TUNER_MODE_MONO)\n\t\t\t\tchip->prevmode = -1; /* reset previous mode */\n\t\t\tmod_timer(&chip->wt, jiffies+msecs_to_jiffies(2000));\n\t\t}\n\t\tbreak;\n\n\tcase VIDIOC_G_CHIP_IDENT:\n\t\treturn v4l2_chip_ident_i2c_client(client, arg, V4L2_IDENT_TVAUDIO, 0);\n\t}\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static int tvaudio_set_ctrl(struct CHIPSTATE *chip,\n\t\t\t    struct v4l2_control *ctrl)\n{\n\tstruct CHIPDESC *desc = chip->desc;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_AUDIO_MUTE:\n\t\tif (ctrl->value < 0 || ctrl->value >= 2)\n\t\t\treturn -ERANGE;\n\t\tchip->muted = ctrl->value;\n\t\tif (chip->muted)\n\t\t\tchip_write_masked(chip,desc->inputreg,desc->inputmute,desc->inputmask);\n\t\telse\n\t\t\tchip_write_masked(chip,desc->inputreg,\n\t\t\t\t\tdesc->inputmap[chip->input],desc->inputmask);\n\t\treturn 0;\n\tcase V4L2_CID_AUDIO_VOLUME:\n\t{\n\t\tint volume,balance;\n\n\t\tif (!(desc->flags & CHIP_HAS_VOLUME))\n\t\t\tbreak;\n\n\t\tvolume = max(chip->left,chip->right);\n\t\tif (volume)\n\t\t\tbalance=(32768*min(chip->left,chip->right))/volume;\n\t\telse\n\t\t\tbalance=32768;\n\n\t\tvolume=ctrl->value;\n\t\tchip->left = (min(65536 - balance,32768) * volume) / 32768;\n\t\tchip->right = (min(balance,volume *(__u16)32768)) / 32768;\n\n\t\tchip_write(chip,desc->leftreg,desc->volfunc(chip->left));\n\t\tchip_write(chip,desc->rightreg,desc->volfunc(chip->right));\n\n\t\treturn 0;\n\t}\n\tcase V4L2_CID_AUDIO_BALANCE:\n\t{\n\t\tint volume, balance;\n\t\tif (!(desc->flags & CHIP_HAS_VOLUME))\n\t\t\tbreak;\n\n\t\tvolume = max(chip->left,chip->right);\n\t\tbalance = ctrl->value;\n\n\t\tchip_write(chip,desc->leftreg,desc->volfunc(chip->left));\n\t\tchip_write(chip,desc->rightreg,desc->volfunc(chip->right));\n\n\t\treturn 0;\n\t}\n\tcase V4L2_CID_AUDIO_BASS:\n\t\tif (desc->flags & CHIP_HAS_BASSTREBLE)\n\t\t\tbreak;\n\t\tchip->bass = ctrl->value;\n\t\tchip_write(chip,desc->bassreg,desc->bassfunc(chip->bass));\n\n\t\treturn 0;\n\tcase V4L2_CID_AUDIO_TREBLE:\n\t\tif (desc->flags & CHIP_HAS_BASSTREBLE)\n\t\t\treturn -EINVAL;\n\n\t\tchip->treble = ctrl->value;\n\t\tchip_write(chip,desc->treblereg,desc->treblefunc(chip->treble));\n\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}",
        "target": 1
    },
    {
        "func": "static int chip_write_masked(struct CHIPSTATE *chip, int subaddr, int val, int mask)\n{\n\tif (mask != 0) {\n\t\tif (-1 == subaddr) {\n\t\t\tval = (chip->shadow.bytes[1] & ~mask) | (val & mask);\n\t\t} else {\n\t\t\tval = (chip->shadow.bytes[subaddr+1] & ~mask) | (val & mask);\n\t\t}\n\t}\n\treturn chip_write(chip, subaddr, val);\n}",
        "target": 1
    },
    {
        "func": "static int chip_write(struct CHIPSTATE *chip, int subaddr, int val)\n{\n\tunsigned char buffer[2];\n\n\tif (-1 == subaddr) {\n\t\tv4l_dbg(1, debug, chip->c, \"%s: chip_write: 0x%x\\n\",\n\t\t\tchip->c->name, val);\n\t\tchip->shadow.bytes[1] = val;\n\t\tbuffer[0] = val;\n\t\tif (1 != i2c_master_send(chip->c,buffer,1)) {\n\t\t\tv4l_warn(chip->c, \"%s: I/O error (write 0x%x)\\n\",\n\t\t\t\tchip->c->name, val);\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tv4l_dbg(1, debug, chip->c, \"%s: chip_write: reg%d=0x%x\\n\",\n\t\t\tchip->c->name, subaddr, val);\n\t\tchip->shadow.bytes[subaddr+1] = val;\n\t\tbuffer[0] = subaddr;\n\t\tbuffer[1] = val;\n\t\tif (2 != i2c_master_send(chip->c,buffer,2)) {\n\t\t\tv4l_warn(chip->c, \"%s: I/O error (write reg%d=0x%x)\\n\",\n\t\t\tchip->c->name, subaddr, val);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static int chip_cmd(struct CHIPSTATE *chip, char *name, audiocmd *cmd)\n{\n\tint i;\n\n\tif (0 == cmd->count)\n\t\treturn 0;\n\n\t/* update our shadow register set; print bytes if (debug > 0) */\n\tv4l_dbg(1, debug, chip->c, \"%s: chip_cmd(%s): reg=%d, data:\",\n\t\tchip->c->name, name,cmd->bytes[0]);\n\tfor (i = 1; i < cmd->count; i++) {\n\t\tif (debug)\n\t\t\tprintk(\" 0x%x\",cmd->bytes[i]);\n\t\tchip->shadow.bytes[i+cmd->bytes[0]] = cmd->bytes[i];\n\t}\n\tif (debug)\n\t\tprintk(\"\\n\");\n\n\t/* send data to the chip */\n\tif (cmd->count != i2c_master_send(chip->c,cmd->bytes,cmd->count)) {\n\t\tv4l_warn(chip->c, \"%s: I/O error (%s)\\n\", chip->c->name, name);\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static void audit_inotify_unregister(struct list_head *in_list)\n{\n\tstruct audit_parent *p, *n;\n\n\tlist_for_each_entry_safe(p, n, in_list, ilist) {\n\t\tlist_del(&p->ilist);\n\t\tinotify_rm_watch(audit_ih, &p->wdata);\n\t\t/* the put matching the get in audit_do_del_rule() */\n\t\tput_inotify_watch(&p->wdata);\n\t}\n}",
        "target": 1
    },
    {
        "func": "static void untag_chunk(struct audit_chunk *chunk, struct node *p)\n{\n\tstruct audit_chunk *new;\n\tstruct audit_tree *owner;\n\tint size = chunk->count - 1;\n\tint i, j;\n\n\tmutex_lock(&chunk->watch.inode->inotify_mutex);\n\tif (chunk->dead) {\n\t\tmutex_unlock(&chunk->watch.inode->inotify_mutex);\n\t\treturn;\n\t}\n\n\towner = p->owner;\n\n\tif (!size) {\n\t\tchunk->dead = 1;\n\t\tspin_lock(&hash_lock);\n\t\tlist_del_init(&chunk->trees);\n\t\tif (owner->root == chunk)\n\t\t\towner->root = NULL;\n\t\tlist_del_init(&p->list);\n\t\tlist_del_rcu(&chunk->hash);\n\t\tspin_unlock(&hash_lock);\n\t\tinotify_evict_watch(&chunk->watch);\n\t\tmutex_unlock(&chunk->watch.inode->inotify_mutex);\n\t\tput_inotify_watch(&chunk->watch);\n\t\treturn;\n\t}\n\n\tnew = alloc_chunk(size);\n\tif (!new)\n\t\tgoto Fallback;\n\tif (inotify_clone_watch(&chunk->watch, &new->watch) < 0) {\n\t\tfree_chunk(new);\n\t\tgoto Fallback;\n\t}\n\n\tchunk->dead = 1;\n\tspin_lock(&hash_lock);\n\tlist_replace_init(&chunk->trees, &new->trees);\n\tif (owner->root == chunk) {\n\t\tlist_del_init(&owner->same_root);\n\t\towner->root = NULL;\n\t}\n\n\tfor (i = j = 0; i < size; i++, j++) {\n\t\tstruct audit_tree *s;\n\t\tif (&chunk->owners[j] == p) {\n\t\t\tlist_del_init(&p->list);\n\t\t\ti--;\n\t\t\tcontinue;\n\t\t}\n\t\ts = chunk->owners[j].owner;\n\t\tnew->owners[i].owner = s;\n\t\tnew->owners[i].index = chunk->owners[j].index - j + i;\n\t\tif (!s) /* result of earlier fallback */\n\t\t\tcontinue;\n\t\tget_tree(s);\n\t\tlist_replace_init(&chunk->owners[i].list, &new->owners[j].list);\n\t}\n\n\tlist_replace_rcu(&chunk->hash, &new->hash);\n\tlist_for_each_entry(owner, &new->trees, same_root)\n\t\towner->root = new;\n\tspin_unlock(&hash_lock);\n\tinotify_evict_watch(&chunk->watch);\n\tmutex_unlock(&chunk->watch.inode->inotify_mutex);\n\tput_inotify_watch(&chunk->watch);\n\treturn;\n\nFallback:\n\t// do the best we can\n\tspin_lock(&hash_lock);\n\tif (owner->root == chunk) {\n\t\tlist_del_init(&owner->same_root);\n\t\towner->root = NULL;\n\t}\n\tlist_del_init(&p->list);\n\tp->owner = NULL;\n\tput_tree(owner);\n\tspin_unlock(&hash_lock);\n\tmutex_unlock(&chunk->watch.inode->inotify_mutex);\n}",
        "target": 1
    },
    {
        "func": "static void trim_marked(struct audit_tree *tree)\n{\n\tstruct list_head *p, *q;\n\tspin_lock(&hash_lock);\n\tif (tree->goner) {\n\t\tspin_unlock(&hash_lock);\n\t\treturn;\n\t}\n\t/* reorder */\n\tfor (p = tree->chunks.next; p != &tree->chunks; p = q) {\n\t\tstruct node *node = list_entry(p, struct node, list);\n\t\tq = p->next;\n\t\tif (node->index & (1U<<31)) {\n\t\t\tlist_del_init(p);\n\t\t\tlist_add(p, &tree->chunks);\n\t\t}\n\t}\n\n\twhile (!list_empty(&tree->chunks)) {\n\t\tstruct node *node;\n\t\tstruct audit_chunk *chunk;\n\n\t\tnode = list_entry(tree->chunks.next, struct node, list);\n\n\t\t/* have we run out of marked? */\n\t\tif (!(node->index & (1U<<31)))\n\t\t\tbreak;\n\n\t\tchunk = find_chunk(node);\n\t\tget_inotify_watch(&chunk->watch);\n\t\tspin_unlock(&hash_lock);\n\n\t\tuntag_chunk(chunk, node);\n\n\t\tput_inotify_watch(&chunk->watch);\n\t\tspin_lock(&hash_lock);\n\t}\n\tif (!tree->root && !tree->goner) {\n\t\ttree->goner = 1;\n\t\tspin_unlock(&hash_lock);\n\t\tmutex_lock(&audit_filter_mutex);\n\t\tkill_rules(tree);\n\t\tlist_del_init(&tree->list);\n\t\tmutex_unlock(&audit_filter_mutex);\n\t\tprune_one(tree);\n\t} else {\n\t\tspin_unlock(&hash_lock);\n\t}\n}",
        "target": 1
    },
    {
        "func": "static inline void free_chunk(struct audit_chunk *chunk)\n{\n\tcall_rcu(&chunk->head, __free_chunk);\n}",
        "target": 1
    },
    {
        "func": "void inotify_destroy(struct inotify_handle *ih)\n{\n\t/*\n\t * Destroy all of the watches for this handle. Unfortunately, not very\n\t * pretty.  We cannot do a simple iteration over the list, because we\n\t * do not know the inode until we iterate to the watch.  But we need to\n\t * hold inode->inotify_mutex before ih->mutex.  The following works.\n\t */\n\twhile (1) {\n\t\tstruct inotify_watch *watch;\n\t\tstruct list_head *watches;\n\t\tstruct inode *inode;\n\n\t\tmutex_lock(&ih->mutex);\n\t\twatches = &ih->watches;\n\t\tif (list_empty(watches)) {\n\t\t\tmutex_unlock(&ih->mutex);\n\t\t\tbreak;\n\t\t}\n\t\twatch = list_first_entry(watches, struct inotify_watch, h_list);\n\t\tget_inotify_watch(watch);\n\t\tmutex_unlock(&ih->mutex);\n\n\t\tinode = watch->inode;\n\t\tmutex_lock(&inode->inotify_mutex);\n\t\tmutex_lock(&ih->mutex);\n\n\t\t/* make sure we didn't race with another list removal */\n\t\tif (likely(idr_find(&ih->idr, watch->wd))) {\n\t\t\tremove_watch_no_event(watch, ih);\n\t\t\tput_inotify_watch(watch);\n\t\t}\n\n\t\tmutex_unlock(&ih->mutex);\n\t\tmutex_unlock(&inode->inotify_mutex);\n\t\tput_inotify_watch(watch);\n\t}\n\n\t/* free this handle: the put matching the get in inotify_init() */\n\tput_inotify_handle(ih);\n}",
        "target": 1
    },
    {
        "func": "struct audit_chunk *audit_tree_lookup(const struct inode *inode)\n{\n\tstruct list_head *list = chunk_hash(inode);\n\tstruct audit_chunk *p;\n\n\tlist_for_each_entry_rcu(p, list, hash) {\n\t\tif (p->watch.inode == inode) {\n\t\t\tget_inotify_watch(&p->watch);\n\t\t\treturn p;\n\t\t}\n\t}\n\treturn NULL;\n}",
        "target": 1
    },
    {
        "func": "int inotify_rm_wd(struct inotify_handle *ih, u32 wd)\n{\n\tstruct inotify_watch *watch;\n\tstruct inode *inode;\n\n\tmutex_lock(&ih->mutex);\n\twatch = idr_find(&ih->idr, wd);\n\tif (unlikely(!watch)) {\n\t\tmutex_unlock(&ih->mutex);\n\t\treturn -EINVAL;\n\t}\n\tget_inotify_watch(watch);\n\tinode = watch->inode;\n\tmutex_unlock(&ih->mutex);\n\n\tmutex_lock(&inode->inotify_mutex);\n\tmutex_lock(&ih->mutex);\n\n\t/* make sure that we did not race */\n\tif (likely(idr_find(&ih->idr, wd) == watch))\n\t\tinotify_remove_watch_locked(ih, watch);\n\n\tmutex_unlock(&ih->mutex);\n\tmutex_unlock(&inode->inotify_mutex);\n\tput_inotify_watch(watch);\n\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static inline int audit_del_rule(struct audit_entry *entry,\n\t\t\t\t struct list_head *list)\n{\n\tstruct audit_entry  *e;\n\tstruct audit_field *inode_f = entry->rule.inode_f;\n\tstruct audit_watch *watch, *tmp_watch = entry->rule.watch;\n\tstruct audit_tree *tree = entry->rule.tree;\n\tLIST_HEAD(inotify_list);\n\tint h, ret = 0;\n#ifdef CONFIG_AUDITSYSCALL\n\tint dont_count = 0;\n\n\t/* If either of these, don't count towards total */\n\tif (entry->rule.listnr == AUDIT_FILTER_USER ||\n\t\tentry->rule.listnr == AUDIT_FILTER_TYPE)\n\t\tdont_count = 1;\n#endif\n\n\tif (inode_f) {\n\t\th = audit_hash_ino(inode_f->val);\n\t\tlist = &audit_inode_hash[h];\n\t}\n\n\tmutex_lock(&audit_filter_mutex);\n\te = audit_find_rule(entry, list);\n\tif (!e) {\n\t\tmutex_unlock(&audit_filter_mutex);\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\twatch = e->rule.watch;\n\tif (watch) {\n\t\tstruct audit_parent *parent = watch->parent;\n\n\t\tlist_del(&e->rule.rlist);\n\n\t\tif (list_empty(&watch->rules)) {\n\t\t\taudit_remove_watch(watch);\n\n\t\t\tif (list_empty(&parent->watches)) {\n\t\t\t\t/* Put parent on the inotify un-registration\n\t\t\t\t * list.  Grab a reference before releasing\n\t\t\t\t * audit_filter_mutex, to be released in\n\t\t\t\t * audit_inotify_unregister(). */\n\t\t\t\tlist_add(&parent->ilist, &inotify_list);\n\t\t\t\tget_inotify_watch(&parent->wdata);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (e->rule.tree)\n\t\taudit_remove_tree_rule(&e->rule);\n\n\tlist_del_rcu(&e->list);\n\tcall_rcu(&e->rcu, audit_free_rule_rcu);\n\n#ifdef CONFIG_AUDITSYSCALL\n\tif (!dont_count)\n\t\taudit_n_rules--;\n\n\tif (!audit_match_signal(entry))\n\t\taudit_signals--;\n#endif\n\tmutex_unlock(&audit_filter_mutex);\n\n\tif (!list_empty(&inotify_list))\n\t\taudit_inotify_unregister(&inotify_list);\n\nout:\n\tif (tmp_watch)\n\t\taudit_put_watch(tmp_watch); /* match initial get */\n\tif (tree)\n\t\taudit_put_tree(tree);\t/* that's the temporary one */\n\n\treturn ret;\n}",
        "target": 1
    },
    {
        "func": "static void destroy_watch(struct inotify_watch *watch)\n{\n\tstruct audit_chunk *chunk = container_of(watch, struct audit_chunk, watch);\n\tfree_chunk(chunk);\n}",
        "target": 1
    },
    {
        "func": "static struct audit_chunk *alloc_chunk(int count)\n{\n\tstruct audit_chunk *chunk;\n\tsize_t size;\n\tint i;\n\n\tsize = offsetof(struct audit_chunk, owners) + count * sizeof(struct node);\n\tchunk = kzalloc(size, GFP_KERNEL);\n\tif (!chunk)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&chunk->hash);\n\tINIT_LIST_HEAD(&chunk->trees);\n\tchunk->count = count;\n\tfor (i = 0; i < count; i++) {\n\t\tINIT_LIST_HEAD(&chunk->owners[i].list);\n\t\tchunk->owners[i].index = i;\n\t}\n\tinotify_init_watch(&chunk->watch);\n\treturn chunk;\n}",
        "target": 1
    },
    {
        "func": "void audit_put_chunk(struct audit_chunk *chunk)\n{\n\tput_inotify_watch(&chunk->watch);\n}",
        "target": 1
    },
    {
        "func": "static struct audit_chunk *find_chunk(struct node *p)\n{\n\tint index = p->index & ~(1U<<31);\n\tp -= index;\n\treturn container_of(p, struct audit_chunk, owners[0]);\n}",
        "target": 1
    },
    {
        "func": "static void prune_one(struct audit_tree *victim)\n{\n\tspin_lock(&hash_lock);\n\twhile (!list_empty(&victim->chunks)) {\n\t\tstruct node *p;\n\t\tstruct audit_chunk *chunk;\n\n\t\tp = list_entry(victim->chunks.next, struct node, list);\n\t\tchunk = find_chunk(p);\n\t\tget_inotify_watch(&chunk->watch);\n\t\tspin_unlock(&hash_lock);\n\n\t\tuntag_chunk(chunk, p);\n\n\t\tput_inotify_watch(&chunk->watch);\n\t\tspin_lock(&hash_lock);\n\t}\n\tspin_unlock(&hash_lock);\n\tput_tree(victim);\n}",
        "target": 1
    },
    {
        "func": "static void __free_chunk(struct rcu_head *rcu)\n{\n\tstruct audit_chunk *chunk = container_of(rcu, struct audit_chunk, head);\n\tint i;\n\n\tfor (i = 0; i < chunk->count; i++) {\n\t\tif (chunk->owners[i].owner)\n\t\t\tput_tree(chunk->owners[i].owner);\n\t}\n\tkfree(chunk);\n}",
        "target": 1
    },
    {
        "func": "static int unix_stream_sendmsg(struct kiocb *kiocb, struct socket *sock,\n\t\t\t       struct msghdr *msg, size_t len)\n{\n\tstruct sock_iocb *siocb = kiocb_to_siocb(kiocb);\n\tstruct sock *sk = sock->sk;\n\tstruct sock *other = NULL;\n\tstruct sockaddr_un *sunaddr=msg->msg_name;\n\tint err,size;\n\tstruct sk_buff *skb;\n\tint sent=0;\n\tstruct scm_cookie tmp_scm;\n\n\tif (NULL == siocb->scm)\n\t\tsiocb->scm = &tmp_scm;\n\terr = scm_send(sock, msg, siocb->scm);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = -EOPNOTSUPP;\n\tif (msg->msg_flags&MSG_OOB)\n\t\tgoto out_err;\n\n\tif (msg->msg_namelen) {\n\t\terr = sk->sk_state == TCP_ESTABLISHED ? -EISCONN : -EOPNOTSUPP;\n\t\tgoto out_err;\n\t} else {\n\t\tsunaddr = NULL;\n\t\terr = -ENOTCONN;\n\t\tother = unix_peer(sk);\n\t\tif (!other)\n\t\t\tgoto out_err;\n\t}\n\n\tif (sk->sk_shutdown & SEND_SHUTDOWN)\n\t\tgoto pipe_err;\n\n\twhile(sent < len)\n\t{\n\t\t/*\n\t\t *\tOptimisation for the fact that under 0.01% of X\n\t\t *\tmessages typically need breaking up.\n\t\t */\n\n\t\tsize = len-sent;\n\n\t\t/* Keep two messages in the pipe so it schedules better */\n\t\tif (size > ((sk->sk_sndbuf >> 1) - 64))\n\t\t\tsize = (sk->sk_sndbuf >> 1) - 64;\n\n\t\tif (size > SKB_MAX_ALLOC)\n\t\t\tsize = SKB_MAX_ALLOC;\n\n\t\t/*\n\t\t *\tGrab a buffer\n\t\t */\n\n\t\tskb=sock_alloc_send_skb(sk,size,msg->msg_flags&MSG_DONTWAIT, &err);\n\n\t\tif (skb==NULL)\n\t\t\tgoto out_err;\n\n\t\t/*\n\t\t *\tIf you pass two values to the sock_alloc_send_skb\n\t\t *\tit tries to grab the large buffer with GFP_NOFS\n\t\t *\t(which can fail easily), and if it fails grab the\n\t\t *\tfallback size buffer which is under a page and will\n\t\t *\tsucceed. [Alan]\n\t\t */\n\t\tsize = min_t(int, size, skb_tailroom(skb));\n\n\t\tmemcpy(UNIXCREDS(skb), &siocb->scm->creds, sizeof(struct ucred));\n\t\tif (siocb->scm->fp) {\n\t\t\terr = unix_attach_fds(siocb->scm, skb);\n\t\t\tif (err) {\n\t\t\t\tkfree_skb(skb);\n\t\t\t\tgoto out_err;\n\t\t\t}\n\t\t}\n\n\t\tif ((err = memcpy_fromiovec(skb_put(skb,size), msg->msg_iov, size)) != 0) {\n\t\t\tkfree_skb(skb);\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tunix_state_lock(other);\n\n\t\tif (sock_flag(other, SOCK_DEAD) ||\n\t\t    (other->sk_shutdown & RCV_SHUTDOWN))\n\t\t\tgoto pipe_err_free;\n\n\t\tskb_queue_tail(&other->sk_receive_queue, skb);\n\t\tunix_state_unlock(other);\n\t\tother->sk_data_ready(other, size);\n\t\tsent+=size;\n\t}\n\n\tscm_destroy(siocb->scm);\n\tsiocb->scm = NULL;\n\n\treturn sent;\n\npipe_err_free:\n\tunix_state_unlock(other);\n\tkfree_skb(skb);\npipe_err:\n\tif (sent==0 && !(msg->msg_flags&MSG_NOSIGNAL))\n\t\tsend_sig(SIGPIPE,current,0);\n\terr = -EPIPE;\nout_err:\n\tscm_destroy(siocb->scm);\n\tsiocb->scm = NULL;\n\treturn sent ? : err;\n}",
        "target": 1
    },
    {
        "func": "void unix_gc(void)\n{\n\tstatic bool gc_in_progress = false;\n\n\tstruct unix_sock *u;\n\tstruct unix_sock *next;\n\tstruct sk_buff_head hitlist;\n\tstruct list_head cursor;\n\tLIST_HEAD(not_cycle_list);\n\n\tspin_lock(&unix_gc_lock);\n\n\t/* Avoid a recursive GC. */\n\tif (gc_in_progress)\n\t\tgoto out;\n\n\tgc_in_progress = true;\n\t/*\n\t * First, select candidates for garbage collection.  Only\n\t * in-flight sockets are considered, and from those only ones\n\t * which don't have any external reference.\n\t *\n\t * Holding unix_gc_lock will protect these candidates from\n\t * being detached, and hence from gaining an external\n\t * reference.  Since there are no possible receivers, all\n\t * buffers currently on the candidates' queues stay there\n\t * during the garbage collection.\n\t *\n\t * We also know that no new candidate can be added onto the\n\t * receive queues.  Other, non candidate sockets _can_ be\n\t * added to queue, so we must make sure only to touch\n\t * candidates.\n\t */\n\tlist_for_each_entry_safe(u, next, &gc_inflight_list, link) {\n\t\tlong total_refs;\n\t\tlong inflight_refs;\n\n\t\ttotal_refs = file_count(u->sk.sk_socket->file);\n\t\tinflight_refs = atomic_long_read(&u->inflight);\n\n\t\tBUG_ON(inflight_refs < 1);\n\t\tBUG_ON(total_refs < inflight_refs);\n\t\tif (total_refs == inflight_refs) {\n\t\t\tlist_move_tail(&u->link, &gc_candidates);\n\t\t\tu->gc_candidate = 1;\n\t\t\tu->gc_maybe_cycle = 1;\n\t\t}\n\t}\n\n\t/*\n\t * Now remove all internal in-flight reference to children of\n\t * the candidates.\n\t */\n\tlist_for_each_entry(u, &gc_candidates, link)\n\t\tscan_children(&u->sk, dec_inflight, NULL);\n\n\t/*\n\t * Restore the references for children of all candidates,\n\t * which have remaining references.  Do this recursively, so\n\t * only those remain, which form cyclic references.\n\t *\n\t * Use a \"cursor\" link, to make the list traversal safe, even\n\t * though elements might be moved about.\n\t */\n\tlist_add(&cursor, &gc_candidates);\n\twhile (cursor.next != &gc_candidates) {\n\t\tu = list_entry(cursor.next, struct unix_sock, link);\n\n\t\t/* Move cursor to after the current position. */\n\t\tlist_move(&cursor, &u->link);\n\n\t\tif (atomic_long_read(&u->inflight) > 0) {\n\t\t\tlist_move_tail(&u->link, &not_cycle_list);\n\t\t\tu->gc_maybe_cycle = 0;\n\t\t\tscan_children(&u->sk, inc_inflight_move_tail, NULL);\n\t\t}\n\t}\n\tlist_del(&cursor);\n\n\t/*\n\t * not_cycle_list contains those sockets which do not make up a\n\t * cycle.  Restore these to the inflight list.\n\t */\n\twhile (!list_empty(&not_cycle_list)) {\n\t\tu = list_entry(not_cycle_list.next, struct unix_sock, link);\n\t\tu->gc_candidate = 0;\n\t\tlist_move_tail(&u->link, &gc_inflight_list);\n\t}\n\n\t/*\n\t * Now gc_candidates contains only garbage.  Restore original\n\t * inflight counters for these as well, and remove the skbuffs\n\t * which are creating the cycle(s).\n\t */\n\tskb_queue_head_init(&hitlist);\n\tlist_for_each_entry(u, &gc_candidates, link)\n\t\tscan_children(&u->sk, inc_inflight, &hitlist);\n\n\tspin_unlock(&unix_gc_lock);\n\n\t/* Here we are. Hitlist is filled. Die. */\n\t__skb_queue_purge(&hitlist);\n\n\tspin_lock(&unix_gc_lock);\n\n\t/* All candidates should have been detached by now. */\n\tBUG_ON(!list_empty(&gc_candidates));\n\tgc_in_progress = false;\n\n out:\n\tspin_unlock(&unix_gc_lock);\n}",
        "target": 1
    },
    {
        "func": "static int unix_dgram_sendmsg(struct kiocb *kiocb, struct socket *sock,\n\t\t\t      struct msghdr *msg, size_t len)\n{\n\tstruct sock_iocb *siocb = kiocb_to_siocb(kiocb);\n\tstruct sock *sk = sock->sk;\n\tstruct net *net = sock_net(sk);\n\tstruct unix_sock *u = unix_sk(sk);\n\tstruct sockaddr_un *sunaddr=msg->msg_name;\n\tstruct sock *other = NULL;\n\tint namelen = 0; /* fake GCC */\n\tint err;\n\tunsigned hash;\n\tstruct sk_buff *skb;\n\tlong timeo;\n\tstruct scm_cookie tmp_scm;\n\n\tif (NULL == siocb->scm)\n\t\tsiocb->scm = &tmp_scm;\n\terr = scm_send(sock, msg, siocb->scm);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = -EOPNOTSUPP;\n\tif (msg->msg_flags&MSG_OOB)\n\t\tgoto out;\n\n\tif (msg->msg_namelen) {\n\t\terr = unix_mkname(sunaddr, msg->msg_namelen, &hash);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\tnamelen = err;\n\t} else {\n\t\tsunaddr = NULL;\n\t\terr = -ENOTCONN;\n\t\tother = unix_peer_get(sk);\n\t\tif (!other)\n\t\t\tgoto out;\n\t}\n\n\tif (test_bit(SOCK_PASSCRED, &sock->flags)\n\t\t&& !u->addr && (err = unix_autobind(sock)) != 0)\n\t\tgoto out;\n\n\terr = -EMSGSIZE;\n\tif (len > sk->sk_sndbuf - 32)\n\t\tgoto out;\n\n\tskb = sock_alloc_send_skb(sk, len, msg->msg_flags&MSG_DONTWAIT, &err);\n\tif (skb==NULL)\n\t\tgoto out;\n\n\tmemcpy(UNIXCREDS(skb), &siocb->scm->creds, sizeof(struct ucred));\n\tif (siocb->scm->fp) {\n\t\terr = unix_attach_fds(siocb->scm, skb);\n\t\tif (err)\n\t\t\tgoto out_free;\n\t}\n\tunix_get_secdata(siocb->scm, skb);\n\n\tskb_reset_transport_header(skb);\n\terr = memcpy_fromiovec(skb_put(skb,len), msg->msg_iov, len);\n\tif (err)\n\t\tgoto out_free;\n\n\ttimeo = sock_sndtimeo(sk, msg->msg_flags & MSG_DONTWAIT);\n\nrestart:\n\tif (!other) {\n\t\terr = -ECONNRESET;\n\t\tif (sunaddr == NULL)\n\t\t\tgoto out_free;\n\n\t\tother = unix_find_other(net, sunaddr, namelen, sk->sk_type,\n\t\t\t\t\thash, &err);\n\t\tif (other==NULL)\n\t\t\tgoto out_free;\n\t}\n\n\tunix_state_lock(other);\n\terr = -EPERM;\n\tif (!unix_may_send(sk, other))\n\t\tgoto out_unlock;\n\n\tif (sock_flag(other, SOCK_DEAD)) {\n\t\t/*\n\t\t *\tCheck with 1003.1g - what should\n\t\t *\tdatagram error\n\t\t */\n\t\tunix_state_unlock(other);\n\t\tsock_put(other);\n\n\t\terr = 0;\n\t\tunix_state_lock(sk);\n\t\tif (unix_peer(sk) == other) {\n\t\t\tunix_peer(sk)=NULL;\n\t\t\tunix_state_unlock(sk);\n\n\t\t\tunix_dgram_disconnected(sk, other);\n\t\t\tsock_put(other);\n\t\t\terr = -ECONNREFUSED;\n\t\t} else {\n\t\t\tunix_state_unlock(sk);\n\t\t}\n\n\t\tother = NULL;\n\t\tif (err)\n\t\t\tgoto out_free;\n\t\tgoto restart;\n\t}\n\n\terr = -EPIPE;\n\tif (other->sk_shutdown & RCV_SHUTDOWN)\n\t\tgoto out_unlock;\n\n\tif (sk->sk_type != SOCK_SEQPACKET) {\n\t\terr = security_unix_may_send(sk->sk_socket, other->sk_socket);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\t}\n\n\tif (unix_peer(other) != sk && unix_recvq_full(other)) {\n\t\tif (!timeo) {\n\t\t\terr = -EAGAIN;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\ttimeo = unix_wait_for_peer(other, timeo);\n\n\t\terr = sock_intr_errno(timeo);\n\t\tif (signal_pending(current))\n\t\t\tgoto out_free;\n\n\t\tgoto restart;\n\t}\n\n\tskb_queue_tail(&other->sk_receive_queue, skb);\n\tunix_state_unlock(other);\n\tother->sk_data_ready(other, len);\n\tsock_put(other);\n\tscm_destroy(siocb->scm);\n\treturn len;\n\nout_unlock:\n\tunix_state_unlock(other);\nout_free:\n\tkfree_skb(skb);\nout:\n\tif (other)\n\t\tsock_put(other);\n\tscm_destroy(siocb->scm);\n\treturn err;\n}",
        "target": 1
    },
    {
        "func": "static int svc_listen(struct socket *sock,int backlog)\n{\n\tDEFINE_WAIT(wait);\n\tstruct sock *sk = sock->sk;\n\tstruct atm_vcc *vcc = ATM_SD(sock);\n\tint error;\n\n\tpr_debug(\"svc_listen %p\\n\",vcc);\n\tlock_sock(sk);\n\t/* let server handle listen on unbound sockets */\n\tif (test_bit(ATM_VF_SESSION,&vcc->flags)) {\n\t\terror = -EINVAL;\n\t\tgoto out;\n\t}\n\tvcc_insert_socket(sk);\n\tset_bit(ATM_VF_WAITING, &vcc->flags);\n\tprepare_to_wait(sk->sk_sleep, &wait, TASK_UNINTERRUPTIBLE);\n\tsigd_enq(vcc,as_listen,NULL,NULL,&vcc->local);\n\twhile (test_bit(ATM_VF_WAITING, &vcc->flags) && sigd) {\n\t\tschedule();\n\t\tprepare_to_wait(sk->sk_sleep, &wait, TASK_UNINTERRUPTIBLE);\n\t}\n\tfinish_wait(sk->sk_sleep, &wait);\n\tif (!sigd) {\n\t\terror = -EUNATCH;\n\t\tgoto out;\n\t}\n\tset_bit(ATM_VF_LISTEN,&vcc->flags);\n\tsk->sk_max_ack_backlog = backlog > 0 ? backlog : ATM_BACKLOG_DEFAULT;\n\terror = -sk->sk_err;\nout:\n\trelease_sock(sk);\n\treturn error;\n}",
        "target": 1
    },
    {
        "func": "static int blk_fill_sghdr_rq(struct request_queue *q, struct request *rq,\n\t\t\t     struct sg_io_hdr *hdr, fmode_t mode)\n{\n\tif (copy_from_user(rq->cmd, hdr->cmdp, hdr->cmd_len))\n\t\treturn -EFAULT;\n\tif (blk_verify_command(&q->cmd_filter, rq->cmd, mode & FMODE_WRITE))\n\t\treturn -EPERM;\n\n\t/*\n\t * fill in request structure\n\t */\n\trq->cmd_len = hdr->cmd_len;\n\trq->cmd_type = REQ_TYPE_BLOCK_PC;\n\n\trq->timeout = msecs_to_jiffies(hdr->timeout);\n\tif (!rq->timeout)\n\t\trq->timeout = q->sg_timeout;\n\tif (!rq->timeout)\n\t\trq->timeout = BLK_DEFAULT_SG_TIMEOUT;\n\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static int blk_fill_sgv4_hdr_rq(struct request_queue *q, struct request *rq,\n\t\t\t\tstruct sg_io_v4 *hdr, struct bsg_device *bd,\n\t\t\t\tfmode_t has_write_perm)\n{\n\tif (hdr->request_len > BLK_MAX_CDB) {\n\t\trq->cmd = kzalloc(hdr->request_len, GFP_KERNEL);\n\t\tif (!rq->cmd)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (copy_from_user(rq->cmd, (void *)(unsigned long)hdr->request,\n\t\t\t   hdr->request_len))\n\t\treturn -EFAULT;\n\n\tif (hdr->subprotocol == BSG_SUB_PROTOCOL_SCSI_CMD) {\n\t\tif (blk_verify_command(&q->cmd_filter, rq->cmd, has_write_perm))\n\t\t\treturn -EPERM;\n\t} else if (!capable(CAP_SYS_RAWIO))\n\t\treturn -EPERM;\n\n\t/*\n\t * fill in request structure\n\t */\n\trq->cmd_len = hdr->request_len;\n\trq->cmd_type = REQ_TYPE_BLOCK_PC;\n\n\trq->timeout = (hdr->timeout * HZ) / 1000;\n\tif (!rq->timeout)\n\t\trq->timeout = q->sg_timeout;\n\tif (!rq->timeout)\n\t\trq->timeout = BLK_DEFAULT_SG_TIMEOUT;\n\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static int ibwdt_set_heartbeat(int t)\n{\n\tint i;\n\n\tif ((t < 0) || (t > 30))\n\t\treturn -EINVAL;\n\n\tfor (i = 0x0F; i > -1; i--)\n\t\tif (wd_times[i] > t)\n\t\t\tbreak;\n\twd_margin = i;\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static void dispatch_packet(AvahiServer *s, AvahiDnsPacket *p, const AvahiAddress *src_address, uint16_t port, const AvahiAddress *dst_address, AvahiIfIndex iface, int ttl) {\n    AvahiInterface *i;\n    int from_local_iface = 0;\n\n    assert(s);\n    assert(p);\n    assert(src_address);\n    assert(dst_address);\n    assert(iface > 0);\n    assert(src_address->proto == dst_address->proto);\n\n    if (!(i = avahi_interface_monitor_get_interface(s->monitor, iface, src_address->proto)) ||\n        !i->announcing) {\n        avahi_log_warn(\"Received packet from invalid interface.\");\n        return;\n    }\n\n    if (avahi_address_is_ipv4_in_ipv6(src_address))\n        /* This is an IPv4 address encapsulated in IPv6, so let's ignore it. */\n        return;\n\n    if (originates_from_local_legacy_unicast_socket(s, src_address, port))\n        /* This originates from our local reflector, so let's ignore it */\n        return;\n\n    /* We don't want to reflect local traffic, so we check if this packet is generated locally. */\n    if (s->config.enable_reflector)\n        from_local_iface = originates_from_local_iface(s, iface, src_address, port);\n\n    if (avahi_dns_packet_check_valid_multicast(p) < 0) {\n        avahi_log_warn(\"Received invalid packet.\");\n        return;\n    }\n\n    if (avahi_dns_packet_is_query(p)) {\n        int legacy_unicast = 0;\n\n        if (avahi_dns_packet_get_field(p, AVAHI_DNS_FIELD_ARCOUNT) != 0) {\n            avahi_log_warn(\"Invalid query packet.\");\n            return;\n        }\n\n        if (port != AVAHI_MDNS_PORT) {\n            /* Legacy Unicast */\n\n            if ((avahi_dns_packet_get_field(p, AVAHI_DNS_FIELD_ANCOUNT) != 0 ||\n                 avahi_dns_packet_get_field(p, AVAHI_DNS_FIELD_NSCOUNT) != 0)) {\n                avahi_log_warn(\"Invalid legacy unicast query packet.\");\n                return;\n            }\n\n            legacy_unicast = 1;\n        }\n\n        if (legacy_unicast)\n            reflect_legacy_unicast_query_packet(s, p, i, src_address, port);\n\n        handle_query_packet(s, p, i, src_address, port, legacy_unicast, from_local_iface);\n\n    } else {\n        char t[AVAHI_ADDRESS_STR_MAX];\n\n        if (port != AVAHI_MDNS_PORT) {\n            avahi_log_warn(\"Received response from host %s with invalid source port %u on interface '%s.%i'\", avahi_address_snprint(t, sizeof(t), src_address), port, i->hardware->name, i->protocol);\n            return;\n        }\n\n        if (ttl != 255 && s->config.check_response_ttl) {\n            avahi_log_warn(\"Received response from host %s with invalid TTL %u on interface '%s.%i'.\", avahi_address_snprint(t, sizeof(t), src_address), ttl, i->hardware->name, i->protocol);\n            return;\n        }\n\n        if (!is_mdns_mcast_address(dst_address) &&\n            !avahi_interface_address_on_link(i, src_address)) {\n\n            avahi_log_warn(\"Received non-local response from host %s on interface '%s.%i'.\", avahi_address_snprint(t, sizeof(t), src_address), i->hardware->name, i->protocol);\n            return;\n        }\n\n        if (avahi_dns_packet_get_field(p, AVAHI_DNS_FIELD_QDCOUNT) != 0 ||\n            avahi_dns_packet_get_field(p, AVAHI_DNS_FIELD_ANCOUNT) == 0 ||\n            avahi_dns_packet_get_field(p, AVAHI_DNS_FIELD_NSCOUNT) != 0) {\n\n            avahi_log_warn(\"Invalid response packet from host %s.\", avahi_address_snprint(t, sizeof(t), src_address));\n            return;\n        }\n\n        handle_response_packet(s, p, i, src_address, from_local_iface);\n    }\n}",
        "target": 1
    },
    {
        "func": "\twhile(1) {\n\t\t/* Add the Unix Domain Sockets to the list of read\n\t\t * descriptors.\n\t\t * rgerhards 2005-08-01: we must now check if there are\n\t\t * any local sockets to listen to at all. If the -o option\n\t\t * is given without -a, we do not need to listen at all..\n\t\t */\n\t        maxfds = 0;\n\t        FD_ZERO (&readfds);\n\n\t\t/* Add the UDP listen sockets to the list of read descriptors.\n\t\t */\n\t\tif(udpLstnSocks != NULL) {\n                        for (i = 0; i < *udpLstnSocks; i++) {\n                                if (udpLstnSocks[i+1] != -1) {\n\t\t\t\t\tif(Debug)\n\t\t\t\t\t\tnet.debugListenInfo(udpLstnSocks[i+1], \"UDP\");\n                                        FD_SET(udpLstnSocks[i+1], &readfds);\n\t\t\t\t\tif(udpLstnSocks[i+1]>maxfds) maxfds=udpLstnSocks[i+1];\n\t\t\t\t}\n                        }\n\t\t}\n\t\tif(Debug) {\n\t\t\tdbgprintf(\"--------imUDP calling select, active file descriptors (max %d): \", maxfds);\n\t\t\tfor (nfds = 0; nfds <= maxfds; ++nfds)\n\t\t\t\tif ( FD_ISSET(nfds, &readfds) )\n\t\t\t\t\tdbgprintf(\"%d \", nfds);\n\t\t\tdbgprintf(\"\\n\");\n\t\t}\n\n\t\t/* wait for io to become ready */\n\t\tnfds = select(maxfds+1, (fd_set *) &readfds, NULL, NULL, NULL);\n\n\t\tif(udpLstnSocks != NULL) {\n\t\t       for (i = 0; nfds && i < *udpLstnSocks; i++) {\n\t\t\t       if (FD_ISSET(udpLstnSocks[i+1], &readfds)) {\n\t\t\t\t       socklen = sizeof(frominet);\n\t\t\t\t       l = recvfrom(udpLstnSocks[i+1], (char*) pRcvBuf, MAXLINE - 1, 0,\n\t\t\t\t\t\t    (struct sockaddr *)&frominet, &socklen);\n\t\t\t\t       if (l > 0) {\n\t\t\t\t\t       if(net.cvthname(&frominet, fromHost, fromHostFQDN, fromHostIP) == RS_RET_OK) {\n\t\t\t\t\t\t       dbgprintf(\"Message from inetd socket: #%d, host: %s\\n\",\n\t\t\t\t\t\t\t       udpLstnSocks[i+1], fromHost);\n\t\t\t\t\t\t       /* Here we check if a host is permitted to send us\n\t\t\t\t\t\t\t* syslog messages. If it isn't, we do not further\n\t\t\t\t\t\t\t* process the message but log a warning (if we are\n\t\t\t\t\t\t\t* configured to do this).\n\t\t\t\t\t\t\t* rgerhards, 2005-09-26\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t       if(net.isAllowedSender((uchar*) \"UDP\",\n\t\t\t\t\t\t\t  (struct sockaddr *)&frominet, (char*)fromHostFQDN)) {\n\t\t\t\t\t\t\t       parseAndSubmitMessage(fromHost, fromHostIP, pRcvBuf, l,\n\t\t\t\t\t\t\t       MSG_PARSE_HOSTNAME, NOFLAG, eFLOWCTL_NO_DELAY);\n\t\t\t\t\t\t       } else {\n\t\t\t\t\t\t\t       dbgprintf(\"%s is not an allowed sender\\n\", (char*)fromHostFQDN);\n\t\t\t\t\t\t\t       if(glbl.GetOption_DisallowWarning) {\n\t\t\t\t\t\t\t\t       errmsg.LogError(0, NO_ERRCODE, \"UDP message from disallowed sender %s discarded\",\n\t\t\t\t\t\t\t\t\t\t  (char*)fromHost);\n\t\t\t\t\t\t\t       }\t\n\t\t\t\t\t\t       }\n\t\t\t\t\t       }\n\t\t\t\t       } else if (l < 0 && errno != EINTR && errno != EAGAIN) {\n\t\t\t\t\t\tchar errStr[1024];\n\t\t\t\t\t\trs_strerror_r(errno, errStr, sizeof(errStr));\n\t\t\t\t\t\tdbgprintf(\"INET socket error: %d = %s.\\n\", errno, errStr);\n\t\t\t\t\t\t       errmsg.LogError(errno, NO_ERRCODE, \"recvfrom inet\");\n\t\t\t\t\t\t       /* should be harmless */\n\t\t\t\t\t\t       sleep(1);\n\t\t\t\t\t       }\n\t\t\t\t\t--nfds; /* indicate we have processed one */\n\t\t\t\t}\n\t\t       }\n\t\t}\n\t}",
        "target": 1
    },
    {
        "func": "void __qdisc_run(struct net_device *dev)\n{\n\tdo {\n\t\tif (!qdisc_restart(dev))\n\t\t\tbreak;\n\t} while (!netif_queue_stopped(dev));\n\n\tclear_bit(__LINK_STATE_QDISC_RUNNING, &dev->state);\n}",
        "target": 1
    },
    {
        "func": "sctp_disposition_t sctp_sf_eat_fwd_tsn_fast(\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_fwdtsn_hdr *fwdtsn_hdr;\n\t__u16 len;\n\t__u32 tsn;\n\n\tif (!sctp_vtag_verify(chunk, asoc)) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n\t\t\t\tSCTP_NULL());\n\t\treturn sctp_sf_pdiscard(ep, asoc, type, arg, commands);\n\t}\n\n\t/* Make sure that the FORWARD_TSN chunk has a valid length.  */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_fwdtsn_chunk)))\n\t\treturn sctp_sf_violation_chunklen(ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tfwdtsn_hdr = (struct sctp_fwdtsn_hdr *)chunk->skb->data;\n\tchunk->subh.fwdtsn_hdr = fwdtsn_hdr;\n\tlen = ntohs(chunk->chunk_hdr->length);\n\tlen -= sizeof(struct sctp_chunkhdr);\n\tskb_pull(chunk->skb, len);\n\n\ttsn = ntohl(fwdtsn_hdr->new_cum_tsn);\n\tSCTP_DEBUG_PRINTK(\"%s: TSN 0x%x.\\n\", __func__, tsn);\n\n\t/* The TSN is too high--silently discard the chunk and count on it\n\t * getting retransmitted later.\n\t */\n\tif (sctp_tsnmap_check(&asoc->peer.tsn_map, tsn) < 0)\n\t\tgoto gen_shutdown;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_FWDTSN, SCTP_U32(tsn));\n\tif (len > sizeof(struct sctp_fwdtsn_hdr))\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_FWDTSN,\n\t\t\t\tSCTP_CHUNK(chunk));\n\n\t/* Go a head and force a SACK, since we are shutting down. */\ngen_shutdown:\n\t/* Implementor's Guide.\n\t *\n\t * While in SHUTDOWN-SENT state, the SHUTDOWN sender MUST immediately\n\t * respond to each received packet containing one or more DATA chunk(s)\n\t * with a SACK, a SHUTDOWN chunk, and restart the T2-shutdown timer\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SHUTDOWN, SCTP_NULL());\n\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SACK, SCTP_FORCE());\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}",
        "target": 1
    },
    {
        "func": "sctp_disposition_t sctp_sf_eat_fwd_tsn(const struct sctp_endpoint *ep,\n\t\t\t\t       const struct sctp_association *asoc,\n\t\t\t\t       const sctp_subtype_t type,\n\t\t\t\t       void *arg,\n\t\t\t\t       sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_fwdtsn_hdr *fwdtsn_hdr;\n\t__u16 len;\n\t__u32 tsn;\n\n\tif (!sctp_vtag_verify(chunk, asoc)) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n\t\t\t\tSCTP_NULL());\n\t\treturn sctp_sf_pdiscard(ep, asoc, type, arg, commands);\n\t}\n\n\t/* Make sure that the FORWARD_TSN chunk has valid length.  */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_fwdtsn_chunk)))\n\t\treturn sctp_sf_violation_chunklen(ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tfwdtsn_hdr = (struct sctp_fwdtsn_hdr *)chunk->skb->data;\n\tchunk->subh.fwdtsn_hdr = fwdtsn_hdr;\n\tlen = ntohs(chunk->chunk_hdr->length);\n\tlen -= sizeof(struct sctp_chunkhdr);\n\tskb_pull(chunk->skb, len);\n\n\ttsn = ntohl(fwdtsn_hdr->new_cum_tsn);\n\tSCTP_DEBUG_PRINTK(\"%s: TSN 0x%x.\\n\", __func__, tsn);\n\n\t/* The TSN is too high--silently discard the chunk and count on it\n\t * getting retransmitted later.\n\t */\n\tif (sctp_tsnmap_check(&asoc->peer.tsn_map, tsn) < 0)\n\t\tgoto discard_noforce;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_FWDTSN, SCTP_U32(tsn));\n\tif (len > sizeof(struct sctp_fwdtsn_hdr))\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_FWDTSN,\n\t\t\t\tSCTP_CHUNK(chunk));\n\n\t/* Count this as receiving DATA. */\n\tif (asoc->autoclose) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_AUTOCLOSE));\n\t}\n\n\t/* FIXME: For now send a SACK, but DATA processing may\n\t * send another.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SACK, SCTP_NOFORCE());\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\ndiscard_noforce:\n\treturn SCTP_DISPOSITION_DISCARD;\n}",
        "target": 1
    },
    {
        "func": "static struct task_struct *copy_process(unsigned long clone_flags,\n\t\t\t\t\tunsigned long stack_start,\n\t\t\t\t\tstruct pt_regs *regs,\n\t\t\t\t\tunsigned long stack_size,\n\t\t\t\t\tint __user *child_tidptr,\n\t\t\t\t\tstruct pid *pid,\n\t\t\t\t\tint trace)\n{\n\tint retval;\n\tstruct task_struct *p;\n\tint cgroup_callbacks_done = 0;\n\n\tif ((clone_flags & (CLONE_NEWNS|CLONE_FS)) == (CLONE_NEWNS|CLONE_FS))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * Thread groups must share signals as well, and detached threads\n\t * can only be started up within the thread group.\n\t */\n\tif ((clone_flags & CLONE_THREAD) && !(clone_flags & CLONE_SIGHAND))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * Shared signal handlers imply shared VM. By way of the above,\n\t * thread groups also imply shared VM. Blocking this case allows\n\t * for various simplifications in other code.\n\t */\n\tif ((clone_flags & CLONE_SIGHAND) && !(clone_flags & CLONE_VM))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tretval = security_task_create(clone_flags);\n\tif (retval)\n\t\tgoto fork_out;\n\n\tretval = -ENOMEM;\n\tp = dup_task_struct(current);\n\tif (!p)\n\t\tgoto fork_out;\n\n\trt_mutex_init_task(p);\n\n#ifdef CONFIG_PROVE_LOCKING\n\tDEBUG_LOCKS_WARN_ON(!p->hardirqs_enabled);\n\tDEBUG_LOCKS_WARN_ON(!p->softirqs_enabled);\n#endif\n\tretval = -EAGAIN;\n\tif (atomic_read(&p->real_cred->user->processes) >=\n\t\t\tp->signal->rlim[RLIMIT_NPROC].rlim_cur) {\n\t\tif (!capable(CAP_SYS_ADMIN) && !capable(CAP_SYS_RESOURCE) &&\n\t\t    p->real_cred->user != INIT_USER)\n\t\t\tgoto bad_fork_free;\n\t}\n\n\tretval = copy_creds(p, clone_flags);\n\tif (retval < 0)\n\t\tgoto bad_fork_free;\n\n\t/*\n\t * If multiple threads are within copy_process(), then this check\n\t * triggers too late. This doesn't hurt, the check is only there\n\t * to stop root fork bombs.\n\t */\n\tretval = -EAGAIN;\n\tif (nr_threads >= max_threads)\n\t\tgoto bad_fork_cleanup_count;\n\n\tif (!try_module_get(task_thread_info(p)->exec_domain->module))\n\t\tgoto bad_fork_cleanup_count;\n\n\tif (p->binfmt && !try_module_get(p->binfmt->module))\n\t\tgoto bad_fork_cleanup_put_domain;\n\n\tp->did_exec = 0;\n\tdelayacct_tsk_init(p);\t/* Must remain after dup_task_struct() */\n\tcopy_flags(clone_flags, p);\n\tINIT_LIST_HEAD(&p->children);\n\tINIT_LIST_HEAD(&p->sibling);\n#ifdef CONFIG_PREEMPT_RCU\n\tp->rcu_read_lock_nesting = 0;\n\tp->rcu_flipctr_idx = 0;\n#endif /* #ifdef CONFIG_PREEMPT_RCU */\n\tp->vfork_done = NULL;\n\tspin_lock_init(&p->alloc_lock);\n\n\tclear_tsk_thread_flag(p, TIF_SIGPENDING);\n\tinit_sigpending(&p->pending);\n\n\tp->utime = cputime_zero;\n\tp->stime = cputime_zero;\n\tp->gtime = cputime_zero;\n\tp->utimescaled = cputime_zero;\n\tp->stimescaled = cputime_zero;\n\tp->prev_utime = cputime_zero;\n\tp->prev_stime = cputime_zero;\n\n\tp->default_timer_slack_ns = current->timer_slack_ns;\n\n#ifdef CONFIG_DETECT_SOFTLOCKUP\n\tp->last_switch_count = 0;\n\tp->last_switch_timestamp = 0;\n#endif\n\n\ttask_io_accounting_init(&p->ioac);\n\tacct_clear_integrals(p);\n\n\tposix_cpu_timers_init(p);\n\n\tp->lock_depth = -1;\t\t/* -1 = no lock */\n\tdo_posix_clock_monotonic_gettime(&p->start_time);\n\tp->real_start_time = p->start_time;\n\tmonotonic_to_bootbased(&p->real_start_time);\n\tp->io_context = NULL;\n\tp->audit_context = NULL;\n\tcgroup_fork(p);\n#ifdef CONFIG_NUMA\n\tp->mempolicy = mpol_dup(p->mempolicy);\n \tif (IS_ERR(p->mempolicy)) {\n \t\tretval = PTR_ERR(p->mempolicy);\n \t\tp->mempolicy = NULL;\n \t\tgoto bad_fork_cleanup_cgroup;\n \t}\n\tmpol_fix_fork_child_flag(p);\n#endif\n#ifdef CONFIG_TRACE_IRQFLAGS\n\tp->irq_events = 0;\n#ifdef __ARCH_WANT_INTERRUPTS_ON_CTXSW\n\tp->hardirqs_enabled = 1;\n#else\n\tp->hardirqs_enabled = 0;\n#endif\n\tp->hardirq_enable_ip = 0;\n\tp->hardirq_enable_event = 0;\n\tp->hardirq_disable_ip = _THIS_IP_;\n\tp->hardirq_disable_event = 0;\n\tp->softirqs_enabled = 1;\n\tp->softirq_enable_ip = _THIS_IP_;\n\tp->softirq_enable_event = 0;\n\tp->softirq_disable_ip = 0;\n\tp->softirq_disable_event = 0;\n\tp->hardirq_context = 0;\n\tp->softirq_context = 0;\n#endif\n#ifdef CONFIG_LOCKDEP\n\tp->lockdep_depth = 0; /* no locks held yet */\n\tp->curr_chain_key = 0;\n\tp->lockdep_recursion = 0;\n#endif\n\n#ifdef CONFIG_DEBUG_MUTEXES\n\tp->blocked_on = NULL; /* not blocked yet */\n#endif\n\tif (unlikely(current->ptrace))\n\t\tptrace_fork(p, clone_flags);\n\n\t/* Perform scheduler related setup. Assign this task to a CPU. */\n\tsched_fork(p, clone_flags);\n\n\tif ((retval = audit_alloc(p)))\n\t\tgoto bad_fork_cleanup_policy;\n\t/* copy all the process information */\n\tif ((retval = copy_semundo(clone_flags, p)))\n\t\tgoto bad_fork_cleanup_audit;\n\tif ((retval = copy_files(clone_flags, p)))\n\t\tgoto bad_fork_cleanup_semundo;\n\tif ((retval = copy_fs(clone_flags, p)))\n\t\tgoto bad_fork_cleanup_files;\n\tif ((retval = copy_sighand(clone_flags, p)))\n\t\tgoto bad_fork_cleanup_fs;\n\tif ((retval = copy_signal(clone_flags, p)))\n\t\tgoto bad_fork_cleanup_sighand;\n\tif ((retval = copy_mm(clone_flags, p)))\n\t\tgoto bad_fork_cleanup_signal;\n\tif ((retval = copy_namespaces(clone_flags, p)))\n\t\tgoto bad_fork_cleanup_mm;\n\tif ((retval = copy_io(clone_flags, p)))\n\t\tgoto bad_fork_cleanup_namespaces;\n\tretval = copy_thread(0, clone_flags, stack_start, stack_size, p, regs);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_io;\n\n\tif (pid != &init_struct_pid) {\n\t\tretval = -ENOMEM;\n\t\tpid = alloc_pid(p->nsproxy->pid_ns);\n\t\tif (!pid)\n\t\t\tgoto bad_fork_cleanup_io;\n\n\t\tif (clone_flags & CLONE_NEWPID) {\n\t\t\tretval = pid_ns_prepare_proc(p->nsproxy->pid_ns);\n\t\t\tif (retval < 0)\n\t\t\t\tgoto bad_fork_free_pid;\n\t\t}\n\t}\n\n\tftrace_graph_init_task(p);\n\n\tp->pid = pid_nr(pid);\n\tp->tgid = p->pid;\n\tif (clone_flags & CLONE_THREAD)\n\t\tp->tgid = current->tgid;\n\n\tif (current->nsproxy != p->nsproxy) {\n\t\tretval = ns_cgroup_clone(p, pid);\n\t\tif (retval)\n\t\t\tgoto bad_fork_free_graph;\n\t}\n\n\tp->set_child_tid = (clone_flags & CLONE_CHILD_SETTID) ? child_tidptr : NULL;\n\t/*\n\t * Clear TID on mm_release()?\n\t */\n\tp->clear_child_tid = (clone_flags & CLONE_CHILD_CLEARTID) ? child_tidptr: NULL;\n#ifdef CONFIG_FUTEX\n\tp->robust_list = NULL;\n#ifdef CONFIG_COMPAT\n\tp->compat_robust_list = NULL;\n#endif\n\tINIT_LIST_HEAD(&p->pi_state_list);\n\tp->pi_state_cache = NULL;\n#endif\n\t/*\n\t * sigaltstack should be cleared when sharing the same VM\n\t */\n\tif ((clone_flags & (CLONE_VM|CLONE_VFORK)) == CLONE_VM)\n\t\tp->sas_ss_sp = p->sas_ss_size = 0;\n\n\t/*\n\t * Syscall tracing should be turned off in the child regardless\n\t * of CLONE_PTRACE.\n\t */\n\tclear_tsk_thread_flag(p, TIF_SYSCALL_TRACE);\n#ifdef TIF_SYSCALL_EMU\n\tclear_tsk_thread_flag(p, TIF_SYSCALL_EMU);\n#endif\n\tclear_all_latency_tracing(p);\n\n\t/* Our parent execution domain becomes current domain\n\t   These must match for thread signalling to apply */\n\tp->parent_exec_id = p->self_exec_id;\n\n\t/* ok, now we should be set up.. */\n\tp->exit_signal = (clone_flags & CLONE_THREAD) ? -1 : (clone_flags & CSIGNAL);\n\tp->pdeath_signal = 0;\n\tp->exit_state = 0;\n\n\t/*\n\t * Ok, make it visible to the rest of the system.\n\t * We dont wake it up yet.\n\t */\n\tp->group_leader = p;\n\tINIT_LIST_HEAD(&p->thread_group);\n\n\t/* Now that the task is set up, run cgroup callbacks if\n\t * necessary. We need to run them before the task is visible\n\t * on the tasklist. */\n\tcgroup_fork_callbacks(p);\n\tcgroup_callbacks_done = 1;\n\n\t/* Need tasklist lock for parent etc handling! */\n\twrite_lock_irq(&tasklist_lock);\n\n\t/*\n\t * The task hasn't been attached yet, so its cpus_allowed mask will\n\t * not be changed, nor will its assigned CPU.\n\t *\n\t * The cpus_allowed mask of the parent may have changed after it was\n\t * copied first time - so re-copy it here, then check the child's CPU\n\t * to ensure it is on a valid CPU (and if not, just force it back to\n\t * parent's CPU). This avoids alot of nasty races.\n\t */\n\tp->cpus_allowed = current->cpus_allowed;\n\tp->rt.nr_cpus_allowed = current->rt.nr_cpus_allowed;\n\tif (unlikely(!cpu_isset(task_cpu(p), p->cpus_allowed) ||\n\t\t\t!cpu_online(task_cpu(p))))\n\t\tset_task_cpu(p, smp_processor_id());\n\n\t/* CLONE_PARENT re-uses the old parent */\n\tif (clone_flags & (CLONE_PARENT|CLONE_THREAD))\n\t\tp->real_parent = current->real_parent;\n\telse\n\t\tp->real_parent = current;\n\n\tspin_lock(&current->sighand->siglock);\n\n\t/*\n\t * Process group and session signals need to be delivered to just the\n\t * parent before the fork or both the parent and the child after the\n\t * fork. Restart if a signal comes in before we add the new process to\n\t * it's process group.\n\t * A fatal signal pending means that current will exit, so the new\n\t * thread can't slip out of an OOM kill (or normal SIGKILL).\n \t */\n\trecalc_sigpending();\n\tif (signal_pending(current)) {\n\t\tspin_unlock(&current->sighand->siglock);\n\t\twrite_unlock_irq(&tasklist_lock);\n\t\tretval = -ERESTARTNOINTR;\n\t\tgoto bad_fork_free_graph;\n\t}\n\n\tif (clone_flags & CLONE_THREAD) {\n\t\tp->group_leader = current->group_leader;\n\t\tlist_add_tail_rcu(&p->thread_group, &p->group_leader->thread_group);\n\t}\n\n\tif (likely(p->pid)) {\n\t\tlist_add_tail(&p->sibling, &p->real_parent->children);\n\t\ttracehook_finish_clone(p, clone_flags, trace);\n\n\t\tif (thread_group_leader(p)) {\n\t\t\tif (clone_flags & CLONE_NEWPID)\n\t\t\t\tp->nsproxy->pid_ns->child_reaper = p;\n\n\t\t\tp->signal->leader_pid = pid;\n\t\t\ttty_kref_put(p->signal->tty);\n\t\t\tp->signal->tty = tty_kref_get(current->signal->tty);\n\t\t\tset_task_pgrp(p, task_pgrp_nr(current));\n\t\t\tset_task_session(p, task_session_nr(current));\n\t\t\tattach_pid(p, PIDTYPE_PGID, task_pgrp(current));\n\t\t\tattach_pid(p, PIDTYPE_SID, task_session(current));\n\t\t\tlist_add_tail_rcu(&p->tasks, &init_task.tasks);\n\t\t\t__get_cpu_var(process_counts)++;\n\t\t}\n\t\tattach_pid(p, PIDTYPE_PID, pid);\n\t\tnr_threads++;\n\t}\n\n\ttotal_forks++;\n\tspin_unlock(&current->sighand->siglock);\n\twrite_unlock_irq(&tasklist_lock);\n\tproc_fork_connector(p);\n\tcgroup_post_fork(p);\n\treturn p;\n\nbad_fork_free_graph:\n\tftrace_graph_exit_task(p);\nbad_fork_free_pid:\n\tif (pid != &init_struct_pid)\n\t\tfree_pid(pid);\nbad_fork_cleanup_io:\n\tput_io_context(p->io_context);\nbad_fork_cleanup_namespaces:\n\texit_task_namespaces(p);\nbad_fork_cleanup_mm:\n\tif (p->mm)\n\t\tmmput(p->mm);\nbad_fork_cleanup_signal:\n\tcleanup_signal(p);\nbad_fork_cleanup_sighand:\n\t__cleanup_sighand(p->sighand);\nbad_fork_cleanup_fs:\n\texit_fs(p); /* blocking */\nbad_fork_cleanup_files:\n\texit_files(p); /* blocking */\nbad_fork_cleanup_semundo:\n\texit_sem(p);\nbad_fork_cleanup_audit:\n\taudit_free(p);\nbad_fork_cleanup_policy:\n#ifdef CONFIG_NUMA\n\tmpol_put(p->mempolicy);\nbad_fork_cleanup_cgroup:\n#endif\n\tcgroup_exit(p, cgroup_callbacks_done);\n\tdelayacct_tsk_free(p);\n\tif (p->binfmt)\n\t\tmodule_put(p->binfmt->module);\nbad_fork_cleanup_put_domain:\n\tmodule_put(task_thread_info(p)->exec_domain->module);\nbad_fork_cleanup_count:\n\tatomic_dec(&p->cred->user->processes);\n\tput_cred(p->real_cred);\n\tput_cred(p->cred);\nbad_fork_free:\n\tfree_task(p);\nfork_out:\n\treturn ERR_PTR(retval);\n}",
        "target": 1
    },
    {
        "func": "_AFmoduleinst _af_ms_adpcm_init_decompress (_Track *track, AFvirtualfile *fh,\n\tbool seekok, bool headerless, AFframecount *chunkframes)\n{\n\t_AFmoduleinst\tret = _AFnewmodinst(&ms_adpcm_decompress);\n\tms_adpcm_data\t*d;\n\tAUpvlist\tpv;\n\tlong\t\tl;\n\tvoid\t\t*v;\n\n\tassert(af_ftell(fh) == track->fpos_first_frame);\n\n\td = (ms_adpcm_data *) _af_malloc(sizeof (ms_adpcm_data));\n\n\td->track = track;\n\td->fh = fh;\n\n\td->track->frames2ignore = 0;\n\td->track->fpos_next_frame = d->track->fpos_first_frame;\n\n\tpv = d->track->f.compressionParams;\n\tif (_af_pv_getlong(pv, _AF_MS_ADPCM_NUM_COEFFICIENTS, &l))\n\t\td->numCoefficients = l;\n\telse\n\t\t_af_error(AF_BAD_CODEC_CONFIG, \"number of coefficients not set\");\n\n\tif (_af_pv_getptr(pv, _AF_MS_ADPCM_COEFFICIENTS, &v))\n\t\tmemcpy(d->coefficients, v, sizeof (int16_t) * 256 * 2);\n\telse\n\t\t_af_error(AF_BAD_CODEC_CONFIG, \"coefficient array not set\");\n\n\tif (_af_pv_getlong(pv, _AF_SAMPLES_PER_BLOCK, &l))\n\t\td->samplesPerBlock = l;\n\telse\n\t\t_af_error(AF_BAD_CODEC_CONFIG, \"samples per block not set\");\n\n\tif (_af_pv_getlong(pv, _AF_BLOCK_SIZE, &l))\n\t\td->blockAlign = l;\n\telse\n\t\t_af_error(AF_BAD_CODEC_CONFIG, \"block size not set\");\n\n\t*chunkframes = d->samplesPerBlock / d->track->f.channelCount;\n\n\tret.modspec = d;\n\treturn ret;\n}",
        "target": 1
    },
    {
        "func": "static void ms_adpcm_run_pull (_AFmoduleinst *module)\n{\n\tms_adpcm_data\t*d = (ms_adpcm_data *) module->modspec;\n\tAFframecount\tframes2read = module->outc->nframes;\n\tAFframecount\tnframes = 0;\n\tint\t\ti, framesPerBlock, blockCount;\n\tssize_t\t\tblocksRead, bytesDecoded;\n\n\tframesPerBlock = d->samplesPerBlock / d->track->f.channelCount;\n\tassert(module->outc->nframes % framesPerBlock == 0);\n\tblockCount = module->outc->nframes / framesPerBlock;\n\n\t/* Read the compressed frames. */\n\tblocksRead = af_fread(module->inc->buf, d->blockAlign, blockCount, d->fh);\n\n\t/* Decompress into module->outc. */\n\tfor (i=0; i<blockCount; i++)\n\t{\n\t\tbytesDecoded = ms_adpcm_decode_block(d,\n\t\t\t(uint8_t *) module->inc->buf + i * d->blockAlign,\n\t\t\t(int16_t *) module->outc->buf + i * d->samplesPerBlock);\n\n\t\tnframes += framesPerBlock;\n\t}\n\n\td->track->nextfframe += nframes;\n\n\tif (blocksRead > 0)\n\t\td->track->fpos_next_frame += blocksRead * d->blockAlign;\n\n\tassert(af_ftell(d->fh) == d->track->fpos_next_frame);\n\n\t/*\n\t\tIf we got EOF from read, then we return the actual amount read.\n\n\t\tComplain only if there should have been more frames in the file.\n\t*/\n\n\tif (d->track->totalfframes != -1 && nframes != frames2read)\n\t{\n\t\t/* Report error if we haven't already */\n\t\tif (d->track->filemodhappy)\n\t\t{\n\t\t\t_af_error(AF_BAD_READ,\n\t\t\t\t\"file missing data -- read %d frames, should be %d\",\n\t\t\t\td->track->nextfframe,\n\t\t\t\td->track->totalfframes);\n\t\t\td->track->filemodhappy = AF_FALSE;\n\t\t}\n\t}\n\n\tmodule->outc->nframes = nframes;\n}",
        "target": 1
    },
    {
        "func": "static void ms_adpcm_reset2 (_AFmoduleinst *i)\n{\n\tms_adpcm_data\t*d = (ms_adpcm_data *) i->modspec;\n\tint\t\tframesPerBlock;\n\n\tframesPerBlock = d->samplesPerBlock / d->track->f.channelCount;\n\n\td->track->fpos_next_frame = d->track->fpos_first_frame +\n\t\td->blockAlign * (d->track->nextfframe / framesPerBlock);\n\td->track->frames2ignore += d->framesToIgnore;\n\n\tassert(d->track->nextfframe % framesPerBlock == 0);\n}",
        "target": 1
    },
    {
        "func": "static void ima_adpcm_reset2 (_AFmoduleinst *i)\n{\n\tima_adpcm_data\t*d = (ima_adpcm_data *) i->modspec;\n\tint\t\tframesPerBlock;\n\n\tframesPerBlock = d->samplesPerBlock / d->track->f.channelCount;\n\n\td->track->fpos_next_frame = d->track->fpos_first_frame +\n\t\td->blockAlign * (d->track->nextfframe / framesPerBlock);\n\td->track->frames2ignore += d->framesToIgnore;\n\n\tassert(d->track->nextfframe % framesPerBlock == 0);\n}",
        "target": 1
    },
    {
        "func": "void _af_adpcm_decoder (uint8_t *indata, int16_t *outdata, int len,\n\tstruct adpcm_state *state)\n{\n    uint8_t *inp;\t\t/* Input buffer pointer */\n    int16_t *outp;\t\t/* output buffer pointer */\n    int sign;\t\t\t/* Current adpcm sign bit */\n    int delta;\t\t\t/* Current adpcm output value */\n    int step;\t\t\t/* Stepsize */\n    int valpred;\t\t/* Predicted value */\n    int vpdiff;\t\t\t/* Current change to valpred */\n    int index;\t\t\t/* Current step change index */\n    int inputbuffer;\t\t/* place to keep next 4-bit value */\n    int bufferstep;\t\t/* toggle between inputbuffer/input */\n\n    outp = outdata;\n    inp = indata;\n\n    valpred = state->valprev;\n    index = state->index;\n    step = stepsizeTable[index];\n\n    bufferstep = 0;\n    \n    for ( ; len > 0 ; len-- ) {\n\t\n\t/* Step 1 - get the delta value */\n\tif ( bufferstep ) {\n\t    delta = (inputbuffer >> 4) & 0xf;\n\t} else {\n\t    inputbuffer = *inp++;\n\t    delta = inputbuffer & 0xf;\n\t}\n\tbufferstep = !bufferstep;\n\n\t/* Step 2 - Find new index value (for later) */\n\tindex += indexTable[delta];\n\tif ( index < 0 ) index = 0;\n\tif ( index > 88 ) index = 88;\n\n\t/* Step 3 - Separate sign and magnitude */\n\tsign = delta & 8;\n\tdelta = delta & 7;\n\n\t/* Step 4 - Compute difference and new predicted value */\n\t/*\n\t** Computes 'vpdiff = (delta+0.5)*step/4', but see comment\n\t** in adpcm_coder.\n\t*/\n\tvpdiff = step >> 3;\n\tif ( delta & 4 ) vpdiff += step;\n\tif ( delta & 2 ) vpdiff += step>>1;\n\tif ( delta & 1 ) vpdiff += step>>2;\n\n\tif ( sign )\n\t  valpred -= vpdiff;\n\telse\n\t  valpred += vpdiff;\n\n\t/* Step 5 - clamp output value */\n\tif ( valpred > 32767 )\n\t  valpred = 32767;\n\telse if ( valpred < -32768 )\n\t  valpred = -32768;\n\n\t/* Step 6 - Update step value */\n\tstep = stepsizeTable[index];\n\n\t/* Step 7 - Output value */\n\t*outp++ = valpred;\n    }\n\n    state->valprev = valpred;\n    state->index = index;\n}",
        "target": 1
    },
    {
        "func": "static int ima_adpcm_decode_block (ima_adpcm_data *ima, uint8_t *encoded,\n\tint16_t *decoded)\n{\n\tint outputLength;\n\n\tstruct adpcm_state state;\n\n\toutputLength = ima->samplesPerBlock * sizeof (int16_t) *\n\t\tima->track->f.channelCount;\n\n\tstate.valprev = (encoded[1]<<8) | encoded[0];\n\tif (encoded[1] & 0x80)\n\t\tstate.valprev -= 0x10000;\n\n\tstate.index = encoded[2];\n\n\t*decoded++ = state.valprev;\n\n\tencoded += 4;\n\n\t_af_adpcm_decoder(encoded, decoded, ima->samplesPerBlock - 1, &state);\n\n\treturn outputLength;\n}",
        "target": 1
    },
    {
        "func": "_AFmoduleinst _af_ima_adpcm_init_decompress (_Track *track, AFvirtualfile *fh,\n\tbool seekok, bool headerless, AFframecount *chunkframes)\n{\n\t_AFmoduleinst\tret = _AFnewmodinst(&ima_adpcm_decompress);\n\tima_adpcm_data\t*d;\n\tAUpvlist\tpv;\n\tlong\t\tl;\n\n\tassert(af_ftell(fh) == track->fpos_first_frame);\n\n\td = (ima_adpcm_data *) _af_malloc(sizeof (ima_adpcm_data));\n\n\td->track = track;\n\td->fh = fh;\n\n\td->track->frames2ignore = 0;\n\td->track->fpos_next_frame = d->track->fpos_first_frame;\n\n\tpv = d->track->f.compressionParams;\n\n\tif (_af_pv_getlong(pv, _AF_SAMPLES_PER_BLOCK, &l))\n\t\td->samplesPerBlock = l;\n\telse\n\t\t_af_error(AF_BAD_CODEC_CONFIG, \"samples per block not set\");\n\n\tif (_af_pv_getlong(pv, _AF_BLOCK_SIZE, &l))\n\t\td->blockAlign = l;\n\telse\n\t\t_af_error(AF_BAD_CODEC_CONFIG, \"block size not set\");\n\n\t*chunkframes = d->samplesPerBlock / d->track->f.channelCount;\n\n\tret.modspec = d;\n\treturn ret;\n}",
        "target": 1
    },
    {
        "func": "static void ima_adpcm_reset1 (_AFmoduleinst *i)\n{\n\tima_adpcm_data\t*d = (ima_adpcm_data *) i->modspec;\n\tAFframecount\tnextTrackFrame;\n\tint\t\tframesPerBlock;\n\n\tframesPerBlock = d->samplesPerBlock / d->track->f.channelCount;\n\n\tnextTrackFrame = d->track->nextfframe;\n\td->track->nextfframe = (nextTrackFrame / framesPerBlock) *\n\t\tframesPerBlock;\n\n\td->framesToIgnore = nextTrackFrame - d->track->nextfframe;\n\t/* postroll = frames2ignore */\n}",
        "target": 1
    },
    {
        "func": "void _af_adpcm_coder (int16_t *indata, uint8_t *outdata, int len,\n\tstruct adpcm_state *state)\n{\n    int16_t *inp;\t\t/* Input buffer pointer */\n    uint8_t *outp;\t\t/* Output buffer pointer */\n    int val;\t\t\t/* Current input sample value */\n    int sign;\t\t\t/* Current adpcm sign bit */\n    int delta;\t\t\t/* Current adpcm output value */\n    int diff;\t\t\t/* Difference between val and valprev */\n    int step;\t\t\t/* Stepsize */\n    int valpred;\t\t/* Predicted output value */\n    int vpdiff;\t\t\t/* Current change to valpred */\n    int index;\t\t\t/* Current step change index */\n    int outputbuffer;\t\t/* place to keep previous 4-bit value */\n    int bufferstep;\t\t/* toggle between outputbuffer/output */\n\n    outp = outdata;\n    inp = indata;\n\n    valpred = state->valprev;\n    index = state->index;\n    step = stepsizeTable[index];\n    \n    bufferstep = 1;\n\n    for ( ; len > 0 ; len-- ) {\n\tval = *inp++;\n\n\t/* Step 1 - compute difference with previous value */\n\tdiff = val - valpred;\n\tsign = (diff < 0) ? 8 : 0;\n\tif ( sign ) diff = (-diff);\n\n\t/* Step 2 - Divide and clamp */\n\t/* Note:\n\t** This code *approximately* computes:\n\t**    delta = diff*4/step;\n\t**    vpdiff = (delta+0.5)*step/4;\n\t** but in shift step bits are dropped. The net result of this is\n\t** that even if you have fast mul/div hardware you cannot put it to\n\t** good use since the fixup would be too expensive.\n\t*/\n\tdelta = 0;\n\tvpdiff = (step >> 3);\n\t\n\tif ( diff >= step ) {\n\t    delta = 4;\n\t    diff -= step;\n\t    vpdiff += step;\n\t}\n\tstep >>= 1;\n\tif ( diff >= step  ) {\n\t    delta |= 2;\n\t    diff -= step;\n\t    vpdiff += step;\n\t}\n\tstep >>= 1;\n\tif ( diff >= step ) {\n\t    delta |= 1;\n\t    vpdiff += step;\n\t}\n\n\t/* Step 3 - Update previous value */\n\tif ( sign )\n\t  valpred -= vpdiff;\n\telse\n\t  valpred += vpdiff;\n\n\t/* Step 4 - Clamp previous value to 16 bits */\n\tif ( valpred > 32767 )\n\t  valpred = 32767;\n\telse if ( valpred < -32768 )\n\t  valpred = -32768;\n\n\t/* Step 5 - Assemble value, update index and step values */\n\tdelta |= sign;\n\t\n\tindex += indexTable[delta];\n\tif ( index < 0 ) index = 0;\n\tif ( index > 88 ) index = 88;\n\tstep = stepsizeTable[index];\n\n\t/* Step 6 - Output value */\n\tif ( bufferstep ) {\n\t    outputbuffer = delta & 0x0f;\n\t} else {\n\t    *outp++ = ((delta << 4) & 0xf0) | outputbuffer;\n\t}\n\tbufferstep = !bufferstep;\n    }\n\n    /* Output last step, if needed */\n    if ( !bufferstep )\n      *outp++ = outputbuffer;\n    \n    state->valprev = valpred;\n    state->index = index;\n}",
        "target": 1
    },
    {
        "func": "static void ima_adpcm_run_pull (_AFmoduleinst *module)\n{\n\tima_adpcm_data\t*d = (ima_adpcm_data *) module->modspec;\n\tAFframecount\tframes2read = module->outc->nframes;\n\tAFframecount\tnframes = 0;\n\tint\t\ti, framesPerBlock, blockCount;\n\tssize_t\t\tblocksRead, bytesDecoded;\n\n\tframesPerBlock = d->samplesPerBlock / d->track->f.channelCount;\n\tassert(module->outc->nframes % framesPerBlock == 0);\n\tblockCount = module->outc->nframes / framesPerBlock;\n\n\t/* Read the compressed frames. */\n\tblocksRead = af_fread(module->inc->buf, d->blockAlign, blockCount, d->fh);\n\n\t/* This condition would indicate that the file is bad. */\n\tif (blocksRead < 0)\n\t{\n\t\tif (d->track->filemodhappy)\n\t\t{\n\t\t\t_af_error(AF_BAD_READ, \"file missing data\");\n\t\t\td->track->filemodhappy = AF_FALSE;\n\t\t}\n\t}\n\n\tif (blocksRead < blockCount)\n\t\tblockCount = blocksRead;\n\n\t/* Decompress into module->outc. */\n\tfor (i=0; i<blockCount; i++)\n\t{\n\t\tbytesDecoded = ima_adpcm_decode_block(d,\n\t\t\t(uint8_t *) module->inc->buf + i * d->blockAlign,\n\t\t\t(int16_t *) module->outc->buf + i * d->samplesPerBlock);\n\n\t\tnframes += framesPerBlock;\n\t}\n\n\td->track->nextfframe += nframes;\n\n\tif (blocksRead > 0)\n\t\td->track->fpos_next_frame += blocksRead * d->blockAlign;\n\n\tassert(af_ftell(d->fh) == d->track->fpos_next_frame);\n\n\t/*\n\t\tIf we got EOF from read, then we return the actual amount read.\n\n\t\tComplain only if there should have been more frames in the file.\n\t*/\n\n\tif (d->track->totalfframes != -1 && nframes != frames2read)\n\t{\n\t\t/* Report error if we haven't already */\n\t\tif (d->track->filemodhappy)\n\t\t{\n\t\t\t_af_error(AF_BAD_READ,\n\t\t\t\t\"file missing data -- read %d frames, should be %d\",\n\t\t\t\td->track->nextfframe,\n\t\t\t\td->track->totalfframes);\n\t\t\td->track->filemodhappy = AF_FALSE;\n\t\t}\n\t}\n\n\tmodule->outc->nframes = nframes;\n}",
        "target": 1
    },
    {
        "func": "static int ms_adpcm_decode_block (ms_adpcm_data *msadpcm, uint8_t *encoded,\n\tint16_t *decoded)\n{\n\tint\t\ti, outputLength, samplesRemaining;\n\tint\t\tchannelCount;\n\tint16_t\t\t*coefficient[2];\n\tms_adpcm_state\tdecoderState[2];\n\tms_adpcm_state\t*state[2];\n\n\t/* Calculate the number of bytes needed for decoded data. */\n\toutputLength = msadpcm->samplesPerBlock * sizeof (int16_t) *\n\t\tmsadpcm->track->f.channelCount;\n\n\tchannelCount = msadpcm->track->f.channelCount;\n\n\tstate[0] = &decoderState[0];\n\tif (channelCount == 2)\n\t\tstate[1] = &decoderState[1];\n\telse\n\t\tstate[1] = &decoderState[0];\n\n\t/* Initialize predictor. */\n\tfor (i=0; i<channelCount; i++)\n\t{\n\t\tstate[i]->predictor = *encoded++;\n\t\tassert(state[i]->predictor < msadpcm->numCoefficients);\n\t}\n\n\t/* Initialize delta. */\n\tfor (i=0; i<channelCount; i++)\n\t{\n\t\tstate[i]->delta = (encoded[1]<<8) | encoded[0];\n\t\tencoded += sizeof (uint16_t);\n\t}\n\n\t/* Initialize first two samples. */\n\tfor (i=0; i<channelCount; i++)\n\t{\n\t\tstate[i]->sample1 = (encoded[1]<<8) | encoded[0];\n\t\tencoded += sizeof (uint16_t);\n\t}\n\n\tfor (i=0; i<channelCount; i++)\n\t{\n\t\tstate[i]->sample2 = (encoded[1]<<8) | encoded[0];\n\t\tencoded += sizeof (uint16_t);\n\t}\n\n\tcoefficient[0] = msadpcm->coefficients[state[0]->predictor];\n\tcoefficient[1] = msadpcm->coefficients[state[1]->predictor];\n\n\tfor (i=0; i<channelCount; i++)\n\t\t*decoded++ = state[i]->sample2;\n\n\tfor (i=0; i<channelCount; i++)\n\t\t*decoded++ = state[i]->sample1;\n\n\t/*\n\t\tThe first two samples have already been 'decoded' in\n\t\tthe block header.\n\t*/\n\tsamplesRemaining = (msadpcm->samplesPerBlock - 2) *\n\t\tmsadpcm->track->f.channelCount;\n\n\twhile (samplesRemaining > 0)\n\t{\n\t\tuint8_t code;\n\t\tint16_t newSample;\n\n\t\tcode = *encoded >> 4;\n\t\tnewSample = ms_adpcm_decode_sample(state[0], code,\n\t\t\tcoefficient[0]);\n\t\t*decoded++ = newSample;\n\n\t\tcode = *encoded & 0x0f;\n\t\tnewSample = ms_adpcm_decode_sample(state[1], code,\n\t\t\tcoefficient[1]);\n\t\t*decoded++ = newSample;\n\n\t\tencoded++;\n\t\tsamplesRemaining -= 2;\n\t}\n\n\treturn outputLength;\n}",
        "target": 1
    },
    {
        "func": "static void ms_adpcm_reset1 (_AFmoduleinst *i)\n{\n\tms_adpcm_data\t*d = (ms_adpcm_data *) i->modspec;\n\tAFframecount\tnextTrackFrame;\n\tint\t\tframesPerBlock;\n\n\tframesPerBlock = d->samplesPerBlock / d->track->f.channelCount;\n\n\tnextTrackFrame = d->track->nextfframe;\n\td->track->nextfframe = (nextTrackFrame / framesPerBlock) *\n\t\tframesPerBlock;\n\n\td->framesToIgnore = nextTrackFrame - d->track->nextfframe;\n\t/* postroll = frames2ignore */\n}",
        "target": 1
    },
    {
        "func": "static status ParseFormat (AFfilehandle filehandle, AFvirtualfile *fp,\n\tuint32_t id, size_t size)\n{\n\t_Track\t\t*track;\n\tuint16_t\tformatTag, channelCount;\n\tuint32_t\tsampleRate, averageBytesPerSecond;\n\tuint16_t\tblockAlign;\n\t_WAVEInfo\t*wave;\n\n\tassert(filehandle != NULL);\n\tassert(fp != NULL);\n\tassert(!memcmp(&id, \"fmt \", 4));\n\n\ttrack = _af_filehandle_get_track(filehandle, AF_DEFAULT_TRACK);\n\n\tassert(filehandle->formatSpecific != NULL);\n\twave = (_WAVEInfo *) filehandle->formatSpecific;\n\n\taf_read_uint16_le(&formatTag, fp);\n\taf_read_uint16_le(&channelCount, fp);\n\taf_read_uint32_le(&sampleRate, fp);\n\taf_read_uint32_le(&averageBytesPerSecond, fp);\n\taf_read_uint16_le(&blockAlign, fp);\n\n\ttrack->f.channelCount = channelCount;\n\ttrack->f.sampleRate = sampleRate;\n\ttrack->f.byteOrder = AF_BYTEORDER_LITTLEENDIAN;\n\n\t/* Default to uncompressed audio data. */\n\ttrack->f.compressionType = AF_COMPRESSION_NONE;\n\n\tswitch (formatTag)\n\t{\n\t\tcase WAVE_FORMAT_PCM:\n\t\t{\n\t\t\tuint16_t\tbitsPerSample;\n\n\t\t\taf_read_uint16_le(&bitsPerSample, fp);\n\n\t\t\ttrack->f.sampleWidth = bitsPerSample;\n\n\t\t\tif (bitsPerSample == 0 || bitsPerSample > 32)\n\t\t\t{\n\t\t\t\t_af_error(AF_BAD_WIDTH,\n\t\t\t\t\t\"bad sample width of %d bits\",\n\t\t\t\t\tbitsPerSample);\n\t\t\t\treturn AF_FAIL;\n\t\t\t}\n\n\t\t\tif (bitsPerSample <= 8)\n\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_UNSIGNED;\n\t\t\telse\n\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t}\n\t\tbreak;\n\n\t\tcase WAVE_FORMAT_MULAW:\n\t\tcase IBM_FORMAT_MULAW:\n\t\t\ttrack->f.sampleWidth = 16;\n\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t\ttrack->f.compressionType = AF_COMPRESSION_G711_ULAW;\n\t\t\tbreak;\n\n\t\tcase WAVE_FORMAT_ALAW:\n\t\tcase IBM_FORMAT_ALAW:\n\t\t\ttrack->f.sampleWidth = 16;\n\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t\ttrack->f.compressionType = AF_COMPRESSION_G711_ALAW;\n\t\t\tbreak;\n\n\t\tcase WAVE_FORMAT_IEEE_FLOAT:\n\t\t{\n\t\t\tuint16_t\tbitsPerSample;\n\n\t\t\taf_read_uint16_le(&bitsPerSample, fp);\n\n\t\t\tif (bitsPerSample == 64)\n\t\t\t{\n\t\t\t\ttrack->f.sampleWidth = 64;\n\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_DOUBLE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttrack->f.sampleWidth = 32;\n\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_FLOAT;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase WAVE_FORMAT_ADPCM:\n\t\t{\n\t\t\tuint16_t\tbitsPerSample, extraByteCount,\n\t\t\t\t\tsamplesPerBlock, numCoefficients;\n\t\t\tint\t\ti;\n\t\t\tAUpvlist\tpv;\n\t\t\tlong\t\tl;\n\t\t\tvoid\t\t*v;\n\n\t\t\tif (track->f.channelCount != 1 &&\n\t\t\t\ttrack->f.channelCount != 2)\n\t\t\t{\n\t\t\t\t_af_error(AF_BAD_CHANNELS,\n\t\t\t\t\t\"WAVE file with MS ADPCM compression \"\n\t\t\t\t\t\"must have 1 or 2 channels\");\n\t\t\t}\n\n\t\t\taf_read_uint16_le(&bitsPerSample, fp);\n\t\t\taf_read_uint16_le(&extraByteCount, fp);\n\t\t\taf_read_uint16_le(&samplesPerBlock, fp);\n\t\t\taf_read_uint16_le(&numCoefficients, fp);\n\n\t\t\t/* numCoefficients should be at least 7. */\n\t\t\tassert(numCoefficients >= 7 && numCoefficients <= 255);\n\n\t\t\tfor (i=0; i<numCoefficients; i++)\n\t\t\t{\n\t\t\t\tint16_t\ta0, a1;\n\n\t\t\t\taf_fread(&a0, 1, 2, fp);\n\t\t\t\taf_fread(&a1, 1, 2, fp);\n\n\t\t\t\ta0 = LENDIAN_TO_HOST_INT16(a0);\n\t\t\t\ta1 = LENDIAN_TO_HOST_INT16(a1);\n\n\t\t\t\twave->msadpcmCoefficients[i][0] = a0;\n\t\t\t\twave->msadpcmCoefficients[i][1] = a1;\n\t\t\t}\n\n\t\t\ttrack->f.sampleWidth = 16;\n\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t\ttrack->f.compressionType = AF_COMPRESSION_MS_ADPCM;\n\t\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n\n\t\t\t/* Create the parameter list. */\n\t\t\tpv = AUpvnew(4);\n\t\t\tAUpvsetparam(pv, 0, _AF_MS_ADPCM_NUM_COEFFICIENTS);\n\t\t\tAUpvsetvaltype(pv, 0, AU_PVTYPE_LONG);\n\t\t\tl = numCoefficients;\n\t\t\tAUpvsetval(pv, 0, &l);\n\n\t\t\tAUpvsetparam(pv, 1, _AF_MS_ADPCM_COEFFICIENTS);\n\t\t\tAUpvsetvaltype(pv, 1, AU_PVTYPE_PTR);\n\t\t\tv = wave->msadpcmCoefficients;\n\t\t\tAUpvsetval(pv, 1, &v);\n\n\t\t\tAUpvsetparam(pv, 2, _AF_SAMPLES_PER_BLOCK);\n\t\t\tAUpvsetvaltype(pv, 2, AU_PVTYPE_LONG);\n\t\t\tl = samplesPerBlock;\n\t\t\tAUpvsetval(pv, 2, &l);\n\n\t\t\tAUpvsetparam(pv, 3, _AF_BLOCK_SIZE);\n\t\t\tAUpvsetvaltype(pv, 3, AU_PVTYPE_LONG);\n\t\t\tl = blockAlign;\n\t\t\tAUpvsetval(pv, 3, &l);\n\n\t\t\ttrack->f.compressionParams = pv;\n\t\t}\n\t\tbreak;\n\n\t\tcase WAVE_FORMAT_DVI_ADPCM:\n\t\t{\n\t\t\tAUpvlist\tpv;\n\t\t\tlong\t\tl;\n\n\t\t\tuint16_t\tbitsPerSample, extraByteCount,\n\t\t\t\t\tsamplesPerBlock;\n\n\t\t\taf_read_uint16_le(&bitsPerSample, fp);\n\t\t\taf_read_uint16_le(&extraByteCount, fp);\n\t\t\taf_read_uint16_le(&samplesPerBlock, fp);\n\n\t\t\ttrack->f.sampleWidth = 16;\n\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t\ttrack->f.compressionType = AF_COMPRESSION_IMA;\n\t\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n\n\t\t\t/* Create the parameter list. */\n\t\t\tpv = AUpvnew(2);\n\t\t\tAUpvsetparam(pv, 0, _AF_SAMPLES_PER_BLOCK);\n\t\t\tAUpvsetvaltype(pv, 0, AU_PVTYPE_LONG);\n\t\t\tl = samplesPerBlock;\n\t\t\tAUpvsetval(pv, 0, &l);\n\n\t\t\tAUpvsetparam(pv, 1, _AF_BLOCK_SIZE);\n\t\t\tAUpvsetvaltype(pv, 1, AU_PVTYPE_LONG);\n\t\t\tl = blockAlign;\n\t\t\tAUpvsetval(pv, 1, &l);\n\n\t\t\ttrack->f.compressionParams = pv;\n\t\t}\n\t\tbreak;\n\n\t\tcase WAVE_FORMAT_YAMAHA_ADPCM:\n\t\tcase WAVE_FORMAT_OKI_ADPCM:\n\t\tcase WAVE_FORMAT_CREATIVE_ADPCM:\n\t\tcase IBM_FORMAT_ADPCM:\n\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"WAVE ADPCM data format 0x%x is not currently supported\", formatTag);\n\t\t\treturn AF_FAIL;\n\t\t\tbreak;\n\n\t\tcase WAVE_FORMAT_MPEG:\n\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"WAVE MPEG data format is not supported\");\n\t\t\treturn AF_FAIL;\n\t\t\tbreak;\n\n\t\tcase WAVE_FORMAT_MPEGLAYER3:\n\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"WAVE MPEG layer 3 data format is not supported\");\n\t\t\treturn AF_FAIL;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"WAVE file data format 0x%x not currently supported\", formatTag);\n\t\t\treturn AF_FAIL;\n\t\t\tbreak;\n\t}\n\n\t_af_set_sample_format(&track->f, track->f.sampleFormat, track->f.sampleWidth);\n\n\treturn AF_SUCCEED;\n}",
        "target": 1
    },
    {
        "func": "long keyctl_join_session_keyring(const char __user *_name)\n{\n\tchar *name;\n\tlong ret;\n\n\t/* fetch the name from userspace */\n\tname = NULL;\n\tif (_name) {\n\t\tname = strndup_user(_name, PAGE_SIZE);\n\t\tif (IS_ERR(name)) {\n\t\t\tret = PTR_ERR(name);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t/* join the session */\n\tret = join_session_keyring(name);\n\n error:\n\treturn ret;\n\n} /* end keyctl_join_session_keyring() */",
        "target": 1
    },
    {
        "func": "int sock_getsockopt(struct socket *sock, int level, int optname,\n\t\t    char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\n\tunion {\n\t\tint val;\n\t\tstruct linger ling;\n\t\tstruct timeval tm;\n\t} v;\n\n\tunsigned int lv = sizeof(int);\n\tint len;\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (len < 0)\n\t\treturn -EINVAL;\n\n\tswitch(optname) {\n\tcase SO_DEBUG:\n\t\tv.val = sock_flag(sk, SOCK_DBG);\n\t\tbreak;\n\n\tcase SO_DONTROUTE:\n\t\tv.val = sock_flag(sk, SOCK_LOCALROUTE);\n\t\tbreak;\n\n\tcase SO_BROADCAST:\n\t\tv.val = !!sock_flag(sk, SOCK_BROADCAST);\n\t\tbreak;\n\n\tcase SO_SNDBUF:\n\t\tv.val = sk->sk_sndbuf;\n\t\tbreak;\n\n\tcase SO_RCVBUF:\n\t\tv.val = sk->sk_rcvbuf;\n\t\tbreak;\n\n\tcase SO_REUSEADDR:\n\t\tv.val = sk->sk_reuse;\n\t\tbreak;\n\n\tcase SO_KEEPALIVE:\n\t\tv.val = !!sock_flag(sk, SOCK_KEEPOPEN);\n\t\tbreak;\n\n\tcase SO_TYPE:\n\t\tv.val = sk->sk_type;\n\t\tbreak;\n\n\tcase SO_ERROR:\n\t\tv.val = -sock_error(sk);\n\t\tif (v.val==0)\n\t\t\tv.val = xchg(&sk->sk_err_soft, 0);\n\t\tbreak;\n\n\tcase SO_OOBINLINE:\n\t\tv.val = !!sock_flag(sk, SOCK_URGINLINE);\n\t\tbreak;\n\n\tcase SO_NO_CHECK:\n\t\tv.val = sk->sk_no_check;\n\t\tbreak;\n\n\tcase SO_PRIORITY:\n\t\tv.val = sk->sk_priority;\n\t\tbreak;\n\n\tcase SO_LINGER:\n\t\tlv\t\t= sizeof(v.ling);\n\t\tv.ling.l_onoff\t= !!sock_flag(sk, SOCK_LINGER);\n\t\tv.ling.l_linger\t= sk->sk_lingertime / HZ;\n\t\tbreak;\n\n\tcase SO_BSDCOMPAT:\n\t\tsock_warn_obsolete_bsdism(\"getsockopt\");\n\t\tbreak;\n\n\tcase SO_TIMESTAMP:\n\t\tv.val = sock_flag(sk, SOCK_RCVTSTAMP) &&\n\t\t\t\t!sock_flag(sk, SOCK_RCVTSTAMPNS);\n\t\tbreak;\n\n\tcase SO_TIMESTAMPNS:\n\t\tv.val = sock_flag(sk, SOCK_RCVTSTAMPNS);\n\t\tbreak;\n\n\tcase SO_RCVTIMEO:\n\t\tlv=sizeof(struct timeval);\n\t\tif (sk->sk_rcvtimeo == MAX_SCHEDULE_TIMEOUT) {\n\t\t\tv.tm.tv_sec = 0;\n\t\t\tv.tm.tv_usec = 0;\n\t\t} else {\n\t\t\tv.tm.tv_sec = sk->sk_rcvtimeo / HZ;\n\t\t\tv.tm.tv_usec = ((sk->sk_rcvtimeo % HZ) * 1000000) / HZ;\n\t\t}\n\t\tbreak;\n\n\tcase SO_SNDTIMEO:\n\t\tlv=sizeof(struct timeval);\n\t\tif (sk->sk_sndtimeo == MAX_SCHEDULE_TIMEOUT) {\n\t\t\tv.tm.tv_sec = 0;\n\t\t\tv.tm.tv_usec = 0;\n\t\t} else {\n\t\t\tv.tm.tv_sec = sk->sk_sndtimeo / HZ;\n\t\t\tv.tm.tv_usec = ((sk->sk_sndtimeo % HZ) * 1000000) / HZ;\n\t\t}\n\t\tbreak;\n\n\tcase SO_RCVLOWAT:\n\t\tv.val = sk->sk_rcvlowat;\n\t\tbreak;\n\n\tcase SO_SNDLOWAT:\n\t\tv.val=1;\n\t\tbreak;\n\n\tcase SO_PASSCRED:\n\t\tv.val = test_bit(SOCK_PASSCRED, &sock->flags) ? 1 : 0;\n\t\tbreak;\n\n\tcase SO_PEERCRED:\n\t\tif (len > sizeof(sk->sk_peercred))\n\t\t\tlen = sizeof(sk->sk_peercred);\n\t\tif (copy_to_user(optval, &sk->sk_peercred, len))\n\t\t\treturn -EFAULT;\n\t\tgoto lenout;\n\n\tcase SO_PEERNAME:\n\t{\n\t\tchar address[128];\n\n\t\tif (sock->ops->getname(sock, (struct sockaddr *)address, &lv, 2))\n\t\t\treturn -ENOTCONN;\n\t\tif (lv < len)\n\t\t\treturn -EINVAL;\n\t\tif (copy_to_user(optval, address, len))\n\t\t\treturn -EFAULT;\n\t\tgoto lenout;\n\t}\n\n\t/* Dubious BSD thing... Probably nobody even uses it, but\n\t * the UNIX standard wants it for whatever reason... -DaveM\n\t */\n\tcase SO_ACCEPTCONN:\n\t\tv.val = sk->sk_state == TCP_LISTEN;\n\t\tbreak;\n\n\tcase SO_PASSSEC:\n\t\tv.val = test_bit(SOCK_PASSSEC, &sock->flags) ? 1 : 0;\n\t\tbreak;\n\n\tcase SO_PEERSEC:\n\t\treturn security_socket_getpeersec_stream(sock, optval, optlen, len);\n\n\tcase SO_MARK:\n\t\tv.val = sk->sk_mark;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\n\tif (len > lv)\n\t\tlen = lv;\n\tif (copy_to_user(optval, &v, len))\n\t\treturn -EFAULT;\nlenout:\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "int sock_getsockopt(struct socket *sock, int level, int optname,\n\t\t    char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\n\tunion {\n\t\tint val;\n\t\tstruct linger ling;\n\t\tstruct timeval tm;\n\t} v;\n\n\tunsigned int lv = sizeof(int);\n\tint len;\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (len < 0)\n\t\treturn -EINVAL;\n\n\tv.val = 0;\n\n\tswitch(optname) {\n\tcase SO_DEBUG:\n\t\tv.val = sock_flag(sk, SOCK_DBG);\n\t\tbreak;\n\n\tcase SO_DONTROUTE:\n\t\tv.val = sock_flag(sk, SOCK_LOCALROUTE);\n\t\tbreak;\n\n\tcase SO_BROADCAST:\n\t\tv.val = !!sock_flag(sk, SOCK_BROADCAST);\n\t\tbreak;\n\n\tcase SO_SNDBUF:\n\t\tv.val = sk->sk_sndbuf;\n\t\tbreak;\n\n\tcase SO_RCVBUF:\n\t\tv.val = sk->sk_rcvbuf;\n\t\tbreak;\n\n\tcase SO_REUSEADDR:\n\t\tv.val = sk->sk_reuse;\n\t\tbreak;\n\n\tcase SO_KEEPALIVE:\n\t\tv.val = !!sock_flag(sk, SOCK_KEEPOPEN);\n\t\tbreak;\n\n\tcase SO_TYPE:\n\t\tv.val = sk->sk_type;\n\t\tbreak;\n\n\tcase SO_ERROR:\n\t\tv.val = -sock_error(sk);\n\t\tif (v.val==0)\n\t\t\tv.val = xchg(&sk->sk_err_soft, 0);\n\t\tbreak;\n\n\tcase SO_OOBINLINE:\n\t\tv.val = !!sock_flag(sk, SOCK_URGINLINE);\n\t\tbreak;\n\n\tcase SO_NO_CHECK:\n\t\tv.val = sk->sk_no_check;\n\t\tbreak;\n\n\tcase SO_PRIORITY:\n\t\tv.val = sk->sk_priority;\n\t\tbreak;\n\n\tcase SO_LINGER:\n\t\tlv\t\t= sizeof(v.ling);\n\t\tv.ling.l_onoff\t= !!sock_flag(sk, SOCK_LINGER);\n\t\tv.ling.l_linger\t= sk->sk_lingertime / HZ;\n\t\tbreak;\n\n\tcase SO_BSDCOMPAT:\n\t\tsock_warn_obsolete_bsdism(\"getsockopt\");\n\t\tbreak;\n\n\tcase SO_TIMESTAMP:\n\t\tv.val = sock_flag(sk, SOCK_RCVTSTAMP) &&\n\t\t\t\t!sock_flag(sk, SOCK_RCVTSTAMPNS);\n\t\tbreak;\n\n\tcase SO_TIMESTAMPNS:\n\t\tv.val = sock_flag(sk, SOCK_RCVTSTAMPNS);\n\t\tbreak;\n\n\tcase SO_RCVTIMEO:\n\t\tlv=sizeof(struct timeval);\n\t\tif (sk->sk_rcvtimeo == MAX_SCHEDULE_TIMEOUT) {\n\t\t\tv.tm.tv_sec = 0;\n\t\t\tv.tm.tv_usec = 0;\n\t\t} else {\n\t\t\tv.tm.tv_sec = sk->sk_rcvtimeo / HZ;\n\t\t\tv.tm.tv_usec = ((sk->sk_rcvtimeo % HZ) * 1000000) / HZ;\n\t\t}\n\t\tbreak;\n\n\tcase SO_SNDTIMEO:\n\t\tlv=sizeof(struct timeval);\n\t\tif (sk->sk_sndtimeo == MAX_SCHEDULE_TIMEOUT) {\n\t\t\tv.tm.tv_sec = 0;\n\t\t\tv.tm.tv_usec = 0;\n\t\t} else {\n\t\t\tv.tm.tv_sec = sk->sk_sndtimeo / HZ;\n\t\t\tv.tm.tv_usec = ((sk->sk_sndtimeo % HZ) * 1000000) / HZ;\n\t\t}\n\t\tbreak;\n\n\tcase SO_RCVLOWAT:\n\t\tv.val = sk->sk_rcvlowat;\n\t\tbreak;\n\n\tcase SO_SNDLOWAT:\n\t\tv.val=1;\n\t\tbreak;\n\n\tcase SO_PASSCRED:\n\t\tv.val = test_bit(SOCK_PASSCRED, &sock->flags) ? 1 : 0;\n\t\tbreak;\n\n\tcase SO_PEERCRED:\n\t\tif (len > sizeof(sk->sk_peercred))\n\t\t\tlen = sizeof(sk->sk_peercred);\n\t\tif (copy_to_user(optval, &sk->sk_peercred, len))\n\t\t\treturn -EFAULT;\n\t\tgoto lenout;\n\n\tcase SO_PEERNAME:\n\t{\n\t\tchar address[128];\n\n\t\tif (sock->ops->getname(sock, (struct sockaddr *)address, &lv, 2))\n\t\t\treturn -ENOTCONN;\n\t\tif (lv < len)\n\t\t\treturn -EINVAL;\n\t\tif (copy_to_user(optval, address, len))\n\t\t\treturn -EFAULT;\n\t\tgoto lenout;\n\t}\n\n\t/* Dubious BSD thing... Probably nobody even uses it, but\n\t * the UNIX standard wants it for whatever reason... -DaveM\n\t */\n\tcase SO_ACCEPTCONN:\n\t\tv.val = sk->sk_state == TCP_LISTEN;\n\t\tbreak;\n\n\tcase SO_PASSSEC:\n\t\tv.val = test_bit(SOCK_PASSSEC, &sock->flags) ? 1 : 0;\n\t\tbreak;\n\n\tcase SO_PEERSEC:\n\t\treturn security_socket_getpeersec_stream(sock, optval, optlen, len);\n\n\tcase SO_MARK:\n\t\tv.val = sk->sk_mark;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\n\tif (len > lv)\n\t\tlen = lv;\n\tif (copy_to_user(optval, &v, len))\n\t\treturn -EFAULT;\nlenout:\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static int skfp_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\n{\n\tstruct s_smc *smc = netdev_priv(dev);\n\tskfddi_priv *lp = &smc->os;\n\tstruct s_skfp_ioctl ioc;\n\tint status = 0;\n\n\tif (copy_from_user(&ioc, rq->ifr_data, sizeof(struct s_skfp_ioctl)))\n\t\treturn -EFAULT;\n\n\tswitch (ioc.cmd) {\n\tcase SKFP_GET_STATS:\t/* Get the driver statistics */\n\t\tioc.len = sizeof(lp->MacStat);\n\t\tstatus = copy_to_user(ioc.data, skfp_ctl_get_stats(dev), ioc.len)\n\t\t\t\t? -EFAULT : 0;\n\t\tbreak;\n\tcase SKFP_CLR_STATS:\t/* Zero out the driver statistics */\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\tmemset(&lp->MacStat, 0, sizeof(lp->MacStat));\n\t\t} else {\n\t\t\tstatus = -EPERM;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tprintk(\"ioctl for %s: unknow cmd: %04x\\n\", dev->name, ioc.cmd);\n\t\tstatus = -EOPNOTSUPP;\n\n\t}\t\t\t// switch\n\n\treturn status;\n}\t\t\t\t// skfp_ioctl",
        "target": 1
    },
    {
        "func": "int ext4_group_add(struct super_block *sb, struct ext4_new_group_data *input)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tint reserved_gdb = ext4_bg_has_super(sb, input->group) ?\n\t\tle16_to_cpu(es->s_reserved_gdt_blocks) : 0;\n\tstruct buffer_head *primary = NULL;\n\tstruct ext4_group_desc *gdp;\n\tstruct inode *inode = NULL;\n\thandle_t *handle;\n\tint gdb_off, gdb_num;\n\tint num_grp_locked = 0;\n\tint err, err2;\n\n\tgdb_num = input->group / EXT4_DESC_PER_BLOCK(sb);\n\tgdb_off = input->group % EXT4_DESC_PER_BLOCK(sb);\n\n\tif (gdb_off == 0 && !EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT4_FEATURE_RO_COMPAT_SPARSE_SUPER)) {\n\t\text4_warning(sb, __func__,\n\t\t\t     \"Can't resize non-sparse filesystem further\");\n\t\treturn -EPERM;\n\t}\n\n\tif (ext4_blocks_count(es) + input->blocks_count <\n\t    ext4_blocks_count(es)) {\n\t\text4_warning(sb, __func__, \"blocks_count overflow\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (le32_to_cpu(es->s_inodes_count) + EXT4_INODES_PER_GROUP(sb) <\n\t    le32_to_cpu(es->s_inodes_count)) {\n\t\text4_warning(sb, __func__, \"inodes_count overflow\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (reserved_gdb || gdb_off == 0) {\n\t\tif (!EXT4_HAS_COMPAT_FEATURE(sb,\n\t\t\t\t\t     EXT4_FEATURE_COMPAT_RESIZE_INODE)\n\t\t    || !le16_to_cpu(es->s_reserved_gdt_blocks)) {\n\t\t\text4_warning(sb, __func__,\n\t\t\t\t     \"No reserved GDT blocks, can't resize\");\n\t\t\treturn -EPERM;\n\t\t}\n\t\tinode = ext4_iget(sb, EXT4_RESIZE_INO);\n\t\tif (IS_ERR(inode)) {\n\t\t\text4_warning(sb, __func__,\n\t\t\t\t     \"Error opening resize inode\");\n\t\t\treturn PTR_ERR(inode);\n\t\t}\n\t}\n\n\n\tif ((err = verify_group_input(sb, input)))\n\t\tgoto exit_put;\n\n\tif ((err = setup_new_group_blocks(sb, input)))\n\t\tgoto exit_put;\n\n\t/*\n\t * We will always be modifying at least the superblock and a GDT\n\t * block.  If we are adding a group past the last current GDT block,\n\t * we will also modify the inode and the dindirect block.  If we\n\t * are adding a group with superblock/GDT backups  we will also\n\t * modify each of the reserved GDT dindirect blocks.\n\t */\n\thandle = ext4_journal_start_sb(sb,\n\t\t\t\t       ext4_bg_has_super(sb, input->group) ?\n\t\t\t\t       3 + reserved_gdb : 4);\n\tif (IS_ERR(handle)) {\n\t\terr = PTR_ERR(handle);\n\t\tgoto exit_put;\n\t}\n\n\tlock_super(sb);\n\tif (input->group != sbi->s_groups_count) {\n\t\text4_warning(sb, __func__,\n\t\t\t     \"multiple resizers run on filesystem!\");\n\t\terr = -EBUSY;\n\t\tgoto exit_journal;\n\t}\n\n\tif ((err = ext4_journal_get_write_access(handle, sbi->s_sbh)))\n\t\tgoto exit_journal;\n\n        /*\n         * We will only either add reserved group blocks to a backup group\n         * or remove reserved blocks for the first group in a new group block.\n         * Doing both would be mean more complex code, and sane people don't\n         * use non-sparse filesystems anymore.  This is already checked above.\n         */\n\tif (gdb_off) {\n\t\tprimary = sbi->s_group_desc[gdb_num];\n\t\tif ((err = ext4_journal_get_write_access(handle, primary)))\n\t\t\tgoto exit_journal;\n\n\t\tif (reserved_gdb && ext4_bg_num_gdb(sb, input->group) &&\n\t\t    (err = reserve_backup_gdb(handle, inode, input)))\n\t\t\tgoto exit_journal;\n\t} else if ((err = add_new_gdb(handle, inode, input, &primary)))\n\t\tgoto exit_journal;\n\n        /*\n         * OK, now we've set up the new group.  Time to make it active.\n         *\n         * Current kernels don't lock all allocations via lock_super(),\n         * so we have to be safe wrt. concurrent accesses the group\n         * data.  So we need to be careful to set all of the relevant\n         * group descriptor data etc. *before* we enable the group.\n         *\n         * The key field here is sbi->s_groups_count: as long as\n         * that retains its old value, nobody is going to access the new\n         * group.\n         *\n         * So first we update all the descriptor metadata for the new\n         * group; then we update the total disk blocks count; then we\n         * update the groups count to enable the group; then finally we\n         * update the free space counts so that the system can start\n         * using the new disk blocks.\n         */\n\n\tnum_grp_locked = ext4_mb_get_buddy_cache_lock(sb, input->group);\n\t/* Update group descriptor block for new group */\n\tgdp = (struct ext4_group_desc *)((char *)primary->b_data +\n\t\t\t\t\t gdb_off * EXT4_DESC_SIZE(sb));\n\n\text4_block_bitmap_set(sb, gdp, input->block_bitmap); /* LV FIXME */\n\text4_inode_bitmap_set(sb, gdp, input->inode_bitmap); /* LV FIXME */\n\text4_inode_table_set(sb, gdp, input->inode_table); /* LV FIXME */\n\text4_free_blks_set(sb, gdp, input->free_blocks_count);\n\text4_free_inodes_set(sb, gdp, EXT4_INODES_PER_GROUP(sb));\n\tgdp->bg_flags |= cpu_to_le16(EXT4_BG_INODE_ZEROED);\n\tgdp->bg_checksum = ext4_group_desc_csum(sbi, input->group, gdp);\n\n\t/*\n\t * We can allocate memory for mb_alloc based on the new group\n\t * descriptor\n\t */\n\terr = ext4_mb_add_groupinfo(sb, input->group, gdp);\n\tif (err) {\n\t\text4_mb_put_buddy_cache_lock(sb, input->group, num_grp_locked);\n\t\tgoto exit_journal;\n\t}\n\n\t/*\n\t * Make the new blocks and inodes valid next.  We do this before\n\t * increasing the group count so that once the group is enabled,\n\t * all of its blocks and inodes are already valid.\n\t *\n\t * We always allocate group-by-group, then block-by-block or\n\t * inode-by-inode within a group, so enabling these\n\t * blocks/inodes before the group is live won't actually let us\n\t * allocate the new space yet.\n\t */\n\text4_blocks_count_set(es, ext4_blocks_count(es) +\n\t\tinput->blocks_count);\n\tle32_add_cpu(&es->s_inodes_count, EXT4_INODES_PER_GROUP(sb));\n\n\t/*\n\t * We need to protect s_groups_count against other CPUs seeing\n\t * inconsistent state in the superblock.\n\t *\n\t * The precise rules we use are:\n\t *\n\t * * Writers of s_groups_count *must* hold lock_super\n\t * AND\n\t * * Writers must perform a smp_wmb() after updating all dependent\n\t *   data and before modifying the groups count\n\t *\n\t * * Readers must hold lock_super() over the access\n\t * OR\n\t * * Readers must perform an smp_rmb() after reading the groups count\n\t *   and before reading any dependent data.\n\t *\n\t * NB. These rules can be relaxed when checking the group count\n\t * while freeing data, as we can only allocate from a block\n\t * group after serialising against the group count, and we can\n\t * only then free after serialising in turn against that\n\t * allocation.\n\t */\n\tsmp_wmb();\n\n\t/* Update the global fs size fields */\n\tsbi->s_groups_count++;\n\text4_mb_put_buddy_cache_lock(sb, input->group, num_grp_locked);\n\n\text4_handle_dirty_metadata(handle, NULL, primary);\n\n\t/* Update the reserved block counts only once the new group is\n\t * active. */\n\text4_r_blocks_count_set(es, ext4_r_blocks_count(es) +\n\t\tinput->reserved_blocks);\n\n\t/* Update the free space counts */\n\tpercpu_counter_add(&sbi->s_freeblocks_counter,\n\t\t\t   input->free_blocks_count);\n\tpercpu_counter_add(&sbi->s_freeinodes_counter,\n\t\t\t   EXT4_INODES_PER_GROUP(sb));\n\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_FLEX_BG)) {\n\t\text4_group_t flex_group;\n\t\tflex_group = ext4_flex_group(sbi, input->group);\n\t\tsbi->s_flex_groups[flex_group].free_blocks +=\n\t\t\tinput->free_blocks_count;\n\t\tsbi->s_flex_groups[flex_group].free_inodes +=\n\t\t\tEXT4_INODES_PER_GROUP(sb);\n\t}\n\n\text4_handle_dirty_metadata(handle, NULL, sbi->s_sbh);\n\tsb->s_dirt = 1;\n\nexit_journal:\n\tunlock_super(sb);\n\tif ((err2 = ext4_journal_stop(handle)) && !err)\n\t\terr = err2;\n\tif (!err) {\n\t\tupdate_backups(sb, sbi->s_sbh->b_blocknr, (char *)es,\n\t\t\t       sizeof(struct ext4_super_block));\n\t\tupdate_backups(sb, primary->b_blocknr, primary->b_data,\n\t\t\t       primary->b_size);\n\t}\nexit_put:\n\tiput(inode);\n\treturn err;\n} /* ext4_group_add */",
        "target": 1
    },
    {
        "func": "static int make_indexed_dir(handle_t *handle, struct dentry *dentry,\n\t\t\t    struct inode *inode, struct buffer_head *bh)\n{\n\tstruct inode\t*dir = dentry->d_parent->d_inode;\n\tconst char\t*name = dentry->d_name.name;\n\tint\t\tnamelen = dentry->d_name.len;\n\tstruct buffer_head *bh2;\n\tstruct dx_root\t*root;\n\tstruct dx_frame\tframes[2], *frame;\n\tstruct dx_entry *entries;\n\tstruct ext4_dir_entry_2\t*de, *de2;\n\tchar\t\t*data1, *top;\n\tunsigned\tlen;\n\tint\t\tretval;\n\tunsigned\tblocksize;\n\tstruct dx_hash_info hinfo;\n\text4_lblk_t  block;\n\tstruct fake_dirent *fde;\n\n\tblocksize =  dir->i_sb->s_blocksize;\n\tdxtrace(printk(KERN_DEBUG \"Creating index\\n\"));\n\tretval = ext4_journal_get_write_access(handle, bh);\n\tif (retval) {\n\t\text4_std_error(dir->i_sb, retval);\n\t\tbrelse(bh);\n\t\treturn retval;\n\t}\n\troot = (struct dx_root *) bh->b_data;\n\n\tbh2 = ext4_append(handle, dir, &block, &retval);\n\tif (!(bh2)) {\n\t\tbrelse(bh);\n\t\treturn retval;\n\t}\n\tEXT4_I(dir)->i_flags |= EXT4_INDEX_FL;\n\tdata1 = bh2->b_data;\n\n\t/* The 0th block becomes the root, move the dirents out */\n\tfde = &root->dotdot;\n\tde = (struct ext4_dir_entry_2 *)((char *)fde +\n\t\text4_rec_len_from_disk(fde->rec_len));\n\tlen = ((char *) root) + blocksize - (char *) de;\n\tmemcpy (data1, de, len);\n\tde = (struct ext4_dir_entry_2 *) data1;\n\ttop = data1 + len;\n\twhile ((char *)(de2 = ext4_next_entry(de)) < top)\n\t\tde = de2;\n\tde->rec_len = ext4_rec_len_to_disk(data1 + blocksize - (char *) de);\n\t/* Initialize the root; the dot dirents already exist */\n\tde = (struct ext4_dir_entry_2 *) (&root->dotdot);\n\tde->rec_len = ext4_rec_len_to_disk(blocksize - EXT4_DIR_REC_LEN(2));\n\tmemset (&root->info, 0, sizeof(root->info));\n\troot->info.info_length = sizeof(root->info);\n\troot->info.hash_version = EXT4_SB(dir->i_sb)->s_def_hash_version;\n\tentries = root->entries;\n\tdx_set_block(entries, 1);\n\tdx_set_count(entries, 1);\n\tdx_set_limit(entries, dx_root_limit(dir, sizeof(root->info)));\n\n\t/* Initialize as for dx_probe */\n\thinfo.hash_version = root->info.hash_version;\n\tif (hinfo.hash_version <= DX_HASH_TEA)\n\t\thinfo.hash_version += EXT4_SB(dir->i_sb)->s_hash_unsigned;\n\thinfo.seed = EXT4_SB(dir->i_sb)->s_hash_seed;\n\text4fs_dirhash(name, namelen, &hinfo);\n\tframe = frames;\n\tframe->entries = entries;\n\tframe->at = entries;\n\tframe->bh = bh;\n\tbh = bh2;\n\tde = do_split(handle,dir, &bh, frame, &hinfo, &retval);\n\tdx_release (frames);\n\tif (!(de))\n\t\treturn retval;\n\n\treturn add_dirent_to_buf(handle, dentry, inode, de, bh);\n}",
        "target": 1
    },
    {
        "func": "static int ext4_block_to_path(struct inode *inode,\n\t\t\text4_lblk_t i_block,\n\t\t\text4_lblk_t offsets[4], int *boundary)\n{\n\tint ptrs = EXT4_ADDR_PER_BLOCK(inode->i_sb);\n\tint ptrs_bits = EXT4_ADDR_PER_BLOCK_BITS(inode->i_sb);\n\tconst long direct_blocks = EXT4_NDIR_BLOCKS,\n\t\tindirect_blocks = ptrs,\n\t\tdouble_blocks = (1 << (ptrs_bits * 2));\n\tint n = 0;\n\tint final = 0;\n\n\tif (i_block < 0) {\n\t\text4_warning(inode->i_sb, \"ext4_block_to_path\", \"block < 0\");\n\t} else if (i_block < direct_blocks) {\n\t\toffsets[n++] = i_block;\n\t\tfinal = direct_blocks;\n\t} else if ((i_block -= direct_blocks) < indirect_blocks) {\n\t\toffsets[n++] = EXT4_IND_BLOCK;\n\t\toffsets[n++] = i_block;\n\t\tfinal = ptrs;\n\t} else if ((i_block -= indirect_blocks) < double_blocks) {\n\t\toffsets[n++] = EXT4_DIND_BLOCK;\n\t\toffsets[n++] = i_block >> ptrs_bits;\n\t\toffsets[n++] = i_block & (ptrs - 1);\n\t\tfinal = ptrs;\n\t} else if (((i_block -= double_blocks) >> (ptrs_bits * 2)) < ptrs) {\n\t\toffsets[n++] = EXT4_TIND_BLOCK;\n\t\toffsets[n++] = i_block >> (ptrs_bits * 2);\n\t\toffsets[n++] = (i_block >> ptrs_bits) & (ptrs - 1);\n\t\toffsets[n++] = i_block & (ptrs - 1);\n\t\tfinal = ptrs;\n\t} else {\n\t\text4_warning(inode->i_sb, \"ext4_block_to_path\",\n\t\t\t\t\"block %lu > max\",\n\t\t\t\ti_block + direct_blocks +\n\t\t\t\tindirect_blocks + double_blocks);\n\t}\n\tif (boundary)\n\t\t*boundary = final - 1 - (i_block & (ptrs - 1));\n\treturn n;\n}",
        "target": 1
    },
    {
        "func": "\nstatic inline loff_t ext4_isize(struct ext4_inode *raw_inode)\n{\n\treturn ((loff_t)le32_to_cpu(raw_inode->i_size_high) << 32) |\n\t\tle32_to_cpu(raw_inode->i_size_lo);",
        "target": 1
    },
    {
        "func": "\t\t\t\t__acquires(kernel_lock)\n\n{\n\tstruct buffer_head *bh;\n\tstruct ext4_super_block *es = NULL;\n\tstruct ext4_sb_info *sbi;\n\text4_fsblk_t block;\n\text4_fsblk_t sb_block = get_sb_block(&data);\n\text4_fsblk_t logical_sb_block;\n\tunsigned long offset = 0;\n\tunsigned long journal_devnum = 0;\n\tunsigned long def_mount_opts;\n\tstruct inode *root;\n\tchar *cp;\n\tconst char *descr;\n\tint ret = -EINVAL;\n\tint blocksize;\n\tint db_count;\n\tint i;\n\tint needs_recovery, has_huge_files;\n\tint features;\n\t__u64 blocks_count;\n\tint err;\n\tunsigned int journal_ioprio = DEFAULT_JOURNAL_IOPRIO;\n\n\tsbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\tsb->s_fs_info = sbi;\n\tsbi->s_mount_opt = 0;\n\tsbi->s_resuid = EXT4_DEF_RESUID;\n\tsbi->s_resgid = EXT4_DEF_RESGID;\n\tsbi->s_inode_readahead_blks = EXT4_DEF_INODE_READAHEAD_BLKS;\n\tsbi->s_sb_block = sb_block;\n\n\tunlock_kernel();\n\n\t/* Cleanup superblock name */\n\tfor (cp = sb->s_id; (cp = strchr(cp, '/'));)\n\t\t*cp = '!';\n\n\tblocksize = sb_min_blocksize(sb, EXT4_MIN_BLOCK_SIZE);\n\tif (!blocksize) {\n\t\tprintk(KERN_ERR \"EXT4-fs: unable to set blocksize\\n\");\n\t\tgoto out_fail;\n\t}\n\n\t/*\n\t * The ext4 superblock will not be buffer aligned for other than 1kB\n\t * block sizes.  We need to calculate the offset from buffer start.\n\t */\n\tif (blocksize != EXT4_MIN_BLOCK_SIZE) {\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t} else {\n\t\tlogical_sb_block = sb_block;\n\t}\n\n\tif (!(bh = sb_bread(sb, logical_sb_block))) {\n\t\tprintk(KERN_ERR \"EXT4-fs: unable to read superblock\\n\");\n\t\tgoto out_fail;\n\t}\n\t/*\n\t * Note: s_es must be initialized as soon as possible because\n\t *       some ext4 macro-instructions depend on its value\n\t */\n\tes = (struct ext4_super_block *) (((char *)bh->b_data) + offset);\n\tsbi->s_es = es;\n\tsb->s_magic = le16_to_cpu(es->s_magic);\n\tif (sb->s_magic != EXT4_SUPER_MAGIC)\n\t\tgoto cantfind_ext4;\n\n\t/* Set defaults before we parse the mount options */\n\tdef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n\tif (def_mount_opts & EXT4_DEFM_DEBUG)\n\t\tset_opt(sbi->s_mount_opt, DEBUG);\n\tif (def_mount_opts & EXT4_DEFM_BSDGROUPS)\n\t\tset_opt(sbi->s_mount_opt, GRPID);\n\tif (def_mount_opts & EXT4_DEFM_UID16)\n\t\tset_opt(sbi->s_mount_opt, NO_UID32);\n#ifdef CONFIG_EXT4_FS_XATTR\n\tif (def_mount_opts & EXT4_DEFM_XATTR_USER)\n\t\tset_opt(sbi->s_mount_opt, XATTR_USER);\n#endif\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\tif (def_mount_opts & EXT4_DEFM_ACL)\n\t\tset_opt(sbi->s_mount_opt, POSIX_ACL);\n#endif\n\tif ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_DATA)\n\t\tsbi->s_mount_opt |= EXT4_MOUNT_JOURNAL_DATA;\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_ORDERED)\n\t\tsbi->s_mount_opt |= EXT4_MOUNT_ORDERED_DATA;\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_WBACK)\n\t\tsbi->s_mount_opt |= EXT4_MOUNT_WRITEBACK_DATA;\n\n\tif (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_PANIC)\n\t\tset_opt(sbi->s_mount_opt, ERRORS_PANIC);\n\telse if (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_CONTINUE)\n\t\tset_opt(sbi->s_mount_opt, ERRORS_CONT);\n\telse\n\t\tset_opt(sbi->s_mount_opt, ERRORS_RO);\n\n\tsbi->s_resuid = le16_to_cpu(es->s_def_resuid);\n\tsbi->s_resgid = le16_to_cpu(es->s_def_resgid);\n\tsbi->s_commit_interval = JBD2_DEFAULT_MAX_COMMIT_AGE * HZ;\n\tsbi->s_min_batch_time = EXT4_DEF_MIN_BATCH_TIME;\n\tsbi->s_max_batch_time = EXT4_DEF_MAX_BATCH_TIME;\n\n\tset_opt(sbi->s_mount_opt, RESERVATION);\n\tset_opt(sbi->s_mount_opt, BARRIER);\n\n\t/*\n\t * turn on extents feature by default in ext4 filesystem\n\t * only if feature flag already set by mkfs or tune2fs.\n\t * Use -o noextents to turn it off\n\t */\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_EXTENTS))\n\t\tset_opt(sbi->s_mount_opt, EXTENTS);\n\telse\n\t\text4_warning(sb, __func__,\n\t\t\t\"extents feature not enabled on this filesystem, \"\n\t\t\t\"use tune2fs.\");\n\n\t/*\n\t * enable delayed allocation by default\n\t * Use -o nodelalloc to turn it off\n\t */\n\tset_opt(sbi->s_mount_opt, DELALLOC);\n\n\n\tif (!parse_options((char *) data, sb, &journal_devnum,\n\t\t\t   &journal_ioprio, NULL, 0))\n\t\tgoto failed_mount;\n\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t((sbi->s_mount_opt & EXT4_MOUNT_POSIX_ACL) ? MS_POSIXACL : 0);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV &&\n\t    (EXT4_HAS_COMPAT_FEATURE(sb, ~0U) ||\n\t     EXT4_HAS_RO_COMPAT_FEATURE(sb, ~0U) ||\n\t     EXT4_HAS_INCOMPAT_FEATURE(sb, ~0U)))\n\t\tprintk(KERN_WARNING\n\t\t       \"EXT4-fs warning: feature flags set on rev 0 fs, \"\n\t\t       \"running e2fsck is recommended\\n\");\n\n\t/*\n\t * Check feature flags regardless of the revision level, since we\n\t * previously didn't change the revision level when setting the flags,\n\t * so there is a chance incompat flags are set on a rev 0 filesystem.\n\t */\n\tfeatures = EXT4_HAS_INCOMPAT_FEATURE(sb, ~EXT4_FEATURE_INCOMPAT_SUPP);\n\tif (features) {\n\t\tprintk(KERN_ERR \"EXT4-fs: %s: couldn't mount because of \"\n\t\t       \"unsupported optional features (%x).\\n\", sb->s_id,\n\t\t\t(le32_to_cpu(EXT4_SB(sb)->s_es->s_feature_incompat) &\n\t\t\t~EXT4_FEATURE_INCOMPAT_SUPP));\n\t\tgoto failed_mount;\n\t}\n\tfeatures = EXT4_HAS_RO_COMPAT_FEATURE(sb, ~EXT4_FEATURE_RO_COMPAT_SUPP);\n\tif (!(sb->s_flags & MS_RDONLY) && features) {\n\t\tprintk(KERN_ERR \"EXT4-fs: %s: couldn't mount RDWR because of \"\n\t\t       \"unsupported optional features (%x).\\n\", sb->s_id,\n\t\t\t(le32_to_cpu(EXT4_SB(sb)->s_es->s_feature_ro_compat) &\n\t\t\t~EXT4_FEATURE_RO_COMPAT_SUPP));\n\t\tgoto failed_mount;\n\t}\n\thas_huge_files = EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t    EXT4_FEATURE_RO_COMPAT_HUGE_FILE);\n\tif (has_huge_files) {\n\t\t/*\n\t\t * Large file size enabled file system can only be\n\t\t * mount if kernel is build with CONFIG_LBD\n\t\t */\n\t\tif (sizeof(root->i_blocks) < sizeof(u64) &&\n\t\t\t\t!(sb->s_flags & MS_RDONLY)) {\n\t\t\tprintk(KERN_ERR \"EXT4-fs: %s: Filesystem with huge \"\n\t\t\t\t\t\"files cannot be mounted read-write \"\n\t\t\t\t\t\"without CONFIG_LBD.\\n\", sb->s_id);\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\tblocksize = BLOCK_SIZE << le32_to_cpu(es->s_log_block_size);\n\n\tif (blocksize < EXT4_MIN_BLOCK_SIZE ||\n\t    blocksize > EXT4_MAX_BLOCK_SIZE) {\n\t\tprintk(KERN_ERR\n\t\t       \"EXT4-fs: Unsupported filesystem blocksize %d on %s.\\n\",\n\t\t       blocksize, sb->s_id);\n\t\tgoto failed_mount;\n\t}\n\n\tif (sb->s_blocksize != blocksize) {\n\n\t\t/* Validate the filesystem blocksize */\n\t\tif (!sb_set_blocksize(sb, blocksize)) {\n\t\t\tprintk(KERN_ERR \"EXT4-fs: bad block size %d.\\n\",\n\t\t\t\t\tblocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t\tbh = sb_bread(sb, logical_sb_block);\n\t\tif (!bh) {\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"EXT4-fs: Can't read superblock on 2nd try.\\n\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tes = (struct ext4_super_block *)(((char *)bh->b_data) + offset);\n\t\tsbi->s_es = es;\n\t\tif (es->s_magic != cpu_to_le16(EXT4_SUPER_MAGIC)) {\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"EXT4-fs: Magic mismatch, very weird !\\n\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tsbi->s_bitmap_maxbytes = ext4_max_bitmap_size(sb->s_blocksize_bits,\n\t\t\t\t\t\t      has_huge_files);\n\tsb->s_maxbytes = ext4_max_size(sb->s_blocksize_bits, has_huge_files);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV) {\n\t\tsbi->s_inode_size = EXT4_GOOD_OLD_INODE_SIZE;\n\t\tsbi->s_first_ino = EXT4_GOOD_OLD_FIRST_INO;\n\t} else {\n\t\tsbi->s_inode_size = le16_to_cpu(es->s_inode_size);\n\t\tsbi->s_first_ino = le32_to_cpu(es->s_first_ino);\n\t\tif ((sbi->s_inode_size < EXT4_GOOD_OLD_INODE_SIZE) ||\n\t\t    (!is_power_of_2(sbi->s_inode_size)) ||\n\t\t    (sbi->s_inode_size > blocksize)) {\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"EXT4-fs: unsupported inode size: %d\\n\",\n\t\t\t       sbi->s_inode_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE)\n\t\t\tsb->s_time_gran = 1 << (EXT4_EPOCH_BITS - 2);\n\t}\n\tsbi->s_desc_size = le16_to_cpu(es->s_desc_size);\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_64BIT)) {\n\t\tif (sbi->s_desc_size < EXT4_MIN_DESC_SIZE_64BIT ||\n\t\t    sbi->s_desc_size > EXT4_MAX_DESC_SIZE ||\n\t\t    !is_power_of_2(sbi->s_desc_size)) {\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"EXT4-fs: unsupported descriptor size %lu\\n\",\n\t\t\t       sbi->s_desc_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else\n\t\tsbi->s_desc_size = EXT4_MIN_DESC_SIZE;\n\tsbi->s_blocks_per_group = le32_to_cpu(es->s_blocks_per_group);\n\tsbi->s_inodes_per_group = le32_to_cpu(es->s_inodes_per_group);\n\tif (EXT4_INODE_SIZE(sb) == 0 || EXT4_INODES_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext4;\n\tsbi->s_inodes_per_block = blocksize / EXT4_INODE_SIZE(sb);\n\tif (sbi->s_inodes_per_block == 0)\n\t\tgoto cantfind_ext4;\n\tsbi->s_itb_per_group = sbi->s_inodes_per_group /\n\t\t\t\t\tsbi->s_inodes_per_block;\n\tsbi->s_desc_per_block = blocksize / EXT4_DESC_SIZE(sb);\n\tsbi->s_sbh = bh;\n\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\tsbi->s_addr_per_block_bits = ilog2(EXT4_ADDR_PER_BLOCK(sb));\n\tsbi->s_desc_per_block_bits = ilog2(EXT4_DESC_PER_BLOCK(sb));\n\tfor (i = 0; i < 4; i++)\n\t\tsbi->s_hash_seed[i] = le32_to_cpu(es->s_hash_seed[i]);\n\tsbi->s_def_hash_version = es->s_def_hash_version;\n\ti = le32_to_cpu(es->s_flags);\n\tif (i & EXT2_FLAGS_UNSIGNED_HASH)\n\t\tsbi->s_hash_unsigned = 3;\n\telse if ((i & EXT2_FLAGS_SIGNED_HASH) == 0) {\n#ifdef __CHAR_UNSIGNED__\n\t\tes->s_flags |= cpu_to_le32(EXT2_FLAGS_UNSIGNED_HASH);\n\t\tsbi->s_hash_unsigned = 3;\n#else\n\t\tes->s_flags |= cpu_to_le32(EXT2_FLAGS_SIGNED_HASH);\n#endif\n\t\tsb->s_dirt = 1;\n\t}\n\n\tif (sbi->s_blocks_per_group > blocksize * 8) {\n\t\tprintk(KERN_ERR\n\t\t       \"EXT4-fs: #blocks per group too big: %lu\\n\",\n\t\t       sbi->s_blocks_per_group);\n\t\tgoto failed_mount;\n\t}\n\tif (sbi->s_inodes_per_group > blocksize * 8) {\n\t\tprintk(KERN_ERR\n\t\t       \"EXT4-fs: #inodes per group too big: %lu\\n\",\n\t\t       sbi->s_inodes_per_group);\n\t\tgoto failed_mount;\n\t}\n\n\tif (ext4_blocks_count(es) >\n\t\t    (sector_t)(~0ULL) >> (sb->s_blocksize_bits - 9)) {\n\t\tprintk(KERN_ERR \"EXT4-fs: filesystem on %s:\"\n\t\t\t\" too large to mount safely\\n\", sb->s_id);\n\t\tif (sizeof(sector_t) < 8)\n\t\t\tprintk(KERN_WARNING \"EXT4-fs: CONFIG_LBD not \"\n\t\t\t\t\t\"enabled\\n\");\n\t\tgoto failed_mount;\n\t}\n\n\tif (EXT4_BLOCKS_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext4;\n\n\t/* ensure blocks_count calculation below doesn't sign-extend */\n\tif (ext4_blocks_count(es) + EXT4_BLOCKS_PER_GROUP(sb) <\n\t    le32_to_cpu(es->s_first_data_block) + 1) {\n\t\tprintk(KERN_WARNING \"EXT4-fs: bad geometry: block count %llu, \"\n\t\t       \"first data block %u, blocks per group %lu\\n\",\n\t\t\text4_blocks_count(es),\n\t\t\tle32_to_cpu(es->s_first_data_block),\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb));\n\t\tgoto failed_mount;\n\t}\n\tblocks_count = (ext4_blocks_count(es) -\n\t\t\tle32_to_cpu(es->s_first_data_block) +\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb) - 1);\n\tdo_div(blocks_count, EXT4_BLOCKS_PER_GROUP(sb));\n\tsbi->s_groups_count = blocks_count;\n\tdb_count = (sbi->s_groups_count + EXT4_DESC_PER_BLOCK(sb) - 1) /\n\t\t   EXT4_DESC_PER_BLOCK(sb);\n\tsbi->s_group_desc = kmalloc(db_count * sizeof(struct buffer_head *),\n\t\t\t\t    GFP_KERNEL);\n\tif (sbi->s_group_desc == NULL) {\n\t\tprintk(KERN_ERR \"EXT4-fs: not enough memory\\n\");\n\t\tgoto failed_mount;\n\t}\n\n#ifdef CONFIG_PROC_FS\n\tif (ext4_proc_root)\n\t\tsbi->s_proc = proc_mkdir(sb->s_id, ext4_proc_root);\n\n\tif (sbi->s_proc)\n\t\tproc_create_data(\"inode_readahead_blks\", 0644, sbi->s_proc,\n\t\t\t\t &ext4_ui_proc_fops,\n\t\t\t\t &sbi->s_inode_readahead_blks);\n#endif\n\n\tbgl_lock_init(&sbi->s_blockgroup_lock);\n\n\tfor (i = 0; i < db_count; i++) {\n\t\tblock = descriptor_loc(sb, logical_sb_block, i);\n\t\tsbi->s_group_desc[i] = sb_bread(sb, block);\n\t\tif (!sbi->s_group_desc[i]) {\n\t\t\tprintk(KERN_ERR \"EXT4-fs: \"\n\t\t\t       \"can't read group descriptor %d\\n\", i);\n\t\t\tdb_count = i;\n\t\t\tgoto failed_mount2;\n\t\t}\n\t}\n\tif (!ext4_check_descriptors(sb)) {\n\t\tprintk(KERN_ERR \"EXT4-fs: group descriptors corrupted!\\n\");\n\t\tgoto failed_mount2;\n\t}\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_FLEX_BG))\n\t\tif (!ext4_fill_flex_info(sb)) {\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"EXT4-fs: unable to initialize \"\n\t\t\t       \"flex_bg meta info!\\n\");\n\t\t\tgoto failed_mount2;\n\t\t}\n\n\tsbi->s_gdb_count = db_count;\n\tget_random_bytes(&sbi->s_next_generation, sizeof(u32));\n\tspin_lock_init(&sbi->s_next_gen_lock);\n\n\terr = percpu_counter_init(&sbi->s_freeblocks_counter,\n\t\t\text4_count_free_blocks(sb));\n\tif (!err) {\n\t\terr = percpu_counter_init(&sbi->s_freeinodes_counter,\n\t\t\t\text4_count_free_inodes(sb));\n\t}\n\tif (!err) {\n\t\terr = percpu_counter_init(&sbi->s_dirs_counter,\n\t\t\t\text4_count_dirs(sb));\n\t}\n\tif (!err) {\n\t\terr = percpu_counter_init(&sbi->s_dirtyblocks_counter, 0);\n\t}\n\tif (err) {\n\t\tprintk(KERN_ERR \"EXT4-fs: insufficient memory\\n\");\n\t\tgoto failed_mount3;\n\t}\n\n\tsbi->s_stripe = ext4_get_stripe_size(sbi);\n\n\t/*\n\t * set up enough so that it can read an inode\n\t */\n\tsb->s_op = &ext4_sops;\n\tsb->s_export_op = &ext4_export_ops;\n\tsb->s_xattr = ext4_xattr_handlers;\n#ifdef CONFIG_QUOTA\n\tsb->s_qcop = &ext4_qctl_operations;\n\tsb->dq_op = &ext4_quota_operations;\n#endif\n\tINIT_LIST_HEAD(&sbi->s_orphan); /* unlinked but open files */\n\n\tsb->s_root = NULL;\n\n\tneeds_recovery = (es->s_last_orphan != 0 ||\n\t\t\t  EXT4_HAS_INCOMPAT_FEATURE(sb,\n\t\t\t\t    EXT4_FEATURE_INCOMPAT_RECOVER));\n\n\t/*\n\t * The first inode we look at is the journal inode.  Don't try\n\t * root first: it may be modified in the journal!\n\t */\n\tif (!test_opt(sb, NOLOAD) &&\n\t    EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_HAS_JOURNAL)) {\n\t\tif (ext4_load_journal(sb, es, journal_devnum))\n\t\t\tgoto failed_mount3;\n\t\tif (!(sb->s_flags & MS_RDONLY) &&\n\t\t    EXT4_SB(sb)->s_journal->j_failed_commit) {\n\t\t\tprintk(KERN_CRIT \"EXT4-fs error (device %s): \"\n\t\t\t       \"ext4_fill_super: Journal transaction \"\n\t\t\t       \"%u is corrupt\\n\", sb->s_id,\n\t\t\t       EXT4_SB(sb)->s_journal->j_failed_commit);\n\t\t\tif (test_opt(sb, ERRORS_RO)) {\n\t\t\t\tprintk(KERN_CRIT\n\t\t\t\t       \"Mounting filesystem read-only\\n\");\n\t\t\t\tsb->s_flags |= MS_RDONLY;\n\t\t\t\tEXT4_SB(sb)->s_mount_state |= EXT4_ERROR_FS;\n\t\t\t\tes->s_state |= cpu_to_le16(EXT4_ERROR_FS);\n\t\t\t}\n\t\t\tif (test_opt(sb, ERRORS_PANIC)) {\n\t\t\t\tEXT4_SB(sb)->s_mount_state |= EXT4_ERROR_FS;\n\t\t\t\tes->s_state |= cpu_to_le16(EXT4_ERROR_FS);\n\t\t\t\text4_commit_super(sb, es, 1);\n\t\t\t\tgoto failed_mount4;\n\t\t\t}\n\t\t}\n\t} else if (test_opt(sb, NOLOAD) && !(sb->s_flags & MS_RDONLY) &&\n\t      EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER)) {\n\t\tprintk(KERN_ERR \"EXT4-fs: required journal recovery \"\n\t\t       \"suppressed and not mounted read-only\\n\");\n\t\tgoto failed_mount4;\n\t} else {\n\t\tclear_opt(sbi->s_mount_opt, DATA_FLAGS);\n\t\tset_opt(sbi->s_mount_opt, WRITEBACK_DATA);\n\t\tsbi->s_journal = NULL;\n\t\tneeds_recovery = 0;\n\t\tgoto no_journal;\n\t}\n\n\tif (ext4_blocks_count(es) > 0xffffffffULL &&\n\t    !jbd2_journal_set_features(EXT4_SB(sb)->s_journal, 0, 0,\n\t\t\t\t       JBD2_FEATURE_INCOMPAT_64BIT)) {\n\t\tprintk(KERN_ERR \"ext4: Failed to set 64-bit journal feature\\n\");\n\t\tgoto failed_mount4;\n\t}\n\n\tif (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n\t\tjbd2_journal_set_features(sbi->s_journal,\n\t\t\t\tJBD2_FEATURE_COMPAT_CHECKSUM, 0,\n\t\t\t\tJBD2_FEATURE_INCOMPAT_ASYNC_COMMIT);\n\t} else if (test_opt(sb, JOURNAL_CHECKSUM)) {\n\t\tjbd2_journal_set_features(sbi->s_journal,\n\t\t\t\tJBD2_FEATURE_COMPAT_CHECKSUM, 0, 0);\n\t\tjbd2_journal_clear_features(sbi->s_journal, 0, 0,\n\t\t\t\tJBD2_FEATURE_INCOMPAT_ASYNC_COMMIT);\n\t} else {\n\t\tjbd2_journal_clear_features(sbi->s_journal,\n\t\t\t\tJBD2_FEATURE_COMPAT_CHECKSUM, 0,\n\t\t\t\tJBD2_FEATURE_INCOMPAT_ASYNC_COMMIT);\n\t}\n\n\t/* We have now updated the journal if required, so we can\n\t * validate the data journaling mode. */\n\tswitch (test_opt(sb, DATA_FLAGS)) {\n\tcase 0:\n\t\t/* No mode set, assume a default based on the journal\n\t\t * capabilities: ORDERED_DATA if the journal can\n\t\t * cope, else JOURNAL_DATA\n\t\t */\n\t\tif (jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE))\n\t\t\tset_opt(sbi->s_mount_opt, ORDERED_DATA);\n\t\telse\n\t\t\tset_opt(sbi->s_mount_opt, JOURNAL_DATA);\n\t\tbreak;\n\n\tcase EXT4_MOUNT_ORDERED_DATA:\n\tcase EXT4_MOUNT_WRITEBACK_DATA:\n\t\tif (!jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE)) {\n\t\t\tprintk(KERN_ERR \"EXT4-fs: Journal does not support \"\n\t\t\t       \"requested data journaling mode\\n\");\n\t\t\tgoto failed_mount4;\n\t\t}\n\tdefault:\n\t\tbreak;\n\t}\n\tset_task_ioprio(sbi->s_journal->j_task, journal_ioprio);\n\nno_journal:\n\n\tif (test_opt(sb, NOBH)) {\n\t\tif (!(test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_WRITEBACK_DATA)) {\n\t\t\tprintk(KERN_WARNING \"EXT4-fs: Ignoring nobh option - \"\n\t\t\t\t\"its supported only with writeback mode\\n\");\n\t\t\tclear_opt(sbi->s_mount_opt, NOBH);\n\t\t}\n\t}\n\t/*\n\t * The jbd2_journal_load will have done any necessary log recovery,\n\t * so we can safely mount the rest of the filesystem now.\n\t */\n\n\troot = ext4_iget(sb, EXT4_ROOT_INO);\n\tif (IS_ERR(root)) {\n\t\tprintk(KERN_ERR \"EXT4-fs: get root inode failed\\n\");\n\t\tret = PTR_ERR(root);\n\t\tgoto failed_mount4;\n\t}\n\tif (!S_ISDIR(root->i_mode) || !root->i_blocks || !root->i_size) {\n\t\tiput(root);\n\t\tprintk(KERN_ERR \"EXT4-fs: corrupt root inode, run e2fsck\\n\");\n\t\tgoto failed_mount4;\n\t}\n\tsb->s_root = d_alloc_root(root);\n\tif (!sb->s_root) {\n\t\tprintk(KERN_ERR \"EXT4-fs: get root dentry failed\\n\");\n\t\tiput(root);\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\text4_setup_super(sb, es, sb->s_flags & MS_RDONLY);\n\n\t/* determine the minimum size of new large inodes, if present */\n\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t     EXT4_GOOD_OLD_INODE_SIZE;\n\t\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t       EXT4_FEATURE_RO_COMPAT_EXTRA_ISIZE)) {\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_want_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_want_extra_isize);\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_min_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_min_extra_isize);\n\t\t}\n\t}\n\t/* Check if enough inode space is available */\n\tif (EXT4_GOOD_OLD_INODE_SIZE + sbi->s_want_extra_isize >\n\t\t\t\t\t\t\tsbi->s_inode_size) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t       EXT4_GOOD_OLD_INODE_SIZE;\n\t\tprintk(KERN_INFO \"EXT4-fs: required extra inode space not\"\n\t\t\t\"available.\\n\");\n\t}\n\n\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA) {\n\t\tprintk(KERN_WARNING \"EXT4-fs: Ignoring delalloc option - \"\n\t\t\t\t\"requested data journaling mode\\n\");\n\t\tclear_opt(sbi->s_mount_opt, DELALLOC);\n\t} else if (test_opt(sb, DELALLOC))\n\t\tprintk(KERN_INFO \"EXT4-fs: delayed allocation enabled\\n\");\n\n\text4_ext_init(sb);\n\terr = ext4_mb_init(sb, needs_recovery);\n\tif (err) {\n\t\tprintk(KERN_ERR \"EXT4-fs: failed to initalize mballoc (%d)\\n\",\n\t\t       err);\n\t\tgoto failed_mount4;\n\t}\n\n\t/*\n\t * akpm: core read_super() calls in here with the superblock locked.\n\t * That deadlocks, because orphan cleanup needs to lock the superblock\n\t * in numerous places.  Here we just pop the lock - it's relatively\n\t * harmless, because we are now ready to accept write_super() requests,\n\t * and aviro says that's the only reason for hanging onto the\n\t * superblock lock.\n\t */\n\tEXT4_SB(sb)->s_mount_state |= EXT4_ORPHAN_FS;\n\text4_orphan_cleanup(sb, es);\n\tEXT4_SB(sb)->s_mount_state &= ~EXT4_ORPHAN_FS;\n\tif (needs_recovery) {\n\t\tprintk(KERN_INFO \"EXT4-fs: recovery complete.\\n\");\n\t\text4_mark_recovery_complete(sb, es);\n\t}\n\tif (EXT4_SB(sb)->s_journal) {\n\t\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)\n\t\t\tdescr = \" journalled data mode\";\n\t\telse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)\n\t\t\tdescr = \" ordered data mode\";\n\t\telse\n\t\t\tdescr = \" writeback data mode\";\n\t} else\n\t\tdescr = \"out journal\";\n\n\tprintk(KERN_INFO \"EXT4-fs: mounted filesystem %s with%s\\n\",\n\t       sb->s_id, descr);\n\n\tlock_kernel();\n\treturn 0;\n\ncantfind_ext4:\n\tif (!silent)\n\t\tprintk(KERN_ERR \"VFS: Can't find ext4 filesystem on dev %s.\\n\",\n\t\t       sb->s_id);\n\tgoto failed_mount;\n\nfailed_mount4:\n\tprintk(KERN_ERR \"EXT4-fs (device %s): mount failed\\n\", sb->s_id);\n\tif (sbi->s_journal) {\n\t\tjbd2_journal_destroy(sbi->s_journal);\n\t\tsbi->s_journal = NULL;\n\t}\nfailed_mount3:\n\tpercpu_counter_destroy(&sbi->s_freeblocks_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tpercpu_counter_destroy(&sbi->s_dirtyblocks_counter);\nfailed_mount2:\n\tfor (i = 0; i < db_count; i++)\n\t\tbrelse(sbi->s_group_desc[i]);\n\tkfree(sbi->s_group_desc);\nfailed_mount:\n\tif (sbi->s_proc) {\n\t\tremove_proc_entry(\"inode_readahead_blks\", sbi->s_proc);\n\t\tremove_proc_entry(sb->s_id, ext4_proc_root);\n\t}\n#ifdef CONFIG_QUOTA\n\tfor (i = 0; i < MAXQUOTAS; i++)\n\t\tkfree(sbi->s_qf_names[i]);\n#endif\n\text4_blkdev_remove(sbi);\n\tbrelse(bh);\nout_fail:\n\tsb->s_fs_info = NULL;\n\tkfree(sbi);\n\tlock_kernel();\n\treturn ret;\n}",
        "target": 1
    },
    {
        "func": "int selinux_netlbl_inode_permission(struct inode *inode, int mask)\n{\n\tint rc;\n\tstruct sock *sk;\n\tstruct socket *sock;\n\tstruct sk_security_struct *sksec;\n\n\tif (!S_ISSOCK(inode->i_mode) ||\n\t    ((mask & (MAY_WRITE | MAY_APPEND)) == 0))\n\t\treturn 0;\n\n\tsock = SOCKET_I(inode);\n\tsk = sock->sk;\n\tsksec = sk->sk_security;\n\tif (sksec->nlbl_state != NLBL_REQUIRE)\n\t\treturn 0;\n\n\tlocal_bh_disable();\n\tbh_lock_sock_nested(sk);\n\tif (likely(sksec->nlbl_state == NLBL_REQUIRE))\n\t\trc = selinux_netlbl_sock_setsid(sk);\n\telse\n\t\trc = 0;\n\tbh_unlock_sock(sk);\n\tlocal_bh_enable();\n\n\treturn rc;\n}",
        "target": 1
    },
    {
        "func": "static int originates_from_local_legacy_unicast_socket(AvahiServer *s, const AvahiAddress *address, uint16_t port) {\n    assert(s);\n    assert(address);\n    assert(port > 0);\n\n    if (!s->config.enable_reflector)\n        return 0;\n\n    if (!avahi_address_is_local(s->monitor, address))\n        return 0;\n\n    if (address->proto == AVAHI_PROTO_INET && s->fd_legacy_unicast_ipv4 >= 0) {\n        struct sockaddr_in lsa;\n        socklen_t l = sizeof(lsa);\n\n        if (getsockname(s->fd_legacy_unicast_ipv4, (struct sockaddr*) &lsa, &l) != 0)\n            avahi_log_warn(\"getsockname(): %s\", strerror(errno));\n        else\n            return lsa.sin_port == port;\n\n    }\n\n    if (address->proto == AVAHI_PROTO_INET6 && s->fd_legacy_unicast_ipv6 >= 0) {\n        struct sockaddr_in6 lsa;\n        socklen_t l = sizeof(lsa);\n\n        if (getsockname(s->fd_legacy_unicast_ipv6, (struct sockaddr*) &lsa, &l) != 0)\n            avahi_log_warn(\"getsockname(): %s\", strerror(errno));\n        else\n            return lsa.sin6_port == port;\n    }\n\n    return 0;\n}",
        "target": 1
    },
    {
        "func": "static ssize_t inotify_read(struct file *file, char __user *buf,\n\t\t\t    size_t count, loff_t *pos)\n{\n\tsize_t event_size = sizeof (struct inotify_event);\n\tstruct inotify_device *dev;\n\tchar __user *start;\n\tint ret;\n\tDEFINE_WAIT(wait);\n\n\tstart = buf;\n\tdev = file->private_data;\n\n\twhile (1) {\n\n\t\tprepare_to_wait(&dev->wq, &wait, TASK_INTERRUPTIBLE);\n\n\t\tmutex_lock(&dev->ev_mutex);\n\t\tif (!list_empty(&dev->events)) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tmutex_unlock(&dev->ev_mutex);\n\n\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (signal_pending(current)) {\n\t\t\tret = -EINTR;\n\t\t\tbreak;\n\t\t}\n\n\t\tschedule();\n\t}\n\n\tfinish_wait(&dev->wq, &wait);\n\tif (ret)\n\t\treturn ret;\n\n\twhile (1) {\n\t\tstruct inotify_kernel_event *kevent;\n\n\t\tret = buf - start;\n\t\tif (list_empty(&dev->events))\n\t\t\tbreak;\n\n\t\tkevent = inotify_dev_get_event(dev);\n\t\tif (event_size + kevent->event.len > count) {\n\t\t\tif (ret == 0 && count > 0) {\n\t\t\t\t/*\n\t\t\t\t * could not get a single event because we\n\t\t\t\t * didn't have enough buffer space.\n\t\t\t\t */\n\t\t\t\tret = -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tremove_kevent(dev, kevent);\n\n\t\t/*\n\t\t * Must perform the copy_to_user outside the mutex in order\n\t\t * to avoid a lock order reversal with mmap_sem.\n\t\t */\n\t\tmutex_unlock(&dev->ev_mutex);\n\n\t\tif (copy_to_user(buf, &kevent->event, event_size)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tbuf += event_size;\n\t\tcount -= event_size;\n\n\t\tif (kevent->name) {\n\t\t\tif (copy_to_user(buf, kevent->name, kevent->event.len)){\n\t\t\t\tret = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbuf += kevent->event.len;\n\t\t\tcount -= kevent->event.len;\n\t\t}\n\n\t\tfree_kevent(kevent);\n\n\t\tmutex_lock(&dev->ev_mutex);\n\t}\n\tmutex_unlock(&dev->ev_mutex);\n\n\treturn ret;\n}",
        "target": 1
    },
    {
        "func": "int ecryptfs_write_metadata(struct dentry *ecryptfs_dentry)\n{\n\tstruct ecryptfs_crypt_stat *crypt_stat =\n\t\t&ecryptfs_inode_to_private(ecryptfs_dentry->d_inode)->crypt_stat;\n\tchar *virt;\n\tsize_t size = 0;\n\tint rc = 0;\n\n\tif (likely(crypt_stat->flags & ECRYPTFS_ENCRYPTED)) {\n\t\tif (!(crypt_stat->flags & ECRYPTFS_KEY_VALID)) {\n\t\t\tprintk(KERN_ERR \"Key is invalid; bailing out\\n\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tprintk(KERN_WARNING \"%s: Encrypted flag not set\\n\",\n\t\t       __func__);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\t/* Released in this function */\n\tvirt = (char *)get_zeroed_page(GFP_KERNEL);\n\tif (!virt) {\n\t\tprintk(KERN_ERR \"%s: Out of memory\\n\", __func__);\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\trc = ecryptfs_write_headers_virt(virt, PAGE_CACHE_SIZE, &size,\n\t\t\t\t\t crypt_stat, ecryptfs_dentry);\n\tif (unlikely(rc)) {\n\t\tprintk(KERN_ERR \"%s: Error whilst writing headers; rc = [%d]\\n\",\n\t\t       __func__, rc);\n\t\tgoto out_free;\n\t}\n\tif (crypt_stat->flags & ECRYPTFS_METADATA_IN_XATTR)\n\t\trc = ecryptfs_write_metadata_to_xattr(ecryptfs_dentry,\n\t\t\t\t\t\t      crypt_stat, virt, size);\n\telse\n\t\trc = ecryptfs_write_metadata_to_contents(crypt_stat,\n\t\t\t\t\t\t\t ecryptfs_dentry, virt);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Error writing metadata out to lower file; \"\n\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\tgoto out_free;\n\t}\nout_free:\n\tfree_page((unsigned long)virt);\nout:\n\treturn rc;\n}",
        "target": 1
    },
    {
        "func": "ecryptfs_write_metadata_to_xattr(struct dentry *ecryptfs_dentry,\n\t\t\t\t struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t\t char *page_virt, size_t size)\n{\n\tint rc;\n\n\trc = ecryptfs_setxattr(ecryptfs_dentry, ECRYPTFS_XATTR_NAME, page_virt,\n\t\t\t       size, 0);\n\treturn rc;\n}",
        "target": 1
    },
    {
        "func": "ecryptfs_write_metadata_to_contents(struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t\t    struct dentry *ecryptfs_dentry,\n\t\t\t\t    char *virt)\n{\n\tint rc;\n\n\trc = ecryptfs_write_lower(ecryptfs_dentry->d_inode, virt,\n\t\t\t\t  0, crypt_stat->num_header_bytes_at_front);\n\tif (rc)\n\t\tprintk(KERN_ERR \"%s: Error attempting to write header \"\n\t\t       \"information to lower file; rc = [%d]\\n\", __func__,\n\t\t       rc);\n\treturn rc;\n}",
        "target": 1
    },
    {
        "func": "int set_selection(const struct tiocl_selection __user *sel, struct tty_struct *tty)\n{\n\tstruct vc_data *vc = vc_cons[fg_console].d;\n\tint sel_mode, new_sel_start, new_sel_end, spc;\n\tchar *bp, *obp;\n\tint i, ps, pe, multiplier;\n\tu16 c;\n\tstruct kbd_struct *kbd = kbd_table + fg_console;\n\n\tpoke_blanked_console();\n\n\t{ unsigned short xs, ys, xe, ye;\n\n\t  if (!access_ok(VERIFY_READ, sel, sizeof(*sel)))\n\t\treturn -EFAULT;\n\t  __get_user(xs, &sel->xs);\n\t  __get_user(ys, &sel->ys);\n\t  __get_user(xe, &sel->xe);\n\t  __get_user(ye, &sel->ye);\n\t  __get_user(sel_mode, &sel->sel_mode);\n\t  xs--; ys--; xe--; ye--;\n\t  xs = limit(xs, vc->vc_cols - 1);\n\t  ys = limit(ys, vc->vc_rows - 1);\n\t  xe = limit(xe, vc->vc_cols - 1);\n\t  ye = limit(ye, vc->vc_rows - 1);\n\t  ps = ys * vc->vc_size_row + (xs << 1);\n\t  pe = ye * vc->vc_size_row + (xe << 1);\n\n\t  if (sel_mode == TIOCL_SELCLEAR) {\n\t      /* useful for screendump without selection highlights */\n\t      clear_selection();\n\t      return 0;\n\t  }\n\n\t  if (mouse_reporting() && (sel_mode & TIOCL_SELMOUSEREPORT)) {\n\t      mouse_report(tty, sel_mode & TIOCL_SELBUTTONMASK, xs, ys);\n\t      return 0;\n\t  }\n        }\n\n\tif (ps > pe)\t/* make sel_start <= sel_end */\n\t{\n\t\tint tmp = ps;\n\t\tps = pe;\n\t\tpe = tmp;\n\t}\n\n\tif (sel_cons != vc_cons[fg_console].d) {\n\t\tclear_selection();\n\t\tsel_cons = vc_cons[fg_console].d;\n\t}\n\tuse_unicode = kbd && kbd->kbdmode == VC_UNICODE;\n\n\tswitch (sel_mode)\n\t{\n\t\tcase TIOCL_SELCHAR:\t/* character-by-character selection */\n\t\t\tnew_sel_start = ps;\n\t\t\tnew_sel_end = pe;\n\t\t\tbreak;\n\t\tcase TIOCL_SELWORD:\t/* word-by-word selection */\n\t\t\tspc = isspace(sel_pos(ps));\n\t\t\tfor (new_sel_start = ps; ; ps -= 2)\n\t\t\t{\n\t\t\t\tif ((spc && !isspace(sel_pos(ps))) ||\n\t\t\t\t    (!spc && !inword(sel_pos(ps))))\n\t\t\t\t\tbreak;\n\t\t\t\tnew_sel_start = ps;\n\t\t\t\tif (!(ps % vc->vc_size_row))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tspc = isspace(sel_pos(pe));\n\t\t\tfor (new_sel_end = pe; ; pe += 2)\n\t\t\t{\n\t\t\t\tif ((spc && !isspace(sel_pos(pe))) ||\n\t\t\t\t    (!spc && !inword(sel_pos(pe))))\n\t\t\t\t\tbreak;\n\t\t\t\tnew_sel_end = pe;\n\t\t\t\tif (!((pe + 2) % vc->vc_size_row))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIOCL_SELLINE:\t/* line-by-line selection */\n\t\t\tnew_sel_start = ps - ps % vc->vc_size_row;\n\t\t\tnew_sel_end = pe + vc->vc_size_row\n\t\t\t\t    - pe % vc->vc_size_row - 2;\n\t\t\tbreak;\n\t\tcase TIOCL_SELPOINTER:\n\t\t\thighlight_pointer(pe);\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\n\t/* remove the pointer */\n\thighlight_pointer(-1);\n\n\t/* select to end of line if on trailing space */\n\tif (new_sel_end > new_sel_start &&\n\t\t!atedge(new_sel_end, vc->vc_size_row) &&\n\t\tisspace(sel_pos(new_sel_end))) {\n\t\tfor (pe = new_sel_end + 2; ; pe += 2)\n\t\t\tif (!isspace(sel_pos(pe)) ||\n\t\t\t    atedge(pe, vc->vc_size_row))\n\t\t\t\tbreak;\n\t\tif (isspace(sel_pos(pe)))\n\t\t\tnew_sel_end = pe;\n\t}\n\tif (sel_start == -1)\t/* no current selection */\n\t\thighlight(new_sel_start, new_sel_end);\n\telse if (new_sel_start == sel_start)\n\t{\n\t\tif (new_sel_end == sel_end)\t/* no action required */\n\t\t\treturn 0;\n\t\telse if (new_sel_end > sel_end)\t/* extend to right */\n\t\t\thighlight(sel_end + 2, new_sel_end);\n\t\telse\t\t\t\t/* contract from right */\n\t\t\thighlight(new_sel_end + 2, sel_end);\n\t}\n\telse if (new_sel_end == sel_end)\n\t{\n\t\tif (new_sel_start < sel_start)\t/* extend to left */\n\t\t\thighlight(new_sel_start, sel_start - 2);\n\t\telse\t\t\t\t/* contract from left */\n\t\t\thighlight(sel_start, new_sel_start - 2);\n\t}\n\telse\t/* some other case; start selection from scratch */\n\t{\n\t\tclear_selection();\n\t\thighlight(new_sel_start, new_sel_end);\n\t}\n\tsel_start = new_sel_start;\n\tsel_end = new_sel_end;\n\n\t/* Allocate a new buffer before freeing the old one ... */\n\tmultiplier = use_unicode ? 3 : 1;  /* chars can take up to 3 bytes */\n\tbp = kmalloc((sel_end-sel_start)/2*multiplier+1, GFP_KERNEL);\n\tif (!bp) {\n\t\tprintk(KERN_WARNING \"selection: kmalloc() failed\\n\");\n\t\tclear_selection();\n\t\treturn -ENOMEM;\n\t}\n\tkfree(sel_buffer);\n\tsel_buffer = bp;\n\n\tobp = bp;\n\tfor (i = sel_start; i <= sel_end; i += 2) {\n\t\tc = sel_pos(i);\n\t\tif (use_unicode)\n\t\t\tbp += store_utf8(c, bp);\n\t\telse\n\t\t\t*bp++ = c;\n\t\tif (!isspace(c))\n\t\t\tobp = bp;\n\t\tif (! ((i + 2) % vc->vc_size_row)) {\n\t\t\t/* strip trailing blanks from line and add newline,\n\t\t\t   unless non-space at end of line. */\n\t\t\tif (obp != bp) {\n\t\t\t\tbp = obp;\n\t\t\t\t*bp++ = '\\r';\n\t\t\t}\n\t\t\tobp = bp;\n\t\t}\n\t}\n\tsel_buffer_lth = bp - sel_buffer;\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "struct nfs_server *nfs4_create_server(const struct nfs4_mount_data *data,\n\t\t\t\t      const char *hostname,\n\t\t\t\t      const struct sockaddr_in *addr,\n\t\t\t\t      const char *mntpath,\n\t\t\t\t      const char *ip_addr,\n\t\t\t\t      rpc_authflavor_t authflavour,\n\t\t\t\t      struct nfs_fh *mntfh)\n{\n\tstruct nfs_fattr fattr;\n\tstruct nfs_server *server;\n\tint error;\n\n\tdprintk(\"--> nfs4_create_server()\\n\");\n\n\tserver = nfs_alloc_server();\n\tif (!server)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* Get a client record */\n\terror = nfs4_set_client(server, hostname, addr, ip_addr, authflavour,\n\t\t\tdata->proto, data->timeo, data->retrans);\n\tif (error < 0)\n\t\tgoto error;\n\n\t/* set up the general RPC client */\n\terror = nfs4_init_server(server, data, authflavour);\n\tif (error < 0)\n\t\tgoto error;\n\n\tBUG_ON(!server->nfs_client);\n\tBUG_ON(!server->nfs_client->rpc_ops);\n\tBUG_ON(!server->nfs_client->rpc_ops->file_inode_ops);\n\n\t/* Probe the root fh to retrieve its FSID */\n\terror = nfs4_path_walk(server, mntfh, mntpath);\n\tif (error < 0)\n\t\tgoto error;\n\n\tdprintk(\"Server FSID: %llx:%llx\\n\",\n\t\t(unsigned long long) server->fsid.major,\n\t\t(unsigned long long) server->fsid.minor);\n\tdprintk(\"Mount FH: %d\\n\", mntfh->size);\n\n\terror = nfs_probe_fsinfo(server, mntfh, &fattr);\n\tif (error < 0)\n\t\tgoto error;\n\n\tBUG_ON(!server->nfs_client);\n\tBUG_ON(!server->nfs_client->rpc_ops);\n\tBUG_ON(!server->nfs_client->rpc_ops->file_inode_ops);\n\n\tspin_lock(&nfs_client_lock);\n\tlist_add_tail(&server->client_link, &server->nfs_client->cl_superblocks);\n\tlist_add_tail(&server->master_link, &nfs_volume_list);\n\tspin_unlock(&nfs_client_lock);\n\n\tserver->mount_time = jiffies;\n\tdprintk(\"<-- nfs4_create_server() = %p\\n\", server);\n\treturn server;\n\nerror:\n\tnfs_free_server(server);\n\tdprintk(\"<-- nfs4_create_server() = error %d\\n\", error);\n\treturn ERR_PTR(error);\n}",
        "target": 1
    },
    {
        "func": "static struct dentry *nfs_readdir_lookup(nfs_readdir_descriptor_t *desc)\n{\n\tstruct dentry *parent = desc->file->f_path.dentry;\n\tstruct inode *dir = parent->d_inode;\n\tstruct nfs_entry *entry = desc->entry;\n\tstruct dentry *dentry, *alias;\n\tstruct qstr name = {\n\t\t.name = entry->name,\n\t\t.len = entry->len,\n\t};\n\tstruct inode *inode;\n\n\tswitch (name.len) {\n\t\tcase 2:\n\t\t\tif (name.name[0] == '.' && name.name[1] == '.')\n\t\t\t\treturn dget_parent(parent);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (name.name[0] == '.')\n\t\t\t\treturn dget(parent);\n\t}\n\tname.hash = full_name_hash(name.name, name.len);\n\tdentry = d_lookup(parent, &name);\n\tif (dentry != NULL) {\n\t\t/* Is this a positive dentry that matches the readdir info? */\n\t\tif (dentry->d_inode != NULL &&\n\t\t\t\t(NFS_FILEID(dentry->d_inode) == entry->ino ||\n\t\t\t\td_mountpoint(dentry))) {\n\t\t\tif (!desc->plus || entry->fh->size == 0)\n\t\t\t\treturn dentry;\n\t\t\tif (nfs_compare_fh(NFS_FH(dentry->d_inode),\n\t\t\t\t\t\tentry->fh) == 0)\n\t\t\t\tgoto out_renew;\n\t\t}\n\t\t/* No, so d_drop to allow one to be created */\n\t\td_drop(dentry);\n\t\tdput(dentry);\n\t}\n\tif (!desc->plus || !(entry->fattr->valid & NFS_ATTR_FATTR))\n\t\treturn NULL;\n\t/* Note: caller is already holding the dir->i_mutex! */\n\tdentry = d_alloc(parent, &name);\n\tif (dentry == NULL)\n\t\treturn NULL;\n\tdentry->d_op = NFS_PROTO(dir)->dentry_ops;\n\tinode = nfs_fhget(dentry->d_sb, entry->fh, entry->fattr);\n\tif (IS_ERR(inode)) {\n\t\tdput(dentry);\n\t\treturn NULL;\n\t}\n\n\talias = d_materialise_unique(dentry, inode);\n\tif (alias != NULL) {\n\t\tdput(dentry);\n\t\tif (IS_ERR(alias))\n\t\t\treturn NULL;\n\t\tdentry = alias;\n\t}\n\n\tnfs_renew_times(dentry);\n\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n\treturn dentry;\nout_renew:\n\tnfs_renew_times(dentry);\n\tnfs_refresh_verifier(dentry, nfs_save_change_attribute(dir));\n\treturn dentry;\n}",
        "target": 1
    },
    {
        "func": "int nfs4_path_walk(struct nfs_server *server,\n\t\t   struct nfs_fh *mntfh,\n\t\t   const char *path)\n{\n\tstruct nfs_fsinfo fsinfo;\n\tstruct nfs_fattr fattr;\n\tstruct nfs_fh lastfh;\n\tstruct qstr name;\n\tint ret;\n\n\tdprintk(\"--> nfs4_path_walk(,,%s)\\n\", path);\n\n\tfsinfo.fattr = &fattr;\n\tnfs_fattr_init(&fattr);\n\n\t/* Eat leading slashes */\n\twhile (*path == '/')\n\t\tpath++;\n\n\t/* Start by getting the root filehandle from the server */\n\tret = server->nfs_client->rpc_ops->getroot(server, mntfh, &fsinfo);\n\tif (ret < 0) {\n\t\tdprintk(\"nfs4_get_root: getroot error = %d\\n\", -ret);\n\t\treturn ret;\n\t}\n\n\tif (fattr.type != NFDIR) {\n\t\tprintk(KERN_ERR \"nfs4_get_root:\"\n\t\t       \" getroot encountered non-directory\\n\");\n\t\treturn -ENOTDIR;\n\t}\n\n\t/* FIXME: It is quite valid for the server to return a referral here */\n\tif (fattr.valid & NFS_ATTR_FATTR_V4_REFERRAL) {\n\t\tprintk(KERN_ERR \"nfs4_get_root:\"\n\t\t       \" getroot obtained referral\\n\");\n\t\treturn -EREMOTE;\n\t}\n\nnext_component:\n\tdprintk(\"Next: %s\\n\", path);\n\n\t/* extract the next bit of the path */\n\tif (!*path)\n\t\tgoto path_walk_complete;\n\n\tname.name = path;\n\twhile (*path && *path != '/')\n\t\tpath++;\n\tname.len = path - (const char *) name.name;\n\neat_dot_dir:\n\twhile (*path == '/')\n\t\tpath++;\n\n\tif (path[0] == '.' && (path[1] == '/' || !path[1])) {\n\t\tpath += 2;\n\t\tgoto eat_dot_dir;\n\t}\n\n\t/* FIXME: Why shouldn't the user be able to use \"..\" in the path? */\n\tif (path[0] == '.' && path[1] == '.' && (path[2] == '/' || !path[2])\n\t    ) {\n\t\tprintk(KERN_ERR \"nfs4_get_root:\"\n\t\t       \" Mount path contains reference to \\\"..\\\"\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* lookup the next FH in the sequence */\n\tmemcpy(&lastfh, mntfh, sizeof(lastfh));\n\n\tdprintk(\"LookupFH: %*.*s [%s]\\n\", name.len, name.len, name.name, path);\n\n\tret = server->nfs_client->rpc_ops->lookupfh(server, &lastfh, &name,\n\t\t\t\t\t\t    mntfh, &fattr);\n\tif (ret < 0) {\n\t\tdprintk(\"nfs4_get_root: getroot error = %d\\n\", -ret);\n\t\treturn ret;\n\t}\n\n\tif (fattr.type != NFDIR) {\n\t\tprintk(KERN_ERR \"nfs4_get_root:\"\n\t\t       \" lookupfh encountered non-directory\\n\");\n\t\treturn -ENOTDIR;\n\t}\n\n\t/* FIXME: Referrals are quite valid here too */\n\tif (fattr.valid & NFS_ATTR_FATTR_V4_REFERRAL) {\n\t\tprintk(KERN_ERR \"nfs4_get_root:\"\n\t\t       \" lookupfh obtained referral\\n\");\n\t\treturn -EREMOTE;\n\t}\n\n\tgoto next_component;\n\npath_walk_complete:\n\tmemcpy(&server->fsid, &fattr.fsid, sizeof(server->fsid));\n\tdprintk(\"<-- nfs4_path_walk() = 0\\n\");\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "struct nfs_server *nfs4_create_referral_server(struct nfs_clone_mount *data,\n\t\t\t\t\t       struct nfs_fh *mntfh)\n{\n\tstruct nfs_client *parent_client;\n\tstruct nfs_server *server, *parent_server;\n\tstruct nfs_fattr fattr;\n\tint error;\n\n\tdprintk(\"--> nfs4_create_referral_server()\\n\");\n\n\tserver = nfs_alloc_server();\n\tif (!server)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tparent_server = NFS_SB(data->sb);\n\tparent_client = parent_server->nfs_client;\n\n\t/* Get a client representation.\n\t * Note: NFSv4 always uses TCP, */\n\terror = nfs4_set_client(server, data->hostname, data->addr,\n\t\t\tparent_client->cl_ipaddr,\n\t\t\tdata->authflavor,\n\t\t\tparent_server->client->cl_xprt->prot,\n\t\t\tparent_client->retrans_timeo,\n\t\t\tparent_client->retrans_count);\n\tif (error < 0)\n\t\tgoto error;\n\n\t/* Initialise the client representation from the parent server */\n\tnfs_server_copy_userdata(server, parent_server);\n\tserver->caps |= NFS_CAP_ATOMIC_OPEN;\n\n\terror = nfs_init_server_rpcclient(server, data->authflavor);\n\tif (error < 0)\n\t\tgoto error;\n\n\tBUG_ON(!server->nfs_client);\n\tBUG_ON(!server->nfs_client->rpc_ops);\n\tBUG_ON(!server->nfs_client->rpc_ops->file_inode_ops);\n\n\t/* Probe the root fh to retrieve its FSID and filehandle */\n\terror = nfs4_path_walk(server, mntfh, data->mnt_path);\n\tif (error < 0)\n\t\tgoto error;\n\n\t/* probe the filesystem info for this server filesystem */\n\terror = nfs_probe_fsinfo(server, mntfh, &fattr);\n\tif (error < 0)\n\t\tgoto error;\n\n\tdprintk(\"Referral FSID: %llx:%llx\\n\",\n\t\t(unsigned long long) server->fsid.major,\n\t\t(unsigned long long) server->fsid.minor);\n\n\tspin_lock(&nfs_client_lock);\n\tlist_add_tail(&server->client_link, &server->nfs_client->cl_superblocks);\n\tlist_add_tail(&server->master_link, &nfs_volume_list);\n\tspin_unlock(&nfs_client_lock);\n\n\tserver->mount_time = jiffies;\n\n\tdprintk(\"<-- nfs_create_referral_server() = %p\\n\", server);\n\treturn server;\n\nerror:\n\tnfs_free_server(server);\n\tdprintk(\"<-- nfs4_create_referral_server() = error %d\\n\", error);\n\treturn ERR_PTR(error);\n}",
        "target": 1
    },
    {
        "func": "struct nfs_server *nfs_clone_server(struct nfs_server *source,\n\t\t\t\t    struct nfs_fh *fh,\n\t\t\t\t    struct nfs_fattr *fattr)\n{\n\tstruct nfs_server *server;\n\tstruct nfs_fattr fattr_fsinfo;\n\tint error;\n\n\tdprintk(\"--> nfs_clone_server(,%llx:%llx,)\\n\",\n\t\t(unsigned long long) fattr->fsid.major,\n\t\t(unsigned long long) fattr->fsid.minor);\n\n\tserver = nfs_alloc_server();\n\tif (!server)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* Copy data from the source */\n\tserver->nfs_client = source->nfs_client;\n\tatomic_inc(&server->nfs_client->cl_count);\n\tnfs_server_copy_userdata(server, source);\n\n\tserver->fsid = fattr->fsid;\n\n\terror = nfs_init_server_rpcclient(server, source->client->cl_auth->au_flavor);\n\tif (error < 0)\n\t\tgoto out_free_server;\n\tif (!IS_ERR(source->client_acl))\n\t\tnfs_init_server_aclclient(server);\n\n\t/* probe the filesystem info for this server filesystem */\n\terror = nfs_probe_fsinfo(server, fh, &fattr_fsinfo);\n\tif (error < 0)\n\t\tgoto out_free_server;\n\n\tdprintk(\"Cloned FSID: %llx:%llx\\n\",\n\t\t(unsigned long long) server->fsid.major,\n\t\t(unsigned long long) server->fsid.minor);\n\n\terror = nfs_start_lockd(server);\n\tif (error < 0)\n\t\tgoto out_free_server;\n\n\tspin_lock(&nfs_client_lock);\n\tlist_add_tail(&server->client_link, &server->nfs_client->cl_superblocks);\n\tlist_add_tail(&server->master_link, &nfs_volume_list);\n\tspin_unlock(&nfs_client_lock);\n\n\tserver->mount_time = jiffies;\n\n\tdprintk(\"<-- nfs_clone_server() = %p\\n\", server);\n\treturn server;\n\nout_free_server:\n\tnfs_free_server(server);\n\tdprintk(\"<-- nfs_clone_server() = error %d\\n\", error);\n\treturn ERR_PTR(error);\n}",
        "target": 1
    },
    {
        "func": "struct nfs_server *nfs_create_server(const struct nfs_mount_data *data,\n\t\t\t\t     struct nfs_fh *mntfh)\n{\n\tstruct nfs_server *server;\n\tstruct nfs_fattr fattr;\n\tint error;\n\n\tserver = nfs_alloc_server();\n\tif (!server)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* Get a client representation */\n\terror = nfs_init_server(server, data);\n\tif (error < 0)\n\t\tgoto error;\n\n\tBUG_ON(!server->nfs_client);\n\tBUG_ON(!server->nfs_client->rpc_ops);\n\tBUG_ON(!server->nfs_client->rpc_ops->file_inode_ops);\n\n\t/* Probe the root fh to retrieve its FSID */\n\terror = nfs_probe_fsinfo(server, mntfh, &fattr);\n\tif (error < 0)\n\t\tgoto error;\n\tif (!(fattr.valid & NFS_ATTR_FATTR)) {\n\t\terror = server->nfs_client->rpc_ops->getattr(server, mntfh, &fattr);\n\t\tif (error < 0) {\n\t\t\tdprintk(\"nfs_create_server: getattr error = %d\\n\", -error);\n\t\t\tgoto error;\n\t\t}\n\t}\n\tmemcpy(&server->fsid, &fattr.fsid, sizeof(server->fsid));\n\n\tdprintk(\"Server FSID: %llx:%llx\\n\",\n\t\t(unsigned long long) server->fsid.major,\n\t\t(unsigned long long) server->fsid.minor);\n\n\tBUG_ON(!server->nfs_client);\n\tBUG_ON(!server->nfs_client->rpc_ops);\n\tBUG_ON(!server->nfs_client->rpc_ops->file_inode_ops);\n\n\tspin_lock(&nfs_client_lock);\n\tlist_add_tail(&server->client_link, &server->nfs_client->cl_superblocks);\n\tlist_add_tail(&server->master_link, &nfs_volume_list);\n\tspin_unlock(&nfs_client_lock);\n\n\tserver->mount_time = jiffies;\n\treturn server;\n\nerror:\n\tnfs_free_server(server);\n\treturn ERR_PTR(error);\n}",
        "target": 1
    },
    {
        "func": "static int nfs_init_server(struct nfs_server *server, const struct nfs_mount_data *data)\n{\n\tstruct nfs_client *clp;\n\tint error, nfsvers = 2;\n\n\tdprintk(\"--> nfs_init_server()\\n\");\n\n#ifdef CONFIG_NFS_V3\n\tif (data->flags & NFS_MOUNT_VER3)\n\t\tnfsvers = 3;\n#endif\n\n\t/* Allocate or find a client reference we can use */\n\tclp = nfs_get_client(data->hostname, &data->addr, nfsvers);\n\tif (IS_ERR(clp)) {\n\t\tdprintk(\"<-- nfs_init_server() = error %ld\\n\", PTR_ERR(clp));\n\t\treturn PTR_ERR(clp);\n\t}\n\n\terror = nfs_init_client(clp, data);\n\tif (error < 0)\n\t\tgoto error;\n\n\tserver->nfs_client = clp;\n\n\t/* Initialise the client representation from the mount data */\n\tserver->flags = data->flags & NFS_MOUNT_FLAGMASK;\n\n\tif (data->rsize)\n\t\tserver->rsize = nfs_block_size(data->rsize, NULL);\n\tif (data->wsize)\n\t\tserver->wsize = nfs_block_size(data->wsize, NULL);\n\n\tserver->acregmin = data->acregmin * HZ;\n\tserver->acregmax = data->acregmax * HZ;\n\tserver->acdirmin = data->acdirmin * HZ;\n\tserver->acdirmax = data->acdirmax * HZ;\n\n\t/* Start lockd here, before we might error out */\n\terror = nfs_start_lockd(server);\n\tif (error < 0)\n\t\tgoto error;\n\n\terror = nfs_init_server_rpcclient(server, data->pseudoflavor);\n\tif (error < 0)\n\t\tgoto error;\n\n\tserver->namelen  = data->namlen;\n\t/* Create a client RPC handle for the NFSv3 ACL management interface */\n\tnfs_init_server_aclclient(server);\n\tif (clp->cl_nfsversion == 3) {\n\t\tif (server->namelen == 0 || server->namelen > NFS3_MAXNAMLEN)\n\t\t\tserver->namelen = NFS3_MAXNAMLEN;\n\t\tif (!(data->flags & NFS_MOUNT_NORDIRPLUS))\n\t\t\tserver->caps |= NFS_CAP_READDIRPLUS;\n\t} else {\n\t\tif (server->namelen == 0 || server->namelen > NFS2_MAXNAMLEN)\n\t\t\tserver->namelen = NFS2_MAXNAMLEN;\n\t}\n\n\tdprintk(\"<-- nfs_init_server() = 0 [new %p]\\n\", clp);\n\treturn 0;\n\nerror:\n\tserver->nfs_client = NULL;\n\tnfs_put_client(clp);\n\tdprintk(\"<-- nfs_init_server() = xerror %d\\n\", error);\n\treturn error;\n}",
        "target": 1
    },
    {
        "func": "int udev_monitor_enable_receiving(struct udev_monitor *udev_monitor)\n{\n\tint err;\n\tconst int on = 1;\n\n\tif (udev_monitor->snl.nl_family != 0) {\n\t\terr = bind(udev_monitor->sock,\n\t\t\t   (struct sockaddr *)&udev_monitor->snl, sizeof(struct sockaddr_nl));\n\t\tif (err < 0) {\n\t\t\terr(udev_monitor->udev, \"bind failed: %m\\n\");\n\t\t\treturn err;\n\t\t}\n\t\tdbg(udev_monitor->udev, \"monitor %p listening on netlink\\n\", udev_monitor);\n\t} else if (udev_monitor->sun.sun_family != 0) {\n\t\terr = bind(udev_monitor->sock,\n\t\t\t   (struct sockaddr *)&udev_monitor->sun, udev_monitor->addrlen);\n\t\tif (err < 0) {\n\t\t\terr(udev_monitor->udev, \"bind failed: %m\\n\");\n\t\t\treturn err;\n\t\t}\n\t\t/* enable receiving of the sender credentials */\n\t\tsetsockopt(udev_monitor->sock, SOL_SOCKET, SO_PASSCRED, &on, sizeof(on));\n\t\tdbg(udev_monitor->udev, \"monitor %p listening on socket\\n\", udev_monitor);\n\t}\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "struct udev_device *udev_monitor_receive_device(struct udev_monitor *udev_monitor)\n{\n\tstruct udev_device *udev_device;\n\tstruct msghdr smsg;\n\tstruct iovec iov;\n\tchar cred_msg[CMSG_SPACE(sizeof(struct ucred))];\n\tchar buf[4096];\n\tsize_t bufpos;\n\tint devpath_set = 0;\n\tint subsystem_set = 0;\n\tint action_set = 0;\n\tint maj = 0;\n\tint min = 0;\n\n\tif (udev_monitor == NULL)\n\t\treturn NULL;\n\tmemset(buf, 0x00, sizeof(buf));\n\tiov.iov_base = &buf;\n\tiov.iov_len = sizeof(buf);\n\tmemset (&smsg, 0x00, sizeof(struct msghdr));\n\tsmsg.msg_iov = &iov;\n\tsmsg.msg_iovlen = 1;\n\tsmsg.msg_control = cred_msg;\n\tsmsg.msg_controllen = sizeof(cred_msg);\n\n\tif (recvmsg(udev_monitor->sock, &smsg, 0) < 0) {\n\t\tif (errno != EINTR)\n\t\t\tinfo(udev_monitor->udev, \"unable to receive message\");\n\t\treturn NULL;\n\t}\n\n\tif (udev_monitor->sun.sun_family != 0) {\n\t\tstruct cmsghdr *cmsg = CMSG_FIRSTHDR(&smsg);\n\t\tstruct ucred *cred = (struct ucred *)CMSG_DATA (cmsg);\n\n\t\tif (cmsg == NULL || cmsg->cmsg_type != SCM_CREDENTIALS) {\n\t\t\tinfo(udev_monitor->udev, \"no sender credentials received, message ignored\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (cred->uid != 0) {\n\t\t\tinfo(udev_monitor->udev, \"sender uid=%d, message ignored\", cred->uid);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t/* skip header */\n\tbufpos = strlen(buf) + 1;\n\tif (bufpos < sizeof(\"a@/d\") || bufpos >= sizeof(buf)) {\n\t\tinfo(udev_monitor->udev, \"invalid message length\");\n\t\treturn NULL;\n\t}\n\n\t/* check message header */\n\tif (strstr(buf, \"@/\") == NULL) {\n\t\tinfo(udev_monitor->udev, \"unrecognized message header\");\n\t\treturn NULL;\n\t}\n\n\tudev_device = device_new(udev_monitor->udev);\n\tif (udev_device == NULL) {\n\t\treturn NULL;\n\t}\n\n\twhile (bufpos < sizeof(buf)) {\n\t\tchar *key;\n\t\tsize_t keylen;\n\n\t\tkey = &buf[bufpos];\n\t\tkeylen = strlen(key);\n\t\tif (keylen == 0)\n\t\t\tbreak;\n\t\tbufpos += keylen + 1;\n\n\t\tif (strncmp(key, \"DEVPATH=\", 8) == 0) {\n\t\t\tchar path[UTIL_PATH_SIZE];\n\n\t\t\tutil_strlcpy(path, udev_get_sys_path(udev_monitor->udev), sizeof(path));\n\t\t\tutil_strlcat(path, &key[8], sizeof(path));\n\t\t\tudev_device_set_syspath(udev_device, path);\n\t\t\tdevpath_set = 1;\n\t\t} else if (strncmp(key, \"SUBSYSTEM=\", 10) == 0) {\n\t\t\tudev_device_set_subsystem(udev_device, &key[10]);\n\t\t\tsubsystem_set = 1;\n\t\t} else if (strncmp(key, \"DEVTYPE=\", 8) == 0) {\n\t\t\tudev_device_set_devtype(udev_device, &key[8]);\n\t\t} else if (strncmp(key, \"DEVNAME=\", 8) == 0) {\n\t\t\tudev_device_set_devnode(udev_device, &key[8]);\n\t\t} else if (strncmp(key, \"DEVLINKS=\", 9) == 0) {\n\t\t\tchar devlinks[UTIL_PATH_SIZE];\n\t\t\tchar *slink;\n\t\t\tchar *next;\n\n\t\t\tutil_strlcpy(devlinks, &key[9], sizeof(devlinks));\n\t\t\tslink = devlinks;\n\t\t\tnext = strchr(slink, ' ');\n\t\t\twhile (next != NULL) {\n\t\t\t\tnext[0] = '\\0';\n\t\t\t\tudev_device_add_devlink(udev_device, slink);\n\t\t\t\tslink = &next[1];\n\t\t\t\tnext = strchr(slink, ' ');\n\t\t\t}\n\t\t\tif (slink[0] != '\\0')\n\t\t\t\tudev_device_add_devlink(udev_device, slink);\n\t\t} else if (strncmp(key, \"DRIVER=\", 7) == 0) {\n\t\t\tudev_device_set_driver(udev_device, &key[7]);\n\t\t} else if (strncmp(key, \"ACTION=\", 7) == 0) {\n\t\t\tudev_device_set_action(udev_device, &key[7]);\n\t\t\taction_set = 1;\n\t\t} else if (strncmp(key, \"MAJOR=\", 6) == 0) {\n\t\t\tmaj = strtoull(&key[6], NULL, 10);\n\t\t} else if (strncmp(key, \"MINOR=\", 6) == 0) {\n\t\t\tmin = strtoull(&key[6], NULL, 10);\n\t\t} else if (strncmp(key, \"DEVPATH_OLD=\", 12) == 0) {\n\t\t\tudev_device_set_devpath_old(udev_device, &key[12]);\n\t\t} else if (strncmp(key, \"PHYSDEVPATH=\", 12) == 0) {\n\t\t\tudev_device_set_physdevpath(udev_device, &key[12]);\n\t\t} else if (strncmp(key, \"SEQNUM=\", 7) == 0) {\n\t\t\tudev_device_set_seqnum(udev_device, strtoull(&key[7], NULL, 10));\n\t\t} else if (strncmp(key, \"TIMEOUT=\", 8) == 0) {\n\t\t\tudev_device_set_timeout(udev_device, strtoull(&key[8], NULL, 10));\n\t\t} else if (strncmp(key, \"PHYSDEV\", 7) == 0) {\n\t\t\t/* skip deprecated values */\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tudev_device_add_property_from_string(udev_device, key);\n\t\t}\n\t}\n\tif (!devpath_set || !subsystem_set || !action_set) {\n\t\tinfo(udev_monitor->udev, \"missing values, skip\\n\");\n\t\tudev_device_unref(udev_device);\n\t\treturn NULL;\n\t}\n\tif (maj > 0)\n\t\tudev_device_set_devnum(udev_device, makedev(maj, min));\n\tudev_device_set_info_loaded(udev_device);\n\treturn udev_device;\n}",
        "target": 1
    },
    {
        "func": "int udev_monitor_send_device(struct udev_monitor *udev_monitor, struct udev_device *udev_device)\n{\n\tconst char *buf;\n\tssize_t len;\n\tssize_t count;\n\n\tlen = udev_device_get_properties_monitor_buf(udev_device, &buf);\n\tif (len < 32)\n\t\treturn -1;\n\tif (udev_monitor->sun.sun_family != 0) {\n\t\tcount = sendto(udev_monitor->sock,\n\t\t\t       buf, len, 0,\n\t\t\t       (struct sockaddr *)&udev_monitor->sun,\n\t\t\t       udev_monitor->addrlen);\n\t} else {\n\t\t/* no destination besides the muticast group, we will always get -1 ECONNREFUSED */\n\t\tcount = sendto(udev_monitor->sock,\n\t\t\t       buf, len, 0,\n\t\t\t       (struct sockaddr *)&udev_monitor->snl_peer,\n\t\t\t       sizeof(struct sockaddr_nl));\n\t}\n\tinfo(udev_monitor->udev, \"passed %zi bytes to monitor %p, \\n\", count, udev_monitor);\n\treturn count;\n}",
        "target": 1
    },
    {
        "func": "struct udev_device *udev_monitor_receive_device(struct udev_monitor *udev_monitor)\n{\n\tstruct udev_device *udev_device;\n\tstruct msghdr smsg;\n\tstruct iovec iov;\n\tchar cred_msg[CMSG_SPACE(sizeof(struct ucred))];\n\tstruct cmsghdr *cmsg;\n\tstruct ucred *cred;\n\tchar buf[4096];\n\tsize_t bufpos;\n\tint devpath_set = 0;\n\tint subsystem_set = 0;\n\tint action_set = 0;\n\tint maj = 0;\n\tint min = 0;\n\n\tif (udev_monitor == NULL)\n\t\treturn NULL;\n\tmemset(buf, 0x00, sizeof(buf));\n\tiov.iov_base = &buf;\n\tiov.iov_len = sizeof(buf);\n\tmemset (&smsg, 0x00, sizeof(struct msghdr));\n\tsmsg.msg_iov = &iov;\n\tsmsg.msg_iovlen = 1;\n\tsmsg.msg_control = cred_msg;\n\tsmsg.msg_controllen = sizeof(cred_msg);\n\n\tif (recvmsg(udev_monitor->sock, &smsg, 0) < 0) {\n\t\tif (errno != EINTR)\n\t\t\tinfo(udev_monitor->udev, \"unable to receive message\");\n\t\treturn NULL;\n\t}\n\n\tcmsg = CMSG_FIRSTHDR(&smsg);\n\tif (cmsg == NULL || cmsg->cmsg_type != SCM_CREDENTIALS) {\n\t\tinfo(udev_monitor->udev, \"no sender credentials received, message ignored\");\n\t\treturn NULL;\n\t}\n\n\tcred = (struct ucred *)CMSG_DATA(cmsg);\n\tif (cred->uid != 0) {\n\t\tinfo(udev_monitor->udev, \"sender uid=%d, message ignored\", cred->uid);\n\t\treturn NULL;\n\t}\n\n\t/* skip header */\n\tbufpos = strlen(buf) + 1;\n\tif (bufpos < sizeof(\"a@/d\") || bufpos >= sizeof(buf)) {\n\t\tinfo(udev_monitor->udev, \"invalid message length\");\n\t\treturn NULL;\n\t}\n\n\t/* check message header */\n\tif (strstr(buf, \"@/\") == NULL) {\n\t\tinfo(udev_monitor->udev, \"unrecognized message header\");\n\t\treturn NULL;\n\t}\n\n\tudev_device = device_new(udev_monitor->udev);\n\tif (udev_device == NULL) {\n\t\treturn NULL;\n\t}\n\n\twhile (bufpos < sizeof(buf)) {\n\t\tchar *key;\n\t\tsize_t keylen;\n\n\t\tkey = &buf[bufpos];\n\t\tkeylen = strlen(key);\n\t\tif (keylen == 0)\n\t\t\tbreak;\n\t\tbufpos += keylen + 1;\n\n\t\tif (strncmp(key, \"DEVPATH=\", 8) == 0) {\n\t\t\tchar path[UTIL_PATH_SIZE];\n\n\t\t\tutil_strlcpy(path, udev_get_sys_path(udev_monitor->udev), sizeof(path));\n\t\t\tutil_strlcat(path, &key[8], sizeof(path));\n\t\t\tudev_device_set_syspath(udev_device, path);\n\t\t\tdevpath_set = 1;\n\t\t} else if (strncmp(key, \"SUBSYSTEM=\", 10) == 0) {\n\t\t\tudev_device_set_subsystem(udev_device, &key[10]);\n\t\t\tsubsystem_set = 1;\n\t\t} else if (strncmp(key, \"DEVTYPE=\", 8) == 0) {\n\t\t\tudev_device_set_devtype(udev_device, &key[8]);\n\t\t} else if (strncmp(key, \"DEVNAME=\", 8) == 0) {\n\t\t\tudev_device_set_devnode(udev_device, &key[8]);\n\t\t} else if (strncmp(key, \"DEVLINKS=\", 9) == 0) {\n\t\t\tchar devlinks[UTIL_PATH_SIZE];\n\t\t\tchar *slink;\n\t\t\tchar *next;\n\n\t\t\tutil_strlcpy(devlinks, &key[9], sizeof(devlinks));\n\t\t\tslink = devlinks;\n\t\t\tnext = strchr(slink, ' ');\n\t\t\twhile (next != NULL) {\n\t\t\t\tnext[0] = '\\0';\n\t\t\t\tudev_device_add_devlink(udev_device, slink);\n\t\t\t\tslink = &next[1];\n\t\t\t\tnext = strchr(slink, ' ');\n\t\t\t}\n\t\t\tif (slink[0] != '\\0')\n\t\t\t\tudev_device_add_devlink(udev_device, slink);\n\t\t} else if (strncmp(key, \"DRIVER=\", 7) == 0) {\n\t\t\tudev_device_set_driver(udev_device, &key[7]);\n\t\t} else if (strncmp(key, \"ACTION=\", 7) == 0) {\n\t\t\tudev_device_set_action(udev_device, &key[7]);\n\t\t\taction_set = 1;\n\t\t} else if (strncmp(key, \"MAJOR=\", 6) == 0) {\n\t\t\tmaj = strtoull(&key[6], NULL, 10);\n\t\t} else if (strncmp(key, \"MINOR=\", 6) == 0) {\n\t\t\tmin = strtoull(&key[6], NULL, 10);\n\t\t} else if (strncmp(key, \"DEVPATH_OLD=\", 12) == 0) {\n\t\t\tudev_device_set_devpath_old(udev_device, &key[12]);\n\t\t} else if (strncmp(key, \"PHYSDEVPATH=\", 12) == 0) {\n\t\t\tudev_device_set_physdevpath(udev_device, &key[12]);\n\t\t} else if (strncmp(key, \"SEQNUM=\", 7) == 0) {\n\t\t\tudev_device_set_seqnum(udev_device, strtoull(&key[7], NULL, 10));\n\t\t} else if (strncmp(key, \"TIMEOUT=\", 8) == 0) {\n\t\t\tudev_device_set_timeout(udev_device, strtoull(&key[8], NULL, 10));\n\t\t} else if (strncmp(key, \"PHYSDEV\", 7) == 0) {\n\t\t\t/* skip deprecated values */\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tudev_device_add_property_from_string(udev_device, key);\n\t\t}\n\t}\n\tif (!devpath_set || !subsystem_set || !action_set) {\n\t\tinfo(udev_monitor->udev, \"missing values, skip\\n\");\n\t\tudev_device_unref(udev_device);\n\t\treturn NULL;\n\t}\n\tif (maj > 0)\n\t\tudev_device_set_devnum(udev_device, makedev(maj, min));\n\tudev_device_set_info_loaded(udev_device);\n\treturn udev_device;\n}",
        "target": 1
    },
    {
        "func": "int udev_monitor_send_device(struct udev_monitor *udev_monitor, struct udev_device *udev_device)\n{\n\tconst char *buf;\n\tssize_t len;\n\tssize_t count;\n\n\tlen = udev_device_get_properties_monitor_buf(udev_device, &buf);\n\tif (len < 32)\n\t\treturn -1;\n\tif (udev_monitor->sun.sun_family != 0)\n\t\tcount = sendto(udev_monitor->sock,\n\t\t\t       buf, len, 0,\n\t\t\t       (struct sockaddr *)&udev_monitor->sun,\n\t\t\t       udev_monitor->addrlen);\n\telse if (udev_monitor->snl.nl_family != 0)\n\t\t/* no destination besides the muticast group, we will always get ECONNREFUSED */\n\t\tcount = sendto(udev_monitor->sock,\n\t\t\t       buf, len, 0,\n\t\t\t       (struct sockaddr *)&udev_monitor->snl_peer,\n\t\t\t       sizeof(struct sockaddr_nl));\n\telse\n\t\treturn -1;\n\n\tinfo(udev_monitor->udev, \"passed %zi bytes to monitor %p, \\n\", count, udev_monitor);\n\treturn count;\n}",
        "target": 1
    },
    {
        "func": "size_t util_path_encode(char *s, size_t len)\n{\n\tchar t[(len * 3)+1];\n\tsize_t i, j;\n\n\tfor (i = 0, j = 0; s[i] != '\\0'; i++) {\n\t\tif (s[i] == '/') {\n\t\t\tmemcpy(&t[j], \"\\\\x2f\", 4);\n\t\t\tj += 4;\n\t\t} else if (s[i] == '\\\\') {\n\t\t\tmemcpy(&t[j], \"\\\\x5c\", 4);\n\t\t\tj += 4;\n\t\t} else {\n\t\t\tt[j] = s[i];\n\t\t\tj++;\n\t\t}\n\t}\n\tif (len == 0)\n\t\treturn j;\n\ti = (j < len - 1) ? j : len - 1;\n\tmemcpy(s, t, i);\n\ts[i] = '\\0';\n\treturn j;\n}",
        "target": 1
    },
    {
        "func": "void async_request(TALLOC_CTX *mem_ctx, struct winbindd_child *child,\n\t\t   struct winbindd_request *request,\n\t\t   struct winbindd_response *response,\n\t\t   void (*continuation)(void *private_data, BOOL success),\n\t\t   void *private_data)\n{\n\tstruct winbindd_async_request *state;\n\n\tSMB_ASSERT(continuation != NULL);\n\n\tstate = TALLOC_P(mem_ctx, struct winbindd_async_request);\n\n\tif (state == NULL) {\n\t\tDEBUG(0, (\"talloc failed\\n\"));\n\t\tcontinuation(private_data, False);\n\t\treturn;\n\t}\n\n\tstate->mem_ctx = mem_ctx;\n\tstate->child = child;\n\tstate->request = request;\n\tstate->response = response;\n\tstate->continuation = continuation;\n\tstate->private_data = private_data;\n\n\tDLIST_ADD_END(child->requests, state, struct winbindd_async_request *);\n\n\tschedule_async_request(child);\n\n\treturn;\n}",
        "target": 1
    },
    {
        "func": "static void async_main_request_sent(void *private_data, BOOL success)\n{\n\tstruct winbindd_async_request *state =\n\t\ttalloc_get_type_abort(private_data, struct winbindd_async_request);\n\n\tif (!success) {\n\t\tDEBUG(5, (\"Could not send async request\\n\"));\n\n\t\tstate->response->length = sizeof(struct winbindd_response);\n\t\tstate->response->result = WINBINDD_ERROR;\n\t\tstate->continuation(state->private_data, False);\n\t\treturn;\n\t}\n\n\tif (state->request->extra_len == 0) {\n\t\tasync_request_sent(private_data, True);\n\t\treturn;\n\t}\n\n\tsetup_async_write(&state->child->event, state->request->extra_data.data,\n\t\t\t  state->request->extra_len,\n\t\t\t  async_request_sent, state);\n}",
        "target": 1
    },
    {
        "func": "static int vmx_set_msr(struct kvm_vcpu *vcpu, u32 msr_index, u64 data)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct kvm_msr_entry *msr;\n\tu64 host_tsc;\n\tint ret = 0;\n\n\tswitch (msr_index) {\n#ifdef CONFIG_X86_64\n\tcase MSR_EFER:\n\t\tvmx_load_host_state(vmx);\n\t\tret = kvm_set_msr_common(vcpu, msr_index, data);\n\t\tbreak;\n\tcase MSR_FS_BASE:\n\t\tvmcs_writel(GUEST_FS_BASE, data);\n\t\tbreak;\n\tcase MSR_GS_BASE:\n\t\tvmcs_writel(GUEST_GS_BASE, data);\n\t\tbreak;\n#endif\n\tcase MSR_IA32_SYSENTER_CS:\n\t\tvmcs_write32(GUEST_SYSENTER_CS, data);\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_EIP:\n\t\tvmcs_writel(GUEST_SYSENTER_EIP, data);\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_ESP:\n\t\tvmcs_writel(GUEST_SYSENTER_ESP, data);\n\t\tbreak;\n\tcase MSR_IA32_TIME_STAMP_COUNTER:\n\t\trdtscll(host_tsc);\n\t\tguest_write_tsc(data, host_tsc);\n\t\tbreak;\n\tcase MSR_P6_PERFCTR0:\n\tcase MSR_P6_PERFCTR1:\n\tcase MSR_P6_EVNTSEL0:\n\tcase MSR_P6_EVNTSEL1:\n\t\t/*\n\t\t * Just discard all writes to the performance counters; this\n\t\t * should keep both older linux and windows 64-bit guests\n\t\t * happy\n\t\t */\n\t\tpr_unimpl(vcpu, \"unimplemented perfctr wrmsr: 0x%x data 0x%llx\\n\", msr_index, data);\n\n\t\tbreak;\n\tcase MSR_IA32_CR_PAT:\n\t\tif (vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_PAT) {\n\t\t\tvmcs_write64(GUEST_IA32_PAT, data);\n\t\t\tvcpu->arch.pat = data;\n\t\t\tbreak;\n\t\t}\n\t\t/* Otherwise falls through to kvm_set_msr_common */\n\tdefault:\n\t\tvmx_load_host_state(vmx);\n\t\tmsr = find_msr_entry(vmx, msr_index);\n\t\tif (msr) {\n\t\t\tmsr->data = data;\n\t\t\tbreak;\n\t\t}\n\t\tret = kvm_set_msr_common(vcpu, msr_index, data);\n\t}\n\n\treturn ret;\n}",
        "target": 1
    },
    {
        "func": "static bool acl_group_override(connection_struct *conn,\n\t\t\t\tgid_t prim_gid,\n\t\t\t\tconst char *fname)\n{\n\tSMB_STRUCT_STAT sbuf;\n\n\tif ((errno != EPERM) && (errno != EACCES)) {\n\t\treturn false;\n\t}\n\n\t/* file primary group == user primary or supplementary group */\n\tif (lp_acl_group_control(SNUM(conn)) &&\n\t\t\tcurrent_user_in_group(prim_gid)) {\n\t\treturn true;\n\t}\n\n\t/* user has writeable permission */\n\tif (lp_dos_filemode(SNUM(conn)) &&\n\t\t\tcan_write_to_file(conn, fname, &sbuf)) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
        "target": 1
    },
    {
        "func": "static bool set_canon_ace_list(files_struct *fsp, canon_ace *the_ace, bool default_ace, gid_t prim_gid, bool *pacl_set_support)\n{\n\tconnection_struct *conn = fsp->conn;\n\tbool ret = False;\n\tSMB_ACL_T the_acl = SMB_VFS_SYS_ACL_INIT(conn, (int)count_canon_ace_list(the_ace) + 1);\n\tcanon_ace *p_ace;\n\tint i;\n\tSMB_ACL_ENTRY_T mask_entry;\n\tbool got_mask_entry = False;\n\tSMB_ACL_PERMSET_T mask_permset;\n\tSMB_ACL_TYPE_T the_acl_type = (default_ace ? SMB_ACL_TYPE_DEFAULT : SMB_ACL_TYPE_ACCESS);\n\tbool needs_mask = False;\n\tmode_t mask_perms = 0;\n\n#if defined(POSIX_ACL_NEEDS_MASK)\n\t/* HP-UX always wants to have a mask (called \"class\" there). */\n\tneeds_mask = True;\n#endif\n\n\tif (the_acl == NULL) {\n\n\t\tif (!no_acl_syscall_error(errno)) {\n\t\t\t/*\n\t\t\t * Only print this error message if we have some kind of ACL\n\t\t\t * support that's not working. Otherwise we would always get this.\n\t\t\t */\n\t\t\tDEBUG(0,(\"set_canon_ace_list: Unable to init %s ACL. (%s)\\n\",\n\t\t\t\tdefault_ace ? \"default\" : \"file\", strerror(errno) ));\n\t\t}\n\t\t*pacl_set_support = False;\n\t\treturn False;\n\t}\n\n\tif( DEBUGLVL( 10 )) {\n\t\tdbgtext(\"set_canon_ace_list: setting ACL:\\n\");\n\t\tfor (i = 0, p_ace = the_ace; p_ace; p_ace = p_ace->next, i++ ) {\n\t\t\tprint_canon_ace( p_ace, i);\n\t\t}\n\t}\n\n\tfor (i = 0, p_ace = the_ace; p_ace; p_ace = p_ace->next, i++ ) {\n\t\tSMB_ACL_ENTRY_T the_entry;\n\t\tSMB_ACL_PERMSET_T the_permset;\n\n\t\t/*\n\t\t * ACLs only \"need\" an ACL_MASK entry if there are any named user or\n\t\t * named group entries. But if there is an ACL_MASK entry, it applies\n\t\t * to ACL_USER, ACL_GROUP, and ACL_GROUP_OBJ entries. Set the mask\n\t\t * so that it doesn't deny (i.e., mask off) any permissions.\n\t\t */\n\n\t\tif (p_ace->type == SMB_ACL_USER || p_ace->type == SMB_ACL_GROUP) {\n\t\t\tneeds_mask = True;\n\t\t\tmask_perms |= p_ace->perms;\n\t\t} else if (p_ace->type == SMB_ACL_GROUP_OBJ) {\n\t\t\tmask_perms |= p_ace->perms;\n\t\t}\n\n\t\t/*\n\t\t * Get the entry for this ACE.\n\t\t */\n\n\t\tif (SMB_VFS_SYS_ACL_CREATE_ENTRY(conn, &the_acl, &the_entry) == -1) {\n\t\t\tDEBUG(0,(\"set_canon_ace_list: Failed to create entry %d. (%s)\\n\",\n\t\t\t\ti, strerror(errno) ));\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (p_ace->type == SMB_ACL_MASK) {\n\t\t\tmask_entry = the_entry;\n\t\t\tgot_mask_entry = True;\n\t\t}\n\n\t\t/*\n\t\t * Ok - we now know the ACL calls should be working, don't\n\t\t * allow fallback to chmod.\n\t\t */\n\n\t\t*pacl_set_support = True;\n\n\t\t/*\n\t\t * Initialise the entry from the canon_ace.\n\t\t */\n\n\t\t/*\n\t\t * First tell the entry what type of ACE this is.\n\t\t */\n\n\t\tif (SMB_VFS_SYS_ACL_SET_TAG_TYPE(conn, the_entry, p_ace->type) == -1) {\n\t\t\tDEBUG(0,(\"set_canon_ace_list: Failed to set tag type on entry %d. (%s)\\n\",\n\t\t\t\ti, strerror(errno) ));\n\t\t\tgoto fail;\n\t\t}\n\n\t\t/*\n\t\t * Only set the qualifier (user or group id) if the entry is a user\n\t\t * or group id ACE.\n\t\t */\n\n\t\tif ((p_ace->type == SMB_ACL_USER) || (p_ace->type == SMB_ACL_GROUP)) {\n\t\t\tif (SMB_VFS_SYS_ACL_SET_QUALIFIER(conn, the_entry,(void *)&p_ace->unix_ug.uid) == -1) {\n\t\t\t\tDEBUG(0,(\"set_canon_ace_list: Failed to set qualifier on entry %d. (%s)\\n\",\n\t\t\t\t\ti, strerror(errno) ));\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Convert the mode_t perms in the canon_ace to a POSIX permset.\n\t\t */\n\n\t\tif (SMB_VFS_SYS_ACL_GET_PERMSET(conn, the_entry, &the_permset) == -1) {\n\t\t\tDEBUG(0,(\"set_canon_ace_list: Failed to get permset on entry %d. (%s)\\n\",\n\t\t\t\ti, strerror(errno) ));\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (map_acl_perms_to_permset(conn, p_ace->perms, &the_permset) == -1) {\n\t\t\tDEBUG(0,(\"set_canon_ace_list: Failed to create permset for mode (%u) on entry %d. (%s)\\n\",\n\t\t\t\t(unsigned int)p_ace->perms, i, strerror(errno) ));\n\t\t\tgoto fail;\n\t\t}\n\n\t\t/*\n\t\t * ..and apply them to the entry.\n\t\t */\n\n\t\tif (SMB_VFS_SYS_ACL_SET_PERMSET(conn, the_entry, the_permset) == -1) {\n\t\t\tDEBUG(0,(\"set_canon_ace_list: Failed to add permset on entry %d. (%s)\\n\",\n\t\t\t\ti, strerror(errno) ));\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif( DEBUGLVL( 10 ))\n\t\t\tprint_canon_ace( p_ace, i);\n\n\t}\n\n\tif (needs_mask && !got_mask_entry) {\n\t\tif (SMB_VFS_SYS_ACL_CREATE_ENTRY(conn, &the_acl, &mask_entry) == -1) {\n\t\t\tDEBUG(0,(\"set_canon_ace_list: Failed to create mask entry. (%s)\\n\", strerror(errno) ));\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (SMB_VFS_SYS_ACL_SET_TAG_TYPE(conn, mask_entry, SMB_ACL_MASK) == -1) {\n\t\t\tDEBUG(0,(\"set_canon_ace_list: Failed to set tag type on mask entry. (%s)\\n\",strerror(errno) ));\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (SMB_VFS_SYS_ACL_GET_PERMSET(conn, mask_entry, &mask_permset) == -1) {\n\t\t\tDEBUG(0,(\"set_canon_ace_list: Failed to get mask permset. (%s)\\n\", strerror(errno) ));\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (map_acl_perms_to_permset(conn, S_IRUSR|S_IWUSR|S_IXUSR, &mask_permset) == -1) {\n\t\t\tDEBUG(0,(\"set_canon_ace_list: Failed to create mask permset. (%s)\\n\", strerror(errno) ));\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (SMB_VFS_SYS_ACL_SET_PERMSET(conn, mask_entry, mask_permset) == -1) {\n\t\t\tDEBUG(0,(\"set_canon_ace_list: Failed to add mask permset. (%s)\\n\", strerror(errno) ));\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t/*\n\t * Finally apply it to the file or directory.\n\t */\n\n\tif(default_ace || fsp->is_directory || fsp->fh->fd == -1) {\n\t\tif (SMB_VFS_SYS_ACL_SET_FILE(conn, fsp->fsp_name, the_acl_type, the_acl) == -1) {\n\t\t\t/*\n\t\t\t * Some systems allow all the above calls and only fail with no ACL support\n\t\t\t * when attempting to apply the acl. HPUX with HFS is an example of this. JRA.\n\t\t\t */\n\t\t\tif (no_acl_syscall_error(errno)) {\n\t\t\t\t*pacl_set_support = False;\n\t\t\t}\n\n\t\t\tif (acl_group_override(conn, prim_gid, fsp->fsp_name)) {\n\t\t\t\tint sret;\n\n\t\t\t\tDEBUG(5,(\"set_canon_ace_list: acl group control on and current user in file %s primary group.\\n\",\n\t\t\t\t\tfsp->fsp_name ));\n\n\t\t\t\tbecome_root();\n\t\t\t\tsret = SMB_VFS_SYS_ACL_SET_FILE(conn, fsp->fsp_name, the_acl_type, the_acl);\n\t\t\t\tunbecome_root();\n\t\t\t\tif (sret == 0) {\n\t\t\t\t\tret = True;\t\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ret == False) {\n\t\t\t\tDEBUG(2,(\"set_canon_ace_list: sys_acl_set_file type %s failed for file %s (%s).\\n\",\n\t\t\t\t\t\tthe_acl_type == SMB_ACL_TYPE_DEFAULT ? \"directory default\" : \"file\",\n\t\t\t\t\t\tfsp->fsp_name, strerror(errno) ));\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (SMB_VFS_SYS_ACL_SET_FD(fsp, the_acl) == -1) {\n\t\t\t/*\n\t\t\t * Some systems allow all the above calls and only fail with no ACL support\n\t\t\t * when attempting to apply the acl. HPUX with HFS is an example of this. JRA.\n\t\t\t */\n\t\t\tif (no_acl_syscall_error(errno)) {\n\t\t\t\t*pacl_set_support = False;\n\t\t\t}\n\n\t\t\tif (acl_group_override(conn, prim_gid, fsp->fsp_name)) {\n\t\t\t\tint sret;\n\n\t\t\t\tDEBUG(5,(\"set_canon_ace_list: acl group control on and current user in file %s primary group.\\n\",\n\t\t\t\t\tfsp->fsp_name ));\n\n\t\t\t\tbecome_root();\n\t\t\t\tsret = SMB_VFS_SYS_ACL_SET_FD(fsp, the_acl);\n\t\t\t\tunbecome_root();\n\t\t\t\tif (sret == 0) {\n\t\t\t\t\tret = True;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ret == False) {\n\t\t\t\tDEBUG(2,(\"set_canon_ace_list: sys_acl_set_file failed for file %s (%s).\\n\",\n\t\t\t\t\t\tfsp->fsp_name, strerror(errno) ));\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = True;\n\n  fail:\n\n\tif (the_acl != NULL) {\n\t\tSMB_VFS_SYS_ACL_FREE_ACL(conn, the_acl);\n\t}\n\n\treturn ret;\n}",
        "target": 1
    },
    {
        "func": "NTSTATUS set_nt_acl(files_struct *fsp, uint32 security_info_sent, SEC_DESC *psd)\n{\n\tconnection_struct *conn = fsp->conn;\n\tuid_t user = (uid_t)-1;\n\tgid_t grp = (gid_t)-1;\n\tSMB_STRUCT_STAT sbuf;\n\tDOM_SID file_owner_sid;\n\tDOM_SID file_grp_sid;\n\tcanon_ace *file_ace_list = NULL;\n\tcanon_ace *dir_ace_list = NULL;\n\tbool acl_perms = False;\n\tmode_t orig_mode = (mode_t)0;\n\tNTSTATUS status;\n\tbool set_acl_as_root = false;\n\tbool acl_set_support = false;\n\tbool ret = false;\n\n\tDEBUG(10,(\"set_nt_acl: called for file %s\\n\", fsp->fsp_name ));\n\n\tif (!CAN_WRITE(conn)) {\n\t\tDEBUG(10,(\"set acl rejected on read-only share\\n\"));\n\t\treturn NT_STATUS_MEDIA_WRITE_PROTECTED;\n\t}\n\n\t/*\n\t * Get the current state of the file.\n\t */\n\n\tif(fsp->is_directory || fsp->fh->fd == -1) {\n\t\tif(SMB_VFS_STAT(fsp->conn,fsp->fsp_name, &sbuf) != 0)\n\t\t\treturn map_nt_error_from_unix(errno);\n\t} else {\n\t\tif(SMB_VFS_FSTAT(fsp, &sbuf) != 0)\n\t\t\treturn map_nt_error_from_unix(errno);\n\t}\n\n\t/* Save the original element we check against. */\n\torig_mode = sbuf.st_mode;\n\n\t/*\n\t * Unpack the user/group/world id's.\n\t */\n\n\tstatus = unpack_nt_owners( SNUM(conn), &user, &grp, security_info_sent, psd);\n\tif (!NT_STATUS_IS_OK(status)) {\n\t\treturn status;\n\t}\n\n\t/*\n\t * Do we need to chown ? If so this must be done first as the incoming\n\t * CREATOR_OWNER acl will be relative to the *new* owner, not the old.\n\t * Noticed by Simo.\n\t */\n\n\tif (((user != (uid_t)-1) && (sbuf.st_uid != user)) || (( grp != (gid_t)-1) && (sbuf.st_gid != grp))) {\n\n\t\tDEBUG(3,(\"set_nt_acl: chown %s. uid = %u, gid = %u.\\n\",\n\t\t\t\tfsp->fsp_name, (unsigned int)user, (unsigned int)grp ));\n\n\t\tif(try_chown( fsp->conn, fsp->fsp_name, user, grp) == -1) {\n\t\t\tDEBUG(3,(\"set_nt_acl: chown %s, %u, %u failed. Error = %s.\\n\",\n\t\t\t\tfsp->fsp_name, (unsigned int)user, (unsigned int)grp, strerror(errno) ));\n\t\t\tif (errno == EPERM) {\n\t\t\t\treturn NT_STATUS_INVALID_OWNER;\n\t\t\t}\n\t\t\treturn map_nt_error_from_unix(errno);\n\t\t}\n\n\t\t/*\n\t\t * Recheck the current state of the file, which may have changed.\n\t\t * (suid/sgid bits, for instance)\n\t\t */\n\n\t\tif(fsp->is_directory) {\n\t\t\tif(SMB_VFS_STAT(fsp->conn, fsp->fsp_name, &sbuf) != 0) {\n\t\t\t\treturn map_nt_error_from_unix(errno);\n\t\t\t}\n\t\t} else {\n\n\t\t\tint sret;\n\n\t\t\tif(fsp->fh->fd == -1)\n\t\t\t\tsret = SMB_VFS_STAT(fsp->conn, fsp->fsp_name, &sbuf);\n\t\t\telse\n\t\t\t\tsret = SMB_VFS_FSTAT(fsp, &sbuf);\n\n\t\t\tif(sret != 0)\n\t\t\t\treturn map_nt_error_from_unix(errno);\n\t\t}\n\n\t\t/* Save the original element we check against. */\n\t\torig_mode = sbuf.st_mode;\n\n\t\t/* If we successfully chowned, we know we must\n \t\t * be able to set the acl, so do it as root.\n \t\t */\n\t\tset_acl_as_root = true;\n\t}\n\n\tcreate_file_sids(&sbuf, &file_owner_sid, &file_grp_sid);\n\n\tacl_perms = unpack_canon_ace( fsp, &sbuf, &file_owner_sid, &file_grp_sid,\n\t\t\t\t\t&file_ace_list, &dir_ace_list, security_info_sent, psd);\n\n\t/* Ignore W2K traverse DACL set. */\n\tif (!file_ace_list && !dir_ace_list) {\n\t\treturn NT_STATUS_OK;\n\t}\n\n\tif (!acl_perms) {\n\t\tDEBUG(3,(\"set_nt_acl: cannot set permissions\\n\"));\n\t\tfree_canon_ace_list(file_ace_list);\n\t\tfree_canon_ace_list(dir_ace_list);\n\t\treturn NT_STATUS_ACCESS_DENIED;\n\t}\n\n\t/*\n\t * Only change security if we got a DACL.\n\t */\n\n\tif(!(security_info_sent & DACL_SECURITY_INFORMATION) || (psd->dacl == NULL)) {\n\t\tfree_canon_ace_list(file_ace_list);\n\t\tfree_canon_ace_list(dir_ace_list);\n\t\treturn NT_STATUS_OK;\n\t}\n\n\t/*\n\t * Try using the POSIX ACL set first. Fall back to chmod if\n\t * we have no ACL support on this filesystem.\n\t */\n\n\tif (acl_perms && file_ace_list) {\n\t\tif (set_acl_as_root) {\n\t\t\tbecome_root();\n\t\t}\n\t\tret = set_canon_ace_list(fsp, file_ace_list, False, sbuf.st_gid, &acl_set_support);\n\t\tif (set_acl_as_root) {\n\t\t\tunbecome_root();\n\t\t}\n\t\tif (acl_set_support && ret == false) {\n\t\t\tDEBUG(3,(\"set_nt_acl: failed to set file acl on file %s (%s).\\n\", fsp->fsp_name, strerror(errno) ));\n\t\t\tfree_canon_ace_list(file_ace_list);\n\t\t\tfree_canon_ace_list(dir_ace_list);\n\t\t\treturn map_nt_error_from_unix(errno);\n\t\t}\n\t}\n\n\tif (acl_perms && acl_set_support && fsp->is_directory) {\n\t\tif (dir_ace_list) {\n\t\t\tif (set_acl_as_root) {\n\t\t\t\tbecome_root();\n\t\t\t}\n\t\t\tret = set_canon_ace_list(fsp, dir_ace_list, True, sbuf.st_gid, &acl_set_support);\n\t\t\tif (set_acl_as_root) {\n\t\t\t\tunbecome_root();\n\t\t\t}\n\t\t\tif (ret == false) {\n\t\t\t\tDEBUG(3,(\"set_nt_acl: failed to set default acl on directory %s (%s).\\n\", fsp->fsp_name, strerror(errno) ));\n\t\t\t\tfree_canon_ace_list(file_ace_list);\n\t\t\t\tfree_canon_ace_list(dir_ace_list);\n\t\t\t\treturn map_nt_error_from_unix(errno);\n\t\t\t}\n\t\t} else {\n\t\t\tint sret = -1;\n\n\t\t\t/*\n\t\t\t * No default ACL - delete one if it exists.\n\t\t\t */\n\n\t\t\tif (set_acl_as_root) {\n\t\t\t\tbecome_root();\n\t\t\t}\n\t\t\tsret = SMB_VFS_SYS_ACL_DELETE_DEF_FILE(conn, fsp->fsp_name);\n\t\t\tif (set_acl_as_root) {\n\t\t\t\tunbecome_root();\n\t\t\t}\n\t\t\tif (sret == -1) {\n\t\t\t\tif (acl_group_override(conn, sbuf.st_gid, fsp->fsp_name)) {\n\t\t\t\t\tDEBUG(5,(\"set_nt_acl: acl group control on and \"\n\t\t\t\t\t\t\"current user in file %s primary group. Override delete_def_acl\\n\",\n\t\t\t\t\t\tfsp->fsp_name ));\n\n\t\t\t\t\tbecome_root();\n\t\t\t\t\tsret = SMB_VFS_SYS_ACL_DELETE_DEF_FILE(conn, fsp->fsp_name);\n\t\t\t\t\tunbecome_root();\n\t\t\t\t}\n\n\t\t\t\tif (sret == -1) {\n\t\t\t\t\tDEBUG(3,(\"set_nt_acl: sys_acl_delete_def_file failed (%s)\\n\", strerror(errno)));\n\t\t\t\t\tfree_canon_ace_list(file_ace_list);\n\t\t\t\t\tfree_canon_ace_list(dir_ace_list);\n\t\t\t\t\treturn map_nt_error_from_unix(errno);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (acl_set_support) {\n\t\tif (set_acl_as_root) {\n\t\t\tbecome_root();\n\t\t}\n\t\tstore_inheritance_attributes(fsp, file_ace_list, dir_ace_list,\n\t\t\t\t(psd->type & SE_DESC_DACL_PROTECTED) ? True : False);\n\t\tif (set_acl_as_root) {\n\t\t\tunbecome_root();\n\t\t}\n\t}\n\n\t/*\n\t * If we cannot set using POSIX ACLs we fall back to checking if we need to chmod.\n\t */\n\n\tif(!acl_set_support && acl_perms) {\n\t\tmode_t posix_perms;\n\n\t\tif (!convert_canon_ace_to_posix_perms( fsp, file_ace_list, &posix_perms)) {\n\t\t\tfree_canon_ace_list(file_ace_list);\n\t\t\tfree_canon_ace_list(dir_ace_list);\n\t\t\tDEBUG(3,(\"set_nt_acl: failed to convert file acl to posix permissions for file %s.\\n\",\n\t\t\t\tfsp->fsp_name ));\n\t\t\treturn NT_STATUS_ACCESS_DENIED;\n\t\t}\n\n\t\tif (orig_mode != posix_perms) {\n\t\t\tint sret = -1;\n\n\t\t\tDEBUG(3,(\"set_nt_acl: chmod %s. perms = 0%o.\\n\",\n\t\t\t\tfsp->fsp_name, (unsigned int)posix_perms ));\n\n\t\t\tif (set_acl_as_root) {\n\t\t\t\tbecome_root();\n\t\t\t}\n\t\t\tsret = SMB_VFS_CHMOD(conn,fsp->fsp_name, posix_perms);\n\t\t\tif (set_acl_as_root) {\n\t\t\t\tunbecome_root();\n\t\t\t}\n\t\t\tif(sret == -1) {\n\t\t\t\tif (acl_group_override(conn, sbuf.st_gid, fsp->fsp_name)) {\n\t\t\t\t\tDEBUG(5,(\"set_nt_acl: acl group control on and \"\n\t\t\t\t\t\t\"current user in file %s primary group. Override chmod\\n\",\n\t\t\t\t\t\tfsp->fsp_name ));\n\n\t\t\t\t\tbecome_root();\n\t\t\t\t\tsret = SMB_VFS_CHMOD(conn,fsp->fsp_name, posix_perms);\n\t\t\t\t\tunbecome_root();\n\t\t\t\t}\n\n\t\t\t\tif (sret == -1) {\n\t\t\t\t\tDEBUG(3,(\"set_nt_acl: chmod %s, 0%o failed. Error = %s.\\n\",\n\t\t\t\t\t\tfsp->fsp_name, (unsigned int)posix_perms, strerror(errno) ));\n\t\t\t\t\tfree_canon_ace_list(file_ace_list);\n\t\t\t\t\tfree_canon_ace_list(dir_ace_list);\n\t\t\t\t\treturn map_nt_error_from_unix(errno);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfree_canon_ace_list(file_ace_list);\n\tfree_canon_ace_list(dir_ace_list);\n\treturn NT_STATUS_OK;\n}",
        "target": 1
    },
    {
        "func": "static unsigned int tun_chr_poll(struct file *file, poll_table * wait)\n{\n\tstruct tun_file *tfile = file->private_data;\n\tstruct tun_struct *tun = __tun_get(tfile);\n\tstruct sock *sk = tun->sk;\n\tunsigned int mask = 0;\n\n\tif (!tun)\n\t\treturn POLLERR;\n\n\tDBG(KERN_INFO \"%s: tun_chr_poll\\n\", tun->dev->name);\n\n\tpoll_wait(file, &tun->socket.wait, wait);\n\n\tif (!skb_queue_empty(&tun->readq))\n\t\tmask |= POLLIN | POLLRDNORM;\n\n\tif (sock_writeable(sk) ||\n\t    (!test_and_set_bit(SOCK_ASYNC_NOSPACE, &sk->sk_socket->flags) &&\n\t     sock_writeable(sk)))\n\t\tmask |= POLLOUT | POLLWRNORM;\n\n\tif (tun->dev->reg_state != NETREG_REGISTERED)\n\t\tmask = POLLERR;\n\n\ttun_put(tun);\n\treturn mask;\n}",
        "target": 1
    },
    {
        "func": "int kvm_arch_vcpu_ioctl_set_sregs(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_sregs *sregs)\n{\n\tint mmu_reset_needed = 0;\n\tint i, pending_vec, max_bits;\n\tstruct descriptor_table dt;\n\n\tvcpu_load(vcpu);\n\n\tdt.limit = sregs->idt.limit;\n\tdt.base = sregs->idt.base;\n\tkvm_x86_ops->set_idt(vcpu, &dt);\n\tdt.limit = sregs->gdt.limit;\n\tdt.base = sregs->gdt.base;\n\tkvm_x86_ops->set_gdt(vcpu, &dt);\n\n\tvcpu->arch.cr2 = sregs->cr2;\n\tmmu_reset_needed |= vcpu->arch.cr3 != sregs->cr3;\n\tvcpu->arch.cr3 = sregs->cr3;\n\n\tkvm_set_cr8(vcpu, sregs->cr8);\n\n\tmmu_reset_needed |= vcpu->arch.shadow_efer != sregs->efer;\n\tkvm_x86_ops->set_efer(vcpu, sregs->efer);\n\tkvm_set_apic_base(vcpu, sregs->apic_base);\n\n\tkvm_x86_ops->decache_cr4_guest_bits(vcpu);\n\n\tmmu_reset_needed |= vcpu->arch.cr0 != sregs->cr0;\n\tkvm_x86_ops->set_cr0(vcpu, sregs->cr0);\n\tvcpu->arch.cr0 = sregs->cr0;\n\n\tmmu_reset_needed |= vcpu->arch.cr4 != sregs->cr4;\n\tkvm_x86_ops->set_cr4(vcpu, sregs->cr4);\n\tif (!is_long_mode(vcpu) && is_pae(vcpu))\n\t\tload_pdptrs(vcpu, vcpu->arch.cr3);\n\n\tif (mmu_reset_needed)\n\t\tkvm_mmu_reset_context(vcpu);\n\n\tif (!irqchip_in_kernel(vcpu->kvm)) {\n\t\tmemcpy(vcpu->arch.irq_pending, sregs->interrupt_bitmap,\n\t\t       sizeof vcpu->arch.irq_pending);\n\t\tvcpu->arch.irq_summary = 0;\n\t\tfor (i = 0; i < ARRAY_SIZE(vcpu->arch.irq_pending); ++i)\n\t\t\tif (vcpu->arch.irq_pending[i])\n\t\t\t\t__set_bit(i, &vcpu->arch.irq_summary);\n\t} else {\n\t\tmax_bits = (sizeof sregs->interrupt_bitmap) << 3;\n\t\tpending_vec = find_first_bit(\n\t\t\t(const unsigned long *)sregs->interrupt_bitmap,\n\t\t\tmax_bits);\n\t\t/* Only pending external irq is handled here */\n\t\tif (pending_vec < max_bits) {\n\t\t\tkvm_x86_ops->set_irq(vcpu, pending_vec);\n\t\t\tpr_debug(\"Set back pending irq %d\\n\",\n\t\t\t\t pending_vec);\n\t\t}\n\t\tkvm_pic_clear_isr_ack(vcpu->kvm);\n\t}\n\n\tkvm_set_segment(vcpu, &sregs->cs, VCPU_SREG_CS);\n\tkvm_set_segment(vcpu, &sregs->ds, VCPU_SREG_DS);\n\tkvm_set_segment(vcpu, &sregs->es, VCPU_SREG_ES);\n\tkvm_set_segment(vcpu, &sregs->fs, VCPU_SREG_FS);\n\tkvm_set_segment(vcpu, &sregs->gs, VCPU_SREG_GS);\n\tkvm_set_segment(vcpu, &sregs->ss, VCPU_SREG_SS);\n\n\tkvm_set_segment(vcpu, &sregs->tr, VCPU_SREG_TR);\n\tkvm_set_segment(vcpu, &sregs->ldt, VCPU_SREG_LDTR);\n\n\t/* Older userspace won't unhalt the vcpu on reset. */\n\tif (vcpu->vcpu_id == 0 && kvm_rip_read(vcpu) == 0xfff0 &&\n\t    sregs->cs.selector == 0xf000 && sregs->cs.base == 0xffff0000 &&\n\t    !(vcpu->arch.cr0 & X86_CR0_PE))\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n\n\tvcpu_put(vcpu);\n\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "parse_tag_11_packet(unsigned char *data, unsigned char *contents,\n\t\t    size_t max_contents_bytes, size_t *tag_11_contents_size,\n\t\t    size_t *packet_size, size_t max_packet_size)\n{\n\tsize_t body_size;\n\tsize_t length_size;\n\tint rc = 0;\n\n\t(*packet_size) = 0;\n\t(*tag_11_contents_size) = 0;\n\t/* This format is inspired by OpenPGP; see RFC 2440\n\t * packet tag 11\n\t *\n\t * Tag 11 identifier (1 byte)\n\t * Max Tag 11 packet size (max 3 bytes)\n\t * Binary format specifier (1 byte)\n\t * Filename length (1 byte)\n\t * Filename (\"_CONSOLE\") (8 bytes)\n\t * Modification date (4 bytes)\n\t * Literal data (arbitrary)\n\t *\n\t * We need at least 16 bytes of data for the packet to even be\n\t * valid.\n\t */\n\tif (max_packet_size < 16) {\n\t\tprintk(KERN_ERR \"Maximum packet size too small\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (data[(*packet_size)++] != ECRYPTFS_TAG_11_PACKET_TYPE) {\n\t\tprintk(KERN_WARNING \"Invalid tag 11 packet format\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\trc = ecryptfs_parse_packet_length(&data[(*packet_size)], &body_size,\n\t\t\t\t\t  &length_size);\n\tif (rc) {\n\t\tprintk(KERN_WARNING \"Invalid tag 11 packet format\\n\");\n\t\tgoto out;\n\t}\n\tif (body_size < 14) {\n\t\tprintk(KERN_WARNING \"Invalid body size ([%td])\\n\", body_size);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\t(*packet_size) += length_size;\n\t(*tag_11_contents_size) = (body_size - 14);\n\tif (unlikely((*packet_size) + body_size + 1 > max_packet_size)) {\n\t\tprintk(KERN_ERR \"Packet size exceeds max\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (data[(*packet_size)++] != 0x62) {\n\t\tprintk(KERN_WARNING \"Unrecognizable packet\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (data[(*packet_size)++] != 0x08) {\n\t\tprintk(KERN_WARNING \"Unrecognizable packet\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\t(*packet_size) += 12; /* Ignore filename and modification date */\n\tmemcpy(contents, &data[(*packet_size)], (*tag_11_contents_size));\n\t(*packet_size) += (*tag_11_contents_size);\nout:\n\tif (rc) {\n\t\t(*packet_size) = 0;\n\t\t(*tag_11_contents_size) = 0;\n\t}\n\treturn rc;\n}",
        "target": 1
    },
    {
        "func": "parse_tag_3_packet(struct ecryptfs_crypt_stat *crypt_stat,\n\t\t   unsigned char *data, struct list_head *auth_tok_list,\n\t\t   struct ecryptfs_auth_tok **new_auth_tok,\n\t\t   size_t *packet_size, size_t max_packet_size)\n{\n\tsize_t body_size;\n\tstruct ecryptfs_auth_tok_list_item *auth_tok_list_item;\n\tsize_t length_size;\n\tint rc = 0;\n\n\t(*packet_size) = 0;\n\t(*new_auth_tok) = NULL;\n\t/**\n\t *This format is inspired by OpenPGP; see RFC 2440\n\t * packet tag 3\n\t *\n\t * Tag 3 identifier (1 byte)\n\t * Max Tag 3 packet size (max 3 bytes)\n\t * Version (1 byte)\n\t * Cipher code (1 byte)\n\t * S2K specifier (1 byte)\n\t * Hash identifier (1 byte)\n\t * Salt (ECRYPTFS_SALT_SIZE)\n\t * Hash iterations (1 byte)\n\t * Encrypted key (arbitrary)\n\t *\n\t * (ECRYPTFS_SALT_SIZE + 7) minimum packet size\n\t */\n\tif (max_packet_size < (ECRYPTFS_SALT_SIZE + 7)) {\n\t\tprintk(KERN_ERR \"Max packet size too large\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (data[(*packet_size)++] != ECRYPTFS_TAG_3_PACKET_TYPE) {\n\t\tprintk(KERN_ERR \"First byte != 0x%.2x; invalid packet\\n\",\n\t\t       ECRYPTFS_TAG_3_PACKET_TYPE);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\t/* Released: wipe_auth_tok_list called in ecryptfs_parse_packet_set or\n\t * at end of function upon failure */\n\tauth_tok_list_item =\n\t    kmem_cache_zalloc(ecryptfs_auth_tok_list_item_cache, GFP_KERNEL);\n\tif (!auth_tok_list_item) {\n\t\tprintk(KERN_ERR \"Unable to allocate memory\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\t(*new_auth_tok) = &auth_tok_list_item->auth_tok;\n\trc = ecryptfs_parse_packet_length(&data[(*packet_size)], &body_size,\n\t\t\t\t\t  &length_size);\n\tif (rc) {\n\t\tprintk(KERN_WARNING \"Error parsing packet length; rc = [%d]\\n\",\n\t\t       rc);\n\t\tgoto out_free;\n\t}\n\tif (unlikely(body_size < (ECRYPTFS_SALT_SIZE + 5))) {\n\t\tprintk(KERN_WARNING \"Invalid body size ([%td])\\n\", body_size);\n\t\trc = -EINVAL;\n\t\tgoto out_free;\n\t}\n\t(*packet_size) += length_size;\n\tif (unlikely((*packet_size) + body_size > max_packet_size)) {\n\t\tprintk(KERN_ERR \"Packet size exceeds max\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out_free;\n\t}\n\t(*new_auth_tok)->session_key.encrypted_key_size =\n\t\t(body_size - (ECRYPTFS_SALT_SIZE + 5));\n\tif (unlikely(data[(*packet_size)++] != 0x04)) {\n\t\tprintk(KERN_WARNING \"Unknown version number [%d]\\n\",\n\t\t       data[(*packet_size) - 1]);\n\t\trc = -EINVAL;\n\t\tgoto out_free;\n\t}\n\tecryptfs_cipher_code_to_string(crypt_stat->cipher,\n\t\t\t\t       (u16)data[(*packet_size)]);\n\t/* A little extra work to differentiate among the AES key\n\t * sizes; see RFC2440 */\n\tswitch(data[(*packet_size)++]) {\n\tcase RFC2440_CIPHER_AES_192:\n\t\tcrypt_stat->key_size = 24;\n\t\tbreak;\n\tdefault:\n\t\tcrypt_stat->key_size =\n\t\t\t(*new_auth_tok)->session_key.encrypted_key_size;\n\t}\n\tecryptfs_init_crypt_ctx(crypt_stat);\n\tif (unlikely(data[(*packet_size)++] != 0x03)) {\n\t\tprintk(KERN_WARNING \"Only S2K ID 3 is currently supported\\n\");\n\t\trc = -ENOSYS;\n\t\tgoto out_free;\n\t}\n\t/* TODO: finish the hash mapping */\n\tswitch (data[(*packet_size)++]) {\n\tcase 0x01: /* See RFC2440 for these numbers and their mappings */\n\t\t/* Choose MD5 */\n\t\tmemcpy((*new_auth_tok)->token.password.salt,\n\t\t       &data[(*packet_size)], ECRYPTFS_SALT_SIZE);\n\t\t(*packet_size) += ECRYPTFS_SALT_SIZE;\n\t\t/* This conversion was taken straight from RFC2440 */\n\t\t(*new_auth_tok)->token.password.hash_iterations =\n\t\t\t((u32) 16 + (data[(*packet_size)] & 15))\n\t\t\t\t<< ((data[(*packet_size)] >> 4) + 6);\n\t\t(*packet_size)++;\n\t\t/* Friendly reminder:\n\t\t * (*new_auth_tok)->session_key.encrypted_key_size =\n\t\t *         (body_size - (ECRYPTFS_SALT_SIZE + 5)); */\n\t\tmemcpy((*new_auth_tok)->session_key.encrypted_key,\n\t\t       &data[(*packet_size)],\n\t\t       (*new_auth_tok)->session_key.encrypted_key_size);\n\t\t(*packet_size) +=\n\t\t\t(*new_auth_tok)->session_key.encrypted_key_size;\n\t\t(*new_auth_tok)->session_key.flags &=\n\t\t\t~ECRYPTFS_CONTAINS_DECRYPTED_KEY;\n\t\t(*new_auth_tok)->session_key.flags |=\n\t\t\tECRYPTFS_CONTAINS_ENCRYPTED_KEY;\n\t\t(*new_auth_tok)->token.password.hash_algo = 0x01; /* MD5 */\n\t\tbreak;\n\tdefault:\n\t\tecryptfs_printk(KERN_ERR, \"Unsupported hash algorithm: \"\n\t\t\t\t\"[%d]\\n\", data[(*packet_size) - 1]);\n\t\trc = -ENOSYS;\n\t\tgoto out_free;\n\t}\n\t(*new_auth_tok)->token_type = ECRYPTFS_PASSWORD;\n\t/* TODO: Parametarize; we might actually want userspace to\n\t * decrypt the session key. */\n\t(*new_auth_tok)->session_key.flags &=\n\t\t\t    ~(ECRYPTFS_USERSPACE_SHOULD_TRY_TO_DECRYPT);\n\t(*new_auth_tok)->session_key.flags &=\n\t\t\t    ~(ECRYPTFS_USERSPACE_SHOULD_TRY_TO_ENCRYPT);\n\tlist_add(&auth_tok_list_item->list, auth_tok_list);\n\tgoto out;\nout_free:\n\t(*new_auth_tok) = NULL;\n\tmemset(auth_tok_list_item, 0,\n\t       sizeof(struct ecryptfs_auth_tok_list_item));\n\tkmem_cache_free(ecryptfs_auth_tok_list_item_cache,\n\t\t\tauth_tok_list_item);\nout:\n\tif (rc)\n\t\t(*packet_size) = 0;\n\treturn rc;\n}",
        "target": 1
    },
    {
        "func": "int huft_build(b, n, s, d, e, t, m)\nunsigned *b;            /* code lengths in bits (all assumed <= BMAX) */\nunsigned n;             /* number of codes (assumed <= N_MAX) */\nunsigned s;             /* number of simple-valued codes (0..s-1) */\nush *d;                 /* list of base values for non-simple codes */\nush *e;                 /* list of extra bits for non-simple codes */\nstruct huft **t;        /* result: starting table */\nint *m;                 /* maximum lookup bits, returns actual */\n/* Given a list of code lengths and a maximum table size, make a set of\n   tables to decode that set of codes.  Return zero on success, one if\n   the given code set is incomplete (the tables are still built in this\n   case), two if the input is invalid (all zero length codes or an\n   oversubscribed set of lengths), and three if not enough memory. */\n{\n  unsigned a;                   /* counter for codes of length k */\n  unsigned c[BMAX+1];           /* bit length count table */\n  unsigned f;                   /* i repeats in table every f entries */\n  int g;                        /* maximum code length */\n  int h;                        /* table level */\n  register unsigned i;          /* counter, current code */\n  register unsigned j;          /* counter */\n  register int k;               /* number of bits in current code */\n  int l;                        /* bits per table (returned in m) */\n  register unsigned *p;         /* pointer into c[], b[], or v[] */\n  register struct huft *q;      /* points to current table */\n  struct huft r;                /* table entry for structure assignment */\n  struct huft *u[BMAX];         /* table stack */\n  unsigned v[N_MAX];            /* values in order of bit length */\n  register int w;               /* bits before this table == (l * h) */\n  unsigned x[BMAX+1];           /* bit offsets, then code stack */\n  unsigned *xp;                 /* pointer into x */\n  int y;                        /* number of dummy codes added */\n  unsigned z;                   /* number of entries in current table */\n\n\n  /* Generate counts for each bit length */\n  memzero(c, sizeof(c));\n  p = b;  i = n;\n  do {\n    Tracecv(*p, (stderr, (n-i >= ' ' && n-i <= '~' ? \"%c %d\\n\" : \"0x%x %d\\n\"),\n\t    n-i, *p));\n    c[*p]++;                    /* assume all entries <= BMAX */\n    p++;                      /* Can't combine with above line (Solaris bug) */\n  } while (--i);\n  if (c[0] == n)                /* null input--all zero length codes */\n  {\n    q = (struct huft *) malloc (2 * sizeof *q);\n    if (!q)\n      return 3;\n    hufts += 2;\n    q[0].v.t = (struct huft *) NULL;\n    q[1].e = 99;    /* invalid code marker */\n    q[1].b = 1;\n    *t = q + 1;\n    *m = 1;\n    return 0;\n  }\n\n\n  /* Find minimum and maximum length, bound *m by those */\n  l = *m;\n  for (j = 1; j <= BMAX; j++)\n    if (c[j])\n      break;\n  k = j;                        /* minimum code length */\n  if ((unsigned)l < j)\n    l = j;\n  for (i = BMAX; i; i--)\n    if (c[i])\n      break;\n  g = i;                        /* maximum code length */\n  if ((unsigned)l > i)\n    l = i;\n  *m = l;\n\n\n  /* Adjust last length count to fill out codes, if needed */\n  for (y = 1 << j; j < i; j++, y <<= 1)\n    if ((y -= c[j]) < 0)\n      return 2;                 /* bad input: more codes than bits */\n  if ((y -= c[i]) < 0)\n    return 2;\n  c[i] += y;\n\n\n  /* Generate starting offsets into the value table for each length */\n  x[1] = j = 0;\n  p = c + 1;  xp = x + 2;\n  while (--i) {                 /* note that i == g from above */\n    *xp++ = (j += *p++);\n  }\n\n\n  /* Make a table of values in order of bit lengths */\n  p = b;  i = 0;\n  do {\n    if ((j = *p++) != 0)\n      v[x[j]++] = i;\n  } while (++i < n);\n  n = x[g];                   /* set n to length of v */\n\n\n  /* Generate the Huffman codes and for each, make the table entries */\n  x[0] = i = 0;                 /* first Huffman code is zero */\n  p = v;                        /* grab values in bit order */\n  h = -1;                       /* no tables yet--level -1 */\n  w = -l;                       /* bits decoded == (l * h) */\n  u[0] = (struct huft *)NULL;   /* just to keep compilers happy */\n  q = (struct huft *)NULL;      /* ditto */\n  z = 0;                        /* ditto */\n\n  /* go through the bit lengths (k already is bits in shortest code) */\n  for (; k <= g; k++)\n  {\n    a = c[k];\n    while (a--)\n    {\n      /* here i is the Huffman code of length k bits for value *p */\n      /* make tables up to required level */\n      while (k > w + l)\n      {\n        h++;\n        w += l;                 /* previous table always l bits */\n\n        /* compute minimum size table less than or equal to l bits */\n        z = (z = g - w) > (unsigned)l ? l : z;  /* upper limit on table size */\n        if ((f = 1 << (j = k - w)) > a + 1)     /* try a k-w bit table */\n        {                       /* too few codes for k-w bit table */\n          f -= a + 1;           /* deduct codes from patterns left */\n          xp = c + k;\n\t  if (j < z)\n\t    while (++j < z)       /* try smaller tables up to z bits */\n\t    {\n\t      if ((f <<= 1) <= *++xp)\n\t\tbreak;            /* enough codes to use up j bits */\n\t      f -= *xp;           /* else deduct codes from patterns */\n\t    }\n        }\n        z = 1 << j;             /* table entries for j-bit table */\n\n        /* allocate and link in new table */\n        if ((q = (struct huft *)malloc((z + 1)*sizeof(struct huft))) ==\n            (struct huft *)NULL)\n        {\n          if (h)\n            huft_free(u[0]);\n          return 3;             /* not enough memory */\n        }\n        hufts += z + 1;         /* track memory usage */\n        *t = q + 1;             /* link to list for huft_free() */\n        *(t = &(q->v.t)) = (struct huft *)NULL;\n        u[h] = ++q;             /* table starts after link */\n\n        /* connect to last table, if there is one */\n        if (h)\n        {\n          x[h] = i;             /* save pattern for backing up */\n          r.b = (uch)l;         /* bits to dump before this table */\n          r.e = (uch)(16 + j);  /* bits in this table */\n          r.v.t = q;            /* pointer to this table */\n          j = i >> (w - l);     /* (get around Turbo C bug) */\n          u[h-1][j] = r;        /* connect to last table */\n        }\n      }\n\n      /* set up table entry in r */\n      r.b = (uch)(k - w);\n      if (p >= v + n)\n        r.e = 99;               /* out of values--invalid code */\n      else if (*p < s)\n      {\n        r.e = (uch)(*p < 256 ? 16 : 15);    /* 256 is end-of-block code */\n        r.v.n = (ush)(*p);             /* simple code is just the value */\n\tp++;                           /* one compiler does not like *p++ */\n      }\n      else\n      {\n        r.e = (uch)e[*p - s];   /* non-simple--look up in lists */\n        r.v.n = d[*p++ - s];\n      }\n\n      /* fill code-like entries with r */\n      f = 1 << (k - w);\n      for (j = i >> w; j < z; j += f)\n        q[j] = r;\n\n      /* backwards increment the k-bit code i */\n      for (j = 1 << (k - 1); i & j; j >>= 1)\n        i ^= j;\n      i ^= j;\n\n      /* backup over finished tables */\n      while ((i & ((1 << w) - 1)) != x[h])\n      {\n        h--;                    /* don't need to update q */\n        w -= l;\n      }\n    }\n  }\n\n\n  /* Return true (1) if we were given an incomplete table */\n  return y != 0 && g != 1;\n}",
        "target": 1
    },
    {
        "func": "do_sigaltstack (const stack_t __user *uss, stack_t __user *uoss, unsigned long sp)\n{\n\tstack_t oss;\n\tint error;\n\n\tif (uoss) {\n\t\toss.ss_sp = (void __user *) current->sas_ss_sp;\n\t\toss.ss_size = current->sas_ss_size;\n\t\toss.ss_flags = sas_ss_flags(sp);\n\t}\n\n\tif (uss) {\n\t\tvoid __user *ss_sp;\n\t\tsize_t ss_size;\n\t\tint ss_flags;\n\n\t\terror = -EFAULT;\n\t\tif (!access_ok(VERIFY_READ, uss, sizeof(*uss))\n\t\t    || __get_user(ss_sp, &uss->ss_sp)\n\t\t    || __get_user(ss_flags, &uss->ss_flags)\n\t\t    || __get_user(ss_size, &uss->ss_size))\n\t\t\tgoto out;\n\n\t\terror = -EPERM;\n\t\tif (on_sig_stack(sp))\n\t\t\tgoto out;\n\n\t\terror = -EINVAL;\n\t\t/*\n\t\t *\n\t\t * Note - this code used to test ss_flags incorrectly\n\t\t *  \t  old code may have been written using ss_flags==0\n\t\t *\t  to mean ss_flags==SS_ONSTACK (as this was the only\n\t\t *\t  way that worked) - this fix preserves that older\n\t\t *\t  mechanism\n\t\t */\n\t\tif (ss_flags != SS_DISABLE && ss_flags != SS_ONSTACK && ss_flags != 0)\n\t\t\tgoto out;\n\n\t\tif (ss_flags == SS_DISABLE) {\n\t\t\tss_size = 0;\n\t\t\tss_sp = NULL;\n\t\t} else {\n\t\t\terror = -ENOMEM;\n\t\t\tif (ss_size < MINSIGSTKSZ)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tcurrent->sas_ss_sp = (unsigned long) ss_sp;\n\t\tcurrent->sas_ss_size = ss_size;\n\t}\n\n\tif (uoss) {\n\t\terror = -EFAULT;\n\t\tif (copy_to_user(uoss, &oss, sizeof(oss)))\n\t\t\tgoto out;\n\t}\n\n\terror = 0;\nout:\n\treturn error;\n}",
        "target": 1
    },
    {
        "func": "int udp_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\n\t\tsize_t len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct udp_sock *up = udp_sk(sk);\n\tint ulen = len;\n\tstruct ipcm_cookie ipc;\n\tstruct rtable *rt = NULL;\n\tint free = 0;\n\tint connected = 0;\n\t__be32 daddr, faddr, saddr;\n\t__be16 dport;\n\tu8  tos;\n\tint err;\n\tint corkreq = up->corkflag || msg->msg_flags&MSG_MORE;\n\n\tif (len > 0xFFFF)\n\t\treturn -EMSGSIZE;\n\n\t/* \n\t *\tCheck the flags.\n\t */\n\n\tif (msg->msg_flags&MSG_OOB)\t/* Mirror BSD error message compatibility */\n\t\treturn -EOPNOTSUPP;\n\n\tipc.opt = NULL;\n\n\tif (up->pending) {\n\t\t/*\n\t\t * There are pending frames.\n\t \t * The socket lock must be held while it's corked.\n\t\t */\n\t\tlock_sock(sk);\n\t\tif (likely(up->pending)) {\n\t\t\tif (unlikely(up->pending != AF_INET)) {\n\t\t\t\trelease_sock(sk);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n \t\t\tgoto do_append_data;\n\t\t}\n\t\trelease_sock(sk);\n\t}\n\tulen += sizeof(struct udphdr);\n\n\t/*\n\t *\tGet and verify the address. \n\t */\n\tif (msg->msg_name) {\n\t\tstruct sockaddr_in * usin = (struct sockaddr_in*)msg->msg_name;\n\t\tif (msg->msg_namelen < sizeof(*usin))\n\t\t\treturn -EINVAL;\n\t\tif (usin->sin_family != AF_INET) {\n\t\t\tif (usin->sin_family != AF_UNSPEC)\n\t\t\t\treturn -EAFNOSUPPORT;\n\t\t}\n\n\t\tdaddr = usin->sin_addr.s_addr;\n\t\tdport = usin->sin_port;\n\t\tif (dport == 0)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -EDESTADDRREQ;\n\t\tdaddr = inet->daddr;\n\t\tdport = inet->dport;\n\t\t/* Open fast path for connected socket.\n\t\t   Route will not be used, if at least one option is set.\n\t\t */\n\t\tconnected = 1;\n  \t}\n\tipc.addr = inet->saddr;\n\n\tipc.oif = sk->sk_bound_dev_if;\n\tif (msg->msg_controllen) {\n\t\terr = ip_cmsg_send(msg, &ipc);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (ipc.opt)\n\t\t\tfree = 1;\n\t\tconnected = 0;\n\t}\n\tif (!ipc.opt)\n\t\tipc.opt = inet->opt;\n\n\tsaddr = ipc.addr;\n\tipc.addr = faddr = daddr;\n\n\tif (ipc.opt && ipc.opt->srr) {\n\t\tif (!daddr)\n\t\t\treturn -EINVAL;\n\t\tfaddr = ipc.opt->faddr;\n\t\tconnected = 0;\n\t}\n\ttos = RT_TOS(inet->tos);\n\tif (sock_flag(sk, SOCK_LOCALROUTE) ||\n\t    (msg->msg_flags & MSG_DONTROUTE) || \n\t    (ipc.opt && ipc.opt->is_strictroute)) {\n\t\ttos |= RTO_ONLINK;\n\t\tconnected = 0;\n\t}\n\n\tif (MULTICAST(daddr)) {\n\t\tif (!ipc.oif)\n\t\t\tipc.oif = inet->mc_index;\n\t\tif (!saddr)\n\t\t\tsaddr = inet->mc_addr;\n\t\tconnected = 0;\n\t}\n\n\tif (connected)\n\t\trt = (struct rtable*)sk_dst_check(sk, 0);\n\n\tif (rt == NULL) {\n\t\tstruct flowi fl = { .oif = ipc.oif,\n\t\t\t\t    .nl_u = { .ip4_u =\n\t\t\t\t\t      { .daddr = faddr,\n\t\t\t\t\t\t.saddr = saddr,\n\t\t\t\t\t\t.tos = tos } },\n\t\t\t\t    .proto = IPPROTO_UDP,\n\t\t\t\t    .uli_u = { .ports =\n\t\t\t\t\t       { .sport = inet->sport,\n\t\t\t\t\t\t .dport = dport } } };\n\t\tsecurity_sk_classify_flow(sk, &fl);\n\t\terr = ip_route_output_flow(&rt, &fl, sk, !(msg->msg_flags&MSG_DONTWAIT));\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = -EACCES;\n\t\tif ((rt->rt_flags & RTCF_BROADCAST) &&\n\t\t    !sock_flag(sk, SOCK_BROADCAST))\n\t\t\tgoto out;\n\t\tif (connected)\n\t\t\tsk_dst_set(sk, dst_clone(&rt->u.dst));\n\t}\n\n\tif (msg->msg_flags&MSG_CONFIRM)\n\t\tgoto do_confirm;\nback_from_confirm:\n\n\tsaddr = rt->rt_src;\n\tif (!ipc.addr)\n\t\tdaddr = ipc.addr = rt->rt_dst;\n\n\tlock_sock(sk);\n\tif (unlikely(up->pending)) {\n\t\t/* The socket is already corked while preparing it. */\n\t\t/* ... which is an evident application bug. --ANK */\n\t\trelease_sock(sk);\n\n\t\tLIMIT_NETDEBUG(KERN_DEBUG \"udp cork app bug 2\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\t/*\n\t *\tNow cork the socket to pend data.\n\t */\n\tinet->cork.fl.fl4_dst = daddr;\n\tinet->cork.fl.fl_ip_dport = dport;\n\tinet->cork.fl.fl4_src = saddr;\n\tinet->cork.fl.fl_ip_sport = inet->sport;\n\tup->pending = AF_INET;\n\ndo_append_data:\n\tup->len += ulen;\n\terr = ip_append_data(sk, ip_generic_getfrag, msg->msg_iov, ulen, \n\t\t\tsizeof(struct udphdr), &ipc, rt, \n\t\t\tcorkreq ? msg->msg_flags|MSG_MORE : msg->msg_flags);\n\tif (err)\n\t\tudp_flush_pending_frames(sk);\n\telse if (!corkreq)\n\t\terr = udp_push_pending_frames(sk, up);\n\trelease_sock(sk);\n\nout:\n\tip_rt_put(rt);\n\tif (free)\n\t\tkfree(ipc.opt);\n\tif (!err) {\n\t\tUDP_INC_STATS_USER(UDP_MIB_OUTDATAGRAMS);\n\t\treturn len;\n\t}\n\t/*\n\t * ENOBUFS = no kernel mem, SOCK_NOSPACE = no sndbuf space.  Reporting\n\t * ENOBUFS might not be good (it's not tunable per se), but otherwise\n\t * we don't have a good statistic (IpOutDiscards but it can be too many\n\t * things).  We could add another new stat but at least for now that\n\t * seems like overkill.\n\t */\n\tif (err == -ENOBUFS || test_bit(SOCK_NOSPACE, &sk->sk_socket->flags)) {\n\t\tUDP_INC_STATS_USER(UDP_MIB_SNDBUFERRORS);\n\t}\n\treturn err;\n\ndo_confirm:\n\tdst_confirm(&rt->u.dst);\n\tif (!(msg->msg_flags&MSG_PROBE) || len)\n\t\tgoto back_from_confirm;\n\terr = 0;\n\tgoto out;\n}",
        "target": 1
    },
    {
        "func": "static int udpv6_sendmsg(struct kiocb *iocb, struct sock *sk, \n\t\t  struct msghdr *msg, size_t len)\n{\n\tstruct ipv6_txoptions opt_space;\n\tstruct udp_sock *up = udp_sk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sockaddr_in6 *sin6 = (struct sockaddr_in6 *) msg->msg_name;\n\tstruct in6_addr *daddr, *final_p = NULL, final;\n\tstruct ipv6_txoptions *opt = NULL;\n\tstruct ip6_flowlabel *flowlabel = NULL;\n\tstruct flowi fl;\n\tstruct dst_entry *dst;\n\tint addr_len = msg->msg_namelen;\n\tint ulen = len;\n\tint hlimit = -1;\n\tint tclass = -1;\n\tint corkreq = up->corkflag || msg->msg_flags&MSG_MORE;\n\tint err;\n\tint connected = 0;\n\n\t/* destination address check */\n\tif (sin6) {\n\t\tif (addr_len < offsetof(struct sockaddr, sa_data))\n\t\t\treturn -EINVAL;\n\n\t\tswitch (sin6->sin6_family) {\n\t\tcase AF_INET6:\n\t\t\tif (addr_len < SIN6_LEN_RFC2133)\n\t\t\t\treturn -EINVAL;\n\t\t\tdaddr = &sin6->sin6_addr;\n\t\t\tbreak;\n\t\tcase AF_INET:\n\t\t\tgoto do_udp_sendmsg;\n\t\tcase AF_UNSPEC:\n\t\t\tmsg->msg_name = sin6 = NULL;\n\t\t\tmsg->msg_namelen = addr_len = 0;\n\t\t\tdaddr = NULL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (!up->pending) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -EDESTADDRREQ;\n\t\tdaddr = &np->daddr;\n\t} else \n\t\tdaddr = NULL;\n\n\tif (daddr) {\n\t\tif (ipv6_addr_type(daddr) == IPV6_ADDR_MAPPED) {\n\t\t\tstruct sockaddr_in sin;\n\t\t\tsin.sin_family = AF_INET;\n\t\t\tsin.sin_port = sin6 ? sin6->sin6_port : inet->dport;\n\t\t\tsin.sin_addr.s_addr = daddr->s6_addr32[3];\n\t\t\tmsg->msg_name = &sin;\n\t\t\tmsg->msg_namelen = sizeof(sin);\ndo_udp_sendmsg:\n\t\t\tif (__ipv6_only_sock(sk))\n\t\t\t\treturn -ENETUNREACH;\n\t\t\treturn udp_sendmsg(iocb, sk, msg, len);\n\t\t}\n\t}\n\n\tif (up->pending == AF_INET)\n\t\treturn udp_sendmsg(iocb, sk, msg, len);\n\n\t/* Rough check on arithmetic overflow,\n\t   better check is made in ip6_build_xmit\n\t   */\n\tif (len > INT_MAX - sizeof(struct udphdr))\n\t\treturn -EMSGSIZE;\n\t\n\tif (up->pending) {\n\t\t/*\n\t\t * There are pending frames.\n\t\t * The socket lock must be held while it's corked.\n\t\t */\n\t\tlock_sock(sk);\n\t\tif (likely(up->pending)) {\n\t\t\tif (unlikely(up->pending != AF_INET6)) {\n\t\t\t\trelease_sock(sk);\n\t\t\t\treturn -EAFNOSUPPORT;\n\t\t\t}\n\t\t\tdst = NULL;\n\t\t\tgoto do_append_data;\n\t\t}\n\t\trelease_sock(sk);\n\t}\n\tulen += sizeof(struct udphdr);\n\n\tmemset(&fl, 0, sizeof(fl));\n\n\tif (sin6) {\n\t\tif (sin6->sin6_port == 0)\n\t\t\treturn -EINVAL;\n\n\t\tfl.fl_ip_dport = sin6->sin6_port;\n\t\tdaddr = &sin6->sin6_addr;\n\n\t\tif (np->sndflow) {\n\t\t\tfl.fl6_flowlabel = sin6->sin6_flowinfo&IPV6_FLOWINFO_MASK;\n\t\t\tif (fl.fl6_flowlabel&IPV6_FLOWLABEL_MASK) {\n\t\t\t\tflowlabel = fl6_sock_lookup(sk, fl.fl6_flowlabel);\n\t\t\t\tif (flowlabel == NULL)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tdaddr = &flowlabel->dst;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Otherwise it will be difficult to maintain\n\t\t * sk->sk_dst_cache.\n\t\t */\n\t\tif (sk->sk_state == TCP_ESTABLISHED &&\n\t\t    ipv6_addr_equal(daddr, &np->daddr))\n\t\t\tdaddr = &np->daddr;\n\n\t\tif (addr_len >= sizeof(struct sockaddr_in6) &&\n\t\t    sin6->sin6_scope_id &&\n\t\t    ipv6_addr_type(daddr)&IPV6_ADDR_LINKLOCAL)\n\t\t\tfl.oif = sin6->sin6_scope_id;\n\t} else {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -EDESTADDRREQ;\n\n\t\tfl.fl_ip_dport = inet->dport;\n\t\tdaddr = &np->daddr;\n\t\tfl.fl6_flowlabel = np->flow_label;\n\t\tconnected = 1;\n\t}\n\n\tif (!fl.oif)\n\t\tfl.oif = sk->sk_bound_dev_if;\n\n\tif (msg->msg_controllen) {\n\t\topt = &opt_space;\n\t\tmemset(opt, 0, sizeof(struct ipv6_txoptions));\n\t\topt->tot_len = sizeof(*opt);\n\n\t\terr = datagram_send_ctl(msg, &fl, opt, &hlimit, &tclass);\n\t\tif (err < 0) {\n\t\t\tfl6_sock_release(flowlabel);\n\t\t\treturn err;\n\t\t}\n\t\tif ((fl.fl6_flowlabel&IPV6_FLOWLABEL_MASK) && !flowlabel) {\n\t\t\tflowlabel = fl6_sock_lookup(sk, fl.fl6_flowlabel);\n\t\t\tif (flowlabel == NULL)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!(opt->opt_nflen|opt->opt_flen))\n\t\t\topt = NULL;\n\t\tconnected = 0;\n\t}\n\tif (opt == NULL)\n\t\topt = np->opt;\n\tif (flowlabel)\n\t\topt = fl6_merge_options(&opt_space, flowlabel, opt);\n\topt = ipv6_fixup_options(&opt_space, opt);\n\n\tfl.proto = IPPROTO_UDP;\n\tipv6_addr_copy(&fl.fl6_dst, daddr);\n\tif (ipv6_addr_any(&fl.fl6_src) && !ipv6_addr_any(&np->saddr))\n\t\tipv6_addr_copy(&fl.fl6_src, &np->saddr);\n\tfl.fl_ip_sport = inet->sport;\n\t\n\t/* merge ip6_build_xmit from ip6_output */\n\tif (opt && opt->srcrt) {\n\t\tstruct rt0_hdr *rt0 = (struct rt0_hdr *) opt->srcrt;\n\t\tipv6_addr_copy(&final, &fl.fl6_dst);\n\t\tipv6_addr_copy(&fl.fl6_dst, rt0->addr);\n\t\tfinal_p = &final;\n\t\tconnected = 0;\n\t}\n\n\tif (!fl.oif && ipv6_addr_is_multicast(&fl.fl6_dst)) {\n\t\tfl.oif = np->mcast_oif;\n\t\tconnected = 0;\n\t}\n\n\tsecurity_sk_classify_flow(sk, &fl);\n\n\terr = ip6_sk_dst_lookup(sk, &dst, &fl);\n\tif (err)\n\t\tgoto out;\n\tif (final_p)\n\t\tipv6_addr_copy(&fl.fl6_dst, final_p);\n\n\tif ((err = xfrm_lookup(&dst, &fl, sk, 0)) < 0)\n\t\tgoto out;\n\n\tif (hlimit < 0) {\n\t\tif (ipv6_addr_is_multicast(&fl.fl6_dst))\n\t\t\thlimit = np->mcast_hops;\n\t\telse\n\t\t\thlimit = np->hop_limit;\n\t\tif (hlimit < 0)\n\t\t\thlimit = dst_metric(dst, RTAX_HOPLIMIT);\n\t\tif (hlimit < 0)\n\t\t\thlimit = ipv6_get_hoplimit(dst->dev);\n\t}\n\n\tif (tclass < 0) {\n\t\ttclass = np->tclass;\n\t\tif (tclass < 0)\n\t\t\ttclass = 0;\n\t}\n\n\tif (msg->msg_flags&MSG_CONFIRM)\n\t\tgoto do_confirm;\nback_from_confirm:\n\n\tlock_sock(sk);\n\tif (unlikely(up->pending)) {\n\t\t/* The socket is already corked while preparing it. */\n\t\t/* ... which is an evident application bug. --ANK */\n\t\trelease_sock(sk);\n\n\t\tLIMIT_NETDEBUG(KERN_DEBUG \"udp cork app bug 2\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tup->pending = AF_INET6;\n\ndo_append_data:\n\tup->len += ulen;\n\terr = ip6_append_data(sk, ip_generic_getfrag, msg->msg_iov, ulen,\n\t\tsizeof(struct udphdr), hlimit, tclass, opt, &fl,\n\t\t(struct rt6_info*)dst,\n\t\tcorkreq ? msg->msg_flags|MSG_MORE : msg->msg_flags);\n\tif (err)\n\t\tudp_v6_flush_pending_frames(sk);\n\telse if (!corkreq)\n\t\terr = udp_v6_push_pending_frames(sk, up);\n\n\tif (dst) {\n\t\tif (connected) {\n\t\t\tip6_dst_store(sk, dst,\n\t\t\t\t      ipv6_addr_equal(&fl.fl6_dst, &np->daddr) ?\n\t\t\t\t      &np->daddr : NULL,\n#ifdef CONFIG_IPV6_SUBTREES\n\t\t\t\t      ipv6_addr_equal(&fl.fl6_src, &np->saddr) ?\n\t\t\t\t      &np->saddr :\n#endif\n\t\t\t\t      NULL);\n\t\t} else {\n\t\t\tdst_release(dst);\n\t\t}\n\t}\n\n\tif (err > 0)\n\t\terr = np->recverr ? net_xmit_errno(err) : 0;\n\trelease_sock(sk);\nout:\n\tfl6_sock_release(flowlabel);\n\tif (!err) {\n\t\tUDP6_INC_STATS_USER(UDP_MIB_OUTDATAGRAMS);\n\t\treturn len;\n\t}\n\t/*\n\t * ENOBUFS = no kernel mem, SOCK_NOSPACE = no sndbuf space.  Reporting\n\t * ENOBUFS might not be good (it's not tunable per se), but otherwise\n\t * we don't have a good statistic (IpOutDiscards but it can be too many\n\t * things).  We could add another new stat but at least for now that\n\t * seems like overkill.\n\t */\n\tif (err == -ENOBUFS || test_bit(SOCK_NOSPACE, &sk->sk_socket->flags)) {\n\t\tUDP6_INC_STATS_USER(UDP_MIB_SNDBUFERRORS);\n\t}\n\treturn err;\n\ndo_confirm:\n\tdst_confirm(dst);\n\tif (!(msg->msg_flags&MSG_PROBE) || len)\n\t\tgoto back_from_confirm;\n\terr = 0;\n\tgoto out;\n}",
        "target": 1
    },
    {
        "func": "static int llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t  int *uaddrlen, int peer)\n{\n\tstruct sockaddr_llc sllc;\n\tstruct sock *sk = sock->sk;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tint rc = 0;\n\n\tlock_sock(sk);\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\tgoto out;\n\t*uaddrlen = sizeof(sllc);\n\tmemset(uaddr, 0, *uaddrlen);\n\tif (peer) {\n\t\trc = -ENOTCONN;\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\tgoto out;\n\t\tif(llc->dev)\n\t\t\tsllc.sllc_arphrd = llc->dev->type;\n\t\tsllc.sllc_sap = llc->daddr.lsap;\n\t\tmemcpy(&sllc.sllc_mac, &llc->daddr.mac, IFHWADDRLEN);\n\t} else {\n\t\trc = -EINVAL;\n\t\tif (!llc->sap)\n\t\t\tgoto out;\n\t\tsllc.sllc_sap = llc->sap->laddr.lsap;\n\n\t\tif (llc->dev) {\n\t\t\tsllc.sllc_arphrd = llc->dev->type;\n\t\t\tmemcpy(&sllc.sllc_mac, llc->dev->dev_addr,\n\t\t\t       IFHWADDRLEN);\n\t\t}\n\t}\n\trc = 0;\n\tsllc.sllc_family = AF_LLC;\n\tmemcpy(uaddr, &sllc, sizeof(sllc));\nout:\n\trelease_sock(sk);\n\treturn rc;\n}",
        "target": 1
    },
    {
        "func": "static int irda_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\tint *uaddr_len, int peer)\n{\n\tstruct sockaddr_irda saddr;\n\tstruct sock *sk = sock->sk;\n\tstruct irda_sock *self = irda_sk(sk);\n\n\tif (peer) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -ENOTCONN;\n\n\t\tsaddr.sir_family = AF_IRDA;\n\t\tsaddr.sir_lsap_sel = self->dtsap_sel;\n\t\tsaddr.sir_addr = self->daddr;\n\t} else {\n\t\tsaddr.sir_family = AF_IRDA;\n\t\tsaddr.sir_lsap_sel = self->stsap_sel;\n\t\tsaddr.sir_addr = self->saddr;\n\t}\n\n\tIRDA_DEBUG(1, \"%s(), tsap_sel = %#x\\n\", __func__, saddr.sir_lsap_sel);\n\tIRDA_DEBUG(1, \"%s(), addr = %08x\\n\", __func__, saddr.sir_addr);\n\n\t/* uaddr_len come to us uninitialised */\n\t*uaddr_len = sizeof (struct sockaddr_irda);\n\tmemcpy(uaddr, &saddr, *uaddr_len);\n\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static int rose_getname(struct socket *sock, struct sockaddr *uaddr,\n\tint *uaddr_len, int peer)\n{\n\tstruct full_sockaddr_rose *srose = (struct full_sockaddr_rose *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct rose_sock *rose = rose_sk(sk);\n\tint n;\n\n\tif (peer != 0) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -ENOTCONN;\n\t\tsrose->srose_family = AF_ROSE;\n\t\tsrose->srose_addr   = rose->dest_addr;\n\t\tsrose->srose_call   = rose->dest_call;\n\t\tsrose->srose_ndigis = rose->dest_ndigis;\n\t\tfor (n = 0; n < rose->dest_ndigis; n++)\n\t\t\tsrose->srose_digis[n] = rose->dest_digis[n];\n\t} else {\n\t\tsrose->srose_family = AF_ROSE;\n\t\tsrose->srose_addr   = rose->source_addr;\n\t\tsrose->srose_call   = rose->source_call;\n\t\tsrose->srose_ndigis = rose->source_ndigis;\n\t\tfor (n = 0; n < rose->source_ndigis; n++)\n\t\t\tsrose->srose_digis[n] = rose->source_digis[n];\n\t}\n\n\t*uaddr_len = sizeof(struct full_sockaddr_rose);\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static int atalk_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t int *uaddr_len, int peer)\n{\n\tstruct sockaddr_at sat;\n\tstruct sock *sk = sock->sk;\n\tstruct atalk_sock *at = at_sk(sk);\n\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\tif (atalk_autobind(sk) < 0)\n\t\t\treturn -ENOBUFS;\n\n\t*uaddr_len = sizeof(struct sockaddr_at);\n\n\tif (peer) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -ENOTCONN;\n\n\t\tsat.sat_addr.s_net  = at->dest_net;\n\t\tsat.sat_addr.s_node = at->dest_node;\n\t\tsat.sat_port\t    = at->dest_port;\n\t} else {\n\t\tsat.sat_addr.s_net  = at->src_net;\n\t\tsat.sat_addr.s_node = at->src_node;\n\t\tsat.sat_port\t    = at->src_port;\n\t}\n\n\tsat.sat_family = AF_APPLETALK;\n\tmemcpy(uaddr, &sat, sizeof(sat));\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static int econet_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t  int *uaddr_len, int peer)\n{\n\tstruct sock *sk;\n\tstruct econet_sock *eo;\n\tstruct sockaddr_ec *sec = (struct sockaddr_ec *)uaddr;\n\n\tif (peer)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&econet_mutex);\n\n\tsk = sock->sk;\n\teo = ec_sk(sk);\n\n\tsec->sec_family\t  = AF_ECONET;\n\tsec->port\t  = eo->port;\n\tsec->addr.station = eo->station;\n\tsec->addr.net\t  = eo->net;\n\n\tmutex_unlock(&econet_mutex);\n\n\t*uaddr_len = sizeof(*sec);\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static int raw_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t       int *len, int peer)\n{\n\tstruct sockaddr_can *addr = (struct sockaddr_can *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct raw_sock *ro = raw_sk(sk);\n\n\tif (peer)\n\t\treturn -EOPNOTSUPP;\n\n\taddr->can_family  = AF_CAN;\n\taddr->can_ifindex = ro->ifindex;\n\n\t*len = sizeof(*addr);\n\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static int nr_getname(struct socket *sock, struct sockaddr *uaddr,\n\tint *uaddr_len, int peer)\n{\n\tstruct full_sockaddr_ax25 *sax = (struct full_sockaddr_ax25 *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct nr_sock *nr = nr_sk(sk);\n\n\tlock_sock(sk);\n\tif (peer != 0) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\t\trelease_sock(sk);\n\t\t\treturn -ENOTCONN;\n\t\t}\n\t\tsax->fsa_ax25.sax25_family = AF_NETROM;\n\t\tsax->fsa_ax25.sax25_ndigis = 1;\n\t\tsax->fsa_ax25.sax25_call   = nr->user_addr;\n\t\tsax->fsa_digipeater[0]     = nr->dest_addr;\n\t\t*uaddr_len = sizeof(struct full_sockaddr_ax25);\n\t} else {\n\t\tsax->fsa_ax25.sax25_family = AF_NETROM;\n\t\tsax->fsa_ax25.sax25_ndigis = 0;\n\t\tsax->fsa_ax25.sax25_call   = nr->source_addr;\n\t\t*uaddr_len = sizeof(struct sockaddr_ax25);\n\t}\n\trelease_sock(sk);\n\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static int tc_fill_tclass(struct sk_buff *skb, struct Qdisc *q,\n\t\t\t  unsigned long cl,\n\t\t\t  u32 pid, u32 seq, u16 flags, int event)\n{\n\tstruct tcmsg *tcm;\n\tstruct nlmsghdr  *nlh;\n\tunsigned char *b = skb_tail_pointer(skb);\n\tstruct gnet_dump d;\n\tconst struct Qdisc_class_ops *cl_ops = q->ops->cl_ops;\n\n\tnlh = NLMSG_NEW(skb, pid, seq, event, sizeof(*tcm), flags);\n\ttcm = NLMSG_DATA(nlh);\n\ttcm->tcm_family = AF_UNSPEC;\n\ttcm->tcm_ifindex = qdisc_dev(q)->ifindex;\n\ttcm->tcm_parent = q->handle;\n\ttcm->tcm_handle = q->handle;\n\ttcm->tcm_info = 0;\n\tNLA_PUT_STRING(skb, TCA_KIND, q->ops->id);\n\tif (cl_ops->dump && cl_ops->dump(q, cl, skb, tcm) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (gnet_stats_start_copy_compat(skb, TCA_STATS2, TCA_STATS, TCA_XSTATS,\n\t\t\t\t\t qdisc_root_sleeping_lock(q), &d) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (cl_ops->dump_stats && cl_ops->dump_stats(q, cl, &d) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (gnet_stats_finish_copy(&d) < 0)\n\t\tgoto nla_put_failure;\n\n\tnlh->nlmsg_len = skb_tail_pointer(skb) - b;\n\treturn skb->len;\n\nnlmsg_failure:\nnla_put_failure:\n\tnlmsg_trim(skb, b);\n\treturn -1;\n}",
        "target": 1
    },
    {
        "func": "static __inline__ int cbq_dump_ovl(struct sk_buff *skb, struct cbq_class *cl)\n{\n\tunsigned char\t *b = skb->tail;\n\tstruct tc_cbq_ovl opt;\n\n\topt.strategy = cl->ovl_strategy;\n\topt.priority2 = cl->priority2+1;\n\topt.penalty = (cl->penalty*1000)/HZ;\n\tRTA_PUT(skb, TCA_CBQ_OVL_STRATEGY, sizeof(opt), &opt);\n\treturn skb->len;\n\nrtattr_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}",
        "target": 1
    },
    {
        "func": "static int rsvp_dump(struct tcf_proto *tp, unsigned long fh,\n\t\t     struct sk_buff *skb, struct tcmsg *t)\n{\n\tstruct rsvp_filter *f = (struct rsvp_filter*)fh;\n\tstruct rsvp_session *s;\n\tunsigned char\t *b = skb->tail;\n\tstruct rtattr *rta;\n\tstruct tc_rsvp_pinfo pinfo;\n\n\tif (f == NULL)\n\t\treturn skb->len;\n\ts = f->sess;\n\n\tt->tcm_handle = f->handle;\n\n\n\trta = (struct rtattr*)b;\n\tRTA_PUT(skb, TCA_OPTIONS, 0, NULL);\n\n\tRTA_PUT(skb, TCA_RSVP_DST, sizeof(s->dst), &s->dst);\n\tpinfo.dpi = s->dpi;\n\tpinfo.spi = f->spi;\n\tpinfo.protocol = s->protocol;\n\tpinfo.tunnelid = s->tunnelid;\n\tpinfo.tunnelhdr = f->tunnelhdr;\n\tRTA_PUT(skb, TCA_RSVP_PINFO, sizeof(pinfo), &pinfo);\n\tif (f->res.classid)\n\t\tRTA_PUT(skb, TCA_RSVP_CLASSID, 4, &f->res.classid);\n\tif (((f->handle>>8)&0xFF) != 16)\n\t\tRTA_PUT(skb, TCA_RSVP_SRC, sizeof(f->src), f->src);\n\n\tif (tcf_exts_dump(skb, &f->exts, &rsvp_ext_map) < 0)\n\t\tgoto rtattr_failure;\n\n\trta->rta_len = skb->tail - b;\n\n\tif (tcf_exts_dump_stats(skb, &f->exts, &rsvp_ext_map) < 0)\n\t\tgoto rtattr_failure;\n\treturn skb->len;\n\nrtattr_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}",
        "target": 1
    },
    {
        "func": "static int inet6_fill_prefix(struct sk_buff *skb, struct inet6_dev *idev,\n\t\t\tstruct prefix_info *pinfo, u32 pid, u32 seq, \n\t\t\tint event, unsigned int flags)\n{\n\tstruct prefixmsg\t*pmsg;\n\tstruct nlmsghdr \t*nlh;\n\tunsigned char\t\t*b = skb->tail;\n\tstruct prefix_cacheinfo\tci;\n\n\tnlh = NLMSG_NEW(skb, pid, seq, event, sizeof(*pmsg), flags);\n\tpmsg = NLMSG_DATA(nlh);\n\tpmsg->prefix_family = AF_INET6;\n\tpmsg->prefix_ifindex = idev->dev->ifindex;\n\tpmsg->prefix_len = pinfo->prefix_len;\n\tpmsg->prefix_type = pinfo->type;\n\t\n\tpmsg->prefix_flags = 0;\n\tif (pinfo->onlink)\n\t\tpmsg->prefix_flags |= IF_PREFIX_ONLINK;\n\tif (pinfo->autoconf)\n\t\tpmsg->prefix_flags |= IF_PREFIX_AUTOCONF;\n\n\tRTA_PUT(skb, PREFIX_ADDRESS, sizeof(pinfo->prefix), &pinfo->prefix);\n\n\tci.preferred_time = ntohl(pinfo->prefered);\n\tci.valid_time = ntohl(pinfo->valid);\n\tRTA_PUT(skb, PREFIX_CACHEINFO, sizeof(ci), &ci);\n\n\tnlh->nlmsg_len = skb->tail - b;\n\treturn skb->len;\n\nnlmsg_failure:\nrtattr_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}",
        "target": 1
    },
    {
        "func": "static int neightbl_fill_info(struct neigh_table *tbl, struct sk_buff *skb,\n\t\t\t      struct netlink_callback *cb)\n{\n\tstruct nlmsghdr *nlh;\n\tstruct ndtmsg *ndtmsg;\n\n\tnlh = NLMSG_NEW_ANSWER(skb, cb, RTM_NEWNEIGHTBL, sizeof(struct ndtmsg),\n\t\t\t       NLM_F_MULTI);\n\n\tndtmsg = NLMSG_DATA(nlh);\n\n\tread_lock_bh(&tbl->lock);\n\tndtmsg->ndtm_family = tbl->family;\n\n\tRTA_PUT_STRING(skb, NDTA_NAME, tbl->id);\n\tRTA_PUT_MSECS(skb, NDTA_GC_INTERVAL, tbl->gc_interval);\n\tRTA_PUT_U32(skb, NDTA_THRESH1, tbl->gc_thresh1);\n\tRTA_PUT_U32(skb, NDTA_THRESH2, tbl->gc_thresh2);\n\tRTA_PUT_U32(skb, NDTA_THRESH3, tbl->gc_thresh3);\n\n\t{\n\t\tunsigned long now = jiffies;\n\t\tunsigned int flush_delta = now - tbl->last_flush;\n\t\tunsigned int rand_delta = now - tbl->last_rand;\n\n\t\tstruct ndt_config ndc = {\n\t\t\t.ndtc_key_len\t\t= tbl->key_len,\n\t\t\t.ndtc_entry_size\t= tbl->entry_size,\n\t\t\t.ndtc_entries\t\t= atomic_read(&tbl->entries),\n\t\t\t.ndtc_last_flush\t= jiffies_to_msecs(flush_delta),\n\t\t\t.ndtc_last_rand\t\t= jiffies_to_msecs(rand_delta),\n\t\t\t.ndtc_hash_rnd\t\t= tbl->hash_rnd,\n\t\t\t.ndtc_hash_mask\t\t= tbl->hash_mask,\n\t\t\t.ndtc_hash_chain_gc\t= tbl->hash_chain_gc,\n\t\t\t.ndtc_proxy_qlen\t= tbl->proxy_queue.qlen,\n\t\t};\n\n\t\tRTA_PUT(skb, NDTA_CONFIG, sizeof(ndc), &ndc);\n\t}\n\n\t{\n\t\tint cpu;\n\t\tstruct ndt_stats ndst;\n\n\t\tmemset(&ndst, 0, sizeof(ndst));\n\n\t\tfor (cpu = 0; cpu < NR_CPUS; cpu++) {\n\t\t\tstruct neigh_statistics\t*st;\n\n\t\t\tif (!cpu_possible(cpu))\n\t\t\t\tcontinue;\n\n\t\t\tst = per_cpu_ptr(tbl->stats, cpu);\n\t\t\tndst.ndts_allocs\t\t+= st->allocs;\n\t\t\tndst.ndts_destroys\t\t+= st->destroys;\n\t\t\tndst.ndts_hash_grows\t\t+= st->hash_grows;\n\t\t\tndst.ndts_res_failed\t\t+= st->res_failed;\n\t\t\tndst.ndts_lookups\t\t+= st->lookups;\n\t\t\tndst.ndts_hits\t\t\t+= st->hits;\n\t\t\tndst.ndts_rcv_probes_mcast\t+= st->rcv_probes_mcast;\n\t\t\tndst.ndts_rcv_probes_ucast\t+= st->rcv_probes_ucast;\n\t\t\tndst.ndts_periodic_gc_runs\t+= st->periodic_gc_runs;\n\t\t\tndst.ndts_forced_gc_runs\t+= st->forced_gc_runs;\n\t\t}\n\n\t\tRTA_PUT(skb, NDTA_STATS, sizeof(ndst), &ndst);\n\t}\n\n\tBUG_ON(tbl->parms.dev);\n\tif (neightbl_fill_parms(skb, &tbl->parms) < 0)\n\t\tgoto rtattr_failure;\n\n\tread_unlock_bh(&tbl->lock);\n\treturn NLMSG_END(skb, nlh);\n\nrtattr_failure:\n\tread_unlock_bh(&tbl->lock);\n\treturn NLMSG_CANCEL(skb, nlh);\n \nnlmsg_failure:\n\treturn -1;\n}",
        "target": 1
    },
    {
        "func": "static void ipmr_destroy_unres(struct mfc_cache *c)\n{\n\tstruct sk_buff *skb;\n\n\tatomic_dec(&cache_resolve_queue_len);\n\n\twhile((skb=skb_dequeue(&c->mfc_un.unres.unresolved))) {\n\t\tif (skb->nh.iph->version == 0) {\n\t\t\tstruct nlmsghdr *nlh = (struct nlmsghdr *)skb_pull(skb, sizeof(struct iphdr));\n\t\t\tnlh->nlmsg_type = NLMSG_ERROR;\n\t\t\tnlh->nlmsg_len = NLMSG_LENGTH(sizeof(struct nlmsgerr));\n\t\t\tskb_trim(skb, nlh->nlmsg_len);\n\t\t\t((struct nlmsgerr*)NLMSG_DATA(nlh))->error = -ETIMEDOUT;\n\t\t\tnetlink_unicast(rtnl, skb, NETLINK_CB(skb).dst_pid, MSG_DONTWAIT);\n\t\t} else\n\t\t\tkfree_skb(skb);\n\t}\n\n\tkmem_cache_free(mrt_cachep, c);\n}",
        "target": 1
    },
    {
        "func": "static void ipmr_cache_resolve(struct mfc_cache *uc, struct mfc_cache *c)\n{\n\tstruct sk_buff *skb;\n\n\t/*\n\t *\tPlay the pending entries through our router\n\t */\n\n\twhile((skb=__skb_dequeue(&uc->mfc_un.unres.unresolved))) {\n\t\tif (skb->nh.iph->version == 0) {\n\t\t\tint err;\n\t\t\tstruct nlmsghdr *nlh = (struct nlmsghdr *)skb_pull(skb, sizeof(struct iphdr));\n\n\t\t\tif (ipmr_fill_mroute(skb, c, NLMSG_DATA(nlh)) > 0) {\n\t\t\t\tnlh->nlmsg_len = skb->tail - (u8*)nlh;\n\t\t\t} else {\n\t\t\t\tnlh->nlmsg_type = NLMSG_ERROR;\n\t\t\t\tnlh->nlmsg_len = NLMSG_LENGTH(sizeof(struct nlmsgerr));\n\t\t\t\tskb_trim(skb, nlh->nlmsg_len);\n\t\t\t\t((struct nlmsgerr*)NLMSG_DATA(nlh))->error = -EMSGSIZE;\n\t\t\t}\n\t\t\terr = netlink_unicast(rtnl, skb, NETLINK_CB(skb).dst_pid, MSG_DONTWAIT);\n\t\t} else\n\t\t\tip_mr_forward(skb, c, 0);\n\t}\n}",
        "target": 1
    },
    {
        "func": "static int inet6_fill_ifinfo(struct sk_buff *skb, struct inet6_dev *idev, \n\t\t\t     u32 pid, u32 seq, int event, unsigned int flags)\n{\n\tstruct net_device\t*dev = idev->dev;\n\t__s32\t\t\t*array = NULL;\n\tstruct ifinfomsg\t*r;\n\tstruct nlmsghdr \t*nlh;\n\tunsigned char\t\t*b = skb->tail;\n\tstruct rtattr\t\t*subattr;\n\t__u32\t\t\tmtu = dev->mtu;\n\tstruct ifla_cacheinfo\tci;\n\n\tnlh = NLMSG_NEW(skb, pid, seq, event, sizeof(*r), flags);\n\tr = NLMSG_DATA(nlh);\n\tr->ifi_family = AF_INET6;\n\tr->ifi_type = dev->type;\n\tr->ifi_index = dev->ifindex;\n\tr->ifi_flags = dev_get_flags(dev);\n\tr->ifi_change = 0;\n\n\tRTA_PUT(skb, IFLA_IFNAME, strlen(dev->name)+1, dev->name);\n\n\tif (dev->addr_len)\n\t\tRTA_PUT(skb, IFLA_ADDRESS, dev->addr_len, dev->dev_addr);\n\n\tRTA_PUT(skb, IFLA_MTU, sizeof(mtu), &mtu);\n\tif (dev->ifindex != dev->iflink)\n\t\tRTA_PUT(skb, IFLA_LINK, sizeof(int), &dev->iflink);\n\t\t\t\n\tsubattr = (struct rtattr*)skb->tail;\n\n\tRTA_PUT(skb, IFLA_PROTINFO, 0, NULL);\n\n\t/* return the device flags */\n\tRTA_PUT(skb, IFLA_INET6_FLAGS, sizeof(__u32), &idev->if_flags);\n\n\t/* return interface cacheinfo */\n\tci.max_reasm_len = IPV6_MAXPLEN;\n\tci.tstamp = (__u32)(TIME_DELTA(idev->tstamp, INITIAL_JIFFIES) / HZ * 100\n\t\t    + TIME_DELTA(idev->tstamp, INITIAL_JIFFIES) % HZ * 100 / HZ);\n\tci.reachable_time = idev->nd_parms->reachable_time;\n\tci.retrans_time = idev->nd_parms->retrans_time;\n\tRTA_PUT(skb, IFLA_INET6_CACHEINFO, sizeof(ci), &ci);\n\t\n\t/* return the device sysctl params */\n\tif ((array = kmalloc(DEVCONF_MAX * sizeof(*array), GFP_ATOMIC)) == NULL)\n\t\tgoto rtattr_failure;\n\tipv6_store_devconf(&idev->cnf, array, DEVCONF_MAX * sizeof(*array));\n\tRTA_PUT(skb, IFLA_INET6_CONF, DEVCONF_MAX * sizeof(*array), array);\n\n\t/* XXX - Statistics/MC not implemented */\n\tsubattr->rta_len = skb->tail - (u8*)subattr;\n\n\tnlh->nlmsg_len = skb->tail - b;\n\tkfree(array);\n\treturn skb->len;\n\nnlmsg_failure:\nrtattr_failure:\n\tif (array)\n\t\tkfree(array);\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}",
        "target": 1
    },
    {
        "func": "static int tcf_add_notify(struct tc_action *a, u32 pid, u32 seq, int event,\n                          u16 flags)\n{\n\tstruct tcamsg *t;\n\tstruct nlmsghdr *nlh;\n\tstruct sk_buff *skb;\n\tstruct rtattr *x;\n\tunsigned char *b;\n\tint err = 0;\n\n\tskb = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\n\tb = (unsigned char *)skb->tail;\n\n\tnlh = NLMSG_NEW(skb, pid, seq, event, sizeof(*t), flags);\n\tt = NLMSG_DATA(nlh);\n\tt->tca_family = AF_UNSPEC;\n\t\n\tx = (struct rtattr*) skb->tail;\n\tRTA_PUT(skb, TCA_ACT_TAB, 0, NULL);\n\n\tif (tcf_action_dump(skb, a, 0, 0) < 0)\n\t\tgoto rtattr_failure;\n\n\tx->rta_len = skb->tail - (u8*)x;\n\t\n\tnlh->nlmsg_len = skb->tail - b;\n\tNETLINK_CB(skb).dst_groups = RTMGRP_TC;\n\t\n\terr = rtnetlink_send(skb, pid, RTMGRP_TC, flags&NLM_F_ECHO);\n\tif (err > 0)\n\t\terr = 0;\n\treturn err;\n\nrtattr_failure:\nnlmsg_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}",
        "target": 1
    },
    {
        "func": "static __inline__ int cbq_dump_police(struct sk_buff *skb, struct cbq_class *cl)\n{\n\tunsigned char\t *b = skb->tail;\n\tstruct tc_cbq_police opt;\n\n\tif (cl->police) {\n\t\topt.police = cl->police;\n\t\tRTA_PUT(skb, TCA_CBQ_POLICE, sizeof(opt), &opt);\n\t}\n\treturn skb->len;\n\nrtattr_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}",
        "target": 1
    },
    {
        "func": "tca_get_fill(struct sk_buff *skb, struct tc_action *a, u32 pid, u32 seq,\n             u16 flags, int event, int bind, int ref)\n{\n\tstruct tcamsg *t;\n\tstruct nlmsghdr *nlh;\n\tunsigned char *b = skb->tail;\n\tstruct rtattr *x;\n\n\tnlh = NLMSG_NEW(skb, pid, seq, event, sizeof(*t), flags);\n\n\tt = NLMSG_DATA(nlh);\n\tt->tca_family = AF_UNSPEC;\n\t\n\tx = (struct rtattr*) skb->tail;\n\tRTA_PUT(skb, TCA_ACT_TAB, 0, NULL);\n\n\tif (tcf_action_dump(skb, a, bind, ref) < 0)\n\t\tgoto rtattr_failure;\n\n\tx->rta_len = skb->tail - (u8*)x;\n\t\n\tnlh->nlmsg_len = skb->tail - b;\n\treturn skb->len;\n\nrtattr_failure:\nnlmsg_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}",
        "target": 1
    },
    {
        "func": "tc_dump_action(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct nlmsghdr *nlh;\n\tunsigned char *b = skb->tail;\n\tstruct rtattr *x;\n\tstruct tc_action_ops *a_o;\n\tstruct tc_action a;\n\tint ret = 0;\n\tstruct tcamsg *t = (struct tcamsg *) NLMSG_DATA(cb->nlh);\n\tchar *kind = find_dump_kind(cb->nlh);\n\n\tif (kind == NULL) {\n\t\tprintk(\"tc_dump_action: action bad kind\\n\");\n\t\treturn 0;\n\t}\n\n\ta_o = tc_lookup_action_n(kind);\n\tif (a_o == NULL) {\n\t\tprintk(\"failed to find %s\\n\", kind);\n\t\treturn 0;\n\t}\n\n\tmemset(&a, 0, sizeof(struct tc_action));\n\ta.ops = a_o;\n\n\tif (a_o->walk == NULL) {\n\t\tprintk(\"tc_dump_action: %s !capable of dumping table\\n\", kind);\n\t\tgoto rtattr_failure;\n\t}\n\n\tnlh = NLMSG_PUT(skb, NETLINK_CB(cb->skb).pid, cb->nlh->nlmsg_seq,\n\t                cb->nlh->nlmsg_type, sizeof(*t));\n\tt = NLMSG_DATA(nlh);\n\tt->tca_family = AF_UNSPEC;\n\n\tx = (struct rtattr *) skb->tail;\n\tRTA_PUT(skb, TCA_ACT_TAB, 0, NULL);\n\n\tret = a_o->walk(skb, cb, RTM_GETACTION, &a);\n\tif (ret < 0)\n\t\tgoto rtattr_failure;\n\n\tif (ret > 0) {\n\t\tx->rta_len = skb->tail - (u8 *) x;\n\t\tret = skb->len;\n\t} else\n\t\tskb_trim(skb, (u8*)x - skb->data);\n\n\tnlh->nlmsg_len = skb->tail - b;\n\tif (NETLINK_CB(cb->skb).pid && ret)\n\t\tnlh->nlmsg_flags |= NLM_F_MULTI;\n\tmodule_put(a_o->owner);\n\treturn skb->len;\n\nrtattr_failure:\nnlmsg_failure:\n\tmodule_put(a_o->owner);\n\tskb_trim(skb, b - skb->data);\n\treturn skb->len;\n}",
        "target": 1
    },
    {
        "func": "static int rtnetlink_fill_ifinfo(struct sk_buff *skb, struct net_device *dev,\n\t\t\t\t int type, u32 pid, u32 seq, u32 change, \n\t\t\t\t unsigned int flags)\n{\n\tstruct ifinfomsg *r;\n\tstruct nlmsghdr  *nlh;\n\tunsigned char\t *b = skb->tail;\n\n\tnlh = NLMSG_NEW(skb, pid, seq, type, sizeof(*r), flags);\n\tr = NLMSG_DATA(nlh);\n\tr->ifi_family = AF_UNSPEC;\n\tr->ifi_type = dev->type;\n\tr->ifi_index = dev->ifindex;\n\tr->ifi_flags = dev_get_flags(dev);\n\tr->ifi_change = change;\n\n\tRTA_PUT(skb, IFLA_IFNAME, strlen(dev->name)+1, dev->name);\n\n\tif (1) {\n\t\tu32 txqlen = dev->tx_queue_len;\n\t\tRTA_PUT(skb, IFLA_TXQLEN, sizeof(txqlen), &txqlen);\n\t}\n\n\tif (1) {\n\t\tu32 weight = dev->weight;\n\t\tRTA_PUT(skb, IFLA_WEIGHT, sizeof(weight), &weight);\n\t}\n\n\tif (1) {\n\t\tstruct rtnl_link_ifmap map = {\n\t\t\t.mem_start   = dev->mem_start,\n\t\t\t.mem_end     = dev->mem_end,\n\t\t\t.base_addr   = dev->base_addr,\n\t\t\t.irq         = dev->irq,\n\t\t\t.dma         = dev->dma,\n\t\t\t.port        = dev->if_port,\n\t\t};\n\t\tRTA_PUT(skb, IFLA_MAP, sizeof(map), &map);\n\t}\n\n\tif (dev->addr_len) {\n\t\tRTA_PUT(skb, IFLA_ADDRESS, dev->addr_len, dev->dev_addr);\n\t\tRTA_PUT(skb, IFLA_BROADCAST, dev->addr_len, dev->broadcast);\n\t}\n\n\tif (1) {\n\t\tu32 mtu = dev->mtu;\n\t\tRTA_PUT(skb, IFLA_MTU, sizeof(mtu), &mtu);\n\t}\n\n\tif (dev->ifindex != dev->iflink) {\n\t\tu32 iflink = dev->iflink;\n\t\tRTA_PUT(skb, IFLA_LINK, sizeof(iflink), &iflink);\n\t}\n\n\tif (dev->qdisc_sleeping)\n\t\tRTA_PUT(skb, IFLA_QDISC,\n\t\t\tstrlen(dev->qdisc_sleeping->ops->id) + 1,\n\t\t\tdev->qdisc_sleeping->ops->id);\n\t\n\tif (dev->master) {\n\t\tu32 master = dev->master->ifindex;\n\t\tRTA_PUT(skb, IFLA_MASTER, sizeof(master), &master);\n\t}\n\n\tif (dev->get_stats) {\n\t\tunsigned long *stats = (unsigned long*)dev->get_stats(dev);\n\t\tif (stats) {\n\t\t\tstruct rtattr  *a;\n\t\t\t__u32\t       *s;\n\t\t\tint\t\ti;\n\t\t\tint\t\tn = sizeof(struct rtnl_link_stats)/4;\n\n\t\t\ta = __RTA_PUT(skb, IFLA_STATS, n*4);\n\t\t\ts = RTA_DATA(a);\n\t\t\tfor (i=0; i<n; i++)\n\t\t\t\ts[i] = stats[i];\n\t\t}\n\t}\n\tnlh->nlmsg_len = skb->tail - b;\n\treturn skb->len;\n\nnlmsg_failure:\nrtattr_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}",
        "target": 1
    },
    {
        "func": "static int neigh_fill_info(struct sk_buff *skb, struct neighbour *n,\n\t\t\t   u32 pid, u32 seq, int event, unsigned int flags)\n{\n\tunsigned long now = jiffies;\n\tunsigned char *b = skb->tail;\n\tstruct nda_cacheinfo ci;\n\tint locked = 0;\n\tu32 probes;\n\tstruct nlmsghdr *nlh = NLMSG_NEW(skb, pid, seq, event,\n\t\t\t\t\t sizeof(struct ndmsg), flags);\n\tstruct ndmsg *ndm = NLMSG_DATA(nlh);\n\n\tndm->ndm_family\t = n->ops->family;\n\tndm->ndm_flags\t = n->flags;\n\tndm->ndm_type\t = n->type;\n\tndm->ndm_ifindex = n->dev->ifindex;\n\tRTA_PUT(skb, NDA_DST, n->tbl->key_len, n->primary_key);\n\tread_lock_bh(&n->lock);\n\tlocked\t\t = 1;\n\tndm->ndm_state\t = n->nud_state;\n\tif (n->nud_state & NUD_VALID)\n\t\tRTA_PUT(skb, NDA_LLADDR, n->dev->addr_len, n->ha);\n\tci.ndm_used\t = now - n->used;\n\tci.ndm_confirmed = now - n->confirmed;\n\tci.ndm_updated\t = now - n->updated;\n\tci.ndm_refcnt\t = atomic_read(&n->refcnt) - 1;\n\tprobes = atomic_read(&n->probes);\n\tread_unlock_bh(&n->lock);\n\tlocked\t\t = 0;\n\tRTA_PUT(skb, NDA_CACHEINFO, sizeof(ci), &ci);\n\tRTA_PUT(skb, NDA_PROBES, sizeof(probes), &probes);\n\tnlh->nlmsg_len\t = skb->tail - b;\n\treturn skb->len;\n\nnlmsg_failure:\nrtattr_failure:\n\tif (locked)\n\t\tread_unlock_bh(&n->lock);\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}",
        "target": 1
    },
    {
        "func": "static inline int rtnetlink_fill_iwinfo(struct sk_buff *\tskb,\n\t\t\t\t\tstruct net_device *\tdev,\n\t\t\t\t\tint\t\t\ttype,\n\t\t\t\t\tchar *\t\t\tevent,\n\t\t\t\t\tint\t\t\tevent_len)\n{\n\tstruct ifinfomsg *r;\n\tstruct nlmsghdr  *nlh;\n\tunsigned char\t *b = skb->tail;\n\n\tnlh = NLMSG_PUT(skb, 0, 0, type, sizeof(*r));\n\tr = NLMSG_DATA(nlh);\n\tr->ifi_family = AF_UNSPEC;\n\tr->ifi_type = dev->type;\n\tr->ifi_index = dev->ifindex;\n\tr->ifi_flags = dev->flags;\n\tr->ifi_change = 0;\t/* Wireless changes don't affect those flags */\n\n\t/* Add the wireless events in the netlink packet */\n\tRTA_PUT(skb, IFLA_WIRELESS,\n\t\tevent_len, event);\n\n\tnlh->nlmsg_len = skb->tail - b;\n\treturn skb->len;\n\nnlmsg_failure:\nrtattr_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}",
        "target": 1
    },
    {
        "func": "tcf_fill_node(struct sk_buff *skb, struct tcf_proto *tp, unsigned long fh,\n\t      u32 pid, u32 seq, u16 flags, int event)\n{\n\tstruct tcmsg *tcm;\n\tstruct nlmsghdr  *nlh;\n\tunsigned char\t *b = skb->tail;\n\n\tnlh = NLMSG_NEW(skb, pid, seq, event, sizeof(*tcm), flags);\n\ttcm = NLMSG_DATA(nlh);\n\ttcm->tcm_family = AF_UNSPEC;\n\ttcm->tcm_ifindex = tp->q->dev->ifindex;\n\ttcm->tcm_parent = tp->classid;\n\ttcm->tcm_info = TC_H_MAKE(tp->prio, tp->protocol);\n\tRTA_PUT(skb, TCA_KIND, IFNAMSIZ, tp->ops->kind);\n\ttcm->tcm_handle = fh;\n\tif (RTM_DELTFILTER != event) {\n\t\ttcm->tcm_handle = 0;\n\t\tif (tp->ops->dump && tp->ops->dump(tp, fh, skb, tcm) < 0)\n\t\t\tgoto rtattr_failure;\n\t}\n\tnlh->nlmsg_len = skb->tail - b;\n\treturn skb->len;\n\nnlmsg_failure:\nrtattr_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}",
        "target": 1
    },
    {
        "func": "static int tc_fill_qdisc(struct sk_buff *skb, struct Qdisc *q, u32 clid,\n\t\t\t u32 pid, u32 seq, u16 flags, int event)\n{\n\tstruct tcmsg *tcm;\n\tstruct nlmsghdr  *nlh;\n\tunsigned char\t *b = skb->tail;\n\tstruct gnet_dump d;\n\n\tnlh = NLMSG_NEW(skb, pid, seq, event, sizeof(*tcm), flags);\n\ttcm = NLMSG_DATA(nlh);\n\ttcm->tcm_family = AF_UNSPEC;\n\ttcm->tcm_ifindex = q->dev->ifindex;\n\ttcm->tcm_parent = clid;\n\ttcm->tcm_handle = q->handle;\n\ttcm->tcm_info = atomic_read(&q->refcnt);\n\tRTA_PUT(skb, TCA_KIND, IFNAMSIZ, q->ops->id);\n\tif (q->ops->dump && q->ops->dump(q, skb) < 0)\n\t\tgoto rtattr_failure;\n\tq->qstats.qlen = q->q.qlen;\n\n\tif (gnet_stats_start_copy_compat(skb, TCA_STATS2, TCA_STATS,\n\t\t\tTCA_XSTATS, q->stats_lock, &d) < 0)\n\t\tgoto rtattr_failure;\n\n\tif (q->ops->dump_stats && q->ops->dump_stats(q, &d) < 0)\n\t\tgoto rtattr_failure;\n\n\tif (gnet_stats_copy_basic(&d, &q->bstats) < 0 ||\n#ifdef CONFIG_NET_ESTIMATOR\n\t    gnet_stats_copy_rate_est(&d, &q->rate_est) < 0 ||\n#endif\n\t    gnet_stats_copy_queue(&d, &q->qstats) < 0)\n\t\tgoto rtattr_failure;\n\t\n\tif (gnet_stats_finish_copy(&d) < 0)\n\t\tgoto rtattr_failure;\n\t\n\tnlh->nlmsg_len = skb->tail - b;\n\treturn skb->len;\n\nnlmsg_failure:\nrtattr_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}",
        "target": 1
    },
    {
        "func": "static int neightbl_fill_param_info(struct neigh_table *tbl,\n\t\t\t\t    struct neigh_parms *parms,\n\t\t\t\t    struct sk_buff *skb,\n\t\t\t\t    struct netlink_callback *cb)\n{\n\tstruct ndtmsg *ndtmsg;\n\tstruct nlmsghdr *nlh;\n\n\tnlh = NLMSG_NEW_ANSWER(skb, cb, RTM_NEWNEIGHTBL, sizeof(struct ndtmsg),\n\t\t\t       NLM_F_MULTI);\n\n\tndtmsg = NLMSG_DATA(nlh);\n\n\tread_lock_bh(&tbl->lock);\n\tndtmsg->ndtm_family = tbl->family;\n\tRTA_PUT_STRING(skb, NDTA_NAME, tbl->id);\n\n\tif (neightbl_fill_parms(skb, parms) < 0)\n\t\tgoto rtattr_failure;\n\n\tread_unlock_bh(&tbl->lock);\n\treturn NLMSG_END(skb, nlh);\n\nrtattr_failure:\n\tread_unlock_bh(&tbl->lock);\n\treturn NLMSG_CANCEL(skb, nlh);\n\nnlmsg_failure:\n\treturn -1;\n}",
        "target": 1
    },
    {
        "func": "static int tca_action_flush(struct rtattr *rta, struct nlmsghdr *n, u32 pid)\n{\n\tstruct sk_buff *skb;\n\tunsigned char *b;\n\tstruct nlmsghdr *nlh;\n\tstruct tcamsg *t;\n\tstruct netlink_callback dcb;\n\tstruct rtattr *x;\n\tstruct rtattr *tb[TCA_ACT_MAX+1];\n\tstruct rtattr *kind;\n\tstruct tc_action *a = create_a(0);\n\tint err = -EINVAL;\n\n\tif (a == NULL) {\n\t\tprintk(\"tca_action_flush: couldnt create tc_action\\n\");\n\t\treturn err;\n\t}\n\n\tskb = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!skb) {\n\t\tprintk(\"tca_action_flush: failed skb alloc\\n\");\n\t\tkfree(a);\n\t\treturn -ENOBUFS;\n\t}\n\n\tb = (unsigned char *)skb->tail;\n\n\tif (rtattr_parse_nested(tb, TCA_ACT_MAX, rta) < 0)\n\t\tgoto err_out;\n\n\tkind = tb[TCA_ACT_KIND-1];\n\ta->ops = tc_lookup_action(kind);\n\tif (a->ops == NULL)\n\t\tgoto err_out;\n\n\tnlh = NLMSG_PUT(skb, pid, n->nlmsg_seq, RTM_DELACTION, sizeof(*t));\n\tt = NLMSG_DATA(nlh);\n\tt->tca_family = AF_UNSPEC;\n\n\tx = (struct rtattr *) skb->tail;\n\tRTA_PUT(skb, TCA_ACT_TAB, 0, NULL);\n\n\terr = a->ops->walk(skb, &dcb, RTM_DELACTION, a);\n\tif (err < 0)\n\t\tgoto rtattr_failure;\n\n\tx->rta_len = skb->tail - (u8 *) x;\n\n\tnlh->nlmsg_len = skb->tail - b;\n\tnlh->nlmsg_flags |= NLM_F_ROOT;\n\tmodule_put(a->ops->owner);\n\tkfree(a);\n\terr = rtnetlink_send(skb, pid, RTMGRP_TC, n->nlmsg_flags&NLM_F_ECHO);\n\tif (err > 0)\n\t\treturn 0;\n\n\treturn err;\n\nrtattr_failure:\n\tmodule_put(a->ops->owner);\nnlmsg_failure:\nerr_out:\n\tkfree_skb(skb);\n\tkfree(a);\n\treturn err;\n}",
        "target": 1
    },
    {
        "func": "__rta_reserve(struct sk_buff *skb, int attrtype, int attrlen)\n{\n\tstruct rtattr *rta;\n\tint size = RTA_LENGTH(attrlen);\n\n\trta = (struct rtattr*)skb_put(skb, RTA_ALIGN(size));\n\trta->rta_type = attrtype;\n\trta->rta_len = size;\n\treturn rta;\n}",
        "target": 1
    },
    {
        "func": "void __rta_fill(struct sk_buff *skb, int attrtype, int attrlen, const void *data)\n{\n\tstruct rtattr *rta;\n\tint size = RTA_LENGTH(attrlen);\n\n\trta = (struct rtattr*)skb_put(skb, RTA_ALIGN(size));\n\trta->rta_type = attrtype;\n\trta->rta_len = size;\n\tmemcpy(RTA_DATA(rta), data, attrlen);\n}",
        "target": 1
    },
    {
        "func": "__nlmsg_put(struct sk_buff *skb, u32 pid, u32 seq, int type, int len, int flags)\n{\n\tstruct nlmsghdr *nlh;\n\tint size = NLMSG_LENGTH(len);\n\n\tnlh = (struct nlmsghdr*)skb_put(skb, NLMSG_ALIGN(size));\n\tnlh->nlmsg_type = type;\n\tnlh->nlmsg_len = size;\n\tnlh->nlmsg_flags = flags;\n\tnlh->nlmsg_pid = pid;\n\tnlh->nlmsg_seq = seq;\n\treturn nlh;\n}",
        "target": 1
    },
    {
        "func": "void saveVCard (TNEFStruct *tnef, const gchar *tmpdir) {\n    gchar ifilename[512];\n    FILE *fptr;\n    variableLength *vl;\n    variableLength *pobox, *street, *city, *state, *zip, *country;\n    dtr thedate;\n    gint boolean, i;\n\n    if ((vl = MAPIFindProperty (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, PR_DISPLAY_NAME))) == MAPI_UNDEFINED) {\n        if ((vl=MAPIFindProperty (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, PR_COMPANY_NAME))) == MAPI_UNDEFINED) {\n            if (tnef->subject.size > 0) {\n                sprintf(ifilename, \"%s/%s.vcard\", tmpdir, tnef->subject.data);\n            } else {\n                sprintf(ifilename, \"%s/unknown.vcard\", tmpdir);\n            }\n        } else {\n            sprintf(ifilename, \"%s/%s.vcard\", tmpdir, vl->data);\n        }\n    } else {\n        sprintf(ifilename, \"%s/%s.vcard\", tmpdir, vl->data);\n    }\n    for (i=0; i<strlen (ifilename); i++)\n        if (ifilename[i] == ' ')\n            ifilename[i] = '_';\n    printf(\"%s\\n\", ifilename);\n\n    if ((fptr = fopen(ifilename, \"wb\"))==NULL) {\n            printf(\"Error writing file to disk!\");\n    } else {\n        fprintf(fptr, \"BEGIN:VCARD\\n\");\n        fprintf(fptr, \"VERSION:2.1\\n\");\n        if (vl != MAPI_UNDEFINED) {\n            fprintf(fptr, \"FN:%s\\n\", vl->data);\n        }\n        fprintProperty(tnef, fptr, PT_STRING8, PR_NICKNAME, \"NICKNAME:%s\\n\");\n        fprintUserProp(tnef, fptr, PT_STRING8, 0x8554, \"MAILER:Microsoft Outlook %s\\n\");\n        fprintProperty(tnef, fptr, PT_STRING8, PR_SPOUSE_NAME, \"X-EVOLUTION-SPOUSE:%s\\n\");\n        fprintProperty(tnef, fptr, PT_STRING8, PR_MANAGER_NAME, \"X-EVOLUTION-MANAGER:%s\\n\");\n        fprintProperty(tnef, fptr, PT_STRING8, PR_ASSISTANT, \"X-EVOLUTION-ASSISTANT:%s\\n\");\n\n        /* Organizational */\n        if ((vl=MAPIFindProperty (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, PR_COMPANY_NAME))) != MAPI_UNDEFINED) {\n            if (vl->size > 0) {\n                if ((vl->size == 1) && (vl->data[0] == 0)) {\n                } else {\n                    fprintf(fptr,\"ORG:%s\", vl->data);\n                    if ((vl=MAPIFindProperty (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, PR_DEPARTMENT_NAME))) != MAPI_UNDEFINED) {\n                        fprintf(fptr,\";%s\", vl->data);\n                    }\n                    fprintf(fptr, \"\\n\");\n                }\n            }\n        }\n\n        fprintProperty(tnef, fptr, PT_STRING8, PR_OFFICE_LOCATION, \"X-EVOLUTION-OFFICE:%s\\n\");\n        fprintProperty(tnef, fptr, PT_STRING8, PR_TITLE, \"TITLE:%s\\n\");\n        fprintProperty(tnef, fptr, PT_STRING8, PR_PROFESSION, \"ROLE:%s\\n\");\n        fprintProperty(tnef, fptr, PT_STRING8, PR_BODY, \"NOTE:%s\\n\");\n        if (tnef->body.size > 0) {\n            fprintf(fptr, \"NOTE;QUOTED-PRINTABLE:\");\n            quotedfprint (fptr, &(tnef->body));\n            fprintf(fptr,\"\\n\");\n        }\n\n        /* Business Address */\n        boolean = 0;\n        if ((pobox = MAPIFindProperty (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, PR_POST_OFFICE_BOX))) != MAPI_UNDEFINED) {\n            boolean = 1;\n        }\n        if ((street = MAPIFindProperty (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, PR_STREET_ADDRESS))) != MAPI_UNDEFINED) {\n            boolean = 1;\n        }\n        if ((city = MAPIFindProperty (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, PR_LOCALITY))) != MAPI_UNDEFINED) {\n            boolean = 1;\n        }\n        if ((state = MAPIFindProperty (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, PR_STATE_OR_PROVINCE))) != MAPI_UNDEFINED) {\n            boolean = 1;\n        }\n        if ((zip = MAPIFindProperty (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, PR_POSTAL_CODE))) != MAPI_UNDEFINED) {\n            boolean = 1;\n        }\n        if ((country = MAPIFindProperty (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, PR_COUNTRY))) != MAPI_UNDEFINED) {\n            boolean = 1;\n        }\n        if (boolean == 1) {\n            fprintf(fptr, \"ADR;QUOTED-PRINTABLE;WORK:\");\n            if (pobox != MAPI_UNDEFINED) {\n                quotedfprint (fptr, pobox);\n            }\n            fprintf(fptr, \";;\");\n            if (street != MAPI_UNDEFINED) {\n                quotedfprint (fptr, street);\n            }\n            fprintf(fptr, \";\");\n            if (city != MAPI_UNDEFINED) {\n                quotedfprint (fptr, city);\n            }\n            fprintf(fptr, \";\");\n            if (state != MAPI_UNDEFINED) {\n                quotedfprint (fptr, state);\n            }\n            fprintf(fptr, \";\");\n            if (zip != MAPI_UNDEFINED) {\n                quotedfprint (fptr, zip);\n            }\n            fprintf(fptr, \";\");\n            if (country != MAPI_UNDEFINED) {\n                quotedfprint (fptr, country);\n            }\n            fprintf(fptr,\"\\n\");\n            if ((vl = MAPIFindUserProp (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, 0x801b))) != MAPI_UNDEFINED) {\n                fprintf(fptr, \"LABEL;QUOTED-PRINTABLE;WORK:\");\n                quotedfprint (fptr, vl);\n                fprintf(fptr,\"\\n\");\n            }\n        }\n\n        /* Home Address */\n        boolean = 0;\n        if ((pobox = MAPIFindProperty (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, PR_HOME_ADDRESS_POST_OFFICE_BOX))) != MAPI_UNDEFINED) {\n            boolean = 1;\n        }\n        if ((street = MAPIFindProperty (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, PR_HOME_ADDRESS_STREET))) != MAPI_UNDEFINED) {\n            boolean = 1;\n        }\n        if ((city = MAPIFindProperty (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, PR_HOME_ADDRESS_CITY))) != MAPI_UNDEFINED) {\n            boolean = 1;\n        }\n        if ((state = MAPIFindProperty (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, PR_HOME_ADDRESS_STATE_OR_PROVINCE))) != MAPI_UNDEFINED) {\n            boolean = 1;\n        }\n        if ((zip = MAPIFindProperty (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, PR_HOME_ADDRESS_POSTAL_CODE))) != MAPI_UNDEFINED) {\n            boolean = 1;\n        }\n        if ((country = MAPIFindProperty (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, PR_HOME_ADDRESS_COUNTRY))) != MAPI_UNDEFINED) {\n            boolean = 1;\n        }\n        if (boolean == 1) {\n            fprintf(fptr, \"ADR;QUOTED-PRINTABLE;HOME:\");\n            if (pobox != MAPI_UNDEFINED) {\n                quotedfprint (fptr, pobox);\n            }\n            fprintf(fptr, \";;\");\n            if (street != MAPI_UNDEFINED) {\n                quotedfprint (fptr, street);\n            }\n            fprintf(fptr, \";\");\n            if (city != MAPI_UNDEFINED) {\n                quotedfprint (fptr, city);\n            }\n            fprintf(fptr, \";\");\n            if (state != MAPI_UNDEFINED) {\n                quotedfprint (fptr, state);\n            }\n            fprintf(fptr, \";\");\n            if (zip != MAPI_UNDEFINED) {\n                quotedfprint (fptr, zip);\n            }\n            fprintf(fptr, \";\");\n            if (country != MAPI_UNDEFINED) {\n                quotedfprint (fptr, country);\n            }\n            fprintf(fptr,\"\\n\");\n            if ((vl = MAPIFindUserProp (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, 0x801a))) != MAPI_UNDEFINED) {\n                fprintf(fptr, \"LABEL;QUOTED-PRINTABLE;WORK:\");\n                quotedfprint (fptr, vl);\n                fprintf(fptr,\"\\n\");\n            }\n        }\n\n        /* Other Address */\n        boolean = 0;\n        if ((pobox = MAPIFindProperty (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, PR_OTHER_ADDRESS_POST_OFFICE_BOX))) != MAPI_UNDEFINED) {\n            boolean = 1;\n        }\n        if ((street = MAPIFindProperty (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, PR_OTHER_ADDRESS_STREET))) != MAPI_UNDEFINED) {\n            boolean = 1;\n        }\n        if ((city = MAPIFindProperty (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, PR_OTHER_ADDRESS_CITY))) != MAPI_UNDEFINED) {\n            boolean = 1;\n        }\n        if ((state = MAPIFindProperty (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, PR_OTHER_ADDRESS_STATE_OR_PROVINCE))) != MAPI_UNDEFINED) {\n            boolean = 1;\n        }\n        if ((zip = MAPIFindProperty (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, PR_OTHER_ADDRESS_POSTAL_CODE))) != MAPI_UNDEFINED) {\n            boolean = 1;\n        }\n        if ((country = MAPIFindProperty (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, PR_OTHER_ADDRESS_COUNTRY))) != MAPI_UNDEFINED) {\n            boolean = 1;\n        }\n        if (boolean == 1) {\n            fprintf(fptr, \"ADR;QUOTED-PRINTABLE;OTHER:\");\n            if (pobox != MAPI_UNDEFINED) {\n                quotedfprint (fptr, pobox);\n            }\n            fprintf(fptr, \";;\");\n            if (street != MAPI_UNDEFINED) {\n                quotedfprint (fptr, street);\n            }\n            fprintf(fptr, \";\");\n            if (city != MAPI_UNDEFINED) {\n                quotedfprint (fptr, city);\n            }\n            fprintf(fptr, \";\");\n            if (state != MAPI_UNDEFINED) {\n                quotedfprint (fptr, state);\n            }\n            fprintf(fptr, \";\");\n            if (zip != MAPI_UNDEFINED) {\n                quotedfprint (fptr, zip);\n            }\n            fprintf(fptr, \";\");\n            if (country != MAPI_UNDEFINED) {\n                quotedfprint (fptr, country);\n            }\n            fprintf(fptr,\"\\n\");\n        }\n\n        fprintProperty(tnef, fptr, PT_STRING8, PR_CALLBACK_TELEPHONE_NUMBER, \"TEL;X-EVOLUTION-CALLBACK:%s\\n\");\n        fprintProperty(tnef, fptr, PT_STRING8, PR_PRIMARY_TELEPHONE_NUMBER, \"TEL;PREF:%s\\n\");\n        fprintProperty(tnef, fptr, PT_STRING8, PR_MOBILE_TELEPHONE_NUMBER, \"TEL;CELL:%s\\n\");\n        fprintProperty(tnef, fptr, PT_STRING8, PR_RADIO_TELEPHONE_NUMBER, \"TEL;X-EVOLUTION-RADIO:%s\\n\");\n        fprintProperty(tnef, fptr, PT_STRING8, PR_CAR_TELEPHONE_NUMBER, \"TEL;CAR:%s\\n\");\n        fprintProperty(tnef, fptr, PT_STRING8, PR_OTHER_TELEPHONE_NUMBER, \"TEL;VOICE:%s\\n\");\n        fprintProperty(tnef, fptr, PT_STRING8, PR_PAGER_TELEPHONE_NUMBER, \"TEL;PAGER:%s\\n\");\n        fprintProperty(tnef, fptr, PT_STRING8, PR_TELEX_NUMBER, \"TEL;X-EVOLUTION-TELEX:%s\\n\");\n        fprintProperty(tnef, fptr, PT_STRING8, PR_ISDN_NUMBER, \"TEL;ISDN:%s\\n\");\n        fprintProperty(tnef, fptr, PT_STRING8, PR_HOME2_TELEPHONE_NUMBER, \"TEL;HOME:%s\\n\");\n        fprintProperty(tnef, fptr, PT_STRING8, PR_TTYTDD_PHONE_NUMBER, \"TEL;X-EVOLUTION-TTYTDD:%s\\n\");\n        fprintProperty(tnef, fptr, PT_STRING8, PR_HOME_TELEPHONE_NUMBER, \"TEL;HOME;VOICE:%s\\n\");\n        fprintProperty(tnef, fptr, PT_STRING8, PR_ASSISTANT_TELEPHONE_NUMBER, \"TEL;X-EVOLUTION-ASSISTANT:%s\\n\");\n        fprintProperty(tnef, fptr, PT_STRING8, PR_COMPANY_MAIN_PHONE_NUMBER, \"TEL;WORK:%s\\n\");\n        fprintProperty(tnef, fptr, PT_STRING8, PR_BUSINESS_TELEPHONE_NUMBER, \"TEL;WORK:%s\\n\");\n        fprintProperty(tnef, fptr, PT_STRING8, PR_BUSINESS2_TELEPHONE_NUMBER, \"TEL;WORK;VOICE:%s\\n\");\n        fprintProperty(tnef, fptr, PT_STRING8, PR_PRIMARY_FAX_NUMBER, \"TEL;PREF;FAX:%s\\n\");\n        fprintProperty(tnef, fptr, PT_STRING8, PR_BUSINESS_FAX_NUMBER, \"TEL;WORK;FAX:%s\\n\");\n        fprintProperty(tnef, fptr, PT_STRING8, PR_HOME_FAX_NUMBER, \"TEL;HOME;FAX:%s\\n\");\n\n        /* Email addresses */\n        if ((vl=MAPIFindUserProp (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, 0x8083))) == MAPI_UNDEFINED) {\n            vl=MAPIFindUserProp (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, 0x8084));\n        }\n        if (vl != MAPI_UNDEFINED) {\n            if (vl->size > 0)\n                fprintf(fptr, \"EMAIL:%s\\n\", vl->data);\n        }\n        if ((vl=MAPIFindUserProp (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, 0x8093))) == MAPI_UNDEFINED) {\n            vl=MAPIFindUserProp (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, 0x8094));\n        }\n        if (vl != MAPI_UNDEFINED) {\n            if (vl->size > 0)\n                fprintf(fptr, \"EMAIL:%s\\n\", vl->data);\n        }\n        if ((vl=MAPIFindUserProp (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, 0x80a3))) == MAPI_UNDEFINED) {\n            vl=MAPIFindUserProp (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, 0x80a4));\n        }\n        if (vl != MAPI_UNDEFINED) {\n            if (vl->size > 0)\n                fprintf(fptr, \"EMAIL:%s\\n\", vl->data);\n        }\n\n        fprintProperty(tnef, fptr, PT_STRING8, PR_BUSINESS_HOME_PAGE, \"URL:%s\\n\");\n        fprintUserProp(tnef, fptr, PT_STRING8, 0x80d8, \"FBURL:%s\\n\");\n\n        /* Birthday */\n        if ((vl=MAPIFindProperty (&(tnef->MapiProperties), PROP_TAG (PT_SYSTIME, PR_BIRTHDAY))) != MAPI_UNDEFINED) {\n            fprintf(fptr, \"BDAY:\");\n            MAPISysTimetoDTR ((guchar *) vl->data, &thedate);\n            fprintf(fptr, \"%i-%02i-%02i\\n\", thedate.wYear, thedate.wMonth, thedate.wDay);\n        }\n\n        /* Anniversary */\n        if ((vl=MAPIFindProperty (&(tnef->MapiProperties), PROP_TAG (PT_SYSTIME, PR_WEDDING_ANNIVERSARY))) != MAPI_UNDEFINED) {\n            fprintf(fptr, \"X-EVOLUTION-ANNIVERSARY:\");\n            MAPISysTimetoDTR ((guchar *) vl->data, &thedate);\n            fprintf(fptr, \"%i-%02i-%02i\\n\", thedate.wYear, thedate.wMonth, thedate.wDay);\n        }\n        fprintf(fptr, \"END:VCARD\\n\");\n        fclose (fptr);\n    }\n}",
        "target": 1
    },
    {
        "func": "void processTnef (TNEFStruct *tnef, const gchar *tmpdir) {\n    variableLength *filename;\n    variableLength *filedata;\n    Attachment *p;\n    gint RealAttachment;\n    gint object;\n    gchar ifilename[256];\n    gint i, count;\n    gint foundCal=0;\n\n    FILE *fptr;\n\n    /* First see if this requires special processing. */\n    /* ie: it's a Contact Card, Task, or Meeting request (vCal/vCard) */\n    if (tnef->messageClass[0] != 0)  {\n        if (strcmp(tnef->messageClass, \"IPM.Contact\") == 0) {\n            saveVCard (tnef, tmpdir);\n        }\n        if (strcmp(tnef->messageClass, \"IPM.Task\") == 0) {\n            saveVTask (tnef, tmpdir);\n        }\n        if (strcmp(tnef->messageClass, \"IPM.Appointment\") == 0) {\n            saveVCalendar (tnef, tmpdir);\n            foundCal = 1;\n        }\n    }\n\n    if ((filename = MAPIFindUserProp (&(tnef->MapiProperties),\n                        PROP_TAG (PT_STRING8,0x24))) != MAPI_UNDEFINED) {\n        if (strcmp(filename->data, \"IPM.Appointment\") == 0) {\n             /* If it's \"indicated\" twice, we don't want to save 2 calendar entries. */\n            if (foundCal == 0) {\n                saveVCalendar (tnef, tmpdir);\n            }\n        }\n    }\n\n    if (strcmp(tnef->messageClass, \"IPM.Microsoft Mail.Note\") == 0) {\n        if ((saveRTF == 1) && (tnef->subject.size > 0)) {\n            /*  Description */\n            if ((filename=MAPIFindProperty (&(tnef->MapiProperties),\n\t\t\t\t\t   PROP_TAG (PT_BINARY, PR_RTF_COMPRESSED)))\n                    != MAPI_UNDEFINED) {\n                variableLength buf;\n                if ((buf.data = (gchar *) DecompressRTF (filename, &buf.size)) != NULL) {\n                    sprintf(ifilename, \"%s/%s.rtf\", tmpdir, tnef->subject.data);\n                    for (i=0; i<strlen (ifilename); i++)\n                        if (ifilename[i] == ' ')\n                            ifilename[i] = '_';\n\n                    if ((fptr = fopen(ifilename, \"wb\"))==NULL) {\n                        printf(\"ERROR: Error writing file to disk!\");\n                    } else {\n                        fwrite (buf.data,\n                                sizeof (BYTE),\n                                buf.size,\n                                fptr);\n                        fclose (fptr);\n                    }\n                    free (buf.data);\n                }\n            }\n\t}\n    }\n\n    /* Now process each attachment */\n    p = tnef->starting_attach.next;\n    count = 0;\n    while (p != NULL) {\n        count++;\n        /* Make sure it has a size. */\n        if (p->FileData.size > 0) {\n            object = 1;\n\n            /* See if the contents are stored as \"attached data\" */\n\t    /* Inside the MAPI blocks. */\n            if ((filedata = MAPIFindProperty (&(p->MAPI),\n                                    PROP_TAG (PT_OBJECT, PR_ATTACH_DATA_OBJ)))\n                    == MAPI_UNDEFINED) {\n                if ((filedata = MAPIFindProperty (&(p->MAPI),\n                                    PROP_TAG (PT_BINARY, PR_ATTACH_DATA_OBJ)))\n\t\t   == MAPI_UNDEFINED) {\n                    /* Nope, standard TNEF stuff. */\n                    filedata = &(p->FileData);\n                    object = 0;\n                }\n            }\n            /* See if this is an embedded TNEF stream. */\n            RealAttachment = 1;\n            if (object == 1) {\n                /*  This is an \"embedded object\", so skip the */\n                /* 16-byte identifier first. */\n                TNEFStruct emb_tnef;\n                DWORD signature;\n                memcpy (&signature, filedata->data+16, sizeof (DWORD));\n                if (TNEFCheckForSignature (signature) == 0) {\n                    /* Has a TNEF signature, so process it. */\n                    TNEFInitialize (&emb_tnef);\n                    emb_tnef.Debug = tnef->Debug;\n                    if (TNEFParseMemory ((guchar *) filedata->data+16,\n                             filedata->size-16, &emb_tnef) != -1) {\n                        processTnef (&emb_tnef, tmpdir);\n                        RealAttachment = 0;\n                    }\n                    TNEFFree (&emb_tnef);\n                }\n            } else {\n                TNEFStruct emb_tnef;\n                DWORD signature;\n                memcpy (&signature, filedata->data, sizeof (DWORD));\n                if (TNEFCheckForSignature (signature) == 0) {\n                    /* Has a TNEF signature, so process it. */\n                    TNEFInitialize (&emb_tnef);\n                    emb_tnef.Debug = tnef->Debug;\n                    if (TNEFParseMemory ((guchar *) filedata->data,\n                            filedata->size, &emb_tnef) != -1) {\n                        processTnef (&emb_tnef, tmpdir);\n                        RealAttachment = 0;\n                    }\n                    TNEFFree (&emb_tnef);\n                }\n            }\n            if ((RealAttachment == 1) || (saveintermediate == 1)) {\n\t\tgchar tmpname[20];\n                /* Ok, it's not an embedded stream, so now we */\n\t\t/* process it. */\n                if ((filename = MAPIFindProperty (&(p->MAPI),\n                                        PROP_TAG (PT_STRING8, PR_ATTACH_LONG_FILENAME)))\n                        == MAPI_UNDEFINED) {\n                    if ((filename = MAPIFindProperty (&(p->MAPI),\n                                        PROP_TAG (PT_STRING8, PR_DISPLAY_NAME)))\n                            == MAPI_UNDEFINED) {\n                        filename = &(p->Title);\n                    }\n                }\n                if (filename->size == 1) {\n                    filename->size = 20;\n                    sprintf(tmpname, \"file_%03i.dat\", count);\n                    filename->data = tmpname;\n                }\n                sprintf(ifilename, \"%s/%s\", tmpdir, filename->data);\n                for (i=0; i<strlen (ifilename); i++)\n                    if (ifilename[i] == ' ')\n                        ifilename[i] = '_';\n\n\t\tif ((fptr = fopen(ifilename, \"wb\"))==NULL) {\n\t\t    printf(\"ERROR: Error writing file to disk!\");\n\t\t} else {\n\t\t    if (object == 1) {\n\t\t\tfwrite (filedata->data + 16,\n\t\t\t       sizeof (BYTE),\n\t\t\t       filedata->size - 16,\n\t\t\t       fptr);\n\t\t    } else {\n\t\t\tfwrite (filedata->data,\n\t\t\t       sizeof (BYTE),\n\t\t\t       filedata->size,\n\t\t\t       fptr);\n\t\t    }\n\t\t    fclose (fptr);\n\t\t}\n            }\n        } /* if size>0 */\n        p=p->next;\n    } /* while p!= null */\n}",
        "target": 1
    },
    {
        "func": "void saveVTask (TNEFStruct *tnef, const gchar *tmpdir) {\n    variableLength *vl;\n    variableLength *filename;\n    gint index,i;\n    gchar ifilename[256];\n    gchar *charptr, *charptr2;\n    dtr thedate;\n    FILE *fptr;\n    DWORD *dword_ptr;\n    DWORD dword_val;\n\n    vl = MAPIFindProperty (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, PR_CONVERSATION_TOPIC));\n\n    if (vl == MAPI_UNDEFINED) {\n        return;\n    }\n\n    index = strlen (vl->data);\n    while (vl->data[index] == ' ')\n            vl->data[index--] = 0;\n\n    sprintf(ifilename, \"%s/%s.ics\", tmpdir, vl->data);\n    for (i=0; i<strlen (ifilename); i++)\n        if (ifilename[i] == ' ')\n            ifilename[i] = '_';\n    printf(\"%s\\n\", ifilename);\n\n    if ((fptr = fopen(ifilename, \"wb\"))==NULL) {\n            printf(\"Error writing file to disk!\");\n    } else {\n        fprintf(fptr, \"BEGIN:VCALENDAR\\n\");\n        fprintf(fptr, \"VERSION:2.0\\n\");\n        fprintf(fptr, \"METHOD:PUBLISH\\n\");\n        filename = NULL;\n\n        fprintf(fptr, \"BEGIN:VTODO\\n\");\n        if (tnef->messageID[0] != 0) {\n            fprintf(fptr,\"UID:%s\\n\", tnef->messageID);\n        }\n        filename = MAPIFindUserProp (&(tnef->MapiProperties), \\\n                        PROP_TAG (PT_STRING8, 0x8122));\n        if (filename != MAPI_UNDEFINED) {\n            fprintf(fptr, \"ORGANIZER:%s\\n\", filename->data);\n        }\n\n        if ((filename = MAPIFindProperty (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, PR_DISPLAY_TO))) != MAPI_UNDEFINED) {\n            filename = MAPIFindUserProp (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, 0x811f));\n        }\n        if ((filename != MAPI_UNDEFINED) && (filename->size > 1)) {\n            charptr = filename->data-1;\n            while (charptr != NULL) {\n                charptr++;\n                charptr2 = strstr(charptr, \";\");\n                if (charptr2 != NULL) {\n                    *charptr2 = 0;\n                }\n                while (*charptr == ' ')\n                    charptr++;\n                fprintf(fptr, \"ATTENDEE;CN=%s;ROLE=REQ-PARTICIPANT:%s\\n\", charptr, charptr);\n                charptr = charptr2;\n            }\n        }\n\n        if (tnef->subject.size > 0) {\n            fprintf(fptr,\"SUMMARY:\");\n            cstylefprint (fptr,&(tnef->subject));\n            fprintf(fptr,\"\\n\");\n        }\n\n        if (tnef->body.size > 0) {\n            fprintf(fptr,\"DESCRIPTION:\");\n            cstylefprint (fptr,&(tnef->body));\n            fprintf(fptr,\"\\n\");\n        }\n\n        filename = MAPIFindProperty (&(tnef->MapiProperties), \\\n                    PROP_TAG (PT_SYSTIME, PR_CREATION_TIME));\n        if (filename != MAPI_UNDEFINED) {\n            fprintf(fptr, \"DTSTAMP:\");\n            MAPISysTimetoDTR ((guchar *) filename->data, &thedate);\n            fprintf(fptr,\"%04i%02i%02iT%02i%02i%02iZ\\n\",\n                    thedate.wYear, thedate.wMonth, thedate.wDay,\n                    thedate.wHour, thedate.wMinute, thedate.wSecond);\n        }\n\n        filename = MAPIFindUserProp (&(tnef->MapiProperties), \\\n                    PROP_TAG (PT_SYSTIME, 0x8517));\n        if (filename != MAPI_UNDEFINED) {\n            fprintf(fptr, \"DUE:\");\n            MAPISysTimetoDTR ((guchar *) filename->data, &thedate);\n            fprintf(fptr,\"%04i%02i%02iT%02i%02i%02iZ\\n\",\n                    thedate.wYear, thedate.wMonth, thedate.wDay,\n                    thedate.wHour, thedate.wMinute, thedate.wSecond);\n        }\n        filename = MAPIFindProperty (&(tnef->MapiProperties), \\\n                    PROP_TAG (PT_SYSTIME, PR_LAST_MODIFICATION_TIME));\n        if (filename != MAPI_UNDEFINED) {\n            fprintf(fptr, \"LAST-MODIFIED:\");\n            MAPISysTimetoDTR ((guchar *) filename->data, &thedate);\n            fprintf(fptr,\"%04i%02i%02iT%02i%02i%02iZ\\n\",\n                    thedate.wYear, thedate.wMonth, thedate.wDay,\n                    thedate.wHour, thedate.wMinute, thedate.wSecond);\n        }\n        /* Class */\n        filename = MAPIFindUserProp (&(tnef->MapiProperties), \\\n                        PROP_TAG (PT_BOOLEAN, 0x8506));\n        if (filename != MAPI_UNDEFINED) {\n            dword_ptr = (DWORD*)filename->data;\n            dword_val = SwapDWord ((BYTE*)dword_ptr);\n            fprintf(fptr, \"CLASS:\" );\n            if (*dword_ptr == 1) {\n                fprintf(fptr,\"PRIVATE\\n\");\n            } else {\n                fprintf(fptr,\"PUBLIC\\n\");\n            }\n        }\n        fprintf(fptr, \"END:VTODO\\n\");\n        fprintf(fptr, \"END:VCALENDAR\\n\");\n        fclose (fptr);\n    }\n\n}",
        "target": 1
    },
    {
        "func": "void saveVCalendar (TNEFStruct *tnef, const gchar *tmpdir) {\n    gchar ifilename[256];\n    variableLength *filename;\n    gchar *charptr, *charptr2;\n    FILE *fptr;\n    gint index;\n    DWORD *dword_ptr;\n    DWORD dword_val;\n    dtr thedate;\n\n    sprintf(ifilename, \"%s/calendar.ics\", tmpdir);\n    printf(\"%s\\n\", ifilename);\n\n    if ((fptr = fopen(ifilename, \"wb\"))==NULL) {\n            printf(\"Error writing file to disk!\");\n    } else {\n        fprintf(fptr, \"BEGIN:VCALENDAR\\n\");\n        if (tnef->messageClass[0] != 0) {\n            charptr2=tnef->messageClass;\n            charptr=charptr2;\n            while (*charptr != 0) {\n                if (*charptr == '.') {\n                    charptr2 = charptr;\n                }\n                charptr++;\n            }\n            if (strcmp(charptr2, \".MtgCncl\") == 0) {\n                fprintf(fptr, \"METHOD:CANCEL\\n\");\n            } else {\n                fprintf(fptr, \"METHOD:REQUEST\\n\");\n            }\n        } else {\n            fprintf(fptr, \"METHOD:REQUEST\\n\");\n        }\n        fprintf(fptr, \"VERSION:2.0\\n\");\n        fprintf(fptr, \"BEGIN:VEVENT\\n\");\n\n\t/* UID\n\t   After alot of comparisons, I'm reasonably sure this is totally\n\t   wrong.  But it's not really necessary. */\n\n\t/* I think it only exists to connect future modification entries to\n\t   this entry. so as long as it's incorrectly interpreted the same way\n\t   every time, it should be ok :) */\n        filename = NULL;\n        if ((filename=MAPIFindUserProp (&(tnef->MapiProperties),\n                        PROP_TAG (PT_BINARY, 0x3))) == MAPI_UNDEFINED) {\n            if ((filename=MAPIFindUserProp (&(tnef->MapiProperties),\n                            PROP_TAG (PT_BINARY, 0x23))) == MAPI_UNDEFINED) {\n                filename = NULL;\n            }\n        }\n        if (filename!=NULL) {\n            fprintf(fptr, \"UID:\");\n            for (index=0;index<filename->size;index++) {\n                fprintf(fptr,\"%02X\", (guchar)filename->data[index]);\n            }\n            fprintf(fptr,\"\\n\");\n        }\n\n        /* Sequence */\n        filename = NULL;\n        if ((filename=MAPIFindUserProp (&(tnef->MapiProperties),\n                        PROP_TAG (PT_LONG, 0x8201))) != MAPI_UNDEFINED) {\n            dword_ptr = (DWORD*)filename->data;\n            fprintf(fptr, \"SEQUENCE:%i\\n\", (gint) *dword_ptr);\n        }\n        if ((filename=MAPIFindProperty (&(tnef->MapiProperties),\n                        PROP_TAG (PT_BINARY, PR_SENDER_SEARCH_KEY)))\n                != MAPI_UNDEFINED) {\n            charptr = filename->data;\n            charptr2 = strstr(charptr, \":\");\n            if (charptr2 == NULL)\n                charptr2 = charptr;\n            else\n                charptr2++;\n            fprintf(fptr, \"ORGANIZER;CN=\\\"%s\\\":MAILTO:%s\\n\",\n                    charptr2, charptr2);\n        }\n\n        /* Required Attendees */\n        if ((filename = MAPIFindUserProp (&(tnef->MapiProperties),\n                        PROP_TAG (PT_STRING8, 0x823b))) != MAPI_UNDEFINED) {\n\t    /* We have a list of required participants, so\n\t       write them out. */\n            if (filename->size > 1) {\n                charptr = filename->data-1;\n                while (charptr != NULL) {\n                    charptr++;\n                    charptr2 = strstr(charptr, \";\");\n                    if (charptr2 != NULL) {\n                        *charptr2 = 0;\n                    }\n                    while (*charptr == ' ')\n                        charptr++;\n                    fprintf(fptr, \"ATTENDEE;PARTSTAT=NEEDS-ACTION;\");\n                    fprintf(fptr, \"ROLE=REQ-PARTICIPANT;RSVP=TRUE;\");\n                    fprintf(fptr, \"CN=\\\"%s\\\":MAILTO:%s\\n\",\n                                charptr, charptr);\n                    charptr = charptr2;\n                }\n            }\n            /* Optional attendees */\n            if ((filename = MAPIFindUserProp (&(tnef->MapiProperties),\n                            PROP_TAG (PT_STRING8, 0x823c))) != MAPI_UNDEFINED) {\n                    /* The list of optional participants */\n                if (filename->size > 1) {\n                    charptr = filename->data-1;\n                    while (charptr != NULL) {\n                        charptr++;\n                        charptr2 = strstr(charptr, \";\");\n                        if (charptr2 != NULL) {\n                            *charptr2 = 0;\n                        }\n                        while (*charptr == ' ')\n                            charptr++;\n                        fprintf(fptr, \"ATTENDEE;PARTSTAT=NEEDS-ACTION;\");\n                        fprintf(fptr, \"ROLE=OPT-PARTICIPANT;RSVP=TRUE;\");\n                        fprintf(fptr, \"CN=\\\"%s\\\":MAILTO:%s\\n\",\n                                charptr, charptr);\n                        charptr = charptr2;\n                    }\n                }\n            }\n        } else if ((filename = MAPIFindUserProp (&(tnef->MapiProperties),\n                        PROP_TAG (PT_STRING8, 0x8238))) != MAPI_UNDEFINED) {\n            if (filename->size > 1) {\n                charptr = filename->data-1;\n                while (charptr != NULL) {\n                    charptr++;\n                    charptr2 = strstr(charptr, \";\");\n                    if (charptr2 != NULL) {\n                        *charptr2 = 0;\n                    }\n                    while (*charptr == ' ')\n                        charptr++;\n                    fprintf(fptr, \"ATTENDEE;PARTSTAT=NEEDS-ACTION;\");\n                    fprintf(fptr, \"ROLE=REQ-PARTICIPANT;RSVP=TRUE;\");\n                    fprintf(fptr, \"CN=\\\"%s\\\":MAILTO:%s\\n\",\n                                charptr, charptr);\n                    charptr = charptr2;\n                }\n            }\n\n        }\n        /* Summary */\n        filename = NULL;\n        if ((filename=MAPIFindProperty (&(tnef->MapiProperties),\n                        PROP_TAG (PT_STRING8, PR_CONVERSATION_TOPIC)))\n                != MAPI_UNDEFINED) {\n            fprintf(fptr, \"SUMMARY:\");\n            cstylefprint (fptr, filename);\n            fprintf(fptr, \"\\n\");\n        }\n\n        /* Description */\n        if ((filename=MAPIFindProperty (&(tnef->MapiProperties),\n                                PROP_TAG (PT_BINARY, PR_RTF_COMPRESSED)))\n                != MAPI_UNDEFINED) {\n            variableLength buf;\n            if ((buf.data = (gchar *) DecompressRTF (filename, &buf.size)) != NULL) {\n                fprintf(fptr, \"DESCRIPTION:\");\n                printRtf (fptr, &buf);\n                free (buf.data);\n            }\n\n        }\n\n        /* Location */\n        filename = NULL;\n        if ((filename=MAPIFindUserProp (&(tnef->MapiProperties),\n                        PROP_TAG (PT_STRING8, 0x0002))) == MAPI_UNDEFINED) {\n            if ((filename=MAPIFindUserProp (&(tnef->MapiProperties),\n                            PROP_TAG (PT_STRING8, 0x8208))) == MAPI_UNDEFINED) {\n                filename = NULL;\n            }\n        }\n        if (filename != NULL) {\n            fprintf(fptr,\"LOCATION: %s\\n\", filename->data);\n        }\n        /* Date Start */\n        filename = NULL;\n        if ((filename=MAPIFindUserProp (&(tnef->MapiProperties),\n                        PROP_TAG (PT_SYSTIME, 0x820d))) == MAPI_UNDEFINED) {\n            if ((filename=MAPIFindUserProp (&(tnef->MapiProperties),\n                            PROP_TAG (PT_SYSTIME, 0x8516))) == MAPI_UNDEFINED) {\n                filename=NULL;\n            }\n        }\n        if (filename != NULL) {\n            fprintf(fptr, \"DTSTART:\");\n            MAPISysTimetoDTR ((guchar *) filename->data, &thedate);\n            fprintf(fptr,\"%04i%02i%02iT%02i%02i%02iZ\\n\",\n                    thedate.wYear, thedate.wMonth, thedate.wDay,\n                    thedate.wHour, thedate.wMinute, thedate.wSecond);\n        }\n        /* Date End */\n        filename = NULL;\n        if ((filename=MAPIFindUserProp (&(tnef->MapiProperties),\n                        PROP_TAG (PT_SYSTIME, 0x820e))) == MAPI_UNDEFINED) {\n            if ((filename=MAPIFindUserProp (&(tnef->MapiProperties),\n                            PROP_TAG (PT_SYSTIME, 0x8517))) == MAPI_UNDEFINED) {\n                filename=NULL;\n            }\n        }\n        if (filename != NULL) {\n            fprintf(fptr, \"DTEND:\");\n            MAPISysTimetoDTR ((guchar *) filename->data, &thedate);\n            fprintf(fptr,\"%04i%02i%02iT%02i%02i%02iZ\\n\",\n                    thedate.wYear, thedate.wMonth, thedate.wDay,\n                    thedate.wHour, thedate.wMinute, thedate.wSecond);\n        }\n        /* Date Stamp */\n        filename = NULL;\n        if ((filename=MAPIFindUserProp (&(tnef->MapiProperties),\n                        PROP_TAG (PT_SYSTIME, 0x8202))) != MAPI_UNDEFINED) {\n            fprintf(fptr, \"CREATED:\");\n            MAPISysTimetoDTR ((guchar *) filename->data, &thedate);\n            fprintf(fptr,\"%04i%02i%02iT%02i%02i%02iZ\\n\",\n                    thedate.wYear, thedate.wMonth, thedate.wDay,\n                    thedate.wHour, thedate.wMinute, thedate.wSecond);\n        }\n        /* Class */\n        filename = NULL;\n        if ((filename=MAPIFindUserProp (&(tnef->MapiProperties),\n                        PROP_TAG (PT_BOOLEAN, 0x8506))) != MAPI_UNDEFINED) {\n            dword_ptr = (DWORD*)filename->data;\n            dword_val = SwapDWord ((BYTE*)dword_ptr);\n            fprintf(fptr, \"CLASS:\" );\n            if (*dword_ptr == 1) {\n                fprintf(fptr,\"PRIVATE\\n\");\n            } else {\n                fprintf(fptr,\"PUBLIC\\n\");\n            }\n        }\n        /* Recurrence */\n        filename = NULL;\n        if ((filename=MAPIFindUserProp (&(tnef->MapiProperties),\n                        PROP_TAG (PT_BINARY, 0x8216))) != MAPI_UNDEFINED) {\n            printRrule (fptr, filename->data, filename->size, tnef);\n        }\n\n        /* Wrap it up */\n        fprintf(fptr, \"END:VEVENT\\n\");\n        fprintf(fptr, \"END:VCALENDAR\\n\");\n        fclose (fptr);\n    }\n}",
        "target": 1
    },
    {
        "func": "static int tcf_fill_node(struct sk_buff *skb, struct tcf_proto *tp,\n\t\t\t unsigned long fh, u32 pid, u32 seq, u16 flags, int event)\n{\n\tstruct tcmsg *tcm;\n\tstruct nlmsghdr  *nlh;\n\tunsigned char *b = skb_tail_pointer(skb);\n\n\tnlh = NLMSG_NEW(skb, pid, seq, event, sizeof(*tcm), flags);\n\ttcm = NLMSG_DATA(nlh);\n\ttcm->tcm_family = AF_UNSPEC;\n\ttcm->tcm__pad1 = 0;\n\ttcm->tcm__pad1 = 0;\n\ttcm->tcm_ifindex = qdisc_dev(tp->q)->ifindex;\n\ttcm->tcm_parent = tp->classid;\n\ttcm->tcm_info = TC_H_MAKE(tp->prio, tp->protocol);\n\tNLA_PUT_STRING(skb, TCA_KIND, tp->ops->kind);\n\ttcm->tcm_handle = fh;\n\tif (RTM_DELTFILTER != event) {\n\t\ttcm->tcm_handle = 0;\n\t\tif (tp->ops->dump && tp->ops->dump(tp, fh, skb, tcm) < 0)\n\t\t\tgoto nla_put_failure;\n\t}\n\tnlh->nlmsg_len = skb_tail_pointer(skb) - b;\n\treturn skb->len;\n\nnlmsg_failure:\nnla_put_failure:\n\tnlmsg_trim(skb, b);\n\treturn -1;\n}",
        "target": 1
    },
    {
        "func": "check_mountpoint(const char *progname, char *mountpoint)\n{\n\tint err;\n\tstruct stat statbuf;\n\n\t/* does mountpoint exist and is it a directory? */\n\terr = stat(mountpoint, &statbuf);\n\tif (err) {\n\t\tfprintf(stderr, \"%s: failed to stat %s: %s\\n\", progname,\n\t\t\t\tmountpoint, strerror(errno));\n\t\treturn EX_USAGE;\n\t}\n\n\tif (!S_ISDIR(statbuf.st_mode)) {\n\t\tfprintf(stderr, \"%s: %s is not a directory!\", progname,\n\t\t\t\tmountpoint);\n\t\treturn EX_USAGE;\n\t}\n\n#if CIFS_LEGACY_SETUID_CHECK\n\t/* do extra checks on mountpoint for legacy setuid behavior */\n\tif (!getuid() || geteuid())\n\t\treturn 0;\n\n\tif (statbuf.st_uid != getuid()) {\n\t\tfprintf(stderr, \"%s: %s is not owned by user\\n\", progname,\n\t\t\tmountpoint);\n\t\treturn EX_USAGE;\n\t}\n\n\tif ((statbuf.st_mode & S_IRWXU) != S_IRWXU) {\n\t\tfprintf(stderr, \"%s: invalid permissions on %s\\n\", progname,\n\t\t\tmountpoint);\n\t\treturn EX_USAGE;\n\t}\n#endif /* CIFS_LEGACY_SETUID_CHECK */\n\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "int main(int argc, char ** argv)\n{\n\tint c;\n\tunsigned long flags = MS_MANDLOCK;\n\tchar * orgoptions = NULL;\n\tchar * share_name = NULL;\n\tconst char * ipaddr = NULL;\n\tchar * uuid = NULL;\n\tchar * mountpoint = NULL;\n\tchar * options = NULL;\n\tchar * optionstail;\n\tchar * resolved_path = NULL;\n\tchar * temp;\n\tchar * dev_name;\n\tint rc = 0;\n\tint rsize = 0;\n\tint wsize = 0;\n\tint nomtab = 0;\n\tint uid = 0;\n\tint gid = 0;\n\tint optlen = 0;\n\tint orgoptlen = 0;\n\tsize_t options_size = 0;\n\tsize_t current_len;\n\tint retry = 0; /* set when we have to retry mount with uppercase */\n\tstruct addrinfo *addrhead = NULL, *addr;\n\tstruct utsname sysinfo;\n\tstruct mntent mountent;\n\tstruct sockaddr_in *addr4;\n\tstruct sockaddr_in6 *addr6;\n\tFILE * pmntfile;\n\n\t/* setlocale(LC_ALL, \"\");\n\tbindtextdomain(PACKAGE, LOCALEDIR);\n\ttextdomain(PACKAGE); */\n\n\tif(argc && argv)\n\t\tthisprogram = argv[0];\n\telse\n\t\tmount_cifs_usage(stderr);\n\n\tif(thisprogram == NULL)\n\t\tthisprogram = \"mount.cifs\";\n\n\tuname(&sysinfo);\n\t/* BB add workstation name and domain and pass down */\n\n/* #ifdef _GNU_SOURCE\n\tfprintf(stderr, \" node: %s machine: %s sysname %s domain %s\\n\", sysinfo.nodename,sysinfo.machine,sysinfo.sysname,sysinfo.domainname);\n#endif */\n\tif(argc > 2) {\n\t\tdev_name = argv[1];\n\t\tshare_name = strndup(argv[1], MAX_UNC_LEN);\n\t\tif (share_name == NULL) {\n\t\t\tfprintf(stderr, \"%s: %s\", argv[0], strerror(ENOMEM));\n\t\t\texit(EX_SYSERR);\n\t\t}\n\t\tmountpoint = argv[2];\n\t} else if (argc == 2) {\n\t\tif ((strcmp(argv[1], \"-V\") == 0) ||\n\t\t    (strcmp(argv[1], \"--version\") == 0))\n\t\t{\n\t\t\tprint_cifs_mount_version();\n\t\t\texit(0);\n\t\t}\n\n\t\tif ((strcmp(argv[1], \"-h\") == 0) ||\n\t\t    (strcmp(argv[1], \"-?\") == 0) ||\n\t\t    (strcmp(argv[1], \"--help\") == 0))\n\t\t\tmount_cifs_usage(stdout);\n\n\t\tmount_cifs_usage(stderr);\n\t} else {\n\t\tmount_cifs_usage(stderr);\n\t}\n\n\n\t/* add sharename in opts string as unc= parm */\n\twhile ((c = getopt_long (argc, argv, \"afFhilL:no:O:rsSU:vVwt:\",\n\t\t\t longopts, NULL)) != -1) {\n\t\tswitch (c) {\n/* No code to do the following  options yet */\n/*\tcase 'l':\n\t\tlist_with_volumelabel = 1;\n\t\tbreak;\n\tcase 'L':\n\t\tvolumelabel = optarg;\n\t\tbreak; */\n/*\tcase 'a':\t       \n\t\t++mount_all;\n\t\tbreak; */\n\n\t\tcase '?':\n\t\tcase 'h':\t /* help */\n\t\t\tmount_cifs_usage(stdout);\n\t\tcase 'n':\n\t\t\t++nomtab;\n\t\t\tbreak;\n\t\tcase 'b':\n#ifdef MS_BIND\n\t\t\tflags |= MS_BIND;\n#else\n\t\t\tfprintf(stderr,\n\t\t\t\t\"option 'b' (MS_BIND) not supported\\n\");\n#endif\n\t\t\tbreak;\n\t\tcase 'm':\n#ifdef MS_MOVE\t\t      \n\t\t\tflags |= MS_MOVE;\n#else\n\t\t\tfprintf(stderr,\n\t\t\t\t\"option 'm' (MS_MOVE) not supported\\n\");\n#endif\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\torgoptions = strdup(optarg);\n\t\t    break;\n\t\tcase 'r':  /* mount readonly */\n\t\t\tflags |= MS_RDONLY;\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\tuuid = optarg;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\t++verboseflag;\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\tprint_cifs_mount_version();\n\t\t\texit (0);\n\t\tcase 'w':\n\t\t\tflags &= ~MS_RDONLY;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\trsize = atoi(optarg) ;\n\t\t\tbreak;\n\t\tcase 'W':\n\t\t\twsize = atoi(optarg);\n\t\t\tbreak;\n\t\tcase '1':\n\t\t\tif (isdigit(*optarg)) {\n\t\t\t\tchar *ep;\n\n\t\t\t\tuid = strtoul(optarg, &ep, 10);\n\t\t\t\tif (*ep) {\n\t\t\t\t\tfprintf(stderr, \"bad uid value \\\"%s\\\"\\n\", optarg);\n\t\t\t\t\texit(EX_USAGE);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstruct passwd *pw;\n\n\t\t\t\tif (!(pw = getpwnam(optarg))) {\n\t\t\t\t\tfprintf(stderr, \"bad user name \\\"%s\\\"\\n\", optarg);\n\t\t\t\t\texit(EX_USAGE);\n\t\t\t\t}\n\t\t\t\tuid = pw->pw_uid;\n\t\t\t\tendpwent();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '2':\n\t\t\tif (isdigit(*optarg)) {\n\t\t\t\tchar *ep;\n\n\t\t\t\tgid = strtoul(optarg, &ep, 10);\n\t\t\t\tif (*ep) {\n\t\t\t\t\tfprintf(stderr, \"bad gid value \\\"%s\\\"\\n\", optarg);\n\t\t\t\t\texit(EX_USAGE);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstruct group *gr;\n\n\t\t\t\tif (!(gr = getgrnam(optarg))) {\n\t\t\t\t\tfprintf(stderr, \"bad user name \\\"%s\\\"\\n\", optarg);\n\t\t\t\t\texit(EX_USAGE);\n\t\t\t\t}\n\t\t\t\tgid = gr->gr_gid;\n\t\t\t\tendpwent();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tgot_user = 1;\n\t\t\tuser_name = optarg;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tdomain_name = optarg; /* BB fix this - currently ignored */\n\t\t\tgot_domain = 1;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tif(mountpassword == NULL)\n\t\t\t\tmountpassword = (char *)calloc(MOUNT_PASSWD_SIZE+1,1);\n\t\t\tif(mountpassword) {\n\t\t\t\tgot_password = 1;\n\t\t\t\tstrlcpy(mountpassword,optarg,MOUNT_PASSWD_SIZE+1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tget_password_from_file(0 /* stdin */,NULL);\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\t++fakemnt;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(stderr, \"unknown mount option %c\\n\",c);\n\t\t\tmount_cifs_usage(stderr);\n\t\t}\n\t}\n\n\tif((argc < 3) || (dev_name == NULL) || (mountpoint == NULL)) {\n\t\tmount_cifs_usage(stderr);\n\t}\n\n\t/* make sure mountpoint is legit */\n\trc = check_mountpoint(thisprogram, mountpoint);\n\tif (rc)\n\t\tgoto mount_exit;\n\n\t/* sanity check for unprivileged mounts */\n\tif (getuid()) {\n\t\trc = check_fstab(thisprogram, mountpoint, dev_name,\n\t\t\t\t &orgoptions);\n\t\tif (rc)\n\t\t\tgoto mount_exit;\n\n\t\t/* enable any default user mount flags */\n\t\tflags |= CIFS_SETUID_FLAGS;\n\t}\n\n\tif (getenv(\"PASSWD\")) {\n\t\tif(mountpassword == NULL)\n\t\t\tmountpassword = (char *)calloc(MOUNT_PASSWD_SIZE+1,1);\n\t\tif(mountpassword) {\n\t\t\tstrlcpy(mountpassword,getenv(\"PASSWD\"),MOUNT_PASSWD_SIZE+1);\n\t\t\tgot_password = 1;\n\t\t}\n\t} else if (getenv(\"PASSWD_FD\")) {\n\t\tget_password_from_file(atoi(getenv(\"PASSWD_FD\")),NULL);\n\t} else if (getenv(\"PASSWD_FILE\")) {\n\t\tget_password_from_file(0, getenv(\"PASSWD_FILE\"));\n\t}\n\n        if (orgoptions && parse_options(&orgoptions, &flags)) {\n                rc = EX_USAGE;\n\t\tgoto mount_exit;\n\t}\n\n\tif (getuid()) {\n#if !CIFS_LEGACY_SETUID_CHECK\n\t\tif (!(flags & (MS_USERS|MS_USER))) {\n\t\t\tfprintf(stderr, \"%s: permission denied\\n\", thisprogram);\n\t\t\trc = EX_USAGE;\n\t\t\tgoto mount_exit;\n\t\t}\n#endif /* !CIFS_LEGACY_SETUID_CHECK */\n\t\t\n\t\tif (geteuid()) {\n\t\t\tfprintf(stderr, \"%s: not installed setuid - \\\"user\\\" \"\n\t\t\t\t\t\"CIFS mounts not supported.\",\n\t\t\t\t\tthisprogram);\n\t\t\trc = EX_FAIL;\n\t\t\tgoto mount_exit;\n\t\t}\n\t}\n\n\tflags &= ~(MS_USERS|MS_USER);\n\n\taddrhead = addr = parse_server(&share_name);\n\tif((addrhead == NULL) && (got_ip == 0)) {\n\t\tfprintf(stderr, \"No ip address specified and hostname not found\\n\");\n\t\trc = EX_USAGE;\n\t\tgoto mount_exit;\n\t}\n\t\n\t/* BB save off path and pop after mount returns? */\n\tresolved_path = (char *)malloc(PATH_MAX+1);\n\tif(resolved_path) {\n\t\t/* Note that if we can not canonicalize the name, we get\n\t\tanother chance to see if it is valid when we chdir to it */\n\t\tif (realpath(mountpoint, resolved_path)) {\n\t\t\tmountpoint = resolved_path; \n\t\t}\n\t}\n\tif(got_user == 0) {\n\t\t/* Note that the password will not be retrieved from the\n\t\t   USER env variable (ie user%password form) as there is\n\t\t   already a PASSWD environment varaible */\n\t\tif (getenv(\"USER\"))\n\t\t\tuser_name = strdup(getenv(\"USER\"));\n\t\tif (user_name == NULL)\n\t\t\tuser_name = getusername();\n\t\tgot_user = 1;\n\t}\n       \n\tif(got_password == 0) {\n\t\tchar *tmp_pass = getpass(\"Password: \"); /* BB obsolete sys call but\n\t\t\t\t\t\t\t   no good replacement yet. */\n\t\tmountpassword = (char *)calloc(MOUNT_PASSWD_SIZE+1,1);\n\t\tif (!tmp_pass || !mountpassword) {\n\t\t\tfprintf(stderr, \"Password not entered, exiting\\n\");\n\t\t\texit(EX_USAGE);\n\t\t}\n\t\tstrlcpy(mountpassword, tmp_pass, MOUNT_PASSWD_SIZE+1);\n\t\tgot_password = 1;\n\t}\n\t/* FIXME launch daemon (handles dfs name resolution and credential change) \n\t   remember to clear parms and overwrite password field before launching */\n\tif(orgoptions) {\n\t\toptlen = strlen(orgoptions);\n\t\torgoptlen = optlen;\n\t} else\n\t\toptlen = 0;\n\tif(share_name)\n\t\toptlen += strlen(share_name) + 4;\n\telse {\n\t\tfprintf(stderr, \"No server share name specified\\n\");\n\t\tfprintf(stderr, \"\\nMounting the DFS root for server not implemented yet\\n\");\n                exit(EX_USAGE);\n\t}\n\tif(user_name)\n\t\toptlen += strlen(user_name) + 6;\n\toptlen += MAX_ADDRESS_LEN + 4;\n\tif(mountpassword)\n\t\toptlen += strlen(mountpassword) + 6;\nmount_retry:\n\tSAFE_FREE(options);\n\toptions_size = optlen + 10 + DOMAIN_SIZE;\n\toptions = (char *)malloc(options_size /* space for commas in password */ + 8 /* space for domain=  , domain name itself was counted as part of the length username string above */);\n\n\tif(options == NULL) {\n\t\tfprintf(stderr, \"Could not allocate memory for mount options\\n\");\n\t\texit(EX_SYSERR);\n\t}\n\n\tstrlcpy(options, \"unc=\", options_size);\n\tstrlcat(options,share_name,options_size);\n\t/* scan backwards and reverse direction of slash */\n\ttemp = strrchr(options, '/');\n\tif(temp > options + 6)\n\t\t*temp = '\\\\';\n\tif(user_name) {\n\t\t/* check for syntax like user=domain\\user */\n\t\tif(got_domain == 0)\n\t\t\tdomain_name = check_for_domain(&user_name);\n\t\tstrlcat(options,\",user=\",options_size);\n\t\tstrlcat(options,user_name,options_size);\n\t}\n\tif(retry == 0) {\n\t\tif(domain_name) {\n\t\t\t/* extra length accounted for in option string above */\n\t\t\tstrlcat(options,\",domain=\",options_size);\n\t\t\tstrlcat(options,domain_name,options_size);\n\t\t}\n\t}\n\n\tstrlcat(options,\",ver=\",options_size);\n\tstrlcat(options,MOUNT_CIFS_VERSION_MAJOR,options_size);\n\n\tif(orgoptions) {\n\t\tstrlcat(options,\",\",options_size);\n\t\tstrlcat(options,orgoptions,options_size);\n\t}\n\tif(prefixpath) {\n\t\tstrlcat(options,\",prefixpath=\",options_size);\n\t\tstrlcat(options,prefixpath,options_size); /* no need to cat the / */\n\t}\n\n\t/* convert all '\\\\' to '/' in share portion so that /proc/mounts looks pretty */\n\treplace_char(dev_name, '\\\\', '/', strlen(share_name));\n\n\tif (!got_ip && addr) {\n\t\tstrlcat(options, \",ip=\", options_size);\n\t\tcurrent_len = strnlen(options, options_size);\n\t\toptionstail = options + current_len;\n\t\tswitch (addr->ai_addr->sa_family) {\n\t\tcase AF_INET6:\n\t\t\taddr6 = (struct sockaddr_in6 *) addr->ai_addr;\n\t\t\tipaddr = inet_ntop(AF_INET6, &addr6->sin6_addr, optionstail,\n\t\t\t\t\t   options_size - current_len);\n\t\t\tbreak;\n\t\tcase AF_INET:\n\t\t\taddr4 = (struct sockaddr_in *) addr->ai_addr;\n\t\t\tipaddr = inet_ntop(AF_INET, &addr4->sin_addr, optionstail,\n\t\t\t\t\t   options_size - current_len);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tipaddr = NULL;\n\t\t}\n\n\t\t/* if the address looks bogus, try the next one */\n\t\tif (!ipaddr) {\n\t\t\taddr = addr->ai_next;\n\t\t\tif (addr)\n\t\t\t\tgoto mount_retry;\n\t\t\trc = EX_SYSERR;\n\t\t\tgoto mount_exit;\n\t\t}\n\t}\n\n\tif (addr->ai_addr->sa_family == AF_INET6 && addr6->sin6_scope_id) {\n\t\tstrlcat(options, \"%\", options_size);\n\t\tcurrent_len = strnlen(options, options_size);\n\t\toptionstail = options + current_len;\n\t\tsnprintf(optionstail, options_size - current_len, \"%u\",\n\t\t\t addr6->sin6_scope_id);\n\t}\n\n\tif(verboseflag)\n\t\tfprintf(stderr, \"\\nmount.cifs kernel mount options: %s\", options);\n\n\tif (mountpassword) {\n\t\t/*\n\t\t * Commas have to be doubled, or else they will\n\t\t * look like the parameter separator\n\t\t */\n\t\tif(retry == 0)\n\t\t\tcheck_for_comma(&mountpassword);\n\t\tstrlcat(options,\",pass=\",options_size);\n\t\tstrlcat(options,mountpassword,options_size);\n\t\tif (verboseflag)\n\t\t\tfprintf(stderr, \",pass=********\");\n\t}\n\n\tif (verboseflag)\n\t\tfprintf(stderr, \"\\n\");\n\n\tif (!fakemnt && mount(dev_name, mountpoint, cifs_fstype, flags, options)) {\n\t\tswitch (errno) {\n\t\tcase ECONNREFUSED:\n\t\tcase EHOSTUNREACH:\n\t\t\tif (addr) {\n\t\t\t\taddr = addr->ai_next;\n\t\t\t\tif (addr)\n\t\t\t\t\tgoto mount_retry;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ENODEV:\n\t\t\tfprintf(stderr, \"mount error: cifs filesystem not supported by the system\\n\");\n\t\t\tbreak;\n\t\tcase ENXIO:\n\t\t\tif(retry == 0) {\n\t\t\t\tretry = 1;\n\t\t\t\tif (uppercase_string(dev_name) &&\n\t\t\t\t    uppercase_string(share_name) &&\n\t\t\t\t    uppercase_string(prefixpath)) {\n\t\t\t\t\tfprintf(stderr, \"retrying with upper case share name\\n\");\n\t\t\t\t\tgoto mount_retry;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfprintf(stderr, \"mount error(%d): %s\\n\", errno, strerror(errno));\n\t\tfprintf(stderr, \"Refer to the mount.cifs(8) manual page (e.g. man \"\n\t\t       \"mount.cifs)\\n\");\n\t\trc = EX_FAIL;\n\t\tgoto mount_exit;\n\t}\n\n\tif (nomtab)\n\t\tgoto mount_exit;\n\tatexit(unlock_mtab);\n\trc = lock_mtab();\n\tif (rc) {\n\t\tfprintf(stderr, \"cannot lock mtab\");\n\t\tgoto mount_exit;\n\t}\n\tpmntfile = setmntent(MOUNTED, \"a+\");\n\tif (!pmntfile) {\n\t\tfprintf(stderr, \"could not update mount table\\n\");\n\t\tunlock_mtab();\n\t\trc = EX_FILEIO;\n\t\tgoto mount_exit;\n\t}\n\tmountent.mnt_fsname = dev_name;\n\tmountent.mnt_dir = mountpoint;\n\tmountent.mnt_type = (char *)(void *)cifs_fstype;\n\tmountent.mnt_opts = (char *)malloc(220);\n\tif(mountent.mnt_opts) {\n\t\tchar * mount_user = getusername();\n\t\tmemset(mountent.mnt_opts,0,200);\n\t\tif(flags & MS_RDONLY)\n\t\t\tstrlcat(mountent.mnt_opts,\"ro\",220);\n\t\telse\n\t\t\tstrlcat(mountent.mnt_opts,\"rw\",220);\n\t\tif(flags & MS_MANDLOCK)\n\t\t\tstrlcat(mountent.mnt_opts,\",mand\",220);\n\t\tif(flags & MS_NOEXEC)\n\t\t\tstrlcat(mountent.mnt_opts,\",noexec\",220);\n\t\tif(flags & MS_NOSUID)\n\t\t\tstrlcat(mountent.mnt_opts,\",nosuid\",220);\n\t\tif(flags & MS_NODEV)\n\t\t\tstrlcat(mountent.mnt_opts,\",nodev\",220);\n\t\tif(flags & MS_SYNCHRONOUS)\n\t\t\tstrlcat(mountent.mnt_opts,\",sync\",220);\n\t\tif(mount_user) {\n\t\t\tif(getuid() != 0) {\n\t\t\t\tstrlcat(mountent.mnt_opts,\n\t\t\t\t\t\",user=\", 220);\n\t\t\t\tstrlcat(mountent.mnt_opts,\n\t\t\t\t\tmount_user, 220);\n\t\t\t}\n\t\t}\n\t}\n\tmountent.mnt_freq = 0;\n\tmountent.mnt_passno = 0;\n\trc = addmntent(pmntfile,&mountent);\n\tendmntent(pmntfile);\n\tunlock_mtab();\n\tSAFE_FREE(mountent.mnt_opts);\n\tif (rc)\n\t\trc = EX_FILEIO;\nmount_exit:\n\tif(mountpassword) {\n\t\tint len = strlen(mountpassword);\n\t\tmemset(mountpassword,0,len);\n\t\tSAFE_FREE(mountpassword);\n\t}\n\n\tif (addrhead)\n\t\tfreeaddrinfo(addrhead);\n\tSAFE_FREE(options);\n\tSAFE_FREE(orgoptions);\n\tSAFE_FREE(resolved_path);\n\tSAFE_FREE(share_name);\n\texit(rc);\n}",
        "target": 1
    },
    {
        "func": "int main(int argc, char ** argv)\n{\n\tint c;\n\tunsigned long flags = MS_MANDLOCK;\n\tchar * orgoptions = NULL;\n\tchar * share_name = NULL;\n\tconst char * ipaddr = NULL;\n\tchar * uuid = NULL;\n\tchar * mountpoint = NULL;\n\tchar * options = NULL;\n\tchar * optionstail;\n\tchar * resolved_path = NULL;\n\tchar * temp;\n\tchar * dev_name;\n\tint rc = 0;\n\tint rsize = 0;\n\tint wsize = 0;\n\tint nomtab = 0;\n\tint uid = 0;\n\tint gid = 0;\n\tint optlen = 0;\n\tint orgoptlen = 0;\n\tsize_t options_size = 0;\n\tsize_t current_len;\n\tint retry = 0; /* set when we have to retry mount with uppercase */\n\tstruct addrinfo *addrhead = NULL, *addr;\n\tstruct utsname sysinfo;\n\tstruct mntent mountent;\n\tstruct sockaddr_in *addr4;\n\tstruct sockaddr_in6 *addr6;\n\tFILE * pmntfile;\n\n\t/* setlocale(LC_ALL, \"\");\n\tbindtextdomain(PACKAGE, LOCALEDIR);\n\ttextdomain(PACKAGE); */\n\n\tif(argc && argv)\n\t\tthisprogram = argv[0];\n\telse\n\t\tmount_cifs_usage(stderr);\n\n\tif(thisprogram == NULL)\n\t\tthisprogram = \"mount.cifs\";\n\n\tuname(&sysinfo);\n\t/* BB add workstation name and domain and pass down */\n\n/* #ifdef _GNU_SOURCE\n\tfprintf(stderr, \" node: %s machine: %s sysname %s domain %s\\n\", sysinfo.nodename,sysinfo.machine,sysinfo.sysname,sysinfo.domainname);\n#endif */\n\tif(argc > 2) {\n\t\tdev_name = argv[1];\n\t\tshare_name = strndup(argv[1], MAX_UNC_LEN);\n\t\tif (share_name == NULL) {\n\t\t\tfprintf(stderr, \"%s: %s\", argv[0], strerror(ENOMEM));\n\t\t\texit(EX_SYSERR);\n\t\t}\n\t\tmountpoint = argv[2];\n\t} else if (argc == 2) {\n\t\tif ((strcmp(argv[1], \"-V\") == 0) ||\n\t\t    (strcmp(argv[1], \"--version\") == 0))\n\t\t{\n\t\t\tprint_cifs_mount_version();\n\t\t\texit(0);\n\t\t}\n\n\t\tif ((strcmp(argv[1], \"-h\") == 0) ||\n\t\t    (strcmp(argv[1], \"-?\") == 0) ||\n\t\t    (strcmp(argv[1], \"--help\") == 0))\n\t\t\tmount_cifs_usage(stdout);\n\n\t\tmount_cifs_usage(stderr);\n\t} else {\n\t\tmount_cifs_usage(stderr);\n\t}\n\n\n\t/* add sharename in opts string as unc= parm */\n\twhile ((c = getopt_long (argc, argv, \"afFhilL:no:O:rsSU:vVwt:\",\n\t\t\t longopts, NULL)) != -1) {\n\t\tswitch (c) {\n/* No code to do the following  options yet */\n/*\tcase 'l':\n\t\tlist_with_volumelabel = 1;\n\t\tbreak;\n\tcase 'L':\n\t\tvolumelabel = optarg;\n\t\tbreak; */\n/*\tcase 'a':\t       \n\t\t++mount_all;\n\t\tbreak; */\n\n\t\tcase '?':\n\t\tcase 'h':\t /* help */\n\t\t\tmount_cifs_usage(stdout);\n\t\tcase 'n':\n\t\t\t++nomtab;\n\t\t\tbreak;\n\t\tcase 'b':\n#ifdef MS_BIND\n\t\t\tflags |= MS_BIND;\n#else\n\t\t\tfprintf(stderr,\n\t\t\t\t\"option 'b' (MS_BIND) not supported\\n\");\n#endif\n\t\t\tbreak;\n\t\tcase 'm':\n#ifdef MS_MOVE\t\t      \n\t\t\tflags |= MS_MOVE;\n#else\n\t\t\tfprintf(stderr,\n\t\t\t\t\"option 'm' (MS_MOVE) not supported\\n\");\n#endif\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\torgoptions = strdup(optarg);\n\t\t    break;\n\t\tcase 'r':  /* mount readonly */\n\t\t\tflags |= MS_RDONLY;\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\tuuid = optarg;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\t++verboseflag;\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\tprint_cifs_mount_version();\n\t\t\texit (0);\n\t\tcase 'w':\n\t\t\tflags &= ~MS_RDONLY;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\trsize = atoi(optarg) ;\n\t\t\tbreak;\n\t\tcase 'W':\n\t\t\twsize = atoi(optarg);\n\t\t\tbreak;\n\t\tcase '1':\n\t\t\tif (isdigit(*optarg)) {\n\t\t\t\tchar *ep;\n\n\t\t\t\tuid = strtoul(optarg, &ep, 10);\n\t\t\t\tif (*ep) {\n\t\t\t\t\tfprintf(stderr, \"bad uid value \\\"%s\\\"\\n\", optarg);\n\t\t\t\t\texit(EX_USAGE);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstruct passwd *pw;\n\n\t\t\t\tif (!(pw = getpwnam(optarg))) {\n\t\t\t\t\tfprintf(stderr, \"bad user name \\\"%s\\\"\\n\", optarg);\n\t\t\t\t\texit(EX_USAGE);\n\t\t\t\t}\n\t\t\t\tuid = pw->pw_uid;\n\t\t\t\tendpwent();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '2':\n\t\t\tif (isdigit(*optarg)) {\n\t\t\t\tchar *ep;\n\n\t\t\t\tgid = strtoul(optarg, &ep, 10);\n\t\t\t\tif (*ep) {\n\t\t\t\t\tfprintf(stderr, \"bad gid value \\\"%s\\\"\\n\", optarg);\n\t\t\t\t\texit(EX_USAGE);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstruct group *gr;\n\n\t\t\t\tif (!(gr = getgrnam(optarg))) {\n\t\t\t\t\tfprintf(stderr, \"bad user name \\\"%s\\\"\\n\", optarg);\n\t\t\t\t\texit(EX_USAGE);\n\t\t\t\t}\n\t\t\t\tgid = gr->gr_gid;\n\t\t\t\tendpwent();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tgot_user = 1;\n\t\t\tuser_name = optarg;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tdomain_name = optarg; /* BB fix this - currently ignored */\n\t\t\tgot_domain = 1;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tif(mountpassword == NULL)\n\t\t\t\tmountpassword = (char *)calloc(MOUNT_PASSWD_SIZE+1,1);\n\t\t\tif(mountpassword) {\n\t\t\t\tgot_password = 1;\n\t\t\t\tstrlcpy(mountpassword,optarg,MOUNT_PASSWD_SIZE+1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tget_password_from_file(0 /* stdin */,NULL);\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\t++fakemnt;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(stderr, \"unknown mount option %c\\n\",c);\n\t\t\tmount_cifs_usage(stderr);\n\t\t}\n\t}\n\n\tif((argc < 3) || (dev_name == NULL) || (mountpoint == NULL)) {\n\t\tmount_cifs_usage(stderr);\n\t}\n\n\t/* make sure mountpoint is legit */\n\trc = chdir(mountpoint);\n\tif (rc) {\n\t\tfprintf(stderr, \"Couldn't chdir to %s: %s\\n\", mountpoint,\n\t\t\t\tstrerror(errno));\n\t\trc = EX_USAGE;\n\t\tgoto mount_exit;\n\t}\n\n\trc = check_mountpoint(thisprogram, mountpoint);\n\tif (rc)\n\t\tgoto mount_exit;\n\n\t/* sanity check for unprivileged mounts */\n\tif (getuid()) {\n\t\trc = check_fstab(thisprogram, mountpoint, dev_name,\n\t\t\t\t &orgoptions);\n\t\tif (rc)\n\t\t\tgoto mount_exit;\n\n\t\t/* enable any default user mount flags */\n\t\tflags |= CIFS_SETUID_FLAGS;\n\t}\n\n\tif (getenv(\"PASSWD\")) {\n\t\tif(mountpassword == NULL)\n\t\t\tmountpassword = (char *)calloc(MOUNT_PASSWD_SIZE+1,1);\n\t\tif(mountpassword) {\n\t\t\tstrlcpy(mountpassword,getenv(\"PASSWD\"),MOUNT_PASSWD_SIZE+1);\n\t\t\tgot_password = 1;\n\t\t}\n\t} else if (getenv(\"PASSWD_FD\")) {\n\t\tget_password_from_file(atoi(getenv(\"PASSWD_FD\")),NULL);\n\t} else if (getenv(\"PASSWD_FILE\")) {\n\t\tget_password_from_file(0, getenv(\"PASSWD_FILE\"));\n\t}\n\n        if (orgoptions && parse_options(&orgoptions, &flags)) {\n                rc = EX_USAGE;\n\t\tgoto mount_exit;\n\t}\n\n\tif (getuid()) {\n#if !CIFS_LEGACY_SETUID_CHECK\n\t\tif (!(flags & (MS_USERS|MS_USER))) {\n\t\t\tfprintf(stderr, \"%s: permission denied\\n\", thisprogram);\n\t\t\trc = EX_USAGE;\n\t\t\tgoto mount_exit;\n\t\t}\n#endif /* !CIFS_LEGACY_SETUID_CHECK */\n\t\t\n\t\tif (geteuid()) {\n\t\t\tfprintf(stderr, \"%s: not installed setuid - \\\"user\\\" \"\n\t\t\t\t\t\"CIFS mounts not supported.\",\n\t\t\t\t\tthisprogram);\n\t\t\trc = EX_FAIL;\n\t\t\tgoto mount_exit;\n\t\t}\n\t}\n\n\tflags &= ~(MS_USERS|MS_USER);\n\n\taddrhead = addr = parse_server(&share_name);\n\tif((addrhead == NULL) && (got_ip == 0)) {\n\t\tfprintf(stderr, \"No ip address specified and hostname not found\\n\");\n\t\trc = EX_USAGE;\n\t\tgoto mount_exit;\n\t}\n\t\n\t/* BB save off path and pop after mount returns? */\n\tresolved_path = (char *)malloc(PATH_MAX+1);\n\tif (!resolved_path) {\n\t\tfprintf(stderr, \"Unable to allocate memory.\\n\");\n\t\trc = EX_SYSERR;\n\t\tgoto mount_exit;\n\t}\n\n\t/* Note that if we can not canonicalize the name, we get\n\t   another chance to see if it is valid when we chdir to it */\n\tif(!realpath(\".\", resolved_path)) {\n\t\tfprintf(stderr, \"Unable to resolve %s to canonical path: %s\\n\",\n\t\t\t\tmountpoint, strerror(errno));\n\t\trc = EX_SYSERR;\n\t\tgoto mount_exit;\n\t}\n\n\tmountpoint = resolved_path; \n\n\tif(got_user == 0) {\n\t\t/* Note that the password will not be retrieved from the\n\t\t   USER env variable (ie user%password form) as there is\n\t\t   already a PASSWD environment varaible */\n\t\tif (getenv(\"USER\"))\n\t\t\tuser_name = strdup(getenv(\"USER\"));\n\t\tif (user_name == NULL)\n\t\t\tuser_name = getusername();\n\t\tgot_user = 1;\n\t}\n       \n\tif(got_password == 0) {\n\t\tchar *tmp_pass = getpass(\"Password: \"); /* BB obsolete sys call but\n\t\t\t\t\t\t\t   no good replacement yet. */\n\t\tmountpassword = (char *)calloc(MOUNT_PASSWD_SIZE+1,1);\n\t\tif (!tmp_pass || !mountpassword) {\n\t\t\tfprintf(stderr, \"Password not entered, exiting\\n\");\n\t\t\texit(EX_USAGE);\n\t\t}\n\t\tstrlcpy(mountpassword, tmp_pass, MOUNT_PASSWD_SIZE+1);\n\t\tgot_password = 1;\n\t}\n\t/* FIXME launch daemon (handles dfs name resolution and credential change) \n\t   remember to clear parms and overwrite password field before launching */\n\tif(orgoptions) {\n\t\toptlen = strlen(orgoptions);\n\t\torgoptlen = optlen;\n\t} else\n\t\toptlen = 0;\n\tif(share_name)\n\t\toptlen += strlen(share_name) + 4;\n\telse {\n\t\tfprintf(stderr, \"No server share name specified\\n\");\n\t\tfprintf(stderr, \"\\nMounting the DFS root for server not implemented yet\\n\");\n                exit(EX_USAGE);\n\t}\n\tif(user_name)\n\t\toptlen += strlen(user_name) + 6;\n\toptlen += MAX_ADDRESS_LEN + 4;\n\tif(mountpassword)\n\t\toptlen += strlen(mountpassword) + 6;\nmount_retry:\n\tSAFE_FREE(options);\n\toptions_size = optlen + 10 + DOMAIN_SIZE;\n\toptions = (char *)malloc(options_size /* space for commas in password */ + 8 /* space for domain=  , domain name itself was counted as part of the length username string above */);\n\n\tif(options == NULL) {\n\t\tfprintf(stderr, \"Could not allocate memory for mount options\\n\");\n\t\texit(EX_SYSERR);\n\t}\n\n\tstrlcpy(options, \"unc=\", options_size);\n\tstrlcat(options,share_name,options_size);\n\t/* scan backwards and reverse direction of slash */\n\ttemp = strrchr(options, '/');\n\tif(temp > options + 6)\n\t\t*temp = '\\\\';\n\tif(user_name) {\n\t\t/* check for syntax like user=domain\\user */\n\t\tif(got_domain == 0)\n\t\t\tdomain_name = check_for_domain(&user_name);\n\t\tstrlcat(options,\",user=\",options_size);\n\t\tstrlcat(options,user_name,options_size);\n\t}\n\tif(retry == 0) {\n\t\tif(domain_name) {\n\t\t\t/* extra length accounted for in option string above */\n\t\t\tstrlcat(options,\",domain=\",options_size);\n\t\t\tstrlcat(options,domain_name,options_size);\n\t\t}\n\t}\n\n\tstrlcat(options,\",ver=\",options_size);\n\tstrlcat(options,MOUNT_CIFS_VERSION_MAJOR,options_size);\n\n\tif(orgoptions) {\n\t\tstrlcat(options,\",\",options_size);\n\t\tstrlcat(options,orgoptions,options_size);\n\t}\n\tif(prefixpath) {\n\t\tstrlcat(options,\",prefixpath=\",options_size);\n\t\tstrlcat(options,prefixpath,options_size); /* no need to cat the / */\n\t}\n\n\t/* convert all '\\\\' to '/' in share portion so that /proc/mounts looks pretty */\n\treplace_char(dev_name, '\\\\', '/', strlen(share_name));\n\n\tif (!got_ip && addr) {\n\t\tstrlcat(options, \",ip=\", options_size);\n\t\tcurrent_len = strnlen(options, options_size);\n\t\toptionstail = options + current_len;\n\t\tswitch (addr->ai_addr->sa_family) {\n\t\tcase AF_INET6:\n\t\t\taddr6 = (struct sockaddr_in6 *) addr->ai_addr;\n\t\t\tipaddr = inet_ntop(AF_INET6, &addr6->sin6_addr, optionstail,\n\t\t\t\t\t   options_size - current_len);\n\t\t\tbreak;\n\t\tcase AF_INET:\n\t\t\taddr4 = (struct sockaddr_in *) addr->ai_addr;\n\t\t\tipaddr = inet_ntop(AF_INET, &addr4->sin_addr, optionstail,\n\t\t\t\t\t   options_size - current_len);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tipaddr = NULL;\n\t\t}\n\n\t\t/* if the address looks bogus, try the next one */\n\t\tif (!ipaddr) {\n\t\t\taddr = addr->ai_next;\n\t\t\tif (addr)\n\t\t\t\tgoto mount_retry;\n\t\t\trc = EX_SYSERR;\n\t\t\tgoto mount_exit;\n\t\t}\n\t}\n\n\tif (addr->ai_addr->sa_family == AF_INET6 && addr6->sin6_scope_id) {\n\t\tstrlcat(options, \"%\", options_size);\n\t\tcurrent_len = strnlen(options, options_size);\n\t\toptionstail = options + current_len;\n\t\tsnprintf(optionstail, options_size - current_len, \"%u\",\n\t\t\t addr6->sin6_scope_id);\n\t}\n\n\tif(verboseflag)\n\t\tfprintf(stderr, \"\\nmount.cifs kernel mount options: %s\", options);\n\n\tif (mountpassword) {\n\t\t/*\n\t\t * Commas have to be doubled, or else they will\n\t\t * look like the parameter separator\n\t\t */\n\t\tif(retry == 0)\n\t\t\tcheck_for_comma(&mountpassword);\n\t\tstrlcat(options,\",pass=\",options_size);\n\t\tstrlcat(options,mountpassword,options_size);\n\t\tif (verboseflag)\n\t\t\tfprintf(stderr, \",pass=********\");\n\t}\n\n\tif (verboseflag)\n\t\tfprintf(stderr, \"\\n\");\n\n\tif (!fakemnt && mount(dev_name, \".\", cifs_fstype, flags, options)) {\n\t\tswitch (errno) {\n\t\tcase ECONNREFUSED:\n\t\tcase EHOSTUNREACH:\n\t\t\tif (addr) {\n\t\t\t\taddr = addr->ai_next;\n\t\t\t\tif (addr)\n\t\t\t\t\tgoto mount_retry;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ENODEV:\n\t\t\tfprintf(stderr, \"mount error: cifs filesystem not supported by the system\\n\");\n\t\t\tbreak;\n\t\tcase ENXIO:\n\t\t\tif(retry == 0) {\n\t\t\t\tretry = 1;\n\t\t\t\tif (uppercase_string(dev_name) &&\n\t\t\t\t    uppercase_string(share_name) &&\n\t\t\t\t    uppercase_string(prefixpath)) {\n\t\t\t\t\tfprintf(stderr, \"retrying with upper case share name\\n\");\n\t\t\t\t\tgoto mount_retry;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfprintf(stderr, \"mount error(%d): %s\\n\", errno, strerror(errno));\n\t\tfprintf(stderr, \"Refer to the mount.cifs(8) manual page (e.g. man \"\n\t\t       \"mount.cifs)\\n\");\n\t\trc = EX_FAIL;\n\t\tgoto mount_exit;\n\t}\n\n\tif (nomtab)\n\t\tgoto mount_exit;\n\tatexit(unlock_mtab);\n\trc = lock_mtab();\n\tif (rc) {\n\t\tfprintf(stderr, \"cannot lock mtab\");\n\t\tgoto mount_exit;\n\t}\n\tpmntfile = setmntent(MOUNTED, \"a+\");\n\tif (!pmntfile) {\n\t\tfprintf(stderr, \"could not update mount table\\n\");\n\t\tunlock_mtab();\n\t\trc = EX_FILEIO;\n\t\tgoto mount_exit;\n\t}\n\tmountent.mnt_fsname = dev_name;\n\tmountent.mnt_dir = mountpoint;\n\tmountent.mnt_type = (char *)(void *)cifs_fstype;\n\tmountent.mnt_opts = (char *)malloc(220);\n\tif(mountent.mnt_opts) {\n\t\tchar * mount_user = getusername();\n\t\tmemset(mountent.mnt_opts,0,200);\n\t\tif(flags & MS_RDONLY)\n\t\t\tstrlcat(mountent.mnt_opts,\"ro\",220);\n\t\telse\n\t\t\tstrlcat(mountent.mnt_opts,\"rw\",220);\n\t\tif(flags & MS_MANDLOCK)\n\t\t\tstrlcat(mountent.mnt_opts,\",mand\",220);\n\t\tif(flags & MS_NOEXEC)\n\t\t\tstrlcat(mountent.mnt_opts,\",noexec\",220);\n\t\tif(flags & MS_NOSUID)\n\t\t\tstrlcat(mountent.mnt_opts,\",nosuid\",220);\n\t\tif(flags & MS_NODEV)\n\t\t\tstrlcat(mountent.mnt_opts,\",nodev\",220);\n\t\tif(flags & MS_SYNCHRONOUS)\n\t\t\tstrlcat(mountent.mnt_opts,\",sync\",220);\n\t\tif(mount_user) {\n\t\t\tif(getuid() != 0) {\n\t\t\t\tstrlcat(mountent.mnt_opts,\n\t\t\t\t\t\",user=\", 220);\n\t\t\t\tstrlcat(mountent.mnt_opts,\n\t\t\t\t\tmount_user, 220);\n\t\t\t}\n\t\t}\n\t}\n\tmountent.mnt_freq = 0;\n\tmountent.mnt_passno = 0;\n\trc = addmntent(pmntfile,&mountent);\n\tendmntent(pmntfile);\n\tunlock_mtab();\n\tSAFE_FREE(mountent.mnt_opts);\n\tif (rc)\n\t\trc = EX_FILEIO;\nmount_exit:\n\tif(mountpassword) {\n\t\tint len = strlen(mountpassword);\n\t\tmemset(mountpassword,0,len);\n\t\tSAFE_FREE(mountpassword);\n\t}\n\n\tif (addrhead)\n\t\tfreeaddrinfo(addrhead);\n\tSAFE_FREE(options);\n\tSAFE_FREE(orgoptions);\n\tSAFE_FREE(resolved_path);\n\tSAFE_FREE(share_name);\n\texit(rc);\n}",
        "target": 1
    },
    {
        "func": "int main(int argc, char ** argv)\n{\n\tint c;\n\tunsigned long flags = MS_MANDLOCK;\n\tchar * orgoptions = NULL;\n\tchar * share_name = NULL;\n\tconst char * ipaddr = NULL;\n\tchar * uuid = NULL;\n\tchar * mountpoint = NULL;\n\tchar * options = NULL;\n\tchar * optionstail;\n\tchar * resolved_path = NULL;\n\tchar * temp;\n\tchar * dev_name;\n\tint rc = 0;\n\tint rsize = 0;\n\tint wsize = 0;\n\tint nomtab = 0;\n\tint uid = 0;\n\tint gid = 0;\n\tint optlen = 0;\n\tint orgoptlen = 0;\n\tsize_t options_size = 0;\n\tsize_t current_len;\n\tint retry = 0; /* set when we have to retry mount with uppercase */\n\tstruct addrinfo *addrhead = NULL, *addr;\n\tstruct utsname sysinfo;\n\tstruct mntent mountent;\n\tstruct sockaddr_in *addr4;\n\tstruct sockaddr_in6 *addr6;\n\tFILE * pmntfile;\n\n\t/* setlocale(LC_ALL, \"\");\n\tbindtextdomain(PACKAGE, LOCALEDIR);\n\ttextdomain(PACKAGE); */\n\n\tif(argc && argv)\n\t\tthisprogram = argv[0];\n\telse\n\t\tmount_cifs_usage(stderr);\n\n\tif(thisprogram == NULL)\n\t\tthisprogram = \"mount.cifs\";\n\n\tuname(&sysinfo);\n\t/* BB add workstation name and domain and pass down */\n\n/* #ifdef _GNU_SOURCE\n\tfprintf(stderr, \" node: %s machine: %s sysname %s domain %s\\n\", sysinfo.nodename,sysinfo.machine,sysinfo.sysname,sysinfo.domainname);\n#endif */\n\tif(argc > 2) {\n\t\tdev_name = argv[1];\n\t\tshare_name = strndup(argv[1], MAX_UNC_LEN);\n\t\tif (share_name == NULL) {\n\t\t\tfprintf(stderr, \"%s: %s\", argv[0], strerror(ENOMEM));\n\t\t\texit(EX_SYSERR);\n\t\t}\n\t\tmountpoint = argv[2];\n\t} else if (argc == 2) {\n\t\tif ((strcmp(argv[1], \"-V\") == 0) ||\n\t\t    (strcmp(argv[1], \"--version\") == 0))\n\t\t{\n\t\t\tprint_cifs_mount_version();\n\t\t\texit(0);\n\t\t}\n\n\t\tif ((strcmp(argv[1], \"-h\") == 0) ||\n\t\t    (strcmp(argv[1], \"-?\") == 0) ||\n\t\t    (strcmp(argv[1], \"--help\") == 0))\n\t\t\tmount_cifs_usage(stdout);\n\n\t\tmount_cifs_usage(stderr);\n\t} else {\n\t\tmount_cifs_usage(stderr);\n\t}\n\n\n\t/* add sharename in opts string as unc= parm */\n\twhile ((c = getopt_long (argc, argv, \"afFhilL:no:O:rsSU:vVwt:\",\n\t\t\t longopts, NULL)) != -1) {\n\t\tswitch (c) {\n/* No code to do the following  options yet */\n/*\tcase 'l':\n\t\tlist_with_volumelabel = 1;\n\t\tbreak;\n\tcase 'L':\n\t\tvolumelabel = optarg;\n\t\tbreak; */\n/*\tcase 'a':\t       \n\t\t++mount_all;\n\t\tbreak; */\n\n\t\tcase '?':\n\t\tcase 'h':\t /* help */\n\t\t\tmount_cifs_usage(stdout);\n\t\tcase 'n':\n\t\t\t++nomtab;\n\t\t\tbreak;\n\t\tcase 'b':\n#ifdef MS_BIND\n\t\t\tflags |= MS_BIND;\n#else\n\t\t\tfprintf(stderr,\n\t\t\t\t\"option 'b' (MS_BIND) not supported\\n\");\n#endif\n\t\t\tbreak;\n\t\tcase 'm':\n#ifdef MS_MOVE\t\t      \n\t\t\tflags |= MS_MOVE;\n#else\n\t\t\tfprintf(stderr,\n\t\t\t\t\"option 'm' (MS_MOVE) not supported\\n\");\n#endif\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\torgoptions = strdup(optarg);\n\t\t    break;\n\t\tcase 'r':  /* mount readonly */\n\t\t\tflags |= MS_RDONLY;\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\tuuid = optarg;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\t++verboseflag;\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\tprint_cifs_mount_version();\n\t\t\texit (0);\n\t\tcase 'w':\n\t\t\tflags &= ~MS_RDONLY;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\trsize = atoi(optarg) ;\n\t\t\tbreak;\n\t\tcase 'W':\n\t\t\twsize = atoi(optarg);\n\t\t\tbreak;\n\t\tcase '1':\n\t\t\tif (isdigit(*optarg)) {\n\t\t\t\tchar *ep;\n\n\t\t\t\tuid = strtoul(optarg, &ep, 10);\n\t\t\t\tif (*ep) {\n\t\t\t\t\tfprintf(stderr, \"bad uid value \\\"%s\\\"\\n\", optarg);\n\t\t\t\t\texit(EX_USAGE);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstruct passwd *pw;\n\n\t\t\t\tif (!(pw = getpwnam(optarg))) {\n\t\t\t\t\tfprintf(stderr, \"bad user name \\\"%s\\\"\\n\", optarg);\n\t\t\t\t\texit(EX_USAGE);\n\t\t\t\t}\n\t\t\t\tuid = pw->pw_uid;\n\t\t\t\tendpwent();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '2':\n\t\t\tif (isdigit(*optarg)) {\n\t\t\t\tchar *ep;\n\n\t\t\t\tgid = strtoul(optarg, &ep, 10);\n\t\t\t\tif (*ep) {\n\t\t\t\t\tfprintf(stderr, \"bad gid value \\\"%s\\\"\\n\", optarg);\n\t\t\t\t\texit(EX_USAGE);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstruct group *gr;\n\n\t\t\t\tif (!(gr = getgrnam(optarg))) {\n\t\t\t\t\tfprintf(stderr, \"bad user name \\\"%s\\\"\\n\", optarg);\n\t\t\t\t\texit(EX_USAGE);\n\t\t\t\t}\n\t\t\t\tgid = gr->gr_gid;\n\t\t\t\tendpwent();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tgot_user = 1;\n\t\t\tuser_name = optarg;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tdomain_name = optarg; /* BB fix this - currently ignored */\n\t\t\tgot_domain = 1;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tif(mountpassword == NULL)\n\t\t\t\tmountpassword = (char *)calloc(MOUNT_PASSWD_SIZE+1,1);\n\t\t\tif(mountpassword) {\n\t\t\t\tgot_password = 1;\n\t\t\t\tstrlcpy(mountpassword,optarg,MOUNT_PASSWD_SIZE+1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tget_password_from_file(0 /* stdin */,NULL);\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\t++fakemnt;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(stderr, \"unknown mount option %c\\n\",c);\n\t\t\tmount_cifs_usage(stderr);\n\t\t}\n\t}\n\n\tif((argc < 3) || (dev_name == NULL) || (mountpoint == NULL)) {\n\t\tmount_cifs_usage(stderr);\n\t}\n\n\t/* make sure mountpoint is legit */\n\trc = chdir(mountpoint);\n\tif (rc) {\n\t\tfprintf(stderr, \"Couldn't chdir to %s: %s\\n\", mountpoint,\n\t\t\t\tstrerror(errno));\n\t\trc = EX_USAGE;\n\t\tgoto mount_exit;\n\t}\n\n\trc = check_mountpoint(thisprogram, mountpoint);\n\tif (rc)\n\t\tgoto mount_exit;\n\n\t/* sanity check for unprivileged mounts */\n\tif (getuid()) {\n\t\trc = check_fstab(thisprogram, mountpoint, dev_name,\n\t\t\t\t &orgoptions);\n\t\tif (rc)\n\t\t\tgoto mount_exit;\n\n\t\t/* enable any default user mount flags */\n\t\tflags |= CIFS_SETUID_FLAGS;\n\t}\n\n\tif (getenv(\"PASSWD\")) {\n\t\tif(mountpassword == NULL)\n\t\t\tmountpassword = (char *)calloc(MOUNT_PASSWD_SIZE+1,1);\n\t\tif(mountpassword) {\n\t\t\tstrlcpy(mountpassword,getenv(\"PASSWD\"),MOUNT_PASSWD_SIZE+1);\n\t\t\tgot_password = 1;\n\t\t}\n\t} else if (getenv(\"PASSWD_FD\")) {\n\t\tget_password_from_file(atoi(getenv(\"PASSWD_FD\")),NULL);\n\t} else if (getenv(\"PASSWD_FILE\")) {\n\t\tget_password_from_file(0, getenv(\"PASSWD_FILE\"));\n\t}\n\n        if (orgoptions && parse_options(&orgoptions, &flags)) {\n                rc = EX_USAGE;\n\t\tgoto mount_exit;\n\t}\n\n\tif (getuid()) {\n#if !CIFS_LEGACY_SETUID_CHECK\n\t\tif (!(flags & (MS_USERS|MS_USER))) {\n\t\t\tfprintf(stderr, \"%s: permission denied\\n\", thisprogram);\n\t\t\trc = EX_USAGE;\n\t\t\tgoto mount_exit;\n\t\t}\n#endif /* !CIFS_LEGACY_SETUID_CHECK */\n\t\t\n\t\tif (geteuid()) {\n\t\t\tfprintf(stderr, \"%s: not installed setuid - \\\"user\\\" \"\n\t\t\t\t\t\"CIFS mounts not supported.\",\n\t\t\t\t\tthisprogram);\n\t\t\trc = EX_FAIL;\n\t\t\tgoto mount_exit;\n\t\t}\n\t}\n\n\tflags &= ~(MS_USERS|MS_USER);\n\n\taddrhead = addr = parse_server(&share_name);\n\tif((addrhead == NULL) && (got_ip == 0)) {\n\t\tfprintf(stderr, \"No ip address specified and hostname not found\\n\");\n\t\trc = EX_USAGE;\n\t\tgoto mount_exit;\n\t}\n\t\n\t/* BB save off path and pop after mount returns? */\n\tresolved_path = (char *)malloc(PATH_MAX+1);\n\tif (!resolved_path) {\n\t\tfprintf(stderr, \"Unable to allocate memory.\\n\");\n\t\trc = EX_SYSERR;\n\t\tgoto mount_exit;\n\t}\n\n\t/* Note that if we can not canonicalize the name, we get\n\t   another chance to see if it is valid when we chdir to it */\n\tif(!realpath(\".\", resolved_path)) {\n\t\tfprintf(stderr, \"Unable to resolve %s to canonical path: %s\\n\",\n\t\t\t\tmountpoint, strerror(errno));\n\t\trc = EX_SYSERR;\n\t\tgoto mount_exit;\n\t}\n\n\tmountpoint = resolved_path; \n\n\tif(got_user == 0) {\n\t\t/* Note that the password will not be retrieved from the\n\t\t   USER env variable (ie user%password form) as there is\n\t\t   already a PASSWD environment varaible */\n\t\tif (getenv(\"USER\"))\n\t\t\tuser_name = strdup(getenv(\"USER\"));\n\t\tif (user_name == NULL)\n\t\t\tuser_name = getusername();\n\t\tgot_user = 1;\n\t}\n       \n\tif(got_password == 0) {\n\t\tchar *tmp_pass = getpass(\"Password: \"); /* BB obsolete sys call but\n\t\t\t\t\t\t\t   no good replacement yet. */\n\t\tmountpassword = (char *)calloc(MOUNT_PASSWD_SIZE+1,1);\n\t\tif (!tmp_pass || !mountpassword) {\n\t\t\tfprintf(stderr, \"Password not entered, exiting\\n\");\n\t\t\texit(EX_USAGE);\n\t\t}\n\t\tstrlcpy(mountpassword, tmp_pass, MOUNT_PASSWD_SIZE+1);\n\t\tgot_password = 1;\n\t}\n\t/* FIXME launch daemon (handles dfs name resolution and credential change) \n\t   remember to clear parms and overwrite password field before launching */\n\tif(orgoptions) {\n\t\toptlen = strlen(orgoptions);\n\t\torgoptlen = optlen;\n\t} else\n\t\toptlen = 0;\n\tif(share_name)\n\t\toptlen += strlen(share_name) + 4;\n\telse {\n\t\tfprintf(stderr, \"No server share name specified\\n\");\n\t\tfprintf(stderr, \"\\nMounting the DFS root for server not implemented yet\\n\");\n                exit(EX_USAGE);\n\t}\n\tif(user_name)\n\t\toptlen += strlen(user_name) + 6;\n\toptlen += MAX_ADDRESS_LEN + 4;\n\tif(mountpassword)\n\t\toptlen += strlen(mountpassword) + 6;\nmount_retry:\n\tSAFE_FREE(options);\n\toptions_size = optlen + 10 + DOMAIN_SIZE;\n\toptions = (char *)malloc(options_size /* space for commas in password */ + 8 /* space for domain=  , domain name itself was counted as part of the length username string above */);\n\n\tif(options == NULL) {\n\t\tfprintf(stderr, \"Could not allocate memory for mount options\\n\");\n\t\texit(EX_SYSERR);\n\t}\n\n\tstrlcpy(options, \"unc=\", options_size);\n\tstrlcat(options,share_name,options_size);\n\t/* scan backwards and reverse direction of slash */\n\ttemp = strrchr(options, '/');\n\tif(temp > options + 6)\n\t\t*temp = '\\\\';\n\tif(user_name) {\n\t\t/* check for syntax like user=domain\\user */\n\t\tif(got_domain == 0)\n\t\t\tdomain_name = check_for_domain(&user_name);\n\t\tstrlcat(options,\",user=\",options_size);\n\t\tstrlcat(options,user_name,options_size);\n\t}\n\tif(retry == 0) {\n\t\tif(domain_name) {\n\t\t\t/* extra length accounted for in option string above */\n\t\t\tstrlcat(options,\",domain=\",options_size);\n\t\t\tstrlcat(options,domain_name,options_size);\n\t\t}\n\t}\n\n\tstrlcat(options,\",ver=\",options_size);\n\tstrlcat(options,MOUNT_CIFS_VERSION_MAJOR,options_size);\n\n\tif(orgoptions) {\n\t\tstrlcat(options,\",\",options_size);\n\t\tstrlcat(options,orgoptions,options_size);\n\t}\n\tif(prefixpath) {\n\t\tstrlcat(options,\",prefixpath=\",options_size);\n\t\tstrlcat(options,prefixpath,options_size); /* no need to cat the / */\n\t}\n\n\t/* convert all '\\\\' to '/' in share portion so that /proc/mounts looks pretty */\n\treplace_char(dev_name, '\\\\', '/', strlen(share_name));\n\n\tif (!got_ip && addr) {\n\t\tstrlcat(options, \",ip=\", options_size);\n\t\tcurrent_len = strnlen(options, options_size);\n\t\toptionstail = options + current_len;\n\t\tswitch (addr->ai_addr->sa_family) {\n\t\tcase AF_INET6:\n\t\t\taddr6 = (struct sockaddr_in6 *) addr->ai_addr;\n\t\t\tipaddr = inet_ntop(AF_INET6, &addr6->sin6_addr, optionstail,\n\t\t\t\t\t   options_size - current_len);\n\t\t\tbreak;\n\t\tcase AF_INET:\n\t\t\taddr4 = (struct sockaddr_in *) addr->ai_addr;\n\t\t\tipaddr = inet_ntop(AF_INET, &addr4->sin_addr, optionstail,\n\t\t\t\t\t   options_size - current_len);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tipaddr = NULL;\n\t\t}\n\n\t\t/* if the address looks bogus, try the next one */\n\t\tif (!ipaddr) {\n\t\t\taddr = addr->ai_next;\n\t\t\tif (addr)\n\t\t\t\tgoto mount_retry;\n\t\t\trc = EX_SYSERR;\n\t\t\tgoto mount_exit;\n\t\t}\n\t}\n\n\tif (addr->ai_addr->sa_family == AF_INET6 && addr6->sin6_scope_id) {\n\t\tstrlcat(options, \"%\", options_size);\n\t\tcurrent_len = strnlen(options, options_size);\n\t\toptionstail = options + current_len;\n\t\tsnprintf(optionstail, options_size - current_len, \"%u\",\n\t\t\t addr6->sin6_scope_id);\n\t}\n\n\tif(verboseflag)\n\t\tfprintf(stderr, \"\\nmount.cifs kernel mount options: %s\", options);\n\n\tif (mountpassword) {\n\t\t/*\n\t\t * Commas have to be doubled, or else they will\n\t\t * look like the parameter separator\n\t\t */\n\t\tif(retry == 0)\n\t\t\tcheck_for_comma(&mountpassword);\n\t\tstrlcat(options,\",pass=\",options_size);\n\t\tstrlcat(options,mountpassword,options_size);\n\t\tif (verboseflag)\n\t\t\tfprintf(stderr, \",pass=********\");\n\t}\n\n\tif (verboseflag)\n\t\tfprintf(stderr, \"\\n\");\n\n\trc = check_mtab(thisprogram, dev_name, mountpoint);\n\tif (rc)\n\t\tgoto mount_exit;\n\n\tif (!fakemnt && mount(dev_name, \".\", cifs_fstype, flags, options)) {\n\t\tswitch (errno) {\n\t\tcase ECONNREFUSED:\n\t\tcase EHOSTUNREACH:\n\t\t\tif (addr) {\n\t\t\t\taddr = addr->ai_next;\n\t\t\t\tif (addr)\n\t\t\t\t\tgoto mount_retry;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ENODEV:\n\t\t\tfprintf(stderr, \"mount error: cifs filesystem not supported by the system\\n\");\n\t\t\tbreak;\n\t\tcase ENXIO:\n\t\t\tif(retry == 0) {\n\t\t\t\tretry = 1;\n\t\t\t\tif (uppercase_string(dev_name) &&\n\t\t\t\t    uppercase_string(share_name) &&\n\t\t\t\t    uppercase_string(prefixpath)) {\n\t\t\t\t\tfprintf(stderr, \"retrying with upper case share name\\n\");\n\t\t\t\t\tgoto mount_retry;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfprintf(stderr, \"mount error(%d): %s\\n\", errno, strerror(errno));\n\t\tfprintf(stderr, \"Refer to the mount.cifs(8) manual page (e.g. man \"\n\t\t       \"mount.cifs)\\n\");\n\t\trc = EX_FAIL;\n\t\tgoto mount_exit;\n\t}\n\n\tif (nomtab)\n\t\tgoto mount_exit;\n\tatexit(unlock_mtab);\n\trc = lock_mtab();\n\tif (rc) {\n\t\tfprintf(stderr, \"cannot lock mtab\");\n\t\tgoto mount_exit;\n\t}\n\tpmntfile = setmntent(MOUNTED, \"a+\");\n\tif (!pmntfile) {\n\t\tfprintf(stderr, \"could not update mount table\\n\");\n\t\tunlock_mtab();\n\t\trc = EX_FILEIO;\n\t\tgoto mount_exit;\n\t}\n\tmountent.mnt_fsname = dev_name;\n\tmountent.mnt_dir = mountpoint;\n\tmountent.mnt_type = (char *)(void *)cifs_fstype;\n\tmountent.mnt_opts = (char *)malloc(220);\n\tif(mountent.mnt_opts) {\n\t\tchar * mount_user = getusername();\n\t\tmemset(mountent.mnt_opts,0,200);\n\t\tif(flags & MS_RDONLY)\n\t\t\tstrlcat(mountent.mnt_opts,\"ro\",220);\n\t\telse\n\t\t\tstrlcat(mountent.mnt_opts,\"rw\",220);\n\t\tif(flags & MS_MANDLOCK)\n\t\t\tstrlcat(mountent.mnt_opts,\",mand\",220);\n\t\tif(flags & MS_NOEXEC)\n\t\t\tstrlcat(mountent.mnt_opts,\",noexec\",220);\n\t\tif(flags & MS_NOSUID)\n\t\t\tstrlcat(mountent.mnt_opts,\",nosuid\",220);\n\t\tif(flags & MS_NODEV)\n\t\t\tstrlcat(mountent.mnt_opts,\",nodev\",220);\n\t\tif(flags & MS_SYNCHRONOUS)\n\t\t\tstrlcat(mountent.mnt_opts,\",sync\",220);\n\t\tif(mount_user) {\n\t\t\tif(getuid() != 0) {\n\t\t\t\tstrlcat(mountent.mnt_opts,\n\t\t\t\t\t\",user=\", 220);\n\t\t\t\tstrlcat(mountent.mnt_opts,\n\t\t\t\t\tmount_user, 220);\n\t\t\t}\n\t\t}\n\t}\n\tmountent.mnt_freq = 0;\n\tmountent.mnt_passno = 0;\n\trc = addmntent(pmntfile,&mountent);\n\tendmntent(pmntfile);\n\tunlock_mtab();\n\tSAFE_FREE(mountent.mnt_opts);\n\tif (rc)\n\t\trc = EX_FILEIO;\nmount_exit:\n\tif(mountpassword) {\n\t\tint len = strlen(mountpassword);\n\t\tmemset(mountpassword,0,len);\n\t\tSAFE_FREE(mountpassword);\n\t}\n\n\tif (addrhead)\n\t\tfreeaddrinfo(addrhead);\n\tSAFE_FREE(options);\n\tSAFE_FREE(orgoptions);\n\tSAFE_FREE(resolved_path);\n\tSAFE_FREE(share_name);\n\texit(rc);\n}",
        "target": 1
    },
    {
        "func": "ReadBMP (const gchar  *name,\n         GError      **error)\n{\n  FILE     *fd;\n  guchar    buffer[64];\n  gint      ColormapSize, rowbytes, Maps;\n  gboolean  Grey = FALSE;\n  guchar    ColorMap[256][3];\n  gint32    image_ID;\n  gchar     magick[2];\n  Bitmap_Channel masks[4];\n\n  filename = name;\n  fd = g_fopen (filename, \"rb\");\n\n  if (!fd)\n    {\n      g_set_error (error, G_FILE_ERROR, g_file_error_from_errno (errno),\n                   _(\"Could not open '%s' for reading: %s\"),\n                   gimp_filename_to_utf8 (filename), g_strerror (errno));\n      return -1;\n    }\n\n  gimp_progress_init_printf (_(\"Opening '%s'\"),\n                             gimp_filename_to_utf8 (name));\n\n  /* It is a File. Now is it a Bitmap? Read the shortest possible header */\n\n  if (!ReadOK (fd, magick, 2) || !(!strncmp (magick, \"BA\", 2) ||\n     !strncmp (magick, \"BM\", 2) || !strncmp (magick, \"IC\", 2) ||\n     !strncmp (magick, \"PI\", 2) || !strncmp (magick, \"CI\", 2) ||\n     !strncmp (magick, \"CP\", 2)))\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"'%s' is not a valid BMP file\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  while (!strncmp (magick, \"BA\", 2))\n    {\n      if (!ReadOK (fd, buffer, 12))\n        {\n          g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                       _(\"'%s' is not a valid BMP file\"),\n                       gimp_filename_to_utf8 (filename));\n          return -1;\n        }\n      if (!ReadOK (fd, magick, 2))\n        {\n          g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                       _(\"'%s' is not a valid BMP file\"),\n                       gimp_filename_to_utf8 (filename));\n          return -1;\n        }\n    }\n\n  if (!ReadOK (fd, buffer, 12))\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"'%s' is not a valid BMP file\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  /* bring them to the right byteorder. Not too nice, but it should work */\n\n  Bitmap_File_Head.bfSize    = ToL (&buffer[0x00]);\n  Bitmap_File_Head.zzHotX    = ToS (&buffer[0x04]);\n  Bitmap_File_Head.zzHotY    = ToS (&buffer[0x06]);\n  Bitmap_File_Head.bfOffs    = ToL (&buffer[0x08]);\n\n  if (!ReadOK (fd, buffer, 4))\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"'%s' is not a valid BMP file\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  Bitmap_File_Head.biSize    = ToL (&buffer[0x00]);\n\n  /* What kind of bitmap is it? */\n\n  if (Bitmap_File_Head.biSize == 12) /* OS/2 1.x ? */\n    {\n      if (!ReadOK (fd, buffer, 8))\n        {\n          g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                       _(\"Error reading BMP file header from '%s'\"),\n                       gimp_filename_to_utf8 (filename));\n          return -1;\n        }\n\n      Bitmap_Head.biWidth   = ToS (&buffer[0x00]);       /* 12 */\n      Bitmap_Head.biHeight  = ToS (&buffer[0x02]);       /* 14 */\n      Bitmap_Head.biPlanes  = ToS (&buffer[0x04]);       /* 16 */\n      Bitmap_Head.biBitCnt  = ToS (&buffer[0x06]);       /* 18 */\n      Bitmap_Head.biCompr   = 0;\n      Bitmap_Head.biSizeIm  = 0;\n      Bitmap_Head.biXPels   = Bitmap_Head.biYPels = 0;\n      Bitmap_Head.biClrUsed = 0;\n      Bitmap_Head.biClrImp  = 0;\n      Bitmap_Head.masks[0]  = 0;\n      Bitmap_Head.masks[1]  = 0;\n      Bitmap_Head.masks[2]  = 0;\n      Bitmap_Head.masks[3]  = 0;\n\n      memset(masks, 0, sizeof(masks));\n      Maps = 3;\n    }\n  else if (Bitmap_File_Head.biSize == 40) /* Windows 3.x */\n    {\n      if (!ReadOK (fd, buffer, 36))\n        {\n          g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                       _(\"Error reading BMP file header from '%s'\"),\n                       gimp_filename_to_utf8 (filename));\n          return -1;\n        }\n\n      Bitmap_Head.biWidth   = ToL (&buffer[0x00]);      /* 12 */\n      Bitmap_Head.biHeight  = ToL (&buffer[0x04]);      /* 16 */\n      Bitmap_Head.biPlanes  = ToS (&buffer[0x08]);       /* 1A */\n      Bitmap_Head.biBitCnt  = ToS (&buffer[0x0A]);      /* 1C */\n      Bitmap_Head.biCompr   = ToL (&buffer[0x0C]);      /* 1E */\n      Bitmap_Head.biSizeIm  = ToL (&buffer[0x10]);      /* 22 */\n      Bitmap_Head.biXPels   = ToL (&buffer[0x14]);      /* 26 */\n      Bitmap_Head.biYPels   = ToL (&buffer[0x18]);      /* 2A */\n      Bitmap_Head.biClrUsed = ToL (&buffer[0x1C]);      /* 2E */\n      Bitmap_Head.biClrImp  = ToL (&buffer[0x20]);      /* 32 */\n      Bitmap_Head.masks[0]  = 0;\n      Bitmap_Head.masks[1]  = 0;\n      Bitmap_Head.masks[2]  = 0;\n      Bitmap_Head.masks[3]  = 0;\n\n      Maps = 4;\n      memset(masks, 0, sizeof(masks));\n\n      if (Bitmap_Head.biCompr == BI_BITFIELDS)\n        {\n          if (!ReadOK (fd, buffer, 3 * sizeof (guint32)))\n            {\n              g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                           _(\"Error reading BMP file header from '%s'\"),\n                           gimp_filename_to_utf8 (filename));\n              return -1;\n            }\n\n          Bitmap_Head.masks[0] = ToL(&buffer[0x00]);\n          Bitmap_Head.masks[1] = ToL(&buffer[0x04]);\n          Bitmap_Head.masks[2] = ToL(&buffer[0x08]);\n         ReadChannelMasks (&Bitmap_Head.masks[0], masks, 3);\n        }\n      else\n        switch (Bitmap_Head.biBitCnt)\n          {\n          case 32:\n            masks[0].mask     = 0x00ff0000;\n            masks[0].shiftin  = 16;\n            masks[0].max_value= (gfloat)255.0;\n            masks[1].mask     = 0x0000ff00;\n            masks[1].shiftin  = 8;\n            masks[1].max_value= (gfloat)255.0;\n            masks[2].mask     = 0x000000ff;\n            masks[2].shiftin  = 0;\n            masks[2].max_value= (gfloat)255.0;\n            masks[3].mask     = 0xff000000;\n            masks[3].shiftin  = 24;\n            masks[3].max_value= (gfloat)255.0;\n            break;\n         case 24:\n            masks[0].mask     = 0xff0000;\n            masks[0].shiftin  = 16;\n            masks[0].max_value= (gfloat)255.0;\n            masks[1].mask     = 0x00ff00;\n            masks[1].shiftin  = 8;\n            masks[1].max_value= (gfloat)255.0;\n            masks[2].mask     = 0x0000ff;\n            masks[2].shiftin  = 0;\n            masks[2].max_value= (gfloat)255.0;\n            masks[3].mask     = 0x0;\n            masks[3].shiftin  = 0;\n            masks[3].max_value= (gfloat)0.0;\n            break;\n         case 16:\n            masks[0].mask     = 0x7c00;\n            masks[0].shiftin  = 10;\n            masks[0].max_value= (gfloat)31.0;\n            masks[1].mask     = 0x03e0;\n            masks[1].shiftin  = 5;\n            masks[1].max_value= (gfloat)31.0;\n            masks[2].mask     = 0x001f;\n            masks[2].shiftin  = 0;\n            masks[2].max_value= (gfloat)31.0;\n            masks[3].mask     = 0x0;\n            masks[3].shiftin  = 0;\n            masks[3].max_value= (gfloat)0.0;\n            break;\n         default:\n            break;\n         }\n    }\n  else if (Bitmap_File_Head.biSize >= 56 && Bitmap_File_Head.biSize <= 64)\n    /* enhanced Windows format with bit masks */\n    {\n      if (!ReadOK (fd, buffer, Bitmap_File_Head.biSize - 4))\n        {\n          g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                       _(\"Error reading BMP file header from '%s'\"),\n                       gimp_filename_to_utf8 (filename));\n          return -1;\n        }\n\n      Bitmap_Head.biWidth   =ToL (&buffer[0x00]);       /* 12 */\n      Bitmap_Head.biHeight  =ToL (&buffer[0x04]);       /* 16 */\n      Bitmap_Head.biPlanes  =ToS (&buffer[0x08]);       /* 1A */\n      Bitmap_Head.biBitCnt  =ToS (&buffer[0x0A]);       /* 1C */\n      Bitmap_Head.biCompr   =ToL (&buffer[0x0C]);       /* 1E */\n      Bitmap_Head.biSizeIm  =ToL (&buffer[0x10]);       /* 22 */\n      Bitmap_Head.biXPels   =ToL (&buffer[0x14]);       /* 26 */\n      Bitmap_Head.biYPels   =ToL (&buffer[0x18]);       /* 2A */\n      Bitmap_Head.biClrUsed =ToL (&buffer[0x1C]);       /* 2E */\n      Bitmap_Head.biClrImp  =ToL (&buffer[0x20]);       /* 32 */\n      Bitmap_Head.masks[0]  =ToL (&buffer[0x24]);       /* 36 */\n      Bitmap_Head.masks[1]  =ToL (&buffer[0x28]);       /* 3A */\n      Bitmap_Head.masks[2]  =ToL (&buffer[0x2C]);       /* 3E */\n      Bitmap_Head.masks[3]  =ToL (&buffer[0x30]);       /* 42 */\n\n      Maps = 4;\n      ReadChannelMasks (&Bitmap_Head.masks[0], masks, 4);\n    }\n  else\n    {\n      GdkPixbuf* pixbuf = gdk_pixbuf_new_from_file(filename, NULL);\n\n      if (pixbuf)\n        {\n          gint32 layer_ID;\n\n          image_ID = gimp_image_new (gdk_pixbuf_get_width (pixbuf),\n                                     gdk_pixbuf_get_height (pixbuf),\n                                     GIMP_RGB);\n\n          layer_ID = gimp_layer_new_from_pixbuf (image_ID, _(\"Background\"),\n                                                 pixbuf,\n                                                 100.,\n                                                 GIMP_NORMAL_MODE, 0, 0);\n          g_object_unref (pixbuf);\n\n          gimp_image_set_filename (image_ID, filename);\n          gimp_image_add_layer (image_ID, layer_ID, -1);\n\n          return image_ID;\n        }\n      else\n        {\n\n          g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                       _(\"Error reading BMP file header from '%s'\"),\n                       gimp_filename_to_utf8 (filename));\n          return -1;\n        }\n    }\n\n  /* Valid bitpdepthis 1, 4, 8, 16, 24, 32 */\n  /* 16 is awful, we should probably shoot whoever invented it */\n\n  /* There should be some colors used! */\n\n  ColormapSize =\n    (Bitmap_File_Head.bfOffs - Bitmap_File_Head.biSize - 14) / Maps;\n\n  if ((Bitmap_Head.biClrUsed == 0) && (Bitmap_Head.biBitCnt <= 8))\n    ColormapSize = Bitmap_Head.biClrUsed = 1 << Bitmap_Head.biBitCnt;\n\n  if (ColormapSize > 256)\n    ColormapSize = 256;\n\n  /* Sanity checks */\n\n  if (Bitmap_Head.biHeight == 0 || Bitmap_Head.biWidth == 0)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"'%s' is not a valid BMP file\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  if (Bitmap_Head.biWidth < 0)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"'%s' is not a valid BMP file\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  if (Bitmap_Head.biPlanes != 1)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"'%s' is not a valid BMP file\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  if (Bitmap_Head.biClrUsed > 256)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"'%s' is not a valid BMP file\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  /* Windows and OS/2 declare filler so that rows are a multiple of\n   * word length (32 bits == 4 bytes)\n   */\n\n  rowbytes= ((Bitmap_Head.biWidth * Bitmap_Head.biBitCnt - 1) / 32) * 4 + 4;\n\n#ifdef DEBUG\n  printf (\"\\nSize: %u, Colors: %u, Bits: %u, Width: %u, Height: %u, \"\n          \"Comp: %u, Zeile: %u\\n\",\n          Bitmap_File_Head.bfSize,\n          Bitmap_Head.biClrUsed,\n          Bitmap_Head.biBitCnt,\n          Bitmap_Head.biWidth,\n          Bitmap_Head.biHeight,\n          Bitmap_Head.biCompr,\n          rowbytes);\n#endif\n\n  if (Bitmap_Head.biBitCnt <= 8)\n    {\n#ifdef DEBUG\n      printf (\"Colormap read\\n\");\n#endif\n      /* Get the Colormap */\n      if (!ReadColorMap (fd, ColorMap, ColormapSize, Maps, &Grey))\n        return -1;\n    }\n\n  fseek (fd, Bitmap_File_Head.bfOffs, SEEK_SET);\n\n  /* Get the Image and return the ID or -1 on error*/\n  image_ID = ReadImage (fd,\n                        Bitmap_Head.biWidth,\n                        ABS (Bitmap_Head.biHeight),\n                        ColorMap,\n                        Bitmap_Head.biClrUsed,\n                        Bitmap_Head.biBitCnt,\n                        Bitmap_Head.biCompr,\n                        rowbytes,\n                        Grey,\n                        masks,\n                        error);\n\n  if (image_ID < 0)\n    return -1;\n\n  if (Bitmap_Head.biXPels > 0 && Bitmap_Head.biYPels > 0)\n    {\n      /* Fixed up from scott@asofyet's changes last year, njl195 */\n      gdouble xresolution;\n      gdouble yresolution;\n\n      /* I don't agree with scott's feeling that Gimp should be\n       * trying to \"fix\" metric resolution translations, in the\n       * long term Gimp should be SI (metric) anyway, but we\n       * haven't told the Americans that yet  */\n\n      xresolution = Bitmap_Head.biXPels * 0.0254;\n      yresolution = Bitmap_Head.biYPels * 0.0254;\n\n      gimp_image_set_resolution (image_ID, xresolution, yresolution);\n    }\n\n  if (Bitmap_Head.biHeight < 0)\n    gimp_image_flip (image_ID, GIMP_ORIENTATION_VERTICAL);\n\n  return image_ID;\n}",
        "target": 1
    },
    {
        "func": "read_header_block (PSDimage  *img_a,\n                   FILE      *f,\n                   GError   **error)\n{\n  guint16  version;\n  gchar    sig[4];\n  gchar    buf[6];\n\n  if (fread (sig, 4, 1, f) < 1\n      || fread (&version, 2, 1, f) < 1\n      || fread (buf, 6, 1, f) < 1\n      || fread (&img_a->channels, 2, 1, f) < 1\n      || fread (&img_a->rows, 4, 1, f) < 1\n      || fread (&img_a->columns, 4, 1, f) < 1\n      || fread (&img_a->bps, 2, 1, f) < 1\n      || fread (&img_a->color_mode, 2, 1, f) < 1)\n    {\n      psd_set_error (feof (f), errno, error);\n      return -1;\n    }\n  version = GUINT16_FROM_BE (version);\n  img_a->channels = GUINT16_FROM_BE (img_a->channels);\n  img_a->rows = GUINT32_FROM_BE (img_a->rows);\n  img_a->columns = GUINT32_FROM_BE (img_a->columns);\n  img_a->bps = GUINT16_FROM_BE (img_a->bps);\n  img_a->color_mode = GUINT16_FROM_BE (img_a->color_mode);\n\n  IFDBG(1) g_debug (\"\\n\\n\\tSig: %.4s\\n\\tVer: %d\\n\\tChannels: \"\n                    \"%d\\n\\tSize: %dx%d\\n\\tBPS: %d\\n\\tMode: %d\\n\",\n                    sig, version, img_a->channels,\n                    img_a->columns, img_a->rows,\n                    img_a->bps, img_a->color_mode);\n\n  if (memcmp (sig, \"8BPS\", 4) != 0)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                  _(\"Not a valid photoshop document file\"));\n      return -1;\n    }\n\n  if (version != 1)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                  _(\"Unsupported file format version: %d\"), version);\n      return -1;\n    }\n\n  if (img_a->channels > MAX_CHANNELS)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                  _(\"Too many channels in file: %d\"), img_a->channels);\n      return -1;\n    }\n\n    /* Photoshop CS (version 8) supports 300000 x 300000, but this\n       is currently larger than GIMP_MAX_IMAGE_SIZE */\n\n  if (img_a->rows < 1 || img_a->rows > GIMP_MAX_IMAGE_SIZE)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                  _(\"Unsupported or invalid image height: %d\"),\n                  img_a->rows);\n      return -1;\n    }\n\n  if (img_a->columns < 1 || img_a->columns > GIMP_MAX_IMAGE_SIZE)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                  _(\"Unsupported or invalid image width: %d\"),\n                  img_a->columns);\n      return -1;\n    }\n\n  if (img_a->color_mode != PSD_BITMAP\n      && img_a->color_mode != PSD_GRAYSCALE\n      && img_a->color_mode != PSD_INDEXED\n      && img_a->color_mode != PSD_RGB\n      && img_a->color_mode != PSD_DUOTONE)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"Unsupported color mode: %s\"),\n                   get_psd_color_mode_name (img_a->color_mode));\n      return -1;\n    }\n\n  /* Warnings for format conversions */\n  switch (img_a->bps)\n    {\n      case 16:\n        IFDBG(3) g_debug (\"16 Bit Data\");\n        if (CONVERSION_WARNINGS)\n          g_message (_(\"Warning:\\n\"\n                       \"The image you are loading has 16 bits per channel. GIMP \"\n                       \"can only handle 8 bit, so it will be converted for you. \"\n                       \"Information will be lost because of this conversion.\"));\n        break;\n\n      case 8:\n        IFDBG(3) g_debug (\"8 Bit Data\");\n        break;\n\n      case 1:\n        IFDBG(3) g_debug (\"1 Bit Data\");\n        break;\n\n      default:\n        g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                    _(\"Unsupported bit depth: %d\"), img_a->bps);\n        return -1;\n        break;\n    }\n\n  return 0;\n}",
        "target": 1
    },
    {
        "func": "read_layer_block (PSDimage  *img_a,\n                  FILE      *f,\n                  GError   **error)\n{\n  PSDlayer **lyr_a;\n  guint32    block_len;\n  guint32    block_end;\n  guint32    block_rem;\n  gint32     read_len;\n  gint32     write_len;\n  gint       lidx;                  /* Layer index */\n  gint       cidx;                  /* Channel index */\n\n  if (fread (&block_len, 4, 1, f) < 1)\n    {\n      psd_set_error (feof (f), errno, error);\n      img_a->num_layers = -1;\n      return NULL;\n    }\n  img_a->mask_layer_len = GUINT32_FROM_BE (block_len);\n\n  IFDBG(1) g_debug (\"Layer and mask block size = %d\", img_a->mask_layer_len);\n\n  img_a->transparency = FALSE;\n  img_a->layer_data_len = 0;\n\n  if (!img_a->mask_layer_len)\n    {\n      img_a->num_layers = 0;\n      return NULL;\n    }\n  else\n    {\n      img_a->mask_layer_start = ftell (f);\n      block_end = img_a->mask_layer_start + img_a->mask_layer_len;\n\n      /* Get number of layers */\n      if (fread (&block_len, 4, 1, f) < 1\n          || fread (&img_a->num_layers, 2, 1, f) < 1)\n        {\n          psd_set_error (feof (f), errno, error);\n          img_a->num_layers = -1;\n          return NULL;\n        }\n      img_a->num_layers = GINT16_FROM_BE (img_a->num_layers);\n      IFDBG(2) g_debug (\"Number of layers: %d\", img_a->num_layers);\n\n      if (img_a->num_layers < 0)\n        {\n          img_a->transparency = TRUE;\n          img_a->num_layers = -img_a->num_layers;\n        }\n\n      if (img_a->num_layers)\n        {\n          /* Read layer records */\n          PSDlayerres           res_a;\n\n          /* Create pointer array for the layer records */\n          lyr_a = g_new (PSDlayer *, img_a->num_layers);\n          for (lidx = 0; lidx < img_a->num_layers; ++lidx)\n            {\n              /* Allocate layer record */\n              lyr_a[lidx] = (PSDlayer *) g_malloc (sizeof (PSDlayer) );\n\n              /* Initialise record */\n              lyr_a[lidx]->drop = FALSE;\n              lyr_a[lidx]->id = 0;\n\n              if (fread (&lyr_a[lidx]->top, 4, 1, f) < 1\n                  || fread (&lyr_a[lidx]->left, 4, 1, f) < 1\n                  || fread (&lyr_a[lidx]->bottom, 4, 1, f) < 1\n                  || fread (&lyr_a[lidx]->right, 4, 1, f) < 1\n                  || fread (&lyr_a[lidx]->num_channels, 2, 1, f) < 1)\n                {\n                  psd_set_error (feof (f), errno, error);\n                  return NULL;\n                }\n              lyr_a[lidx]->top = GINT32_FROM_BE (lyr_a[lidx]->top);\n              lyr_a[lidx]->left = GINT32_FROM_BE (lyr_a[lidx]->left);\n              lyr_a[lidx]->bottom = GINT32_FROM_BE (lyr_a[lidx]->bottom);\n              lyr_a[lidx]->right = GINT32_FROM_BE (lyr_a[lidx]->right);\n              lyr_a[lidx]->num_channels = GUINT16_FROM_BE (lyr_a[lidx]->num_channels);\n\n              if (lyr_a[lidx]->num_channels > MAX_CHANNELS)\n                {\n                  g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                              _(\"Too many channels in layer: %d\"),\n                              lyr_a[lidx]->num_channels);\n                  return NULL;\n                }\n              if (lyr_a[lidx]->bottom - lyr_a[lidx]->top > GIMP_MAX_IMAGE_SIZE)\n                {\n                  g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                              _(\"Unsupported or invalid layer height: %d\"),\n                              lyr_a[lidx]->bottom - lyr_a[lidx]->top);\n                  return NULL;\n                }\n              if (lyr_a[lidx]->right - lyr_a[lidx]->left > GIMP_MAX_IMAGE_SIZE)\n                {\n                  g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                              _(\"Unsupported or invalid layer width: %d\"),\n                              lyr_a[lidx]->right - lyr_a[lidx]->left);\n                  return NULL;\n                }\n\n              IFDBG(2) g_debug (\"Layer %d, Coords %d %d %d %d, channels %d, \",\n                                 lidx, lyr_a[lidx]->left, lyr_a[lidx]->top,\n                                 lyr_a[lidx]->right, lyr_a[lidx]->bottom,\n                                 lyr_a[lidx]->num_channels);\n\n              lyr_a[lidx]->chn_info = g_new (ChannelLengthInfo, lyr_a[lidx]->num_channels);\n              for (cidx = 0; cidx < lyr_a[lidx]->num_channels; ++cidx)\n                {\n                  if (fread (&lyr_a[lidx]->chn_info[cidx].channel_id, 2, 1, f) < 1\n                      || fread (&lyr_a[lidx]->chn_info[cidx].data_len, 4, 1, f) < 1)\n                    {\n                      psd_set_error (feof (f), errno, error);\n                      return NULL;\n                    }\n                  lyr_a[lidx]->chn_info[cidx].channel_id =\n                    GINT16_FROM_BE (lyr_a[lidx]->chn_info[cidx].channel_id);\n                  lyr_a[lidx]->chn_info[cidx].data_len =\n                    GUINT32_FROM_BE (lyr_a[lidx]->chn_info[cidx].data_len);\n                  img_a->layer_data_len += lyr_a[lidx]->chn_info[cidx].data_len;\n                  IFDBG(3) g_debug (\"Channel ID %d, data len %d\",\n                                     lyr_a[lidx]->chn_info[cidx].channel_id,\n                                     lyr_a[lidx]->chn_info[cidx].data_len);\n                }\n\n              if (fread (lyr_a[lidx]->mode_key, 4, 1, f) < 1\n                  || fread (lyr_a[lidx]->blend_mode, 4, 1, f) < 1\n                  || fread (&lyr_a[lidx]->opacity, 1, 1, f) < 1\n                  || fread (&lyr_a[lidx]->clipping, 1, 1, f) < 1\n                  || fread (&lyr_a[lidx]->flags, 1, 1, f) < 1\n                  || fread (&lyr_a[lidx]->filler, 1, 1, f) < 1\n                  || fread (&lyr_a[lidx]->extra_len, 4, 1, f) < 1)\n                {\n                  psd_set_error (feof (f), errno, error);\n                  return NULL;\n                }\n              if (memcmp (lyr_a[lidx]->mode_key, \"8BIM\", 4) != 0)\n                {\n                  IFDBG(1) g_debug (\"Incorrect layer mode signature %.4s\",\n                                    lyr_a[lidx]->mode_key);\n                  g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                              _(\"The file is corrupt!\"));\n                  return NULL;\n                }\n\n              lyr_a[lidx]->layer_flags.trans_prot = lyr_a[lidx]->flags & 1 ? TRUE : FALSE;\n              lyr_a[lidx]->layer_flags.visible = lyr_a[lidx]->flags & 2 ? FALSE : TRUE;\n              if (lyr_a[lidx]->flags & 8)\n                lyr_a[lidx]->layer_flags.irrelevant = lyr_a[lidx]->flags & 16 ? TRUE : FALSE;\n              else\n                lyr_a[lidx]->layer_flags.irrelevant = FALSE;\n\n              lyr_a[lidx]->extra_len = GUINT32_FROM_BE (lyr_a[lidx]->extra_len);\n              block_rem = lyr_a[lidx]->extra_len;\n              IFDBG(2) g_debug (\"\\n\\tLayer mode sig: %.4s\\n\\tBlend mode: %.4s\\n\\t\"\n                                \"Opacity: %d\\n\\tClipping: %d\\n\\tExtra data len: %d\\n\\t\"\n                                \"Alpha lock: %d\\n\\tVisible: %d\\n\\tIrrelevant: %d\",\n                                    lyr_a[lidx]->mode_key,\n                                    lyr_a[lidx]->blend_mode,\n                                    lyr_a[lidx]->opacity,\n                                    lyr_a[lidx]->clipping,\n                                    lyr_a[lidx]->extra_len,\n                                    lyr_a[lidx]->layer_flags.trans_prot,\n                                    lyr_a[lidx]->layer_flags.visible,\n                                    lyr_a[lidx]->layer_flags.irrelevant);\n              IFDBG(3) g_debug (\"Remaining length %d\", block_rem);\n\n              /* Layer mask data */\n              if (fread (&block_len, 4, 1, f) < 1)\n                {\n                  psd_set_error (feof (f), errno, error);\n                  return NULL;\n                }\n              block_len = GUINT32_FROM_BE (block_len);\n              block_rem -= (block_len + 4);\n              IFDBG(3) g_debug (\"Remaining length %d\", block_rem);\n\n              lyr_a[lidx]->layer_mask_extra.top = 0;\n              lyr_a[lidx]->layer_mask_extra.left = 0;\n              lyr_a[lidx]->layer_mask_extra.bottom = 0;\n              lyr_a[lidx]->layer_mask_extra.right = 0;\n              lyr_a[lidx]->layer_mask.top = 0;\n              lyr_a[lidx]->layer_mask.left = 0;\n              lyr_a[lidx]->layer_mask.bottom = 0;\n              lyr_a[lidx]->layer_mask.right = 0;\n              lyr_a[lidx]->layer_mask.def_color = 0;\n              lyr_a[lidx]->layer_mask.extra_def_color = 0;\n              lyr_a[lidx]->layer_mask.mask_flags.relative_pos = FALSE;\n              lyr_a[lidx]->layer_mask.mask_flags.disabled = FALSE;\n              lyr_a[lidx]->layer_mask.mask_flags.invert = FALSE;\n\n              switch (block_len)\n                {\n                  case 0:\n                    break;\n\n                  case 20:\n                    if (fread (&lyr_a[lidx]->layer_mask.top, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.left, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.bottom, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.right, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.def_color, 1, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.flags, 1, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.extra_def_color, 1, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.extra_flags, 1, 1, f) < 1)\n                      {\n                        psd_set_error (feof (f), errno, error);\n                        return NULL;\n                      }\n                    lyr_a[lidx]->layer_mask.top =\n                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask.top);\n                    lyr_a[lidx]->layer_mask.left =\n                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask.left);\n                    lyr_a[lidx]->layer_mask.bottom =\n                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask.bottom);\n                    lyr_a[lidx]->layer_mask.right =\n                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask.right);\n                    lyr_a[lidx]->layer_mask.mask_flags.relative_pos =\n                      lyr_a[lidx]->layer_mask.flags & 1 ? TRUE : FALSE;\n                    lyr_a[lidx]->layer_mask.mask_flags.disabled =\n                      lyr_a[lidx]->layer_mask.flags & 2 ? TRUE : FALSE;\n                    lyr_a[lidx]->layer_mask.mask_flags.invert =\n                      lyr_a[lidx]->layer_mask.flags & 4 ? TRUE : FALSE;\n                    break;\n                  case 36: /* If we have a 36 byte mask record assume second data set is correct */\n                    if (fread (&lyr_a[lidx]->layer_mask_extra.top, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask_extra.left, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask_extra.bottom, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask_extra.right, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.extra_def_color, 1, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.extra_flags, 1, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.def_color, 1, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.flags, 1, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.top, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.left, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.bottom, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.right, 4, 1, f) < 1)\n                      {\n                        psd_set_error (feof (f), errno, error);\n                        return NULL;\n                      }\n                    lyr_a[lidx]->layer_mask_extra.top =\n                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask_extra.top);\n                    lyr_a[lidx]->layer_mask_extra.left =\n                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask_extra.left);\n                    lyr_a[lidx]->layer_mask_extra.bottom =\n                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask_extra.bottom);\n                    lyr_a[lidx]->layer_mask_extra.right =\n                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask_extra.right);\n                    lyr_a[lidx]->layer_mask.top =\n                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask.top);\n                    lyr_a[lidx]->layer_mask.left =\n                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask.left);\n                    lyr_a[lidx]->layer_mask.bottom =\n                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask.bottom);\n                    lyr_a[lidx]->layer_mask.right =\n                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask.right);\n                    lyr_a[lidx]->layer_mask.mask_flags.relative_pos =\n                      lyr_a[lidx]->layer_mask.flags & 1 ? TRUE : FALSE;\n                    lyr_a[lidx]->layer_mask.mask_flags.disabled =\n                      lyr_a[lidx]->layer_mask.flags & 2 ? TRUE : FALSE;\n                    lyr_a[lidx]->layer_mask.mask_flags.invert =\n                      lyr_a[lidx]->layer_mask.flags & 4 ? TRUE : FALSE;\n                    break;\n\n                  default:\n                    IFDBG(1) g_debug (\"Unknown layer mask record size ... skipping\");\n                    if (fseek (f, block_len, SEEK_CUR) < 0)\n                      {\n                        psd_set_error (feof (f), errno, error);\n                        return NULL;\n                      }\n                }\n\n              IFDBG(2) g_debug (\"Layer mask coords %d %d %d %d, Rel pos %d\",\n                                lyr_a[lidx]->layer_mask.left,\n                                lyr_a[lidx]->layer_mask.top,\n                                lyr_a[lidx]->layer_mask.right,\n                                lyr_a[lidx]->layer_mask.bottom,\n                                lyr_a[lidx]->layer_mask.mask_flags.relative_pos);\n\n              IFDBG(3) g_debug (\"Default mask color, %d, %d\",\n                                lyr_a[lidx]->layer_mask.def_color,\n                                lyr_a[lidx]->layer_mask.extra_def_color);\n\n              /* Layer blending ranges */           /* FIXME  */\n              if (fread (&block_len, 4, 1, f) < 1)\n                {\n                  psd_set_error (feof (f), errno, error);\n                  return NULL;\n                }\n              block_len = GUINT32_FROM_BE (block_len);\n              block_rem -= (block_len + 4);\n              IFDBG(3) g_debug (\"Remaining length %d\", block_rem);\n              if (block_len > 0)\n                {\n                  if (fseek (f, block_len, SEEK_CUR) < 0)\n                    {\n                      psd_set_error (feof (f), errno, error);\n                      return NULL;\n                    }\n                }\n\n              lyr_a[lidx]->name = fread_pascal_string (&read_len, &write_len,\n                                                       4, f, error);\n              if (*error)\n                return NULL;\n              block_rem -= read_len;\n              IFDBG(3) g_debug (\"Remaining length %d\", block_rem);\n\n              /* Adjustment layer info */           /* FIXME */\n\n              while (block_rem > 7)\n                {\n                  if (get_layer_resource_header (&res_a, f, error) < 0)\n                    return NULL;\n                  block_rem -= 12;\n\n                  if (res_a.data_len > block_rem)\n                    {\n                      IFDBG(1) g_debug (\"Unexpected end of layer resource data\");\n                      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                                  _(\"The file is corrupt!\"));\n                      return NULL;\n                    }\n\n                  if (load_layer_resource (&res_a, lyr_a[lidx], f, error) < 0)\n                    return NULL;\n                  block_rem -= res_a.data_len;\n                }\n              if (block_rem > 0)\n                {\n                  if (fseek (f, block_rem, SEEK_CUR) < 0)\n                    {\n                      psd_set_error (feof (f), errno, error);\n                      return NULL;\n                    }\n                }\n            }\n\n          img_a->layer_data_start = ftell(f);\n          if (fseek (f, img_a->layer_data_len, SEEK_CUR) < 0)\n            {\n              psd_set_error (feof (f), errno, error);\n              return NULL;\n            }\n\n          IFDBG(1) g_debug (\"Layer image data block size %d\",\n                             img_a->layer_data_len);\n        }\n      else\n        lyr_a = NULL;\n\n      /* Read global layer mask record */       /* FIXME */\n\n      /* Skip to end of block */\n      if (fseek (f, block_end, SEEK_SET) < 0)\n        {\n          psd_set_error (feof (f), errno, error);\n          return NULL;\n        }\n    }\n\n  return lyr_a;\n}",
        "target": 1
    },
    {
        "func": "read_channel_data (PSDchannel     *channel,\n                   const guint16   bps,\n                   const guint16   compression,\n                   const guint16  *rle_pack_len,\n                   FILE           *f,\n                   GError        **error)\n{\n  gchar    *raw_data;\n  gchar    *src;\n  gchar    *dst;\n  guint32   readline_len;\n  gint      i;\n\n  if (bps == 1)\n    readline_len = ((channel->columns + 7) >> 3);\n  else\n    readline_len = (channel->columns * bps >> 3);\n\n  IFDBG(3) g_debug (\"raw data size %d x %d = %d\", readline_len,\n                    channel->rows, readline_len * channel->rows);\n  raw_data = g_malloc (readline_len * channel->rows);\n  switch (compression)\n    {\n      case PSD_COMP_RAW:\n        if (fread (raw_data, readline_len, channel->rows, f) < 1)\n          {\n            psd_set_error (feof (f), errno, error);\n            return -1;\n          }\n        break;\n\n      case PSD_COMP_RLE:\n        for (i = 0; i < channel->rows; ++i)\n          {\n            src = g_malloc (rle_pack_len[i]);\n            dst = g_malloc (readline_len);\n/*      FIXME check for over-run\n            if (ftell (f) + rle_pack_len[i] > block_end)\n              {\n                psd_set_error (TRUE, errno, error);\n                return -1;\n              }\n*/\n            if (fread (src, rle_pack_len[i], 1, f) < 1)\n              {\n                psd_set_error (feof (f), errno, error);\n                return -1;\n              }\n            /* FIXME check for errors returned from decode packbits */\n            decode_packbits (src, dst, rle_pack_len[i], readline_len);\n            g_free (src);\n            memcpy (raw_data + i * readline_len, dst, readline_len);\n            g_free (dst);\n          }\n        break;\n    }\n\n  /* Convert channel data to GIMP format */\n  switch (bps)\n    {\n      case 16:\n        channel->data = (gchar *) g_malloc (channel->rows * channel->columns);\n        convert_16_bit (raw_data, channel->data, (channel->rows * channel->columns) << 1);\n        break;\n\n      case 8:\n        channel->data = (gchar *) g_malloc (channel->rows * channel->columns);\n        memcpy (channel->data, raw_data, (channel->rows * channel->columns));\n        break;\n\n      case 1:\n        channel->data = (gchar *) g_malloc (channel->rows * channel->columns);\n        convert_1_bit (raw_data, channel->data, channel->rows, channel->columns);\n        break;\n    }\n\n  g_free (raw_data);\n\n  return 1;\n}",
        "target": 1
    },
    {
        "func": "add_layers (const gint32  image_id,\n            PSDimage     *img_a,\n            PSDlayer    **lyr_a,\n            FILE         *f,\n            GError      **error)\n{\n  PSDchannel          **lyr_chn;\n  guchar               *pixels;\n  guint16               alpha_chn;\n  guint16               user_mask_chn;\n  guint16               layer_channels;\n  guint16               channel_idx[MAX_CHANNELS];\n  guint16              *rle_pack_len;\n  gint32                l_x;                   /* Layer x */\n  gint32                l_y;                   /* Layer y */\n  gint32                l_w;                   /* Layer width */\n  gint32                l_h;                   /* Layer height */\n  gint32                lm_x;                  /* Layer mask x */\n  gint32                lm_y;                  /* Layer mask y */\n  gint32                lm_w;                  /* Layer mask width */\n  gint32                lm_h;                  /* Layer mask height */\n  gint32                layer_size;\n  gint32                layer_id = -1;\n  gint32                mask_id = -1;\n  gint                  lidx;                  /* Layer index */\n  gint                  cidx;                  /* Channel index */\n  gint                  rowi;                  /* Row index */\n  gint                  coli;                  /* Column index */\n  gint                  i;\n  gboolean              alpha;\n  gboolean              user_mask;\n  gboolean              empty;\n  gboolean              empty_mask;\n  GimpDrawable         *drawable;\n  GimpPixelRgn          pixel_rgn;\n  GimpImageType         image_type;\n  GimpLayerModeEffects  layer_mode;\n\n\n  IFDBG(2) g_debug (\"Number of layers: %d\", img_a->num_layers);\n\n  if (img_a->num_layers == 0)\n    {\n      IFDBG(2) g_debug (\"No layers to process\");\n      return 0;\n    }\n\n  /* Layered image - Photoshop 3 style */\n  if (fseek (f, img_a->layer_data_start, SEEK_SET) < 0)\n    {\n      psd_set_error (feof (f), errno, error);\n      return -1;\n    }\n\n  for (lidx = 0; lidx < img_a->num_layers; ++lidx)\n    {\n      IFDBG(2) g_debug (\"Process Layer No %d.\", lidx);\n\n      if (lyr_a[lidx]->drop)\n        {\n          IFDBG(2) g_debug (\"Drop layer %d\", lidx);\n\n          /* Step past layer data */\n          for (cidx = 0; cidx < lyr_a[lidx]->num_channels; ++cidx)\n            {\n              if (fseek (f, lyr_a[lidx]->chn_info[cidx].data_len, SEEK_CUR) < 0)\n                {\n                  psd_set_error (feof (f), errno, error);\n                  return -1;\n                }\n            }\n          g_free (lyr_a[lidx]->chn_info);\n          g_free (lyr_a[lidx]->name);\n        }\n\n      else\n        {\n          /* Empty layer */\n          if (lyr_a[lidx]->bottom - lyr_a[lidx]->top == 0\n              || lyr_a[lidx]->right - lyr_a[lidx]->left == 0)\n              empty = TRUE;\n          else\n              empty = FALSE;\n\n          /* Empty mask */\n          if (lyr_a[lidx]->layer_mask.bottom - lyr_a[lidx]->layer_mask.top == 0\n              || lyr_a[lidx]->layer_mask.right - lyr_a[lidx]->layer_mask.left == 0)\n              empty_mask = TRUE;\n          else\n              empty_mask = FALSE;\n\n          IFDBG(3) g_debug (\"Empty mask %d, size %d %d\", empty_mask,\n                            lyr_a[lidx]->layer_mask.bottom - lyr_a[lidx]->layer_mask.top,\n                            lyr_a[lidx]->layer_mask.right - lyr_a[lidx]->layer_mask.left);\n\n          /* Load layer channel data */\n          IFDBG(2) g_debug (\"Number of channels: %d\", lyr_a[lidx]->num_channels);\n          /* Create pointer array for the channel records */\n          lyr_chn = g_new (PSDchannel *, lyr_a[lidx]->num_channels);\n          for (cidx = 0; cidx < lyr_a[lidx]->num_channels; ++cidx)\n            {\n              guint16 comp_mode = PSD_COMP_RAW;\n\n              /* Allocate channel record */\n              lyr_chn[cidx] = g_malloc (sizeof (PSDchannel) );\n\n              lyr_chn[cidx]->id = lyr_a[lidx]->chn_info[cidx].channel_id;\n              lyr_chn[cidx]->rows = lyr_a[lidx]->bottom - lyr_a[lidx]->top;\n              lyr_chn[cidx]->columns = lyr_a[lidx]->right - lyr_a[lidx]->left;\n\n              if (lyr_chn[cidx]->id == PSD_CHANNEL_MASK)\n                {\n                  /* Works around a bug in panotools psd files where the layer mask\n                     size is given as 0 but data exists. Set mask size to layer size.\n                  */\n                  if (empty_mask && lyr_a[lidx]->chn_info[cidx].data_len - 2 > 0)\n                    {\n                      empty_mask = FALSE;\n                      if (lyr_a[lidx]->layer_mask.top == lyr_a[lidx]->layer_mask.bottom)\n                        {\n                          lyr_a[lidx]->layer_mask.top = lyr_a[lidx]->top;\n                          lyr_a[lidx]->layer_mask.bottom = lyr_a[lidx]->bottom;\n                        }\n                      if (lyr_a[lidx]->layer_mask.right == lyr_a[lidx]->layer_mask.left)\n                        {\n                          lyr_a[lidx]->layer_mask.right = lyr_a[lidx]->right;\n                          lyr_a[lidx]->layer_mask.left = lyr_a[lidx]->left;\n                        }\n                    }\n                  lyr_chn[cidx]->rows = (lyr_a[lidx]->layer_mask.bottom -\n                                        lyr_a[lidx]->layer_mask.top);\n                  lyr_chn[cidx]->columns = (lyr_a[lidx]->layer_mask.right -\n                                           lyr_a[lidx]->layer_mask.left);\n                }\n\n              IFDBG(3) g_debug (\"Channel id %d, %dx%d\",\n                                lyr_chn[cidx]->id,\n                                lyr_chn[cidx]->columns,\n                                lyr_chn[cidx]->rows);\n\n              /* Only read channel data if there is any channel\n               * data. Note that the channel data can contain a\n               * compression method but no actual data.\n               */\n              if (lyr_a[lidx]->chn_info[cidx].data_len >= COMP_MODE_SIZE)\n                {\n                  if (fread (&comp_mode, COMP_MODE_SIZE, 1, f) < 1)\n                    {\n                      psd_set_error (feof (f), errno, error);\n                      return -1;\n                    }\n                  comp_mode = GUINT16_FROM_BE (comp_mode);\n                  IFDBG(3) g_debug (\"Compression mode: %d\", comp_mode);\n                }\n              if (lyr_a[lidx]->chn_info[cidx].data_len > COMP_MODE_SIZE)\n                {\n                  switch (comp_mode)\n                    {\n                      case PSD_COMP_RAW:        /* Planar raw data */\n                        IFDBG(3) g_debug (\"Raw data length: %d\",\n                                          lyr_a[lidx]->chn_info[cidx].data_len - 2);\n                        if (read_channel_data (lyr_chn[cidx], img_a->bps,\n                            PSD_COMP_RAW, NULL, f, error) < 1)\n                          return -1;\n                        break;\n\n                      case PSD_COMP_RLE:        /* Packbits */\n                        IFDBG(3) g_debug (\"RLE channel length %d, RLE length data: %d, \"\n                                          \"RLE data block: %d\",\n                                          lyr_a[lidx]->chn_info[cidx].data_len - 2,\n                                          lyr_chn[cidx]->rows * 2,\n                                          (lyr_a[lidx]->chn_info[cidx].data_len - 2 -\n                                           lyr_chn[cidx]->rows * 2));\n                        rle_pack_len = g_malloc (lyr_chn[cidx]->rows * 2);\n                        for (rowi = 0; rowi < lyr_chn[cidx]->rows; ++rowi)\n                          {\n                            if (fread (&rle_pack_len[rowi], 2, 1, f) < 1)\n                              {\n                                psd_set_error (feof (f), errno, error);\n                                return -1;\n                              }\n                                rle_pack_len[rowi] = GUINT16_FROM_BE (rle_pack_len[rowi]);\n                          }\n\n                        IFDBG(3) g_debug (\"RLE decode - data\");\n                        if (read_channel_data (lyr_chn[cidx], img_a->bps,\n                            PSD_COMP_RLE, rle_pack_len, f, error) < 1)\n                          return -1;\n\n                        g_free (rle_pack_len);\n                        break;\n\n                      case PSD_COMP_ZIP:                 /* ? */\n                      case PSD_COMP_ZIP_PRED:\n                      default:\n                        g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                                    _(\"Unsupported compression mode: %d\"), comp_mode);\n                        return -1;\n                        break;\n                    }\n                }\n            }\n          g_free (lyr_a[lidx]->chn_info);\n\n          /* Draw layer */\n\n          alpha = FALSE;\n          alpha_chn = -1;\n          user_mask = FALSE;\n          user_mask_chn = -1;\n          layer_channels = 0;\n          l_x = 0;\n          l_y = 0;\n          l_w = img_a->columns;\n          l_h = img_a->rows;\n\n          IFDBG(3) g_debug (\"Re-hash channel indices\");\n          for (cidx = 0; cidx < lyr_a[lidx]->num_channels; ++cidx)\n            {\n              if (lyr_chn[cidx]->id == PSD_CHANNEL_MASK)\n                {\n                  user_mask = TRUE;\n                  user_mask_chn = cidx;\n                }\n              else if (lyr_chn[cidx]->id == PSD_CHANNEL_ALPHA)\n                {\n                  alpha = TRUE;\n                  alpha_chn = cidx;\n                }\n              else\n                {\n                  channel_idx[layer_channels] = cidx;   /* Assumes in sane order */\n                  layer_channels++;                     /* RGB, Lab, CMYK etc.   */\n                }\n            }\n          if (alpha)\n            {\n              channel_idx[layer_channels] = alpha_chn;\n              layer_channels++;\n            }\n\n          if (empty)\n            {\n              IFDBG(2) g_debug (\"Create blank layer\");\n              image_type = get_gimp_image_type (img_a->base_type, TRUE);\n              layer_id = gimp_layer_new (image_id, lyr_a[lidx]->name,\n                                         img_a->columns, img_a->rows,\n                                         image_type, 0, GIMP_NORMAL_MODE);\n              g_free (lyr_a[lidx]->name);\n              gimp_image_add_layer (image_id, layer_id, -1);\n              drawable = gimp_drawable_get (layer_id);\n              gimp_drawable_fill (drawable->drawable_id, GIMP_TRANSPARENT_FILL);\n              gimp_drawable_set_visible (drawable->drawable_id, lyr_a[lidx]->layer_flags.visible);\n              if (lyr_a[lidx]->id)\n                gimp_drawable_set_tattoo (drawable->drawable_id, lyr_a[lidx]->id);\n              if (lyr_a[lidx]->layer_flags.irrelevant)\n                gimp_drawable_set_visible (drawable->drawable_id, FALSE);\n              gimp_drawable_flush (drawable);\n              gimp_drawable_detach (drawable);\n            }\n          else\n            {\n              l_x = lyr_a[lidx]->left;\n              l_y = lyr_a[lidx]->top;\n              l_w = lyr_a[lidx]->right - lyr_a[lidx]->left;\n              l_h = lyr_a[lidx]->bottom - lyr_a[lidx]->top;\n\n              IFDBG(3) g_debug (\"Draw layer\");\n              image_type = get_gimp_image_type (img_a->base_type, alpha);\n              IFDBG(3) g_debug (\"Layer type %d\", image_type);\n              layer_size = l_w * l_h;\n              pixels = g_malloc (layer_size * layer_channels);\n              for (cidx = 0; cidx < layer_channels; ++cidx)\n                {\n                  IFDBG(3) g_debug (\"Start channel %d\", channel_idx[cidx]);\n                  for (i = 0; i < layer_size; ++i)\n                    pixels[(i * layer_channels) + cidx] = lyr_chn[channel_idx[cidx]]->data[i];\n                  g_free (lyr_chn[channel_idx[cidx]]->data);\n                }\n\n              layer_mode = psd_to_gimp_blend_mode (lyr_a[lidx]->blend_mode);\n              layer_id = gimp_layer_new (image_id, lyr_a[lidx]->name, l_w, l_h,\n                                         image_type, lyr_a[lidx]->opacity * 100 / 255,\n                                         layer_mode);\n              IFDBG(3) g_debug (\"Layer tattoo: %d\", layer_id);\n              g_free (lyr_a[lidx]->name);\n              gimp_image_add_layer (image_id, layer_id, -1);\n              gimp_layer_set_offsets (layer_id, l_x, l_y);\n              gimp_layer_set_lock_alpha  (layer_id, lyr_a[lidx]->layer_flags.trans_prot);\n              drawable = gimp_drawable_get (layer_id);\n              gimp_pixel_rgn_init (&pixel_rgn, drawable, 0, 0,\n                                   drawable->width, drawable->height, TRUE, FALSE);\n              gimp_pixel_rgn_set_rect (&pixel_rgn, pixels,\n                                       0, 0, drawable->width, drawable->height);\n              gimp_drawable_set_visible (drawable->drawable_id, lyr_a[lidx]->layer_flags.visible);\n              if (lyr_a[lidx]->id)\n                gimp_drawable_set_tattoo (drawable->drawable_id, lyr_a[lidx]->id);\n              gimp_drawable_flush (drawable);\n              gimp_drawable_detach (drawable);\n              g_free (pixels);\n            }\n\n          /* Layer mask */\n          if (user_mask)\n            {\n              if (empty_mask)\n                {\n                  IFDBG(3) g_debug (\"Create empty mask\");\n                  if (lyr_a[lidx]->layer_mask.def_color == 255)\n                    mask_id = gimp_layer_create_mask (layer_id, GIMP_ADD_WHITE_MASK);\n                  else\n                    mask_id = gimp_layer_create_mask (layer_id, GIMP_ADD_BLACK_MASK);\n                  gimp_layer_add_mask (layer_id, mask_id);\n                  gimp_layer_set_apply_mask (layer_id,\n                    ! lyr_a[lidx]->layer_mask.mask_flags.disabled);\n                }\n              else\n                {\n                  /* Load layer mask data */\n                  if (lyr_a[lidx]->layer_mask.mask_flags.relative_pos)\n                    {\n                      lm_x = lyr_a[lidx]->layer_mask.left;\n                      lm_y = lyr_a[lidx]->layer_mask.top;\n                      lm_w = lyr_a[lidx]->layer_mask.right - lyr_a[lidx]->layer_mask.left;\n                      lm_h = lyr_a[lidx]->layer_mask.bottom - lyr_a[lidx]->layer_mask.top;\n                    }\n                  else\n                    {\n                      lm_x = lyr_a[lidx]->layer_mask.left - l_x;\n                      lm_y = lyr_a[lidx]->layer_mask.top - l_y;\n                      lm_w = lyr_a[lidx]->layer_mask.right - lyr_a[lidx]->layer_mask.left;\n                      lm_h = lyr_a[lidx]->layer_mask.bottom - lyr_a[lidx]->layer_mask.top;\n                    }\n                  IFDBG(3) g_debug (\"Mask channel index %d\", user_mask_chn);\n                  IFDBG(3) g_debug (\"Relative pos %d\",\n                                    lyr_a[lidx]->layer_mask.mask_flags.relative_pos);\n                  layer_size = lm_w * lm_h;\n                  pixels = g_malloc (layer_size);\n                  IFDBG(3) g_debug (\"Allocate Pixels %d\", layer_size);\n                  /* Crop mask at layer boundry */\n                  IFDBG(3) g_debug (\"Original Mask %d %d %d %d\", lm_x, lm_y, lm_w, lm_h);\n                  if (lm_x < 0\n                      || lm_y < 0\n                      || lm_w + lm_x > l_w\n                      || lm_h + lm_y > l_h)\n                    {\n                      if (CONVERSION_WARNINGS)\n                        g_message (\"Warning\\n\"\n                                   \"The layer mask is partly outside the \"\n                                   \"layer boundary. The mask will be \"\n                                   \"cropped which may result in data loss.\");\n                      i = 0;\n                      for (rowi = 0; rowi < lm_h; ++rowi)\n                        {\n                          if (rowi + lm_y >= 0 && rowi + lm_y < l_h)\n                            {\n                              for (coli = 0; coli < lm_w; ++coli)\n                                {\n                                  if (coli + lm_x >= 0 && coli + lm_x < l_w)\n                                    {\n                                      pixels[i] =\n                                        lyr_chn[user_mask_chn]->data[(rowi * lm_w) + coli];\n                                      i++;\n                                    }\n                                }\n                            }\n                        }\n                      if (lm_x < 0)\n                        {\n                          lm_w += lm_x;\n                          lm_x = 0;\n                        }\n                      if (lm_y < 0)\n                        {\n                          lm_h += lm_y;\n                          lm_y = 0;\n                        }\n                      if (lm_w + lm_x > l_w)\n                        lm_w = l_w - lm_x;\n                      if (lm_h + lm_y > l_h)\n                        lm_h = l_h - lm_y;\n                    }\n                  else\n                    memcpy (pixels, lyr_chn[user_mask_chn]->data, layer_size);\n                  g_free (lyr_chn[user_mask_chn]->data);\n                  /* Draw layer mask data */\n                  IFDBG(3) g_debug (\"Layer %d %d %d %d\", l_x, l_y, l_w, l_h);\n                  IFDBG(3) g_debug (\"Mask %d %d %d %d\", lm_x, lm_y, lm_w, lm_h);\n\n                  if (lyr_a[lidx]->layer_mask.def_color == 255)\n                    mask_id = gimp_layer_create_mask (layer_id, GIMP_ADD_WHITE_MASK);\n                  else\n                    mask_id = gimp_layer_create_mask (layer_id, GIMP_ADD_BLACK_MASK);\n\n                  IFDBG(3) g_debug (\"New layer mask %d\", mask_id);\n                  gimp_layer_add_mask (layer_id, mask_id);\n                  drawable = gimp_drawable_get (mask_id);\n                  gimp_pixel_rgn_init (&pixel_rgn, drawable, 0 , 0,\n                                       drawable->width, drawable->height, TRUE, FALSE);\n                  gimp_pixel_rgn_set_rect (&pixel_rgn, pixels, lm_x, lm_y, lm_w, lm_h);\n                  gimp_drawable_flush (drawable);\n                  gimp_drawable_detach (drawable);\n                  gimp_layer_set_apply_mask (layer_id,\n                    ! lyr_a[lidx]->layer_mask.mask_flags.disabled);\n                  g_free (pixels);\n                }\n            }\n          for (cidx = 0; cidx < lyr_a[lidx]->num_channels; ++cidx)\n            if (lyr_chn[cidx])\n              g_free (lyr_chn[cidx]);\n          g_free (lyr_chn);\n        }\n      g_free (lyr_a[lidx]);\n    }\n  g_free (lyr_a);\n\n  return 0;\n}",
        "target": 1
    },
    {
        "func": "read_layer_block (PSDimage  *img_a,\n                  FILE      *f,\n                  GError   **error)\n{\n  PSDlayer **lyr_a;\n  guint32    block_len;\n  guint32    block_end;\n  guint32    block_rem;\n  gint32     read_len;\n  gint32     write_len;\n  gint       lidx;                  /* Layer index */\n  gint       cidx;                  /* Channel index */\n\n  if (fread (&block_len, 4, 1, f) < 1)\n    {\n      psd_set_error (feof (f), errno, error);\n      img_a->num_layers = -1;\n      return NULL;\n    }\n  img_a->mask_layer_len = GUINT32_FROM_BE (block_len);\n\n  IFDBG(1) g_debug (\"Layer and mask block size = %d\", img_a->mask_layer_len);\n\n  img_a->transparency = FALSE;\n  img_a->layer_data_len = 0;\n\n  if (!img_a->mask_layer_len)\n    {\n      img_a->num_layers = 0;\n      return NULL;\n    }\n  else\n    {\n      img_a->mask_layer_start = ftell (f);\n      block_end = img_a->mask_layer_start + img_a->mask_layer_len;\n\n      /* Get number of layers */\n      if (fread (&block_len, 4, 1, f) < 1\n          || fread (&img_a->num_layers, 2, 1, f) < 1)\n        {\n          psd_set_error (feof (f), errno, error);\n          img_a->num_layers = -1;\n          return NULL;\n        }\n      img_a->num_layers = GINT16_FROM_BE (img_a->num_layers);\n      IFDBG(2) g_debug (\"Number of layers: %d\", img_a->num_layers);\n\n      if (img_a->num_layers < 0)\n        {\n          img_a->transparency = TRUE;\n          img_a->num_layers = -img_a->num_layers;\n        }\n\n      if (img_a->num_layers)\n        {\n          /* Read layer records */\n          PSDlayerres           res_a;\n\n          /* Create pointer array for the layer records */\n          lyr_a = g_new (PSDlayer *, img_a->num_layers);\n          for (lidx = 0; lidx < img_a->num_layers; ++lidx)\n            {\n              /* Allocate layer record */\n              lyr_a[lidx] = (PSDlayer *) g_malloc (sizeof (PSDlayer) );\n\n              /* Initialise record */\n              lyr_a[lidx]->drop = FALSE;\n              lyr_a[lidx]->id = 0;\n\n              if (fread (&lyr_a[lidx]->top, 4, 1, f) < 1\n                  || fread (&lyr_a[lidx]->left, 4, 1, f) < 1\n                  || fread (&lyr_a[lidx]->bottom, 4, 1, f) < 1\n                  || fread (&lyr_a[lidx]->right, 4, 1, f) < 1\n                  || fread (&lyr_a[lidx]->num_channels, 2, 1, f) < 1)\n                {\n                  psd_set_error (feof (f), errno, error);\n                  return NULL;\n                }\n              lyr_a[lidx]->top = GUINT32_FROM_BE (lyr_a[lidx]->top);\n              lyr_a[lidx]->left = GUINT32_FROM_BE (lyr_a[lidx]->left);\n              lyr_a[lidx]->bottom = GUINT32_FROM_BE (lyr_a[lidx]->bottom);\n              lyr_a[lidx]->right = GUINT32_FROM_BE (lyr_a[lidx]->right);\n              lyr_a[lidx]->num_channels = GUINT16_FROM_BE (lyr_a[lidx]->num_channels);\n\n              if (lyr_a[lidx]->num_channels > MAX_CHANNELS)\n                {\n                  g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                              _(\"Too many channels in layer: %d\"),\n                              lyr_a[lidx]->num_channels);\n                  return NULL;\n                }\n              if (lyr_a[lidx]->bottom - lyr_a[lidx]->top > GIMP_MAX_IMAGE_SIZE)\n                {\n                  g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                              _(\"Unsupported or invalid layer height: %d\"),\n                              lyr_a[lidx]->bottom - lyr_a[lidx]->top);\n                  return NULL;\n                }\n              if (lyr_a[lidx]->right - lyr_a[lidx]->left > GIMP_MAX_IMAGE_SIZE)\n                {\n                  g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                              _(\"Unsupported or invalid layer width: %d\"),\n                              lyr_a[lidx]->right - lyr_a[lidx]->left);\n                  return NULL;\n                }\n\n              IFDBG(2) g_debug (\"Layer %d, Coords %d %d %d %d, channels %d, \",\n                                 lidx, lyr_a[lidx]->left, lyr_a[lidx]->top,\n                                 lyr_a[lidx]->right, lyr_a[lidx]->bottom,\n                                 lyr_a[lidx]->num_channels);\n\n              lyr_a[lidx]->chn_info = g_new (ChannelLengthInfo, lyr_a[lidx]->num_channels);\n              for (cidx = 0; cidx < lyr_a[lidx]->num_channels; ++cidx)\n                {\n                  if (fread (&lyr_a[lidx]->chn_info[cidx].channel_id, 2, 1, f) < 1\n                      || fread (&lyr_a[lidx]->chn_info[cidx].data_len, 4, 1, f) < 1)\n                    {\n                      psd_set_error (feof (f), errno, error);\n                      return NULL;\n                    }\n                  lyr_a[lidx]->chn_info[cidx].channel_id =\n                    GINT16_FROM_BE (lyr_a[lidx]->chn_info[cidx].channel_id);\n                  lyr_a[lidx]->chn_info[cidx].data_len =\n                    GUINT32_FROM_BE (lyr_a[lidx]->chn_info[cidx].data_len);\n                  img_a->layer_data_len += lyr_a[lidx]->chn_info[cidx].data_len;\n                  IFDBG(3) g_debug (\"Channel ID %d, data len %d\",\n                                     lyr_a[lidx]->chn_info[cidx].channel_id,\n                                     lyr_a[lidx]->chn_info[cidx].data_len);\n                }\n\n              if (fread (lyr_a[lidx]->mode_key, 4, 1, f) < 1\n                  || fread (lyr_a[lidx]->blend_mode, 4, 1, f) < 1\n                  || fread (&lyr_a[lidx]->opacity, 1, 1, f) < 1\n                  || fread (&lyr_a[lidx]->clipping, 1, 1, f) < 1\n                  || fread (&lyr_a[lidx]->flags, 1, 1, f) < 1\n                  || fread (&lyr_a[lidx]->filler, 1, 1, f) < 1\n                  || fread (&lyr_a[lidx]->extra_len, 4, 1, f) < 1)\n                {\n                  psd_set_error (feof (f), errno, error);\n                  return NULL;\n                }\n              if (memcmp (lyr_a[lidx]->mode_key, \"8BIM\", 4) != 0)\n                {\n                  IFDBG(1) g_debug (\"Incorrect layer mode signature %.4s\",\n                                    lyr_a[lidx]->mode_key);\n                  g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                              _(\"The file is corrupt!\"));\n                  return NULL;\n                }\n\n              lyr_a[lidx]->layer_flags.trans_prot = lyr_a[lidx]->flags & 1 ? TRUE : FALSE;\n              lyr_a[lidx]->layer_flags.visible = lyr_a[lidx]->flags & 2 ? FALSE : TRUE;\n              if (lyr_a[lidx]->flags & 8)\n                lyr_a[lidx]->layer_flags.irrelevant = lyr_a[lidx]->flags & 16 ? TRUE : FALSE;\n              else\n                lyr_a[lidx]->layer_flags.irrelevant = FALSE;\n\n              lyr_a[lidx]->extra_len = GUINT32_FROM_BE (lyr_a[lidx]->extra_len);\n              block_rem = lyr_a[lidx]->extra_len;\n              IFDBG(2) g_debug (\"\\n\\tLayer mode sig: %.4s\\n\\tBlend mode: %.4s\\n\\t\"\n                                \"Opacity: %d\\n\\tClipping: %d\\n\\tExtra data len: %d\\n\\t\"\n                                \"Alpha lock: %d\\n\\tVisible: %d\\n\\tIrrelevant: %d\",\n                                    lyr_a[lidx]->mode_key,\n                                    lyr_a[lidx]->blend_mode,\n                                    lyr_a[lidx]->opacity,\n                                    lyr_a[lidx]->clipping,\n                                    lyr_a[lidx]->extra_len,\n                                    lyr_a[lidx]->layer_flags.trans_prot,\n                                    lyr_a[lidx]->layer_flags.visible,\n                                    lyr_a[lidx]->layer_flags.irrelevant);\n              IFDBG(3) g_debug (\"Remaining length %d\", block_rem);\n\n              /* Layer mask data */\n              if (fread (&block_len, 4, 1, f) < 1)\n                {\n                  psd_set_error (feof (f), errno, error);\n                  return NULL;\n                }\n              block_len = GUINT32_FROM_BE (block_len);\n              block_rem -= (block_len + 4);\n              IFDBG(3) g_debug (\"Remaining length %d\", block_rem);\n\n              lyr_a[lidx]->layer_mask_extra.top = 0;\n              lyr_a[lidx]->layer_mask_extra.left = 0;\n              lyr_a[lidx]->layer_mask_extra.bottom = 0;\n              lyr_a[lidx]->layer_mask_extra.right = 0;\n              lyr_a[lidx]->layer_mask.top = 0;\n              lyr_a[lidx]->layer_mask.left = 0;\n              lyr_a[lidx]->layer_mask.bottom = 0;\n              lyr_a[lidx]->layer_mask.right = 0;\n              lyr_a[lidx]->layer_mask.def_color = 0;\n              lyr_a[lidx]->layer_mask.extra_def_color = 0;\n              lyr_a[lidx]->layer_mask.mask_flags.relative_pos = FALSE;\n              lyr_a[lidx]->layer_mask.mask_flags.disabled = FALSE;\n              lyr_a[lidx]->layer_mask.mask_flags.invert = FALSE;\n\n              switch (block_len)\n                {\n                  case 0:\n                    break;\n\n                  case 20:\n                    if (fread (&lyr_a[lidx]->layer_mask.top, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.left, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.bottom, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.right, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.def_color, 1, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.flags, 1, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.extra_def_color, 1, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.extra_flags, 1, 1, f) < 1)\n                      {\n                        psd_set_error (feof (f), errno, error);\n                        return NULL;\n                      }\n                    lyr_a[lidx]->layer_mask.top =\n                      GUINT32_FROM_BE (lyr_a[lidx]->layer_mask.top);\n                    lyr_a[lidx]->layer_mask.left =\n                      GUINT32_FROM_BE (lyr_a[lidx]->layer_mask.left);\n                    lyr_a[lidx]->layer_mask.bottom =\n                      GUINT32_FROM_BE (lyr_a[lidx]->layer_mask.bottom);\n                    lyr_a[lidx]->layer_mask.right =\n                      GUINT32_FROM_BE (lyr_a[lidx]->layer_mask.right);\n                    lyr_a[lidx]->layer_mask.mask_flags.relative_pos =\n                      lyr_a[lidx]->layer_mask.flags & 1 ? TRUE : FALSE;\n                    lyr_a[lidx]->layer_mask.mask_flags.disabled =\n                      lyr_a[lidx]->layer_mask.flags & 2 ? TRUE : FALSE;\n                    lyr_a[lidx]->layer_mask.mask_flags.invert =\n                      lyr_a[lidx]->layer_mask.flags & 4 ? TRUE : FALSE;\n                    break;\n                  case 36: /* If we have a 36 byte mask record assume second data set is correct */\n                    if (fread (&lyr_a[lidx]->layer_mask_extra.top, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask_extra.left, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask_extra.bottom, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask_extra.right, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.extra_def_color, 1, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.extra_flags, 1, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.def_color, 1, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.flags, 1, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.top, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.left, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.bottom, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.right, 4, 1, f) < 1)\n                      {\n                        psd_set_error (feof (f), errno, error);\n                        return NULL;\n                      }\n                    lyr_a[lidx]->layer_mask_extra.top =\n                      GUINT32_FROM_BE (lyr_a[lidx]->layer_mask_extra.top);\n                    lyr_a[lidx]->layer_mask_extra.left =\n                      GUINT32_FROM_BE (lyr_a[lidx]->layer_mask_extra.left);\n                    lyr_a[lidx]->layer_mask_extra.bottom =\n                      GUINT32_FROM_BE (lyr_a[lidx]->layer_mask_extra.bottom);\n                    lyr_a[lidx]->layer_mask_extra.right =\n                      GUINT32_FROM_BE (lyr_a[lidx]->layer_mask_extra.right);\n                    lyr_a[lidx]->layer_mask.top =\n                      GUINT32_FROM_BE (lyr_a[lidx]->layer_mask.top);\n                    lyr_a[lidx]->layer_mask.left =\n                      GUINT32_FROM_BE (lyr_a[lidx]->layer_mask.left);\n                    lyr_a[lidx]->layer_mask.bottom =\n                      GUINT32_FROM_BE (lyr_a[lidx]->layer_mask.bottom);\n                    lyr_a[lidx]->layer_mask.right =\n                      GUINT32_FROM_BE (lyr_a[lidx]->layer_mask.right);\n                    lyr_a[lidx]->layer_mask.mask_flags.relative_pos =\n                      lyr_a[lidx]->layer_mask.flags & 1 ? TRUE : FALSE;\n                    lyr_a[lidx]->layer_mask.mask_flags.disabled =\n                      lyr_a[lidx]->layer_mask.flags & 2 ? TRUE : FALSE;\n                    lyr_a[lidx]->layer_mask.mask_flags.invert =\n                      lyr_a[lidx]->layer_mask.flags & 4 ? TRUE : FALSE;\n                    break;\n\n                  default:\n                    IFDBG(1) g_debug (\"Unknown layer mask record size ... skipping\");\n                    if (fseek (f, block_len, SEEK_CUR) < 0)\n                      {\n                        psd_set_error (feof (f), errno, error);\n                        return NULL;\n                      }\n                }\n\n              IFDBG(2) g_debug (\"Layer mask coords %d %d %d %d, Rel pos %d\",\n                                lyr_a[lidx]->layer_mask.left,\n                                lyr_a[lidx]->layer_mask.top,\n                                lyr_a[lidx]->layer_mask.right,\n                                lyr_a[lidx]->layer_mask.bottom,\n                                lyr_a[lidx]->layer_mask.mask_flags.relative_pos);\n\n              IFDBG(3) g_debug (\"Default mask color, %d, %d\",\n                                lyr_a[lidx]->layer_mask.def_color,\n                                lyr_a[lidx]->layer_mask.extra_def_color);\n\n              /* Layer blending ranges */           /* FIXME  */\n              if (fread (&block_len, 4, 1, f) < 1)\n                {\n                  psd_set_error (feof (f), errno, error);\n                  return NULL;\n                }\n              block_len = GUINT32_FROM_BE (block_len);\n              block_rem -= (block_len + 4);\n              IFDBG(3) g_debug (\"Remaining length %d\", block_rem);\n              if (block_len > 0)\n                {\n                  if (fseek (f, block_len, SEEK_CUR) < 0)\n                    {\n                      psd_set_error (feof (f), errno, error);\n                      return NULL;\n                    }\n                }\n\n              lyr_a[lidx]->name = fread_pascal_string (&read_len, &write_len,\n                                                       4, f, error);\n              if (*error)\n                return NULL;\n              block_rem -= read_len;\n              IFDBG(3) g_debug (\"Remaining length %d\", block_rem);\n\n              /* Adjustment layer info */           /* FIXME */\n\n              while (block_rem > 7)\n                {\n                  if (get_layer_resource_header (&res_a, f, error) < 0)\n                    return NULL;\n                  block_rem -= 12;\n\n                  if (res_a.data_len > block_rem)\n                    {\n                      IFDBG(1) g_debug (\"Unexpected end of layer resource data\");\n                      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                                  _(\"The file is corrupt!\"));\n                      return NULL;\n                    }\n\n                  if (load_layer_resource (&res_a, lyr_a[lidx], f, error) < 0)\n                    return NULL;\n                  block_rem -= res_a.data_len;\n                }\n              if (block_rem > 0)\n                {\n                  if (fseek (f, block_rem, SEEK_CUR) < 0)\n                    {\n                      psd_set_error (feof (f), errno, error);\n                      return NULL;\n                    }\n                }\n            }\n\n          img_a->layer_data_start = ftell(f);\n          if (fseek (f, img_a->layer_data_len, SEEK_CUR) < 0)\n            {\n              psd_set_error (feof (f), errno, error);\n              return NULL;\n            }\n\n          IFDBG(1) g_debug (\"Layer image data block size %d\",\n                             img_a->layer_data_len);\n        }\n      else\n        lyr_a = NULL;\n\n      /* Read global layer mask record */       /* FIXME */\n\n      /* Skip to end of block */\n      if (fseek (f, block_end, SEEK_SET) < 0)\n        {\n          psd_set_error (feof (f), errno, error);\n          return NULL;\n        }\n    }\n\n  return lyr_a;\n}",
        "target": 1
    },
    {
        "func": "try_dlopen (lt_dlhandle *phandle, const char *filename, const char *ext,\n\t    lt_dladvise advise)\n{\n  const char *\tsaved_error\t= 0;\n  char *\tarchive_name\t= 0;\n  char *\tcanonical\t= 0;\n  char *\tbase_name\t= 0;\n  char *\tdir\t\t= 0;\n  char *\tname\t\t= 0;\n  char *        attempt\t\t= 0;\n  int\t\terrors\t\t= 0;\n  lt_dlhandle\tnewhandle;\n\n  assert (phandle);\n  assert (*phandle == 0);\n\n#ifdef LT_DEBUG_LOADERS\n  fprintf (stderr, \"try_dlopen (%s, %s)\\n\",\n\t   filename ? filename : \"(null)\",\n\t   ext ? ext : \"(null)\");\n#endif\n\n  LT__GETERROR (saved_error);\n\n  /* dlopen self? */\n  if (!filename)\n    {\n      *phandle = (lt_dlhandle) lt__zalloc (sizeof (struct lt__handle));\n      if (*phandle == 0)\n\treturn 1;\n\n      newhandle\t= *phandle;\n\n      /* lt_dlclose()ing yourself is very bad!  Disallow it.  */\n      newhandle->info.is_resident = 1;\n\n      if (tryall_dlopen (&newhandle, 0, advise, 0) != 0)\n\t{\n\t  FREE (*phandle);\n\t  return 1;\n\t}\n\n      goto register_handle;\n    }\n\n  assert (filename && *filename);\n\n  if (ext)\n    {\n      attempt = MALLOC (char, LT_STRLEN (filename) + LT_STRLEN (ext) + 1);\n      if (!attempt)\n\treturn 1;\n\n      sprintf(attempt, \"%s%s\", filename, ext);\n    }\n  else\n    {\n      attempt = lt__strdup (filename);\n      if (!attempt)\n\treturn 1;\n    }\n\n  /* Doing this immediately allows internal functions to safely\n     assume only canonicalized paths are passed.  */\n  if (canonicalize_path (attempt, &canonical) != 0)\n    {\n      ++errors;\n      goto cleanup;\n    }\n\n  /* If the canonical module name is a path (relative or absolute)\n     then split it into a directory part and a name part.  */\n  base_name = strrchr (canonical, '/');\n  if (base_name)\n    {\n      size_t dirlen = (1+ base_name) - canonical;\n\n      dir = MALLOC (char, 1+ dirlen);\n      if (!dir)\n\t{\n\t  ++errors;\n\t  goto cleanup;\n\t}\n\n      strncpy (dir, canonical, dirlen);\n      dir[dirlen] = LT_EOS_CHAR;\n\n      ++base_name;\n    }\n  else\n    MEMREASSIGN (base_name, canonical);\n\n  assert (base_name && *base_name);\n\n  ext = strrchr (base_name, '.');\n  if (!ext)\n    {\n      ext = base_name + LT_STRLEN (base_name);\n    }\n\n  /* extract the module name from the file name */\n  name = MALLOC (char, ext - base_name + 1);\n  if (!name)\n    {\n      ++errors;\n      goto cleanup;\n    }\n\n  /* canonicalize the module name */\n  {\n    int i;\n    for (i = 0; i < ext - base_name; ++i)\n      {\n\tif (isalnum ((unsigned char)(base_name[i])))\n\t  {\n\t    name[i] = base_name[i];\n\t  }\n\telse\n\t  {\n\t    name[i] = '_';\n\t  }\n      }\n    name[ext - base_name] = LT_EOS_CHAR;\n  }\n\n  /* Before trawling through the filesystem in search of a module,\n     check whether we are opening a preloaded module.  */\n  if (!dir)\n    {\n      const lt_dlvtable *vtable\t= lt_dlloader_find (\"lt_preopen\");\n\n      if (vtable)\n\t{\n\t  /* name + \".\" + libext + NULL */\n\t  archive_name = MALLOC (char, LT_STRLEN (name) + strlen (libext) + 2);\n\t  *phandle = (lt_dlhandle) lt__zalloc (sizeof (struct lt__handle));\n\n\t  if ((*phandle == NULL) || (archive_name == NULL))\n\t    {\n\t      ++errors;\n\t      goto cleanup;\n\t    }\n\t  newhandle = *phandle;\n\n\t  /* Preloaded modules are always named according to their old\n\t     archive name.  */\n\t  sprintf (archive_name, \"%s.%s\", name, libext);\n\n\t  if (tryall_dlopen (&newhandle, archive_name, advise, vtable) == 0)\n\t    {\n\t      goto register_handle;\n\t    }\n\n\t  /* If we're still here, there was no matching preloaded module,\n\t     so put things back as we found them, and continue searching.  */\n\t  FREE (*phandle);\n\t  newhandle = NULL;\n\t}\n    }\n\n  /* If we are allowing only preloaded modules, and we didn't find\n     anything yet, give up on the search here.  */\n  if (advise && advise->try_preload_only)\n    {\n      goto cleanup;\n    }\n\n  /* Check whether we are opening a libtool module (.la extension).  */\n  if (ext && streq (ext, archive_ext))\n    {\n      /* this seems to be a libtool module */\n      FILE *\tfile\t = 0;\n      char *\tdlname\t = 0;\n      char *\told_name = 0;\n      char *\tlibdir\t = 0;\n      char *\tdeplibs\t = 0;\n\n      /* if we can't find the installed flag, it is probably an\n\t installed libtool archive, produced with an old version\n\t of libtool */\n      int\tinstalled = 1;\n\n      /* Now try to open the .la file.  If there is no directory name\n\t component, try to find it first in user_search_path and then other\n\t prescribed paths.  Otherwise (or in any case if the module was not\n\t yet found) try opening just the module name as passed.  */\n      if (!dir)\n\t{\n\t  const char *search_path = user_search_path;\n\n\t  if (search_path)\n\t    file = find_file (user_search_path, base_name, &dir);\n\n\t  if (!file)\n\t    {\n\t      search_path = getenv (LTDL_SEARCHPATH_VAR);\n\t      if (search_path)\n\t\tfile = find_file (search_path, base_name, &dir);\n\t    }\n\n#if defined(LT_MODULE_PATH_VAR)\n\t  if (!file)\n\t    {\n\t      search_path = getenv (LT_MODULE_PATH_VAR);\n\t      if (search_path)\n\t\tfile = find_file (search_path, base_name, &dir);\n\t    }\n#endif\n#if defined(LT_DLSEARCH_PATH)\n\t  if (!file && *sys_dlsearch_path)\n\t    {\n\t      file = find_file (sys_dlsearch_path, base_name, &dir);\n\t    }\n#endif\n\t}\n      if (!file)\n\t{\n\t  file = fopen (attempt, LT_READTEXT_MODE);\n\t}\n\n      /* If we didn't find the file by now, it really isn't there.  Set\n\t the status flag, and bail out.  */\n      if (!file)\n\t{\n\t  LT__SETERROR (FILE_NOT_FOUND);\n\t  ++errors;\n\t  goto cleanup;\n\t}\n\n      /* read the .la file */\n      if (parse_dotla_file(file, &dlname, &libdir, &deplibs,\n\t    &old_name, &installed) != 0)\n\t++errors;\n\n      fclose (file);\n\n      /* allocate the handle */\n      *phandle = (lt_dlhandle) lt__zalloc (sizeof (struct lt__handle));\n      if (*phandle == 0)\n\t++errors;\n\n      if (errors)\n\t{\n\t  FREE (dlname);\n\t  FREE (old_name);\n\t  FREE (libdir);\n\t  FREE (deplibs);\n\t  FREE (*phandle);\n\t  goto cleanup;\n\t}\n\n      assert (*phandle);\n\n      if (load_deplibs (*phandle, deplibs) == 0)\n\t{\n\t  newhandle = *phandle;\n\t  /* find_module may replace newhandle */\n\t  if (find_module (&newhandle, dir, libdir, dlname, old_name,\n\t\t\t   installed, advise))\n\t    {\n\t      unload_deplibs (*phandle);\n\t      ++errors;\n\t    }\n\t}\n      else\n\t{\n\t  ++errors;\n\t}\n\n      FREE (dlname);\n      FREE (old_name);\n      FREE (libdir);\n      FREE (deplibs);\n\n      if (errors)\n\t{\n\t  FREE (*phandle);\n\t  goto cleanup;\n\t}\n\n      if (*phandle != newhandle)\n\t{\n\t  unload_deplibs (*phandle);\n\t}\n    }\n  else\n    {\n      /* not a libtool module */\n      *phandle = (lt_dlhandle) lt__zalloc (sizeof (struct lt__handle));\n      if (*phandle == 0)\n\t{\n\t  ++errors;\n\t  goto cleanup;\n\t}\n\n      newhandle = *phandle;\n\n      /* If the module has no directory name component, try to find it\n\t first in user_search_path and then other prescribed paths.\n\t Otherwise (or in any case if the module was not yet found) try\n\t opening just the module name as passed.  */\n      if ((dir || (!find_handle (user_search_path, base_name,\n\t\t\t\t &newhandle, advise)\n\t\t   && !find_handle (getenv (LTDL_SEARCHPATH_VAR), base_name,\n\t\t\t\t    &newhandle, advise)\n#if defined(LT_MODULE_PATH_VAR)\n\t\t   && !find_handle (getenv (LT_MODULE_PATH_VAR), base_name,\n\t\t\t\t    &newhandle, advise)\n#endif\n#if defined(LT_DLSEARCH_PATH)\n\t\t   && !find_handle (sys_dlsearch_path, base_name,\n\t\t\t\t    &newhandle, advise)\n#endif\n\t\t   )))\n\t{\n\t  if (tryall_dlopen (&newhandle, attempt, advise, 0) != 0)\n\t    {\n\t      newhandle = NULL;\n\t    }\n\t}\n\n      if (!newhandle)\n\t{\n\t  FREE (*phandle);\n\t  ++errors;\n\t  goto cleanup;\n\t}\n    }\n\n register_handle:\n  MEMREASSIGN (*phandle, newhandle);\n\n  if ((*phandle)->info.ref_count == 0)\n    {\n      (*phandle)->info.ref_count\t= 1;\n      MEMREASSIGN ((*phandle)->info.name, name);\n\n      (*phandle)->next\t= handles;\n      handles\t\t= *phandle;\n    }\n\n  LT__SETERRORSTR (saved_error);\n\n cleanup:\n  FREE (dir);\n  FREE (attempt);\n  FREE (name);\n  if (!canonical)\t\t/* was MEMREASSIGNed */\n    FREE (base_name);\n  FREE (canonical);\n  FREE (archive_name);\n\n  return errors;\n}",
        "target": 1
    },
    {
        "func": "find_module (lt_dlhandle *handle, const char *dir, const char *libdir,\n\t     const char *dlname,  const char *old_name, int installed,\n\t     lt_dladvise advise)\n{\n  /* Try to open the old library first; if it was dlpreopened,\n     we want the preopened version of it, even if a dlopenable\n     module is available.  */\n  if (old_name && tryall_dlopen (handle, old_name, advise, 0) == 0)\n    {\n      return 0;\n    }\n\n  /* Try to open the dynamic library.  */\n  if (dlname)\n    {\n      /* try to open the installed module */\n      if (installed && libdir)\n\t{\n\t  if (tryall_dlopen_module (handle, (const char *) 0,\n\t\t\t\t    libdir, dlname, advise) == 0)\n\t    return 0;\n\t}\n\n      /* try to open the not-installed module */\n      if (!installed)\n\t{\n\t  if (tryall_dlopen_module (handle, dir, objdir,\n\t\t\t\t    dlname, advise) == 0)\n\t    return 0;\n\t}\n\n      /* maybe it was moved to another directory */\n      {\n\t  if (dir && (tryall_dlopen_module (handle, (const char *) 0,\n\t\t\t\t\t    dir, dlname, advise) == 0))\n\t    return 0;\n      }\n    }\n\n  return 1;\n}",
        "target": 1
    },
    {
        "func": "x86_decode_insn(struct x86_emulate_ctxt *ctxt, struct x86_emulate_ops *ops)\n{\n\tstruct decode_cache *c = &ctxt->decode;\n\tint rc = 0;\n\tint mode = ctxt->mode;\n\tint def_op_bytes, def_ad_bytes, group;\n\n\t/* Shadow copy of register state. Committed on successful emulation. */\n\n\tmemset(c, 0, sizeof(struct decode_cache));\n\tc->eip = kvm_rip_read(ctxt->vcpu);\n\tctxt->cs_base = seg_base(ctxt, VCPU_SREG_CS);\n\tmemcpy(c->regs, ctxt->vcpu->arch.regs, sizeof c->regs);\n\n\tswitch (mode) {\n\tcase X86EMUL_MODE_REAL:\n\tcase X86EMUL_MODE_PROT16:\n\t\tdef_op_bytes = def_ad_bytes = 2;\n\t\tbreak;\n\tcase X86EMUL_MODE_PROT32:\n\t\tdef_op_bytes = def_ad_bytes = 4;\n\t\tbreak;\n#ifdef CONFIG_X86_64\n\tcase X86EMUL_MODE_PROT64:\n\t\tdef_op_bytes = 4;\n\t\tdef_ad_bytes = 8;\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn -1;\n\t}\n\n\tc->op_bytes = def_op_bytes;\n\tc->ad_bytes = def_ad_bytes;\n\n\t/* Legacy prefixes. */\n\tfor (;;) {\n\t\tswitch (c->b = insn_fetch(u8, 1, c->eip)) {\n\t\tcase 0x66:\t/* operand-size override */\n\t\t\t/* switch between 2/4 bytes */\n\t\t\tc->op_bytes = def_op_bytes ^ 6;\n\t\t\tbreak;\n\t\tcase 0x67:\t/* address-size override */\n\t\t\tif (mode == X86EMUL_MODE_PROT64)\n\t\t\t\t/* switch between 4/8 bytes */\n\t\t\t\tc->ad_bytes = def_ad_bytes ^ 12;\n\t\t\telse\n\t\t\t\t/* switch between 2/4 bytes */\n\t\t\t\tc->ad_bytes = def_ad_bytes ^ 6;\n\t\t\tbreak;\n\t\tcase 0x26:\t/* ES override */\n\t\tcase 0x2e:\t/* CS override */\n\t\tcase 0x36:\t/* SS override */\n\t\tcase 0x3e:\t/* DS override */\n\t\t\tset_seg_override(c, (c->b >> 3) & 3);\n\t\t\tbreak;\n\t\tcase 0x64:\t/* FS override */\n\t\tcase 0x65:\t/* GS override */\n\t\t\tset_seg_override(c, c->b & 7);\n\t\t\tbreak;\n\t\tcase 0x40 ... 0x4f: /* REX */\n\t\t\tif (mode != X86EMUL_MODE_PROT64)\n\t\t\t\tgoto done_prefixes;\n\t\t\tc->rex_prefix = c->b;\n\t\t\tcontinue;\n\t\tcase 0xf0:\t/* LOCK */\n\t\t\tc->lock_prefix = 1;\n\t\t\tbreak;\n\t\tcase 0xf2:\t/* REPNE/REPNZ */\n\t\t\tc->rep_prefix = REPNE_PREFIX;\n\t\t\tbreak;\n\t\tcase 0xf3:\t/* REP/REPE/REPZ */\n\t\t\tc->rep_prefix = REPE_PREFIX;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto done_prefixes;\n\t\t}\n\n\t\t/* Any legacy prefix after a REX prefix nullifies its effect. */\n\n\t\tc->rex_prefix = 0;\n\t}\n\ndone_prefixes:\n\n\t/* REX prefix. */\n\tif (c->rex_prefix)\n\t\tif (c->rex_prefix & 8)\n\t\t\tc->op_bytes = 8;\t/* REX.W */\n\n\t/* Opcode byte(s). */\n\tc->d = opcode_table[c->b];\n\tif (c->d == 0) {\n\t\t/* Two-byte opcode? */\n\t\tif (c->b == 0x0f) {\n\t\t\tc->twobyte = 1;\n\t\t\tc->b = insn_fetch(u8, 1, c->eip);\n\t\t\tc->d = twobyte_table[c->b];\n\t\t}\n\t}\n\n\tif (mode == X86EMUL_MODE_PROT64 && (c->d & No64)) {\n\t\tkvm_report_emulation_failure(ctxt->vcpu, \"invalid x86/64 instruction\");;\n\t\treturn -1;\n\t}\n\n\tif (c->d & Group) {\n\t\tgroup = c->d & GroupMask;\n\t\tc->modrm = insn_fetch(u8, 1, c->eip);\n\t\t--c->eip;\n\n\t\tgroup = (group << 3) + ((c->modrm >> 3) & 7);\n\t\tif ((c->d & GroupDual) && (c->modrm >> 6) == 3)\n\t\t\tc->d = group2_table[group];\n\t\telse\n\t\t\tc->d = group_table[group];\n\t}\n\n\t/* Unrecognised? */\n\tif (c->d == 0) {\n\t\tDPRINTF(\"Cannot emulate %02x\\n\", c->b);\n\t\treturn -1;\n\t}\n\n\tif (mode == X86EMUL_MODE_PROT64 && (c->d & Stack))\n\t\tc->op_bytes = 8;\n\n\t/* ModRM and SIB bytes. */\n\tif (c->d & ModRM)\n\t\trc = decode_modrm(ctxt, ops);\n\telse if (c->d & MemAbs)\n\t\trc = decode_abs(ctxt, ops);\n\tif (rc)\n\t\tgoto done;\n\n\tif (!c->has_seg_override)\n\t\tset_seg_override(c, VCPU_SREG_DS);\n\n\tif (!(!c->twobyte && c->b == 0x8d))\n\t\tc->modrm_ea += seg_override_base(ctxt, c);\n\n\tif (c->ad_bytes != 8)\n\t\tc->modrm_ea = (u32)c->modrm_ea;\n\t/*\n\t * Decode and fetch the source operand: register, memory\n\t * or immediate.\n\t */\n\tswitch (c->d & SrcMask) {\n\tcase SrcNone:\n\t\tbreak;\n\tcase SrcReg:\n\t\tdecode_register_operand(&c->src, c, 0);\n\t\tbreak;\n\tcase SrcMem16:\n\t\tc->src.bytes = 2;\n\t\tgoto srcmem_common;\n\tcase SrcMem32:\n\t\tc->src.bytes = 4;\n\t\tgoto srcmem_common;\n\tcase SrcMem:\n\t\tc->src.bytes = (c->d & ByteOp) ? 1 :\n\t\t\t\t\t\t\t   c->op_bytes;\n\t\t/* Don't fetch the address for invlpg: it could be unmapped. */\n\t\tif (c->twobyte && c->b == 0x01 && c->modrm_reg == 7)\n\t\t\tbreak;\n\tsrcmem_common:\n\t\t/*\n\t\t * For instructions with a ModR/M byte, switch to register\n\t\t * access if Mod = 3.\n\t\t */\n\t\tif ((c->d & ModRM) && c->modrm_mod == 3) {\n\t\t\tc->src.type = OP_REG;\n\t\t\tc->src.val = c->modrm_val;\n\t\t\tc->src.ptr = c->modrm_ptr;\n\t\t\tbreak;\n\t\t}\n\t\tc->src.type = OP_MEM;\n\t\tbreak;\n\tcase SrcImm:\n\tcase SrcImmU:\n\t\tc->src.type = OP_IMM;\n\t\tc->src.ptr = (unsigned long *)c->eip;\n\t\tc->src.bytes = (c->d & ByteOp) ? 1 : c->op_bytes;\n\t\tif (c->src.bytes == 8)\n\t\t\tc->src.bytes = 4;\n\t\t/* NB. Immediates are sign-extended as necessary. */\n\t\tswitch (c->src.bytes) {\n\t\tcase 1:\n\t\t\tc->src.val = insn_fetch(s8, 1, c->eip);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tc->src.val = insn_fetch(s16, 2, c->eip);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tc->src.val = insn_fetch(s32, 4, c->eip);\n\t\t\tbreak;\n\t\t}\n\t\tif ((c->d & SrcMask) == SrcImmU) {\n\t\t\tswitch (c->src.bytes) {\n\t\t\tcase 1:\n\t\t\t\tc->src.val &= 0xff;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tc->src.val &= 0xffff;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tc->src.val &= 0xffffffff;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase SrcImmByte:\n\tcase SrcImmUByte:\n\t\tc->src.type = OP_IMM;\n\t\tc->src.ptr = (unsigned long *)c->eip;\n\t\tc->src.bytes = 1;\n\t\tif ((c->d & SrcMask) == SrcImmByte)\n\t\t\tc->src.val = insn_fetch(s8, 1, c->eip);\n\t\telse\n\t\t\tc->src.val = insn_fetch(u8, 1, c->eip);\n\t\tbreak;\n\tcase SrcOne:\n\t\tc->src.bytes = 1;\n\t\tc->src.val = 1;\n\t\tbreak;\n\t}\n\n\t/*\n\t * Decode and fetch the second source operand: register, memory\n\t * or immediate.\n\t */\n\tswitch (c->d & Src2Mask) {\n\tcase Src2None:\n\t\tbreak;\n\tcase Src2CL:\n\t\tc->src2.bytes = 1;\n\t\tc->src2.val = c->regs[VCPU_REGS_RCX] & 0x8;\n\t\tbreak;\n\tcase Src2ImmByte:\n\t\tc->src2.type = OP_IMM;\n\t\tc->src2.ptr = (unsigned long *)c->eip;\n\t\tc->src2.bytes = 1;\n\t\tc->src2.val = insn_fetch(u8, 1, c->eip);\n\t\tbreak;\n\tcase Src2Imm16:\n\t\tc->src2.type = OP_IMM;\n\t\tc->src2.ptr = (unsigned long *)c->eip;\n\t\tc->src2.bytes = 2;\n\t\tc->src2.val = insn_fetch(u16, 2, c->eip);\n\t\tbreak;\n\tcase Src2One:\n\t\tc->src2.bytes = 1;\n\t\tc->src2.val = 1;\n\t\tbreak;\n\t}\n\n\t/* Decode and fetch the destination operand: register or memory. */\n\tswitch (c->d & DstMask) {\n\tcase ImplicitOps:\n\t\t/* Special instructions do their own operand decoding. */\n\t\treturn 0;\n\tcase DstReg:\n\t\tdecode_register_operand(&c->dst, c,\n\t\t\t c->twobyte && (c->b == 0xb6 || c->b == 0xb7));\n\t\tbreak;\n\tcase DstMem:\n\t\tif ((c->d & ModRM) && c->modrm_mod == 3) {\n\t\t\tc->dst.bytes = (c->d & ByteOp) ? 1 : c->op_bytes;\n\t\t\tc->dst.type = OP_REG;\n\t\t\tc->dst.val = c->dst.orig_val = c->modrm_val;\n\t\t\tc->dst.ptr = c->modrm_ptr;\n\t\t\tbreak;\n\t\t}\n\t\tc->dst.type = OP_MEM;\n\t\tbreak;\n\tcase DstAcc:\n\t\tc->dst.type = OP_REG;\n\t\tc->dst.bytes = c->op_bytes;\n\t\tc->dst.ptr = &c->regs[VCPU_REGS_RAX];\n\t\tswitch (c->op_bytes) {\n\t\t\tcase 1:\n\t\t\t\tc->dst.val = *(u8 *)c->dst.ptr;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tc->dst.val = *(u16 *)c->dst.ptr;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tc->dst.val = *(u32 *)c->dst.ptr;\n\t\t\t\tbreak;\n\t\t}\n\t\tc->dst.orig_val = c->dst.val;\n\t\tbreak;\n\t}\n\n\tif (c->rip_relative)\n\t\tc->modrm_ea += c->eip;\n\ndone:\n\treturn (rc == X86EMUL_UNHANDLEABLE) ? -1 : 0;\n}",
        "target": 1
    },
    {
        "func": "static int do_insn_fetch(struct x86_emulate_ctxt *ctxt,\n\t\t\t struct x86_emulate_ops *ops,\n\t\t\t unsigned long eip, void *dest, unsigned size)\n{\n\tint rc = 0;\n\n\teip += ctxt->cs_base;\n\twhile (size--) {\n\t\trc = do_fetch_insn_byte(ctxt, ops, eip++, dest++);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "nma_gconf_settings_new (void)\n{\n\treturn (NMAGConfSettings *) g_object_new (NMA_TYPE_GCONF_SETTINGS, NULL);\n}",
        "target": 1
    },
    {
        "func": "nm_connection_list_new (GType def_type)\n{\n\tNMConnectionList *list;\n\tDBusGConnection *dbus_connection;\n\tGError *error = NULL;\n\n\tlist = g_object_new (NM_TYPE_CONNECTION_LIST, NULL);\n\tif (!list)\n\t\treturn NULL;\n\n\t/* load GUI */\n\tlist->gui = glade_xml_new (GLADEDIR \"/nm-connection-editor.glade\", \"NMConnectionList\", NULL);\n\tif (!list->gui) {\n\t\tg_warning (\"Could not load Glade file for connection list\");\n\t\tgoto error;\n\t}\n\n\tgtk_window_set_default_icon_name (\"preferences-system-network\");\n\n\tlist->icon_theme = gtk_icon_theme_get_for_screen (gdk_screen_get_default ());\n\n\t/* Load icons */\n\tICON_LOAD(list->wired_icon, \"nm-device-wired\");\n\tICON_LOAD(list->wireless_icon, \"nm-device-wireless\");\n\tICON_LOAD(list->wwan_icon, \"nm-device-wwan\");\n\tICON_LOAD(list->vpn_icon, \"nm-vpn-standalone-lock\");\n\tICON_LOAD(list->unknown_icon, \"nm-no-connection\");\n\n\tlist->client = gconf_client_get_default ();\n\tif (!list->client)\n\t\tgoto error;\n\n\tdbus_connection = dbus_g_bus_get (DBUS_BUS_SYSTEM, &error);\n\tif (error) {\n\t\tg_warning (\"Could not connect to the system bus: %s\", error->message);\n\t\tg_error_free (error);\n\t\tgoto error;\n\t}\n\n\tlist->system_settings = nm_dbus_settings_system_new (dbus_connection);\n\tdbus_g_connection_unref (dbus_connection);\n\tg_signal_connect (list->system_settings, \"new-connection\",\n\t\t\t\t   G_CALLBACK (connection_added),\n\t\t\t\t   list);\n\n\tlist->gconf_settings = nma_gconf_settings_new ();\n\tg_signal_connect (list->gconf_settings, \"new-connection\",\n\t\t\t\t   G_CALLBACK (connection_added),\n\t\t\t\t   list);\n\n\tadd_connection_tabs (list, def_type);\n\n\tlist->editors = g_hash_table_new_full (g_direct_hash, g_direct_equal, g_object_unref, g_object_unref);\n\n\tlist->dialog = glade_xml_get_widget (list->gui, \"NMConnectionList\");\n\tif (!list->dialog)\n\t\tgoto error;\n\tg_signal_connect (G_OBJECT (list->dialog), \"response\", G_CALLBACK (dialog_response_cb), list);\n\n\tif (!vpn_get_plugins (&error)) {\n\t\tg_warning (\"%s: failed to load VPN plugins: %s\", __func__, error->message);\n\t\tg_error_free (error);\n\t}\n\n\treturn list;\n\nerror:\n\tg_object_unref (list);\n\treturn NULL;\n}",
        "target": 1
    },
    {
        "func": "add_connection_real (NMAGConfSettings *self, NMAGConfConnection *connection)\n{\n\tNMAGConfSettingsPrivate *priv = NMA_GCONF_SETTINGS_GET_PRIVATE (self);\n\n\tif (connection) {\n\t\tpriv->connections = g_slist_prepend (priv->connections, connection);\n\t\tg_signal_connect (connection, \"new-secrets-requested\",\n\t\t\t\t\t   G_CALLBACK (connection_new_secrets_requested_cb),\n\t\t\t\t\t   self);\n\n\t\tg_signal_connect (connection, \"removed\", G_CALLBACK (connection_removed), self);\n\t\tnm_settings_signal_new_connection (NM_SETTINGS (self),\n\t\t\t\t\t\t\t\t\tNM_EXPORTED_CONNECTION (connection));\n\t}\n}",
        "target": 1
    },
    {
        "func": "constructor (GType type,\n             guint n_props,\n             GObjectConstructParam *construct_props)\n{\n\tNMApplet *applet;\n\tAppletDBusManager *dbus_mgr;\n\tGList *server_caps, *iter;\n\n\tapplet = NM_APPLET (G_OBJECT_CLASS (nma_parent_class)->constructor (type, n_props, construct_props));\n\n\tg_set_application_name (_(\"NetworkManager Applet\"));\n\tgtk_window_set_default_icon_name (GTK_STOCK_NETWORK);\n\n\tapplet->glade_file = g_build_filename (GLADEDIR, \"applet.glade\", NULL);\n\tif (!applet->glade_file || !g_file_test (applet->glade_file, G_FILE_TEST_IS_REGULAR)) {\n\t\tGtkWidget *dialog;\n\t\tdialog = applet_warning_dialog_show (_(\"The NetworkManager Applet could not find some required resources (the glade file was not found).\"));\n\t\tgtk_dialog_run (GTK_DIALOG (dialog));\n\t\tgoto error;\n\t}\n\n\tapplet->info_dialog_xml = glade_xml_new (applet->glade_file, \"info_dialog\", NULL);\n\tif (!applet->info_dialog_xml)\n\t\tgoto error;\n\n\tapplet->gconf_client = gconf_client_get_default ();\n\tif (!applet->gconf_client)\n\t\tgoto error;\n\n\t/* Load pixmaps and create applet widgets */\n\tif (!setup_widgets (applet))\n\t\tgoto error;\n\tnma_icons_init (applet);\n\n\tif (!notify_is_initted ())\n\t\tnotify_init (\"NetworkManager\");\n\n\tserver_caps = notify_get_server_caps();\n\tapplet->notify_with_actions = FALSE;\n\tfor (iter = server_caps; iter; iter = g_list_next (iter)) {\n\t\tif (!strcmp ((const char *) iter->data, NOTIFY_CAPS_ACTIONS_KEY))\n\t\t\tapplet->notify_with_actions = TRUE;\n\t}\n\n\tg_list_foreach (server_caps, (GFunc) g_free, NULL);\n\tg_list_free (server_caps);\n\n\tdbus_mgr = applet_dbus_manager_get ();\n\tif (dbus_mgr == NULL) {\n\t\tnm_warning (\"Couldn't initialize the D-Bus manager.\");\n\t\tg_object_unref (applet);\n\t\treturn NULL;\n\t}\n\tg_signal_connect (G_OBJECT (dbus_mgr), \"exit-now\", G_CALLBACK (exit_cb), applet);\n\n\tapplet->dbus_settings = (NMDBusSettings *) nm_dbus_settings_system_new (applet_dbus_manager_get_connection (dbus_mgr));\n\n\tapplet->gconf_settings = nma_gconf_settings_new ();\n\tg_signal_connect (applet->gconf_settings, \"new-secrets-requested\",\n\t                  G_CALLBACK (applet_settings_new_secrets_requested_cb),\n\t                  applet);\n\n\tdbus_g_connection_register_g_object (applet_dbus_manager_get_connection (dbus_mgr),\n\t                                     NM_DBUS_PATH_SETTINGS,\n\t                                     G_OBJECT (applet->gconf_settings));\n\n\t/* Start our DBus service */\n\tif (!applet_dbus_manager_start_service (dbus_mgr)) {\n\t\tg_object_unref (applet);\n\t\treturn NULL;\n\t}\n\n\t/* Initialize device classes */\n\tapplet->wired_class = applet_device_wired_get_class (applet);\n\tg_assert (applet->wired_class);\n\n\tapplet->wifi_class = applet_device_wifi_get_class (applet);\n\tg_assert (applet->wifi_class);\n\n\tapplet->gsm_class = applet_device_gsm_get_class (applet);\n\tg_assert (applet->gsm_class);\n\n\tapplet->cdma_class = applet_device_cdma_get_class (applet);\n\tg_assert (applet->cdma_class);\n\n\tfoo_client_setup (applet);\n\n\t/* timeout to update connection timestamps every 5 minutes */\n\tapplet->update_timestamps_id = g_timeout_add_seconds (300,\n\t\t\t(GSourceFunc) periodic_update_active_connection_timestamps, applet);\n\n\tnm_gconf_set_pre_keyring_callback (applet_pre_keyring_callback, applet);\n\n\treturn G_OBJECT (applet);\n\nerror:\n\tg_object_unref (applet);\n\treturn NULL;\n}",
        "target": 1
    },
    {
        "func": "connection_changes_done (gpointer data)\n{\n\tConnectionChangedInfo *info = (ConnectionChangedInfo *) data;\n\tNMAGConfSettingsPrivate *priv = NMA_GCONF_SETTINGS_GET_PRIVATE (info->settings);\n\tNMAGConfConnection *connection;\n\n\tconnection = nma_gconf_settings_get_by_path (info->settings, info->path);\n\tif (!connection) {\n\t\t/* New connection */\n\t\tconnection = nma_gconf_connection_new (priv->client, info->path);\n\t\tadd_connection_real (info->settings, connection);\n\t} else {\n\t\tif (gconf_client_dir_exists (priv->client, info->path, NULL)) {\n\t\t\t/* Updated connection */\n\t\t\tif (!nma_gconf_connection_changed (connection))\n\t\t\t\tpriv->connections = g_slist_remove (priv->connections, connection);\n\t\t}\n\t}\n\n\tg_hash_table_remove (priv->pending_changes, info->path);\n\n\treturn FALSE;\n}",
        "target": 1
    },
    {
        "func": "constructor (GType type,\n\t\t   guint n_construct_params,\n\t\t   GObjectConstructParam *construct_params)\n{\n\tGObject *object;\n\tNMAGConfConnectionPrivate *priv;\n\tNMConnection *connection;\n\tDBusGConnection *bus;\n\tGError *error = NULL;\n\n\tobject = G_OBJECT_CLASS (nma_gconf_connection_parent_class)->constructor (type, n_construct_params, construct_params);\n\n\tif (!object)\n\t\treturn NULL;\n\n\tpriv = NMA_GCONF_CONNECTION_GET_PRIVATE (object);\n\n\tif (!priv->client) {\n\t\tnm_warning (\"GConfClient not provided.\");\n\t\tgoto err;\n\t}\n\n\tif (!priv->dir) {\n\t\tnm_warning (\"GConf directory not provided.\");\n\t\tgoto err;\n\t}\n\n\tconnection = nm_exported_connection_get_connection (NM_EXPORTED_CONNECTION (object));\n\n\tutils_fill_connection_certs (connection);\n\tif (!nm_connection_verify (connection, &error)) {\n\t\tutils_clear_filled_connection_certs (connection);\n\t\tg_warning (\"Invalid connection: '%s' / '%s' invalid: %d\",\n\t\t           g_type_name (nm_connection_lookup_setting_type_by_quark (error->domain)),\n\t\t           error->message, error->code);\n\t\tg_error_free (error);\n\t\tgoto err;\n\t}\n\tutils_clear_filled_connection_certs (connection);\n\n\tfill_vpn_user_name (connection);\n\n\tbus = dbus_g_bus_get (DBUS_BUS_SYSTEM, &error);\n\tif (!bus) {\n\t\tnm_warning (\"Could not get the system bus: %s\", error->message);\n\t\tg_error_free (error);\n\t\tgoto err;\n\t}\n\n\tnm_exported_connection_register_object (NM_EXPORTED_CONNECTION (object),\n\t                                        NM_CONNECTION_SCOPE_USER,\n\t                                        bus);\n\tdbus_g_connection_unref (bus);\n\n\treturn object;\n\n err:\n\tg_object_unref (object);\n\n\treturn NULL;\n}",
        "target": 1
    },
    {
        "func": "read_connections (NMAGConfSettings *settings)\n{\n\tNMAGConfSettingsPrivate *priv = NMA_GCONF_SETTINGS_GET_PRIVATE (settings);\n\tGSList *dir_list;\n\tGSList *iter;\n\n\tdir_list = nm_gconf_get_all_connections (priv->client);\n\tif (!dir_list)\n\t\treturn;\n\n\tfor (iter = dir_list; iter; iter = iter->next) {\n\t\tchar *dir = (char *) iter->data;\n\n\t\tadd_connection_real (settings, nma_gconf_connection_new (priv->client, dir));\n\t\tg_free (dir);\n\t}\n\n\tg_slist_free (dir_list);\n\tpriv->connections = g_slist_reverse (priv->connections);\n}",
        "target": 1
    },
    {
        "func": "dispose (GObject *object)\n{\n\tNMAGConfSettingsPrivate *priv = NMA_GCONF_SETTINGS_GET_PRIVATE (object);\n\n\tif (priv->disposed)\n\t\treturn;\n\n\tpriv->disposed = TRUE;\n\n\tg_hash_table_destroy (priv->pending_changes);\n\n\tif (priv->read_connections_id) {\n\t\tg_source_remove (priv->read_connections_id);\n\t\tpriv->read_connections_id = 0;\n\t}\n\n\tgconf_client_notify_remove (priv->client, priv->conf_notify_id);\n\tgconf_client_remove_dir (priv->client, GCONF_PATH_CONNECTIONS, NULL);\n\n\tg_slist_foreach (priv->connections, (GFunc) g_object_unref, NULL);\n\tg_slist_free (priv->connections);\n\n\tg_object_unref (priv->client);\n\n\tG_OBJECT_CLASS (nma_gconf_settings_parent_class)->dispose (object);\n}",
        "target": 1
    },
    {
        "func": "add_connection_real (NMAGConfSettings *self, NMAGConfConnection *connection)\n{\n\tNMAGConfSettingsPrivate *priv = NMA_GCONF_SETTINGS_GET_PRIVATE (self);\n\n\tg_return_if_fail (connection != NULL);\n\n\tpriv->connections = g_slist_prepend (priv->connections, connection);\n\tg_signal_connect (connection, \"new-secrets-requested\",\n\t\t\t\t   G_CALLBACK (connection_new_secrets_requested_cb),\n\t\t\t\t   self);\n\n\tg_signal_connect (connection, \"removed\", G_CALLBACK (connection_removed), self);\n\n\t/* Export the connection over dbus if requested */\n\tif (priv->bus) {\n\t\tnm_exported_connection_register_object (NM_EXPORTED_CONNECTION (connection),\n\t\t                                        NM_CONNECTION_SCOPE_USER,\n\t\t                                        priv->bus);\n\t\tdbus_g_connection_unref (priv->bus);\n\t}\n\n\tnm_settings_signal_new_connection (NM_SETTINGS (self), NM_EXPORTED_CONNECTION (connection));\n}",
        "target": 1
    },
    {
        "func": "nma_gconf_connection_new (GConfClient *client, const char *conf_dir)\n{\n\tNMConnection *connection;\n\tNMAGConfConnection *gconf_connection;\n\n\tg_return_val_if_fail (GCONF_IS_CLIENT (client), NULL);\n\tg_return_val_if_fail (conf_dir != NULL, NULL);\n\n\t/* retrieve GConf data */\n\tconnection = nm_gconf_read_connection (client, conf_dir);\n\tif (connection) {\n\t\tgconf_connection = nma_gconf_connection_new_from_connection (client, conf_dir, connection);\n\t\tg_object_unref (connection);\n\t} else {\n\t\tnm_warning (\"No connection read from GConf at %s.\", conf_dir);\n\t\tgconf_connection = NULL;\n\t}\n\t\n\treturn gconf_connection;\n}",
        "target": 1
    },
    {
        "func": "nma_gconf_connection_changed (NMAGConfConnection *self)\n{\n\tNMAGConfConnectionPrivate *priv;\n\tGHashTable *settings;\n\tNMConnection *wrapped_connection;\n\tNMConnection *gconf_connection;\n\tGHashTable *new_settings;\n\tGError *error = NULL;\n\n\tg_return_val_if_fail (NMA_IS_GCONF_CONNECTION (self), FALSE);\n\n\tpriv = NMA_GCONF_CONNECTION_GET_PRIVATE (self);\n\twrapped_connection = nm_exported_connection_get_connection (NM_EXPORTED_CONNECTION (self));\n\n\tgconf_connection = nm_gconf_read_connection (priv->client, priv->dir);\n\tif (!gconf_connection) {\n\t\tg_warning (\"No connection read from GConf at %s.\", priv->dir);\n\t\tgoto invalid;\n\t}\n\n\tutils_fill_connection_certs (gconf_connection);\n\tif (!nm_connection_verify (gconf_connection, &error)) {\n\t\tutils_clear_filled_connection_certs (gconf_connection);\n\t\tg_warning (\"%s: Invalid connection %s: '%s' / '%s' invalid: %d\",\n\t\t           __func__, priv->dir,\n\t\t           g_type_name (nm_connection_lookup_setting_type_by_quark (error->domain)),\n\t\t           error->message, error->code);\n\t\tgoto invalid;\n\t}\n\tutils_clear_filled_connection_certs (gconf_connection);\n\n\t/* Ignore the GConf update if nothing changed */\n\tif (   nm_connection_compare (wrapped_connection, gconf_connection, NM_SETTING_COMPARE_FLAG_EXACT)\n\t    && nm_gconf_compare_private_connection_values (wrapped_connection, gconf_connection))\n\t\treturn TRUE;\n\n\t/* Update private values to catch any certificate path changes */\n\tnm_gconf_copy_private_connection_values (wrapped_connection, gconf_connection);\n\n\tutils_fill_connection_certs (gconf_connection);\n\tnew_settings = nm_connection_to_hash (gconf_connection);\n\tutils_clear_filled_connection_certs (gconf_connection);\n\n\tif (!nm_connection_replace_settings (wrapped_connection, new_settings, &error)) {\n\t\tutils_clear_filled_connection_certs (wrapped_connection);\n\t\tg_hash_table_destroy (new_settings);\n\n\t\tg_warning (\"%s: '%s' / '%s' invalid: %d\",\n\t\t           __func__,\n\t\t           error ? g_type_name (nm_connection_lookup_setting_type_by_quark (error->domain)) : \"(none)\",\n\t\t           (error && error->message) ? error->message : \"(none)\",\n\t\t           error ? error->code : -1);\n\t\tgoto invalid;\n\t}\n\tg_object_unref (gconf_connection);\n\tg_hash_table_destroy (new_settings);\n\n\tfill_vpn_user_name (wrapped_connection);\n\n\tsettings = nm_connection_to_hash (wrapped_connection);\n\tutils_clear_filled_connection_certs (wrapped_connection);\n\n\tnm_exported_connection_signal_updated (NM_EXPORTED_CONNECTION (self), settings);\n\tg_hash_table_destroy (settings);\n\treturn TRUE;\n\ninvalid:\n\tg_clear_error (&error);\n\tnm_exported_connection_signal_removed (NM_EXPORTED_CONNECTION (self));\n\treturn FALSE;\n}",
        "target": 1
    },
    {
        "func": "utils_fill_connection_certs (NMConnection *connection)\n{\n\tNMSetting8021x *s_8021x;\n\tconst char *filename;\n\tGError *error = NULL;\n\tgboolean need_client_cert = TRUE;\n\n\tg_return_if_fail (connection != NULL);\n\n\ts_8021x = NM_SETTING_802_1X (nm_connection_get_setting (connection, NM_TYPE_SETTING_802_1X));\n\tif (!s_8021x)\n\t\treturn;\n\n\tfilename = g_object_get_data (G_OBJECT (connection), NMA_PATH_CA_CERT_TAG);\n\tif (filename) {\n\t\tif (!nm_setting_802_1x_set_ca_cert_from_file (s_8021x, filename, NULL, &error))\n\t\t\tg_warning (\"%s: couldn't read CA certificate: %d %s\", __func__, error->code, error->message);\n\t\tg_clear_error (&error);\n\t}\n\n\t/* If the private key is PKCS#12, don't set the client cert */\n\tneed_client_cert = fill_one_private_key (connection,\n\t                                         NMA_PATH_PRIVATE_KEY_TAG,\n\t                                         NM_SETTING_802_1X_PRIVATE_KEY,\n\t                                         NM_SETTING_802_1X_CLIENT_CERT);\n\tif (need_client_cert) {\n\t\tfilename = g_object_get_data (G_OBJECT (connection), NMA_PATH_CLIENT_CERT_TAG);\n\t\tif (filename) {\n\t\t\tif (!nm_setting_802_1x_set_client_cert_from_file (s_8021x, filename, NULL, &error))\n\t\t\t\tg_warning (\"%s: couldn't read client certificate: %d %s\", __func__, error->code, error->message);\n\t\t\tg_clear_error (&error);\n\t\t}\n\t}\n\n\tfilename = g_object_get_data (G_OBJECT (connection), NMA_PATH_PHASE2_CA_CERT_TAG);\n\tif (filename) {\n\t\tif (!nm_setting_802_1x_set_phase2_ca_cert_from_file (s_8021x, filename, NULL, &error))\n\t\t\tg_warning (\"%s: couldn't read phase2 CA certificate: %d %s\", __func__, error->code, error->message);\n\t\tg_clear_error (&error);\n\t}\n\n\t/* If the private key is PKCS#12, don't set the client cert */\n\tneed_client_cert = fill_one_private_key (connection,\n\t                                         NMA_PATH_PHASE2_PRIVATE_KEY_TAG,\n\t                                         NM_SETTING_802_1X_PHASE2_PRIVATE_KEY,\n\t                                         NM_SETTING_802_1X_PHASE2_CLIENT_CERT);\n\tif (need_client_cert) {\n\t\tfilename = g_object_get_data (G_OBJECT (connection), NMA_PATH_PHASE2_CLIENT_CERT_TAG);\n\t\tif (filename) {\n\t\t\tif (!nm_setting_802_1x_set_phase2_client_cert_from_file (s_8021x, filename, NULL, &error))\n\t\t\t\tg_warning (\"%s: couldn't read phase2 client certificate: %d %s\", __func__, error->code, error->message);\n\t\t\tg_clear_error (&error);\n\t\t}\n\t}\n}",
        "target": 1
    },
    {
        "func": "update_connection (NMConnectionList *list,\n                   NMConnectionEditor *editor,\n                   NMExportedConnection *original,\n                   NMConnection *modified,\n                   ConnectionUpdatedFn callback,\n                   gpointer user_data)\n{\n\tNMConnectionScope original_scope;\n\tConnectionUpdateInfo *info;\n\n\tinfo = g_slice_new0 (ConnectionUpdateInfo);\n\tinfo->list = list;\n\tinfo->editor = editor;\n\tinfo->original = g_object_ref (original);\n\tinfo->modified = g_object_ref (modified);\n\tinfo->callback = callback;\n\tinfo->user_data = user_data;\n\n\toriginal_scope = nm_connection_get_scope (nm_exported_connection_get_connection (original));\n\tif (nm_connection_get_scope (modified) == original_scope) {\n\t\t/* The easy part: Connection is updated */\n\t\tGHashTable *new_settings;\n\t\tGError *error = NULL;\n\t\tgboolean success;\n\t\tgboolean pending_auth = FALSE;\n\t\tGtkWindow *parent;\n\n\t\tutils_fill_connection_certs (modified);\n\t\tnew_settings = nm_connection_to_hash (modified);\n\n\t\t/* Hack; make sure that gconf private values are copied */\n\t\tnm_gconf_copy_private_connection_values (nm_exported_connection_get_connection (original),\n\t\t                                         modified);\n\n\t\tsuccess = nm_exported_connection_update (original, new_settings, &error);\n\t\tg_hash_table_destroy (new_settings);\n\t\tutils_clear_filled_connection_certs (modified);\n\n\t\tparent = nm_connection_editor_get_window (editor);\n\t\tif (!success) {\n\t\t\tif (pk_helper_is_permission_denied_error (error)) {\n\t\t\t\tGError *auth_error = NULL;\n\n\t\t\t\tpending_auth = pk_helper_obtain_auth (error, parent, update_connection_cb, info, &auth_error);\n\t\t\t\tif (auth_error) {\n\t\t\t\t\terror_dialog (parent,\n\t\t\t\t\t              _(\"Could not update connection\"),\n\t\t\t\t\t              \"%s\", auth_error->message);\n\t\t\t\t\tg_error_free (auth_error);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\terror_dialog (parent,\n\t\t\t\t              _(\"Could not update connection\"),\n\t\t\t\t              \"%s\", error->message);\n\t\t\t}\n\n\t\t\tg_error_free (error);\n\t\t} else {\n\t\t\t/* Save user-connection vpn secrets */\n\t\t\tif (editor && (original_scope == NM_CONNECTION_SCOPE_USER))\n\t\t\t\tnm_connection_editor_save_vpn_secrets (editor);\n\t\t}\n\n\t\tif (!pending_auth)\n\t\t\tconnection_update_done (info, success);\n\t} else {\n\t\t/* The hard part: Connection scope changed:\n\t\t   Add the exported connection,\n\t\t   if it succeeds, remove the old one. */\n\t\tadd_connection (list, editor, modified, connection_update_add_done, info);\n\t}\n}",
        "target": 1
    },
    {
        "func": "add_connection (NMConnectionList *self,\n                NMConnectionEditor *editor,\n                NMConnection *connection,\n                ConnectionAddedFn callback,\n                gpointer user_data)\n{\n\tNMExportedConnection *exported = NULL;\n\tNMConnectionScope scope;\n\tgboolean success = FALSE;\n\n\tscope = nm_connection_get_scope (connection);\n\tif (scope == NM_CONNECTION_SCOPE_SYSTEM) {\n\t\tGError *error = NULL;\n\n\t\tutils_fill_connection_certs (connection);\n\t\tsuccess = nm_dbus_settings_system_add_connection (self->system_settings, connection, &error);\n\t\tutils_clear_filled_connection_certs (connection);\n\n\t\tif (!success) {\n\t\t\tgboolean pending_auth = FALSE;\n\t\t\tGtkWindow *parent;\n\n\t\t\tparent = nm_connection_editor_get_window (editor);\n\t\t\tif (pk_helper_is_permission_denied_error (error)) {\n\t\t\t\tConnectionAddInfo *info;\n\t\t\t\tGError *auth_error = NULL;\n\n\t\t\t\tinfo = g_slice_new (ConnectionAddInfo);\n\t\t\t\tinfo->list = self;\n\t\t\t\tinfo->editor = editor;\n\t\t\t\tinfo->connection = g_object_ref (connection);\n\t\t\t\tinfo->callback = callback;\n\t\t\t\tinfo->user_data = user_data;\n\n\t\t\t\tpending_auth = pk_helper_obtain_auth (error, parent, add_connection_cb, info, &auth_error);\n\t\t\t\tif (auth_error) {\n\t\t\t\t\terror_dialog (parent,\n\t\t\t\t\t              _(\"Could not add connection\"),\n\t\t\t\t\t              \"%s\", auth_error->message);\n\t\t\t\t\tg_error_free (auth_error);\n\t\t\t\t}\n\n\t\t\t\tif (!pending_auth) {\n\t\t\t\t\tg_object_unref (info->connection);\n\t\t\t\t\tg_slice_free (ConnectionAddInfo, info);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\terror_dialog (parent,\n\t\t\t\t              _(\"Could not add connection\"),\n\t\t\t\t              \"%s\", error->message);\n\t\t\t}\n\n\t\t\tg_error_free (error);\n\n\t\t\tif (pending_auth)\n\t\t\t\treturn;\n\t\t}\n\t} else if (scope == NM_CONNECTION_SCOPE_USER) {\n\t\texported = (NMExportedConnection *) nma_gconf_settings_add_connection (self->gconf_settings, connection);\n\t\tsuccess = exported != NULL;\n\t\tif (success && editor)\n\t\t\tnm_connection_editor_save_vpn_secrets (editor);\n\t} else\n\t\tg_warning (\"%s: unhandled connection scope %d!\", __func__, scope);\n\n\tif (callback)\n\t\tcallback (exported, success, user_data);\n\n\tif (exported)\n\t\tg_object_unref (exported);\n}",
        "target": 1
    },
    {
        "func": "read_one_cert (ReadFromGConfInfo *info,\n               const char *setting_name,\n               const char *key)\n{\n\tchar *value = NULL;\n\n\tif (!nm_gconf_get_string_helper (info->client, info->dir, key, setting_name, &value))\n\t\treturn;\n\n\tg_object_set_data_full (G_OBJECT (info->connection),\n\t                        key, value,\n\t                        (GDestroyNotify) g_free);\n}",
        "target": 1
    },
    {
        "func": "read_applet_private_values_from_gconf (NMSetting *setting,\n                                       ReadFromGConfInfo *info)\n{\n\tif (NM_IS_SETTING_802_1X (setting)) {\n\t\tconst char *setting_name = nm_setting_get_name (setting);\n\t\tgboolean value;\n\n\t\tif (nm_gconf_get_bool_helper (info->client, info->dir,\n\t\t                              NMA_CA_CERT_IGNORE_TAG,\n\t\t                              setting_name, &value)) {\n\t\t\tg_object_set_data (G_OBJECT (info->connection),\n\t\t\t                   NMA_CA_CERT_IGNORE_TAG,\n\t\t\t                   GUINT_TO_POINTER (value));\n\t\t}\n\n\t\tif (nm_gconf_get_bool_helper (info->client, info->dir,\n\t\t                              NMA_PHASE2_CA_CERT_IGNORE_TAG,\n\t\t                              setting_name, &value)) {\n\t\t\tg_object_set_data (G_OBJECT (info->connection),\n\t\t\t                   NMA_PHASE2_CA_CERT_IGNORE_TAG,\n\t\t\t                   GUINT_TO_POINTER (value));\n\t\t}\n\n\t\t/* Binary certificate and key data doesn't get stored in GConf.  Instead,\n\t\t * the path to the certificate gets stored in a special key and the\n\t\t * certificate is read and stuffed into the setting right before\n\t\t * the connection is sent to NM\n\t\t */\n\t\tread_one_cert (info, setting_name, NMA_PATH_CA_CERT_TAG);\n\t\tread_one_cert (info, setting_name, NMA_PATH_CLIENT_CERT_TAG);\n\t\tread_one_cert (info, setting_name, NMA_PATH_PRIVATE_KEY_TAG);\n\t\tread_one_cert (info, setting_name, NMA_PATH_PHASE2_CA_CERT_TAG);\n\t\tread_one_cert (info, setting_name, NMA_PATH_PHASE2_CLIENT_CERT_TAG);\n\t\tread_one_cert (info, setting_name, NMA_PATH_PHASE2_PRIVATE_KEY_TAG);\n\t}\n}",
        "target": 1
    },
    {
        "func": "get_8021x_secrets_cb (GtkDialog *dialog,\n\t\t\t\t\t  gint response,\n\t\t\t\t\t  gpointer user_data)\n{\n\tNM8021xInfo *info = user_data;\n\tNMAGConfConnection *gconf_connection;\n\tNMConnection *connection = NULL;\n\tNMSetting *setting;\n\tGHashTable *settings_hash;\n\tGHashTable *secrets;\n\tGError *err = NULL;\n\n\t/* Got a user response, clear the NMActiveConnection destroy handler for\n\t * this dialog since this function will now take over dialog destruction.\n\t */\n\tg_object_weak_unref (G_OBJECT (info->active_connection), destroy_8021x_dialog, info);\n\n\tif (response != GTK_RESPONSE_OK) {\n\t\tg_set_error (&err, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_SECRETS_REQUEST_CANCELED,\n\t\t             \"%s.%d (%s): canceled\",\n\t\t             __FILE__, __LINE__, __func__);\n\t\tgoto done;\n\t}\n\n\tconnection = nma_wired_dialog_get_connection (info->dialog);\n\tif (!connection) {\n\t\tg_set_error (&err, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INTERNAL_ERROR,\n\t\t             \"%s.%d (%s): couldn't get connection from wired dialog.\",\n\t\t             __FILE__, __LINE__, __func__);\n\t\tgoto done;\n\t}\n\n\tsetting = nm_connection_get_setting (connection, NM_TYPE_SETTING_802_1X);\n\tif (!setting) {\n\t\tg_set_error (&err, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,\n\t\t\t\t\t \"%s.%d (%s): requested setting '802-1x' didn't\"\n\t\t\t\t\t \" exist in the connection.\",\n\t\t\t\t\t __FILE__, __LINE__, __func__);\n\t\tgoto done;\n\t}\n\n\tutils_fill_connection_certs (NM_CONNECTION (connection));\n\tsecrets = nm_setting_to_hash (setting);\n\tutils_clear_filled_connection_certs (NM_CONNECTION (connection));\n\n\tif (!secrets) {\n\t\tg_set_error (&err, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INTERNAL_ERROR,\n\t\t\t\t\t \"%s.%d (%s): failed to hash setting '%s'.\",\n\t\t\t\t\t __FILE__, __LINE__, __func__, nm_setting_get_name (setting));\n\t\tgoto done;\n\t}\n\n\t/* Returned secrets are a{sa{sv}}; this is the outer a{s...} hash that\n\t * will contain all the individual settings hashes.\n\t */\n\tsettings_hash = g_hash_table_new_full (g_str_hash, g_str_equal,\n\t\t\t\t\t\t\t\t\t\t   g_free, (GDestroyNotify) g_hash_table_destroy);\n\n\tg_hash_table_insert (settings_hash, g_strdup (nm_setting_get_name (setting)), secrets);\n\tdbus_g_method_return (info->context, settings_hash);\n\tg_hash_table_destroy (settings_hash);\n\n\t/* Save the connection back to GConf _after_ hashing it, because\n\t * saving to GConf might trigger the GConf change notifiers, resulting\n\t * in the connection being read back in from GConf which clears secrets.\n\t */\n\tgconf_connection = nma_gconf_settings_get_by_connection (info->applet->gconf_settings, connection);\n\tif (gconf_connection)\n\t\tnma_gconf_connection_save (gconf_connection);\n\ndone:\n\tif (err) {\n\t\tg_warning (\"%s\", err->message);\n\t\tdbus_g_method_return_error (info->context, err);\n\t\tg_error_free (err);\n\t}\n\n\tif (connection)\n\t\tnm_connection_clear_secrets (connection);\n\n\tdestroy_8021x_dialog (info, NULL);\n}",
        "target": 1
    },
    {
        "func": "add_one_setting (GHashTable *settings,\n                 NMConnection *connection,\n                 NMSetting *setting,\n                 GError **error)\n{\n\tGHashTable *secrets;\n\n\tg_return_val_if_fail (settings != NULL, FALSE);\n\tg_return_val_if_fail (connection != NULL, FALSE);\n\tg_return_val_if_fail (setting != NULL, FALSE);\n\tg_return_val_if_fail (error != NULL, FALSE);\n\tg_return_val_if_fail (*error == NULL, FALSE);\n\n\tutils_fill_connection_certs (connection);\n\tsecrets = nm_setting_to_hash (setting);\n\tutils_clear_filled_connection_certs (connection);\n\n\tif (secrets) {\n\t\tg_hash_table_insert (settings, g_strdup (nm_setting_get_name (setting)), secrets);\n\t} else {\n\t\tg_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INTERNAL_ERROR,\n\t\t             \"%s.%d (%s): failed to hash setting '%s'.\",\n\t\t             __FILE__, __LINE__, __func__, nm_setting_get_name (setting));\n\t}\n\n\treturn secrets ? TRUE : FALSE;\n}",
        "target": 1
    },
    {
        "func": "get_settings (NMExportedConnection *exported)\n{\n\tNMConnection *connection;\n\tGHashTable *settings;\n\n\tconnection = nm_exported_connection_get_connection (exported);\n\n\tutils_fill_connection_certs (connection);\n\tsettings = nm_connection_to_hash (connection);\n\tutils_clear_filled_connection_certs (connection);\n\n\treturn settings;\n}",
        "target": 1
    },
    {
        "func": "constructor (GType type,\n\t\t   guint n_construct_params,\n\t\t   GObjectConstructParam *construct_params)\n{\n\tGObject *object;\n\tNMAGConfConnectionPrivate *priv;\n\tNMConnection *connection;\n\tGError *error = NULL;\n\n\tobject = G_OBJECT_CLASS (nma_gconf_connection_parent_class)->constructor (type, n_construct_params, construct_params);\n\n\tif (!object)\n\t\treturn NULL;\n\n\tpriv = NMA_GCONF_CONNECTION_GET_PRIVATE (object);\n\n\tif (!priv->client) {\n\t\tnm_warning (\"GConfClient not provided.\");\n\t\tgoto err;\n\t}\n\n\tif (!priv->dir) {\n\t\tnm_warning (\"GConf directory not provided.\");\n\t\tgoto err;\n\t}\n\n\tconnection = nm_exported_connection_get_connection (NM_EXPORTED_CONNECTION (object));\n\n\tutils_fill_connection_certs (connection);\n\tif (!nm_connection_verify (connection, &error)) {\n\t\tutils_clear_filled_connection_certs (connection);\n\t\tg_warning (\"Invalid connection: '%s' / '%s' invalid: %d\",\n\t\t           g_type_name (nm_connection_lookup_setting_type_by_quark (error->domain)),\n\t\t           error->message, error->code);\n\t\tg_error_free (error);\n\t\tgoto err;\n\t}\n\tutils_clear_filled_connection_certs (connection);\n\n\tfill_vpn_user_name (connection);\n\n\treturn object;\n\n err:\n\tg_object_unref (object);\n\n\treturn NULL;\n}",
        "target": 1
    },
    {
        "func": "nm_gconf_read_connection (GConfClient *client,\n                          const char *dir)\n{\n\tReadFromGConfInfo info;\n\tGSList *list;\n\tGError *err = NULL;\n\n\tlist = gconf_client_all_dirs (client, dir, &err);\n\tif (err) {\n\t\tg_warning (\"Error while reading connection: %s\", err->message);\n\t\tg_error_free (err);\n\t\treturn NULL;\n\t}\n\n\tif (!list) {\n\t\tg_warning (\"Invalid connection (empty)\");\n\t\treturn NULL;\n\t}\n\n\tinfo.connection = nm_connection_new ();\n\tinfo.client = client;\n\tinfo.dir = dir;\n\tinfo.dir_len = strlen (dir);\n\n\tg_slist_foreach (list, read_one_setting, &info);\n\tg_slist_free (list);\n\n\treturn info.connection;\n}",
        "target": 1
    },
    {
        "func": "edit_done_cb (NMConnectionEditor *editor, gint response, GError *error, gpointer user_data)\n{\n\tEditConnectionInfo *info = (EditConnectionInfo *) user_data;\n\tconst char *message = _(\"An unknown error ocurred.\");\n\n\tg_hash_table_remove (info->list->editors, info->original_connection);\n\n\tif (response == GTK_RESPONSE_NONE) {\n\t\tif (error && error->message)\n\t\t\tmessage = error->message;\n\t\terror_dialog (GTK_WINDOW (editor->window), _(\"Error initializing editor\"), \"%s\", message);\n\t} else if (response == GTK_RESPONSE_OK) {\n\t\tNMConnection *connection;\n\t\tGError *edit_error = NULL;\n\t\tgboolean success;\n\n\t\tconnection = nm_connection_editor_get_connection (editor);\n\n\t\tutils_fill_connection_certs (connection);\n\t\tsuccess = nm_connection_verify (connection, &edit_error);\n\t\tutils_clear_filled_connection_certs (connection);\n\n\t\tif (success) {\n\t\t\tupdate_connection (info->list, editor, info->original_connection,\n\t\t\t                   connection, connection_updated_cb, info);\n\t\t} else {\n\t\t\tg_warning (\"%s: invalid connection after update: bug in the \"\n\t\t\t           \"'%s' / '%s' invalid: %d\",\n\t\t\t           __func__,\n\t\t\t           g_type_name (nm_connection_lookup_setting_type_by_quark (edit_error->domain)),\n\t\t\t           edit_error->message, edit_error->code);\n\t\t\tg_error_free (edit_error);\n\t\t\tconnection_updated_cb (info->list, FALSE, user_data);\n\t\t}\n\t}\n}",
        "target": 1
    },
    {
        "func": "static int ohci_queue_iso_receive_dualbuffer(struct fw_iso_context *base,\n\t\t\t\t\t     struct fw_iso_packet *packet,\n\t\t\t\t\t     struct fw_iso_buffer *buffer,\n\t\t\t\t\t     unsigned long payload)\n{\n\tstruct iso_context *ctx = container_of(base, struct iso_context, base);\n\tstruct db_descriptor *db = NULL;\n\tstruct descriptor *d;\n\tstruct fw_iso_packet *p;\n\tdma_addr_t d_bus, page_bus;\n\tu32 z, header_z, length, rest;\n\tint page, offset, packet_count, header_size;\n\n\t/*\n\t * FIXME: Cycle lost behavior should be configurable: lose\n\t * packet, retransmit or terminate..\n\t */\n\n\tp = packet;\n\tz = 2;\n\n\t/*\n\t * The OHCI controller puts the isochronous header and trailer in the\n\t * buffer, so we need at least 8 bytes.\n\t */\n\tpacket_count = p->header_length / ctx->base.header_size;\n\theader_size = packet_count * max(ctx->base.header_size, (size_t)8);\n\n\t/* Get header size in number of descriptors. */\n\theader_z = DIV_ROUND_UP(header_size, sizeof(*d));\n\tpage     = payload >> PAGE_SHIFT;\n\toffset   = payload & ~PAGE_MASK;\n\trest     = p->payload_length;\n\n\t/* FIXME: make packet-per-buffer/dual-buffer a context option */\n\twhile (rest > 0) {\n\t\td = context_get_descriptors(&ctx->context,\n\t\t\t\t\t    z + header_z, &d_bus);\n\t\tif (d == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tdb = (struct db_descriptor *) d;\n\t\tdb->control = cpu_to_le16(DESCRIPTOR_STATUS |\n\t\t\t\t\t  DESCRIPTOR_BRANCH_ALWAYS);\n\t\tdb->first_size =\n\t\t    cpu_to_le16(max(ctx->base.header_size, (size_t)8));\n\t\tif (p->skip && rest == p->payload_length) {\n\t\t\tdb->control |= cpu_to_le16(DESCRIPTOR_WAIT);\n\t\t\tdb->first_req_count = db->first_size;\n\t\t} else {\n\t\t\tdb->first_req_count = cpu_to_le16(header_size);\n\t\t}\n\t\tdb->first_res_count = db->first_req_count;\n\t\tdb->first_buffer = cpu_to_le32(d_bus + sizeof(*db));\n\n\t\tif (p->skip && rest == p->payload_length)\n\t\t\tlength = 4;\n\t\telse if (offset + rest < PAGE_SIZE)\n\t\t\tlength = rest;\n\t\telse\n\t\t\tlength = PAGE_SIZE - offset;\n\n\t\tdb->second_req_count = cpu_to_le16(length);\n\t\tdb->second_res_count = db->second_req_count;\n\t\tpage_bus = page_private(buffer->pages[page]);\n\t\tdb->second_buffer = cpu_to_le32(page_bus + offset);\n\n\t\tif (p->interrupt && length == rest)\n\t\t\tdb->control |= cpu_to_le16(DESCRIPTOR_IRQ_ALWAYS);\n\n\t\tcontext_append(&ctx->context, d, z, header_z);\n\t\toffset = (offset + length) & ~PAGE_MASK;\n\t\trest -= length;\n\t\tif (offset == 0)\n\t\t\tpage++;\n\t}\n\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static int ohci_queue_iso_receive_packet_per_buffer(struct fw_iso_context *base,\n\t\t\t\t\tstruct fw_iso_packet *packet,\n\t\t\t\t\tstruct fw_iso_buffer *buffer,\n\t\t\t\t\tunsigned long payload)\n{\n\tstruct iso_context *ctx = container_of(base, struct iso_context, base);\n\tstruct descriptor *d = NULL, *pd = NULL;\n\tstruct fw_iso_packet *p = packet;\n\tdma_addr_t d_bus, page_bus;\n\tu32 z, header_z, rest;\n\tint i, j, length;\n\tint page, offset, packet_count, header_size, payload_per_buffer;\n\n\t/*\n\t * The OHCI controller puts the isochronous header and trailer in the\n\t * buffer, so we need at least 8 bytes.\n\t */\n\tpacket_count = p->header_length / ctx->base.header_size;\n\theader_size  = max(ctx->base.header_size, (size_t)8);\n\n\t/* Get header size in number of descriptors. */\n\theader_z = DIV_ROUND_UP(header_size, sizeof(*d));\n\tpage     = payload >> PAGE_SHIFT;\n\toffset   = payload & ~PAGE_MASK;\n\tpayload_per_buffer = p->payload_length / packet_count;\n\n\tfor (i = 0; i < packet_count; i++) {\n\t\t/* d points to the header descriptor */\n\t\tz = DIV_ROUND_UP(payload_per_buffer + offset, PAGE_SIZE) + 1;\n\t\td = context_get_descriptors(&ctx->context,\n\t\t\t\tz + header_z, &d_bus);\n\t\tif (d == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\td->control      = cpu_to_le16(DESCRIPTOR_STATUS |\n\t\t\t\t\t      DESCRIPTOR_INPUT_MORE);\n\t\tif (p->skip && i == 0)\n\t\t\td->control |= cpu_to_le16(DESCRIPTOR_WAIT);\n\t\td->req_count    = cpu_to_le16(header_size);\n\t\td->res_count    = d->req_count;\n\t\td->transfer_status = 0;\n\t\td->data_address = cpu_to_le32(d_bus + (z * sizeof(*d)));\n\n\t\trest = payload_per_buffer;\n\t\tfor (j = 1; j < z; j++) {\n\t\t\tpd = d + j;\n\t\t\tpd->control = cpu_to_le16(DESCRIPTOR_STATUS |\n\t\t\t\t\t\t  DESCRIPTOR_INPUT_MORE);\n\n\t\t\tif (offset + rest < PAGE_SIZE)\n\t\t\t\tlength = rest;\n\t\t\telse\n\t\t\t\tlength = PAGE_SIZE - offset;\n\t\t\tpd->req_count = cpu_to_le16(length);\n\t\t\tpd->res_count = pd->req_count;\n\t\t\tpd->transfer_status = 0;\n\n\t\t\tpage_bus = page_private(buffer->pages[page]);\n\t\t\tpd->data_address = cpu_to_le32(page_bus + offset);\n\n\t\t\toffset = (offset + length) & ~PAGE_MASK;\n\t\t\trest -= length;\n\t\t\tif (offset == 0)\n\t\t\t\tpage++;\n\t\t}\n\t\tpd->control = cpu_to_le16(DESCRIPTOR_STATUS |\n\t\t\t\t\t  DESCRIPTOR_INPUT_LAST |\n\t\t\t\t\t  DESCRIPTOR_BRANCH_ALWAYS);\n\t\tif (p->interrupt && i == packet_count - 1)\n\t\t\tpd->control |= cpu_to_le16(DESCRIPTOR_IRQ_ALWAYS);\n\n\t\tcontext_append(&ctx->context, d, z, header_z);\n\t}\n\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "activate_parameters_install_free (ActivateParametersInstall *parameters_install)\n{\n\tif (parameters_install->slot_info) {\n\t\tg_object_remove_weak_pointer (G_OBJECT (parameters_install->slot_info), (gpointer *)&parameters_install->slot_info);\n\t}\n\tif (parameters_install->parent_window) {\n\t\tg_object_remove_weak_pointer (G_OBJECT (parameters_install->parent_window), (gpointer *)&parameters_install->parent_window);\n\t}\n\tnautilus_file_list_free (parameters_install->files);\n\tg_free (parameters_install->activation_directory);\n\tg_free (parameters_install);\n}",
        "target": 1
    },
    {
        "func": "link_info_done (NautilusDirectory *directory,\n\t\tNautilusFile *file,\n\t\tconst char *uri,\n\t\tconst char *name, \n\t\tconst char *icon,\n\t\tgboolean is_launcher,\n\t\tgboolean is_foreign)\n{\n\tfile->details->link_info_is_up_to_date = TRUE;\n\n\tnautilus_file_set_display_name (file, name, name, TRUE);\n\t\n\tfile->details->got_link_info = TRUE;\n\tg_free (file->details->custom_icon);\n\tif (uri) {\n\t\tif (file->details->activation_location) {\n\t\t\tg_object_unref (file->details->activation_location);\n\t\t\tfile->details->activation_location = NULL;\n\t\t}\n\t\tfile->details->got_custom_activation_location = TRUE;\n\t\tfile->details->activation_location = g_file_new_for_uri (uri);\n\t}\n\tfile->details->custom_icon = g_strdup (icon);\n\tfile->details->is_launcher = is_launcher;\n\tfile->details->is_foreign_link = is_foreign;\n\t\n\tnautilus_directory_async_state_changed (directory);\n}",
        "target": 1
    },
    {
        "func": "nautilus_file_set_display_name (NautilusFile *file,\n\t\t\t\tconst char *display_name,\n\t\t\t\tconst char *edit_name,\n\t\t\t\tgboolean custom)\n{\n\tgboolean changed;\n\n\tif (display_name == NULL || *display_name == 0) {\n\t\treturn FALSE;\n\t}\n\t\n\tif (!custom && file->details->got_custom_display_name) {\n\t\treturn FALSE;\n\t}\n\n\tif (custom && display_name == NULL) {\n\t\t/* We're re-setting a custom display name, invalidate it if\n\t\t   we already set it so that the old one is re-read */\n\t\tif (file->details->got_custom_display_name) {\n\t\t\tfile->details->got_custom_display_name = FALSE;\n\t\t\tnautilus_file_invalidate_attributes (file,\n\t\t\t\t\t\t\t     NAUTILUS_FILE_ATTRIBUTE_INFO);\n\t\t}\n\t\treturn FALSE;\n\t}\n\n\tif (edit_name == NULL) {\n\t\tedit_name = display_name;\n\t}\n\t    \n\tchanged = FALSE;\n\t\n\tif (eel_strcmp (eel_ref_str_peek (file->details->display_name), display_name) != 0) {\n\t\tchanged = TRUE;\n\t\t\n\t\teel_ref_str_unref (file->details->display_name);\n\t\t\n\t\tif (eel_strcmp (eel_ref_str_peek (file->details->name), display_name) == 0) {\n\t\t\tfile->details->display_name = eel_ref_str_ref (file->details->name);\n\t\t} else {\n\t\t\tfile->details->display_name = eel_ref_str_new (display_name);\n\t\t}\n\t\t\n\t\tg_free (file->details->display_name_collation_key);\n\t\tfile->details->display_name_collation_key = g_utf8_collate_key_for_filename (display_name, -1);\n\t}\n\n\tif (eel_strcmp (eel_ref_str_peek (file->details->edit_name), edit_name) != 0) {\n\t\tchanged = TRUE;\n\t\t\n\t\teel_ref_str_unref (file->details->edit_name);\n\t\tif (eel_strcmp (eel_ref_str_peek (file->details->display_name), edit_name) == 0) {\n\t\t\tfile->details->edit_name = eel_ref_str_ref (file->details->display_name);\n\t\t} else {\n\t\t\tfile->details->edit_name = eel_ref_str_new (edit_name);\n\t\t}\n\t}\n\t\n\tfile->details->got_custom_display_name = custom;\n\treturn changed;\n}",
        "target": 1
    },
    {
        "func": "activate_files (ActivateParameters *parameters)\n{\n\tNautilusWindowInfo *window_info;\n\tNautilusWindowOpenFlags flags;\n\tNautilusFile *file;\n\tGList *launch_desktop_files;\n\tGList *launch_files;\n\tGList *launch_in_terminal_files;\n\tGList *open_in_app_files;\n\tGList *open_in_app_parameters;\n\tGList *unhandled_open_in_app_files;\n\tApplicationLaunchParameters *one_parameters;\n\tGList *open_in_view_files;\n\tGList *l;\n\tint count;\n\tchar *uri;\n\tchar *executable_path, *quoted_path, *name;\n\tchar *old_working_dir;\n\tActivationAction action;\n\tGdkScreen *screen;\n\t\n\tscreen = gtk_widget_get_screen (GTK_WIDGET (parameters->parent_window));\n\n\tlaunch_desktop_files = NULL;\n\tlaunch_files = NULL;\n\tlaunch_in_terminal_files = NULL;\n\topen_in_app_files = NULL;\n\topen_in_view_files = NULL;\n\n\tfor (l = parameters->files; l != NULL; l = l->next) {\n\t\tfile = NAUTILUS_FILE (l->data);\n\n\t\tif (file_was_cancelled (file)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\taction = get_activation_action (file);\n\t\tif (action == ACTIVATION_ACTION_ASK) {\n\t\t\t/* Special case for executable text files, since it might be\n\t\t\t * dangerous & unexpected to launch these.\n\t\t\t */\n\t\t\tpause_activation_timed_cancel (parameters);\n\t\t\taction = get_executable_text_file_action (parameters->parent_window, file);\n\t\t\tunpause_activation_timed_cancel (parameters);\n\t\t}\n\n\t\tswitch (action) {\n\t\tcase ACTIVATION_ACTION_LAUNCH_DESKTOP_FILE :\n\t\t\tlaunch_desktop_files = g_list_prepend (launch_desktop_files, file);\n\t\t\tbreak;\n\t\tcase ACTIVATION_ACTION_LAUNCH :\n\t\t\tlaunch_files = g_list_prepend (launch_files, file);\n\t\t\tbreak;\n\t\tcase ACTIVATION_ACTION_LAUNCH_IN_TERMINAL :\n\t\t\tlaunch_in_terminal_files = g_list_prepend (launch_in_terminal_files, file);\n\t\t\tbreak;\n\t\tcase ACTIVATION_ACTION_OPEN_IN_VIEW :\n\t\t\topen_in_view_files = g_list_prepend (open_in_view_files, file);\n\t\t\tbreak;\n\t\tcase ACTIVATION_ACTION_OPEN_IN_APPLICATION :\n\t\t\topen_in_app_files = g_list_prepend (open_in_app_files, file);\n\t\t\tbreak;\n\t\tcase ACTIVATION_ACTION_DO_NOTHING :\n\t\t\tbreak;\n\t\tcase ACTIVATION_ACTION_ASK :\n\t\t\tg_assert_not_reached ();\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tlaunch_desktop_files = g_list_reverse (launch_desktop_files);\n\tfor (l = launch_desktop_files; l != NULL; l = l->next) {\n\t\tfile = NAUTILUS_FILE (l->data);\n\t\t\n\t\turi = nautilus_file_get_uri (file);\n\t\tnautilus_debug_log (FALSE, NAUTILUS_DEBUG_LOG_DOMAIN_USER,\n\t\t\t\t    \"directory view activate_callback launch_desktop_file window=%p: %s\",\n\t\t\t\t    parameters->parent_window, uri);\n\t\tnautilus_launch_desktop_file (screen, uri, NULL,\n\t\t\t\t\t      parameters->parent_window);\n\t\tg_free (uri);\n\t}\n\n\told_working_dir = NULL;\n\tif (parameters->activation_directory &&\n\t    (launch_files != NULL || launch_in_terminal_files != NULL)) {\n\t\told_working_dir = g_get_current_dir ();\n\t\tg_chdir (parameters->activation_directory);\n\t\t\n\t}\n\n\tlaunch_files = g_list_reverse (launch_files);\n\tfor (l = launch_files; l != NULL; l = l->next) {\n\t\tfile = NAUTILUS_FILE (l->data);\n\n\t\turi = nautilus_file_get_activation_uri (file);\n\t\texecutable_path = g_filename_from_uri (uri, NULL, NULL);\n\t\tquoted_path = g_shell_quote (executable_path);\n\t\tname = nautilus_file_get_name (file);\n\n\t\tnautilus_debug_log (FALSE, NAUTILUS_DEBUG_LOG_DOMAIN_USER,\n\t\t\t\t    \"directory view activate_callback launch_file window=%p: %s\",\n\t\t\t\t    parameters->parent_window, quoted_path);\n\n\t\tnautilus_launch_application_from_command (screen, name, quoted_path, FALSE, NULL);\n\t\tg_free (name);\n\t\tg_free (quoted_path);\n\t\tg_free (executable_path);\n\t\tg_free (uri);\n\t\t\t\n\t}\n\n\tlaunch_in_terminal_files = g_list_reverse (launch_in_terminal_files);\n\tfor (l = launch_in_terminal_files; l != NULL; l = l->next) {\n\t\tfile = NAUTILUS_FILE (l->data);\n\n\t\turi = nautilus_file_get_activation_uri (file);\n\t\texecutable_path = g_filename_from_uri (uri, NULL, NULL);\n\t\tquoted_path = g_shell_quote (executable_path);\n\t\tname = nautilus_file_get_name (file);\n\n\t\tnautilus_debug_log (FALSE, NAUTILUS_DEBUG_LOG_DOMAIN_USER,\n\t\t\t\t    \"directory view activate_callback launch_in_terminal window=%p: %s\",\n\t\t\t\t    parameters->parent_window, quoted_path);\n\n\t\tnautilus_launch_application_from_command (screen, name, quoted_path, TRUE, NULL);\n\t\tg_free (name);\n\t\tg_free (quoted_path);\n\t\tg_free (executable_path);\n\t\tg_free (uri);\n\t}\n\n\tif (old_working_dir != NULL) {\n\t\tg_chdir (old_working_dir);\n\t\tg_free (old_working_dir);\n\t}\n\n\topen_in_view_files = g_list_reverse (open_in_view_files);\n\tcount = g_list_length (open_in_view_files);\n\n\tflags = parameters->flags;\n\tif (count > 1) {\n\t\tif (eel_preferences_get_boolean (NAUTILUS_PREFERENCES_ENABLE_TABS) &&\n\t\t    (parameters->flags & NAUTILUS_WINDOW_OPEN_FLAG_NEW_WINDOW) == 0) {\n\t\t\tflags |= NAUTILUS_WINDOW_OPEN_FLAG_NEW_TAB;\n\t\t} else {\n\t\t\tflags |= NAUTILUS_WINDOW_OPEN_FLAG_NEW_WINDOW;\n\t\t}\n\t}\n\n\tif (parameters->slot_info != NULL &&\n\t    (!parameters->user_confirmation ||\n\t     confirm_multiple_windows (parameters->parent_window, count,\n\t\t\t\t       (flags & NAUTILUS_WINDOW_OPEN_FLAG_NEW_TAB) != 0))) {\n\n\t\tif ((flags & NAUTILUS_WINDOW_OPEN_FLAG_NEW_TAB) != 0 &&\n\t\t    eel_preferences_get_enum (NAUTILUS_PREFERENCES_NEW_TAB_POSITION) ==\n\t\t    NAUTILUS_NEW_TAB_POSITION_AFTER_CURRENT_TAB) {\n\t\t\t/* When inserting N tabs after the current one,\n\t\t\t * we first open tab N, then tab N-1, ..., then tab 0.\n\t\t\t * Each of them is appended to the current tab, i.e.\n\t\t\t * prepended to the list of tabs to open.\n\t\t\t */\n\t\t\topen_in_view_files = g_list_reverse (open_in_view_files);\n\t\t}\n\n\n\t\tfor (l = open_in_view_files; l != NULL; l = l->next) {\n\t\t\tGFile *f;\n\t\t\t/* The ui should ask for navigation or object windows\n\t\t\t * depending on what the current one is */\n\t\t\tfile = NAUTILUS_FILE (l->data);\n\n\t\t\turi = nautilus_file_get_activation_uri (file);\n\t\t\tf = g_file_new_for_uri (uri);\n\t\t\tnautilus_window_slot_info_open_location (parameters->slot_info,\n\t\t\t\t\t\t\t\t f, parameters->mode, flags, NULL);\n\t\t\tg_object_unref (f);\n\t\t\tg_free (uri);\n\t\t}\n\t}\n\n\topen_in_app_parameters = NULL;\n\tunhandled_open_in_app_files = NULL;\n\n\tif (open_in_app_files != NULL) {\n\t\topen_in_app_files = g_list_reverse (open_in_app_files);\n\n\t\topen_in_app_parameters = fm_directory_view_make_activation_parameters\n\t\t\t(open_in_app_files, &unhandled_open_in_app_files);\n\t}\n\n\tfor (l = open_in_app_parameters; l != NULL; l = l->next) {\n\t\tone_parameters = l->data;\n\n\t\tnautilus_launch_application (one_parameters->application,\n\t\t\t\t\t     one_parameters->files,\n\t\t\t\t\t     parameters->parent_window);\n\t\tapplication_launch_parameters_free (one_parameters);\n\t}\n\n\tfor (l = unhandled_open_in_app_files; l != NULL; l = l->next) {\n\t\tfile = NAUTILUS_FILE (l->data);\n\n\t\t/* this does not block */\n\t\tapplication_unhandled_file (parameters, file);\n\t}\n\n\twindow_info = NULL;\n\tif (parameters->slot_info != NULL) {\n\t\twindow_info = nautilus_window_slot_info_get_window (parameters->slot_info);\n\t}\n\n\tif (open_in_app_parameters != NULL ||\n\t    unhandled_open_in_app_files != NULL) {\n\t\tif ((parameters->flags & NAUTILUS_WINDOW_OPEN_FLAG_CLOSE_BEHIND) != 0 &&\n\t\t    window_info != NULL && \n\t\t     nautilus_window_info_get_window_type (window_info) == NAUTILUS_WINDOW_SPATIAL) {\n\t\t\tnautilus_window_info_close (window_info);\n\t\t}\n\t}\n\n\tg_list_free (launch_desktop_files);\n\tg_list_free (launch_files);\n\tg_list_free (launch_in_terminal_files);\n\tg_list_free (open_in_view_files);\n\tg_list_free (open_in_app_files);\n\tg_list_free (open_in_app_parameters);\n\tg_list_free (unhandled_open_in_app_files);\n\t\n\tactivation_parameters_free (parameters);\n}",
        "target": 1
    },
    {
        "func": "nautilus_file_clear_info (NautilusFile *file)\n{\n\tfile->details->got_file_info = FALSE;\n\tif (file->details->get_info_error) {\n\t\tg_error_free (file->details->get_info_error);\n\t\tfile->details->get_info_error = NULL;\n\t}\n\t/* Reset to default type, which might be other than unknown for\n\t   special kinds of files like the desktop or a search directory */\n\tfile->details->type = NAUTILUS_FILE_GET_CLASS (file)->default_file_type;\n\n\tif (!file->details->got_custom_display_name) {\n\t\tnautilus_file_clear_display_name (file);\n\t}\n\n\tif (!file->details->got_custom_activation_location &&\n\t    file->details->activation_location != NULL) {\n\t\tg_object_unref (file->details->activation_location);\n\t\tfile->details->activation_location = NULL;\n\t}\n\t\n\tif (file->details->icon != NULL) {\n\t\tg_object_unref (file->details->icon);\n\t\tfile->details->icon = NULL;\n\t}\n\n\tg_free (file->details->thumbnail_path);\n\tfile->details->thumbnail_path = NULL;\n\tfile->details->thumbnailing_failed = FALSE;\n\t\n\tfile->details->is_launcher = FALSE;\n\tfile->details->is_foreign_link = FALSE;\n\tfile->details->is_symlink = FALSE;\n\tfile->details->is_hidden = FALSE;\n\tfile->details->is_backup = FALSE;\n\tfile->details->is_mountpoint = FALSE;\n\tfile->details->uid = -1;\n\tfile->details->gid = -1;\n\tfile->details->can_read = TRUE;\n\tfile->details->can_write = TRUE;\n\tfile->details->can_execute = TRUE;\n\tfile->details->can_delete = TRUE;\n\tfile->details->can_trash = TRUE;\n\tfile->details->can_rename = TRUE;\n\tfile->details->can_mount = FALSE;\n\tfile->details->can_unmount = FALSE;\n\tfile->details->can_eject = FALSE;\n\tfile->details->has_permissions = FALSE;\n\tfile->details->permissions = 0;\n\tfile->details->size = -1;\n\tfile->details->sort_order = 0;\n\tfile->details->mtime = 0;\n\tfile->details->atime = 0;\n\tfile->details->ctime = 0;\n\tg_free (file->details->symlink_name);\n\tfile->details->symlink_name = NULL;\n\teel_ref_str_unref (file->details->mime_type);\n\tfile->details->mime_type = NULL;\n\tg_free (file->details->selinux_context);\n\tfile->details->selinux_context = NULL;\n\tg_free (file->details->description);\n\tfile->details->description = NULL;\n\n\teel_ref_str_unref (file->details->filesystem_id);\n\tfile->details->filesystem_id = NULL;\n}",
        "target": 1
    },
    {
        "func": "mark_trusted_callback (NautilusFile  *file,\n\t\t       GFile         *result_location,\n\t\t       GError        *error,\n\t\t       gpointer       callback_data)\n{\n\tActivateParametersDesktop *parameters;\n\n\tparameters = callback_data;\n\tif (error) {\n\t\teel_show_error_dialog (_(\"Unable to mark launcher trusted (executable)\"),\n\t\t\t\t       error->message,\n\t\t\t\t       parameters->parent_window);\n\t}\n\t\n\tactivate_parameters_desktop_free (parameters);\n}",
        "target": 1
    },
    {
        "func": "untrusted_launcher_response_callback (GtkDialog *dialog,\n\t\t\t\t      int response_id,\n\t\t\t\t      ActivateParametersDesktop *parameters)\n{\n\tGdkScreen *screen;\n\tchar *uri;\n\tgboolean free_params;\n\t\n\tfree_params = TRUE;\n\tswitch (response_id) {\n\tcase RESPONSE_RUN:\n\t\tscreen = gtk_widget_get_screen (GTK_WIDGET (parameters->parent_window));\n\t\turi = nautilus_file_get_uri (parameters->file);\n\t\tnautilus_debug_log (FALSE, NAUTILUS_DEBUG_LOG_DOMAIN_USER,\n\t\t\t\t    \"directory view activate_callback launch_desktop_file window=%p: %s\",\n\t\t\t\t    parameters->parent_window, uri);\n\t\tnautilus_launch_desktop_file (screen, uri, NULL,\n\t\t\t\t\t      parameters->parent_window);\n\t\tg_free (uri);\n\t\tbreak;\n\tcase RESPONSE_MARK_TRUSTED:\n\t\tnautilus_file_set_permissions (parameters->file, \n\t\t\t\t\t       nautilus_file_get_permissions (parameters->file) | S_IXGRP | S_IXUSR | S_IXOTH,\n\t\t\t\t\t       mark_trusted_callback,\n\t\t\t\t\t       parameters);\n\t\tfree_params = FALSE;\n\t\tbreak;\n\tdefault:\n\t\t/* Just destroy dialog */\n\t\tbreak;\n\t}\n\t\n\tgtk_widget_destroy (GTK_WIDGET (dialog));\n\tif (free_params) {\n\t\tactivate_parameters_desktop_free (parameters);\n\t}\n}",
        "target": 1
    },
    {
        "func": "finish_startup (NautilusApplication *application)\n{\n\tGList *drives;\n\n\t/* initialize nautilus modules */\n\tnautilus_module_setup ();\n\n\t/* attach menu-provider module callback */\n\tmenu_provider_init_callback ();\n\t\n\t/* Initialize the desktop link monitor singleton */\n\tnautilus_desktop_link_monitor_get ();\n\n\t/* Watch for mounts so we can restore open windows This used\n\t * to be for showing new window on mount, but is not used\n\t * anymore */\n\n\t/* Watch for unmounts so we can close open windows */\n\t/* TODO-gio: This should be using the UNMOUNTED feature of GFileMonitor instead */\n\tapplication->volume_monitor = g_volume_monitor_get ();\n\tg_signal_connect_object (application->volume_monitor, \"mount_removed\",\n\t\t\t\t G_CALLBACK (mount_removed_callback), application, 0);\n\tg_signal_connect_object (application->volume_monitor, \"mount_pre_unmount\",\n\t\t\t\t G_CALLBACK (mount_removed_callback), application, 0);\n\tg_signal_connect_object (application->volume_monitor, \"mount_added\",\n\t\t\t\t G_CALLBACK (mount_added_callback), application, 0);\n\tg_signal_connect_object (application->volume_monitor, \"volume_added\",\n\t\t\t\t G_CALLBACK (volume_added_callback), application, 0);\n\tg_signal_connect_object (application->volume_monitor, \"drive_connected\",\n\t\t\t\t G_CALLBACK (drive_connected_callback), application, 0);\n\n\t/* listen for eject button presses */\n\tdrives = g_volume_monitor_get_connected_drives (application->volume_monitor);\n\tg_list_foreach (drives, (GFunc) drive_listen_for_eject_button, application);\n\tg_list_foreach (drives, (GFunc) g_object_unref, NULL);\n\tg_list_free (drives);\n\n\tapplication->automount_idle_id = \n\t\tg_idle_add_full (G_PRIORITY_LOW,\n\t\t\t\t automount_all_volumes_idle_cb,\n\t\t\t\t application, NULL);\n}",
        "target": 1
    },
    {
        "func": "mark_trusted_job (GIOSchedulerJob *io_job,\n\t\t  GCancellable *cancellable,\n\t\t  gpointer user_data)\n{\n\tMarkTrustedJob *job = user_data;\n\tCommonJob *common;\n\tchar *contents, *new_contents;\n\tgsize length, new_length;\n\tGError *error;\n\tguint32 current;\n\tint response;\n\tGFileInfo *info;\n\t\n\tcommon = (CommonJob *)job;\n\tcommon->io_job = io_job;\n\t\n\tnautilus_progress_info_start (job->common.progress);\n\n retry:\n\terror = NULL;\n\tif (!g_file_load_contents (job->file,\n\t\t\t\t  cancellable,\n\t\t\t\t  &contents, &length,\n\t\t\t\t  NULL, &error)) {\n\t\tresponse = run_error (common,\n\t\t\t\t      g_strdup (_(\"Unable to mark launcher trusted (executable)\")),\n\t\t\t\t      error->message,\n\t\t\t\t      NULL,\n\t\t\t\t      FALSE,\n\t\t\t\t      GTK_STOCK_CANCEL, RETRY,\n\t\t\t\t      NULL);\n\n\t\tif (response == 0 || response == GTK_RESPONSE_DELETE_EVENT) {\n\t\t\tabort_job (common);\n\t\t} else if (response == 1) {\n\t\t\tgoto retry;\n\t\t} else {\n\t\t\tg_assert_not_reached ();\n\t\t}\n\n\t\tgoto out;\n\t}\n\n\tif (!g_str_has_prefix (contents, \"#!\")) {\n\t\tnew_length = length + strlen (TRUSTED_SHEBANG);\n\t\tnew_contents = g_malloc (new_length);\n\t\t\n\t\tstrcpy (new_contents, TRUSTED_SHEBANG);\n\t\tmemcpy (new_contents + strlen (TRUSTED_SHEBANG),\n\t\t\tcontents, length);\n\t\t\n\t\tif (!g_file_replace_contents (job->file,\n\t\t\t\t\t      new_contents,\n\t\t\t\t\t      new_length,\n\t\t\t\t\t      NULL,\n\t\t\t\t\t      FALSE, 0,\n\t\t\t\t\t      NULL, cancellable, &error)) {\n\t\t\tg_free (contents);\n\t\t\tg_free (new_contents);\n\t\t\t\n\t\t\tresponse = run_error (common,\n\t\t\t\t\t      g_strdup (_(\"Unable to mark launcher trusted (executable)\")),\n\t\t\t\t\t      error->message,\n\t\t\t\t\t      NULL,\n\t\t\t\t\t      FALSE,\n\t\t\t\t\t      GTK_STOCK_CANCEL, RETRY,\n\t\t\t\t\t      NULL);\n\t\t\t\n\t\t\tif (response == 0 || response == GTK_RESPONSE_DELETE_EVENT) {\n\t\t\t\tabort_job (common);\n\t\t\t} else if (response == 1) {\n\t\t\t\tgoto retry;\n\t\t\t} else {\n\t\t\t\tg_assert_not_reached ();\n\t\t\t}\n\t\t\t\n\t\t\tgoto out;\n\t\t}\n\t\tg_free (new_contents);\n\t\t\n\t}\n\tg_free (contents);\n\t\n\tinfo = g_file_query_info (job->file,\n\t\t\t\t  G_FILE_ATTRIBUTE_STANDARD_TYPE\",\"\n\t\t\t\t  G_FILE_ATTRIBUTE_UNIX_MODE,\n\t\t\t\t  G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n\t\t\t\t  common->cancellable,\n\t\t\t\t  &error);\n\n\tif (info == NULL) {\n\t\tresponse = run_error (common,\n\t\t\t\t      g_strdup (_(\"Unable to mark launcher trusted (executable)\")),\n\t\t\t\t      error->message,\n\t\t\t\t      NULL,\n\t\t\t\t      FALSE,\n\t\t\t\t      GTK_STOCK_CANCEL, RETRY,\n\t\t\t\t      NULL);\n\t\t\n\t\tif (response == 0 || response == GTK_RESPONSE_DELETE_EVENT) {\n\t\t\tabort_job (common);\n\t\t} else if (response == 1) {\n\t\t\tgoto retry;\n\t\t} else {\n\t\t\tg_assert_not_reached ();\n\t\t}\n\t\t\n\t\tgoto out;\n\t}\n\t\n\t\n\tif (g_file_info_has_attribute (info, G_FILE_ATTRIBUTE_UNIX_MODE)) {\n\t\tcurrent = g_file_info_get_attribute_uint32 (info, G_FILE_ATTRIBUTE_UNIX_MODE);\n\t\tcurrent = current | S_IXGRP | S_IXUSR | S_IXOTH;\n\n\t\tif (!g_file_set_attribute_uint32 (job->file, G_FILE_ATTRIBUTE_UNIX_MODE,\n\t\t\t\t\t\t  current, G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n\t\t\t\t\t\t  common->cancellable, &error))\n\t\t\t{\n\t\t\t\tg_object_unref (info);\n\t\t\t\t\n\t\t\t\tresponse = run_error (common,\n\t\t\t\t\t\t      g_strdup (_(\"Unable to mark launcher trusted (executable)\")),\n\t\t\t\t\t\t      error->message,\n\t\t\t\t\t\t      NULL,\n\t\t\t\t\t\t      FALSE,\n\t\t\t\t\t\t      GTK_STOCK_CANCEL, RETRY,\n\t\t\t\t\t\t      NULL);\n\t\t\t\t\n\t\t\t\tif (response == 0 || response == GTK_RESPONSE_DELETE_EVENT) {\n\t\t\t\t\tabort_job (common);\n\t\t\t\t} else if (response == 1) {\n\t\t\t\t\tgoto retry;\n\t\t\t\t} else {\n\t\t\t\t\tg_assert_not_reached ();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tgoto out;\n\t\t\t}\n\t} \n\tg_object_unref (info);\n\nout:\n\t\n\tg_io_scheduler_job_send_to_mainloop_async (io_job,\n\t\t\t\t\t\t   mark_trusted_job_done,\n\t\t\t\t\t\t   job,\n\t\t\t\t\t\t   NULL);\n\n\treturn FALSE;\n}",
        "target": 1
    },
    {
        "func": "untrusted_launcher_response_callback (GtkDialog *dialog,\n\t\t\t\t      int response_id,\n\t\t\t\t      ActivateParametersDesktop *parameters)\n{\n\tGdkScreen *screen;\n\tchar *uri;\n\tGFile *file;\n\t\n\tswitch (response_id) {\n\tcase RESPONSE_RUN:\n\t\tscreen = gtk_widget_get_screen (GTK_WIDGET (parameters->parent_window));\n\t\turi = nautilus_file_get_uri (parameters->file);\n\t\tnautilus_debug_log (FALSE, NAUTILUS_DEBUG_LOG_DOMAIN_USER,\n\t\t\t\t    \"directory view activate_callback launch_desktop_file window=%p: %s\",\n\t\t\t\t    parameters->parent_window, uri);\n\t\tnautilus_launch_desktop_file (screen, uri, NULL,\n\t\t\t\t\t      parameters->parent_window);\n\t\tg_free (uri);\n\t\tbreak;\n\tcase RESPONSE_MARK_TRUSTED:\n\t\tfile = nautilus_file_get_location (parameters->file);\n\t\tnautilus_file_mark_desktop_file_trusted (file,\n\t\t\t\t\t\t\t parameters->parent_window,\n\t\t\t\t\t\t\t NULL, NULL);\n\t\tg_object_unref (file);\n\t\tbreak;\n\tdefault:\n\t\t/* Just destroy dialog */\n\t\tbreak;\n\t}\n\t\n\tgtk_widget_destroy (GTK_WIDGET (dialog));\n\tactivate_parameters_desktop_free (parameters);\n}",
        "target": 1
    },
    {
        "func": "nautilus_application_startup (NautilusApplication *application,\n\t\t\t      gboolean kill_shell,\n\t\t\t      gboolean no_default_window,\n\t\t\t      gboolean no_desktop,\n\t\t\t      gboolean browser_window,\n\t\t\t      const char *geometry,\n\t\t\t      char **urls)\n{\n\tUniqueMessageData *message;\n\t\n\t/* Check the user's ~/.nautilus directories and post warnings\n\t * if there are problems.\n\t */\n\tif (!kill_shell && !check_required_directories (application)) {\n\t\treturn;\n\t}\n\n\tif (kill_shell) {\n\t\tif (unique_app_is_running (application->unique_app)) {\n\t\t\tunique_app_send_message (application->unique_app,\n\t\t\t\t\t\t UNIQUE_CLOSE, NULL);\n\t\t\t\n\t\t}\n\t} else {\n\t\t/* If KDE desktop is running, then force no_desktop */\n\t\tif (is_kdesktop_present ()) {\n\t\t\tno_desktop = TRUE;\n\t\t}\n\t\t\n\t\tif (!no_desktop && eel_preferences_get_boolean (NAUTILUS_PREFERENCES_SHOW_DESKTOP)) {\n\t\t\tif (unique_app_is_running (application->unique_app)) {\n\t\t\t\tunique_app_send_message (application->unique_app,\n\t\t\t\t\t\t\t COMMAND_START_DESKTOP, NULL);\n\t\t\t} else {\n\t\t\t\tnautilus_application_open_desktop (application);\n\t\t\t}\n\t\t}\n\n\t\tif (!unique_app_is_running (application->unique_app)) {\n\t\t\tfinish_startup (application);\n\t\t\tg_signal_connect (application->unique_app, \"message-received\", G_CALLBACK (message_received_cb), application);\t\t\t\n\t\t}\n\t\t\n\t\t/* Monitor the preference to show or hide the desktop */\n\t\teel_preferences_add_callback_while_alive (NAUTILUS_PREFERENCES_SHOW_DESKTOP,\n\t\t\t\t\t\t\t  desktop_changed_callback,\n\t\t\t\t\t\t\t  application,\n\t\t\t\t\t\t\t  G_OBJECT (application));\n\n\t\t/* Monitor the preference to have the desktop */\n\t\t/* point to the Unix home folder */\n\t\teel_preferences_add_callback_while_alive (NAUTILUS_PREFERENCES_DESKTOP_IS_HOME_DIR,\n\t\t\t\t\t\t\t  desktop_location_changed_callback,\n\t\t\t\t\t\t\t  NULL,\n\t\t\t\t\t\t\t  G_OBJECT (application));\n\n\t  \t/* Create the other windows. */\n\t\tif (urls != NULL || !no_default_window) {\n\t\t\tif (unique_app_is_running (application->unique_app)) {\n\t\t\t\tmessage = unique_message_data_new ();\n\t\t\t\t_unique_message_data_set_geometry_and_uris (message, geometry, urls);\n\t\t\t\tif (browser_window) {\n\t\t\t\t\tunique_app_send_message (application->unique_app,\n\t\t\t\t\t\t\t\t COMMAND_OPEN_BROWSER, message);\n\t\t\t\t} else {\n\t\t\t\t\tunique_app_send_message (application->unique_app,\n\t\t\t\t\t\t\t\t UNIQUE_OPEN, message);\n\t\t\t\t}\n\t\t\t\tunique_message_data_free (message);\t\t\t\t\n\t\t\t} else {\n\t\t\t\topen_windows (application, NULL,\n\t\t\t\t\t      urls,\n\t\t\t\t\t      geometry,\n\t\t\t\t\t      browser_window);\n\t\t\t}\n\t\t}\n\n\t\t/* Load session info if availible */\n\t\tnautilus_application_load_session (application);\n\t}\n}",
        "target": 1
    },
    {
        "func": "copy_job_done (gpointer user_data)\n{\n\tCopyMoveJob *job;\n\n\tjob = user_data;\n\tif (job->done_callback) {\n\t\tjob->done_callback (job->debuting_files, job->done_callback_data);\n\t}\n\n\teel_g_object_list_free (job->files);\n\tif (job->destination) {\n\t\tg_object_unref (job->destination);\n\t}\n\tg_hash_table_unref (job->debuting_files);\n\tg_free (job->icon_positions);\n\t\n\tfinalize_common ((CommonJob *)job);\n\n\tnautilus_file_changes_consume_changes (TRUE);\n\treturn FALSE;\n}",
        "target": 1
    },
    {
        "func": "mark_desktop_files_trusted (void)\n{\n\tchar *user_dir, *do_once_file;\n\tGFile *f, *c;\n\tGFileEnumerator *e;\n\tGFileInfo *info;\n\tconst char *name;\n\tint fd;\n\t\n\tuser_dir = nautilus_get_user_directory ();\n\tdo_once_file = g_build_filename (user_dir, \"converted-launchers\", NULL);\n\tg_free (user_dir);\n\n\tif (g_file_test (do_once_file, G_FILE_TEST_EXISTS)) {\n\t\tgoto out;\n\t}\n\n\tf = nautilus_get_desktop_location ();\n\te = g_file_enumerate_children (f,\n\t\t\t\t       G_FILE_ATTRIBUTE_STANDARD_TYPE \",\"\n\t\t\t\t       G_FILE_ATTRIBUTE_STANDARD_NAME \",\"\n\t\t\t\t       G_FILE_ATTRIBUTE_ACCESS_CAN_EXECUTE\n\t\t\t\t       ,\n\t\t\t\t       G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n\t\t\t\t       NULL, NULL);\n\tif (e == NULL) {\n\t\tgoto out2;\n\t}\n\t\n\twhile ((info = g_file_enumerator_next_file (e, NULL, NULL)) != NULL) {\n\t\tname = g_file_info_get_name (info);\n\t\t\n\t\tif (g_str_has_suffix (name, \".desktop\") &&\n\t\t    !g_file_info_get_attribute_boolean (info, G_FILE_ATTRIBUTE_ACCESS_CAN_EXECUTE)) {\n\t\t\tc = g_file_get_child (f, name);\n\t\t\tnautilus_file_mark_desktop_file_trusted (c,\n\t\t\t\t\t\t\t\t NULL, FALSE,\n\t\t\t\t\t\t\t\t NULL, NULL);\n\t\t\tg_object_unref (c);\n\t\t}\n\t\tg_object_unref (info);\n\t}\n\t\n\tg_object_unref (e);\n out2:\n\tfd = g_creat (do_once_file, 0666);\n\tclose (fd);\n\t\n\tg_object_unref (f);\n out:\t\n\tg_free (do_once_file);\n}",
        "target": 1
    },
    {
        "func": "nautilus_file_operations_copy (GList *files,\n\t\t\t       GArray *relative_item_points,\n\t\t\t       GFile *target_dir,\n\t\t\t       GtkWindow *parent_window,\n\t\t\t       NautilusCopyCallback  done_callback,\n\t\t\t       gpointer done_callback_data)\n{\n\tCopyMoveJob *job;\n\n\tjob = op_job_new (CopyMoveJob, parent_window);\n\tjob->done_callback = done_callback;\n\tjob->done_callback_data = done_callback_data;\n\tjob->files = eel_g_object_list_copy (files);\n\tjob->destination = g_object_ref (target_dir);\n\tif (relative_item_points != NULL &&\n\t    relative_item_points->len > 0) {\n\t\tjob->icon_positions =\n\t\t\tg_memdup (relative_item_points->data,\n\t\t\t\t  sizeof (GdkPoint) * relative_item_points->len);\n\t\tjob->n_icon_positions = relative_item_points->len;\n\t}\n\tjob->debuting_files = g_hash_table_new_full (g_file_hash, (GEqualFunc)g_file_equal, g_object_unref, NULL);\n\n\tg_io_scheduler_push_job (copy_job,\n\t\t\t   job,\n\t\t\t   NULL, /* destroy notify */\n\t\t\t   0,\n\t\t\t   job->common.cancellable);\n}",
        "target": 1
    },
    {
        "func": "mark_trusted_job (GIOSchedulerJob *io_job,\n\t\t  GCancellable *cancellable,\n\t\t  gpointer user_data)\n{\n\tMarkTrustedJob *job = user_data;\n\tCommonJob *common;\n\tchar *contents, *new_contents;\n\tgsize length, new_length;\n\tGError *error;\n\tguint32 current;\n\tint response;\n\tGFileInfo *info;\n\t\n\tcommon = (CommonJob *)job;\n\tcommon->io_job = io_job;\n\t\n\tnautilus_progress_info_start (job->common.progress);\n\n retry:\n\terror = NULL;\n\tif (!g_file_load_contents (job->file,\n\t\t\t\t  cancellable,\n\t\t\t\t  &contents, &length,\n\t\t\t\t  NULL, &error)) {\n\t\tif (job->interactive) {\n\t\t\tresponse = run_error (common,\n\t\t\t\t\t      g_strdup (_(\"Unable to mark launcher trusted (executable)\")),\n\t\t\t\t\t      error->message,\n\t\t\t\t\t      NULL,\n\t\t\t\t\t      FALSE,\n\t\t\t\t\t      GTK_STOCK_CANCEL, RETRY,\n\t\t\t\t\t      NULL);\n\t\t} else {\n\t\t\tresponse = 0;\n\t\t}\n\t\t\n\n\t\tif (response == 0 || response == GTK_RESPONSE_DELETE_EVENT) {\n\t\t\tabort_job (common);\n\t\t} else if (response == 1) {\n\t\t\tgoto retry;\n\t\t} else {\n\t\t\tg_assert_not_reached ();\n\t\t}\n\n\t\tgoto out;\n\t}\n\n\tif (!g_str_has_prefix (contents, \"#!\")) {\n\t\tnew_length = length + strlen (TRUSTED_SHEBANG);\n\t\tnew_contents = g_malloc (new_length);\n\t\t\n\t\tstrcpy (new_contents, TRUSTED_SHEBANG);\n\t\tmemcpy (new_contents + strlen (TRUSTED_SHEBANG),\n\t\t\tcontents, length);\n\t\t\n\t\tif (!g_file_replace_contents (job->file,\n\t\t\t\t\t      new_contents,\n\t\t\t\t\t      new_length,\n\t\t\t\t\t      NULL,\n\t\t\t\t\t      FALSE, 0,\n\t\t\t\t\t      NULL, cancellable, &error)) {\n\t\t\tg_free (contents);\n\t\t\tg_free (new_contents);\n\t\t\t\n\t\t\tif (job->interactive) {\n\t\t\t\tresponse = run_error (common,\n\t\t\t\t\t\t      g_strdup (_(\"Unable to mark launcher trusted (executable)\")),\n\t\t\t\t\t\t      error->message,\n\t\t\t\t\t\t      NULL,\n\t\t\t\t\t\t      FALSE,\n\t\t\t\t\t\t      GTK_STOCK_CANCEL, RETRY,\n\t\t\t\t\t\t      NULL);\n\t\t\t} else {\n\t\t\t\tresponse = 0;\n\t\t\t}\n\n\t\t\tif (response == 0 || response == GTK_RESPONSE_DELETE_EVENT) {\n\t\t\t\tabort_job (common);\n\t\t\t} else if (response == 1) {\n\t\t\t\tgoto retry;\n\t\t\t} else {\n\t\t\t\tg_assert_not_reached ();\n\t\t\t}\n\t\t\t\n\t\t\tgoto out;\n\t\t}\n\t\tg_free (new_contents);\n\t\t\n\t}\n\tg_free (contents);\n\t\n\tinfo = g_file_query_info (job->file,\n\t\t\t\t  G_FILE_ATTRIBUTE_STANDARD_TYPE\",\"\n\t\t\t\t  G_FILE_ATTRIBUTE_UNIX_MODE,\n\t\t\t\t  G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n\t\t\t\t  common->cancellable,\n\t\t\t\t  &error);\n\n\tif (info == NULL) {\n\t\tif (job->interactive) {\n\t\t\tresponse = run_error (common,\n\t\t\t\t\t      g_strdup (_(\"Unable to mark launcher trusted (executable)\")),\n\t\t\t\t\t      error->message,\n\t\t\t\t\t      NULL,\n\t\t\t\t\t      FALSE,\n\t\t\t\t\t      GTK_STOCK_CANCEL, RETRY,\n\t\t\t\t\t      NULL);\n\t\t} else {\n\t\t\tresponse = 0;\n\t\t}\n\t\t\n\t\tif (response == 0 || response == GTK_RESPONSE_DELETE_EVENT) {\n\t\t\tabort_job (common);\n\t\t} else if (response == 1) {\n\t\t\tgoto retry;\n\t\t} else {\n\t\t\tg_assert_not_reached ();\n\t\t}\n\t\t\n\t\tgoto out;\n\t}\n\t\n\t\n\tif (g_file_info_has_attribute (info, G_FILE_ATTRIBUTE_UNIX_MODE)) {\n\t\tcurrent = g_file_info_get_attribute_uint32 (info, G_FILE_ATTRIBUTE_UNIX_MODE);\n\t\tcurrent = current | S_IXGRP | S_IXUSR | S_IXOTH;\n\n\t\tif (!g_file_set_attribute_uint32 (job->file, G_FILE_ATTRIBUTE_UNIX_MODE,\n\t\t\t\t\t\t  current, G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n\t\t\t\t\t\t  common->cancellable, &error))\n\t\t\t{\n\t\t\t\tg_object_unref (info);\n\t\t\t\t\n\t\t\t\tresponse = run_error (common,\n\t\t\t\t\t\t      g_strdup (_(\"Unable to mark launcher trusted (executable)\")),\n\t\t\t\t\t\t      error->message,\n\t\t\t\t\t\t      NULL,\n\t\t\t\t\t\t      FALSE,\n\t\t\t\t\t\t      GTK_STOCK_CANCEL, RETRY,\n\t\t\t\t\t\t      NULL);\n\t\t\t\t\n\t\t\t\tif (response == 0 || response == GTK_RESPONSE_DELETE_EVENT) {\n\t\t\t\t\tabort_job (common);\n\t\t\t\t} else if (response == 1) {\n\t\t\t\t\tgoto retry;\n\t\t\t\t} else {\n\t\t\t\t\tg_assert_not_reached ();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tgoto out;\n\t\t\t}\n\t} \n\tg_object_unref (info);\n\nout:\n\t\n\tg_io_scheduler_job_send_to_mainloop_async (io_job,\n\t\t\t\t\t\t   mark_trusted_job_done,\n\t\t\t\t\t\t   job,\n\t\t\t\t\t\t   NULL);\n\n\treturn FALSE;\n}",
        "target": 1
    },
    {
        "func": "copy_move_file (CopyMoveJob *copy_job,\n\t\tGFile *src,\n\t\tGFile *dest_dir,\n\t\tgboolean same_fs,\n\t\tgboolean unique_names,\n\t\tchar **dest_fs_type,\n\t\tSourceInfo *source_info,\n\t\tTransferInfo *transfer_info,\n\t\tGHashTable *debuting_files,\n\t\tGdkPoint *position,\n\t\tgboolean overwrite,\n\t\tgboolean *skipped_file,\n\t\tgboolean readonly_source_fs)\n{\n\tGFile *dest, *new_dest;\n\tGError *error;\n\tGFileCopyFlags flags;\n\tchar *primary, *secondary, *details;\n\tint response;\n\tProgressData pdata;\n\tgboolean would_recurse, is_merge;\n\tCommonJob *job;\n\tgboolean res;\n\tint unique_name_nr;\n\tgboolean handled_invalid_filename;\n\n\tjob = (CommonJob *)copy_job;\n\t\n\tif (should_skip_file (job, src)) {\n\t\t*skipped_file = TRUE;\n\t\treturn;\n\t}\n\n\tunique_name_nr = 1;\n\n\t/* another file in the same directory might have handled the invalid\n\t * filename condition for us\n\t */\n\thandled_invalid_filename = *dest_fs_type != NULL;\n\n\tif (unique_names) {\n\t\tdest = get_unique_target_file (src, dest_dir, same_fs, *dest_fs_type, unique_name_nr++);\n\t} else {\n\t\tdest = get_target_file (src, dest_dir, *dest_fs_type, same_fs);\n\t}\n\n\n\t/* Don't allow recursive move/copy into itself.  \n\t * (We would get a file system error if we proceeded but it is nicer to \n\t * detect and report it at this level) */\n\tif (test_dir_is_parent (dest_dir, src)) {\n\t\tif (job->skip_all_error) {\n\t\t\tg_error_free (error);\n\t\t\tgoto out;\n\t\t}\n\t\t\n\t\t/*  the run_warning() frees all strings passed in automatically  */\n\t\tprimary = copy_job->is_move ? g_strdup (_(\"You cannot move a folder into itself.\"))\n\t\t\t\t\t    : g_strdup (_(\"You cannot copy a folder into itself.\"));\n\t\tsecondary = g_strdup (_(\"The destination folder is inside the source folder.\"));\n\t\t\n\t\tresponse = run_warning (job,\n\t\t\t\t\tprimary,\n\t\t\t\t\tsecondary,\n\t\t\t\t\tNULL,\n\t\t\t\t\t(source_info->num_files - transfer_info->num_files) > 1,\n\t\t\t\t\tGTK_STOCK_CANCEL, SKIP_ALL, SKIP,\n\t\t\t\t\tNULL);\n\n\t\tif (response == 0 || response == GTK_RESPONSE_DELETE_EVENT) {\n\t\t\tabort_job (job);\n\t\t} else if (response == 1) { /* skip all */\n\t\t\tjob->skip_all_error = TRUE;\n\t\t} else if (response == 2) { /* skip */\n\t\t\t/* do nothing */\n\t\t} else {\n\t\t\tg_assert_not_reached ();\n\t\t}\n\n\t\tgoto out;\n\t}\n\n\t/* Don't allow copying over the source or one of the parents of the source.\n\t */\n\tif (test_dir_is_parent (src, dest)) {\n\t\tif (job->skip_all_error) {\n\t\t\tg_error_free (error);\n\t\t\tgoto out;\n\t\t}\n\t\t\n\t\t/*  the run_warning() frees all strings passed in automatically  */\n\t\tprimary = copy_job->is_move ? g_strdup (_(\"You cannot move a file over itself.\"))\n\t\t\t\t\t    : g_strdup (_(\"You cannot copy a file over itself.\"));\n\t\tsecondary = g_strdup (_(\"The source file would be overwritten by the destination.\"));\n\t\t\n\t\tresponse = run_warning (job,\n\t\t\t\t\tprimary,\n\t\t\t\t\tsecondary,\n\t\t\t\t\tNULL,\n\t\t\t\t\t(source_info->num_files - transfer_info->num_files) > 1,\n\t\t\t\t\tGTK_STOCK_CANCEL, SKIP_ALL, SKIP,\n\t\t\t\t\tNULL);\n\n\t\tif (response == 0 || response == GTK_RESPONSE_DELETE_EVENT) {\n\t\t\tabort_job (job);\n\t\t} else if (response == 1) { /* skip all */\n\t\t\tjob->skip_all_error = TRUE;\n\t\t} else if (response == 2) { /* skip */\n\t\t\t/* do nothing */\n\t\t} else {\n\t\t\tg_assert_not_reached ();\n\t\t}\n\n\t\tgoto out;\n\t}\n\n\t\n retry:\n\t\n\terror = NULL;\n\tflags = G_FILE_COPY_NOFOLLOW_SYMLINKS;\n\tif (overwrite) {\n\t\tflags |= G_FILE_COPY_OVERWRITE;\n\t}\n\tif (readonly_source_fs) {\n\t\tflags |= G_FILE_COPY_TARGET_DEFAULT_PERMS;\n\t}\n\n\tpdata.job = copy_job;\n\tpdata.last_size = 0;\n\tpdata.source_info = source_info;\n\tpdata.transfer_info = transfer_info;\n\n\tif (copy_job->is_move) {\n\t\tres = g_file_move (src, dest,\n\t\t\t\t   flags,\n\t\t\t\t   job->cancellable,\n\t\t\t\t   copy_file_progress_callback,\n\t\t\t\t   &pdata,\n\t\t\t\t   &error);\n\t} else {\n\t\tres = g_file_copy (src, dest,\n\t\t\t\t   flags,\n\t\t\t\t   job->cancellable,\n\t\t\t\t   copy_file_progress_callback,\n\t\t\t\t   &pdata,\n\t\t\t\t   &error);\n\t}\n\t\n\tif (res) {\n\t\ttransfer_info->num_files ++;\n\t\treport_copy_progress (copy_job, source_info, transfer_info);\n\n\t\tif (debuting_files) {\n\t\t\tif (copy_job->is_move) {\n\t\t\t\tnautilus_file_changes_queue_schedule_metadata_move (src, dest);\n\t\t\t} else {\n\t\t\t\tnautilus_file_changes_queue_schedule_metadata_copy (src, dest);\n\t\t\t}\n\t\t\tif (position) {\n\t\t\t\tnautilus_file_changes_queue_schedule_position_set (dest, *position, job->screen_num);\n\t\t\t} else {\n\t\t\t\tnautilus_file_changes_queue_schedule_position_remove (dest);\n\t\t\t}\n\t\t\t\n\t\t\tg_hash_table_replace (debuting_files, g_object_ref (dest), GINT_TO_POINTER (TRUE));\n\t\t}\n\t\tif (copy_job->is_move) {\n\t\t\tnautilus_file_changes_queue_file_moved (src, dest);\n\t\t} else {\n\t\t\tnautilus_file_changes_queue_file_added (dest);\n\t\t}\n\t\tg_object_unref (dest);\n\t\treturn;\n\t}\n\n\tif (!handled_invalid_filename &&\n\t    IS_IO_ERROR (error, INVALID_FILENAME)) {\n\t\thandled_invalid_filename = TRUE;\n\n\t\tg_assert (*dest_fs_type == NULL);\n\t\t*dest_fs_type = query_fs_type (dest_dir, job->cancellable);\n\n\t\tif (unique_names) {\n\t\t\tnew_dest = get_unique_target_file (src, dest_dir, same_fs, *dest_fs_type, unique_name_nr);\n\t\t} else {\n\t\t\tnew_dest = get_target_file (src, dest_dir, *dest_fs_type, same_fs);\n\t\t}\n\n\t\tif (!g_file_equal (dest, new_dest)) {\n\t\t\tg_object_unref (dest);\n\t\t\tdest = new_dest;\n\n\t\t\tg_error_free (error);\n\t\t\tgoto retry;\n\t\t} else {\n\t\t\tg_object_unref (new_dest);\n\t\t}\n\t}\n\n\t/* Conflict */\n\tif (!overwrite &&\n\t    IS_IO_ERROR (error, EXISTS)) {\n\t\tgboolean is_merge;\n\n\t\tif (unique_names) {\n\t\t\tg_object_unref (dest);\n\t\t\tdest = get_unique_target_file (src, dest_dir, same_fs, *dest_fs_type, unique_name_nr++);\n\t\t\tg_error_free (error);\n\t\t\tgoto retry;\n\t\t}\n\t\t\n\t\tis_merge = FALSE;\n\t\tif (is_dir (dest)) {\n\t\t\tif (is_dir (src)) {\n\t\t\t\tis_merge = TRUE;\n\t\t\t\tprimary = f (_(\"A folder named \\\"%B\\\" already exists.  Do you want to merge the source folder?\"), \n\t\t\t\t\t     dest);\n\t\t\t\tsecondary = f (_(\"The source folder already exists in \\\"%B\\\".  \"\n\t\t\t\t\t\t \"Merging will ask for confirmation before replacing any files in the folder that conflict with the files being copied.\"), \n\t\t\t\t\t       dest_dir);\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\tprimary = f (_(\"A folder named \\\"%B\\\" already exists.  Do you want to replace it?\"), \n\t\t\t\t\t\t\t    dest);\n\t\t\t\tsecondary = f (_(\"The folder already exists in \\\"%F\\\".  \"\n\t\t\t\t\t\t \"Replacing it will remove all files in the folder.\"), \n\t\t\t\t\t       dest_dir);\n\t\t\t}\n\t\t} else {\n\t\t\tprimary = f (_(\"A file named \\\"%B\\\" already exists.  Do you want to replace it?\"), \n\t\t\t\t     dest);\n\t\t\tsecondary = f (_(\"The file already exists in \\\"%F\\\".  \"\n\t\t\t\t\t \"Replacing it will overwrite its content.\"), \n\t\t\t\t       dest_dir);\n\t\t}\n\n\t\tif ((is_merge && job->merge_all) ||\n\t\t    (!is_merge && job->replace_all)) {\n\t\t\tg_free (primary);\n\t\t\tg_free (secondary);\n\t\t\tg_error_free (error);\n\t\t\t\n\t\t\toverwrite = TRUE;\n\t\t\tgoto retry;\n\t\t}\n\n\t\tif (job->skip_all_conflict) {\n\t\t\tg_free (primary);\n\t\t\tg_free (secondary);\n\t\t\tg_error_free (error);\n\t\t\t\n\t\t\tgoto out;\n\t\t}\n\t\t\n\t\tresponse = run_warning (job,\n\t\t\t\t\tprimary,\n\t\t\t\t\tsecondary,\n\t\t\t\t\tNULL,\n\t\t\t\t\t(source_info->num_files - transfer_info->num_files) > 1,\n\t\t\t\t\tGTK_STOCK_CANCEL,\n\t\t\t\t\tSKIP_ALL,\n\t\t\t\t\tis_merge?MERGE_ALL:REPLACE_ALL,\n\t\t\t\t\tSKIP,\n\t\t\t\t\tis_merge?MERGE:REPLACE,\n\t\t\t\t\tNULL);\n\t\t\n\t\tg_error_free (error);\n\t\t\n\t\tif (response == 0 || response == GTK_RESPONSE_DELETE_EVENT) {\n\t\t\tabort_job (job);\n\t\t} else if (response == 1 || response == 3) { /* skip all / skip */\n\t\t\tif (response == 1) {\n\t\t\t\tjob->skip_all_conflict = TRUE;\n\t\t\t}\n\t\t} else if (response == 2 || response == 4) { /* merge/replace all  / merge/replace*/\n\t\t\tif (response == 2) {\n\t\t\t\tif (is_merge) {\n\t\t\t\t\tjob->merge_all = TRUE;\n\t\t\t\t} else {\n\t\t\t\t\tjob->replace_all = TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\toverwrite = TRUE;\n\t\t\tgoto retry;\n\t\t} else {\n\t\t\tg_assert_not_reached ();\n\t\t}\n\t}\n\t\n\telse if (overwrite &&\n\t\t IS_IO_ERROR (error, IS_DIRECTORY)) {\n\n\t\tg_error_free (error);\n\t\t\n\t\tif (remove_target_recursively (job, src, dest, dest)) {\n\t\t\tgoto retry;\n\t\t}\n\t}\n\t\n\t/* Needs to recurse */\n\telse if (IS_IO_ERROR (error, WOULD_RECURSE) ||\n\t\t IS_IO_ERROR (error, WOULD_MERGE)) {\n\t\tis_merge = error->code == G_IO_ERROR_WOULD_MERGE;\n\t\twould_recurse = error->code == G_IO_ERROR_WOULD_RECURSE;\n\t\tg_error_free (error);\n\n\t\tif (overwrite && would_recurse) {\n\t\t\terror = NULL;\n\t\t\t\n\t\t\t/* Copying a dir onto file, first remove the file */\n\t\t\tif (!g_file_delete (dest, job->cancellable, &error) &&\n\t\t\t    !IS_IO_ERROR (error, NOT_FOUND)) {\n\t\t\t\tif (job->skip_all_error) {\n\t\t\t\t\tg_error_free (error);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (copy_job->is_move) {\n\t\t\t\t\tprimary = f (_(\"Error while moving \\\"%B\\\".\"), src);\n\t\t\t\t} else {\n\t\t\t\t\tprimary = f (_(\"Error while copying \\\"%B\\\".\"), src);\n\t\t\t\t}\n\t\t\t\tsecondary = f (_(\"Could not remove the already existing file with the same name in %F.\"), dest_dir);\n\t\t\t\tdetails = error->message;\n\n\t\t\t\t/* setting TRUE on show_all here, as we could have\n\t\t\t\t * another error on the same file later.\n\t\t\t\t */\n\t\t\t\tresponse = run_warning (job,\n\t\t\t\t\t\t\tprimary,\n\t\t\t\t\t\t\tsecondary,\n\t\t\t\t\t\t\tdetails,\n\t\t\t\t\t\t\tTRUE,\n\t\t\t\t\t\t\tGTK_STOCK_CANCEL, SKIP_ALL, SKIP,\n\t\t\t\t\t\t\tNULL);\n\t\t\t\t\n\t\t\t\tg_error_free (error);\n\t\t\t\t\n\t\t\t\tif (response == 0 || response == GTK_RESPONSE_DELETE_EVENT) {\n\t\t\t\t\tabort_job (job);\n\t\t\t\t} else if (response == 1) { /* skip all */\n\t\t\t\t\tjob->skip_all_error = TRUE;\n\t\t\t\t} else if (response == 2) { /* skip */\n\t\t\t\t\t/* do nothing */\n\t\t\t\t} else {\n\t\t\t\t\tg_assert_not_reached ();\n\t\t\t\t}\n\t\t\t\tgoto out;\n\t\t\t\t\n\t\t\t}\n\t\t\tif (error) {\n\t\t\t\tg_error_free (error);\n\t\t\t\terror = NULL;\n\t\t\t}\n\t\t\tif (debuting_files) { /* Only remove metadata for toplevel items */\n\t\t\t\tnautilus_file_changes_queue_schedule_metadata_remove (dest);\n\t\t\t}\n\t\t\tnautilus_file_changes_queue_file_removed (dest);\n\t\t}\n\n\t\tif (is_merge) {\n\t\t\t/* On merge we now write in the target directory, which may not\n\t\t\t   be in the same directory as the source, even if the parent is\n\t\t\t   (if the merged directory is a mountpoint). This could cause\n\t\t\t   problems as we then don't transcode filenames.\n\t\t\t   We just set same_fs to FALSE which is safe but a bit slower. */\n\t\t\tsame_fs = FALSE;\n\t\t}\n\t\t\n\t\tif (!copy_move_directory (copy_job, src, &dest, same_fs,\n\t\t\t\t\t  would_recurse, dest_fs_type,\n\t\t\t\t\t  source_info, transfer_info,\n\t\t\t\t\t  debuting_files, skipped_file,\n\t\t\t\t\t  readonly_source_fs)) {\n\t\t\t/* destination changed, since it was an invalid file name */\n\t\t\tg_assert (*dest_fs_type != NULL);\n\t\t\thandled_invalid_filename = TRUE;\n\t\t\tgoto retry;\n\t\t}\n\n\t\tg_object_unref (dest);\n\t\treturn;\n\t}\n\t\n\telse if (IS_IO_ERROR (error, CANCELLED)) {\n\t\tg_error_free (error);\n\t}\n\t\n\t/* Other error */\n\telse {\n\t\tif (job->skip_all_error) {\n\t\t\tg_error_free (error);\n\t\t\tgoto out;\n\t\t}\n\t\tprimary = f (_(\"Error while copying \\\"%B\\\".\"), src);\n\t\tsecondary = f (_(\"There was an error copying the file into %F.\"), dest_dir);\n\t\tdetails = error->message;\n\t\t\n\t\tresponse = run_warning (job,\n\t\t\t\t\tprimary,\n\t\t\t\t\tsecondary,\n\t\t\t\t\tdetails,\n\t\t\t\t\t(source_info->num_files - transfer_info->num_files) > 1,\n\t\t\t\t\tGTK_STOCK_CANCEL, SKIP_ALL, SKIP,\n\t\t\t\t\tNULL);\n\n\t\tg_error_free (error);\n\t\t\n\t\tif (response == 0 || response == GTK_RESPONSE_DELETE_EVENT) {\n\t\t\tabort_job (job);\n\t\t} else if (response == 1) { /* skip all */\n\t\t\tjob->skip_all_error = TRUE;\n\t\t} else if (response == 2) { /* skip */\n\t\t\t/* do nothing */\n\t\t} else {\n\t\t\tg_assert_not_reached ();\n\t\t}\n\t}\n out:\n\t*skipped_file = TRUE; /* Or aborted, but same-same */\n\tg_object_unref (dest);\n}",
        "target": 1
    },
    {
        "func": "copy_job (GIOSchedulerJob *io_job,\n\t  GCancellable *cancellable,\n\t  gpointer user_data)\n{\n\tCopyMoveJob *job;\n\tCommonJob *common;\n\tSourceInfo source_info;\n\tTransferInfo transfer_info;\n\tchar *dest_fs_id;\n\tGFile *dest;\n\n\tjob = user_data;\n\tcommon = &job->common;\n\tcommon->io_job = io_job;\n\n\tdest_fs_id = NULL;\n\t\n\tnautilus_progress_info_start (job->common.progress);\n\t\n\tscan_sources (job->files,\n\t\t      &source_info,\n\t\t      common,\n\t\t      OP_KIND_COPY);\n\tif (job_aborted (common)) {\n\t\tgoto aborted;\n\t}\n\n\tif (job->destination) {\n\t\tdest = g_object_ref (job->destination);\n\t} else {\n\t\t/* Duplication, no dest,\n\t\t * use source for free size, etc\n\t\t */\n\t\tdest = g_file_get_parent (job->files->data);\n\t}\n\t\n\tverify_destination (&job->common,\n\t\t\t    dest,\n\t\t\t    &dest_fs_id,\n\t\t\t    source_info.num_bytes);\n\tg_object_unref (dest);\n\tif (job_aborted (common)) {\n\t\tgoto aborted;\n\t}\n\n\tg_timer_start (job->common.time);\n\t\n\tmemset (&transfer_info, 0, sizeof (transfer_info));\n\tcopy_files (job,\n\t\t    dest_fs_id,\n\t\t    &source_info, &transfer_info);\n\t\n aborted:\n\t\n\tg_free (dest_fs_id);\n\t\n\tg_io_scheduler_job_send_to_mainloop_async (io_job,\n\t\t\t\t\t\t   copy_job_done,\n\t\t\t\t\t\t   job,\n\t\t\t\t\t\t   NULL);\n\n\treturn FALSE;\n}",
        "target": 1
    },
    {
        "func": "is_link_trusted (NautilusFile *file,\n\t\t gboolean is_launcher)\n{\n\tgboolean res;\n\t\n\tif (!is_launcher) {\n\t\treturn TRUE;\n\t}\n\t\n\tif (nautilus_file_can_execute (file)) {\n\t\treturn TRUE;\n\t}\n\n\tres = FALSE;\n\t\n\tif (nautilus_file_is_local (file)) {\n\t\tconst char * const * data_dirs; \n\t\tchar *uri, *path;\n\t\tint i;\n\t\t\t\n\t\tdata_dirs = g_get_system_data_dirs ();\n\t\t\n\t\tpath = NULL;\n\t\turi = nautilus_file_get_uri (file);\n\t\tif (uri) {\n\t\t\tpath = g_filename_from_uri (uri, NULL, NULL);\n\t\t\tg_free (uri);\n\t\t}\n\n\t\tfor (i = 0; path != NULL && data_dirs[i] != NULL; i++) {\n\t\t\tif (g_str_has_prefix (path, data_dirs[i])) {\n\t\t\t\tres = TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tg_free (path);\n\t}\n\t\n\t\n\treturn res;\n}",
        "target": 1
    },
    {
        "func": "nautilus_link_get_link_info_given_file_contents (const char  *file_contents,\n\t\t\t\t\t\t int          link_file_size,\n\t\t\t\t\t\t const char  *file_uri,\n\t\t\t\t\t\t char       **uri,\n\t\t\t\t\t\t char       **name,\n\t\t\t\t\t\t char       **icon,\n\t\t\t\t\t\t gboolean    *is_launcher,\n\t\t\t\t\t\t gboolean    *is_foreign)\n{\n\tGKeyFile *key_file;\n\tchar *type;\n\tchar **only_show_in;\n\tchar **not_show_in;\n\n\tif (!is_link_data (file_contents, link_file_size)) {\n\t\treturn;\n\t}\n\n\tkey_file = g_key_file_new ();\n\tif (!g_key_file_load_from_data (key_file,\n\t\t\t\t\tfile_contents,\n\t\t\t\t\tlink_file_size,\n\t\t\t\t\tG_KEY_FILE_NONE,\n\t\t\t\t\tNULL)) {\n\t\tg_key_file_free (key_file);\n\t\treturn; \n\t}\n\n\t*uri = nautilus_link_get_link_uri_from_desktop (key_file, file_uri);\n\t*name = nautilus_link_get_link_name_from_desktop (key_file);\n\t*icon = nautilus_link_get_link_icon_from_desktop (key_file);\n\n\t*is_launcher = FALSE;\n\ttype = g_key_file_get_string (key_file, MAIN_GROUP, \"Type\", NULL);\n\tif (g_strcmp0 (type, \"Application\") == 0 &&\n\t    g_key_file_has_key (key_file, MAIN_GROUP, \"Exec\", NULL)) {\n\t\t*is_launcher = TRUE;\n\t}\n\tg_free (type);\n\n\t*is_foreign = FALSE;\n\tonly_show_in = g_key_file_get_string_list (key_file, MAIN_GROUP,\n\t\t\t\t\t\t   \"OnlyShowIn\", NULL, NULL);\n\tif (only_show_in && !string_array_contains (only_show_in, \"GNOME\")) {\n\t\t*is_foreign = TRUE;\n\t}\n\tg_strfreev (only_show_in);\n\n\tnot_show_in = g_key_file_get_string_list (key_file, MAIN_GROUP,\n\t\t\t\t\t\t  \"NotShowIn\", NULL, NULL);\n\tif (not_show_in && string_array_contains (not_show_in, \"GNOME\")) {\n\t\t*is_foreign = TRUE;\n\t}\n\tg_strfreev (not_show_in);\n\n\tg_key_file_free (key_file);\n}",
        "target": 1
    },
    {
        "func": "is_link_data (const char *file_contents, int file_size)\n{\n\tchar *mimetype;\n\tgboolean res;\n\n\tmimetype = g_content_type_guess (NULL, file_contents, file_size, NULL);\n\tres =  is_link_mime_type (mimetype);\n\tg_free (mimetype);\n\treturn res;\n}",
        "target": 1
    },
    {
        "func": "static int fuse_ioctl_copy_user(struct page **pages, struct iovec *iov,\n\t\t\tunsigned int nr_segs, size_t bytes, bool to_user)\n{\n\tstruct iov_iter ii;\n\tint page_idx = 0;\n\n\tif (!bytes)\n\t\treturn 0;\n\n\tiov_iter_init(&ii, iov, nr_segs, bytes, 0);\n\n\twhile (iov_iter_count(&ii)) {\n\t\tstruct page *page = pages[page_idx++];\n\t\tsize_t todo = min_t(size_t, PAGE_SIZE, iov_iter_count(&ii));\n\t\tvoid *kaddr, *map;\n\n\t\tkaddr = map = kmap(page);\n\n\t\twhile (todo) {\n\t\t\tchar __user *uaddr = ii.iov->iov_base + ii.iov_offset;\n\t\t\tsize_t iov_len = ii.iov->iov_len - ii.iov_offset;\n\t\t\tsize_t copy = min(todo, iov_len);\n\t\t\tsize_t left;\n\n\t\t\tif (!to_user)\n\t\t\t\tleft = copy_from_user(kaddr, uaddr, copy);\n\t\t\telse\n\t\t\t\tleft = copy_to_user(uaddr, kaddr, copy);\n\n\t\t\tif (unlikely(left))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tiov_iter_advance(&ii, copy);\n\t\t\ttodo -= copy;\n\t\t\tkaddr += copy;\n\t\t}\n\n\t\tkunmap(map);\n\t}\n\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "int main(int argc, char *argv[])\n{\n\tint opt;\n\tchar *line;\n\n\tprogname = basename(argv[0]);\n\n#if POSIXLY_CORRECT\n\tcmd_line_options = POSIXLY_CMD_LINE_OPTIONS;\n#else\n\tif (getenv(POSIXLY_CORRECT_STR))\n\t\tposixly_correct = 1;\n\tif (!posixly_correct)\n\t\tcmd_line_options = CMD_LINE_OPTIONS;\n\telse\n\t\tcmd_line_options = POSIXLY_CMD_LINE_OPTIONS;\n#endif\n\n\tsetlocale(LC_CTYPE, \"\");\n\tsetlocale(LC_MESSAGES, \"\");\n\tbindtextdomain(PACKAGE, LOCALEDIR);\n\ttextdomain(PACKAGE);\n\n\t/* Align `#effective:' comments to column 40 for tty's */\n\tif (!posixly_correct && isatty(fileno(stdout)))\n\t\tprint_options |= TEXT_SMART_INDENT;\n\n\twhile ((opt = getopt_long(argc, argv, cmd_line_options,\n\t\t                 long_options, NULL)) != -1) {\n\t\tswitch (opt) {\n\t\t\tcase 'a':  /* acl only */\n\t\t\t\tif (posixly_correct)\n\t\t\t\t\tgoto synopsis;\n\t\t\t\topt_print_acl = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 'd':  /* default acl only */\n\t\t\t\topt_print_default_acl = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 'c':  /* no comments */\n\t\t\t\tif (posixly_correct)\n\t\t\t\t\tgoto synopsis;\n\t\t\t\topt_comments = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase 'e':  /* all #effective comments */\n\t\t\t\tif (posixly_correct)\n\t\t\t\t\tgoto synopsis;\n\t\t\t\tprint_options |= TEXT_ALL_EFFECTIVE;\n\t\t\t\tbreak;\n\n\t\t\tcase 'E':  /* no #effective comments */\n\t\t\t\tif (posixly_correct)\n\t\t\t\t\tgoto synopsis;\n\t\t\t\tprint_options &= ~(TEXT_SOME_EFFECTIVE |\n\t\t\t\t                   TEXT_ALL_EFFECTIVE);\n\t\t\t\tbreak;\n\n\t\t\tcase 'R':  /* recursive */\n\t\t\t\tif (posixly_correct)\n\t\t\t\t\tgoto synopsis;\n\t\t\t\twalk_flags |= WALK_TREE_RECURSIVE;\n\t\t\t\tbreak;\n\n\t\t\tcase 'L':  /* follow all symlinks */\n\t\t\t\tif (posixly_correct)\n\t\t\t\t\tgoto synopsis;\n\t\t\t\twalk_flags |= WALK_TREE_LOGICAL;\n\t\t\t\twalk_flags &= ~WALK_TREE_PHYSICAL;\n\t\t\t\tbreak;\n\n\t\t\tcase 'P':  /* skip all symlinks */\n\t\t\t\tif (posixly_correct)\n\t\t\t\t\tgoto synopsis;\n\t\t\t\twalk_flags |= WALK_TREE_PHYSICAL;\n\t\t\t\twalk_flags &= ~WALK_TREE_LOGICAL;\n\t\t\t\tbreak;\n\n\t\t\tcase 's':  /* skip files with only base entries */\n\t\t\t\tif (posixly_correct)\n\t\t\t\t\tgoto synopsis;\n\t\t\t\topt_skip_base = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 'p':\n\t\t\t\tif (posixly_correct)\n\t\t\t\t\tgoto synopsis;\n\t\t\t\topt_strip_leading_slash = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase 't':\n\t\t\t\tif (posixly_correct)\n\t\t\t\t\tgoto synopsis;\n\t\t\t\topt_tabular = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 'n':  /* numeric */\n\t\t\t\topt_numeric = 1;\n\t\t\t\tprint_options |= TEXT_NUMERIC_IDS;\n\t\t\t\tbreak;\n\n\t\t\tcase 'v':  /* print version */\n\t\t\t\tprintf(\"%s \" VERSION \"\\n\", progname);\n\t\t\t\treturn 0;\n\n\t\t\tcase 'h':  /* help */\n\t\t\t\thelp();\n\t\t\t\treturn 0;\n\n\t\t\tcase ':':  /* option missing */\n\t\t\tcase '?':  /* unknown option */\n\t\t\tdefault:\n\t\t\t\tgoto synopsis;\n\t\t}\n\t}\n\n\tif (!(opt_print_acl || opt_print_default_acl)) {\n\t\topt_print_acl = 1;\n\t\tif (!posixly_correct)\n\t\t\topt_print_default_acl = 1;\n\t}\n\t\t\n\tif ((optind == argc) && !posixly_correct)\n\t\tgoto synopsis;\n\n\tdo {\n\t\tif (optind == argc ||\n\t\t    strcmp(argv[optind], \"-\") == 0) {\n\t\t\twhile ((line = next_line(stdin)) != NULL) {\n\t\t\t\tif (*line == '\\0')\n\t\t\t\t\tcontinue;\n\n\t\t\t\thad_errors += walk_tree(line, walk_flags, 0,\n\t\t\t\t\t\t\tdo_print, NULL);\n\t\t\t}\n\t\t\tif (!feof(stdin)) {\n\t\t\t\tfprintf(stderr, _(\"%s: Standard input: %s\\n\"),\n\t\t\t\t        progname, strerror(errno));\n\t\t\t\thad_errors++;\n\t\t\t}\n\t\t} else\n\t\t\thad_errors += walk_tree(argv[optind], walk_flags, 0,\n\t\t\t\t\t\tdo_print, NULL);\n\t\toptind++;\n\t} while (optind < argc);\n\n\treturn had_errors ? 1 : 0;\n\nsynopsis:\n\tfprintf(stderr, _(\"Usage: %s [-%s] file ...\\n\"),\n\t        progname, cmd_line_options);\n\tfprintf(stderr, _(\"Try `%s --help' for more information.\\n\"),\n\t\tprogname);\n\treturn 2;\n}",
        "target": 1
    },
    {
        "func": "int unlzw(in, out)\n    int in, out;    /* input and output file descriptors */\n{\n    REG2   char_type  *stackp;\n    REG3   code_int   code;\n    REG4   int        finchar;\n    REG5   code_int   oldcode;\n    REG6   code_int   incode;\n    REG7   long       inbits;\n    REG8   long       posbits;\n    REG9   int        outpos;\n/*  REG10  int        insize; (global) */\n    REG11  unsigned   bitmask;\n    REG12  code_int   free_ent;\n    REG13  code_int   maxcode;\n    REG14  code_int   maxmaxcode;\n    REG15  int        n_bits;\n    REG16  int        rsize;\n\n#ifdef MAXSEG_64K\n    tab_prefix[0] = tab_prefix0;\n    tab_prefix[1] = tab_prefix1;\n#endif\n    maxbits = get_byte();\n    block_mode = maxbits & BLOCK_MODE;\n    if ((maxbits & LZW_RESERVED) != 0) {\n\tWARN((stderr, \"\\n%s: %s: warning, unknown flags 0x%x\\n\",\n\t      program_name, ifname, maxbits & LZW_RESERVED));\n    }\n    maxbits &= BIT_MASK;\n    maxmaxcode = MAXCODE(maxbits);\n\n    if (maxbits > BITS) {\n\tfprintf(stderr,\n\t\t\"\\n%s: %s: compressed with %d bits, can only handle %d bits\\n\",\n\t\tprogram_name, ifname, maxbits, BITS);\n\texit_code = ERROR;\n\treturn ERROR;\n    }\n    rsize = insize;\n    maxcode = MAXCODE(n_bits = INIT_BITS)-1;\n    bitmask = (1<<n_bits)-1;\n    oldcode = -1;\n    finchar = 0;\n    outpos = 0;\n    posbits = inptr<<3;\n\n    free_ent = ((block_mode) ? FIRST : 256);\n\n    clear_tab_prefixof(); /* Initialize the first 256 entries in the table. */\n\n    for (code = 255 ; code >= 0 ; --code) {\n\ttab_suffixof(code) = (char_type)code;\n    }\n    do {\n\tREG1 int i;\n\tint  e;\n\tint  o;\n\n    resetbuf:\n\te = insize-(o = (posbits>>3));\n\n\tfor (i = 0 ; i < e ; ++i) {\n\t    inbuf[i] = inbuf[i+o];\n\t}\n\tinsize = e;\n\tposbits = 0;\n\n\tif (insize < INBUF_EXTRA) {\n\t    rsize = read_buffer (in, (char *) inbuf + insize, INBUFSIZ);\n\t    if (rsize == -1) {\n\t\tread_error();\n\t    }\n\t    insize += rsize;\n\t    bytes_in += (off_t)rsize;\n\t}\n\tinbits = ((rsize != 0) ? ((long)insize - insize%n_bits)<<3 :\n\t\t  ((long)insize<<3)-(n_bits-1));\n\n\twhile (inbits > posbits) {\n\t    if (free_ent > maxcode) {\n\t\tposbits = ((posbits-1) +\n\t\t\t   ((n_bits<<3)-(posbits-1+(n_bits<<3))%(n_bits<<3)));\n\t\t++n_bits;\n\t\tif (n_bits == maxbits) {\n\t\t    maxcode = maxmaxcode;\n\t\t} else {\n\t\t    maxcode = MAXCODE(n_bits)-1;\n\t\t}\n\t\tbitmask = (1<<n_bits)-1;\n\t\tgoto resetbuf;\n\t    }\n\t    input(inbuf,posbits,code,n_bits,bitmask);\n\t    Tracev((stderr, \"%d \", code));\n\n\t    if (oldcode == -1) {\n\t\tif (256 <= code)\n\t\t  gzip_error (\"corrupt input.\");\n\t\toutbuf[outpos++] = (char_type)(finchar = (int)(oldcode=code));\n\t\tcontinue;\n\t    }\n\t    if (code == CLEAR && block_mode) {\n\t\tclear_tab_prefixof();\n\t\tfree_ent = FIRST - 1;\n\t\tposbits = ((posbits-1) +\n\t\t\t   ((n_bits<<3)-(posbits-1+(n_bits<<3))%(n_bits<<3)));\n\t\tmaxcode = MAXCODE(n_bits = INIT_BITS)-1;\n\t\tbitmask = (1<<n_bits)-1;\n\t\tgoto resetbuf;\n\t    }\n\t    incode = code;\n\t    stackp = de_stack;\n\n\t    if (code >= free_ent) { /* Special case for KwKwK string. */\n\t\tif (code > free_ent) {\n#ifdef DEBUG\n\t\t    char_type *p;\n\n\t\t    posbits -= n_bits;\n\t\t    p = &inbuf[posbits>>3];\n\t\t    fprintf(stderr,\n\t\t\t    \"code:%ld free_ent:%ld n_bits:%d insize:%u\\n\",\n\t\t\t    code, free_ent, n_bits, insize);\n\t\t    fprintf(stderr,\n\t\t\t    \"posbits:%ld inbuf:%02X %02X %02X %02X %02X\\n\",\n\t\t\t    posbits, p[-1],p[0],p[1],p[2],p[3]);\n#endif\n\t\t    if (!test && outpos > 0) {\n\t\t\twrite_buf(out, (char*)outbuf, outpos);\n\t\t\tbytes_out += (off_t)outpos;\n\t\t    }\n\t\t    gzip_error (to_stdout\n\t\t\t\t? \"corrupt input.\"\n\t\t\t\t: \"corrupt input. Use zcat to recover some data.\");\n\t\t}\n\t\t*--stackp = (char_type)finchar;\n\t\tcode = oldcode;\n\t    }\n\n\t    while ((cmp_code_int)code >= (cmp_code_int)256) {\n\t\t/* Generate output characters in reverse order */\n\t\t*--stackp = tab_suffixof(code);\n\t\tcode = tab_prefixof(code);\n\t    }\n\t    *--stackp =\t(char_type)(finchar = tab_suffixof(code));\n\n\t    /* And put them out in forward order */\n\t    {\n\t\tREG1 int\ti;\n\n\t\tif (outpos+(i = (de_stack-stackp)) >= OUTBUFSIZ) {\n\t\t    do {\n\t\t\tif (i > OUTBUFSIZ-outpos) i = OUTBUFSIZ-outpos;\n\n\t\t\tif (i > 0) {\n\t\t\t    memcpy(outbuf+outpos, stackp, i);\n\t\t\t    outpos += i;\n\t\t\t}\n\t\t\tif (outpos >= OUTBUFSIZ) {\n\t\t\t    if (!test) {\n\t\t\t\twrite_buf(out, (char*)outbuf, outpos);\n\t\t\t\tbytes_out += (off_t)outpos;\n\t\t\t    }\n\t\t\t    outpos = 0;\n\t\t\t}\n\t\t\tstackp+= i;\n\t\t    } while ((i = (de_stack-stackp)) > 0);\n\t\t} else {\n\t\t    memcpy(outbuf+outpos, stackp, i);\n\t\t    outpos += i;\n\t\t}\n\t    }\n\n\t    if ((code = free_ent) < maxmaxcode) { /* Generate the new entry. */\n\n\t\ttab_prefixof(code) = (unsigned short)oldcode;\n\t\ttab_suffixof(code) = (char_type)finchar;\n\t\tfree_ent = code+1;\n\t    }\n\t    oldcode = incode;\t/* Remember previous code.\t*/\n\t}\n    } while (rsize != 0);\n\n    if (!test && outpos > 0) {\n\twrite_buf(out, (char*)outbuf, outpos);\n\tbytes_out += (off_t)outpos;\n    }\n    return OK;\n}",
        "target": 1
    },
    {
        "func": "_hb_ot_layout_init (hb_face_t *face)\n{\n  hb_ot_layout_t *layout = &face->ot_layout;\n\n  layout->gdef_blob = Sanitizer<GDEF>::sanitize (hb_face_get_table (face, HB_OT_TAG_GDEF));\n  layout->gdef = &Sanitizer<GDEF>::lock_instance (layout->gdef_blob);\n\n  layout->gsub_blob = Sanitizer<GSUB>::sanitize (hb_face_get_table (face, HB_OT_TAG_GSUB));\n  layout->gsub = &Sanitizer<GSUB>::lock_instance (layout->gsub_blob);\n\n  layout->gpos_blob = Sanitizer<GPOS>::sanitize (hb_face_get_table (face, HB_OT_TAG_GPOS));\n  layout->gpos = &Sanitizer<GPOS>::lock_instance (layout->gpos_blob);\n}",
        "target": 1
    },
    {
        "func": "hb_ot_layout_build_glyph_classes (hb_face_t      *face,\n\t\t\t\t  uint16_t        num_total_glyphs,\n\t\t\t\t  hb_codepoint_t *glyphs,\n\t\t\t\t  unsigned char  *klasses,\n\t\t\t\t  uint16_t        count)\n{\n  if (HB_OBJECT_IS_INERT (face))\n    return;\n\n  hb_ot_layout_t *layout = &face->ot_layout;\n\n  if (HB_UNLIKELY (!count || !glyphs || !klasses))\n    return;\n\n  if (layout->new_gdef.len == 0) {\n    layout->new_gdef.klasses = (unsigned char *) calloc (num_total_glyphs, sizeof (unsigned char));\n    layout->new_gdef.len = count;\n  }\n\n  for (unsigned int i = 0; i < count; i++)\n    _hb_ot_layout_set_glyph_class (face, glyphs[i], (hb_ot_layout_glyph_class_t) klasses[i]);\n}",
        "target": 1
    },
    {
        "func": "static int usb_host_handle_control(USBHostDevice *s, USBPacket *p)\n{\n    struct usbdevfs_urb *urb;\n    AsyncURB *aurb;\n    int ret, value, index;\n\n    /* \n     * Process certain standard device requests.\n     * These are infrequent and are processed synchronously.\n     */\n    value = le16_to_cpu(s->ctrl.req.wValue);\n    index = le16_to_cpu(s->ctrl.req.wIndex);\n\n    dprintf(\"husb: ctrl type 0x%x req 0x%x val 0x%x index %u len %u\\n\",\n        s->ctrl.req.bRequestType, s->ctrl.req.bRequest, value, index, \n        s->ctrl.len);\n\n    if (s->ctrl.req.bRequestType == 0) {\n        switch (s->ctrl.req.bRequest) {\n        case USB_REQ_SET_ADDRESS:\n            return usb_host_set_address(s, value);\n\n        case USB_REQ_SET_CONFIGURATION:\n            return usb_host_set_config(s, value & 0xff);\n        }\n    }\n\n    if (s->ctrl.req.bRequestType == 1 &&\n                  s->ctrl.req.bRequest == USB_REQ_SET_INTERFACE)\n        return usb_host_set_interface(s, index, value);\n\n    /* The rest are asynchronous */\n\n    aurb = async_alloc();\n    aurb->hdev   = s;\n    aurb->packet = p;\n\n    /* \n     * Setup ctrl transfer.\n     *\n     * s->ctrl is layed out such that data buffer immediately follows\n     * 'req' struct which is exactly what usbdevfs expects.\n     */ \n    urb = &aurb->urb;\n\n    urb->type     = USBDEVFS_URB_TYPE_CONTROL;\n    urb->endpoint = p->devep;\n\n    urb->buffer        = &s->ctrl.req;\n    urb->buffer_length = 8 + s->ctrl.len;\n\n    urb->usercontext = s;\n\n    ret = ioctl(s->fd, USBDEVFS_SUBMITURB, urb);\n\n    dprintf(\"husb: submit ctrl. len %u aurb %p\\n\", urb->buffer_length, aurb);\n\n    if (ret < 0) {\n        dprintf(\"husb: submit failed. errno %d\\n\", errno);\n        async_free(aurb);\n\n        switch(errno) {\n        case ETIMEDOUT:\n            return USB_RET_NAK;\n        case EPIPE:\n        default:\n            return USB_RET_STALL;\n        }\n    }\n\n    usb_defer_packet(p, async_cancel, aurb);\n    return USB_RET_ASYNC;\n}",
        "target": 1
    },
    {
        "func": "gs_manager_create_window_for_monitor (GSManager *manager,\n                                      GdkScreen *screen,\n                                      int        monitor)\n{\n        GSWindow    *window;\n        GdkRectangle rect;\n\n        gdk_screen_get_monitor_geometry (screen, monitor, &rect);\n\n        gs_debug (\"Creating window for monitor %d [%d,%d] (%dx%d)\",\n                  monitor, rect.x, rect.y, rect.width, rect.height);\n\n        window = gs_window_new (screen, monitor, manager->priv->lock_active);\n\n        gs_window_set_user_switch_enabled (window, manager->priv->user_switch_enabled);\n        gs_window_set_logout_enabled (window, manager->priv->logout_enabled);\n        gs_window_set_logout_timeout (window, manager->priv->logout_timeout);\n        gs_window_set_logout_command (window, manager->priv->logout_command);\n        gs_window_set_keyboard_enabled (window, manager->priv->keyboard_enabled);\n        gs_window_set_keyboard_command (window, manager->priv->keyboard_command);\n        gs_window_set_status_message (window, manager->priv->status_message);\n\n        connect_window_signals (manager, window);\n\n        manager->priv->windows = g_slist_append (manager->priv->windows, window);\n}",
        "target": 1
    },
    {
        "func": "on_screen_monitors_changed (GdkScreen *screen,\n                            GSManager *manager)\n{\n        GSList *l;\n        int     n_monitors;\n        int     n_windows;\n        int     i;\n\n        n_monitors = gdk_screen_get_n_monitors (screen);\n        n_windows = g_slist_length (manager->priv->windows);\n\n        gs_debug (\"Monitors changed for screen %d: num=%d\",\n                  gdk_screen_get_number (screen),\n                  n_monitors);\n\n        if (n_monitors > n_windows) {\n                /* add more windows */\n                for (i = n_windows; i < n_monitors; i++) {\n                        gs_manager_create_window_for_monitor (manager, screen, i - 1);\n                }\n        } else {\n                /* remove the extra windows */\n                for (l = manager->priv->windows; l != NULL; l = l->next) {\n                        GdkScreen *this_screen;\n                        int        this_monitor;\n\n                        this_screen = gs_window_get_screen (GS_WINDOW (l->data));\n                        this_monitor = gs_window_get_monitor (GS_WINDOW (l->data));\n                        if (this_screen == screen && this_monitor >= n_monitors) {\n                                manager_maybe_stop_job_for_window (manager, GS_WINDOW (l->data));\n                                gs_window_destroy (GS_WINDOW (l->data));\n                                manager->priv->windows = g_slist_delete_link (manager->priv->windows, l);\n                        }\n                }\n        }\n}",
        "target": 1
    },
    {
        "func": "gs_manager_finalize (GObject *object)\n{\n        GSManager *manager;\n\n        g_return_if_fail (object != NULL);\n        g_return_if_fail (GS_IS_MANAGER (object));\n\n        manager = GS_MANAGER (object);\n\n        g_return_if_fail (manager->priv != NULL);\n\n        if (manager->priv->bg_notify_id != 0) {\n                gconf_client_remove_dir (manager->priv->client,\n                                         GNOME_BG_KEY_DIR,\n                                         NULL);\n                gconf_client_notify_remove (manager->priv->client,\n                                            manager->priv->bg_notify_id);\n                manager->priv->bg_notify_id = 0;\n        }\n        if (manager->priv->bg != NULL) {\n                g_object_unref (manager->priv->bg);\n        }\n        if (manager->priv->client != NULL) {\n                g_object_unref (manager->priv->client);\n        }\n\n        free_themes (manager);\n        g_free (manager->priv->logout_command);\n        g_free (manager->priv->keyboard_command);\n        g_free (manager->priv->away_message);\n\n        remove_unfade_idle (manager);\n        remove_timers (manager);\n\n        gs_grab_release (manager->priv->grab);\n\n        manager_stop_jobs (manager);\n\n        gs_manager_destroy_windows (manager);\n\n        manager->priv->active = FALSE;\n        manager->priv->activate_time = 0;\n        manager->priv->lock_enabled = FALSE;\n\n        g_object_unref (manager->priv->fade);\n        g_object_unref (manager->priv->grab);\n        g_object_unref (manager->priv->theme_manager);\n\n        G_OBJECT_CLASS (gs_manager_parent_class)->finalize (object);\n}",
        "target": 1
    },
    {
        "func": "on_screen_monitors_changed (GdkScreen *screen,\n                            GSManager *manager)\n{\n        gs_debug (\"Monitors changed for screen %d: num=%d\",\n                  gdk_screen_get_number (screen),\n                  gdk_screen_get_n_monitors (screen));\n}",
        "target": 1
    },
    {
        "func": "gs_manager_create_windows_for_screen (GSManager *manager,\n                                      GdkScreen *screen)\n{\n        GSWindow *window;\n        int       n_monitors;\n        int       i;\n\n        g_return_if_fail (manager != NULL);\n        g_return_if_fail (GS_IS_MANAGER (manager));\n        g_return_if_fail (GDK_IS_SCREEN (screen));\n\n        g_object_ref (manager);\n        g_object_ref (screen);\n\n        n_monitors = gdk_screen_get_n_monitors (screen);\n\n        gs_debug (\"Creating %d windows for screen %d\", n_monitors, gdk_screen_get_number (screen));\n\n        for (i = 0; i < n_monitors; i++) {\n                window = gs_window_new (screen, i, manager->priv->lock_active);\n\n                gs_window_set_user_switch_enabled (window, manager->priv->user_switch_enabled);\n                gs_window_set_logout_enabled (window, manager->priv->logout_enabled);\n                gs_window_set_logout_timeout (window, manager->priv->logout_timeout);\n                gs_window_set_logout_command (window, manager->priv->logout_command);\n                gs_window_set_keyboard_enabled (window, manager->priv->keyboard_enabled);\n                gs_window_set_keyboard_command (window, manager->priv->keyboard_command);\n                gs_window_set_away_message (window, manager->priv->away_message);\n\n                connect_window_signals (manager, window);\n\n                manager->priv->windows = g_slist_append (manager->priv->windows, window);\n        }\n\n        g_object_unref (screen);\n        g_object_unref (manager);\n}",
        "target": 1
    },
    {
        "func": "gs_manager_destroy_windows (GSManager *manager)\n{\n        GdkDisplay  *display;\n        GSList      *l;\n        int          n_screens;\n        int          i;\n\n        g_return_if_fail (manager != NULL);\n        g_return_if_fail (GS_IS_MANAGER (manager));\n\n        if (manager->priv->windows == NULL) {\n                return;\n        }\n\n        display = gdk_display_get_default ();\n\n        n_screens = gdk_display_get_n_screens (display);\n\n        for (i = 0; i < n_screens; i++) {\n                g_signal_handlers_disconnect_by_func (gdk_display_get_screen (display, i),\n                                                      on_screen_monitors_changed,\n                                                      manager);\n        }\n\n        for (l = manager->priv->windows; l; l = l->next) {\n                gs_window_destroy (l->data);\n        }\n        g_slist_free (manager->priv->windows);\n        manager->priv->windows = NULL;\n}",
        "target": 1
    },
    {
        "func": "auto_configure_outputs (GsdXrandrManager *manager, guint32 timestamp)\n{\n        /* FMQ: implement */\n}",
        "target": 1
    },
    {
        "func": "on_screen_monitors_changed (GdkScreen *screen,\n                            GSManager *manager)\n{\n        GSList *l;\n        int     n_monitors;\n        int     n_windows;\n        int     i;\n\n        n_monitors = gdk_screen_get_n_monitors (screen);\n        n_windows = g_slist_length (manager->priv->windows);\n\n        gs_debug (\"Monitors changed for screen %d: num=%d\",\n                  gdk_screen_get_number (screen),\n                  n_monitors);\n\n        if (n_monitors > n_windows) {\n                /* add more windows */\n                for (i = n_windows; i < n_monitors; i++) {\n                        gs_manager_create_window_for_monitor (manager, screen, i);\n                }\n        } else {\n                /* remove the extra windows */\n                l = manager->priv->windows;\n                while (l != NULL) {\n                        GdkScreen *this_screen;\n                        int        this_monitor;\n                        GSList    *next = l->next;\n\n                        this_screen = gs_window_get_screen (GS_WINDOW (l->data));\n                        this_monitor = gs_window_get_monitor (GS_WINDOW (l->data));\n                        if (this_screen == screen && this_monitor >= n_monitors) {\n                                manager_maybe_stop_job_for_window (manager, GS_WINDOW (l->data));\n                                g_hash_table_remove (manager->priv->jobs, l->data);\n                                gs_window_destroy (GS_WINDOW (l->data));\n                                manager->priv->windows = g_slist_delete_link (manager->priv->windows, l);\n                        }\n                        l = next;\n                }\n        }\n}",
        "target": 1
    },
    {
        "func": "gs_window_destroy (GSWindow *window)\n{\n        g_return_if_fail (GS_IS_WINDOW (window));\n\n        gtk_widget_destroy (GTK_WIDGET (window));\n}",
        "target": 1
    },
    {
        "func": "static NTSTATUS smb_set_file_unix_link(connection_struct *conn,\n\t\t\t\t       struct smb_request *req,\n\t\t\t\t       const char *pdata,\n\t\t\t\t       int total_data,\n\t\t\t\t       const struct smb_filename *smb_fname)\n{\n\tchar *link_target = NULL;\n\tconst char *newname = smb_fname->base_name;\n\tNTSTATUS status = NT_STATUS_OK;\n\tTALLOC_CTX *ctx = talloc_tos();\n\n\t/* Set a symbolic link. */\n\t/* Don't allow this if follow links is false. */\n\n\tif (total_data == 0) {\n\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t}\n\n\tif (!lp_symlinks(SNUM(conn))) {\n\t\treturn NT_STATUS_ACCESS_DENIED;\n\t}\n\n\tsrvstr_pull_talloc(ctx, pdata, req->flags2, &link_target, pdata,\n\t\t    total_data, STR_TERMINATE);\n\n\tif (!link_target) {\n\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t}\n\n\t/* !widelinks forces the target path to be within the share. */\n\t/* This means we can interpret the target as a pathname. */\n\tif (!lp_widelinks(SNUM(conn))) {\n\t\tchar *rel_name = NULL;\n\t\tchar *last_dirp = NULL;\n\n\t\tif (*link_target == '/') {\n\t\t\t/* No absolute paths allowed. */\n\t\t\treturn NT_STATUS_ACCESS_DENIED;\n\t\t}\n\t\trel_name = talloc_strdup(ctx,newname);\n\t\tif (!rel_name) {\n\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t}\n\t\tlast_dirp = strrchr_m(rel_name, '/');\n\t\tif (last_dirp) {\n\t\t\tlast_dirp[1] = '\\0';\n\t\t} else {\n\t\t\trel_name = talloc_strdup(ctx,\"./\");\n\t\t\tif (!rel_name) {\n\t\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t\t}\n\t\t}\n\t\trel_name = talloc_asprintf_append(rel_name,\n\t\t\t\t\"%s\",\n\t\t\t\tlink_target);\n\t\tif (!rel_name) {\n\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t}\n\n\t\tstatus = check_name(conn, rel_name);\n\t\tif (!NT_STATUS_IS_OK(status)) {\n\t\t\treturn status;\n\t\t}\n\t}\n\n\tDEBUG(10,(\"smb_set_file_unix_link: SMB_SET_FILE_UNIX_LINK doing symlink %s -> %s\\n\",\n\t\t\tnewname, link_target ));\n\n\tif (SMB_VFS_SYMLINK(conn,link_target,newname) != 0) {\n\t\treturn map_nt_error_from_unix(errno);\n\t}\n\n\treturn NT_STATUS_OK;\n}",
        "target": 1
    },
    {
        "func": "connection_struct *make_connection_snum(struct smbd_server_connection *sconn,\n\t\t\t\t\tint snum, user_struct *vuser,\n\t\t\t\t\tDATA_BLOB password,\n\t\t\t\t\tconst char *pdev,\n\t\t\t\t\tNTSTATUS *pstatus)\n{\n\tconnection_struct *conn;\n\tstruct smb_filename *smb_fname_cpath = NULL;\n\tfstring dev;\n\tint ret;\n\tchar addr[INET6_ADDRSTRLEN];\n\tbool on_err_call_dis_hook = false;\n\tNTSTATUS status;\n\n\tfstrcpy(dev, pdev);\n\n\tif (NT_STATUS_IS_ERR(*pstatus = share_sanity_checks(snum, dev))) {\n\t\treturn NULL;\n\t}\t\n\n\tconn = conn_new(sconn);\n\tif (!conn) {\n\t\tDEBUG(0,(\"Couldn't find free connection.\\n\"));\n\t\t*pstatus = NT_STATUS_INSUFFICIENT_RESOURCES;\n\t\treturn NULL;\n\t}\n\n\tconn->params->service = snum;\n\n\tstatus = create_connection_server_info(sconn,\n\t\tconn, snum, vuser ? vuser->server_info : NULL, password,\n\t\t&conn->server_info);\n\n\tif (!NT_STATUS_IS_OK(status)) {\n\t\tDEBUG(1, (\"create_connection_server_info failed: %s\\n\",\n\t\t\t  nt_errstr(status)));\n\t\t*pstatus = status;\n\t\tconn_free(conn);\n\t\treturn NULL;\n\t}\n\n\tif ((lp_guest_only(snum)) || (lp_security() == SEC_SHARE)) {\n\t\tconn->force_user = true;\n\t}\n\n\tadd_session_user(sconn, conn->server_info->unix_name);\n\n\tsafe_strcpy(conn->client_address,\n\t\t\tclient_addr(get_client_fd(),addr,sizeof(addr)), \n\t\t\tsizeof(conn->client_address)-1);\n\tconn->num_files_open = 0;\n\tconn->lastused = conn->lastused_count = time(NULL);\n\tconn->used = True;\n\tconn->printer = (strncmp(dev,\"LPT\",3) == 0);\n\tconn->ipc = ( (strncmp(dev,\"IPC\",3) == 0) ||\n\t\t      ( lp_enable_asu_support() && strequal(dev,\"ADMIN$\")) );\n\n\t/* Case options for the share. */\n\tif (lp_casesensitive(snum) == Auto) {\n\t\t/* We will be setting this per packet. Set to be case\n\t\t * insensitive for now. */\n\t\tconn->case_sensitive = False;\n\t} else {\n\t\tconn->case_sensitive = (bool)lp_casesensitive(snum);\n\t}\n\n\tconn->case_preserve = lp_preservecase(snum);\n\tconn->short_case_preserve = lp_shortpreservecase(snum);\n\n\tconn->encrypt_level = lp_smb_encrypt(snum);\n\n\tconn->veto_list = NULL;\n\tconn->hide_list = NULL;\n\tconn->veto_oplock_list = NULL;\n\tconn->aio_write_behind_list = NULL;\n\n\tconn->read_only = lp_readonly(SNUM(conn));\n\tconn->admin_user = False;\n\n\tif (*lp_force_user(snum)) {\n\n\t\t/*\n\t\t * Replace conn->server_info with a completely faked up one\n\t\t * from the username we are forced into :-)\n\t\t */\n\n\t\tchar *fuser;\n\t\tstruct auth_serversupplied_info *forced_serverinfo;\n\n\t\tfuser = talloc_string_sub(conn, lp_force_user(snum), \"%S\",\n\t\t\t\t\t  lp_servicename(snum));\n\t\tif (fuser == NULL) {\n\t\t\tconn_free(conn);\n\t\t\t*pstatus = NT_STATUS_NO_MEMORY;\n\t\t\treturn NULL;\n\t\t}\n\n\t\tstatus = make_serverinfo_from_username(\n\t\t\tconn, fuser, conn->server_info->guest,\n\t\t\t&forced_serverinfo);\n\t\tif (!NT_STATUS_IS_OK(status)) {\n\t\t\tconn_free(conn);\n\t\t\t*pstatus = status;\n\t\t\treturn NULL;\n\t\t}\n\n\t\tTALLOC_FREE(conn->server_info);\n\t\tconn->server_info = forced_serverinfo;\n\n\t\tconn->force_user = True;\n\t\tDEBUG(3,(\"Forced user %s\\n\", fuser));\n\t}\n\n\t/*\n\t * If force group is true, then override\n\t * any groupid stored for the connecting user.\n\t */\n\n\tif (*lp_force_group(snum)) {\n\n\t\tstatus = find_forced_group(\n\t\t\tconn->force_user, snum, conn->server_info->unix_name,\n\t\t\t&conn->server_info->ptok->user_sids[1],\n\t\t\t&conn->server_info->utok.gid);\n\n\t\tif (!NT_STATUS_IS_OK(status)) {\n\t\t\tconn_free(conn);\n\t\t\t*pstatus = status;\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/*\n\t\t * We need to cache this gid, to use within\n \t\t * change_to_user() separately from the conn->server_info\n \t\t * struct. We only use conn->server_info directly if\n \t\t * \"force_user\" was set.\n \t\t */\n\t\tconn->force_group_gid = conn->server_info->utok.gid;\n\t}\n\n\tconn->vuid = (vuser != NULL) ? vuser->vuid : UID_FIELD_INVALID;\n\n\t{\n\t\tchar *s = talloc_sub_advanced(talloc_tos(),\n\t\t\t\t\tlp_servicename(SNUM(conn)),\n\t\t\t\t\tconn->server_info->unix_name,\n\t\t\t\t\tconn->connectpath,\n\t\t\t\t\tconn->server_info->utok.gid,\n\t\t\t\t\tconn->server_info->sanitized_username,\n\t\t\t\t\tpdb_get_domain(conn->server_info->sam_account),\n\t\t\t\t\tlp_pathname(snum));\n\t\tif (!s) {\n\t\t\tconn_free(conn);\n\t\t\t*pstatus = NT_STATUS_NO_MEMORY;\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (!set_conn_connectpath(conn,s)) {\n\t\t\tTALLOC_FREE(s);\n\t\t\tconn_free(conn);\n\t\t\t*pstatus = NT_STATUS_NO_MEMORY;\n\t\t\treturn NULL;\n\t\t}\n\t\tDEBUG(3,(\"Connect path is '%s' for service [%s]\\n\",s,\n\t\t\t lp_servicename(snum)));\n\t\tTALLOC_FREE(s);\n\t}\n\n\t/*\n\t * New code to check if there's a share security descripter\n\t * added from NT server manager. This is done after the\n\t * smb.conf checks are done as we need a uid and token. JRA.\n\t *\n\t */\n\n\t{\n\t\tbool can_write = False;\n\n\t\tcan_write = share_access_check(conn->server_info->ptok,\n\t\t\t\t\t       lp_servicename(snum),\n\t\t\t\t\t       FILE_WRITE_DATA);\n\n\t\tif (!can_write) {\n\t\t\tif (!share_access_check(conn->server_info->ptok,\n\t\t\t\t\t\tlp_servicename(snum),\n\t\t\t\t\t\tFILE_READ_DATA)) {\n\t\t\t\t/* No access, read or write. */\n\t\t\t\tDEBUG(0,(\"make_connection: connection to %s \"\n\t\t\t\t\t \"denied due to security \"\n\t\t\t\t\t \"descriptor.\\n\",\n\t\t\t\t\t  lp_servicename(snum)));\n\t\t\t\tconn_free(conn);\n\t\t\t\t*pstatus = NT_STATUS_ACCESS_DENIED;\n\t\t\t\treturn NULL;\n\t\t\t} else {\n\t\t\t\tconn->read_only = True;\n\t\t\t}\n\t\t}\n\t}\n\t/* Initialise VFS function pointers */\n\n\tif (!smbd_vfs_init(conn)) {\n\t\tDEBUG(0, (\"vfs_init failed for service %s\\n\",\n\t\t\t  lp_servicename(snum)));\n\t\tconn_free(conn);\n\t\t*pstatus = NT_STATUS_BAD_NETWORK_NAME;\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * If widelinks are disallowed we need to canonicalise the connect\n\t * path here to ensure we don't have any symlinks in the\n\t * connectpath. We will be checking all paths on this connection are\n\t * below this directory. We must do this after the VFS init as we\n\t * depend on the realpath() pointer in the vfs table. JRA.\n\t */\n\tif (!lp_widelinks(snum)) {\n\t\tif (!canonicalize_connect_path(conn)) {\n\t\t\tDEBUG(0, (\"canonicalize_connect_path failed \"\n\t\t\t\"for service %s, path %s\\n\",\n\t\t\t\tlp_servicename(snum),\n\t\t\t\tconn->connectpath));\n\t\t\tconn_free(conn);\n\t\t\t*pstatus = NT_STATUS_BAD_NETWORK_NAME;\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif ((!conn->printer) && (!conn->ipc)) {\n\t\tconn->notify_ctx = notify_init(conn, server_id_self(),\n\t\t\t\t\t       smbd_messaging_context(),\n\t\t\t\t\t       smbd_event_context(),\n\t\t\t\t\t       conn);\n\t}\n\n/* ROOT Activities: */\t\n\t/*\n\t * Enforce the max connections parameter.\n\t */\n\n\tif ((lp_max_connections(snum) > 0)\n\t    && (count_current_connections(lp_servicename(SNUM(conn)), True) >=\n\t\tlp_max_connections(snum))) {\n\n\t\tDEBUG(1, (\"Max connections (%d) exceeded for %s\\n\",\n\t\t\t  lp_max_connections(snum), lp_servicename(snum)));\n\t\tconn_free(conn);\n\t\t*pstatus = NT_STATUS_INSUFFICIENT_RESOURCES;\n\t\treturn NULL;\n\t}  \n\n\t/*\n\t * Get us an entry in the connections db\n\t */\n\tif (!claim_connection(conn, lp_servicename(snum), 0)) {\n\t\tDEBUG(1, (\"Could not store connections entry\\n\"));\n\t\tconn_free(conn);\n\t\t*pstatus = NT_STATUS_INTERNAL_DB_ERROR;\n\t\treturn NULL;\n\t}  \n\n\t/* Preexecs are done here as they might make the dir we are to ChDir\n\t * to below */\n\t/* execute any \"root preexec = \" line */\n\tif (*lp_rootpreexec(snum)) {\n\t\tchar *cmd = talloc_sub_advanced(talloc_tos(),\n\t\t\t\t\tlp_servicename(SNUM(conn)),\n\t\t\t\t\tconn->server_info->unix_name,\n\t\t\t\t\tconn->connectpath,\n\t\t\t\t\tconn->server_info->utok.gid,\n\t\t\t\t\tconn->server_info->sanitized_username,\n\t\t\t\t\tpdb_get_domain(conn->server_info->sam_account),\n\t\t\t\t\tlp_rootpreexec(snum));\n\t\tDEBUG(5,(\"cmd=%s\\n\",cmd));\n\t\tret = smbrun(cmd,NULL);\n\t\tTALLOC_FREE(cmd);\n\t\tif (ret != 0 && lp_rootpreexec_close(snum)) {\n\t\t\tDEBUG(1,(\"root preexec gave %d - failing \"\n\t\t\t\t \"connection\\n\", ret));\n\t\t\tyield_connection(conn, lp_servicename(snum));\n\t\t\tconn_free(conn);\n\t\t\t*pstatus = NT_STATUS_ACCESS_DENIED;\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n/* USER Activites: */\n\tif (!change_to_user(conn, conn->vuid)) {\n\t\t/* No point continuing if they fail the basic checks */\n\t\tDEBUG(0,(\"Can't become connected user!\\n\"));\n\t\tyield_connection(conn, lp_servicename(snum));\n\t\tconn_free(conn);\n\t\t*pstatus = NT_STATUS_LOGON_FAILURE;\n\t\treturn NULL;\n\t}\n\n\t/* Remember that a different vuid can connect later without these\n\t * checks... */\n\t\n\t/* Preexecs are done here as they might make the dir we are to ChDir\n\t * to below */\n\n\t/* execute any \"preexec = \" line */\n\tif (*lp_preexec(snum)) {\n\t\tchar *cmd = talloc_sub_advanced(talloc_tos(),\n\t\t\t\t\tlp_servicename(SNUM(conn)),\n\t\t\t\t\tconn->server_info->unix_name,\n\t\t\t\t\tconn->connectpath,\n\t\t\t\t\tconn->server_info->utok.gid,\n\t\t\t\t\tconn->server_info->sanitized_username,\n\t\t\t\t\tpdb_get_domain(conn->server_info->sam_account),\n\t\t\t\t\tlp_preexec(snum));\n\t\tret = smbrun(cmd,NULL);\n\t\tTALLOC_FREE(cmd);\n\t\tif (ret != 0 && lp_preexec_close(snum)) {\n\t\t\tDEBUG(1,(\"preexec gave %d - failing connection\\n\",\n\t\t\t\t ret));\n\t\t\t*pstatus = NT_STATUS_ACCESS_DENIED;\n\t\t\tgoto err_root_exit;\n\t\t}\n\t}\n\n#ifdef WITH_FAKE_KASERVER\n\tif (lp_afs_share(snum)) {\n\t\tafs_login(conn);\n\t}\n#endif\n\t\n\t/* Add veto/hide lists */\n\tif (!IS_IPC(conn) && !IS_PRINT(conn)) {\n\t\tset_namearray( &conn->veto_list, lp_veto_files(snum));\n\t\tset_namearray( &conn->hide_list, lp_hide_files(snum));\n\t\tset_namearray( &conn->veto_oplock_list, lp_veto_oplocks(snum));\n\t\tset_namearray( &conn->aio_write_behind_list,\n\t\t\t\tlp_aio_write_behind(snum));\n\t}\n\t\n\t/* Invoke VFS make connection hook - do this before the VFS_STAT call\n\t   to allow any filesystems needing user credentials to initialize\n\t   themselves. */\n\n\tif (SMB_VFS_CONNECT(conn, lp_servicename(snum),\n\t\t\t    conn->server_info->unix_name) < 0) {\n\t\tDEBUG(0,(\"make_connection: VFS make connection failed!\\n\"));\n\t\t*pstatus = NT_STATUS_UNSUCCESSFUL;\n\t\tgoto err_root_exit;\n\t}\n\n\t/* Any error exit after here needs to call the disconnect hook. */\n\ton_err_call_dis_hook = true;\n\n\tstatus = create_synthetic_smb_fname(talloc_tos(), conn->connectpath,\n\t\t\t\t\t    NULL, NULL, &smb_fname_cpath);\n\tif (!NT_STATUS_IS_OK(status)) {\n\t\t*pstatus = status;\n\t\tgoto err_root_exit;\n\t}\n\n\t/* win2000 does not check the permissions on the directory\n\t   during the tree connect, instead relying on permission\n\t   check during individual operations. To match this behaviour\n\t   I have disabled this chdir check (tridge) */\n\t/* the alternative is just to check the directory exists */\n\tif ((ret = SMB_VFS_STAT(conn, smb_fname_cpath)) != 0 ||\n\t    !S_ISDIR(smb_fname_cpath->st.st_ex_mode)) {\n\t\tif (ret == 0 && !S_ISDIR(smb_fname_cpath->st.st_ex_mode)) {\n\t\t\tDEBUG(0,(\"'%s' is not a directory, when connecting to \"\n\t\t\t\t \"[%s]\\n\", conn->connectpath,\n\t\t\t\t lp_servicename(snum)));\n\t\t} else {\n\t\t\tDEBUG(0,(\"'%s' does not exist or permission denied \"\n\t\t\t\t \"when connecting to [%s] Error was %s\\n\",\n\t\t\t\t conn->connectpath, lp_servicename(snum),\n\t\t\t\t strerror(errno) ));\n\t\t}\n\t\t*pstatus = NT_STATUS_BAD_NETWORK_NAME;\n\t\tgoto err_root_exit;\n\t}\n\n\tstring_set(&conn->origpath,conn->connectpath);\n\n#if SOFTLINK_OPTIMISATION\n\t/* resolve any soft links early if possible */\n\tif (vfs_ChDir(conn,conn->connectpath) == 0) {\n\t\tTALLOC_CTX *ctx = talloc_tos();\n\t\tchar *s = vfs_GetWd(ctx,s);\n\t\tif (!s) {\n\t\t\t*status = map_nt_error_from_unix(errno);\n\t\t\tgoto err_root_exit;\n\t\t}\n\t\tif (!set_conn_connectpath(conn,s)) {\n\t\t\t*status = NT_STATUS_NO_MEMORY;\n\t\t\tgoto err_root_exit;\n\t\t}\n\t\tvfs_ChDir(conn,conn->connectpath);\n\t}\n#endif\n\n\t/* Figure out the characteristics of the underlying filesystem. This\n\t * assumes that all the filesystem mounted withing a share path have\n\t * the same characteristics, which is likely but not guaranteed.\n\t */\n\n\tconn->fs_capabilities = SMB_VFS_FS_CAPABILITIES(conn, &conn->ts_res);\n\n\t/*\n\t * Print out the 'connected as' stuff here as we need\n\t * to know the effective uid and gid we will be using\n\t * (at least initially).\n\t */\n\n\tif( DEBUGLVL( IS_IPC(conn) ? 3 : 1 ) ) {\n\t\tdbgtext( \"%s (%s) \", get_remote_machine_name(),\n\t\t\t conn->client_address );\n\t\tdbgtext( \"%s\", srv_is_signing_active(smbd_server_conn) ? \"signed \" : \"\");\n\t\tdbgtext( \"connect to service %s \", lp_servicename(snum) );\n\t\tdbgtext( \"initially as user %s \",\n\t\t\t conn->server_info->unix_name );\n\t\tdbgtext( \"(uid=%d, gid=%d) \", (int)geteuid(), (int)getegid() );\n\t\tdbgtext( \"(pid %d)\\n\", (int)sys_getpid() );\n\t}\n\n\t/* we've finished with the user stuff - go back to root */\n\tchange_to_root_user();\n\treturn(conn);\n\n  err_root_exit:\n\tTALLOC_FREE(smb_fname_cpath);\n\tchange_to_root_user();\n\tif (on_err_call_dis_hook) {\n\t\t/* Call VFS disconnect hook */\n\t\tSMB_VFS_DISCONNECT(conn);\n\t}\n\tyield_connection(conn, lp_servicename(snum));\n\tconn_free(conn);\n\treturn NULL;\n}",
        "target": 1
    },
    {
        "func": "NTSTATUS check_reduced_name(connection_struct *conn, const char *fname)\n{\n#ifdef REALPATH_TAKES_NULL\n\tbool free_resolved_name = True;\n#else\n        char resolved_name_buf[PATH_MAX+1];\n\tbool free_resolved_name = False;\n#endif\n\tchar *resolved_name = NULL;\n\tchar *p = NULL;\n\n\tDEBUG(3,(\"check_reduced_name [%s] [%s]\\n\", fname, conn->connectpath));\n\n#ifdef REALPATH_TAKES_NULL\n\tresolved_name = SMB_VFS_REALPATH(conn,fname,NULL);\n#else\n\tresolved_name = SMB_VFS_REALPATH(conn,fname,resolved_name_buf);\n#endif\n\n\tif (!resolved_name) {\n\t\tswitch (errno) {\n\t\t\tcase ENOTDIR:\n\t\t\t\tDEBUG(3,(\"check_reduced_name: Component not a \"\n\t\t\t\t\t \"directory in getting realpath for \"\n\t\t\t\t\t \"%s\\n\", fname));\n\t\t\t\treturn NT_STATUS_OBJECT_PATH_NOT_FOUND;\n\t\t\tcase ENOENT:\n\t\t\t{\n\t\t\t\tTALLOC_CTX *ctx = talloc_tos();\n\t\t\t\tchar *tmp_fname = NULL;\n\t\t\t\tchar *last_component = NULL;\n\t\t\t\t/* Last component didn't exist. Remove it and try and canonicalise the directory. */\n\n\t\t\t\ttmp_fname = talloc_strdup(ctx, fname);\n\t\t\t\tif (!tmp_fname) {\n\t\t\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t\t\t}\n\t\t\t\tp = strrchr_m(tmp_fname, '/');\n\t\t\t\tif (p) {\n\t\t\t\t\t*p++ = '\\0';\n\t\t\t\t\tlast_component = p;\n\t\t\t\t} else {\n\t\t\t\t\tlast_component = tmp_fname;\n\t\t\t\t\ttmp_fname = talloc_strdup(ctx,\n\t\t\t\t\t\t\t\".\");\n\t\t\t\t\tif (!tmp_fname) {\n\t\t\t\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t\t\t\t}\n\t\t\t\t}\n\n#ifdef REALPATH_TAKES_NULL\n\t\t\t\tresolved_name = SMB_VFS_REALPATH(conn,tmp_fname,NULL);\n#else\n\t\t\t\tresolved_name = SMB_VFS_REALPATH(conn,tmp_fname,resolved_name_buf);\n#endif\n\t\t\t\tif (!resolved_name) {\n\t\t\t\t\tNTSTATUS status = map_nt_error_from_unix(errno);\n\n\t\t\t\t\tif (errno == ENOENT || errno == ENOTDIR) {\n\t\t\t\t\t\tstatus = NT_STATUS_OBJECT_PATH_NOT_FOUND;\n\t\t\t\t\t}\n\n\t\t\t\t\tDEBUG(3,(\"check_reduce_named: \"\n\t\t\t\t\t\t \"couldn't get realpath for \"\n\t\t\t\t\t\t \"%s (%s)\\n\",\n\t\t\t\t\t\tfname,\n\t\t\t\t\t\tnt_errstr(status)));\n\t\t\t\t\treturn status;\n\t\t\t\t}\n\t\t\t\ttmp_fname = talloc_asprintf(ctx,\n\t\t\t\t\t\t\"%s/%s\",\n\t\t\t\t\t\tresolved_name,\n\t\t\t\t\t\tlast_component);\n\t\t\t\tif (!tmp_fname) {\n\t\t\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t\t\t}\n#ifdef REALPATH_TAKES_NULL\n\t\t\t\tSAFE_FREE(resolved_name);\n\t\t\t\tresolved_name = SMB_STRDUP(tmp_fname);\n\t\t\t\tif (!resolved_name) {\n\t\t\t\t\tDEBUG(0, (\"check_reduced_name: malloc \"\n\t\t\t\t\t\t  \"fail for %s\\n\", tmp_fname));\n\t\t\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t\t\t}\n#else\n\t\t\t\tsafe_strcpy(resolved_name_buf, tmp_fname, PATH_MAX);\n\t\t\t\tresolved_name = resolved_name_buf;\n#endif\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tDEBUG(1,(\"check_reduced_name: couldn't get \"\n\t\t\t\t\t \"realpath for %s\\n\", fname));\n\t\t\t\treturn map_nt_error_from_unix(errno);\n\t\t}\n\t}\n\n\tDEBUG(10,(\"check_reduced_name realpath [%s] -> [%s]\\n\", fname,\n\t\t  resolved_name));\n\n\tif (*resolved_name != '/') {\n\t\tDEBUG(0,(\"check_reduced_name: realpath doesn't return \"\n\t\t\t \"absolute paths !\\n\"));\n\t\tif (free_resolved_name) {\n\t\t\tSAFE_FREE(resolved_name);\n\t\t}\n\t\treturn NT_STATUS_OBJECT_NAME_INVALID;\n\t}\n\n\t/* Check for widelinks allowed. */\n\tif (!lp_widelinks(SNUM(conn))) {\n\t\t    const char *conn_rootdir;\n\n\t\t    conn_rootdir = SMB_VFS_CONNECTPATH(conn, fname);\n\t\t    if (conn_rootdir == NULL) {\n\t\t\t    DEBUG(2, (\"check_reduced_name: Could not get \"\n\t\t\t\t      \"conn_rootdir\\n\"));\n\t\t\t    if (free_resolved_name) {\n\t\t\t\t    SAFE_FREE(resolved_name);\n\t\t\t    }\n\t\t\t    return NT_STATUS_ACCESS_DENIED;\n\t\t    }\n\n\t\t    if (strncmp(conn_rootdir, resolved_name,\n\t\t\t\tstrlen(conn_rootdir)) != 0) {\n\t\t\t    DEBUG(2, (\"check_reduced_name: Bad access \"\n\t\t\t\t      \"attempt: %s is a symlink outside the \"\n\t\t\t\t      \"share path\", fname));\n\t\t\t    if (free_resolved_name) {\n\t\t\t\t    SAFE_FREE(resolved_name);\n\t\t\t    }\n\t\t\t    return NT_STATUS_ACCESS_DENIED;\n\t\t    }\n\t}\n\n        /* Check if we are allowing users to follow symlinks */\n        /* Patch from David Clerc <David.Clerc@cui.unige.ch>\n                University of Geneva */\n\n#ifdef S_ISLNK\n        if (!lp_symlinks(SNUM(conn))) {\n\t\tstruct smb_filename *smb_fname = NULL;\n\t\tNTSTATUS status;\n\n\t\tstatus = create_synthetic_smb_fname(talloc_tos(), fname, NULL,\n\t\t\t\t\t\t    NULL, &smb_fname);\n\t\tif (!NT_STATUS_IS_OK(status)) {\n\t\t\tif (free_resolved_name) {\n\t\t\t\tSAFE_FREE(resolved_name);\n\t\t\t}\n                        return status;\n\t\t}\n\n\t\tif ( (SMB_VFS_LSTAT(conn, smb_fname) != -1) &&\n                                (S_ISLNK(smb_fname->st.st_ex_mode)) ) {\n\t\t\tif (free_resolved_name) {\n\t\t\t\tSAFE_FREE(resolved_name);\n\t\t\t}\n                        DEBUG(3,(\"check_reduced_name: denied: file path name \"\n\t\t\t\t \"%s is a symlink\\n\",resolved_name));\n\t\t\tTALLOC_FREE(smb_fname);\n\t\t\treturn NT_STATUS_ACCESS_DENIED;\n                }\n\t\tTALLOC_FREE(smb_fname);\n        }\n#endif\n\n\tDEBUG(3,(\"check_reduced_name: %s reduced to %s\\n\", fname,\n\t\t resolved_name));\n\tif (free_resolved_name) {\n\t\tSAFE_FREE(resolved_name);\n\t}\n\treturn NT_STATUS_OK;\n}",
        "target": 1
    },
    {
        "func": "on_screen_monitors_changed (GdkScreen *screen,\n                            GSManager *manager)\n{\n        GSList *l;\n        int     n_monitors;\n        int     n_windows;\n        int     i;\n\n        n_monitors = gdk_screen_get_n_monitors (screen);\n        n_windows = g_slist_length (manager->priv->windows);\n\n        gs_debug (\"Monitors changed for screen %d: num=%d\",\n                  gdk_screen_get_number (screen),\n                  n_monitors);\n\n        if (n_monitors > n_windows) {\n                /* add more windows */\n                for (i = n_windows; i < n_monitors; i++) {\n                        gs_manager_create_window_for_monitor (manager, screen, i);\n                }\n        } else {\n\n                gdk_x11_grab_server ();\n\n                /* remove the extra windows */\n                l = manager->priv->windows;\n                while (l != NULL) {\n                        GdkScreen *this_screen;\n                        int        this_monitor;\n                        GSList    *next = l->next;\n\n                        this_screen = gs_window_get_screen (GS_WINDOW (l->data));\n                        this_monitor = gs_window_get_monitor (GS_WINDOW (l->data));\n                        if (this_screen == screen && this_monitor >= n_monitors) {\n                                manager_maybe_stop_job_for_window (manager, GS_WINDOW (l->data));\n                                g_hash_table_remove (manager->priv->jobs, l->data);\n                                gs_window_destroy (GS_WINDOW (l->data));\n                                manager->priv->windows = g_slist_delete_link (manager->priv->windows, l);\n                        }\n                        l = next;\n                }\n\n                /* make sure there is a lock dialog on a connected monitor,\n                 * and that the keyboard is still properly grabbed after all\n                 * the windows above got destroyed*/\n                if (n_windows > n_monitors) {\n                        gs_manager_request_unlock (manager);\n                }\n\n                gdk_flush ();\n                gdk_x11_ungrab_server ();\n        }\n}",
        "target": 1
    },
    {
        "func": "gs_window_destroy (GSWindow *window)\n{\n        g_return_if_fail (GS_IS_WINDOW (window));\n\n        if (window->priv->lock_pid > 0) {\n                gs_window_dialog_finish (window);\n        }\n\n        remove_popup_dialog_idle (window);\n        remove_command_watches (window);\n        remove_watchdog_timer (window);\n\n        if (window->priv->lock_box != NULL) {\n                gtk_container_remove (GTK_CONTAINER (window->priv->vbox), GTK_WIDGET (window->priv->lock_box));\n                window->priv->lock_box = NULL;\n\n                g_signal_emit (window, signals [DIALOG_DOWN], 0);\n        }\n\n        gtk_widget_destroy (GTK_WIDGET (window));\n}",
        "target": 1
    },
    {
        "func": "gs_window_cancel_unlock_request (GSWindow  *window)\n{\n        /* FIXME: This is a bit of a hammer approach...\n\t * Maybe we should send a delete-event to\n\t * the plug?\n\t */\n        g_return_if_fail (GS_IS_WINDOW (window));\n\n        if (window->priv->lock_socket == NULL) {\n                return;\n        }\n\n        if (window->priv->lock_pid > 0) {\n                kill (window->priv->lock_pid, SIGTERM);\n        }\n}",
        "target": 1
    },
    {
        "func": "gs_grab_get_mouse (GSGrab    *grab,\n                   GdkWindow *window,\n                   GdkScreen *screen,\n                   gboolean   hide_cursor)\n{\n        GdkGrabStatus status;\n        GdkCursor    *cursor;\n\n        g_return_val_if_fail (window != NULL, FALSE);\n        g_return_val_if_fail (screen != NULL, FALSE);\n\n        cursor = get_cursor ();\n\n        gs_debug (\"Grabbing mouse widget=%X\", (guint32) GDK_WINDOW_XID (window));\n        status = gdk_pointer_grab (window, TRUE, 0, NULL,\n                                   (hide_cursor ? cursor : NULL),\n                                   GDK_CURRENT_TIME);\n\n        if (status == GDK_GRAB_SUCCESS) {\n                grab->priv->mouse_grab_window = window;\n                grab->priv->mouse_grab_screen = screen;\n                grab->priv->mouse_hide_cursor = hide_cursor;\n        }\n\n        gdk_cursor_unref (cursor);\n\n        return status;\n}",
        "target": 1
    },
    {
        "func": "gs_grab_keyboard_reset (GSGrab *grab)\n{\n        grab->priv->keyboard_grab_window = NULL;\n        grab->priv->keyboard_grab_screen = NULL;\n}",
        "target": 1
    },
    {
        "func": "gs_grab_get_keyboard (GSGrab    *grab,\n                      GdkWindow *window,\n                      GdkScreen *screen)\n{\n        GdkGrabStatus status;\n\n        g_return_val_if_fail (window != NULL, FALSE);\n        g_return_val_if_fail (screen != NULL, FALSE);\n\n        gs_debug (\"Grabbing keyboard widget=%X\", (guint32) GDK_WINDOW_XID (window));\n        status = gdk_keyboard_grab (window, FALSE, GDK_CURRENT_TIME);\n\n        if (status == GDK_GRAB_SUCCESS) {\n                grab->priv->keyboard_grab_window = window;\n                grab->priv->keyboard_grab_screen = screen;\n        } else {\n                gs_debug (\"Couldn't grab keyboard!  (%s)\", grab_string (status));\n        }\n\n        return status;\n}",
        "target": 1
    },
    {
        "func": "gs_grab_mouse_reset (GSGrab *grab)\n{\n        grab->priv->mouse_grab_window = NULL;\n        grab->priv->mouse_grab_screen = NULL;\n}",
        "target": 1
    },
    {
        "func": "listener_ref_entry_has_connection (gpointer key,\n                                   gpointer value,\n                                   gpointer user_data)\n{\n        GSListenerRefEntry *entry;\n        const char         *connection;\n        gboolean            matches;\n\n        entry = (GSListenerRefEntry *)value;\n        connection = (const char *) user_data;\n\n        matches = FALSE;\n        if (connection != NULL && entry->connection != NULL) {\n                matches = (strcmp (connection, entry->connection) == 0);\n                if (matches) {\n                        gs_debug (\"removing %s from %s for reason '%s' on connection %s\",\n                                  get_name_for_entry_type (entry->entry_type),\n                                  entry->application,\n                                  entry->reason,\n                                  entry->connection);\n                }\n        }\n\n        return matches;\n}",
        "target": 1
    },
    {
        "func": "listener_ref_entry_remove_for_connection (GSListener  *listener,\n                                          int          entry_type,\n                                          const char  *connection)\n{\n        gboolean    removed;\n        guint       n_removed;\n        GHashTable *hash;\n\n        hash = get_hash_for_entry_type (listener, entry_type);\n\n        removed = FALSE;\n        n_removed = g_hash_table_foreach_remove (hash, listener_ref_entry_has_connection, (gpointer)connection);\n\n        removed = (n_removed > 0);\n\n        return removed;\n}",
        "target": 1
    },
    {
        "func": "lock_command_watch (GIOChannel   *source,\n                    GIOCondition  condition,\n                    GSWindow     *window)\n{\n        gboolean finished = FALSE;\n\n        g_return_val_if_fail (GS_IS_WINDOW (window), FALSE);\n\n        if (condition & G_IO_IN) {\n                GIOStatus status;\n                GError   *error = NULL;\n                char     *line;\n\n                line = NULL;\n                status = g_io_channel_read_line (source, &line, NULL, NULL, &error);\n\n                switch (status) {\n                case G_IO_STATUS_NORMAL:\n                        gs_debug (\"command output: %s\", line);\n\n                        if (strstr (line, \"WINDOW ID=\") != NULL) {\n                                guint32 id;\n                                char    c;\n                                if (1 == sscanf (line, \" WINDOW ID= %\" G_GUINT32_FORMAT \" %c\", &id, &c)) {\n                                        create_lock_socket (window, id);\n                                }\n                        } else if (strstr (line, \"NOTICE=\") != NULL) {\n                                if (strstr (line, \"NOTICE=AUTH FAILED\") != NULL) {\n                                        shake_dialog (window);\n                                }\n                        } else if (strstr (line, \"RESPONSE=\") != NULL) {\n                                if (strstr (line, \"RESPONSE=OK\") != NULL) {\n                                        gs_debug (\"Got OK response\");\n                                        window->priv->dialog_response = DIALOG_RESPONSE_OK;\n                                } else {\n                                        gs_debug (\"Got CANCEL response\");\n                                        window->priv->dialog_response = DIALOG_RESPONSE_CANCEL;\n                                }\n                                finished = TRUE;\n                        }\n                        break;\n                case G_IO_STATUS_EOF:\n                        finished = TRUE;\n                        break;\n                case G_IO_STATUS_ERROR:\n                        finished = TRUE;\n                        gs_debug (\"Error reading from child: %s\\n\", error->message);\n                        g_error_free (error);\n                        return FALSE;\n                case G_IO_STATUS_AGAIN:\n                default:\n                        break;\n                }\n\n                g_free (line);\n        } else if (condition & G_IO_HUP) {\n                finished = TRUE;\n        }\n\n        if (finished) {\n                gs_window_dialog_finish (window);\n\n                if (window->priv->dialog_response == DIALOG_RESPONSE_OK) {\n                        add_emit_deactivated_idle (window);\n                }\n\n                gtk_widget_show (window->priv->drawing_area);\n\n                gs_window_clear (window);\n                set_invisible_cursor (GTK_WIDGET (window)->window, TRUE);\n                g_signal_emit (window, signals [DIALOG_DOWN], 0);\n\n                /* reset the pointer positions */\n                window->priv->last_x = -1;\n                window->priv->last_y = -1;\n\n                window->priv->lock_watch_id = 0;\n\n                return FALSE;\n        }\n\n        return TRUE;\n}",
        "target": 1
    },
    {
        "func": "popup_dialog_idle (GSWindow *window)\n{\n        gboolean  result;\n        char     *tmp;\n        GString  *command;\n\n        gs_debug (\"Popping up dialog\");\n\n        tmp = g_build_filename (LIBEXECDIR, \"gnome-screensaver-dialog\", NULL);\n        command = g_string_new (tmp);\n        g_free (tmp);\n\n        if (is_logout_enabled (window)) {\n                command = g_string_append (command, \" --enable-logout\");\n                g_string_append_printf (command, \" --logout-command='%s'\", window->priv->logout_command);\n        }\n\n        if (window->priv->status_message) {\n                char *quoted;\n\n                quoted = g_shell_quote (window->priv->status_message);\n                g_string_append_printf (command, \" --status-message=%s\", quoted);\n                g_free (quoted);\n        }\n\n        if (is_user_switch_enabled (window)) {\n                command = g_string_append (command, \" --enable-switch\");\n        }\n\n        if (gs_debug_enabled ()) {\n                command = g_string_append (command, \" --verbose\");\n        }\n\n        gtk_widget_hide (window->priv->drawing_area);\n\n        gs_window_clear_to_background_pixmap (window);\n\n        set_invisible_cursor (GTK_WIDGET (window)->window, FALSE);\n\n        result = spawn_on_window (window,\n                                  command->str,\n                                  &window->priv->lock_pid,\n                                  (GIOFunc)lock_command_watch,\n                                  window,\n                                  &window->priv->lock_watch_id);\n        if (! result) {\n                gs_debug (\"Could not start command: %s\", command->str);\n        }\n\n        g_string_free (command, TRUE);\n\n        window->priv->popup_dialog_idle_id = 0;\n\n        return FALSE;\n}",
        "target": 1
    },
    {
        "func": "shake_dialog (GSWindow *window)\n{\n        int   i;\n        guint left;\n        guint right;\n\n        for (i = 0; i < 9; i++) {\n                if (i % 2 == 0) {\n                        left = 30;\n                        right = 0;\n                } else {\n                        left = 0;\n                        right = 30;\n                }\n\n                if (! window->priv->lock_box) {\n                        break;\n                }\n\n                gtk_alignment_set_padding (GTK_ALIGNMENT (window->priv->lock_box),\n                                           0, 0,\n                                           left,\n                                           right);\n\n                while (gtk_events_pending ()) {\n                        gtk_main_iteration ();\n                }\n\n                g_usleep (10000);\n        }\n}",
        "target": 1
    },
    {
        "func": "auth_check_idle (GSLockPlug *plug)\n{\n        gboolean     res;\n        gboolean     again;\n        static guint loop_counter = 0;\n\n        again = TRUE;\n        res = do_auth_check (plug);\n\n        if (res) {\n                again = FALSE;\n                g_idle_add ((GSourceFunc)quit_response_ok, NULL);\n        } else {\n                loop_counter++;\n\n                if (loop_counter < MAX_FAILURES) {\n                        gs_debug (\"Authentication failed, retrying (%u)\", loop_counter);\n                        g_timeout_add (3000, (GSourceFunc)reset_idle_cb, plug);\n                } else {\n                        gs_debug (\"Authentication failed, quitting (max failures)\");\n                        again = FALSE;\n                        gtk_main_quit ();\n                }\n        }\n\n        return again;\n}",
        "target": 1
    },
    {
        "func": "static int futex_lock_pi(u32 __user *uaddr, int fshared,\n\t\t\t int detect, ktime_t *time, int trylock)\n{\n\tstruct hrtimer_sleeper timeout, *to = NULL;\n\tstruct futex_hash_bucket *hb;\n\tstruct futex_q q;\n\tint res, ret;\n\n\tif (refill_pi_state_cache())\n\t\treturn -ENOMEM;\n\n\tif (time) {\n\t\tto = &timeout;\n\t\thrtimer_init_on_stack(&to->timer, CLOCK_REALTIME,\n\t\t\t\t      HRTIMER_MODE_ABS);\n\t\thrtimer_init_sleeper(to, current);\n\t\thrtimer_set_expires(&to->timer, *time);\n\t}\n\n\tq.pi_state = NULL;\n\tq.rt_waiter = NULL;\n\tq.requeue_pi_key = NULL;\nretry:\n\tq.key = FUTEX_KEY_INIT;\n\tret = get_futex_key(uaddr, fshared, &q.key);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\nretry_private:\n\thb = queue_lock(&q);\n\n\tret = futex_lock_pi_atomic(uaddr, hb, &q.key, &q.pi_state, current, 0);\n\tif (unlikely(ret)) {\n\t\tswitch (ret) {\n\t\tcase 1:\n\t\t\t/* We got the lock. */\n\t\t\tret = 0;\n\t\t\tgoto out_unlock_put_key;\n\t\tcase -EFAULT:\n\t\t\tgoto uaddr_faulted;\n\t\tcase -EAGAIN:\n\t\t\t/*\n\t\t\t * Task is exiting and we just wait for the\n\t\t\t * exit to complete.\n\t\t\t */\n\t\t\tqueue_unlock(&q, hb);\n\t\t\tput_futex_key(fshared, &q.key);\n\t\t\tcond_resched();\n\t\t\tgoto retry;\n\t\tdefault:\n\t\t\tgoto out_unlock_put_key;\n\t\t}\n\t}\n\n\t/*\n\t * Only actually queue now that the atomic ops are done:\n\t */\n\tqueue_me(&q, hb);\n\n\tWARN_ON(!q.pi_state);\n\t/*\n\t * Block on the PI mutex:\n\t */\n\tif (!trylock)\n\t\tret = rt_mutex_timed_lock(&q.pi_state->pi_mutex, to, 1);\n\telse {\n\t\tret = rt_mutex_trylock(&q.pi_state->pi_mutex);\n\t\t/* Fixup the trylock return value: */\n\t\tret = ret ? 0 : -EWOULDBLOCK;\n\t}\n\n\tspin_lock(q.lock_ptr);\n\t/*\n\t * Fixup the pi_state owner and possibly acquire the lock if we\n\t * haven't already.\n\t */\n\tres = fixup_owner(uaddr, fshared, &q, !ret);\n\t/*\n\t * If fixup_owner() returned an error, proprogate that.  If it acquired\n\t * the lock, clear our -ETIMEDOUT or -EINTR.\n\t */\n\tif (res)\n\t\tret = (res < 0) ? res : 0;\n\n\t/*\n\t * If fixup_owner() faulted and was unable to handle the fault, unlock\n\t * it and return the fault to userspace.\n\t */\n\tif (ret && (rt_mutex_owner(&q.pi_state->pi_mutex) == current))\n\t\trt_mutex_unlock(&q.pi_state->pi_mutex);\n\n\t/* Unqueue and drop the lock */\n\tunqueue_me_pi(&q);\n\n\tgoto out;\n\nout_unlock_put_key:\n\tqueue_unlock(&q, hb);\n\nout_put_key:\n\tput_futex_key(fshared, &q.key);\nout:\n\tif (to)\n\t\tdestroy_hrtimer_on_stack(&to->timer);\n\treturn ret != -EINTR ? ret : -ERESTARTNOINTR;\n\nuaddr_faulted:\n\tqueue_unlock(&q, hb);\n\n\tret = fault_in_user_writeable(uaddr);\n\tif (ret)\n\t\tgoto out_put_key;\n\n\tif (!fshared)\n\t\tgoto retry_private;\n\n\tput_futex_key(fshared, &q.key);\n\tgoto retry;\n}",
        "target": 1
    },
    {
        "func": "static int encode_to_private_key_info(gnutls_x509_privkey_t pkey,\n\t\t\t\t      gnutls_datum_t * der,\n\t\t\t\t      ASN1_TYPE * pkey_info)\n{\n    int result;\n    size_t size;\n    opaque *data = NULL;\n    opaque null = 0;\n\n    if (pkey->pk_algorithm != GNUTLS_PK_RSA) {\n\tgnutls_assert();\n\treturn GNUTLS_E_UNIMPLEMENTED_FEATURE;\n    }\n\n    if ((result =\n\t asn1_create_element(_gnutls_get_pkix(),\n\t\t\t     \"PKIX1.pkcs-8-PrivateKeyInfo\",\n\t\t\t     pkey_info)) != ASN1_SUCCESS) {\n\tgnutls_assert();\n\tresult = _gnutls_asn2err(result);\n\tgoto error;\n    }\n\n    /* Write the version.\n     */\n    result = asn1_write_value(*pkey_info, \"version\", &null, 1);\n    if (result != ASN1_SUCCESS) {\n\tgnutls_assert();\n\tresult = _gnutls_asn2err(result);\n\tgoto error;\n    }\n\n    /* write the privateKeyAlgorithm\n     * fields. (OID+NULL data)\n     */\n    result =\n\tasn1_write_value(*pkey_info, \"privateKeyAlgorithm.algorithm\",\n\t\t\t PKIX1_RSA_OID, 1);\n    if (result != ASN1_SUCCESS) {\n\tgnutls_assert();\n\tresult = _gnutls_asn2err(result);\n\tgoto error;\n    }\n\n    result =\n\tasn1_write_value(*pkey_info, \"privateKeyAlgorithm.parameters\",\n\t\t\t NULL, 0);\n    if (result != ASN1_SUCCESS) {\n\tgnutls_assert();\n\tresult = _gnutls_asn2err(result);\n\tgoto error;\n    }\n\n    /* Write the raw private key\n     */\n    size = 0;\n    result =\n\tgnutls_x509_privkey_export(pkey, GNUTLS_X509_FMT_DER, NULL, &size);\n    if (result != GNUTLS_E_SHORT_MEMORY_BUFFER) {\n\tgnutls_assert();\n\tgoto error;\n    }\n\n    data = gnutls_alloca(size);\n    if (data == NULL) {\n\tgnutls_assert();\n\tresult = GNUTLS_E_MEMORY_ERROR;\n\tgoto error;\n    }\n\n\n    result =\n\tgnutls_x509_privkey_export(pkey, GNUTLS_X509_FMT_DER, data, &size);\n    if (result < 0) {\n\tgnutls_assert();\n\tgoto error;\n    }\n\n    result = asn1_write_value(*pkey_info, \"privateKey\", data, size);\n\n    gnutls_afree(data);\n    data = NULL;\n\n    if (result != ASN1_SUCCESS) {\n\tgnutls_assert();\n\tresult = _gnutls_asn2err(result);\n\tgoto error;\n    }\n\n    /* Append an empty Attributes field.\n     */\n    result = asn1_write_value(*pkey_info, \"attributes\", NULL, 0);\n    if (result != ASN1_SUCCESS) {\n\tgnutls_assert();\n\tresult = _gnutls_asn2err(result);\n\tgoto error;\n    }\n\n    /* DER Encode the generated private key info.\n     */\n    size = 0;\n    result = asn1_der_coding(*pkey_info, \"\", NULL, &size, NULL);\n    if (result != ASN1_MEM_ERROR) {\n\tgnutls_assert();\n\tresult = _gnutls_asn2err(result);\n\tgoto error;\n    }\n\n    /* allocate data for the der\n     */\n    der->size = size;\n    der->data = gnutls_malloc(size);\n    if (der->data == NULL) {\n\tgnutls_assert();\n\treturn GNUTLS_E_MEMORY_ERROR;\n    }\n\n    result = asn1_der_coding(*pkey_info, \"\", der->data, &size, NULL);\n    if (result != ASN1_SUCCESS) {\n\tgnutls_assert();\n\tresult = _gnutls_asn2err(result);\n\tgoto error;\n    }\n\n    return 0;\n\n  error:\n    asn1_delete_structure(pkey_info);\n    if (data != NULL) {\n\tgnutls_afree(data);\n    }\n    return result;\n\n}",
        "target": 1
    },
    {
        "func": "int gnutls_x509_crt_get_serial(gnutls_x509_crt_t cert, void *result,\n\t\t\t       size_t * result_size)\n{\n    int ret;\n\n    if (cert == NULL) {\n\tgnutls_assert();\n\treturn GNUTLS_E_INVALID_REQUEST;\n    }\n\n    if ((ret =\n\t asn1_read_value(cert->cert, \"tbsCertificate.serialNumber\", result,\n\t\t\t result_size)) < 0) {\n\tgnutls_assert();\n\treturn _gnutls_asn2err(ret);\n    }\n\n    return 0;\n}",
        "target": 1
    },
    {
        "func": "_gnutls_asn1_get_structure_xml(ASN1_TYPE structure,\n\t\t\t       gnutls_datum_t * res, int detail)\n{\n    node_asn *p, *root;\n    int k, indent = 0, len, len2, len3;\n    opaque tmp[1024];\n    char nname[256];\n    int ret;\n    gnutls_string str;\n\n    if (res == NULL || structure == NULL) {\n\tgnutls_assert();\n\treturn GNUTLS_E_INVALID_REQUEST;\n    }\n\n    _gnutls_string_init(&str, malloc, realloc, free);\n\n    STR_APPEND(XML_HEADER);\n    indent = 1;\n\n    root = _asn1_find_node(structure, \"\");\n\n    if (root == NULL) {\n\tgnutls_assert();\n\t_gnutls_string_clear(&str);\n\treturn GNUTLS_E_INTERNAL_ERROR;\n    }\n\n    if (detail == GNUTLS_XML_SHOW_ALL)\n\tret = asn1_expand_any_defined_by(_gnutls_get_pkix(), &structure);\n    /* we don't need to check the error value\n     * here.\n     */\n\n    if (detail == GNUTLS_XML_SHOW_ALL) {\n\tret = _gnutls_x509_expand_extensions(&structure);\n\tif (ret < 0) {\n\t    gnutls_assert();\n\t    return ret;\n\t}\n    }\n\n    p = root;\n    while (p) {\n\tif (is_node_printable(p)) {\n\t    for (k = 0; k < indent; k++)\n\t\tAPPEND(\" \", 1);\n\n\t    if ((ret = normalize_name(p, nname, sizeof(nname))) < 0) {\n\t\t_gnutls_string_clear(&str);\n\t\tgnutls_assert();\n\t\treturn ret;\n\t    }\n\n\t    APPEND(\"<\", 1);\n\t    STR_APPEND(nname);\n\t}\n\n\tif (is_node_printable(p)) {\n\t    switch (type_field(p->type)) {\n\t    case TYPE_DEFAULT:\n\t\tSTR_APPEND(\" type=\\\"DEFAULT\\\"\");\n\t\tbreak;\n\t    case TYPE_NULL:\n\t\tSTR_APPEND(\" type=\\\"NULL\\\"\");\n\t\tbreak;\n\t    case TYPE_IDENTIFIER:\n\t\tSTR_APPEND(\" type=\\\"IDENTIFIER\\\"\");\n\t\tbreak;\n\t    case TYPE_INTEGER:\n\t\tSTR_APPEND(\" type=\\\"INTEGER\\\"\");\n\t\tSTR_APPEND(\" encoding=\\\"HEX\\\"\");\n\t\tbreak;\n\t    case TYPE_ENUMERATED:\n\t\tSTR_APPEND(\" type=\\\"ENUMERATED\\\"\");\n\t\tSTR_APPEND(\" encoding=\\\"HEX\\\"\");\n\t\tbreak;\n\t    case TYPE_TIME:\n\t\tSTR_APPEND(\" type=\\\"TIME\\\"\");\n\t\tbreak;\n\t    case TYPE_BOOLEAN:\n\t\tSTR_APPEND(\" type=\\\"BOOLEAN\\\"\");\n\t\tbreak;\n\t    case TYPE_SEQUENCE:\n\t\tSTR_APPEND(\" type=\\\"SEQUENCE\\\"\");\n\t\tbreak;\n\t    case TYPE_BIT_STRING:\n\t\tSTR_APPEND(\" type=\\\"BIT STRING\\\"\");\n\t\tSTR_APPEND(\" encoding=\\\"HEX\\\"\");\n\t\tbreak;\n\t    case TYPE_OCTET_STRING:\n\t\tSTR_APPEND(\" type=\\\"OCTET STRING\\\"\");\n\t\tSTR_APPEND(\" encoding=\\\"HEX\\\"\");\n\t\tbreak;\n\t    case TYPE_SEQUENCE_OF:\n\t\tSTR_APPEND(\" type=\\\"SEQUENCE OF\\\"\");\n\t\tbreak;\n\t    case TYPE_OBJECT_ID:\n\t\tSTR_APPEND(\" type=\\\"OBJECT ID\\\"\");\n\t\tbreak;\n\t    case TYPE_ANY:\n\t\tSTR_APPEND(\" type=\\\"ANY\\\"\");\n\t\tif (!p->down)\n\t\t    STR_APPEND(\" encoding=\\\"HEX\\\"\");\n\t\tbreak;\n\t    case TYPE_CONSTANT:{\n\t\t    ASN1_TYPE up = _asn1_find_up(p);\n\n\t\t    if (up && type_field(up->type) == TYPE_ANY &&\n\t\t\tup->left && up->left->value &&\n\t\t\tup->type & CONST_DEFINED_BY &&\n\t\t\ttype_field(up->left->type) == TYPE_OBJECT_ID) {\n\n\t\t\tif (_gnutls_x509_oid_data_printable\n\t\t\t    (up->left->value) == 0) {\n\t\t\t    STR_APPEND(\" encoding=\\\"HEX\\\"\");\n\t\t\t}\n\n\t\t    }\n\t\t}\n\t\tbreak;\n\t    case TYPE_SET:\n\t\tSTR_APPEND(\" type=\\\"SET\\\"\");\n\t\tbreak;\n\t    case TYPE_SET_OF:\n\t\tSTR_APPEND(\" type=\\\"SET OF\\\"\");\n\t\tbreak;\n\t    case TYPE_CHOICE:\n\t\tSTR_APPEND(\" type=\\\"CHOICE\\\"\");\n\t\tbreak;\n\t    case TYPE_DEFINITIONS:\n\t\tSTR_APPEND(\" type=\\\"DEFINITIONS\\\"\");\n\t\tbreak;\n\t    default:\n\t\tbreak;\n\t    }\n\t}\n\n\n\tif (p->type == TYPE_BIT_STRING) {\n\t    len2 = -1;\n\t    len = _asn1_get_length_der(p->value, &len2);\n\t    snprintf(tmp, sizeof(tmp), \" length=\\\"%i\\\"\",\n\t\t     (len - 1) * 8 - (p->value[len2]));\n\t    STR_APPEND(tmp);\n\t}\n\n\tif (is_node_printable(p))\n\t    STR_APPEND(\">\");\n\n\tif (is_node_printable(p)) {\n\t    const unsigned char *value;\n\n\t    if (p->value == NULL)\n\t\tvalue = find_default_value(p);\n\t    else\n\t\tvalue = p->value;\n\n\t    switch (type_field(p->type)) {\n\n\t    case TYPE_DEFAULT:\n\t\tif (value)\n\t\t    STR_APPEND(value);\n\t\tbreak;\n\t    case TYPE_IDENTIFIER:\n\t\tif (value)\n\t\t    STR_APPEND(value);\n\t\tbreak;\n\t    case TYPE_INTEGER:\n\t\tif (value) {\n\t\t    len2 = -1;\n\t\t    len = _asn1_get_length_der(value, &len2);\n\n\t\t    for (k = 0; k < len; k++) {\n\t\t\tsnprintf(tmp, sizeof(tmp),\n\t\t\t\t \"%02X\", (value)[k + len2]);\n\t\t\tSTR_APPEND(tmp);\n\t\t    }\n\n\t\t}\n\t\tbreak;\n\t    case TYPE_ENUMERATED:\n\t\tif (value) {\n\t\t    len2 = -1;\n\t\t    len = _asn1_get_length_der(value, &len2);\n\n\t\t    for (k = 0; k < len; k++) {\n\t\t\tsnprintf(tmp, sizeof(tmp),\n\t\t\t\t \"%02X\", (value)[k + len2]);\n\t\t\tSTR_APPEND(tmp);\n\t\t    }\n\t\t}\n\t\tbreak;\n\t    case TYPE_TIME:\n\t\tif (value)\n\t\t    STR_APPEND(value);\n\t\tbreak;\n\t    case TYPE_BOOLEAN:\n\t\tif (value) {\n\t\t    if (value[0] == 'T') {\n\t\t\tSTR_APPEND(\"TRUE\");\n\t\t    } else if (value[0] == 'F') {\n\t\t\tSTR_APPEND(\"FALSE\");\n\t\t    }\n\t\t}\n\t\tbreak;\n\t    case TYPE_BIT_STRING:\n\t\tif (value) {\n\t\t    len2 = -1;\n\t\t    len = _asn1_get_length_der(value, &len2);\n\n\t\t    for (k = 1; k < len; k++) {\n\t\t\tsnprintf(tmp, sizeof(tmp),\n\t\t\t\t \"%02X\", (value)[k + len2]);\n\t\t\tSTR_APPEND(tmp);\n\t\t    }\n\t\t}\n\t\tbreak;\n\t    case TYPE_OCTET_STRING:\n\t\tif (value) {\n\t\t    len2 = -1;\n\t\t    len = _asn1_get_length_der(value, &len2);\n\t\t    for (k = 0; k < len; k++) {\n\t\t\tsnprintf(tmp, sizeof(tmp),\n\t\t\t\t \"%02X\", (value)[k + len2]);\n\t\t\tSTR_APPEND(tmp);\n\t\t    }\n\t\t}\n\t\tbreak;\n\t    case TYPE_OBJECT_ID:\n\t\tif (value)\n\t\t    STR_APPEND(value);\n\t\tbreak;\n\t    case TYPE_ANY:\n\t\tif (!p->down) {\n\t\t    if (value) {\n\t\t\tlen3 = -1;\n\t\t\tlen2 = _asn1_get_length_der(value, &len3);\n\t\t\tfor (k = 0; k < len2; k++) {\n\t\t\t    snprintf(tmp, sizeof(tmp),\n\t\t\t\t     \"%02X\", (value)[k + len3]);\n\t\t\t    STR_APPEND(tmp);\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tbreak;\n\t    case TYPE_CONSTANT:{\n\t\t    ASN1_TYPE up = _asn1_find_up(p);\n\n\t\t    if (up && type_field(up->type) == TYPE_ANY &&\n\t\t\tup->left && up->left->value &&\n\t\t\tup->type & CONST_DEFINED_BY &&\n\t\t\ttype_field(up->left->type) == TYPE_OBJECT_ID) {\n\n\t\t\tlen2 = _asn1_get_length_der(up->value, &len3);\n\n\t\t\tif (len2 > 0 && strcmp(p->name, \"type\") == 0) {\n\t\t\t    int len = sizeof(tmp);\n\t\t\t    ret =\n\t\t\t\t_gnutls_x509_oid_data2string(up->left->\n\t\t\t\t\t\t\t     value,\n\t\t\t\t\t\t\t     up->value +\n\t\t\t\t\t\t\t     len3, len2,\n\t\t\t\t\t\t\t     tmp, &len);\n\n\t\t\t    if (ret >= 0) {\n\t\t\t\tSTR_APPEND(tmp);\n\t\t\t    }\n\t\t\t} else {\n\t\t\t    for (k = 0; k < len2; k++) {\n\t\t\t\tsnprintf(tmp, sizeof(tmp),\n\t\t\t\t\t \"%02X\", (up->value)[k + len3]);\n\t\t\t\tSTR_APPEND(tmp);\n\t\t\t    }\n\n\t\t\t}\n\t\t    } else {\n\t\t\tif (value)\n\t\t\t    STR_APPEND(value);\n\t\t    }\n\n\t\t}\n\t\tbreak;\n\t    case TYPE_SET:\n\t    case TYPE_SET_OF:\n\t    case TYPE_CHOICE:\n\t    case TYPE_DEFINITIONS:\n\t    case TYPE_SEQUENCE_OF:\n\t    case TYPE_SEQUENCE:\n\t    case TYPE_NULL:\n\t\tbreak;\n\t    default:\n\t\tbreak;\n\t    }\n\t}\n\n\tif (p->down && is_node_printable(p)) {\n\t    ASN1_TYPE x;\n\t    p = p->down;\n\t    indent += 2;\n\t    x = p;\n\t    do {\n\t\tif (is_node_printable(x)) {\n\t\t    STR_APPEND(\"\\n\");\n\t\t    break;\n\t\t}\n\t\tx = x->right;\n\t    } while (x != NULL);\n\t} else if (p == root) {\n\t    if (is_node_printable(p)) {\n\t\tif ((ret = normalize_name(p, nname, sizeof(nname))) < 0) {\n\t\t    _gnutls_string_clear(&str);\n\t\t    gnutls_assert();\n\t\t    return ret;\n\t\t}\n\n\t\tAPPEND(\"</\", 2);\n\t\tSTR_APPEND(nname);\n\t\tAPPEND(\">\\n\", 2);\n\t    }\n\t    p = NULL;\n\t    break;\n\t} else {\n\t    if (is_node_printable(p)) {\n\t\tif ((ret = normalize_name(p, nname, sizeof(nname))) < 0) {\n\t\t    _gnutls_string_clear(&str);\n\t\t    gnutls_assert();\n\t\t    return ret;\n\t\t}\n\n\t\tAPPEND(\"</\", 2);\n\t\tSTR_APPEND(nname);\n\t\tAPPEND(\">\\n\", 2);\n\t    }\n\t    if (p->right)\n\t\tp = p->right;\n\t    else {\n\t\twhile (1) {\n\t\t    ASN1_TYPE old_p;\n\n\t\t    old_p = p;\n\n\t\t    p = _asn1_find_up(p);\n\t\t    indent -= 2;\n\t\t    if (is_node_printable(p)) {\n\t\t\tif (!is_leaf(p))\t/* XXX */\n\t\t\t    for (k = 0; k < indent; k++)\n\t\t\t\tSTR_APPEND(\" \");\n\n\t\t\tif ((ret =\n\t\t\t     normalize_name(p, nname,\n\t\t\t\t\t    sizeof(nname))) < 0) {\n\t\t\t    _gnutls_string_clear(&str);\n\t\t\t    gnutls_assert();\n\t\t\t    return ret;\n\t\t\t}\n\n\t\t\tAPPEND(\"</\", 2);\n\t\t\tSTR_APPEND(nname);\n\t\t\tAPPEND(\">\\n\", 2);\n\t\t    }\n\t\t    if (p == root) {\n\t\t\tp = NULL;\n\t\t\tbreak;\n\t\t    }\n\n\t\t    if (p->right) {\n\t\t\tp = p->right;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n\n    STR_APPEND(XML_FOOTER);\n    APPEND(\"\\n\\0\", 2);\n\n    *res = _gnutls_string2datum(&str);\n    res->size -= 1;\t\t/* null is not included in size */\n\n    return 0;\n}",
        "target": 1
    },
    {
        "func": "int mszip_decompress(struct mszip_stream *zip, off_t out_bytes) {\n  /* for the bit buffer */\n  register unsigned int bit_buffer;\n  register int bits_left;\n  unsigned char *i_ptr, *i_end;\n\n  int i, ret, state, error;\n\n  /* easy answers */\n  if (!zip || (out_bytes < 0)) return CL_ENULLARG;\n  if (zip->error) return zip->error;\n\n  /* flush out any stored-up bytes before we begin */\n  i = zip->o_end - zip->o_ptr;\n  if ((off_t) i > out_bytes) i = (int) out_bytes;\n  if (i) {\n    if (zip->wflag && (ret = mspack_write(zip->ofd, zip->o_ptr, i, zip->file)) != CL_SUCCESS) {\n      return zip->error = ret;\n    }\n    zip->o_ptr  += i;\n    out_bytes   -= i;\n  }\n  if (out_bytes == 0) return CL_SUCCESS;\n\n  while (out_bytes > 0) {\n    /* unpack another block */\n    MSZIP_RESTORE_BITS;\n\n    /* skip to next read 'CK' header */\n    i = bits_left & 7; MSZIP_REMOVE_BITS(i); /* align to bytestream */\n    state = 0;\n    do {\n      MSZIP_READ_BITS(i, 8);\n      if (i == 'C') state = 1;\n      else if ((state == 1) && (i == 'K')) state = 2;\n      else state = 0;\n    } while (state != 2);\n\n    /* inflate a block, repair and realign if necessary */\n    zip->window_posn = 0;\n    zip->bytes_output = 0;\n    MSZIP_STORE_BITS;\n    if ((error = mszip_inflate(zip))) {\n      cli_dbgmsg(\"mszip_decompress: inflate error %d\\n\", error);\n      if (zip->repair_mode) {\n\tcli_dbgmsg(\"mszip_decompress: MSZIP error, %u bytes of data lost\\n\",\n\t\t\t  MSZIP_FRAME_SIZE - zip->bytes_output);\n\tfor (i = zip->bytes_output; i < MSZIP_FRAME_SIZE; i++) {\n\t  zip->window[i] = '\\0';\n\t}\n\tzip->bytes_output = MSZIP_FRAME_SIZE;\n      }\n      else {\n\treturn zip->error = (error > 0) ? error : CL_EFORMAT;\n      }\n    }\n    zip->o_ptr = &zip->window[0];\n    zip->o_end = &zip->o_ptr[zip->bytes_output];\n\n    /* write a frame */\n    i = (out_bytes < (off_t)zip->bytes_output) ?\n      (int)out_bytes : zip->bytes_output;\n    if (zip->wflag && (ret = mspack_write(zip->ofd, zip->o_ptr, i, zip->file)) != CL_SUCCESS) {\n      return zip->error = ret;\n    }\n\n    /* mspack errors (i.e. read errors) are fatal and can't be recovered */\n    if ((error > 0) && zip->repair_mode) return error;\n\n    zip->o_ptr  += i;\n    out_bytes   -= i;\n  }\n\n  if (out_bytes) {\n    cli_dbgmsg(\"mszip_decompress: bytes left to output\\n\");\n    return zip->error = CL_EFORMAT;\n  }\n  return CL_SUCCESS;\n}",
        "target": 1
    },
    {
        "func": "int lzx_decompress(struct lzx_stream *lzx, off_t out_bytes) {\n  /* bitstream reading and huffman variables */\n  register unsigned int bit_buffer;\n  register int bits_left, i=0;\n  register unsigned short sym;\n  unsigned char *i_ptr, *i_end;\n\n  int match_length, length_footer, extra, verbatim_bits, bytes_todo;\n  int this_run, main_element, aligned_bits, j, ret;\n  unsigned char *window, *runsrc, *rundest, buf[12];\n  unsigned int frame_size=0, end_frame, match_offset, window_posn;\n  unsigned int R0, R1, R2;\n\n  /* easy answers */\n  if (!lzx || (out_bytes < 0)) return CL_ENULLARG;\n  if (lzx->error) return lzx->error;\n\n  /* flush out any stored-up bytes before we begin */\n  i = lzx->o_end - lzx->o_ptr;\n  if ((off_t) i > out_bytes) i = (int) out_bytes;\n  if (i) {\n    if (lzx->wflag && (ret = mspack_write(lzx->ofd, lzx->o_ptr, i, lzx->file)) != CL_SUCCESS) {\n      return lzx->error = ret;\n    }\n    lzx->o_ptr  += i;\n    lzx->offset += i;\n    out_bytes   -= i;\n  }\n  if (out_bytes == 0) return CL_SUCCESS;\n\n  /* restore local state */\n  LZX_RESTORE_BITS;\n  window = lzx->window;\n  window_posn = lzx->window_posn;\n  R0 = lzx->R0;\n  R1 = lzx->R1;\n  R2 = lzx->R2;\n\n  end_frame = (unsigned int)((lzx->offset + out_bytes) / LZX_FRAME_SIZE) + 1;\n\n  while (lzx->frame < end_frame) {\n    /* have we reached the reset interval? (if there is one?) */\n    if (lzx->reset_interval && ((lzx->frame % lzx->reset_interval) == 0)) {\n      if (lzx->block_remaining) {\n\tcli_dbgmsg(\"lzx_decompress: %d bytes remaining at reset interval\\n\", lzx->block_remaining);\n\treturn lzx->error = CL_EFORMAT;\n      }\n\n      /* re-read the intel header and reset the huffman lengths */\n      lzx_reset_state(lzx);\n    }\n\n    /* read header if necessary */\n    if (!lzx->header_read) {\n      /* read 1 bit. if bit=0, intel filesize = 0.\n       * if bit=1, read intel filesize (32 bits) */\n      j = 0; LZX_READ_BITS(i, 1); if (i) { LZX_READ_BITS(i, 16); LZX_READ_BITS(j, 16); }\n      lzx->intel_filesize = (i << 16) | j;\n      lzx->header_read = 1;\n    } \n\n    /* calculate size of frame: all frames are 32k except the final frame\n     * which is 32kb or less. this can only be calculated when lzx->length\n     * has been filled in. */\n    frame_size = LZX_FRAME_SIZE;\n    if (lzx->length && (lzx->length - lzx->offset) < (off_t)frame_size) {\n      frame_size = lzx->length - lzx->offset;\n    }\n\n    /* decode until one more frame is available */\n    bytes_todo = lzx->frame_posn + frame_size - window_posn;\n    while (bytes_todo > 0) {\n      /* initialise new block, if one is needed */\n      if (lzx->block_remaining == 0) {\n\t/* realign if previous block was an odd-sized UNCOMPRESSED block */\n\tif ((lzx->block_type == LZX_BLOCKTYPE_UNCOMPRESSED) &&\n\t    (lzx->block_length & 1))\n\t{\n\t  if (i_ptr == i_end) {\n\t    if (lzx_read_input(lzx)) return lzx->error;\n\t    i_ptr = lzx->i_ptr;\n\t    i_end = lzx->i_end;\n\t  }\n\t  i_ptr++;\n\t}\n\n\t/* read block type (3 bits) and block length (24 bits) */\n\tLZX_READ_BITS(lzx->block_type, 3);\n\tLZX_READ_BITS(i, 16); LZX_READ_BITS(j, 8);\n\tlzx->block_remaining = lzx->block_length = (i << 8) | j;\n\n\t/* read individual block headers */\n\tswitch (lzx->block_type) {\n\tcase LZX_BLOCKTYPE_ALIGNED:\n\t  /* read lengths of and build aligned huffman decoding tree */\n\t  for (i = 0; i < 8; i++) { LZX_READ_BITS(j, 3); lzx->ALIGNED_len[i] = j; }\n\t  LZX_BUILD_TABLE(ALIGNED);\n\t  /* no break -- rest of aligned header is same as verbatim */\n\tcase LZX_BLOCKTYPE_VERBATIM:\n\t  /* read lengths of and build main huffman decoding tree */\n\t  LZX_READ_LENGTHS(MAINTREE, 0, 256);\n\t  LZX_READ_LENGTHS(MAINTREE, 256, LZX_NUM_CHARS + (lzx->posn_slots << 3));\n\t  LZX_BUILD_TABLE(MAINTREE);\n\t  /* if the literal 0xE8 is anywhere in the block... */\n\t  if (lzx->MAINTREE_len[0xE8] != 0) lzx->intel_started = 1;\n\t  /* read lengths of and build lengths huffman decoding tree */\n\t  LZX_READ_LENGTHS(LENGTH, 0, LZX_NUM_SECONDARY_LENGTHS);\n\t  LZX_BUILD_TABLE(LENGTH);\n\t  break;\n\n\tcase LZX_BLOCKTYPE_UNCOMPRESSED:\n\t  /* because we can't assume otherwise */\n\t  lzx->intel_started = 1;\n\n\t  /* read 1-16 (not 0-15) bits to align to bytes */\n\t  LZX_ENSURE_BITS(16);\n\t  if (bits_left > 16) i_ptr -= 2;\n\t  bits_left = 0; bit_buffer = 0;\n\n\t  /* read 12 bytes of stored R0 / R1 / R2 values */\n\t  for (rundest = &buf[0], i = 0; i < 12; i++) {\n\t    if (i_ptr == i_end) {\n\t      if (lzx_read_input(lzx)) return lzx->error;\n\t      i_ptr = lzx->i_ptr;\n\t      i_end = lzx->i_end;\n\t    }\n\t    *rundest++ = *i_ptr++;\n\t  }\n\t  R0 = buf[0] | (buf[1] << 8) | (buf[2]  << 16) | (buf[3]  << 24);\n\t  R1 = buf[4] | (buf[5] << 8) | (buf[6]  << 16) | (buf[7]  << 24);\n\t  R2 = buf[8] | (buf[9] << 8) | (buf[10] << 16) | (buf[11] << 24);\n\t  break;\n\n\tdefault:\n\t  cli_dbgmsg(\"lzx_decompress: bad block type (0x%x)\\n\", lzx->block_type);\n\t  return lzx->error = CL_EFORMAT;\n\t}\n      }\n\n      /* decode more of the block:\n       * run = min(what's available, what's needed) */\n      this_run = lzx->block_remaining;\n      if (this_run > bytes_todo) this_run = bytes_todo;\n\n      /* assume we decode exactly this_run bytes, for now */\n      bytes_todo           -= this_run;\n      lzx->block_remaining -= this_run;\n\n      /* decode at least this_run bytes */\n      switch (lzx->block_type) {\n      case LZX_BLOCKTYPE_VERBATIM:\n\twhile (this_run > 0) {\n\t  LZX_READ_HUFFSYM(MAINTREE, main_element);\n\t  if (main_element < LZX_NUM_CHARS) {\n\t    /* literal: 0 to LZX_NUM_CHARS-1 */\n\t    window[window_posn++] = main_element;\n\t    this_run--;\n\t  }\n\t  else {\n\t    /* match: LZX_NUM_CHARS + ((slot<<3) | length_header (3 bits)) */\n\t    main_element -= LZX_NUM_CHARS;\n\n\t    /* get match length */\n\t    match_length = main_element & LZX_NUM_PRIMARY_LENGTHS;\n\t    if (match_length == LZX_NUM_PRIMARY_LENGTHS) {\n\t      LZX_READ_HUFFSYM(LENGTH, length_footer);\n\t      match_length += length_footer;\n\t    }\n\t    match_length += LZX_MIN_MATCH;\n\t  \n\t    /* get match offset */\n\t    switch ((match_offset = (main_element >> 3))) {\n\t    case 0: match_offset = R0;                                  break;\n\t    case 1: match_offset = R1; R1=R0;        R0 = match_offset; break;\n\t    case 2: match_offset = R2; R2=R0;        R0 = match_offset; break;\n\t    case 3: match_offset = 1;  R2=R1; R1=R0; R0 = match_offset; break;\n\t    default:\n\t      extra = lzx->extra_bits[match_offset];\n\t      LZX_READ_BITS(verbatim_bits, extra);\n\t      match_offset = lzx->position_base[match_offset] - 2 + verbatim_bits;\n\t      R2 = R1; R1 = R0; R0 = match_offset;\n\t    }\n\n\t    if ((window_posn + match_length) > lzx->window_size) {\n\t      cli_dbgmsg(\"lzx_decompress: match ran over window wrap\\n\");\n\t      return lzx->error = CL_EFORMAT;\n\t    }\n\t    \n\t    /* copy match */\n\t    rundest = &window[window_posn];\n\t    i = match_length;\n\t    /* does match offset wrap the window? */\n\t    if (match_offset > window_posn) {\n\t      /* j = length from match offset to end of window */\n\t      j = match_offset - window_posn;\n\t      if (j > (int) lzx->window_size) {\n\t        cli_dbgmsg(\"lzx_decompress: match offset beyond window boundaries\\n\");\n\t\treturn lzx->error = CL_EFORMAT;\n\t      }\n\t      runsrc = &window[lzx->window_size - j];\n\t      if (j < i) {\n\t\t/* if match goes over the window edge, do two copy runs */\n\t\ti -= j; while (j-- > 0) *rundest++ = *runsrc++;\n\t\trunsrc = window;\n\t      }\n\t      while (i-- > 0) *rundest++ = *runsrc++;\n\t    }\n\t    else {\n\t      runsrc = rundest - match_offset;\n\t      if(i > (int) (lzx->window_size - window_posn))\n\t        i = lzx->window_size - window_posn;\n\t      while (i-- > 0) *rundest++ = *runsrc++;\n\t    }\n\n\t    this_run    -= match_length;\n\t    window_posn += match_length;\n\t  }\n\t} /* while (this_run > 0) */\n\tbreak;\n\n      case LZX_BLOCKTYPE_ALIGNED:\n\twhile (this_run > 0) {\n\t  LZX_READ_HUFFSYM(MAINTREE, main_element);\n\t  if (main_element < LZX_NUM_CHARS) {\n\t    /* literal: 0 to LZX_NUM_CHARS-1 */\n\t    window[window_posn++] = main_element;\n\t    this_run--;\n\t  }\n\t  else {\n\t    /* match: LZX_NUM_CHARS + ((slot<<3) | length_header (3 bits)) */\n\t    main_element -= LZX_NUM_CHARS;\n\n\t    /* get match length */\n\t    match_length = main_element & LZX_NUM_PRIMARY_LENGTHS;\n\t    if (match_length == LZX_NUM_PRIMARY_LENGTHS) {\n\t      LZX_READ_HUFFSYM(LENGTH, length_footer);\n\t      match_length += length_footer;\n\t    }\n\t    match_length += LZX_MIN_MATCH;\n\n\t    /* get match offset */\n\t    switch ((match_offset = (main_element >> 3))) {\n\t    case 0: match_offset = R0;                             break;\n\t    case 1: match_offset = R1; R1 = R0; R0 = match_offset; break;\n\t    case 2: match_offset = R2; R2 = R0; R0 = match_offset; break;\n\t    default:\n\t      extra = lzx->extra_bits[match_offset];\n\t      match_offset = lzx->position_base[match_offset] - 2;\n\t      if (extra > 3) {\n\t\t/* verbatim and aligned bits */\n\t\textra -= 3;\n\t\tLZX_READ_BITS(verbatim_bits, extra);\n\t\tmatch_offset += (verbatim_bits << 3);\n\t\tLZX_READ_HUFFSYM(ALIGNED, aligned_bits);\n\t\tmatch_offset += aligned_bits;\n\t      }\n\t      else if (extra == 3) {\n\t\t/* aligned bits only */\n\t\tLZX_READ_HUFFSYM(ALIGNED, aligned_bits);\n\t\tmatch_offset += aligned_bits;\n\t      }\n\t      else if (extra > 0) { /* extra==1, extra==2 */\n\t\t/* verbatim bits only */\n\t\tLZX_READ_BITS(verbatim_bits, extra);\n\t\tmatch_offset += verbatim_bits;\n\t      }\n\t      else /* extra == 0 */ {\n\t\t/* ??? not defined in LZX specification! */\n\t\tmatch_offset = 1;\n\t      }\n\t      /* update repeated offset LRU queue */\n\t      R2 = R1; R1 = R0; R0 = match_offset;\n\t    }\n\n\t    if ((window_posn + match_length) > lzx->window_size) {\n\t      cli_dbgmsg(\"lzx_decompress: match ran over window wrap\\n\");\n\t      return lzx->error = CL_EFORMAT;\n\t    }\n\n\t    /* copy match */\n\t    rundest = &window[window_posn];\n\t    i = match_length;\n\t    /* does match offset wrap the window? */\n\t    if (match_offset > window_posn) {\n\t      /* j = length from match offset to end of window */\n\t      j = match_offset - window_posn;\n\t      if (j > (int) lzx->window_size) {\n\t        cli_dbgmsg(\"lzx_decompress: match offset beyond window boundaries\\n\");\n\t\treturn lzx->error = CL_EFORMAT;\n\t      }\n\t      runsrc = &window[lzx->window_size - j];\n\t      if (j < i) {\n\t\t/* if match goes over the window edge, do two copy runs */\n\t\ti -= j; while (j-- > 0) *rundest++ = *runsrc++;\n\t\trunsrc = window;\n\t      }\n\t      while (i-- > 0) *rundest++ = *runsrc++;\n\t    }\n\t    else {\n\t      runsrc = rundest - match_offset;\n\t      while (i-- > 0) *rundest++ = *runsrc++;\n\t    }\n\n\t    this_run    -= match_length;\n\t    window_posn += match_length;\n\t  }\n\t} /* while (this_run > 0) */\n\tbreak;\n\n      case LZX_BLOCKTYPE_UNCOMPRESSED:\n\t/* as this_run is limited not to wrap a frame, this also means it\n\t * won't wrap the window (as the window is a multiple of 32k) */\n\trundest = &window[window_posn];\n\twindow_posn += this_run;\n\twhile (this_run > 0) {\n\t  if ((i = i_end - i_ptr)) {\n\t    if (i > this_run) i = this_run;\n\t    memcpy(rundest, i_ptr, (size_t) i);\n\t    rundest  += i;\n\t    i_ptr    += i;\n\t    this_run -= i;\n\t  }\n\t  else {\n\t    if (lzx_read_input(lzx)) return lzx->error;\n\t    i_ptr = lzx->i_ptr;\n\t    i_end = lzx->i_end;\n\t  }\n\t}\n\tbreak;\n\n      default:\n\treturn lzx->error = CL_EFORMAT; /* might as well */\n      }\n\n      /* did the final match overrun our desired this_run length? */\n      if (this_run < 0) {\n\tif ((unsigned int)(-this_run) > lzx->block_remaining) {\n\t  cli_dbgmsg(\"lzx_decompress: overrun went past end of block by %d (%d remaining)\\n\", -this_run, lzx->block_remaining);\n\t  return lzx->error = CL_EFORMAT;\n\t}\n\tlzx->block_remaining -= -this_run;\n      }\n    } /* while (bytes_todo > 0) */\n\n    /* streams don't extend over frame boundaries */\n    if ((window_posn - lzx->frame_posn) != frame_size) {\n      cli_dbgmsg(\"lzx_decompress: decode beyond output frame limits! %d != %d\\n\", window_posn - lzx->frame_posn, frame_size);\n      return lzx->error = CL_EFORMAT;\n    }\n\n    /* re-align input bitstream */\n    if (bits_left > 0) LZX_ENSURE_BITS(16);\n    if (bits_left & 15) LZX_REMOVE_BITS(bits_left & 15);\n\n    /* check that we've used all of the previous frame first */\n    if (lzx->o_ptr != lzx->o_end) {\n      cli_dbgmsg(\"lzx_decompress: %ld avail bytes, new %d frame\\n\", lzx->o_end-lzx->o_ptr, frame_size);\n      return lzx->error = CL_EFORMAT;\n    }\n\n    /* does this intel block _really_ need decoding? */\n    if (lzx->intel_started && lzx->intel_filesize &&\n\t(lzx->frame <= 32768) && (frame_size > 10))\n    {\n      unsigned char *data    = &lzx->e8_buf[0];\n      unsigned char *dataend = &lzx->e8_buf[frame_size - 10];\n      signed int curpos      = lzx->intel_curpos;\n      signed int filesize    = lzx->intel_filesize;\n      signed int abs_off, rel_off;\n\n      /* copy e8 block to the e8 buffer and tweak if needed */\n      lzx->o_ptr = data;\n      memcpy(data, &lzx->window[lzx->frame_posn], frame_size);\n\n      while (data < dataend) {\n\tif (*data++ != 0xE8) { curpos++; continue; }\n\tabs_off = data[0] | (data[1]<<8) | (data[2]<<16) | (data[3]<<24);\n\tif ((abs_off >= -curpos) && (abs_off < filesize)) {\n\t  rel_off = (abs_off >= 0) ? abs_off - curpos : abs_off + filesize;\n\t  data[0] = (unsigned char) rel_off;\n\t  data[1] = (unsigned char) (rel_off >> 8);\n\t  data[2] = (unsigned char) (rel_off >> 16);\n\t  data[3] = (unsigned char) (rel_off >> 24);\n\t}\n\tdata += 4;\n\tcurpos += 5;\n      }\n      lzx->intel_curpos += frame_size;\n    }\n    else {\n      lzx->o_ptr = &lzx->window[lzx->frame_posn];\n      if (lzx->intel_filesize) lzx->intel_curpos += frame_size;\n    }\n    lzx->o_end = &lzx->o_ptr[frame_size];\n\n    /* write a frame */\n    i = (out_bytes < (off_t)frame_size) ? (unsigned int)out_bytes : frame_size;\n    if (lzx->wflag && (ret = mspack_write(lzx->ofd, lzx->o_ptr, i, lzx->file)) != CL_SUCCESS) {\n      return lzx->error = ret;\n    }\n    lzx->o_ptr  += i;\n    lzx->offset += i;\n    out_bytes   -= i;\n\n    /* advance frame start position */\n    lzx->frame_posn += frame_size;\n    lzx->frame++;\n\n    /* wrap window / frame position pointers */\n    if (window_posn == lzx->window_size)     window_posn = 0;\n    if (lzx->frame_posn == lzx->window_size) lzx->frame_posn = 0;\n\n  } /* while (lzx->frame < end_frame) */\n\n  if (out_bytes) {\n    cli_dbgmsg(\"lzx_decompress: bytes left to output\\n\");\n    return lzx->error = CL_EFORMAT;\n  }\n\n  /* store local state */\n  LZX_STORE_BITS;\n  lzx->window_posn = window_posn;\n  lzx->R0 = R0;\n  lzx->R1 = R1;\n  lzx->R2 = R2;\n\n  return CL_SUCCESS;\n}",
        "target": 1
    },
    {
        "func": "int qtm_decompress(struct qtm_stream *qtm, off_t out_bytes) {\n  unsigned int frame_start, frame_end, window_posn, match_offset, range;\n  unsigned char *window, *i_ptr, *i_end, *runsrc, *rundest;\n  int i, j, selector, extra, sym, match_length, ret;\n  unsigned short H, L, C, symf;\n\n  register unsigned int bit_buffer;\n  register unsigned char bits_left;\n  unsigned char bits_needed, bit_run;\n\n  /* easy answers */\n  if (!qtm || (out_bytes < 0)) return CL_ENULLARG;\n  if (qtm->error) return qtm->error;\n\n  /* flush out any stored-up bytes before we begin */\n  i = qtm->o_end - qtm->o_ptr;\n  if ((off_t) i > out_bytes) i = (int) out_bytes;\n  if (i) {\n    if (qtm->wflag && (ret = mspack_write(qtm->ofd, qtm->o_ptr, i, qtm->file)) != CL_SUCCESS) {\n      return qtm->error = ret;\n    }\n    qtm->o_ptr  += i;\n    out_bytes   -= i;\n  }\n  if (out_bytes == 0) return CL_SUCCESS;\n\n  /* restore local state */\n  QTM_RESTORE_BITS;\n  window = qtm->window;\n  window_posn = qtm->window_posn;\n  frame_start = qtm->frame_start;\n  H = qtm->H;\n  L = qtm->L;\n  C = qtm->C;\n\n  /* while we do not have enough decoded bytes in reserve: */\n  while ((qtm->o_end - qtm->o_ptr) < out_bytes) {\n\n    /* read header if necessary. Initialises H, L and C */\n    if (!qtm->header_read) {\n      H = 0xFFFF; L = 0; QTM_READ_BITS(C, 16);\n      qtm->header_read = 1;\n    }\n\n    /* decode more, at most up to to frame boundary */\n    frame_end = window_posn + (out_bytes - (qtm->o_end - qtm->o_ptr));\n    if ((frame_start + QTM_FRAME_SIZE) < frame_end) {\n      frame_end = frame_start + QTM_FRAME_SIZE;\n    }\n\n    while (window_posn < frame_end) {\n      QTM_GET_SYMBOL(qtm->model7, selector);\n      if (selector < 4) {\n\tstruct qtm_model *mdl = (selector == 0) ? &qtm->model0 :\n\t                        ((selector == 1) ? &qtm->model1 :\n\t\t\t\t((selector == 2) ? &qtm->model2 :\n                                                   &qtm->model3));\n\tQTM_GET_SYMBOL((*mdl), sym);\n\twindow[window_posn++] = sym;\n      }\n      else {\n\tswitch (selector) {\n\tcase 4: /* selector 4 = fixed length match (3 bytes) */\n\t  QTM_GET_SYMBOL(qtm->model4, sym);\n\t  QTM_READ_BITS(extra, qtm->extra_bits[sym]);\n\t  match_offset = qtm->position_base[sym] + extra + 1;\n\t  match_length = 3;\n\t  break;\n\n\tcase 5: /* selector 5 = fixed length match (4 bytes) */\n\t  QTM_GET_SYMBOL(qtm->model5, sym);\n\t  QTM_READ_BITS(extra, qtm->extra_bits[sym]);\n\t  match_offset = qtm->position_base[sym] + extra + 1;\n\t  match_length = 4;\n\t  break;\n\n\tcase 6: /* selector 6 = variable length match */\n\t  QTM_GET_SYMBOL(qtm->model6len, sym);\n\t  QTM_READ_BITS(extra, qtm->length_extra[sym]);\n\t  match_length = qtm->length_base[sym] + extra + 5;\n\n\t  QTM_GET_SYMBOL(qtm->model6, sym);\n\t  QTM_READ_BITS(extra, qtm->extra_bits[sym]);\n\t  match_offset = qtm->position_base[sym] + extra + 1;\n\t  break;\n\n\tdefault:\n\t  /* should be impossible, model7 can only return 0-6 */\n\t  return qtm->error = CL_EFORMAT;\n\t}\n\n\trundest = &window[window_posn];\n\ti = match_length;\n\t/* does match offset wrap the window? */\n\tif (match_offset > window_posn) {\n\t  /* j = length from match offset to end of window */\n\t  j = match_offset - window_posn;\n\t  if (j > (int) qtm->window_size) {\n\t    cli_dbgmsg(\"qtm_decompress: match offset beyond window boundaries\\n\");\n\t    return qtm->error = CL_EFORMAT;\n\t  }\n\t  runsrc = &window[qtm->window_size - j];\n\t  if (j < i) {\n\t    /* if match goes over the window edge, do two copy runs */\n\t    i -= j; while (j-- > 0) *rundest++ = *runsrc++;\n\t    runsrc = window;\n\t  }\n\t  while (i-- > 0) *rundest++ = *runsrc++;\n\t}\n\telse {\n\t  runsrc = rundest - match_offset;\n\t  if(i > (int) (qtm->window_size - window_posn))\n\t    i = qtm->window_size - window_posn;\n\t  while (i-- > 0) *rundest++ = *runsrc++;\n\t}\n\twindow_posn += match_length;\n      }\n    } /* while (window_posn < frame_end) */\n\n    qtm->o_end = &window[window_posn];\n\n    /* another frame completed? */\n    if ((window_posn - frame_start) >= QTM_FRAME_SIZE) {\n      if ((window_posn - frame_start) != QTM_FRAME_SIZE) {\n\tcli_dbgmsg(\"qtm_decompress: overshot frame alignment\\n\");\n\treturn qtm->error = CL_EFORMAT;\n      }\n\n      /* re-align input */\n      if (bits_left & 7) QTM_REMOVE_BITS(bits_left & 7);\n      do { QTM_READ_BITS(i, 8); } while (i != 0xFF);\n      qtm->header_read = 0;\n\n      /* window wrap? */\n      if (window_posn == qtm->window_size) {\n\t/* flush all currently stored data */\n\ti = (qtm->o_end - qtm->o_ptr);\n\tif (qtm->wflag && (ret = mspack_write(qtm->ofd, qtm->o_ptr, i, qtm->file)) != CL_SUCCESS) {\n\t  return qtm->error = ret;\n\t}\n\tout_bytes -= i;\n\tqtm->o_ptr = &window[0];\n\tqtm->o_end = &window[0];\n\twindow_posn = 0;\n      }\n\n      frame_start = window_posn;\n    }\n\n  } /* while (more bytes needed) */\n\n  if (out_bytes) {\n    i = (int) out_bytes;\n    if (qtm->wflag && (ret = mspack_write(qtm->ofd, qtm->o_ptr, i, qtm->file)) != CL_SUCCESS) {\n      return qtm->error = ret;\n    }\n    qtm->o_ptr += i;\n  }\n\n  /* store local state */\n  QTM_STORE_BITS;\n  qtm->window_posn = window_posn;\n  qtm->frame_start = frame_start;\n  qtm->H = H;\n  qtm->L = L;\n  qtm->C = C;\n\n  return CL_SUCCESS;\n}",
        "target": 1
    },
    {
        "func": "struct key *find_keyring_by_name(const char *name, bool skip_perm_check)\n{\n\tstruct key *keyring;\n\tint bucket;\n\n\tkeyring = ERR_PTR(-EINVAL);\n\tif (!name)\n\t\tgoto error;\n\n\tbucket = keyring_hash(name);\n\n\tread_lock(&keyring_name_lock);\n\n\tif (keyring_name_hash[bucket].next) {\n\t\t/* search this hash bucket for a keyring with a matching name\n\t\t * that's readable and that hasn't been revoked */\n\t\tlist_for_each_entry(keyring,\n\t\t\t\t    &keyring_name_hash[bucket],\n\t\t\t\t    type_data.link\n\t\t\t\t    ) {\n\t\t\tif (keyring->user->user_ns != current_user_ns())\n\t\t\t\tcontinue;\n\n\t\t\tif (test_bit(KEY_FLAG_REVOKED, &keyring->flags))\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(keyring->description, name) != 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (!skip_perm_check &&\n\t\t\t    key_permission(make_key_ref(keyring, 0),\n\t\t\t\t\t   KEY_SEARCH) < 0)\n\t\t\t\tcontinue;\n\n\t\t\t/* we've got a match */\n\t\t\tatomic_inc(&keyring->usage);\n\t\t\tread_unlock(&keyring_name_lock);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tread_unlock(&keyring_name_lock);\n\tkeyring = ERR_PTR(-ENOKEY);\n\n error:\n\treturn keyring;\n\n} /* end find_keyring_by_name() */",
        "target": 1
    },
    {
        "func": "static int do_sync(unsigned int num_qd, struct gfs2_quota_data **qda)\n{\n\tstruct gfs2_sbd *sdp = (*qda)->qd_gl->gl_sbd;\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_quota_inode);\n\tunsigned int data_blocks, ind_blocks;\n\tstruct gfs2_holder *ghs, i_gh;\n\tunsigned int qx, x;\n\tstruct gfs2_quota_data *qd;\n\tloff_t offset;\n\tunsigned int nalloc = 0, blocks;\n\tstruct gfs2_alloc *al = NULL;\n\tint error;\n\n\tgfs2_write_calc_reserv(ip, sizeof(struct gfs2_quota),\n\t\t\t      &data_blocks, &ind_blocks);\n\n\tghs = kcalloc(num_qd, sizeof(struct gfs2_holder), GFP_NOFS);\n\tif (!ghs)\n\t\treturn -ENOMEM;\n\n\tsort(qda, num_qd, sizeof(struct gfs2_quota_data *), sort_qd, NULL);\n\tmutex_lock_nested(&ip->i_inode.i_mutex, I_MUTEX_QUOTA);\n\tfor (qx = 0; qx < num_qd; qx++) {\n\t\terror = gfs2_glock_nq_init(qda[qx]->qd_gl, LM_ST_EXCLUSIVE,\n\t\t\t\t\t   GL_NOCACHE, &ghs[qx]);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &i_gh);\n\tif (error)\n\t\tgoto out;\n\n\tfor (x = 0; x < num_qd; x++) {\n\t\tint alloc_required;\n\n\t\toffset = qd2offset(qda[x]);\n\t\terror = gfs2_write_alloc_required(ip, offset,\n\t\t\t\t\t\t  sizeof(struct gfs2_quota),\n\t\t\t\t\t\t  &alloc_required);\n\t\tif (error)\n\t\t\tgoto out_gunlock;\n\t\tif (alloc_required)\n\t\t\tnalloc++;\n\t}\n\n\tal = gfs2_alloc_get(ip);\n\tif (!al) {\n\t\terror = -ENOMEM;\n\t\tgoto out_gunlock;\n\t}\n\t/* \n\t * 1 blk for unstuffing inode if stuffed. We add this extra\n\t * block to the reservation unconditionally. If the inode\n\t * doesn't need unstuffing, the block will be released to the \n\t * rgrp since it won't be allocated during the transaction\n\t */\n\tal->al_requested = 1;\n\t/* +1 in the end for block requested above for unstuffing */\n\tblocks = num_qd * data_blocks + RES_DINODE + num_qd + 1;\n\n\tif (nalloc)\n\t\tal->al_requested += nalloc * (data_blocks + ind_blocks);\t\t\n\terror = gfs2_inplace_reserve(ip);\n\tif (error)\n\t\tgoto out_alloc;\n\n\tif (nalloc)\n\t\tblocks += al->al_rgd->rd_length + nalloc * ind_blocks + RES_STATFS;\n\n\terror = gfs2_trans_begin(sdp, blocks, 0);\n\tif (error)\n\t\tgoto out_ipres;\n\n\tfor (x = 0; x < num_qd; x++) {\n\t\tqd = qda[x];\n\t\toffset = qd2offset(qd);\n\t\terror = gfs2_adjust_quota(ip, offset, qd->qd_change_sync, qd, NULL);\n\t\tif (error)\n\t\t\tgoto out_end_trans;\n\n\t\tdo_qc(qd, -qd->qd_change_sync);\n\t}\n\n\terror = 0;\n\nout_end_trans:\n\tgfs2_trans_end(sdp);\nout_ipres:\n\tgfs2_inplace_release(ip);\nout_alloc:\n\tgfs2_alloc_put(ip);\nout_gunlock:\n\tgfs2_glock_dq_uninit(&i_gh);\nout:\n\twhile (qx--)\n\t\tgfs2_glock_dq_uninit(&ghs[qx]);\n\tmutex_unlock(&ip->i_inode.i_mutex);\n\tkfree(ghs);\n\tgfs2_log_flush(ip->i_gl->gl_sbd, ip->i_gl);\n\treturn error;\n}",
        "target": 1
    },
    {
        "func": "static int gfs2_adjust_quota(struct gfs2_inode *ip, loff_t loc,\n\t\t\t     s64 change, struct gfs2_quota_data *qd,\n\t\t\t     struct fs_disk_quota *fdq)\n{\n\tstruct inode *inode = &ip->i_inode;\n\tstruct address_space *mapping = inode->i_mapping;\n\tunsigned long index = loc >> PAGE_CACHE_SHIFT;\n\tunsigned offset = loc & (PAGE_CACHE_SIZE - 1);\n\tunsigned blocksize, iblock, pos;\n\tstruct buffer_head *bh, *dibh;\n\tstruct page *page;\n\tvoid *kaddr;\n\tstruct gfs2_quota *qp;\n\ts64 value;\n\tint err = -EIO;\n\tu64 size;\n\n\tif (gfs2_is_stuffed(ip))\n\t\tgfs2_unstuff_dinode(ip, NULL);\n\t\n\tpage = grab_cache_page(mapping, index);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tblocksize = inode->i_sb->s_blocksize;\n\tiblock = index << (PAGE_CACHE_SHIFT - inode->i_sb->s_blocksize_bits);\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, blocksize, 0);\n\n\tbh = page_buffers(page);\n\tpos = blocksize;\n\twhile (offset >= pos) {\n\t\tbh = bh->b_this_page;\n\t\tiblock++;\n\t\tpos += blocksize;\n\t}\n\n\tif (!buffer_mapped(bh)) {\n\t\tgfs2_block_map(inode, iblock, bh, 1);\n\t\tif (!buffer_mapped(bh))\n\t\t\tgoto unlock;\n\t}\n\n\tif (PageUptodate(page))\n\t\tset_buffer_uptodate(bh);\n\n\tif (!buffer_uptodate(bh)) {\n\t\tll_rw_block(READ_META, 1, &bh);\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh))\n\t\t\tgoto unlock;\n\t}\n\n\tgfs2_trans_add_bh(ip->i_gl, bh, 0);\n\n\tkaddr = kmap_atomic(page, KM_USER0);\n\tqp = kaddr + offset;\n\tvalue = (s64)be64_to_cpu(qp->qu_value) + change;\n\tqp->qu_value = cpu_to_be64(value);\n\tqd->qd_qb.qb_value = qp->qu_value;\n\tif (fdq) {\n\t\tif (fdq->d_fieldmask & FS_DQ_BSOFT) {\n\t\t\tqp->qu_warn = cpu_to_be64(fdq->d_blk_softlimit);\n\t\t\tqd->qd_qb.qb_warn = qp->qu_warn;\n\t\t}\n\t\tif (fdq->d_fieldmask & FS_DQ_BHARD) {\n\t\t\tqp->qu_limit = cpu_to_be64(fdq->d_blk_hardlimit);\n\t\t\tqd->qd_qb.qb_limit = qp->qu_limit;\n\t\t}\n\t}\n\tflush_dcache_page(page);\n\tkunmap_atomic(kaddr, KM_USER0);\n\n\terr = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (err)\n\t\tgoto unlock;\n\n\tsize = loc + sizeof(struct gfs2_quota);\n\tif (size > inode->i_size) {\n\t\tip->i_disksize = size;\n\t\ti_size_write(inode, size);\n\t}\n\tinode->i_mtime = inode->i_atime = CURRENT_TIME;\n\tgfs2_trans_add_bh(ip->i_gl, dibh, 1);\n\tgfs2_dinode_out(ip, dibh->b_data);\n\tbrelse(dibh);\n\tmark_inode_dirty(inode);\n\nunlock:\n\tunlock_page(page);\n\tpage_cache_release(page);\n\treturn err;\n}",
        "target": 1
    },
    {
        "func": "void chain_reply(struct smb_request *req)\n{\n\tsize_t smblen = smb_len(req->inbuf);\n\tsize_t already_used, length_needed;\n\tuint8_t chain_cmd;\n\tuint32_t chain_offset;\t/* uint32_t to avoid overflow */\n\n\tuint8_t wct;\n\tuint16_t *vwv;\n\tuint16_t buflen;\n\tuint8_t *buf;\n\n\tif (IVAL(req->outbuf, smb_rcls) != 0) {\n\t\tfixup_chain_error_packet(req);\n\t}\n\n\t/*\n\t * Any of the AndX requests and replies have at least a wct of\n\t * 2. vwv[0] is the next command, vwv[1] is the offset from the\n\t * beginning of the SMB header to the next wct field.\n\t *\n\t * None of the AndX requests put anything valuable in vwv[0] and [1],\n\t * so we can overwrite it here to form the chain.\n\t */\n\n\tif ((req->wct < 2) || (CVAL(req->outbuf, smb_wct) < 2)) {\n\t\tgoto error;\n\t}\n\n\t/*\n\t * Here we assume that this is the end of the chain. For that we need\n\t * to set \"next command\" to 0xff and the offset to 0. If we later find\n\t * more commands in the chain, this will be overwritten again.\n\t */\n\n\tSCVAL(req->outbuf, smb_vwv0, 0xff);\n\tSCVAL(req->outbuf, smb_vwv0+1, 0);\n\tSSVAL(req->outbuf, smb_vwv1, 0);\n\n\tif (req->chain_outbuf == NULL) {\n\t\t/*\n\t\t * In req->chain_outbuf we collect all the replies. Start the\n\t\t * chain by copying in the first reply.\n\t\t *\n\t\t * We do the realloc because later on we depend on\n\t\t * talloc_get_size to determine the length of\n\t\t * chain_outbuf. The reply_xxx routines might have\n\t\t * over-allocated (reply_pipe_read_and_X used to be such an\n\t\t * example).\n\t\t */\n\t\treq->chain_outbuf = TALLOC_REALLOC_ARRAY(\n\t\t\treq, req->outbuf, uint8_t, smb_len(req->outbuf) + 4);\n\t\tif (req->chain_outbuf == NULL) {\n\t\t\tgoto error;\n\t\t}\n\t\treq->outbuf = NULL;\n\t} else {\n\t\t/*\n\t\t * Update smb headers where subsequent chained commands\n\t\t * may have updated them.\n\t\t */\n\t\tSCVAL(req->chain_outbuf, smb_tid, CVAL(req->outbuf, smb_tid));\n\t\tSCVAL(req->chain_outbuf, smb_uid, CVAL(req->outbuf, smb_uid));\n\n\t\tif (!smb_splice_chain(&req->chain_outbuf,\n\t\t\t\t      CVAL(req->outbuf, smb_com),\n\t\t\t\t      CVAL(req->outbuf, smb_wct),\n\t\t\t\t      (uint16_t *)(req->outbuf + smb_vwv),\n\t\t\t\t      0, smb_buflen(req->outbuf),\n\t\t\t\t      (uint8_t *)smb_buf(req->outbuf))) {\n\t\t\tgoto error;\n\t\t}\n\t\tTALLOC_FREE(req->outbuf);\n\t}\n\n\t/*\n\t * We use the old request's vwv field to grab the next chained command\n\t * and offset into the chained fields.\n\t */\n\n\tchain_cmd = CVAL(req->vwv+0, 0);\n\tchain_offset = SVAL(req->vwv+1, 0);\n\n\tif (chain_cmd == 0xff) {\n\t\t/*\n\t\t * End of chain, no more requests from the client. So ship the\n\t\t * replies.\n\t\t */\n\t\tsmb_setlen((char *)(req->chain_outbuf),\n\t\t\t   talloc_get_size(req->chain_outbuf) - 4);\n\n\t\tif (!srv_send_smb(smbd_server_fd(), (char *)req->chain_outbuf,\n\t\t\t\t  true, req->seqnum+1,\n\t\t\t\t  IS_CONN_ENCRYPTED(req->conn)\n\t\t\t\t  ||req->encrypted,\n\t\t\t\t  &req->pcd)) {\n\t\t\texit_server_cleanly(\"chain_reply: srv_send_smb \"\n\t\t\t\t\t    \"failed.\");\n\t\t}\n\t\tTALLOC_FREE(req->chain_outbuf);\n\t\treq->done = true;\n\t\treturn;\n\t}\n\n\t/* add a new perfcounter for this element of chain */\n\tSMB_PERFCOUNT_ADD(&req->pcd);\n\tSMB_PERFCOUNT_SET_OP(&req->pcd, chain_cmd);\n\tSMB_PERFCOUNT_SET_MSGLEN_IN(&req->pcd, smblen);\n\n\t/*\n\t * Check if the client tries to fool us. The request so far uses the\n\t * space to the end of the byte buffer in the request just\n\t * processed. The chain_offset can't point into that area. If that was\n\t * the case, we could end up with an endless processing of the chain,\n\t * we would always handle the same request.\n\t */\n\n\talready_used = PTR_DIFF(req->buf+req->buflen, smb_base(req->inbuf));\n\tif (chain_offset < already_used) {\n\t\tgoto error;\n\t}\n\n\t/*\n\t * Next check: Make sure the chain offset does not point beyond the\n\t * overall smb request length.\n\t */\n\n\tlength_needed = chain_offset+1;\t/* wct */\n\tif (length_needed > smblen) {\n\t\tgoto error;\n\t}\n\n\t/*\n\t * Now comes the pointer magic. Goal here is to set up req->vwv and\n\t * req->buf correctly again to be able to call the subsequent\n\t * switch_message(). The chain offset (the former vwv[1]) points at\n\t * the new wct field.\n\t */\n\n\twct = CVAL(smb_base(req->inbuf), chain_offset);\n\n\t/*\n\t * Next consistency check: Make the new vwv array fits in the overall\n\t * smb request.\n\t */\n\n\tlength_needed += (wct+1)*sizeof(uint16_t); /* vwv+buflen */\n\tif (length_needed > smblen) {\n\t\tgoto error;\n\t}\n\tvwv = (uint16_t *)(smb_base(req->inbuf) + chain_offset + 1);\n\n\t/*\n\t * Now grab the new byte buffer....\n\t */\n\n\tbuflen = SVAL(vwv+wct, 0);\n\n\t/*\n\t * .. and check that it fits.\n\t */\n\n\tlength_needed += buflen;\n\tif (length_needed > smblen) {\n\t\tgoto error;\n\t}\n\tbuf = (uint8_t *)(vwv+wct+1);\n\n\treq->cmd = chain_cmd;\n\treq->wct = wct;\n\treq->vwv = vwv;\n\treq->buflen = buflen;\n\treq->buf = buf;\n\n\tswitch_message(chain_cmd, req, smblen);\n\n\tif (req->outbuf == NULL) {\n\t\t/*\n\t\t * This happens if the chained command has suspended itself or\n\t\t * if it has called srv_send_smb() itself.\n\t\t */\n\t\treturn;\n\t}\n\n\t/*\n\t * We end up here if the chained command was not itself chained or\n\t * suspended, but for example a close() command. We now need to splice\n\t * the chained commands' outbuf into the already built up chain_outbuf\n\t * and ship the result.\n\t */\n\tgoto done;\n\n error:\n\t/*\n\t * We end up here if there's any error in the chain syntax. Report a\n\t * DOS error, just like Windows does.\n\t */\n\treply_force_doserror(req, ERRSRV, ERRerror);\n\tfixup_chain_error_packet(req);\n\n done:\n\t/*\n\t * This scary statement intends to set the\n\t * FLAGS2_32_BIT_ERROR_CODES flg2 field in req->chain_outbuf\n\t * to the value req->outbuf carries\n\t */\n\tSSVAL(req->chain_outbuf, smb_flg2,\n\t      (SVAL(req->chain_outbuf, smb_flg2) & ~FLAGS2_32_BIT_ERROR_CODES)\n\t      | (SVAL(req->outbuf, smb_flg2) & FLAGS2_32_BIT_ERROR_CODES));\n\n\t/*\n\t * Transfer the error codes from the subrequest to the main one\n\t */\n\tSSVAL(req->chain_outbuf, smb_rcls, SVAL(req->outbuf, smb_rcls));\n\tSSVAL(req->chain_outbuf, smb_err, SVAL(req->outbuf, smb_err));\n\n\tif (!smb_splice_chain(&req->chain_outbuf,\n\t\t\t      CVAL(req->outbuf, smb_com),\n\t\t\t      CVAL(req->outbuf, smb_wct),\n\t\t\t      (uint16_t *)(req->outbuf + smb_vwv),\n\t\t\t      0, smb_buflen(req->outbuf),\n\t\t\t      (uint8_t *)smb_buf(req->outbuf))) {\n\t\texit_server_cleanly(\"chain_reply: smb_splice_chain failed\\n\");\n\t}\n\tTALLOC_FREE(req->outbuf);\n\n\tsmb_setlen((char *)(req->chain_outbuf),\n\t\t   talloc_get_size(req->chain_outbuf) - 4);\n\n\tshow_msg((char *)(req->chain_outbuf));\n\n\tif (!srv_send_smb(smbd_server_fd(), (char *)req->chain_outbuf,\n\t\t\t  true, req->seqnum+1,\n\t\t\t  IS_CONN_ENCRYPTED(req->conn)||req->encrypted,\n\t\t\t  &req->pcd)) {\n\t\texit_server_cleanly(\"construct_reply: srv_send_smb failed.\");\n\t}\n\tTALLOC_FREE(req->chain_outbuf);\n\treq->done = true;\n}",
        "target": 1
    },
    {
        "func": "static void reply_sesssetup_and_X_spnego(struct smb_request *req)\n{\n\tconst uint8 *p;\n\tDATA_BLOB blob1;\n\tsize_t bufrem;\n\tchar *tmp;\n\tconst char *native_os;\n\tconst char *native_lanman;\n\tconst char *primary_domain;\n\tconst char *p2;\n\tuint16 data_blob_len = SVAL(req->vwv+7, 0);\n\tenum remote_arch_types ra_type = get_remote_arch();\n\tint vuid = req->vuid;\n\tuser_struct *vuser = NULL;\n\tNTSTATUS status = NT_STATUS_OK;\n\tuint16 smbpid = req->smbpid;\n\tstruct smbd_server_connection *sconn = smbd_server_conn;\n\n\tDEBUG(3,(\"Doing spnego session setup\\n\"));\n\n\tif (global_client_caps == 0) {\n\t\tglobal_client_caps = IVAL(req->vwv+10, 0);\n\n\t\tif (!(global_client_caps & CAP_STATUS32)) {\n\t\t\tremove_from_common_flags2(FLAGS2_32_BIT_ERROR_CODES);\n\t\t}\n\n\t}\n\n\tp = req->buf;\n\n\tif (data_blob_len == 0) {\n\t\t/* an invalid request */\n\t\treply_nterror(req, nt_status_squash(NT_STATUS_LOGON_FAILURE));\n\t\treturn;\n\t}\n\n\tbufrem = smbreq_bufrem(req, p);\n\t/* pull the spnego blob */\n\tblob1 = data_blob(p, MIN(bufrem, data_blob_len));\n\n#if 0\n\tfile_save(\"negotiate.dat\", blob1.data, blob1.length);\n#endif\n\n\tp2 = (char *)req->buf + data_blob_len;\n\n\tp2 += srvstr_pull_req_talloc(talloc_tos(), req, &tmp, p2,\n\t\t\t\t     STR_TERMINATE);\n\tnative_os = tmp ? tmp : \"\";\n\n\tp2 += srvstr_pull_req_talloc(talloc_tos(), req, &tmp, p2,\n\t\t\t\t     STR_TERMINATE);\n\tnative_lanman = tmp ? tmp : \"\";\n\n\tp2 += srvstr_pull_req_talloc(talloc_tos(), req, &tmp, p2,\n\t\t\t\t     STR_TERMINATE);\n\tprimary_domain = tmp ? tmp : \"\";\n\n\tDEBUG(3,(\"NativeOS=[%s] NativeLanMan=[%s] PrimaryDomain=[%s]\\n\",\n\t\tnative_os, native_lanman, primary_domain));\n\n\tif ( ra_type == RA_WIN2K ) {\n\t\t/* Vista sets neither the OS or lanman strings */\n\n\t\tif ( !strlen(native_os) && !strlen(native_lanman) )\n\t\t\tset_remote_arch(RA_VISTA);\n\n\t\t/* Windows 2003 doesn't set the native lanman string,\n\t\t   but does set primary domain which is a bug I think */\n\n\t\tif ( !strlen(native_lanman) ) {\n\t\t\tra_lanman_string( primary_domain );\n\t\t} else {\n\t\t\tra_lanman_string( native_lanman );\n\t\t}\n\t}\n\n\t/* Did we get a valid vuid ? */\n\tif (!is_partial_auth_vuid(sconn, vuid)) {\n\t\t/* No, then try and see if this is an intermediate sessionsetup\n\t\t * for a large SPNEGO packet. */\n\t\tstruct pending_auth_data *pad;\n\t\tpad = get_pending_auth_data(sconn, smbpid);\n\t\tif (pad) {\n\t\t\tDEBUG(10,(\"reply_sesssetup_and_X_spnego: found \"\n\t\t\t\t\"pending vuid %u\\n\",\n\t\t\t\t(unsigned int)pad->vuid ));\n\t\t\tvuid = pad->vuid;\n\t\t}\n\t}\n\n\t/* Do we have a valid vuid now ? */\n\tif (!is_partial_auth_vuid(sconn, vuid)) {\n\t\t/* No, start a new authentication setup. */\n\t\tvuid = register_initial_vuid(sconn);\n\t\tif (vuid == UID_FIELD_INVALID) {\n\t\t\tdata_blob_free(&blob1);\n\t\t\treply_nterror(req, nt_status_squash(\n\t\t\t\t\t      NT_STATUS_INVALID_PARAMETER));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tvuser = get_partial_auth_user_struct(sconn, vuid);\n\t/* This MUST be valid. */\n\tif (!vuser) {\n\t\tsmb_panic(\"reply_sesssetup_and_X_spnego: invalid vuid.\");\n\t}\n\n\t/* Large (greater than 4k) SPNEGO blobs are split into multiple\n\t * sessionsetup requests as the Windows limit on the security blob\n\t * field is 4k. Bug #4400. JRA.\n\t */\n\n\tstatus = check_spnego_blob_complete(sconn, smbpid, vuid, &blob1);\n\tif (!NT_STATUS_IS_OK(status)) {\n\t\tif (!NT_STATUS_EQUAL(status,\n\t\t\t\tNT_STATUS_MORE_PROCESSING_REQUIRED)) {\n\t\t\t/* Real error - kill the intermediate vuid */\n\t\t\tinvalidate_vuid(sconn, vuid);\n\t\t}\n\t\tdata_blob_free(&blob1);\n\t\treply_nterror(req, nt_status_squash(status));\n\t\treturn;\n\t}\n\n\tif (blob1.data[0] == ASN1_APPLICATION(0)) {\n\n\t\t/* its a negTokenTarg packet */\n\n\t\treply_spnego_negotiate(req, vuid, blob1,\n\t\t\t\t       &vuser->auth_ntlmssp_state);\n\t\tdata_blob_free(&blob1);\n\t\treturn;\n\t}\n\n\tif (blob1.data[0] == ASN1_CONTEXT(1)) {\n\n\t\t/* its a auth packet */\n\n\t\treply_spnego_auth(req, vuid, blob1,\n\t\t\t\t  &vuser->auth_ntlmssp_state);\n\t\tdata_blob_free(&blob1);\n\t\treturn;\n\t}\n\n\tif (strncmp((char *)(blob1.data), \"NTLMSSP\", 7) == 0) {\n\t\tDATA_BLOB chal;\n\n\t\tif (!vuser->auth_ntlmssp_state) {\n\t\t\tstatus = auth_ntlmssp_start(&vuser->auth_ntlmssp_state);\n\t\t\tif (!NT_STATUS_IS_OK(status)) {\n\t\t\t\t/* Kill the intermediate vuid */\n\t\t\t\tinvalidate_vuid(sconn, vuid);\n\t\t\t\tdata_blob_free(&blob1);\n\t\t\t\treply_nterror(req, nt_status_squash(status));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tstatus = auth_ntlmssp_update(vuser->auth_ntlmssp_state,\n\t\t\t\t\t\tblob1, &chal);\n\n\t\tdata_blob_free(&blob1);\n\n\t\treply_spnego_ntlmssp(req, vuid,\n\t\t\t\t     &vuser->auth_ntlmssp_state,\n\t\t\t\t     &chal, status, OID_NTLMSSP, false);\n\t\tdata_blob_free(&chal);\n\t\treturn;\n\t}\n\n\t/* what sort of packet is this? */\n\tDEBUG(1,(\"Unknown packet in reply_sesssetup_and_X_spnego\\n\"));\n\n\tdata_blob_free(&blob1);\n\n\treply_nterror(req, nt_status_squash(NT_STATUS_LOGON_FAILURE));\n}",
        "target": 1
    },
    {
        "func": "void chain_reply(struct smb_request *req)\n{\n\tsize_t smblen = smb_len(req->inbuf);\n\tsize_t already_used, length_needed;\n\tuint8_t chain_cmd;\n\tuint32_t chain_offset;\t/* uint32_t to avoid overflow */\n\n\tuint8_t wct;\n\tuint16_t *vwv;\n\tuint16_t buflen;\n\tuint8_t *buf;\n\n\tif (IVAL(req->outbuf, smb_rcls) != 0) {\n\t\tfixup_chain_error_packet(req);\n\t}\n\n\t/*\n\t * Any of the AndX requests and replies have at least a wct of\n\t * 2. vwv[0] is the next command, vwv[1] is the offset from the\n\t * beginning of the SMB header to the next wct field.\n\t *\n\t * None of the AndX requests put anything valuable in vwv[0] and [1],\n\t * so we can overwrite it here to form the chain.\n\t */\n\n\tif ((req->wct < 2) || (CVAL(req->outbuf, smb_wct) < 2)) {\n\t\tgoto error;\n\t}\n\n\t/*\n\t * Here we assume that this is the end of the chain. For that we need\n\t * to set \"next command\" to 0xff and the offset to 0. If we later find\n\t * more commands in the chain, this will be overwritten again.\n\t */\n\n\tSCVAL(req->outbuf, smb_vwv0, 0xff);\n\tSCVAL(req->outbuf, smb_vwv0+1, 0);\n\tSSVAL(req->outbuf, smb_vwv1, 0);\n\n\tif (req->chain_outbuf == NULL) {\n\t\t/*\n\t\t * In req->chain_outbuf we collect all the replies. Start the\n\t\t * chain by copying in the first reply.\n\t\t *\n\t\t * We do the realloc because later on we depend on\n\t\t * talloc_get_size to determine the length of\n\t\t * chain_outbuf. The reply_xxx routines might have\n\t\t * over-allocated (reply_pipe_read_and_X used to be such an\n\t\t * example).\n\t\t */\n\t\treq->chain_outbuf = TALLOC_REALLOC_ARRAY(\n\t\t\treq, req->outbuf, uint8_t, smb_len(req->outbuf) + 4);\n\t\tif (req->chain_outbuf == NULL) {\n\t\t\tgoto error;\n\t\t}\n\t\treq->outbuf = NULL;\n\t} else {\n\t\t/*\n\t\t * Update smb headers where subsequent chained commands\n\t\t * may have updated them.\n\t\t */\n\t\tSCVAL(req->chain_outbuf, smb_tid, CVAL(req->outbuf, smb_tid));\n\t\tSCVAL(req->chain_outbuf, smb_uid, CVAL(req->outbuf, smb_uid));\n\n\t\tif (!smb_splice_chain(&req->chain_outbuf,\n\t\t\t\t      CVAL(req->outbuf, smb_com),\n\t\t\t\t      CVAL(req->outbuf, smb_wct),\n\t\t\t\t      (uint16_t *)(req->outbuf + smb_vwv),\n\t\t\t\t      0, smb_buflen(req->outbuf),\n\t\t\t\t      (uint8_t *)smb_buf(req->outbuf))) {\n\t\t\tgoto error;\n\t\t}\n\t\tTALLOC_FREE(req->outbuf);\n\t}\n\n\t/*\n\t * We use the old request's vwv field to grab the next chained command\n\t * and offset into the chained fields.\n\t */\n\n\tchain_cmd = CVAL(req->vwv+0, 0);\n\tchain_offset = SVAL(req->vwv+1, 0);\n\n\tif (chain_cmd == 0xff) {\n\t\t/*\n\t\t * End of chain, no more requests from the client. So ship the\n\t\t * replies.\n\t\t */\n\t\tsmb_setlen((char *)(req->chain_outbuf),\n\t\t\t   talloc_get_size(req->chain_outbuf) - 4);\n\n\t\tif (!srv_send_smb(smbd_server_fd(), (char *)req->chain_outbuf,\n\t\t\t\t  true, req->seqnum+1,\n\t\t\t\t  IS_CONN_ENCRYPTED(req->conn)\n\t\t\t\t  ||req->encrypted,\n\t\t\t\t  &req->pcd)) {\n\t\t\texit_server_cleanly(\"chain_reply: srv_send_smb \"\n\t\t\t\t\t    \"failed.\");\n\t\t}\n\t\tTALLOC_FREE(req);\n\n\t\treturn;\n\t}\n\n\t/* add a new perfcounter for this element of chain */\n\tSMB_PERFCOUNT_ADD(&req->pcd);\n\tSMB_PERFCOUNT_SET_OP(&req->pcd, chain_cmd);\n\tSMB_PERFCOUNT_SET_MSGLEN_IN(&req->pcd, smblen);\n\n\t/*\n\t * Check if the client tries to fool us. The request so far uses the\n\t * space to the end of the byte buffer in the request just\n\t * processed. The chain_offset can't point into that area. If that was\n\t * the case, we could end up with an endless processing of the chain,\n\t * we would always handle the same request.\n\t */\n\n\talready_used = PTR_DIFF(req->buf+req->buflen, smb_base(req->inbuf));\n\tif (chain_offset < already_used) {\n\t\tgoto error;\n\t}\n\n\t/*\n\t * Next check: Make sure the chain offset does not point beyond the\n\t * overall smb request length.\n\t */\n\n\tlength_needed = chain_offset+1;\t/* wct */\n\tif (length_needed > smblen) {\n\t\tgoto error;\n\t}\n\n\t/*\n\t * Now comes the pointer magic. Goal here is to set up req->vwv and\n\t * req->buf correctly again to be able to call the subsequent\n\t * switch_message(). The chain offset (the former vwv[1]) points at\n\t * the new wct field.\n\t */\n\n\twct = CVAL(smb_base(req->inbuf), chain_offset);\n\n\t/*\n\t * Next consistency check: Make the new vwv array fits in the overall\n\t * smb request.\n\t */\n\n\tlength_needed += (wct+1)*sizeof(uint16_t); /* vwv+buflen */\n\tif (length_needed > smblen) {\n\t\tgoto error;\n\t}\n\tvwv = (uint16_t *)(smb_base(req->inbuf) + chain_offset + 1);\n\n\t/*\n\t * Now grab the new byte buffer....\n\t */\n\n\tbuflen = SVAL(vwv+wct, 0);\n\n\t/*\n\t * .. and check that it fits.\n\t */\n\n\tlength_needed += buflen;\n\tif (length_needed > smblen) {\n\t\tgoto error;\n\t}\n\tbuf = (uint8_t *)(vwv+wct+1);\n\n\treq->cmd = chain_cmd;\n\treq->wct = wct;\n\treq->vwv = vwv;\n\treq->buflen = buflen;\n\treq->buf = buf;\n\n\tswitch_message(chain_cmd, req, smblen);\n\n\tif (req->outbuf == NULL) {\n\t\t/*\n\t\t * This happens if the chained command has suspended itself or\n\t\t * if it has called srv_send_smb() itself.\n\t\t */\n\t\treturn;\n\t}\n\n\t/*\n\t * We end up here if the chained command was not itself chained or\n\t * suspended, but for example a close() command. We now need to splice\n\t * the chained commands' outbuf into the already built up chain_outbuf\n\t * and ship the result.\n\t */\n\tgoto done;\n\n error:\n\t/*\n\t * We end up here if there's any error in the chain syntax. Report a\n\t * DOS error, just like Windows does.\n\t */\n\treply_nterror(req, NT_STATUS_DOS(ERRSRV, ERRerror));\n\tfixup_chain_error_packet(req);\n\n done:\n\tif (!smb_splice_chain(&req->chain_outbuf,\n\t\t\t      CVAL(req->outbuf, smb_com),\n\t\t\t      CVAL(req->outbuf, smb_wct),\n\t\t\t      (uint16_t *)(req->outbuf + smb_vwv),\n\t\t\t      0, smb_buflen(req->outbuf),\n\t\t\t      (uint8_t *)smb_buf(req->outbuf))) {\n\t\texit_server_cleanly(\"chain_reply: smb_splice_chain failed\\n\");\n\t}\n\tTALLOC_FREE(req->outbuf);\n\n\tsmb_setlen((char *)(req->chain_outbuf),\n\t\t   talloc_get_size(req->chain_outbuf) - 4);\n\n\tshow_msg((char *)(req->chain_outbuf));\n\n\tif (!srv_send_smb(smbd_server_fd(), (char *)req->chain_outbuf,\n\t\t\t  true, req->seqnum+1,\n\t\t\t  IS_CONN_ENCRYPTED(req->conn)||req->encrypted,\n\t\t\t  &req->pcd)) {\n\t\texit_server_cleanly(\"construct_reply: srv_send_smb failed.\");\n\t}\n\tTALLOC_FREE(req);\n}",
        "target": 1
    },
    {
        "func": "_gnutls_x509_oid2mac_algorithm (const char *oid)\n{\n  gnutls_mac_algorithm_t ret = 0;\n\n  GNUTLS_HASH_LOOP (if (strcmp (oid, p->oid) == 0)\n\t\t    {\n\t\t    ret = p->id; break;}\n  );\n\n  if (ret == 0)\n    return GNUTLS_MAC_UNKNOWN;\n  return ret;\n}",
        "target": 1
    },
    {
        "func": "cli_pdf(const char *dir, cli_ctx *ctx, off_t offset)\n{\n\toff_t size;\t/* total number of bytes in the file */\n\toff_t bytesleft, trailerlength;\n\tchar *buf;\t/* start of memory mapped area */\n\tconst char *p, *q, *trailerstart;\n\tconst char *xrefstart;\t/* cross reference table */\n\t/*size_t xreflength;*/\n\tint printed_predictor_message, printed_embedded_font_message, rc;\n\tunsigned int files;\n\tfmap_t *map = *ctx->fmap;\n\tint opt_failed = 0;\n\n\tcli_dbgmsg(\"in cli_pdf(%s)\\n\", dir);\n\tsize = map->len - offset;\n\n\tif(size <= 7)\t/* doesn't even include the file header */\n\t\treturn CL_CLEAN;\n\n\tp = buf = fmap_need_off_once(map, 0, size); /* FIXME: really port to fmap */\n\tif(!buf) {\n\t\tcli_errmsg(\"cli_pdf: mmap() failed\\n\");\n\t\treturn CL_EMAP;\n\t}\n\n\tcli_dbgmsg(\"cli_pdf: scanning %lu bytes\\n\", (unsigned long)size);\n\n\t/* Lines are terminated by \\r, \\n or both */\n\n\t/* File Header */\n\tbytesleft = size - 5;\n\tfor(q = p; bytesleft; bytesleft--, q++) {\n\t    if(!strncasecmp(q, \"%PDF-\", 5)) {\n\t\tbytesleft = size - (off_t) (q - p);\n\t\tp = q;\n\t\tbreak;\n\t    }\n\t}\n\n\tif(!bytesleft) {\n\t    cli_dbgmsg(\"cli_pdf: file header not found\\n\");\n\t    return CL_CLEAN;\n\t}\n\n\t/* Find the file trailer */\n\tfor(q = &p[bytesleft - 5]; q > p; --q)\n\t\tif(strncasecmp(q, \"%%EOF\", 5) == 0)\n\t\t\tbreak;\n\n\tif(q <= p) {\n\t\tcli_dbgmsg(\"cli_pdf: trailer not found\\n\");\n\t\treturn CL_CLEAN;\n\t}\n\n\tfor(trailerstart = &q[-7]; trailerstart > p; --trailerstart)\n\t\tif(memcmp(trailerstart, \"trailer\", 7) == 0)\n\t\t\tbreak;\n\n\t/*\n\t * q points to the end of the trailer section\n\t */\n\ttrailerlength = (long)(q - trailerstart);\n\tif(cli_memstr(trailerstart, trailerlength, \"Encrypt\", 7)) {\n\t\t/*\n\t\t * This tends to mean that the file is, in effect, read-only\n\t\t * http://www.cs.cmu.edu/~dst/Adobe/Gallery/anon21jul01-pdf-encryption.txt\n\t\t * http://www.adobe.com/devnet/pdf/\n\t\t */\n\t\tcli_dbgmsg(\"cli_pdf: Encrypted PDF files not yet supported\\n\");\n\t\treturn CL_CLEAN;\n\t}\n\n\t/*\n\t * not true, since edits may put data after the trailer\n\tbytesleft -= trailerlength;\n\t */\n\n\t/*\n\t * FIXME: Handle more than one xref section in the xref table\n\t */\n\tfor(xrefstart = trailerstart; xrefstart > p; --xrefstart)\n\t\tif(memcmp(xrefstart, \"xref\", 4) == 0)\n\t\t\t/*\n\t\t\t * Make sure it's the start of the line, not a startxref\n\t\t\t * token\n\t\t\t */\n\t\t\tif((xrefstart[-1] == '\\n') || (xrefstart[-1] == '\\r'))\n\t\t\t\tbreak;\n\n\tif(xrefstart == p) {\n\t\tcli_dbgmsg(\"cli_pdf: xref not found\\n\");\n\t\treturn CL_CLEAN;\n\t}\n\n\tprinted_predictor_message = printed_embedded_font_message = 0;\n\n\t/*\n\t * not true, since edits may put data after the trailer\n\txreflength = (size_t)(trailerstart - xrefstart);\n\tbytesleft -= xreflength;\n\t */\n\n\tfiles = 0;\n\n\trc = CL_CLEAN;\n\n\t/*\n\t * The body section consists of a sequence of indirect objects\n\t */\n\twhile((p < xrefstart) && (cli_checklimits(\"cli_pdf\", ctx, 0, 0, 0)==CL_CLEAN) &&\n\t      ((q = pdf_nextobject(p, bytesleft)) != NULL)) {\n\t\tint is_ascii85decode, is_flatedecode, fout, len, has_cr;\n\t\t/*int object_number, generation_number;*/\n\t\tconst char *objstart, *objend, *streamstart, *streamend;\n\t\tunsigned long length, objlen, real_streamlen, calculated_streamlen;\n\t\tint is_embedded_font, predictor;\n\t\tchar fullname[NAME_MAX + 1];\n\n\t\trc = CL_CLEAN;\n\t\tif(q == xrefstart)\n\t\t\tbreak;\n\t\tif(memcmp(q, \"xref\", 4) == 0)\n\t\t\tbreak;\n\n\t\t/*object_number = atoi(q);*/\n\t\tbytesleft -= (off_t)(q - p);\n\t\tp = q;\n\n\t\tif(memcmp(q, \"endobj\", 6) == 0)\n\t\t\tcontinue;\n\t\tif(!isdigit(*q)) {\n\t\t\tcli_dbgmsg(\"cli_pdf: Object number missing\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tq = pdf_nextobject(p, bytesleft);\n\t\tif((q == NULL) || !isdigit(*q)) {\n\t\t\tcli_dbgmsg(\"cli_pdf: Generation number missing\\n\");\n\t\t\tbreak;\n\t\t}\n\t\t/*generation_number = atoi(q);*/\n\t\tbytesleft -= (off_t)(q - p);\n\t\tp = q;\n\n\t\tq = pdf_nextobject(p, bytesleft);\n\t\tif((q == NULL) || (memcmp(q, \"obj\", 3) != 0)) {\n\t\t\tcli_dbgmsg(\"cli_pdf: Indirect object missing \\\"obj\\\"\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tbytesleft -= (off_t)((q - p) + 3);\n\t\tobjstart = p = &q[3];\n\t\tobjend = cli_memstr(p, bytesleft, \"endobj\", 6);\n\t\tif(objend == NULL) {\n\t\t\tcli_dbgmsg(\"cli_pdf: No matching endobj\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tbytesleft -= (off_t)((objend - p) + 6);\n\t\tp = &objend[6];\n\t\tobjlen = (unsigned long)(objend - objstart);\n\n\t\t/* Is this object a stream? */\n\t\tstreamstart = cli_memstr(objstart, objlen, \"stream\", 6);\n\t\tif(streamstart == NULL)\n\t\t\tcontinue;\n\n\t\tis_embedded_font = length = is_ascii85decode =\n\t\t\tis_flatedecode = 0;\n\t\tpredictor = 1;\n\n\t\t/*\n\t\t * TODO: handle F and FFilter?\n\t\t */\n\t\tq = objstart;\n\t\twhile(q < streamstart) {\n\t\t\tif(*q == '/') {\t/* name object */\n\t\t\t\t/*cli_dbgmsg(\"Name object %8.8s\\n\", q+1, q+1);*/\n\t\t\t\tif(strncmp(++q, \"Length \", 7) == 0) {\n\t\t\t\t\tq += 7;\n\t\t\t\t\tlength = atoi(q);\n\t\t\t\t\twhile(isdigit(*q))\n\t\t\t\t\t\tq++;\n\t\t\t\t\t/*\n\t\t\t\t\t * Note: incremental updates are not\n\t\t\t\t\t *\tsupported\n\t\t\t\t\t */\n\t\t\t\t\tif((bytesleft > 11) && strncmp(q, \" 0 R\", 4) == 0) {\n\t\t\t\t\t\tconst char *r, *nq;\n\t\t\t\t\t\tchar b[14];\n\n\t\t\t\t\t\tq += 4;\n\t\t\t\t\t\tcli_dbgmsg(\"cli_pdf: Length is in indirect obj %lu\\n\",\n\t\t\t\t\t\t\tlength);\n\t\t\t\t\t\tsnprintf(b, sizeof(b),\n\t\t\t\t\t\t\t\"%lu 0 obj\", length);\n\t\t\t\t\t\tlength = (unsigned long)strlen(b);\n\t\t\t\t\t\t/* optimization: assume objects\n\t\t\t\t\t\t * are sequential */\n\t\t\t\t\t\tif(!opt_failed) {\n\t\t\t\t\t\t    nq = q;\n\t\t\t\t\t\t    len = buf + size - q;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t    nq = buf;\n\t\t\t\t\t\t    len = q - buf;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tr = cli_memstr(nq, len, b, length);\n\t\t\t\t\t\t\tif (r > nq) {\n\t\t\t\t\t\t\t\tconst char x = *(r-1);\n\t\t\t\t\t\t\t\tif (x == '\\n' || x=='\\r') {\n\t\t\t\t\t\t\t\t\t--r;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (r) {\n\t\t\t\t\t\t\t\tlen -= r + length - nq;\n\t\t\t\t\t\t\t\tnq = r + length;\n\t\t\t\t\t\t\t} else if (!opt_failed) {\n\t\t\t\t\t\t\t\t/* we failed optimized match,\n\t\t\t\t\t\t\t\t * try matching from the beginning\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tlen = q - buf;\n\t\t\t\t\t\t\t\tr = nq = buf;\n\t\t\t\t\t\t\t\t/* prevent\n\t\t\t\t\t\t\t\t * infloop */\n\t\t\t\t\t\t\t\topt_failed = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} while (r);\n\t\t\t\t\t\tif(r) {\n\t\t\t\t\t\t\tr += length - 1;\n\t\t\t\t\t\t\tr = pdf_nextobject(r, bytesleft - (r - q));\n\t\t\t\t\t\t\tif(r) {\n\t\t\t\t\t\t\t\tlength = atoi(r);\n\t\t\t\t\t\t\t\twhile(isdigit(*r))\n\t\t\t\t\t\t\t\t\tr++;\n\t\t\t\t\t\t\t\tcli_dbgmsg(\"cli_pdf: length in '%s' %lu\\n\",\n\t\t\t\t\t\t\t\t\t&b[1],\n\t\t\t\t\t\t\t\t\tlength);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tcli_dbgmsg(\"cli_pdf: Couldn't find '%s'\\n\",\n\t\t\t\t\t\t\t\t&b[1]);\n\t\t\t\t\t}\n\t\t\t\t\tq--;\n\t\t\t\t} else if(strncmp(q, \"Length2 \", 8) == 0)\n\t\t\t\t\tis_embedded_font = 1;\n\t\t\t\telse if(strncmp(q, \"Predictor \", 10) == 0) {\n\t\t\t\t\tq += 10;\n\t\t\t\t\tpredictor = atoi(q);\n\t\t\t\t\twhile(isdigit(*q))\n\t\t\t\t\t\tq++;\n\t\t\t\t\tq--;\n\t\t\t\t} else if(strncmp(q, \"FlateDecode\", 11) == 0) {\n\t\t\t\t\tis_flatedecode = 1;\n\t\t\t\t\tq += 11;\n\t\t\t\t} else if(strncmp(q, \"ASCII85Decode\", 13) == 0) {\n\t\t\t\t\tis_ascii85decode = 1;\n\t\t\t\t\tq += 13;\n\t\t\t\t}\n\t\t\t}\n\t\t\tq = pdf_nextobject(q, (size_t)(streamstart - q));\n\t\t\tif(q == NULL)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif(is_embedded_font) {\n\t\t\t/*\n\t\t\t * Need some documentation, the only I can find a\n\t\t\t * reference to is not free, if some kind soul wishes\n\t\t\t * to donate a copy, please contact me!\n\t\t\t * (http://safari.adobepress.com/0321304748)\n\t\t\t */\n\t\t\tif(!printed_embedded_font_message) {\n\t\t\t\tcli_dbgmsg(\"cli_pdf: Embedded fonts not yet supported\\n\");\n\t\t\t\tprinted_embedded_font_message = 1;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif(predictor > 1) {\n\t\t\t/*\n\t\t\t * Needs some thought\n\t\t\t */\n\t\t\tif(!printed_predictor_message) {\n\t\t\t\tcli_dbgmsg(\"cli_pdf: Predictor %d not honoured for embedded image\\n\",\n\t\t\t\t\tpredictor);\n\t\t\t\tprinted_predictor_message = 1;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* objend points to the end of the object (start of \"endobj\") */\n\t\tstreamstart += 6;\t/* go past the word \"stream\" */\n\t\tlen = (int)(objend - streamstart);\n\t\tq = pdf_nextlinestart(streamstart, len);\n\t\tif(q == NULL)\n\t\t\tbreak;\n\t\tlen -= (int)(q - streamstart);\n\t\tstreamstart = q;\n\t\tstreamend = cli_memstr(streamstart, len, \"endstream\\n\", 10);\n\t\tif(streamend == NULL) {\n\t\t\tstreamend = cli_memstr(streamstart, len, \"endstream\\r\", 10);\n\t\t\tif(streamend == NULL) {\n\t\t\t\tcli_dbgmsg(\"cli_pdf: No endstream\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\thas_cr = 1;\n\t\t} else\n\t\t\thas_cr = 0;\n\t\tsnprintf(fullname, sizeof(fullname), \"%s\"PATHSEP\"pdf%02u\", dir, files);\n\t\tfout = open(fullname, O_RDWR|O_CREAT|O_EXCL|O_TRUNC|O_BINARY, 0600);\n\t\tif(fout < 0) {\n\t\t\tchar err[128];\n\t\t\tcli_errmsg(\"cli_pdf: can't create temporary file %s: %s\\n\", fullname, cli_strerror(errno, err, sizeof(err)));\n\t\t\trc = CL_ETMPFILE;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Calculate the length ourself, the Length parameter is often\n\t\t * wrong\n\t\t */\n\t\tif((*--streamend != '\\n') && (*streamend != '\\r'))\n\t\t\tstreamend++;\n\t\telse if(has_cr && (*--streamend != '\\r'))\n\t\t\tstreamend++;\n\n\t\tif(streamend <= streamstart) {\n\t\t\tclose(fout);\n\t\t\tcli_dbgmsg(\"cli_pdf: Empty stream\\n\");\n\t\t\tif (cli_unlink(fullname)) {\n\t\t\t\trc = CL_EUNLINK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tcalculated_streamlen = (int)(streamend - streamstart);\n\t\treal_streamlen = length;\n\n\t\tcli_dbgmsg(\"cli_pdf: length %lu, calculated_streamlen %lu isFlate %d isASCII85 %d\\n\",\n\t\t\tlength, calculated_streamlen,\n\t\t\tis_flatedecode, is_ascii85decode);\n\n\t\tif(calculated_streamlen != real_streamlen) {\n\t\t\tcli_dbgmsg(\"cli_pdf: Incorrect Length field in file attempting to recover\\n\");\n\t\t\tif(real_streamlen > calculated_streamlen)\n\t\t\t\treal_streamlen = calculated_streamlen;\n\t\t}\n#if\t0\n\t\t/* FIXME: this isn't right... */\n\t\tif(length)\n\t\t\t/*streamlen = (is_flatedecode) ? length : MIN(length, streamlen);*/\n\t\t\tstreamlen = MIN(length, streamlen);\n#endif\n\n\t\tif(is_ascii85decode) {\n\t\t\tunsigned char *tmpbuf;\n\t\t\tint ret = cli_checklimits(\"cli_pdf\", ctx, calculated_streamlen * 5, calculated_streamlen, real_streamlen);\n\n\t\t\tif(ret != CL_CLEAN) {\n\t\t\t\tclose(fout);\n\t\t\t\tif (cli_unlink(fullname)) {\n\t\t\t\t\trc = CL_EUNLINK;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttmpbuf = cli_malloc(calculated_streamlen * 5);\n\n\t\t\tif(tmpbuf == NULL) {\n\t\t\t\tclose(fout);\n\t\t\t\tif (cli_unlink(fullname)) {\n\t\t\t\t\trc = CL_EUNLINK;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = ascii85decode(streamstart, calculated_streamlen, tmpbuf);\n\n\t\t\tif(ret == -1) {\n\t\t\t\tfree(tmpbuf);\n\t\t\t\tclose(fout);\n\t\t\t\tif (cli_unlink(fullname)) {\n\t\t\t\t\trc = CL_EUNLINK;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(ret) {\n\t\t\t\tunsigned char *t;\n\n\t\t\t\treal_streamlen = ret;\n\t\t\t\t/* free unused trailing bytes */\n\t\t\t\tt = (unsigned char *)cli_realloc(tmpbuf,calculated_streamlen);\n\t\t\t\tif(t == NULL) {\n\t\t\t\t\tfree(tmpbuf);\n\t\t\t\t\tclose(fout);\n\t\t\t\t\tif (cli_unlink(fullname)) {\n\t\t\t\t\t\trc = CL_EUNLINK;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ttmpbuf = t;\n\t\t\t\t/*\n\t\t\t\t * Note that it will probably be both\n\t\t\t\t * ascii85encoded and flateencoded\n\t\t\t\t */\n\n\t\t\t\tif(is_flatedecode)\n\t\t\t\t\trc = try_flatedecode((unsigned char *)tmpbuf, real_streamlen, real_streamlen, fout, ctx);\n\t\t\t\telse\n\t\t\t\t  rc = (unsigned long)cli_writen(fout, (const char *)streamstart, real_streamlen)==real_streamlen ? CL_CLEAN : CL_EWRITE;\n\t\t\t}\n\t\t\tfree(tmpbuf);\n\t\t} else if(is_flatedecode) {\n\t\t\trc = try_flatedecode((unsigned char *)streamstart, real_streamlen, calculated_streamlen, fout, ctx);\n\n\t\t} else {\n\t\t\tcli_dbgmsg(\"cli_pdf: writing %lu bytes from the stream\\n\",\n\t\t\t\t(unsigned long)real_streamlen);\n\t\t\tif((rc = cli_checklimits(\"cli_pdf\", ctx, real_streamlen, 0, 0))==CL_CLEAN)\n\t\t\t\trc = (unsigned long)cli_writen(fout, (const char *)streamstart, real_streamlen) == real_streamlen ? CL_CLEAN : CL_EWRITE;\n\t\t}\n\n\t\tif (rc == CL_CLEAN) {\n\t\t\tcli_dbgmsg(\"cli_pdf: extracted file %u to %s\\n\", files, fullname);\n\t\t\tfiles++;\n\t\n\t\t\tlseek(fout, 0, SEEK_SET);\n\t\t\trc = cli_magic_scandesc(fout, ctx);\n\t\t}\n\t\tclose(fout);\n\t\tif(!ctx->engine->keeptmp)\n\t\t\tif (cli_unlink(fullname)) rc = CL_EUNLINK;\n\t\tif(rc != CL_CLEAN) break;\n\t}\n\n\n\tcli_dbgmsg(\"cli_pdf: returning %d\\n\", rc);\n\treturn rc;\n}",
        "target": 1
    },
    {
        "func": "int cli_pdf(const char *dir, cli_ctx *ctx, off_t offset)\n{\n    struct pdf_struct pdf;\n    fmap_t *map = *ctx->fmap;\n    size_t size = map->len - offset;\n    off_t versize = size > 1032 ? 1032 : size;\n    off_t map_off, bytesleft;\n    long xref;\n    const char *pdfver, *start, *eofmap, *q, *eof;\n    int rc;\n    unsigned i;\n\n    cli_dbgmsg(\"in cli_pdf(%s)\\n\", dir);\n    memset(&pdf, 0, sizeof(pdf));\n    pdf.ctx = ctx;\n    pdf.dir = dir;\n\n    pdfver = start = fmap_need_off_once(map, offset, versize);\n\n    /* Check PDF version */\n    if (!pdfver) {\n\tcli_errmsg(\"cli_pdf: mmap() failed (1)\\n\");\n\treturn CL_EMAP;\n    }\n    /* offset is 0 when coming from filetype2 */\n    pdfver = cli_memstr(pdfver, versize, \"%PDF-\", 5);\n    if (!pdfver) {\n\tcli_dbgmsg(\"cli_pdf: no PDF- header found\\n\");\n\treturn CL_SUCCESS;\n    }\n    /* Check for PDF-1.[0-9]. Although 1.7 is highest now, allow for future\n     * versions */\n    if (pdfver[5] != '1' || pdfver[6] != '.' ||\n\tpdfver[7] < '1' || pdfver[7] > '9') {\n\tpdf.flags |= 1 << BAD_PDF_VERSION;\n\tcli_dbgmsg(\"cli_pdf: bad pdf version: %.8s\\n\", pdfver);\n    }\n    if (pdfver != start || offset) {\n\tpdf.flags |= 1 << BAD_PDF_HEADERPOS;\n\tcli_dbgmsg(\"cli_pdf: PDF header is not at position 0: %ld\\n\",pdfver-start+offset);\n    }\n    offset += pdfver - start;\n\n    /* find trailer and xref, don't fail if not found */\n    map_off = map->len - 2048;\n    if (map_off < 0)\n\tmap_off = 0;\n    bytesleft = map->len - map_off;\n    eofmap = fmap_need_off_once(map, map_off, bytesleft);\n    if (!eofmap) {\n\tcli_errmsg(\"cli_pdf: mmap() failed (2)\\n\");\n\treturn CL_EMAP;\n    }\n    eof = eofmap + bytesleft;\n    for (q=&eofmap[bytesleft-5]; q > eofmap; q--) {\n\tif (memcmp(q, \"%%EOF\", 5) == 0)\n\t    break;\n    }\n    if (q <= eofmap) {\n\tpdf.flags |= 1 << BAD_PDF_TRAILER;\n\tcli_dbgmsg(\"cli_pdf: %%%%EOF not found\\n\");\n    } else {\n\tsize = q - eofmap + map_off;\n\tfor (;q > eofmap;q--) {\n\t    if (memcmp(q, \"startxref\", 9) == 0)\n\t\tbreak;\n\t}\n\tif (q <= eofmap) {\n\t    pdf.flags |= 1 << BAD_PDF_TRAILER;\n\t    cli_dbgmsg(\"cli_pdf: startxref not found\\n\");\n\t}\n\tq += 9;\n\twhile (q < eof && (*q == ' ' || *q == '\\n' || *q == '\\r')) { q++; }\n\txref = atol(q);\n\tbytesleft = map->len - offset - xref;\n\tif (bytesleft > 4096)\n\t    bytesleft = 4096;\n\tq = fmap_need_off_once(map, offset + xref, bytesleft);\n\tif (!q || xrefCheck(q, q+bytesleft) == -1) {\n\t    cli_dbgmsg(\"cli_pdf: did not find valid xref\\n\");\n\t    pdf.flags |= 1 << BAD_PDF_TRAILER;\n\t}\n    }\n    size -= offset;\n\n    pdf.size = size;\n    pdf.map = fmap_need_off_once(map, offset, size);\n    if (!pdf.map) {\n\tcli_errmsg(\"cli_pdf: mmap() failed (3)\\n\");\n\treturn CL_EMAP;\n    }\n    /* parse PDF and find obj offsets */\n    while ((rc = pdf_findobj(&pdf)) > 0) {\n\tstruct pdf_obj *obj = &pdf.objs[pdf.nobjs-1];\n\tcli_dbgmsg(\"found %d %d obj @%ld\\n\", obj->id >> 8, obj->id&0xff, obj->start + offset);\n\tpdf_parseobj(&pdf, obj);\n    }\n    if (rc == -1)\n\tpdf.flags |= 1 << BAD_PDF_TOOMANYOBJS;\n\n    /* extract PDF objs */\n    for (i=0;i<pdf.nobjs;i++) {\n\tstruct pdf_obj *obj = &pdf.objs[i];\n\trc = pdf_extract_obj(&pdf, obj);\n\tif (rc != CL_SUCCESS)\n\t    break;\n    }\n\n    if (pdf.flags) {\n\tcli_dbgmsg(\"cli_pdf: flags 0x%02x\\n\", pdf.flags);\n\tif (pdf.flags & (1 << ESCAPED_COMMON_PDFNAME)) {\n\t    /* for example /Fl#61te#44#65#63#6f#64#65 instead of /FlateDecode */\n\t    *ctx->virname = \"Heuristics.PDF.ObfuscatedNameObject\";\n\t    rc = CL_VIRUS;\n\t}\n    }\n    cli_dbgmsg(\"cli_pdf: returning %d\\n\", rc);\n    free(pdf.objs);\n    return rc;\n}",
        "target": 1
    },
    {
        "func": "retrieve_url (struct url * orig_parsed, const char *origurl, char **file,\n              char **newloc, const char *refurl, int *dt, bool recursive,\n              struct iri *iri, bool register_status)\n{\n  uerr_t result;\n  char *url;\n  bool location_changed;\n  bool iri_fallbacked = 0;\n  int dummy;\n  char *mynewloc, *proxy;\n  struct url *u = orig_parsed, *proxy_url;\n  int up_error_code;            /* url parse error code */\n  char *local_file;\n  int redirection_count = 0;\n\n  bool post_data_suspended = false;\n  char *saved_post_data = NULL;\n  char *saved_post_file_name = NULL;\n\n  /* If dt is NULL, use local storage.  */\n  if (!dt)\n    {\n      dt = &dummy;\n      dummy = 0;\n    }\n  url = xstrdup (origurl);\n  if (newloc)\n    *newloc = NULL;\n  if (file)\n    *file = NULL;\n\n  if (!refurl)\n    refurl = opt.referer;\n\n redirected:\n  /* (also for IRI fallbacking) */\n\n  result = NOCONERROR;\n  mynewloc = NULL;\n  local_file = NULL;\n  proxy_url = NULL;\n\n  proxy = getproxy (u);\n  if (proxy)\n    {\n      struct iri *pi = iri_new ();\n      set_uri_encoding (pi, opt.locale, true);\n      pi->utf8_encode = false;\n\n      /* Parse the proxy URL.  */\n      proxy_url = url_parse (proxy, &up_error_code, NULL, true);\n      if (!proxy_url)\n        {\n          char *error = url_error (proxy, up_error_code);\n          logprintf (LOG_NOTQUIET, _(\"Error parsing proxy URL %s: %s.\\n\"),\n                     proxy, error);\n          xfree (url);\n          xfree (error);\n          RESTORE_POST_DATA;\n          result = PROXERR;\n          goto bail;\n        }\n      if (proxy_url->scheme != SCHEME_HTTP && proxy_url->scheme != u->scheme)\n        {\n          logprintf (LOG_NOTQUIET, _(\"Error in proxy URL %s: Must be HTTP.\\n\"), proxy);\n          url_free (proxy_url);\n          xfree (url);\n          RESTORE_POST_DATA;\n          result = PROXERR;\n          goto bail;\n        }\n    }\n\n  if (u->scheme == SCHEME_HTTP\n#ifdef HAVE_SSL\n      || u->scheme == SCHEME_HTTPS\n#endif\n      || (proxy_url && proxy_url->scheme == SCHEME_HTTP))\n    {\n      result = http_loop (u, &mynewloc, &local_file, refurl, dt, proxy_url, iri);\n    }\n  else if (u->scheme == SCHEME_FTP)\n    {\n      /* If this is a redirection, temporarily turn off opt.ftp_glob\n         and opt.recursive, both being undesirable when following\n         redirects.  */\n      bool oldrec = recursive, glob = opt.ftp_glob;\n      if (redirection_count)\n        oldrec = glob = false;\n\n      result = ftp_loop (u, &local_file, dt, proxy_url, recursive, glob);\n      recursive = oldrec;\n\n      /* There is a possibility of having HTTP being redirected to\n         FTP.  In these cases we must decide whether the text is HTML\n         according to the suffix.  The HTML suffixes are `.html',\n         `.htm' and a few others, case-insensitive.  */\n      if (redirection_count && local_file && u->scheme == SCHEME_FTP)\n        {\n          if (has_html_suffix_p (local_file))\n            *dt |= TEXTHTML;\n        }\n    }\n\n  if (proxy_url)\n    {\n      url_free (proxy_url);\n      proxy_url = NULL;\n    }\n\n  location_changed = (result == NEWLOCATION);\n  if (location_changed)\n    {\n      char *construced_newloc;\n      struct url *newloc_parsed;\n\n      assert (mynewloc != NULL);\n\n      if (local_file)\n        xfree (local_file);\n\n      /* The HTTP specs only allow absolute URLs to appear in\n         redirects, but a ton of boneheaded webservers and CGIs out\n         there break the rules and use relative URLs, and popular\n         browsers are lenient about this, so wget should be too. */\n      construced_newloc = uri_merge (url, mynewloc);\n      xfree (mynewloc);\n      mynewloc = construced_newloc;\n\n      /* Reset UTF-8 encoding state, keep the URI encoding and reset\n         the content encoding. */\n      iri->utf8_encode = opt.enable_iri;\n      set_content_encoding (iri, NULL);\n      xfree_null (iri->orig_url);\n\n      /* Now, see if this new location makes sense. */\n      newloc_parsed = url_parse (mynewloc, &up_error_code, iri, true);\n      if (!newloc_parsed)\n        {\n          char *error = url_error (mynewloc, up_error_code);\n          logprintf (LOG_NOTQUIET, \"%s: %s.\\n\", escnonprint_uri (mynewloc),\n                     error);\n          if (orig_parsed != u)\n            {\n              url_free (u);\n            }\n          xfree (url);\n          xfree (mynewloc);\n          xfree (error);\n          RESTORE_POST_DATA;\n          goto bail;\n        }\n\n      /* Now mynewloc will become newloc_parsed->url, because if the\n         Location contained relative paths like .././something, we\n         don't want that propagating as url.  */\n      xfree (mynewloc);\n      mynewloc = xstrdup (newloc_parsed->url);\n\n      /* Check for max. number of redirections.  */\n      if (++redirection_count > opt.max_redirect)\n        {\n          logprintf (LOG_NOTQUIET, _(\"%d redirections exceeded.\\n\"),\n                     opt.max_redirect);\n          url_free (newloc_parsed);\n          if (orig_parsed != u)\n            {\n              url_free (u);\n            }\n          xfree (url);\n          xfree (mynewloc);\n          RESTORE_POST_DATA;\n          result = WRONGCODE;\n          goto bail;\n        }\n\n      xfree (url);\n      url = mynewloc;\n      if (orig_parsed != u)\n        {\n          url_free (u);\n        }\n      u = newloc_parsed;\n\n      /* If we're being redirected from POST, we don't want to POST\n         again.  Many requests answer POST with a redirection to an\n         index page; that redirection is clearly a GET.  We \"suspend\"\n         POST data for the duration of the redirections, and restore\n         it when we're done. */\n      if (!post_data_suspended)\n        SUSPEND_POST_DATA;\n\n      goto redirected;\n    }\n\n  /* Try to not encode in UTF-8 if fetching failed */\n  if (!(*dt & RETROKF) && iri->utf8_encode)\n    {\n      iri->utf8_encode = false;\n      if (orig_parsed != u)\n        {\n          url_free (u);\n        }\n      u = url_parse (origurl, NULL, iri, true);\n      if (u)\n        {\n          DEBUGP ((\"[IRI fallbacking to non-utf8 for %s\\n\", quote (url)));\n          url = xstrdup (u->url);\n          iri_fallbacked = 1;\n          goto redirected;\n        }\n      else\n          DEBUGP ((\"[Couldn't fallback to non-utf8 for %s\\n\", quote (url)));\n    }\n\n  if (local_file && *dt & RETROKF)\n    {\n      register_download (u->url, local_file);\n      if (redirection_count && 0 != strcmp (origurl, u->url))\n        register_redirection (origurl, u->url);\n      if (*dt & TEXTHTML)\n        register_html (u->url, local_file);\n      if (*dt & RETROKF)\n        {\n          register_download (u->url, local_file);\n          if (redirection_count && 0 != strcmp (origurl, u->url))\n            register_redirection (origurl, u->url);\n          if (*dt & TEXTHTML)\n            register_html (u->url, local_file);\n          if (*dt & TEXTCSS)\n            register_css (u->url, local_file);\n        }\n    }\n\n  if (file)\n    *file = local_file ? local_file : NULL;\n  else\n    xfree_null (local_file);\n\n  if (orig_parsed != u)\n    {\n      url_free (u);\n    }\n\n  if (redirection_count || iri_fallbacked)\n    {\n      if (newloc)\n        *newloc = url;\n      else\n        xfree (url);\n    }\n  else\n    {\n      if (newloc)\n        *newloc = NULL;\n      xfree (url);\n    }\n\n  RESTORE_POST_DATA;\n\nbail:\n  if (register_status)\n    inform_exit_status (result);\n  return result;\n}",
        "target": 1
    },
    {
        "func": "print_help (void)\n{\n  /* We split the help text this way to ease translation of individual\n     entries.  */\n  static const char *help[] = {\n    \"\\n\",\n    N_(\"\\\nMandatory arguments to long options are mandatory for short options too.\\n\\n\"),\n    N_(\"\\\nStartup:\\n\"),\n    N_(\"\\\n  -V,  --version           display the version of Wget and exit.\\n\"),\n    N_(\"\\\n  -h,  --help              print this help.\\n\"),\n    N_(\"\\\n  -b,  --background        go to background after startup.\\n\"),\n    N_(\"\\\n  -e,  --execute=COMMAND   execute a `.wgetrc'-style command.\\n\"),\n    \"\\n\",\n\n    N_(\"\\\nLogging and input file:\\n\"),\n    N_(\"\\\n  -o,  --output-file=FILE    log messages to FILE.\\n\"),\n    N_(\"\\\n  -a,  --append-output=FILE  append messages to FILE.\\n\"),\n#ifdef ENABLE_DEBUG\n    N_(\"\\\n  -d,  --debug               print lots of debugging information.\\n\"),\n#endif\n#ifdef USE_WATT32\n    N_(\"\\\n       --wdebug              print Watt-32 debug output.\\n\"),\n#endif\n    N_(\"\\\n  -q,  --quiet               quiet (no output).\\n\"),\n    N_(\"\\\n  -v,  --verbose             be verbose (this is the default).\\n\"),\n    N_(\"\\\n  -nv, --no-verbose          turn off verboseness, without being quiet.\\n\"),\n    N_(\"\\\n  -i,  --input-file=FILE     download URLs found in local or external FILE.\\n\"),\n    N_(\"\\\n  -F,  --force-html          treat input file as HTML.\\n\"),\n    N_(\"\\\n  -B,  --base=URL            resolves HTML input-file links (-i -F)\\n\\\n                             relative to URL.\\n\"),\n    \"\\n\",\n\n    N_(\"\\\nDownload:\\n\"),\n    N_(\"\\\n  -t,  --tries=NUMBER            set number of retries to NUMBER (0 unlimits).\\n\"),\n    N_(\"\\\n       --retry-connrefused       retry even if connection is refused.\\n\"),\n    N_(\"\\\n  -O,  --output-document=FILE    write documents to FILE.\\n\"),\n    N_(\"\\\n  -nc, --no-clobber              skip downloads that would download to\\n\\\n                                 existing files.\\n\"),\n    N_(\"\\\n  -c,  --continue                resume getting a partially-downloaded file.\\n\"),\n    N_(\"\\\n       --progress=TYPE           select progress gauge type.\\n\"),\n    N_(\"\\\n  -N,  --timestamping            don't re-retrieve files unless newer than\\n\\\n                                 local.\\n\"),\n    N_(\"\\\n  --no-use-server-timestamps     don't set the local file's timestamp by\\n\\\n                                 the one on the server.\\n\"),\n    N_(\"\\\n  -S,  --server-response         print server response.\\n\"),\n    N_(\"\\\n       --spider                  don't download anything.\\n\"),\n    N_(\"\\\n  -T,  --timeout=SECONDS         set all timeout values to SECONDS.\\n\"),\n    N_(\"\\\n       --dns-timeout=SECS        set the DNS lookup timeout to SECS.\\n\"),\n    N_(\"\\\n       --connect-timeout=SECS    set the connect timeout to SECS.\\n\"),\n    N_(\"\\\n       --read-timeout=SECS       set the read timeout to SECS.\\n\"),\n    N_(\"\\\n  -w,  --wait=SECONDS            wait SECONDS between retrievals.\\n\"),\n    N_(\"\\\n       --waitretry=SECONDS       wait 1..SECONDS between retries of a retrieval.\\n\"),\n    N_(\"\\\n       --random-wait             wait from 0.5*WAIT...1.5*WAIT secs between retrievals.\\n\"),\n    N_(\"\\\n       --no-proxy                explicitly turn off proxy.\\n\"),\n    N_(\"\\\n  -Q,  --quota=NUMBER            set retrieval quota to NUMBER.\\n\"),\n    N_(\"\\\n       --bind-address=ADDRESS    bind to ADDRESS (hostname or IP) on local host.\\n\"),\n    N_(\"\\\n       --limit-rate=RATE         limit download rate to RATE.\\n\"),\n    N_(\"\\\n       --no-dns-cache            disable caching DNS lookups.\\n\"),\n    N_(\"\\\n       --restrict-file-names=OS  restrict chars in file names to ones OS allows.\\n\"),\n    N_(\"\\\n       --ignore-case             ignore case when matching files/directories.\\n\"),\n#ifdef ENABLE_IPV6\n    N_(\"\\\n  -4,  --inet4-only              connect only to IPv4 addresses.\\n\"),\n    N_(\"\\\n  -6,  --inet6-only              connect only to IPv6 addresses.\\n\"),\n    N_(\"\\\n       --prefer-family=FAMILY    connect first to addresses of specified family,\\n\\\n                                 one of IPv6, IPv4, or none.\\n\"),\n#endif\n    N_(\"\\\n       --user=USER               set both ftp and http user to USER.\\n\"),\n    N_(\"\\\n       --password=PASS           set both ftp and http password to PASS.\\n\"),\n    N_(\"\\\n       --ask-password            prompt for passwords.\\n\"),\n    N_(\"\\\n       --no-iri                  turn off IRI support.\\n\"),\n    N_(\"\\\n       --local-encoding=ENC      use ENC as the local encoding for IRIs.\\n\"),\n    N_(\"\\\n       --remote-encoding=ENC     use ENC as the default remote encoding.\\n\"),\n    \"\\n\",\n\n    N_(\"\\\nDirectories:\\n\"),\n    N_(\"\\\n  -nd, --no-directories           don't create directories.\\n\"),\n    N_(\"\\\n  -x,  --force-directories        force creation of directories.\\n\"),\n    N_(\"\\\n  -nH, --no-host-directories      don't create host directories.\\n\"),\n    N_(\"\\\n       --protocol-directories     use protocol name in directories.\\n\"),\n    N_(\"\\\n  -P,  --directory-prefix=PREFIX  save files to PREFIX/...\\n\"),\n    N_(\"\\\n       --cut-dirs=NUMBER          ignore NUMBER remote directory components.\\n\"),\n    \"\\n\",\n\n    N_(\"\\\nHTTP options:\\n\"),\n    N_(\"\\\n       --http-user=USER        set http user to USER.\\n\"),\n    N_(\"\\\n       --http-password=PASS    set http password to PASS.\\n\"),\n    N_(\"\\\n       --no-cache              disallow server-cached data.\\n\"),\n    N_ (\"\\\n       --default-page=NAME     Change the default page name (normally\\n\\\n                               this is `index.html'.).\\n\"),\n    N_(\"\\\n  -E,  --adjust-extension      save HTML/CSS documents with proper extensions.\\n\"),\n    N_(\"\\\n       --ignore-length         ignore `Content-Length' header field.\\n\"),\n    N_(\"\\\n       --header=STRING         insert STRING among the headers.\\n\"),\n    N_(\"\\\n       --max-redirect          maximum redirections allowed per page.\\n\"),\n    N_(\"\\\n       --proxy-user=USER       set USER as proxy username.\\n\"),\n    N_(\"\\\n       --proxy-password=PASS   set PASS as proxy password.\\n\"),\n    N_(\"\\\n       --referer=URL           include `Referer: URL' header in HTTP request.\\n\"),\n    N_(\"\\\n       --save-headers          save the HTTP headers to file.\\n\"),\n    N_(\"\\\n  -U,  --user-agent=AGENT      identify as AGENT instead of Wget/VERSION.\\n\"),\n    N_(\"\\\n       --no-http-keep-alive    disable HTTP keep-alive (persistent connections).\\n\"),\n    N_(\"\\\n       --no-cookies            don't use cookies.\\n\"),\n    N_(\"\\\n       --load-cookies=FILE     load cookies from FILE before session.\\n\"),\n    N_(\"\\\n       --save-cookies=FILE     save cookies to FILE after session.\\n\"),\n    N_(\"\\\n       --keep-session-cookies  load and save session (non-permanent) cookies.\\n\"),\n    N_(\"\\\n       --post-data=STRING      use the POST method; send STRING as the data.\\n\"),\n    N_(\"\\\n       --post-file=FILE        use the POST method; send contents of FILE.\\n\"),\n    N_(\"\\\n       --content-disposition   honor the Content-Disposition header when\\n\\\n                               choosing local file names (EXPERIMENTAL).\\n\"),\n    N_(\"\\\n       --auth-no-challenge     send Basic HTTP authentication information\\n\\\n                               without first waiting for the server's\\n\\\n                               challenge.\\n\"),\n    \"\\n\",\n\n#ifdef HAVE_SSL\n    N_(\"\\\nHTTPS (SSL/TLS) options:\\n\"),\n    N_(\"\\\n       --secure-protocol=PR     choose secure protocol, one of auto, SSLv2,\\n\\\n                                SSLv3, and TLSv1.\\n\"),\n    N_(\"\\\n       --no-check-certificate   don't validate the server's certificate.\\n\"),\n    N_(\"\\\n       --certificate=FILE       client certificate file.\\n\"),\n    N_(\"\\\n       --certificate-type=TYPE  client certificate type, PEM or DER.\\n\"),\n    N_(\"\\\n       --private-key=FILE       private key file.\\n\"),\n    N_(\"\\\n       --private-key-type=TYPE  private key type, PEM or DER.\\n\"),\n    N_(\"\\\n       --ca-certificate=FILE    file with the bundle of CA's.\\n\"),\n    N_(\"\\\n       --ca-directory=DIR       directory where hash list of CA's is stored.\\n\"),\n    N_(\"\\\n       --random-file=FILE       file with random data for seeding the SSL PRNG.\\n\"),\n    N_(\"\\\n       --egd-file=FILE          file naming the EGD socket with random data.\\n\"),\n    \"\\n\",\n#endif /* HAVE_SSL */\n\n    N_(\"\\\nFTP options:\\n\"),\n#ifdef __VMS\n    N_(\"\\\n       --ftp-stmlf             Use Stream_LF format for all binary FTP files.\\n\"),\n#endif /* def __VMS */\n    N_(\"\\\n       --ftp-user=USER         set ftp user to USER.\\n\"),\n    N_(\"\\\n       --ftp-password=PASS     set ftp password to PASS.\\n\"),\n    N_(\"\\\n       --no-remove-listing     don't remove `.listing' files.\\n\"),\n    N_(\"\\\n       --no-glob               turn off FTP file name globbing.\\n\"),\n    N_(\"\\\n       --no-passive-ftp        disable the \\\"passive\\\" transfer mode.\\n\"),\n    N_(\"\\\n       --retr-symlinks         when recursing, get linked-to files (not dir).\\n\"),\n    \"\\n\",\n\n    N_(\"\\\nRecursive download:\\n\"),\n    N_(\"\\\n  -r,  --recursive          specify recursive download.\\n\"),\n    N_(\"\\\n  -l,  --level=NUMBER       maximum recursion depth (inf or 0 for infinite).\\n\"),\n    N_(\"\\\n       --delete-after       delete files locally after downloading them.\\n\"),\n    N_(\"\\\n  -k,  --convert-links      make links in downloaded HTML or CSS point to\\n\\\n                            local files.\\n\"),\n#ifdef __VMS\n    N_(\"\\\n  -K,  --backup-converted   before converting file X, back up as X_orig.\\n\"),\n#else /* def __VMS */\n    N_(\"\\\n  -K,  --backup-converted   before converting file X, back up as X.orig.\\n\"),\n#endif /* def __VMS [else] */\n    N_(\"\\\n  -m,  --mirror             shortcut for -N -r -l inf --no-remove-listing.\\n\"),\n    N_(\"\\\n  -p,  --page-requisites    get all images, etc. needed to display HTML page.\\n\"),\n    N_(\"\\\n       --strict-comments    turn on strict (SGML) handling of HTML comments.\\n\"),\n    \"\\n\",\n\n    N_(\"\\\nRecursive accept/reject:\\n\"),\n    N_(\"\\\n  -A,  --accept=LIST               comma-separated list of accepted extensions.\\n\"),\n    N_(\"\\\n  -R,  --reject=LIST               comma-separated list of rejected extensions.\\n\"),\n    N_(\"\\\n  -D,  --domains=LIST              comma-separated list of accepted domains.\\n\"),\n    N_(\"\\\n       --exclude-domains=LIST      comma-separated list of rejected domains.\\n\"),\n    N_(\"\\\n       --follow-ftp                follow FTP links from HTML documents.\\n\"),\n    N_(\"\\\n       --follow-tags=LIST          comma-separated list of followed HTML tags.\\n\"),\n    N_(\"\\\n       --ignore-tags=LIST          comma-separated list of ignored HTML tags.\\n\"),\n    N_(\"\\\n  -H,  --span-hosts                go to foreign hosts when recursive.\\n\"),\n    N_(\"\\\n  -L,  --relative                  follow relative links only.\\n\"),\n    N_(\"\\\n  -I,  --include-directories=LIST  list of allowed directories.\\n\"),\n    N_(\"\\\n  -X,  --exclude-directories=LIST  list of excluded directories.\\n\"),\n    N_(\"\\\n  -np, --no-parent                 don't ascend to the parent directory.\\n\"),\n    \"\\n\",\n\n    N_(\"Mail bug reports and suggestions to <bug-wget@gnu.org>.\\n\")\n  };\n\n  size_t i;\n\n  printf (_(\"GNU Wget %s, a non-interactive network retriever.\\n\"),\n          version_string);\n  print_usage (0);\n\n  for (i = 0; i < countof (help); i++)\n    fputs (_(help[i]), stdout);\n\n  exit (0);\n}",
        "target": 1
    },
    {
        "func": "http_loop (struct url *u, char **newloc, char **local_file, const char *referer,\n           int *dt, struct url *proxy, struct iri *iri)\n{\n  int count;\n  bool got_head = false;         /* used for time-stamping and filename detection */\n  bool time_came_from_head = false;\n  bool got_name = false;\n  char *tms;\n  const char *tmrate;\n  uerr_t err, ret = TRYLIMEXC;\n  time_t tmr = -1;               /* remote time-stamp */\n  struct http_stat hstat;        /* HTTP status */\n  struct_stat st;\n  bool send_head_first = true;\n  char *file_name;\n  bool force_full_retrieve = false;\n\n  /* Assert that no value for *LOCAL_FILE was passed. */\n  assert (local_file == NULL || *local_file == NULL);\n\n  /* Set LOCAL_FILE parameter. */\n  if (local_file && opt.output_document)\n    *local_file = HYPHENP (opt.output_document) ? NULL : xstrdup (opt.output_document);\n\n  /* Reset NEWLOC parameter. */\n  *newloc = NULL;\n\n  /* This used to be done in main(), but it's a better idea to do it\n     here so that we don't go through the hoops if we're just using\n     FTP or whatever. */\n  if (opt.cookies)\n    load_cookies ();\n\n  /* Warn on (likely bogus) wildcard usage in HTTP. */\n  if (opt.ftp_glob && has_wildcards_p (u->path))\n    logputs (LOG_VERBOSE, _(\"Warning: wildcards not supported in HTTP.\\n\"));\n\n  /* Setup hstat struct. */\n  xzero (hstat);\n  hstat.referer = referer;\n\n  if (opt.output_document)\n    {\n      hstat.local_file = xstrdup (opt.output_document);\n      got_name = true;\n    }\n  else if (!opt.content_disposition)\n    {\n      hstat.local_file = url_file_name (u);\n      got_name = true;\n    }\n\n  /* TODO: Ick! This code is now in both gethttp and http_loop, and is\n   * screaming for some refactoring. */\n  if (got_name && file_exists_p (hstat.local_file) && opt.noclobber && !opt.output_document)\n    {\n      /* If opt.noclobber is turned on and file already exists, do not\n         retrieve the file. But if the output_document was given, then this\n         test was already done and the file didn't exist. Hence the !opt.output_document */\n      logprintf (LOG_VERBOSE, _(\"\\\nFile %s already there; not retrieving.\\n\\n\"),\n                 quote (hstat.local_file));\n      /* If the file is there, we suppose it's retrieved OK.  */\n      *dt |= RETROKF;\n\n      /* #### Bogusness alert.  */\n      /* If its suffix is \"html\" or \"htm\" or similar, assume text/html.  */\n      if (has_html_suffix_p (hstat.local_file))\n        *dt |= TEXTHTML;\n\n      ret = RETROK;\n      goto exit;\n    }\n\n  /* Reset the counter. */\n  count = 0;\n\n  /* Reset the document type. */\n  *dt = 0;\n\n  /* Skip preliminary HEAD request if we're not in spider mode.  */\n  if (!opt.spider)\n    send_head_first = false;\n\n  /* Send preliminary HEAD request if -N is given and we have an existing\n   * destination file. */\n  file_name = url_file_name (u);\n  if (opt.timestamping && (file_exists_p (file_name)\n                           || opt.content_disposition))\n    send_head_first = true;\n  xfree (file_name);\n\n  /* THE loop */\n  do\n    {\n      /* Increment the pass counter.  */\n      ++count;\n      sleep_between_retrievals (count);\n\n      /* Get the current time string.  */\n      tms = datetime_str (time (NULL));\n\n      if (opt.spider && !got_head)\n        logprintf (LOG_VERBOSE, _(\"\\\nSpider mode enabled. Check if remote file exists.\\n\"));\n\n      /* Print fetch message, if opt.verbose.  */\n      if (opt.verbose)\n        {\n          char *hurl = url_string (u, URL_AUTH_HIDE_PASSWD);\n\n          if (count > 1)\n            {\n              char tmp[256];\n              sprintf (tmp, _(\"(try:%2d)\"), count);\n              logprintf (LOG_NOTQUIET, \"--%s--  %s  %s\\n\",\n                         tms, tmp, hurl);\n            }\n          else\n            {\n              logprintf (LOG_NOTQUIET, \"--%s--  %s\\n\",\n                         tms, hurl);\n            }\n\n#ifdef WINDOWS\n          ws_changetitle (hurl);\n#endif\n          xfree (hurl);\n        }\n\n      /* Default document type is empty.  However, if spider mode is\n         on or time-stamping is employed, HEAD_ONLY commands is\n         encoded within *dt.  */\n      if (send_head_first && !got_head)\n        *dt |= HEAD_ONLY;\n      else\n        *dt &= ~HEAD_ONLY;\n\n      /* Decide whether or not to restart.  */\n      if (force_full_retrieve)\n        hstat.restval = hstat.len;\n      else if (opt.always_rest\n          && got_name\n          && stat (hstat.local_file, &st) == 0\n          && S_ISREG (st.st_mode))\n        /* When -c is used, continue from on-disk size.  (Can't use\n           hstat.len even if count>1 because we don't want a failed\n           first attempt to clobber existing data.)  */\n        hstat.restval = st.st_size;\n      else if (count > 1)\n        /* otherwise, continue where the previous try left off */\n        hstat.restval = hstat.len;\n      else\n        hstat.restval = 0;\n\n      /* Decide whether to send the no-cache directive.  We send it in\n         two cases:\n           a) we're using a proxy, and we're past our first retrieval.\n              Some proxies are notorious for caching incomplete data, so\n              we require a fresh get.\n           b) caching is explicitly inhibited. */\n      if ((proxy && count > 1)        /* a */\n          || !opt.allow_cache)        /* b */\n        *dt |= SEND_NOCACHE;\n      else\n        *dt &= ~SEND_NOCACHE;\n\n      /* Try fetching the document, or at least its head.  */\n      err = gethttp (u, &hstat, dt, proxy, iri);\n\n      /* Time?  */\n      tms = datetime_str (time (NULL));\n\n      /* Get the new location (with or without the redirection).  */\n      if (hstat.newloc)\n        *newloc = xstrdup (hstat.newloc);\n\n      switch (err)\n        {\n        case HERR: case HEOF: case CONSOCKERR: case CONCLOSED:\n        case CONERROR: case READERR: case WRITEFAILED:\n        case RANGEERR: case FOPEN_EXCL_ERR:\n          /* Non-fatal errors continue executing the loop, which will\n             bring them to \"while\" statement at the end, to judge\n             whether the number of tries was exceeded.  */\n          printwhat (count, opt.ntry);\n          continue;\n        case FWRITEERR: case FOPENERR:\n          /* Another fatal error.  */\n          logputs (LOG_VERBOSE, \"\\n\");\n          logprintf (LOG_NOTQUIET, _(\"Cannot write to %s (%s).\\n\"),\n                     quote (hstat.local_file), strerror (errno));\n        case HOSTERR: case CONIMPOSSIBLE: case PROXERR: case AUTHFAILED:\n        case SSLINITFAILED: case CONTNOTSUPPORTED: case VERIFCERTERR:\n          /* Fatal errors just return from the function.  */\n          ret = err;\n          goto exit;\n        case CONSSLERR:\n          /* Another fatal error.  */\n          logprintf (LOG_NOTQUIET, _(\"Unable to establish SSL connection.\\n\"));\n          ret = err;\n          goto exit;\n        case NEWLOCATION:\n          /* Return the new location to the caller.  */\n          if (!*newloc)\n            {\n              logprintf (LOG_NOTQUIET,\n                         _(\"ERROR: Redirection (%d) without location.\\n\"),\n                         hstat.statcode);\n              ret = WRONGCODE;\n            }\n          else\n            {\n              ret = NEWLOCATION;\n            }\n          goto exit;\n        case RETRUNNEEDED:\n          /* The file was already fully retrieved. */\n          ret = RETROK;\n          goto exit;\n        case RETRFINISHED:\n          /* Deal with you later.  */\n          break;\n        default:\n          /* All possibilities should have been exhausted.  */\n          abort ();\n        }\n\n      if (!(*dt & RETROKF))\n        {\n          char *hurl = NULL;\n          if (!opt.verbose)\n            {\n              /* #### Ugly ugly ugly! */\n              hurl = url_string (u, URL_AUTH_HIDE_PASSWD);\n              logprintf (LOG_NONVERBOSE, \"%s:\\n\", hurl);\n            }\n\n          /* Fall back to GET if HEAD fails with a 500 or 501 error code. */\n          if (*dt & HEAD_ONLY\n              && (hstat.statcode == 500 || hstat.statcode == 501))\n            {\n              got_head = true;\n              continue;\n            }\n          /* Maybe we should always keep track of broken links, not just in\n           * spider mode.\n           * Don't log error if it was UTF-8 encoded because we will try\n           * once unencoded. */\n          else if (opt.spider && !iri->utf8_encode)\n            {\n              /* #### Again: ugly ugly ugly! */\n              if (!hurl)\n                hurl = url_string (u, URL_AUTH_HIDE_PASSWD);\n              nonexisting_url (hurl);\n              logprintf (LOG_NOTQUIET, _(\"\\\nRemote file does not exist -- broken link!!!\\n\"));\n            }\n          else\n            {\n              logprintf (LOG_NOTQUIET, _(\"%s ERROR %d: %s.\\n\"),\n                         tms, hstat.statcode,\n                         quotearg_style (escape_quoting_style, hstat.error));\n            }\n          logputs (LOG_VERBOSE, \"\\n\");\n          ret = WRONGCODE;\n          xfree_null (hurl);\n          goto exit;\n        }\n\n      /* Did we get the time-stamp? */\n      if (!got_head)\n        {\n          got_head = true;    /* no more time-stamping */\n\n          if (opt.timestamping && !hstat.remote_time)\n            {\n              logputs (LOG_NOTQUIET, _(\"\\\nLast-modified header missing -- time-stamps turned off.\\n\"));\n            }\n          else if (hstat.remote_time)\n            {\n              /* Convert the date-string into struct tm.  */\n              tmr = http_atotm (hstat.remote_time);\n              if (tmr == (time_t) (-1))\n                logputs (LOG_VERBOSE, _(\"\\\nLast-modified header invalid -- time-stamp ignored.\\n\"));\n              if (*dt & HEAD_ONLY)\n                time_came_from_head = true;\n            }\n\n          if (send_head_first)\n            {\n              /* The time-stamping section.  */\n              if (opt.timestamping)\n                {\n                  if (hstat.orig_file_name) /* Perform the following\n                                               checks only if the file\n                                               we're supposed to\n                                               download already exists.  */\n                    {\n                      if (hstat.remote_time &&\n                          tmr != (time_t) (-1))\n                        {\n                          /* Now time-stamping can be used validly.\n                             Time-stamping means that if the sizes of\n                             the local and remote file match, and local\n                             file is newer than the remote file, it will\n                             not be retrieved.  Otherwise, the normal\n                             download procedure is resumed.  */\n                          if (hstat.orig_file_tstamp >= tmr)\n                            {\n                              if (hstat.contlen == -1\n                                  || hstat.orig_file_size == hstat.contlen)\n                                {\n                                  logprintf (LOG_VERBOSE, _(\"\\\nServer file no newer than local file %s -- not retrieving.\\n\\n\"),\n                                             quote (hstat.orig_file_name));\n                                  ret = RETROK;\n                                  goto exit;\n                                }\n                              else\n                                {\n                                  logprintf (LOG_VERBOSE, _(\"\\\nThe sizes do not match (local %s) -- retrieving.\\n\"),\n                                             number_to_static_string (hstat.orig_file_size));\n                                }\n                            }\n                          else\n                            {\n                              force_full_retrieve = true;\n                              logputs (LOG_VERBOSE,\n                                       _(\"Remote file is newer, retrieving.\\n\"));\n                            }\n\n                          logputs (LOG_VERBOSE, \"\\n\");\n                        }\n                    }\n\n                  /* free_hstat (&hstat); */\n                  hstat.timestamp_checked = true;\n                }\n\n              if (opt.spider)\n                {\n                  bool finished = true;\n                  if (opt.recursive)\n                    {\n                      if (*dt & TEXTHTML)\n                        {\n                          logputs (LOG_VERBOSE, _(\"\\\nRemote file exists and could contain links to other resources -- retrieving.\\n\\n\"));\n                          finished = false;\n                        }\n                      else\n                        {\n                          logprintf (LOG_VERBOSE, _(\"\\\nRemote file exists but does not contain any link -- not retrieving.\\n\\n\"));\n                          ret = RETROK; /* RETRUNNEEDED is not for caller. */\n                        }\n                    }\n                  else\n                    {\n                      if (*dt & TEXTHTML)\n                        {\n                          logprintf (LOG_VERBOSE, _(\"\\\nRemote file exists and could contain further links,\\n\\\nbut recursion is disabled -- not retrieving.\\n\\n\"));\n                        }\n                      else\n                        {\n                          logprintf (LOG_VERBOSE, _(\"\\\nRemote file exists.\\n\\n\"));\n                        }\n                      ret = RETROK; /* RETRUNNEEDED is not for caller. */\n                    }\n\n                  if (finished)\n                    {\n                      logprintf (LOG_NONVERBOSE,\n                                 _(\"%s URL: %s %2d %s\\n\"),\n                                 tms, u->url, hstat.statcode,\n                                 hstat.message ? quotearg_style (escape_quoting_style, hstat.message) : \"\");\n                      goto exit;\n                    }\n                }\n\n              got_name = true;\n              *dt &= ~HEAD_ONLY;\n              count = 0;          /* the retrieve count for HEAD is reset */\n              continue;\n            } /* send_head_first */\n        } /* !got_head */\n\n      if (opt.useservertimestamps\n          && (tmr != (time_t) (-1))\n          && ((hstat.len == hstat.contlen) ||\n              ((hstat.res == 0) && (hstat.contlen == -1))))\n        {\n          const char *fl = NULL;\n          set_local_file (&fl, hstat.local_file);\n          if (fl)\n            {\n              time_t newtmr = -1;\n              /* Reparse time header, in case it's changed. */\n              if (time_came_from_head\n                  && hstat.remote_time && hstat.remote_time[0])\n                {\n                  newtmr = http_atotm (hstat.remote_time);\n                  if (newtmr != (time_t)-1)\n                    tmr = newtmr;\n                }\n              touch (fl, tmr);\n            }\n        }\n      /* End of time-stamping section. */\n\n      tmrate = retr_rate (hstat.rd_size, hstat.dltime);\n      total_download_time += hstat.dltime;\n\n      if (hstat.len == hstat.contlen)\n        {\n          if (*dt & RETROKF)\n            {\n              bool write_to_stdout = (opt.output_document && HYPHENP (opt.output_document));\n\n              logprintf (LOG_VERBOSE,\n                         write_to_stdout\n                         ? _(\"%s (%s) - written to stdout %s[%s/%s]\\n\\n\")\n                         : _(\"%s (%s) - %s saved [%s/%s]\\n\\n\"),\n                         tms, tmrate,\n                         write_to_stdout ? \"\" : quote (hstat.local_file),\n                         number_to_static_string (hstat.len),\n                         number_to_static_string (hstat.contlen));\n              logprintf (LOG_NONVERBOSE,\n                         \"%s URL:%s [%s/%s] -> \\\"%s\\\" [%d]\\n\",\n                         tms, u->url,\n                         number_to_static_string (hstat.len),\n                         number_to_static_string (hstat.contlen),\n                         hstat.local_file, count);\n            }\n          ++numurls;\n          total_downloaded_bytes += hstat.rd_size;\n\n          /* Remember that we downloaded the file for later \".orig\" code. */\n          if (*dt & ADDED_HTML_EXTENSION)\n            downloaded_file(FILE_DOWNLOADED_AND_HTML_EXTENSION_ADDED, hstat.local_file);\n          else\n            downloaded_file(FILE_DOWNLOADED_NORMALLY, hstat.local_file);\n\n          ret = RETROK;\n          goto exit;\n        }\n      else if (hstat.res == 0) /* No read error */\n        {\n          if (hstat.contlen == -1)  /* We don't know how much we were supposed\n                                       to get, so assume we succeeded. */\n            {\n              if (*dt & RETROKF)\n                {\n                  bool write_to_stdout = (opt.output_document && HYPHENP (opt.output_document));\n\n                  logprintf (LOG_VERBOSE,\n                             write_to_stdout\n                             ? _(\"%s (%s) - written to stdout %s[%s]\\n\\n\")\n                             : _(\"%s (%s) - %s saved [%s]\\n\\n\"),\n                             tms, tmrate,\n                             write_to_stdout ? \"\" : quote (hstat.local_file),\n                             number_to_static_string (hstat.len));\n                  logprintf (LOG_NONVERBOSE,\n                             \"%s URL:%s [%s] -> \\\"%s\\\" [%d]\\n\",\n                             tms, u->url, number_to_static_string (hstat.len),\n                             hstat.local_file, count);\n                }\n              ++numurls;\n              total_downloaded_bytes += hstat.rd_size;\n\n              /* Remember that we downloaded the file for later \".orig\" code. */\n              if (*dt & ADDED_HTML_EXTENSION)\n                downloaded_file(FILE_DOWNLOADED_AND_HTML_EXTENSION_ADDED, hstat.local_file);\n              else\n                downloaded_file(FILE_DOWNLOADED_NORMALLY, hstat.local_file);\n\n              ret = RETROK;\n              goto exit;\n            }\n          else if (hstat.len < hstat.contlen) /* meaning we lost the\n                                                 connection too soon */\n            {\n              logprintf (LOG_VERBOSE,\n                         _(\"%s (%s) - Connection closed at byte %s. \"),\n                         tms, tmrate, number_to_static_string (hstat.len));\n              printwhat (count, opt.ntry);\n              continue;\n            }\n          else if (hstat.len != hstat.restval)\n            /* Getting here would mean reading more data than\n               requested with content-length, which we never do.  */\n            abort ();\n          else\n            {\n              /* Getting here probably means that the content-length was\n               * _less_ than the original, local size. We should probably\n               * truncate or re-read, or something. FIXME */\n              ret = RETROK;\n              goto exit;\n            }\n        }\n      else /* from now on hstat.res can only be -1 */\n        {\n          if (hstat.contlen == -1)\n            {\n              logprintf (LOG_VERBOSE,\n                         _(\"%s (%s) - Read error at byte %s (%s).\"),\n                         tms, tmrate, number_to_static_string (hstat.len),\n                         hstat.rderrmsg);\n              printwhat (count, opt.ntry);\n              continue;\n            }\n          else /* hstat.res == -1 and contlen is given */\n            {\n              logprintf (LOG_VERBOSE,\n                         _(\"%s (%s) - Read error at byte %s/%s (%s). \"),\n                         tms, tmrate,\n                         number_to_static_string (hstat.len),\n                         number_to_static_string (hstat.contlen),\n                         hstat.rderrmsg);\n              printwhat (count, opt.ntry);\n              continue;\n            }\n        }\n      /* not reached */\n    }\n  while (!opt.ntry || (count < opt.ntry));\n\nexit:\n  if (ret == RETROK)\n    *local_file = xstrdup (hstat.local_file);\n  free_hstat (&hstat);\n\n  return ret;\n}",
        "target": 1
    },
    {
        "func": "ftp_loop (struct url *u, char **local_file, int *dt, struct url *proxy, \n          bool recursive, bool glob)\n{\n  ccon con;                     /* FTP connection */\n  uerr_t res;\n\n  *dt = 0;\n\n  xzero (con);\n\n  con.csock = -1;\n  con.st = ON_YOUR_OWN;\n  con.rs = ST_UNIX;\n  con.id = NULL;\n  con.proxy = proxy;\n\n  /* If the file name is empty, the user probably wants a directory\n     index.  We'll provide one, properly HTML-ized.  Unless\n     opt.htmlify is 0, of course.  :-) */\n  if (!*u->file && !recursive)\n    {\n      struct fileinfo *f;\n      res = ftp_get_listing (u, &con, &f);\n\n      if (res == RETROK)\n        {\n          if (opt.htmlify && !opt.spider)\n            {\n              char *filename = (opt.output_document\n                                ? xstrdup (opt.output_document)\n                                : (con.target ? xstrdup (con.target)\n                                   : url_file_name (u)));\n              res = ftp_index (filename, u, f);\n              if (res == FTPOK && opt.verbose)\n                {\n                  if (!opt.output_document)\n                    {\n                      struct_stat st;\n                      wgint sz;\n                      if (stat (filename, &st) == 0)\n                        sz = st.st_size;\n                      else\n                        sz = -1;\n                      logprintf (LOG_NOTQUIET,\n                                 _(\"Wrote HTML-ized index to %s [%s].\\n\"),\n                                 quote (filename), number_to_static_string (sz));\n                    }\n                  else\n                    logprintf (LOG_NOTQUIET,\n                               _(\"Wrote HTML-ized index to %s.\\n\"),\n                               quote (filename));\n                }\n              xfree (filename);\n            }\n          freefileinfo (f);\n        }\n    }\n  else\n    {\n      bool ispattern = false;\n      if (glob)\n        {\n          /* Treat the URL as a pattern if the file name part of the\n             URL path contains wildcards.  (Don't check for u->file\n             because it is unescaped and therefore doesn't leave users\n             the option to escape literal '*' as %2A.)  */\n          char *file_part = strrchr (u->path, '/');\n          if (!file_part)\n            file_part = u->path;\n          ispattern = has_wildcards_p (file_part);\n        }\n      if (ispattern || recursive || opt.timestamping)\n        {\n          /* ftp_retrieve_glob is a catch-all function that gets called\n             if we need globbing, time-stamping or recursion.  Its\n             third argument is just what we really need.  */\n          res = ftp_retrieve_glob (u, &con,\n                                   ispattern ? GLOB_GLOBALL : GLOB_GETONE);\n        }\n      else\n        res = ftp_loop_internal (u, NULL, &con, local_file);\n    }\n  if (res == FTPOK)\n    res = RETROK;\n  if (res == RETROK)\n    *dt |= RETROKF;\n  /* If a connection was left, quench it.  */\n  if (con.csock != -1)\n    fd_close (con.csock);\n  xfree_null (con.id);\n  con.id = NULL;\n  xfree_null (con.target);\n  con.target = NULL;\n  return res;\n}",
        "target": 1
    },
    {
        "func": "static noinline_for_stack int ethtool_get_rxnfc(struct net_device *dev,\n\t\t\t\t\t\tvoid __user *useraddr)\n{\n\tstruct ethtool_rxnfc info;\n\tconst struct ethtool_ops *ops = dev->ethtool_ops;\n\tint ret;\n\tvoid *rule_buf = NULL;\n\n\tif (!ops->get_rxnfc)\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&info, useraddr, sizeof(info)))\n\t\treturn -EFAULT;\n\n\tif (info.cmd == ETHTOOL_GRXCLSRLALL) {\n\t\tif (info.rule_cnt > 0) {\n\t\t\trule_buf = kmalloc(info.rule_cnt * sizeof(u32),\n\t\t\t\t\t   GFP_USER);\n\t\t\tif (!rule_buf)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tret = ops->get_rxnfc(dev, &info, rule_buf);\n\tif (ret < 0)\n\t\tgoto err_out;\n\n\tret = -EFAULT;\n\tif (copy_to_user(useraddr, &info, sizeof(info)))\n\t\tgoto err_out;\n\n\tif (rule_buf) {\n\t\tuseraddr += offsetof(struct ethtool_rxnfc, rule_locs);\n\t\tif (copy_to_user(useraddr, rule_buf,\n\t\t\t\t info.rule_cnt * sizeof(u32)))\n\t\t\tgoto err_out;\n\t}\n\tret = 0;\n\nerr_out:\n\tkfree(rule_buf);\n\n\treturn ret;\n}",
        "target": 1
    },
    {
        "func": "void Server::msgQueryUsers(ServerUser *uSource, MumbleProto::QueryUsers &msg) {\n\tMSG_SETUP(ServerUser::Authenticated);\n\n\tMumbleProto::QueryUsers reply;\n\n\tfor (int i=0;i<msg.ids_size();++i) {\n\t\tint id = msg.ids(i);\n\t\tif (id >= 0) {\n\t\t\tconst QString &name = getUserName(id);\n\t\t\tif (! name.isEmpty()) {\n\t\t\t\treply.add_ids(id);\n\t\t\t\treply.add_names(u8(name));\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i=0;i<msg.names_size();++i) {\n\t\tQString name = u8(msg.names(i));\n\t\tint id = getUserID(name);\n\t\tif (id >= 0) {\n\t\t\tname = getUserName(id);\n\t\t\treply.add_ids(id);\n\t\t\treply.add_names(u8(name));\n\t\t}\n\t}\n\n\tsendMessage(uSource, reply);\n}",
        "target": 1
    },
    {
        "func": "int Server::authenticate(QString &name, const QString &pw, const QStringList &emails, const QString &certhash, bool bStrongCert, const QList<QSslCertificate> &certs) {\n\tint res = -2;\n\n\temit authenticateSig(res, name, certs, certhash, bStrongCert, pw);\n\n\tif (res != -2) {\n\t\t// External authentication handled it. Ignore certificate completely.\n\t\tif (res != -1) {\n\t\t\tTransactionHolder th;\n\t\t\tQSqlQuery &query = *th.qsqQuery;\n\n\t\t\tint lchan=readLastChannel(res);\n\t\t\tif (lchan < 0)\n\t\t\t\tlchan = 0;\n\n\t\t\tSQLPREP(\"REPLACE INTO `%1users` (`server_id`, `user_id`, `name`, `lastchannel`) VALUES (?,?,?,?)\");\n\t\t\tquery.addBindValue(iServerNum);\n\t\t\tquery.addBindValue(res);\n\t\t\tquery.addBindValue(name);\n\t\t\tquery.addBindValue(lchan);\n\t\t\tSQLEXEC();\n\t\t}\n\t\tif (res >= 0) {\n\t\t\tqhUserNameCache.remove(res);\n\t\t\tqhUserIDCache.remove(name);\n\t\t}\n\t\treturn res;\n\t}\n\n\tTransactionHolder th;\n\tQSqlQuery &query = *th.qsqQuery;\n\n\tSQLPREP(\"SELECT `user_id`,`name`,`pw` FROM `%1users` WHERE `server_id` = ? AND `name` like ?\");\n\tquery.addBindValue(iServerNum);\n\tquery.addBindValue(name);\n\tSQLEXEC();\n\tif (query.next()) {\n\t\tres = -1;\n\t\tQString storedpw = query.value(2).toString();\n\t\tQString hashedpw = QString::fromLatin1(sha1(pw).toHex());\n\n\t\tif (! storedpw.isEmpty() && (storedpw == hashedpw)) {\n\t\t\tname = query.value(1).toString();\n\t\t\tres = query.value(0).toInt();\n\t\t} else if (query.value(0).toInt() == 0) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t// No password match. Try cert or email match, but only for non-SuperUser.\n\tif (!certhash.isEmpty() && (res < 0)) {\n\t\tSQLPREP(\"SELECT `user_id` FROM `%1user_info` WHERE `server_id` = ? AND `key` = ? AND `value` = ?\");\n\t\tquery.addBindValue(iServerNum);\n\t\tquery.addBindValue(ServerDB::User_Hash);\n\t\tquery.addBindValue(certhash);\n\t\tSQLEXEC();\n\t\tif (query.next()) {\n\t\t\tres = query.value(0).toInt();\n\t\t} else if (bStrongCert) {\n\t\t\tforeach(const QString &email, emails) {\n\t\t\t\tif (! email.isEmpty()) {\n\t\t\t\t\tquery.addBindValue(iServerNum);\n\t\t\t\t\tquery.addBindValue(ServerDB::User_Email);\n\t\t\t\t\tquery.addBindValue(email);\n\t\t\t\t\tSQLEXEC();\n\t\t\t\t\tif (query.next()) {\n\t\t\t\t\t\tres = query.value(0).toInt();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (res > 0) {\n\t\t\tSQLPREP(\"SELECT `name` FROM `%1users` WHERE `server_id` = ? AND `user_id` = ?\");\n\t\t\tquery.addBindValue(iServerNum);\n\t\t\tquery.addBindValue(res);\n\t\t\tSQLEXEC();\n\t\t\tif (! query.next()) {\n\t\t\t\tres = -1;\n\t\t\t} else {\n\t\t\t\tname = query.value(0).toString();\n\t\t\t}\n\t\t}\n\t}\n\tif (! certhash.isEmpty() && (res > 0)) {\n\t\tSQLPREP(\"REPLACE INTO `%1user_info` (`server_id`, `user_id`, `key`, `value`) VALUES (?, ?, ?, ?)\");\n\t\tquery.addBindValue(iServerNum);\n\t\tquery.addBindValue(res);\n\t\tquery.addBindValue(ServerDB::User_Hash);\n\t\tquery.addBindValue(certhash);\n\t\tSQLEXEC();\n\t\tif (! emails.isEmpty()) {\n\t\t\tquery.addBindValue(iServerNum);\n\t\t\tquery.addBindValue(res);\n\t\t\tquery.addBindValue(ServerDB::User_Email);\n\t\t\tquery.addBindValue(emails.at(0));\n\t\t\tSQLEXEC();\n\t\t}\n\t}\n\tif (res >= 0) {\n\t\tqhUserNameCache.remove(res);\n\t\tqhUserIDCache.remove(name);\n\t}\n\treturn res;\n}",
        "target": 1
    },
    {
        "func": "int Server::getUserID(const QString &name) {\n\tif (qhUserIDCache.contains(name))\n\t\treturn qhUserIDCache.value(name);\n\tint id = -2;\n\temit nameToIdSig(id, name);\n\tif (id != -2) {\n\t\tqhUserIDCache.insert(name, id);\n\t\tqhUserNameCache.insert(id, name);\n\t\treturn id;\n\t}\n\tTransactionHolder th;\n\n\tQSqlQuery &query = *th.qsqQuery;\n\tSQLPREP(\"SELECT `user_id` FROM `%1users` WHERE `server_id` = ? AND `name` like ?\");\n\tquery.addBindValue(iServerNum);\n\tquery.addBindValue(name);\n\tSQLEXEC();\n\tif (query.next()) {\n\t\tid = query.value(0).toInt();\n\t\tqhUserIDCache.insert(name, id);\n\t\tqhUserNameCache.insert(id, name);\n\t}\n\treturn id;\n}",
        "target": 1
    },
    {
        "func": "vte_sequence_handler_window_manipulation (VteTerminal *terminal, GValueArray *params)\n{\n\tGdkScreen *gscreen;\n\tVteScreen *screen;\n\tGValue *value;\n\tGtkWidget *widget;\n\tchar buf[128];\n\tlong param, arg1, arg2;\n\tgint width, height;\n\tguint i;\n\n\twidget = &terminal->widget;\n\tscreen = terminal->pvt->screen;\n\n\tfor (i = 0; ((params != NULL) && (i < params->n_values)); i++) {\n\t\targ1 = arg2 = -1;\n\t\tif (i + 1 < params->n_values) {\n\t\t\tvalue = g_value_array_get_nth(params, i + 1);\n\t\t\tif (G_VALUE_HOLDS_LONG(value)) {\n\t\t\t\targ1 = g_value_get_long(value);\n\t\t\t}\n\t\t}\n\t\tif (i + 2 < params->n_values) {\n\t\t\tvalue = g_value_array_get_nth(params, i + 2);\n\t\t\tif (G_VALUE_HOLDS_LONG(value)) {\n\t\t\t\targ2 = g_value_get_long(value);\n\t\t\t}\n\t\t}\n\t\tvalue = g_value_array_get_nth(params, i);\n\t\tif (!G_VALUE_HOLDS_LONG(value)) {\n\t\t\tcontinue;\n\t\t}\n\t\tparam = g_value_get_long(value);\n\t\tswitch (param) {\n\t\tcase 1:\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\"Deiconifying window.\\n\");\n\t\t\tvte_terminal_emit_deiconify_window(terminal);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\"Iconifying window.\\n\");\n\t\t\tvte_terminal_emit_iconify_window(terminal);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif ((arg1 != -1) && (arg2 != -2)) {\n\t\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\t\"Moving window to \"\n\t\t\t\t\t\t\"%ld,%ld.\\n\", arg1, arg2);\n\t\t\t\tvte_terminal_emit_move_window(terminal,\n\t\t\t\t\t\t\t      arg1, arg2);\n\t\t\t\ti += 2;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tif ((arg1 != -1) && (arg2 != -1)) {\n\t\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\t\"Resizing window \"\n\t\t\t\t\t\t\"(to %ldx%ld pixels).\\n\",\n\t\t\t\t\t\targ2, arg1);\n\t\t\t\tvte_terminal_emit_resize_window(terminal,\n\t\t\t\t\t\t\t\targ2 +\n\t\t\t\t\t\t\t\tVTE_PAD_WIDTH * 2,\n\t\t\t\t\t\t\t\targ1 +\n\t\t\t\t\t\t\t\tVTE_PAD_WIDTH * 2);\n\t\t\t\ti += 2;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE, \"Raising window.\\n\");\n\t\t\tvte_terminal_emit_raise_window(terminal);\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE, \"Lowering window.\\n\");\n\t\t\tvte_terminal_emit_lower_window(terminal);\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\"Refreshing window.\\n\");\n\t\t\t_vte_invalidate_all(terminal);\n\t\t\tvte_terminal_emit_refresh_window(terminal);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tif ((arg1 != -1) && (arg2 != -1)) {\n\t\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\t\"Resizing window \"\n\t\t\t\t\t\t\"(to %ld columns, %ld rows).\\n\",\n\t\t\t\t\t\targ2, arg1);\n\t\t\t\tvte_terminal_emit_resize_window(terminal,\n\t\t\t\t\t\t\t\targ2 * terminal->char_width +\n\t\t\t\t\t\t\t\tVTE_PAD_WIDTH * 2,\n\t\t\t\t\t\t\t\targ1 * terminal->char_height +\n\t\t\t\t\t\t\t\tVTE_PAD_WIDTH * 2);\n\t\t\t\ti += 2;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\tswitch (arg1) {\n\t\t\tcase 0:\n\t\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\t\"Restoring window.\\n\");\n\t\t\t\tvte_terminal_emit_restore_window(terminal);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\t\"Maximizing window.\\n\");\n\t\t\t\tvte_terminal_emit_maximize_window(terminal);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t\tbreak;\n\t\tcase 11:\n\t\t\t/* If we're unmapped, then we're iconified. */\n\t\t\tg_snprintf(buf, sizeof(buf),\n\t\t\t\t   _VTE_CAP_CSI \"%dt\",\n\t\t\t\t   1 + !GTK_WIDGET_MAPPED(widget));\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\"Reporting window state %s.\\n\",\n\t\t\t\t\tGTK_WIDGET_MAPPED(widget) ?\n\t\t\t\t\t\"non-iconified\" : \"iconified\");\n\t\t\tvte_terminal_feed_child(terminal, buf, -1);\n\t\t\tbreak;\n\t\tcase 13:\n\t\t\t/* Send window location, in pixels. */\n\t\t\tgdk_window_get_origin(widget->window,\n\t\t\t\t\t      &width, &height);\n\t\t\tg_snprintf(buf, sizeof(buf),\n\t\t\t\t   _VTE_CAP_CSI \"%d;%dt\",\n\t\t\t\t   width + VTE_PAD_WIDTH, height + VTE_PAD_WIDTH);\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\"Reporting window location\"\n\t\t\t\t\t\"(%d++,%d++).\\n\",\n\t\t\t\t\twidth, height);\n\t\t\tvte_terminal_feed_child(terminal, buf, -1);\n\t\t\tbreak;\n\t\tcase 14:\n\t\t\t/* Send window size, in pixels. */\n\t\t\tg_snprintf(buf, sizeof(buf),\n\t\t\t\t   _VTE_CAP_CSI \"%d;%dt\",\n\t\t\t\t   widget->allocation.height - 2 * VTE_PAD_WIDTH,\n\t\t\t\t   widget->allocation.width - 2 * VTE_PAD_WIDTH);\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\"Reporting window size \"\n\t\t\t\t\t\"(%dx%dn\",\n\t\t\t\t\twidth - 2 * VTE_PAD_WIDTH,\n\t\t\t\t\theight - 2 * VTE_PAD_WIDTH);\n\t\t\tvte_terminal_feed_child(terminal, buf, -1);\n\t\t\tbreak;\n\t\tcase 18:\n\t\t\t/* Send widget size, in cells. */\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\"Reporting widget size.\\n\");\n\t\t\tg_snprintf(buf, sizeof(buf),\n\t\t\t\t   _VTE_CAP_CSI \"%ld;%ldt\",\n\t\t\t\t   terminal->row_count,\n\t\t\t\t   terminal->column_count);\n\t\t\tvte_terminal_feed_child(terminal, buf, -1);\n\t\t\tbreak;\n\t\tcase 19:\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\"Reporting screen size.\\n\");\n\t\t\tgscreen = gtk_widget_get_screen(widget);\n\t\t\theight = gdk_screen_get_height(gscreen);\n\t\t\twidth = gdk_screen_get_width(gscreen);\n\t\t\tg_snprintf(buf, sizeof(buf),\n\t\t\t\t   _VTE_CAP_CSI \"%ld;%ldt\",\n\t\t\t\t   height / terminal->char_height,\n\t\t\t\t   width / terminal->char_width);\n\t\t\tvte_terminal_feed_child(terminal, buf, -1);\n\t\t\tbreak;\n\t\tcase 20:\n\t\t\t/* Report the icon title. */\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\"Reporting icon title.\\n\");\n\t\t\tvte_terminal_feed_child(terminal, _VTE_CAP_OSC \"LTerminal\" _VTE_CAP_ST, -1);\n\t\t\tbreak;\n\t\tcase 21:\n\t\t\t/* Report the window title. */\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\"Reporting window title.\\n\");\n\t\t\tvte_terminal_feed_child(terminal, _VTE_CAP_OSC \"LTerminal\" _VTE_CAP_ST, -1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (param >= 24) {\n\t\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\t\"Resizing to %ld rows.\\n\",\n\t\t\t\t\t       \tparam);\n\t\t\t\t/* Resize to the specified number of\n\t\t\t\t * rows. */\n\t\t\t\tvte_terminal_emit_resize_window(terminal,\n\t\t\t\t\t\t\t\tterminal->column_count * terminal->char_width +\n\t\t\t\t\t\t\t\tVTE_PAD_WIDTH * 2,\n\t\t\t\t\t\t\t\tparam * terminal->char_height +\n\t\t\t\t\t\t\t\tVTE_PAD_WIDTH * 2);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}",
        "target": 1
    },
    {
        "func": "vte_sequence_handler_window_manipulation (VteTerminal *terminal, GValueArray *params)\n{\n\tGdkScreen *gscreen;\n\tVteScreen *screen;\n\tGValue *value;\n\tGtkWidget *widget;\n\tchar buf[128];\n\tlong param, arg1, arg2;\n\tgint width, height;\n\tguint i;\n\tGtkAllocation allocation;\n\n\twidget = &terminal->widget;\n\tscreen = terminal->pvt->screen;\n\n\tfor (i = 0; ((params != NULL) && (i < params->n_values)); i++) {\n\t\targ1 = arg2 = -1;\n\t\tif (i + 1 < params->n_values) {\n\t\t\tvalue = g_value_array_get_nth(params, i + 1);\n\t\t\tif (G_VALUE_HOLDS_LONG(value)) {\n\t\t\t\targ1 = g_value_get_long(value);\n\t\t\t}\n\t\t}\n\t\tif (i + 2 < params->n_values) {\n\t\t\tvalue = g_value_array_get_nth(params, i + 2);\n\t\t\tif (G_VALUE_HOLDS_LONG(value)) {\n\t\t\t\targ2 = g_value_get_long(value);\n\t\t\t}\n\t\t}\n\t\tvalue = g_value_array_get_nth(params, i);\n\t\tif (!G_VALUE_HOLDS_LONG(value)) {\n\t\t\tcontinue;\n\t\t}\n\t\tparam = g_value_get_long(value);\n\t\tswitch (param) {\n\t\tcase 1:\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\"Deiconifying window.\\n\");\n\t\t\tvte_terminal_emit_deiconify_window(terminal);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\"Iconifying window.\\n\");\n\t\t\tvte_terminal_emit_iconify_window(terminal);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif ((arg1 != -1) && (arg2 != -2)) {\n\t\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\t\"Moving window to \"\n\t\t\t\t\t\t\"%ld,%ld.\\n\", arg1, arg2);\n\t\t\t\tvte_terminal_emit_move_window(terminal,\n\t\t\t\t\t\t\t      arg1, arg2);\n\t\t\t\ti += 2;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tif ((arg1 != -1) && (arg2 != -1)) {\n\t\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\t\"Resizing window \"\n\t\t\t\t\t\t\"(to %ldx%ld pixels).\\n\",\n\t\t\t\t\t\targ2, arg1);\n\t\t\t\tvte_terminal_emit_resize_window(terminal,\n\t\t\t\t\t\t\t\targ2 +\n\t\t\t\t\t\t\t\tterminal->pvt->inner_border.left +\n\t\t\t\t\t\t\t\tterminal->pvt->inner_border.right,\n\t\t\t\t\t\t\t\targ1 +\n\t\t\t\t\t\t\t\tterminal->pvt->inner_border.top +\n\t\t\t\t\t\t\t\tterminal->pvt->inner_border.bottom);\n\t\t\t\ti += 2;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE, \"Raising window.\\n\");\n\t\t\tvte_terminal_emit_raise_window(terminal);\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE, \"Lowering window.\\n\");\n\t\t\tvte_terminal_emit_lower_window(terminal);\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\"Refreshing window.\\n\");\n\t\t\t_vte_invalidate_all(terminal);\n\t\t\tvte_terminal_emit_refresh_window(terminal);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tif ((arg1 != -1) && (arg2 != -1)) {\n\t\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\t\"Resizing window \"\n\t\t\t\t\t\t\"(to %ld columns, %ld rows).\\n\",\n\t\t\t\t\t\targ2, arg1);\n\t\t\t\tvte_terminal_emit_resize_window(terminal,\n\t\t\t\t\t\t\t\targ2 * terminal->char_width +\n\t\t\t\t\t\t\t\tterminal->pvt->inner_border.left +\n\t\t\t\t\t\t\t\tterminal->pvt->inner_border.right,\n\t\t\t\t\t\t\t\targ1 * terminal->char_height +\n\t\t\t\t\t\t\t\tterminal->pvt->inner_border.top +\n\t\t\t\t\t\t\t\tterminal->pvt->inner_border.bottom);\n\t\t\t\ti += 2;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\tswitch (arg1) {\n\t\t\tcase 0:\n\t\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\t\"Restoring window.\\n\");\n\t\t\t\tvte_terminal_emit_restore_window(terminal);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\t\"Maximizing window.\\n\");\n\t\t\t\tvte_terminal_emit_maximize_window(terminal);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t\tbreak;\n\t\tcase 11:\n\t\t\t/* If we're unmapped, then we're iconified. */\n\t\t\tg_snprintf(buf, sizeof(buf),\n\t\t\t\t   _VTE_CAP_CSI \"%dt\",\n\t\t\t\t   1 + !gtk_widget_get_mapped(widget));\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\"Reporting window state %s.\\n\",\n\t\t\t\t\tgtk_widget_get_mapped(widget) ?\n\t\t\t\t\t\"non-iconified\" : \"iconified\");\n\t\t\tvte_terminal_feed_child(terminal, buf, -1);\n\t\t\tbreak;\n\t\tcase 13:\n\t\t\t/* Send window location, in pixels. */\n\t\t\tgdk_window_get_origin(gtk_widget_get_window(widget),\n\t\t\t\t\t      &width, &height);\n\t\t\tg_snprintf(buf, sizeof(buf),\n\t\t\t\t   _VTE_CAP_CSI \"3;%d;%dt\",\n\t\t\t\t   width + terminal->pvt->inner_border.left,\n                                   height + terminal->pvt->inner_border.top);\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\"Reporting window location\"\n\t\t\t\t\t\"(%d++,%d++).\\n\",\n\t\t\t\t\twidth, height);\n\t\t\tvte_terminal_feed_child(terminal, buf, -1);\n\t\t\tbreak;\n\t\tcase 14:\n\t\t\t/* Send window size, in pixels. */\n\t\t\tgtk_widget_get_allocation(widget, &allocation);\n\t\t\tg_snprintf(buf, sizeof(buf),\n\t\t\t\t   _VTE_CAP_CSI \"4;%d;%dt\",\n\t\t\t\t   allocation.height -\n                                       (terminal->pvt->inner_border.top +\n                                        terminal->pvt->inner_border.bottom),\n\t\t\t\t   allocation.width -\n                                       (terminal->pvt->inner_border.left +\n                                        terminal->pvt->inner_border.right));\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\"Reporting window size \"\n\t\t\t\t\t\"(%dx%dn\",\n\t\t\t\t\twidth - (terminal->pvt->inner_border.left + terminal->pvt->inner_border.right),\n\t\t\t\t\theight - (terminal->pvt->inner_border.top + terminal->pvt->inner_border.bottom));\n\t\t\tvte_terminal_feed_child(terminal, buf, -1);\n\t\t\tbreak;\n\t\tcase 18:\n\t\t\t/* Send widget size, in cells. */\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\"Reporting widget size.\\n\");\n\t\t\tg_snprintf(buf, sizeof(buf),\n\t\t\t\t   _VTE_CAP_CSI \"8;%ld;%ldt\",\n\t\t\t\t   terminal->row_count,\n\t\t\t\t   terminal->column_count);\n\t\t\tvte_terminal_feed_child(terminal, buf, -1);\n\t\t\tbreak;\n\t\tcase 19:\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\"Reporting screen size.\\n\");\n\t\t\tgscreen = gtk_widget_get_screen(widget);\n\t\t\theight = gdk_screen_get_height(gscreen);\n\t\t\twidth = gdk_screen_get_width(gscreen);\n\t\t\tg_snprintf(buf, sizeof(buf),\n\t\t\t\t   _VTE_CAP_CSI \"9;%ld;%ldt\",\n\t\t\t\t   height / terminal->char_height,\n\t\t\t\t   width / terminal->char_width);\n\t\t\tvte_terminal_feed_child(terminal, buf, -1);\n\t\t\tbreak;\n\t\tcase 20:\n\t\t\t/* Report the icon title. */\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\"Reporting icon title.\\n\");\n\t\t\tg_snprintf (buf, sizeof (buf),\n\t\t\t\t    _VTE_CAP_OSC \"L%s\" _VTE_CAP_ST,\n\t\t\t\t    terminal->icon_title);\n\t\t\tvte_terminal_feed_child(terminal, buf, -1);\n\t\t\tbreak;\n\t\tcase 21:\n\t\t\t/* Report the window title. */\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\"Reporting window title.\\n\");\n\t\t\tg_snprintf (buf, sizeof (buf),\n\t\t\t\t    _VTE_CAP_OSC \"l%s\" _VTE_CAP_ST,\n\t\t\t\t    terminal->window_title);\n\t\t\tvte_terminal_feed_child(terminal, buf, -1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (param >= 24) {\n\t\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\t\"Resizing to %ld rows.\\n\",\n\t\t\t\t\t       \tparam);\n\t\t\t\t/* Resize to the specified number of\n\t\t\t\t * rows. */\n\t\t\t\tvte_terminal_emit_resize_window(terminal,\n\t\t\t\t\t\t\t\tterminal->column_count * terminal->char_width +\n                                                                terminal->pvt->inner_border.left +\n                                                                terminal->pvt->inner_border.right,\n\t\t\t\t\t\t\t\tparam * terminal->char_height +\n\t\t\t\t\t\t\t\tterminal->pvt->inner_border.top +\n                                                                terminal->pvt->inner_border.bottom);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}",
        "target": 1
    },
    {
        "func": "  main( int    argc,\n        char*  argv[] )\n  {\n    int    old_ptsize, orig_ptsize, file;\n    int    first_glyph = 0;\n    int    XisSetup = 0;\n    char*  execname;\n    int    option;\n    int    file_loaded;\n\n    grEvent  event;\n\n\n    execname = ft_basename( argv[0] );\n\n    while ( 1 )\n    {\n      option = getopt( argc, argv, \"d:e:f:r:\" );\n\n      if ( option == -1 )\n        break;\n\n      switch ( option )\n      {\n      case 'd':\n        parse_design_coords( optarg );\n        break;\n\n      case 'e':\n        encoding = (FT_Encoding)make_tag( optarg );\n        break;\n\n      case 'f':\n        first_glyph = atoi( optarg );\n        break;\n\n      case 'r':\n        res = atoi( optarg );\n        if ( res < 1 )\n          usage( execname );\n        break;\n\n      default:\n        usage( execname );\n        break;\n      }\n    }\n\n    argc -= optind;\n    argv += optind;\n\n    if ( argc <= 1 )\n      usage( execname );\n\n    if ( sscanf( argv[0], \"%d\", &orig_ptsize ) != 1 )\n      orig_ptsize = 64;\n\n    file = 1;\n\n    /* Initialize engine */\n    error = FT_Init_FreeType( &library );\n    if ( error )\n      PanicZ( \"Could not initialize FreeType library\" );\n\n  NewFile:\n    ptsize      = orig_ptsize;\n    hinted      = 1;\n    file_loaded = 0;\n\n    /* Load face */\n    error = FT_New_Face( library, argv[file], 0, &face );\n    if ( error )\n      goto Display_Font;\n\n    if ( encoding != FT_ENCODING_NONE )\n    {\n      error = FT_Select_Charmap( face, encoding );\n      if ( error )\n        goto Display_Font;\n    }\n\n    /* retrieve multiple master information */\n    error = FT_Get_MM_Var( face, &multimaster );\n    if ( error )\n      goto Display_Font;\n\n    /* if the user specified a position, use it, otherwise */\n    /* set the current position to the median of each axis */\n    {\n      int  n;\n\n\n      for ( n = 0; n < (int)multimaster->num_axis; n++ )\n      {\n        design_pos[n] = n < requested_cnt ? requested_pos[n]\n                                          : multimaster->axis[n].def;\n        if ( design_pos[n] < multimaster->axis[n].minimum )\n          design_pos[n] = multimaster->axis[n].minimum;\n        else if ( design_pos[n] > multimaster->axis[n].maximum )\n          design_pos[n] = multimaster->axis[n].maximum;\n      }\n    }\n\n    error = FT_Set_Var_Design_Coordinates( face,\n                                           multimaster->num_axis,\n                                           design_pos );\n    if ( error )\n      goto Display_Font;\n\n    file_loaded++;\n\n    Reset_Scale( ptsize );\n\n    num_glyphs = face->num_glyphs;\n    glyph      = face->glyph;\n    size       = face->size;\n\n  Display_Font:\n    /* initialize graphics if needed */\n    if ( !XisSetup )\n    {\n      XisSetup = 1;\n      Init_Display();\n    }\n\n    grSetTitle( surface, \"FreeType Glyph Viewer - press F1 for help\" );\n    old_ptsize = ptsize;\n\n    if ( file_loaded >= 1 )\n    {\n      Fail = 0;\n      Num  = first_glyph;\n\n      if ( Num >= num_glyphs )\n        Num = num_glyphs - 1;\n\n      if ( Num < 0 )\n        Num = 0;\n    }\n\n    for ( ;; )\n    {\n      int  key;\n\n\n      Clear_Display();\n\n      if ( file_loaded >= 1 )\n      {\n        switch ( render_mode )\n        {\n        case 0:\n          Render_Text( Num );\n          break;\n\n        default:\n          Render_All( Num, ptsize );\n        }\n\n        sprintf( Header, \"%s %s (file %s)\",\n                         face->family_name,\n                         face->style_name,\n                         ft_basename( argv[file] ) );\n\n        if ( !new_header )\n          new_header = Header;\n\n        grWriteCellString( &bit, 0, 0, new_header, fore_color );\n        new_header = 0;\n\n        sprintf( Header, \"axis: \" );\n        {\n          int  n;\n\n\n          for ( n = 0; n < (int)multimaster->num_axis; n++ )\n          {\n            char  temp[32];\n\n\n            sprintf( temp, \"  %s:%g\",\n                           multimaster->axis[n].name,\n                           design_pos[n]/65536. );\n            strcat( Header, temp );\n          }\n        }\n        grWriteCellString( &bit, 0, 16, Header, fore_color );\n\n        sprintf( Header, \"at %d points, first glyph = %d\",\n                         ptsize,\n                         Num );\n      }\n      else\n      {\n        sprintf( Header, \"%s: not an MM font file, or could not be opened\",\n                         ft_basename( argv[file] ) );\n      }\n\n      grWriteCellString( &bit, 0, 8, Header, fore_color );\n      grRefreshSurface( surface );\n\n      grListenSurface( surface, 0, &event );\n      if ( !( key = Process_Event( &event ) ) )\n        goto End;\n\n      if ( key == 'n' )\n      {\n        if ( file_loaded >= 1 )\n          FT_Done_Face( face );\n\n        if ( file < argc - 1 )\n          file++;\n\n        goto NewFile;\n      }\n\n      if ( key == 'p' )\n      {\n        if ( file_loaded >= 1 )\n          FT_Done_Face( face );\n\n        if ( file > 1 )\n          file--;\n\n        goto NewFile;\n      }\n\n      if ( ptsize != old_ptsize )\n      {\n        Reset_Scale( ptsize );\n\n        old_ptsize = ptsize;\n      }\n    }\n\n  End:\n    grDoneSurface( surface );\n    grDoneDevices();\n\n    free            ( multimaster );\n    FT_Done_Face    ( face        );\n    FT_Done_FreeType( library     );\n\n    printf( \"Execution completed successfully.\\n\" );\n    printf( \"Fails = %d\\n\", Fail );\n\n    exit( 0 );      /* for safety reasons */\n    return 0;       /* never reached */\n  }",
        "target": 1
    },
    {
        "func": "  write_header( FT_Error error_code )\n  {\n    FT_Face      face;\n    const char*  basename;\n    const char*  format;\n\n\n    error = FTC_Manager_LookupFace( handle->cache_manager,\n                                    handle->scaler.face_id, &face );\n    if ( error )\n      Fatal( \"can't access font file\" );\n\n    if ( !status.header )\n    {\n      basename = ft_basename( handle->current_font->filepathname );\n\n      switch ( error_code )\n      {\n      case FT_Err_Ok:\n        sprintf( status.header_buffer, \"%s %s (file `%s')\",\n                 face->family_name, face->style_name, basename );\n        break;\n\n      case FT_Err_Invalid_Pixel_Size:\n        sprintf( status.header_buffer, \"Invalid pixel size (file `%s')\",\n                 basename );\n        break;\n\n      case FT_Err_Invalid_PPem:\n        sprintf( status.header_buffer, \"Invalid ppem value (file `%s')\",\n                 basename );\n        break;\n\n      default:\n        sprintf( status.header_buffer, \"File `%s': error 0x%04x\",\n                 basename, (FT_UShort)error_code );\n        break;\n      }\n\n      status.header = (const char *)status.header_buffer;\n    }\n\n    grWriteCellString( display->bitmap, 0, 0, status.header,\n                       display->fore_color );\n\n    format = \"at %g points, first glyph index = %d\";\n\n    snprintf( status.header_buffer, 256, format, status.ptsize/64., status.Num );\n\n    if ( FT_HAS_GLYPH_NAMES( face ) )\n    {\n      char*  p;\n      int    format_len, gindex, size;\n\n\n      size = strlen( status.header_buffer );\n      p    = status.header_buffer + size;\n      size = 256 - size;\n\n      format = \", name = \";\n      format_len = strlen( format );\n\n      if ( size >= format_len + 2 )\n      {\n        gindex = status.Num;\n\n        strcpy( p, format );\n        if ( FT_Get_Glyph_Name( face, gindex, p + format_len, size - format_len ) )\n          *p = '\\0';\n      }\n    }\n\n    status.header = (const char *)status.header_buffer;\n    grWriteCellString( display->bitmap, 0, HEADER_HEIGHT,\n                       status.header_buffer, display->fore_color );\n\n    grRefreshSurface( display->surface );\n  }",
        "target": 1
    },
    {
        "func": "  write_header( FT_Error  error_code )\n  {\n    FT_Face      face;\n    const char*  basename;\n\n\n    error = FTC_Manager_LookupFace( handle->cache_manager,\n                                    handle->scaler.face_id, &face );\n    if ( error )\n      PanicZ( \"can't access font file\" );\n\n    if ( !status.header )\n    {\n      basename = ft_basename( handle->current_font->filepathname );\n\n      switch ( error_code )\n      {\n      case FT_Err_Ok:\n        sprintf( status.header_buffer, \"%s %s (file `%s')\", face->family_name,\n                 face->style_name, basename );\n        break;\n      case FT_Err_Invalid_Pixel_Size:\n        sprintf( status.header_buffer, \"Invalid pixel size (file `%s')\",\n                 basename );\n        break;\n      case FT_Err_Invalid_PPem:\n        sprintf( status.header_buffer, \"Invalid ppem value (file `%s')\",\n                 basename );\n        break;\n      default:\n        sprintf( status.header_buffer, \"File `%s': error 0x%04x\", basename,\n            (FT_UShort)error_code );\n        break;\n      }\n\n      status.header = status.header_buffer;\n    }\n\n    grWriteCellString( display->bitmap, 0, 0,\n                       status.header, display->fore_color );\n\n    sprintf( status.header_buffer, \"at %g points, angle = %d\",\n             status.ptsize/64.0, status.angle );\n    grWriteCellString( display->bitmap, 0, CELLSTRING_HEIGHT,\n                       status.header_buffer, display->fore_color );\n\n    grRefreshSurface( display->surface );\n  }",
        "target": 1
    },
    {
        "func": "  write_header( FT_Error  error_code )\n  {\n    FT_Face      face;\n    const char*  basename;\n    const char*  format;\n\n\n    error = FTC_Manager_LookupFace( handle->cache_manager,\n                                    handle->scaler.face_id, &face );\n    if ( error )\n      Fatal( \"can't access font file\" );\n\n    if ( !status.header )\n    {\n      basename = ft_basename( handle->current_font->filepathname );\n\n      switch ( error_code )\n      {\n      case FT_Err_Ok:\n        sprintf( status.header_buffer, \"%s %s (file `%s')\",\n                 face->family_name, face->style_name, basename );\n        break;\n      case FT_Err_Invalid_Pixel_Size:\n        sprintf( status.header_buffer, \"Invalid pixel size (file `%s')\",\n                 basename );\n        break;\n      case FT_Err_Invalid_PPem:\n        sprintf( status.header_buffer, \"Invalid ppem value (file `%s')\",\n                 basename );\n        break;\n      default:\n        sprintf( status.header_buffer, \"File `%s': error 0x%04x\",\n                 basename, (FT_UShort)error_code );\n        break;\n      }\n\n      status.header = status.header_buffer;\n    }\n\n    grWriteCellString( display->bitmap, 0, 0,\n                       status.header, display->fore_color );\n\n    format = status.encoding != FT_ENCODING_NONE\n             ? \"at %g points, first char code = 0x%x\"\n             : \"at %g points, first glyph index = %d\";\n\n    snprintf( status.header_buffer, 256, format,\n              status.ptsize / 64.0, status.Num );\n\n    if ( FT_HAS_GLYPH_NAMES( face ) )\n    {\n      char*  p;\n      int    format_len, gindex, size;\n\n\n      size = strlen( status.header_buffer );\n      p    = status.header_buffer + size;\n      size = 256 - size;\n\n      format = \", name = \";\n      format_len = strlen( format );\n\n      if ( size >= format_len + 2 )\n      {\n        gindex = status.Num;\n        if ( status.encoding != FT_ENCODING_NONE )\n          gindex = FTDemo_Get_Index( handle, status.Num );\n\n        strcpy( p, format );\n        if ( FT_Get_Glyph_Name( face, gindex,\n                                p + format_len, size - format_len ) )\n          *p = '\\0';\n      }\n    }\n\n    status.header = status.header_buffer;\n    grWriteCellString( display->bitmap, 0, HEADER_HEIGHT,\n                       status.header_buffer, display->fore_color );\n\n    if ( status.use_custom_lcd_filter )\n    {\n      int             fwi = status.fw_index;\n      unsigned char  *fw  = status.filter_weights;\n\n\n      sprintf( status.header_buffer,\n               \"%s0x%02X%s%s0x%02X%s%s0x%02X%s%s0x%02X%s%s0x%02X%s\",\n               fwi == 0 ? \"[\" : \" \", fw[0], fwi == 0 ? \"]\" : \" \",\n               fwi == 1 ? \"[\" : \" \", fw[1], fwi == 1 ? \"]\" : \" \",\n               fwi == 2 ? \"[\" : \" \", fw[2], fwi == 2 ? \"]\" : \" \",\n               fwi == 3 ? \"[\" : \" \", fw[3], fwi == 3 ? \"]\" : \" \",\n               fwi == 4 ? \"[\" : \" \", fw[4], fwi == 4 ? \"]\" : \" \" );\n      grWriteCellString( display->bitmap, 0, 2 * HEADER_HEIGHT,\n                         status.header_buffer, display->fore_color );\n    }\n\n    grRefreshSurface( display->surface );\n  }",
        "target": 1
    },
    {
        "func": "  write_message( RenderState  state )\n  {\n    ADisplay  adisplay = (ADisplay)state->display.disp;\n\n\n    if ( state->message == NULL )\n    {\n      FontFace  face = &state->faces[state->face_index];\n      int       idx, total;\n\n\n      idx   = face->index;\n      total = 1;\n      while ( total + state->face_index < state->num_faces &&\n              face[total].filepath == face[0].filepath     )\n        total++;\n\n      total += idx;\n\n      state->message = state->message0;\n      if ( total > 1 )\n        sprintf( state->message0, \"%s %d/%d @ %5.1fpt\",\n                 state->filename, idx + 1, total,\n                 state->char_size );\n      else\n        sprintf( state->message0, \"%s @ %5.1fpt\",\n                 state->filename,\n                 state->char_size );\n    }\n\n    grWriteCellString( adisplay->bitmap, 0, DIM_Y - 10, state->message,\n                       adisplay->fore_color );\n\n    state->message = NULL;\n  }",
        "target": 1
    },
    {
        "func": "  main( int    argc,\n        char*  argv[] )\n  {\n    int    old_ptsize, orig_ptsize, file;\n    int    first_glyph = 0;\n    int    XisSetup = 0;\n    char*  execname;\n    int    option;\n    int    file_loaded;\n\n    grEvent  event;\n\n\n    execname = ft_basename( argv[0] );\n\n    while ( 1 )\n    {\n      option = getopt( argc, argv, \"d:e:f:r:\" );\n\n      if ( option == -1 )\n        break;\n\n      switch ( option )\n      {\n      case 'd':\n        parse_design_coords( optarg );\n        break;\n\n      case 'e':\n        encoding = (FT_Encoding)make_tag( optarg );\n        break;\n\n      case 'f':\n        first_glyph = atoi( optarg );\n        break;\n\n      case 'r':\n        res = atoi( optarg );\n        if ( res < 1 )\n          usage( execname );\n        break;\n\n      default:\n        usage( execname );\n        break;\n      }\n    }\n\n    argc -= optind;\n    argv += optind;\n\n    if ( argc <= 1 )\n      usage( execname );\n\n    if ( sscanf( argv[0], \"%d\", &orig_ptsize ) != 1 )\n      orig_ptsize = 64;\n\n    file = 1;\n\n    /* Initialize engine */\n    error = FT_Init_FreeType( &library );\n    if ( error )\n      PanicZ( \"Could not initialize FreeType library\" );\n\n  NewFile:\n    ptsize      = orig_ptsize;\n    hinted      = 1;\n    file_loaded = 0;\n\n    /* Load face */\n    error = FT_New_Face( library, argv[file], 0, &face );\n    if ( error )\n      goto Display_Font;\n\n    if ( encoding != FT_ENCODING_NONE )\n    {\n      error = FT_Select_Charmap( face, encoding );\n      if ( error )\n        goto Display_Font;\n    }\n\n    /* retrieve multiple master information */\n    error = FT_Get_MM_Var( face, &multimaster );\n    if ( error )\n      goto Display_Font;\n\n    /* if the user specified a position, use it, otherwise */\n    /* set the current position to the median of each axis */\n    {\n      int  n;\n\n\n      for ( n = 0; n < (int)multimaster->num_axis; n++ )\n      {\n        design_pos[n] = n < requested_cnt ? requested_pos[n]\n                                          : multimaster->axis[n].def;\n        if ( design_pos[n] < multimaster->axis[n].minimum )\n          design_pos[n] = multimaster->axis[n].minimum;\n        else if ( design_pos[n] > multimaster->axis[n].maximum )\n          design_pos[n] = multimaster->axis[n].maximum;\n      }\n    }\n\n    error = FT_Set_Var_Design_Coordinates( face,\n                                           multimaster->num_axis,\n                                           design_pos );\n    if ( error )\n      goto Display_Font;\n\n    file_loaded++;\n\n    Reset_Scale( ptsize );\n\n    num_glyphs = face->num_glyphs;\n    glyph      = face->glyph;\n    size       = face->size;\n\n  Display_Font:\n    /* initialize graphics if needed */\n    if ( !XisSetup )\n    {\n      XisSetup = 1;\n      Init_Display();\n    }\n\n    grSetTitle( surface, \"FreeType Glyph Viewer - press F1 for help\" );\n    old_ptsize = ptsize;\n\n    if ( file_loaded >= 1 )\n    {\n      Fail = 0;\n      Num  = first_glyph;\n\n      if ( Num >= num_glyphs )\n        Num = num_glyphs - 1;\n\n      if ( Num < 0 )\n        Num = 0;\n    }\n\n    for ( ;; )\n    {\n      int  key;\n\n\n      Clear_Display();\n\n      if ( file_loaded >= 1 )\n      {\n        switch ( render_mode )\n        {\n        case 0:\n          Render_Text( Num );\n          break;\n\n        default:\n          Render_All( Num, ptsize );\n        }\n\n        sprintf( Header, \"%.50s %.50s (file %.100s)\",\n                         face->family_name,\n                         face->style_name,\n                         ft_basename( argv[file] ) );\n\n        if ( !new_header )\n          new_header = Header;\n\n        grWriteCellString( &bit, 0, 0, new_header, fore_color );\n        new_header = 0;\n\n        sprintf( Header, \"axis: \" );\n        {\n          int  n;\n\n\n          for ( n = 0; n < (int)multimaster->num_axis; n++ )\n          {\n            char  temp[32];\n\n\n            sprintf( temp, \"  %s:%g\",\n                           multimaster->axis[n].name,\n                           design_pos[n]/65536. );\n            strcat( Header, temp );\n          }\n        }\n        grWriteCellString( &bit, 0, 16, Header, fore_color );\n\n        sprintf( Header, \"at %d points, first glyph = %d\",\n                         ptsize,\n                         Num );\n      }\n      else\n      {\n        sprintf( Header, \"%.100s: not an MM font file, or could not be opened\",\n                         ft_basename( argv[file] ) );\n      }\n\n      grWriteCellString( &bit, 0, 8, Header, fore_color );\n      grRefreshSurface( surface );\n\n      grListenSurface( surface, 0, &event );\n      if ( !( key = Process_Event( &event ) ) )\n        goto End;\n\n      if ( key == 'n' )\n      {\n        if ( file_loaded >= 1 )\n          FT_Done_Face( face );\n\n        if ( file < argc - 1 )\n          file++;\n\n        goto NewFile;\n      }\n\n      if ( key == 'p' )\n      {\n        if ( file_loaded >= 1 )\n          FT_Done_Face( face );\n\n        if ( file > 1 )\n          file--;\n\n        goto NewFile;\n      }\n\n      if ( ptsize != old_ptsize )\n      {\n        Reset_Scale( ptsize );\n\n        old_ptsize = ptsize;\n      }\n    }\n\n  End:\n    grDoneSurface( surface );\n    grDoneDevices();\n\n    free            ( multimaster );\n    FT_Done_Face    ( face        );\n    FT_Done_FreeType( library     );\n\n    printf( \"Execution completed successfully.\\n\" );\n    printf( \"Fails = %d\\n\", Fail );\n\n    exit( 0 );      /* for safety reasons */\n    return 0;       /* never reached */\n  }",
        "target": 1
    },
    {
        "func": "long keyctl_session_to_parent(void)\n{\n#ifdef TIF_NOTIFY_RESUME\n\tstruct task_struct *me, *parent;\n\tconst struct cred *mycred, *pcred;\n\tstruct cred *cred, *oldcred;\n\tkey_ref_t keyring_r;\n\tint ret;\n\n\tkeyring_r = lookup_user_key(KEY_SPEC_SESSION_KEYRING, 0, KEY_LINK);\n\tif (IS_ERR(keyring_r))\n\t\treturn PTR_ERR(keyring_r);\n\n\t/* our parent is going to need a new cred struct, a new tgcred struct\n\t * and new security data, so we allocate them here to prevent ENOMEM in\n\t * our parent */\n\tret = -ENOMEM;\n\tcred = cred_alloc_blank();\n\tif (!cred)\n\t\tgoto error_keyring;\n\n\tcred->tgcred->session_keyring = key_ref_to_ptr(keyring_r);\n\tkeyring_r = NULL;\n\n\tme = current;\n\twrite_lock_irq(&tasklist_lock);\n\n\tparent = me->real_parent;\n\tret = -EPERM;\n\n\t/* the parent mustn't be init and mustn't be a kernel thread */\n\tif (parent->pid <= 1 || !parent->mm)\n\t\tgoto not_permitted;\n\n\t/* the parent must be single threaded */\n\tif (!thread_group_empty(parent))\n\t\tgoto not_permitted;\n\n\t/* the parent and the child must have different session keyrings or\n\t * there's no point */\n\tmycred = current_cred();\n\tpcred = __task_cred(parent);\n\tif (mycred == pcred ||\n\t    mycred->tgcred->session_keyring == pcred->tgcred->session_keyring)\n\t\tgoto already_same;\n\n\t/* the parent must have the same effective ownership and mustn't be\n\t * SUID/SGID */\n\tif (pcred->uid\t!= mycred->euid\t||\n\t    pcred->euid\t!= mycred->euid\t||\n\t    pcred->suid\t!= mycred->euid\t||\n\t    pcred->gid\t!= mycred->egid\t||\n\t    pcred->egid\t!= mycred->egid\t||\n\t    pcred->sgid\t!= mycred->egid)\n\t\tgoto not_permitted;\n\n\t/* the keyrings must have the same UID */\n\tif (pcred->tgcred->session_keyring->uid != mycred->euid ||\n\t    mycred->tgcred->session_keyring->uid != mycred->euid)\n\t\tgoto not_permitted;\n\n\t/* if there's an already pending keyring replacement, then we replace\n\t * that */\n\toldcred = parent->replacement_session_keyring;\n\n\t/* the replacement session keyring is applied just prior to userspace\n\t * restarting */\n\tparent->replacement_session_keyring = cred;\n\tcred = NULL;\n\tset_ti_thread_flag(task_thread_info(parent), TIF_NOTIFY_RESUME);\n\n\twrite_unlock_irq(&tasklist_lock);\n\tif (oldcred)\n\t\tput_cred(oldcred);\n\treturn 0;\n\nalready_same:\n\tret = 0;\nnot_permitted:\n\twrite_unlock_irq(&tasklist_lock);\n\tput_cred(cred);\n\treturn ret;\n\nerror_keyring:\n\tkey_ref_put(keyring_r);\n\treturn ret;\n\n#else /* !TIF_NOTIFY_RESUME */\n\t/*\n\t * To be removed when TIF_NOTIFY_RESUME has been implemented on\n\t * m68k/xtensa\n\t */\n#warning TIF_NOTIFY_RESUME not implemented\n\treturn -EOPNOTSUPP;\n#endif /* !TIF_NOTIFY_RESUME */\n}",
        "target": 1
    },
    {
        "func": "long keyctl_session_to_parent(void)\n{\n#ifdef TIF_NOTIFY_RESUME\n\tstruct task_struct *me, *parent;\n\tconst struct cred *mycred, *pcred;\n\tstruct cred *cred, *oldcred;\n\tkey_ref_t keyring_r;\n\tint ret;\n\n\tkeyring_r = lookup_user_key(KEY_SPEC_SESSION_KEYRING, 0, KEY_LINK);\n\tif (IS_ERR(keyring_r))\n\t\treturn PTR_ERR(keyring_r);\n\n\t/* our parent is going to need a new cred struct, a new tgcred struct\n\t * and new security data, so we allocate them here to prevent ENOMEM in\n\t * our parent */\n\tret = -ENOMEM;\n\tcred = cred_alloc_blank();\n\tif (!cred)\n\t\tgoto error_keyring;\n\n\tcred->tgcred->session_keyring = key_ref_to_ptr(keyring_r);\n\tkeyring_r = NULL;\n\n\tme = current;\n\trcu_read_lock();\n\twrite_lock_irq(&tasklist_lock);\n\n\tparent = me->real_parent;\n\tret = -EPERM;\n\n\t/* the parent mustn't be init and mustn't be a kernel thread */\n\tif (parent->pid <= 1 || !parent->mm)\n\t\tgoto not_permitted;\n\n\t/* the parent must be single threaded */\n\tif (!thread_group_empty(parent))\n\t\tgoto not_permitted;\n\n\t/* the parent and the child must have different session keyrings or\n\t * there's no point */\n\tmycred = current_cred();\n\tpcred = __task_cred(parent);\n\tif (mycred == pcred ||\n\t    mycred->tgcred->session_keyring == pcred->tgcred->session_keyring)\n\t\tgoto already_same;\n\n\t/* the parent must have the same effective ownership and mustn't be\n\t * SUID/SGID */\n\tif (pcred->uid\t!= mycred->euid\t||\n\t    pcred->euid\t!= mycred->euid\t||\n\t    pcred->suid\t!= mycred->euid\t||\n\t    pcred->gid\t!= mycred->egid\t||\n\t    pcred->egid\t!= mycred->egid\t||\n\t    pcred->sgid\t!= mycred->egid)\n\t\tgoto not_permitted;\n\n\t/* the keyrings must have the same UID */\n\tif (pcred->tgcred->session_keyring->uid != mycred->euid ||\n\t    mycred->tgcred->session_keyring->uid != mycred->euid)\n\t\tgoto not_permitted;\n\n\t/* if there's an already pending keyring replacement, then we replace\n\t * that */\n\toldcred = parent->replacement_session_keyring;\n\n\t/* the replacement session keyring is applied just prior to userspace\n\t * restarting */\n\tparent->replacement_session_keyring = cred;\n\tcred = NULL;\n\tset_ti_thread_flag(task_thread_info(parent), TIF_NOTIFY_RESUME);\n\n\twrite_unlock_irq(&tasklist_lock);\n\trcu_read_unlock();\n\tif (oldcred)\n\t\tput_cred(oldcred);\n\treturn 0;\n\nalready_same:\n\tret = 0;\nnot_permitted:\n\twrite_unlock_irq(&tasklist_lock);\n\trcu_read_unlock();\n\tput_cred(cred);\n\treturn ret;\n\nerror_keyring:\n\tkey_ref_put(keyring_r);\n\treturn ret;\n\n#else /* !TIF_NOTIFY_RESUME */\n\t/*\n\t * To be removed when TIF_NOTIFY_RESUME has been implemented on\n\t * m68k/xtensa\n\t */\n#warning TIF_NOTIFY_RESUME not implemented\n\treturn -EOPNOTSUPP;\n#endif /* !TIF_NOTIFY_RESUME */\n}",
        "target": 1
    },
    {
        "func": "long do_io_submit(aio_context_t ctx_id, long nr,\n\t\t  struct iocb __user *__user *iocbpp, bool compat)\n{\n\tstruct kioctx *ctx;\n\tlong ret = 0;\n\tint i;\n\tstruct hlist_head batch_hash[AIO_BATCH_HASH_SIZE] = { { 0, }, };\n\n\tif (unlikely(nr < 0))\n\t\treturn -EINVAL;\n\n\tif (unlikely(!access_ok(VERIFY_READ, iocbpp, (nr*sizeof(*iocbpp)))))\n\t\treturn -EFAULT;\n\n\tctx = lookup_ioctx(ctx_id);\n\tif (unlikely(!ctx)) {\n\t\tpr_debug(\"EINVAL: io_submit: invalid context id\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * AKPM: should this return a partial result if some of the IOs were\n\t * successfully submitted?\n\t */\n\tfor (i=0; i<nr; i++) {\n\t\tstruct iocb __user *user_iocb;\n\t\tstruct iocb tmp;\n\n\t\tif (unlikely(__get_user(user_iocb, iocbpp + i))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (unlikely(copy_from_user(&tmp, user_iocb, sizeof(tmp)))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = io_submit_one(ctx, user_iocb, &tmp, batch_hash, compat);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\taio_batch_free(batch_hash);\n\n\tput_ioctx(ctx);\n\treturn i ? i : ret;\n}",
        "target": 1
    },
    {
        "func": "snd_seq_oss_open(struct file *file, int level)\n{\n\tint i, rc;\n\tstruct seq_oss_devinfo *dp;\n\n\tdp = kzalloc(sizeof(*dp), GFP_KERNEL);\n\tif (!dp) {\n\t\tsnd_printk(KERN_ERR \"can't malloc device info\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tdebug_printk((\"oss_open: dp = %p\\n\", dp));\n\n\tdp->cseq = system_client;\n\tdp->port = -1;\n\tdp->queue = -1;\n\n\tfor (i = 0; i < SNDRV_SEQ_OSS_MAX_CLIENTS; i++) {\n\t\tif (client_table[i] == NULL)\n\t\t\tbreak;\n\t}\n\n\tdp->index = i;\n\tif (i >= SNDRV_SEQ_OSS_MAX_CLIENTS) {\n\t\tsnd_printk(KERN_ERR \"too many applications\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto _error;\n\t}\n\n\t/* look up synth and midi devices */\n\tsnd_seq_oss_synth_setup(dp);\n\tsnd_seq_oss_midi_setup(dp);\n\n\tif (dp->synth_opened == 0 && dp->max_mididev == 0) {\n\t\t/* snd_printk(KERN_ERR \"no device found\\n\"); */\n\t\trc = -ENODEV;\n\t\tgoto _error;\n\t}\n\n\t/* create port */\n\tdebug_printk((\"create new port\\n\"));\n\trc = create_port(dp);\n\tif (rc < 0) {\n\t\tsnd_printk(KERN_ERR \"can't create port\\n\");\n\t\tgoto _error;\n\t}\n\n\t/* allocate queue */\n\tdebug_printk((\"allocate queue\\n\"));\n\trc = alloc_seq_queue(dp);\n\tif (rc < 0)\n\t\tgoto _error;\n\n\t/* set address */\n\tdp->addr.client = dp->cseq;\n\tdp->addr.port = dp->port;\n\t/*dp->addr.queue = dp->queue;*/\n\t/*dp->addr.channel = 0;*/\n\n\tdp->seq_mode = level;\n\n\t/* set up file mode */\n\tdp->file_mode = translate_mode(file);\n\n\t/* initialize read queue */\n\tdebug_printk((\"initialize read queue\\n\"));\n\tif (is_read_mode(dp->file_mode)) {\n\t\tdp->readq = snd_seq_oss_readq_new(dp, maxqlen);\n\t\tif (!dp->readq) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto _error;\n\t\t}\n\t}\n\n\t/* initialize write queue */\n\tdebug_printk((\"initialize write queue\\n\"));\n\tif (is_write_mode(dp->file_mode)) {\n\t\tdp->writeq = snd_seq_oss_writeq_new(dp, maxqlen);\n\t\tif (!dp->writeq) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto _error;\n\t\t}\n\t}\n\n\t/* initialize timer */\n\tdebug_printk((\"initialize timer\\n\"));\n\tdp->timer = snd_seq_oss_timer_new(dp);\n\tif (!dp->timer) {\n\t\tsnd_printk(KERN_ERR \"can't alloc timer\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto _error;\n\t}\n\tdebug_printk((\"timer initialized\\n\"));\n\n\t/* set private data pointer */\n\tfile->private_data = dp;\n\n\t/* set up for mode2 */\n\tif (level == SNDRV_SEQ_OSS_MODE_MUSIC)\n\t\tsnd_seq_oss_synth_setup_midi(dp);\n\telse if (is_read_mode(dp->file_mode))\n\t\tsnd_seq_oss_midi_open_all(dp, SNDRV_SEQ_OSS_FILE_READ);\n\n\tclient_table[dp->index] = dp;\n\tnum_clients++;\n\n\tdebug_printk((\"open done\\n\"));\n\treturn 0;\n\n _error:\n\tsnd_seq_oss_writeq_delete(dp->writeq);\n\tsnd_seq_oss_readq_delete(dp->readq);\n\tsnd_seq_oss_synth_cleanup(dp);\n\tsnd_seq_oss_midi_cleanup(dp);\n\tdelete_port(dp);\n\tdelete_seq_queue(dp->queue);\n\tkfree(dp);\n\n\treturn rc;\n}",
        "target": 1
    },
    {
        "func": "delete_port(struct seq_oss_devinfo *dp)\n{\n\tif (dp->port < 0)\n\t\treturn 0;\n\n\tdebug_printk((\"delete_port %i\\n\", dp->port));\n\treturn snd_seq_event_port_detach(dp->cseq, dp->port);\n}",
        "target": 1
    },
    {
        "func": "load_status_changed_cb (WebKitWebView *view,\n                        GParamSpec *spec,\n                        EphyEmbed *embed)\n{\n  EphyEmbedPrivate *priv = embed->priv;\n  WebKitLoadStatus status = webkit_web_view_get_load_status (view);\n\n  if (status == WEBKIT_LOAD_COMMITTED) {\n    const gchar* uri;\n    EphyWebViewSecurityLevel security_level;\n\n    uri = webkit_web_view_get_uri (view);\n\n    ephy_embed_destroy_top_widgets (embed);\n\n    if (g_strcmp0 (uri, priv->loading_uri) != 0) {\n      g_free (priv->loading_uri);\n      priv->loading_uri = g_strdup (uri);\n    }\n\n    ephy_web_view_location_changed (EPHY_WEB_VIEW (view),\n                                    uri);\n    restore_zoom_level (embed, uri);\n    ephy_history_add_page (embed->priv->history,\n                           uri,\n                           FALSE,\n                           FALSE);\n\n    /*\n     * FIXME: as a temporary workaround while soup lacks the needed\n     * security API, determine security level based on the existence of\n     * a 'https' prefix for the URI\n     */\n    if (uri && g_str_has_prefix (uri, \"https\"))\n      security_level = EPHY_WEB_VIEW_STATE_IS_SECURE_HIGH;\n    else\n      security_level = EPHY_WEB_VIEW_STATE_IS_UNKNOWN;\n\n    ephy_web_view_set_security_level (EPHY_WEB_VIEW (view), security_level);\n  } else if (status == WEBKIT_LOAD_PROVISIONAL || status == WEBKIT_LOAD_FINISHED) {\n    EphyWebViewNetState estate = EPHY_WEB_VIEW_STATE_UNKNOWN;\n    char *loading_uri = NULL;\n\n    if (status == WEBKIT_LOAD_PROVISIONAL) {\n      WebKitWebFrame *frame;\n      WebKitWebDataSource *source;\n      WebKitNetworkRequest *request;\n\n      frame = webkit_web_view_get_main_frame (view);\n      source = webkit_web_frame_get_provisional_data_source (frame);\n      request = webkit_web_data_source_get_initial_request (source);\n      loading_uri = g_strdup (webkit_network_request_get_uri (request));\n\n      /* We also store the URI we are currently loading here, because\n       * we will want to use it in WEBKIT_LOAD_FINISHED, because if a\n       * load fails we may never get to committed */\n      priv->loading_uri = g_strdup (loading_uri);\n\n      estate = (EphyWebViewNetState) (estate |\n                                      EPHY_WEB_VIEW_STATE_START |\n                                      EPHY_WEB_VIEW_STATE_NEGOTIATING |\n                                      EPHY_WEB_VIEW_STATE_IS_REQUEST |\n                                      EPHY_WEB_VIEW_STATE_IS_NETWORK);\n      \n      g_signal_emit_by_name (EPHY_WEB_VIEW (view), \"new-document-now\", loading_uri);\n    } else if (status == WEBKIT_LOAD_FINISHED) {\n      loading_uri = priv->loading_uri;\n\n      /* Will be freed below */\n      priv->loading_uri = NULL;\n\n      estate = (EphyWebViewNetState) (estate |\n                                      EPHY_WEB_VIEW_STATE_STOP |\n                                      EPHY_WEB_VIEW_STATE_IS_DOCUMENT |\n                                      EPHY_WEB_VIEW_STATE_IS_NETWORK);\n    }\n\n    ephy_web_view_update_from_net_state (EPHY_WEB_VIEW (view),\n                                         loading_uri,\n                                         (EphyWebViewNetState)estate);\n\n    g_free (loading_uri);\n\n  }\n}",
        "target": 1
    },
    {
        "func": "ephy_embed_single_initialize (EphyEmbedSingle *single)\n{\n  SoupSession *session;\n  SoupCookieJar *jar;\n  char *filename;\n  char *cookie_policy;\n\n  /* Initialise nspluginwrapper's plugins if available */\n  if (g_file_test (NSPLUGINWRAPPER_SETUP, G_FILE_TEST_EXISTS) != FALSE)\n    g_spawn_command_line_sync (NSPLUGINWRAPPER_SETUP, NULL, NULL, NULL, NULL);\n\n  ephy_embed_prefs_init ();\n\n  session = webkit_get_default_session ();\n\n  /* Store cookies in moz-compatible SQLite format */\n  filename = g_build_filename (ephy_dot_dir (), \"cookies.sqlite\", NULL);\n  jar = soup_cookie_jar_sqlite_new (filename, FALSE);\n  g_free (filename);\n  cookie_policy = eel_gconf_get_string (CONF_SECURITY_COOKIES_ACCEPT);\n  ephy_embed_prefs_set_cookie_jar_policy (jar, cookie_policy);\n  g_free (cookie_policy);\n\n  soup_session_add_feature (session, SOUP_SESSION_FEATURE (jar));\n  g_object_unref (jar);\n\n  /* Use GNOME proxy settings through libproxy */\n  soup_session_add_feature_by_type (session, SOUP_TYPE_PROXY_RESOLVER_GNOME);\n\n#ifdef SOUP_TYPE_PASSWORD_MANAGER\n  /* Use GNOME keyring to store passwords. Only add the manager if we\n     are not using a private session, otherwise we want any new\n     password to expire when we exit *and* we don't want to use any\n     existing password in the keyring */\n  if (ephy_has_private_profile () == FALSE)\n    soup_session_add_feature_by_type (session, SOUP_TYPE_PASSWORD_MANAGER_GNOME);\n#endif\n\n  return TRUE;\n}",
        "target": 1
    },
    {
        "func": "ephy_embed_single_initialize (EphyEmbedSingle *single)\n{\n  SoupSession *session;\n  SoupCookieJar *jar;\n  char *filename;\n  char *cookie_policy;\n\n  /* Initialise nspluginwrapper's plugins if available */\n  if (g_file_test (NSPLUGINWRAPPER_SETUP, G_FILE_TEST_EXISTS) != FALSE)\n    g_spawn_command_line_sync (NSPLUGINWRAPPER_SETUP, NULL, NULL, NULL, NULL);\n\n  ephy_embed_prefs_init ();\n\n  session = webkit_get_default_session ();\n\n#ifdef GTLS_SYSTEM_CA_FILE\n  /* Check SSL certificates */\n\n  if (g_file_test (GTLS_SYSTEM_CA_FILE, G_FILE_TEST_EXISTS)) {\n    g_object_set (session,\n                  SOUP_SESSION_SSL_CA_FILE, GTLS_SYSTEM_CA_FILE,\n                  \"ignore-ssl-cert-errors\", TRUE,\n                  NULL);\n  } else {\n    g_warning (_(\"CA Certificates file we should use was not found, \"\\\n                 \"all SSL sites will be considered to have a broken certificate.\"));\n  }\n#endif\n\n  /* Store cookies in moz-compatible SQLite format */\n  filename = g_build_filename (ephy_dot_dir (), \"cookies.sqlite\", NULL);\n  jar = soup_cookie_jar_sqlite_new (filename, FALSE);\n  g_free (filename);\n  cookie_policy = eel_gconf_get_string (CONF_SECURITY_COOKIES_ACCEPT);\n  ephy_embed_prefs_set_cookie_jar_policy (jar, cookie_policy);\n  g_free (cookie_policy);\n\n  soup_session_add_feature (session, SOUP_SESSION_FEATURE (jar));\n  g_object_unref (jar);\n\n  /* Use GNOME proxy settings through libproxy */\n  soup_session_add_feature_by_type (session, SOUP_TYPE_PROXY_RESOLVER_GNOME);\n\n#ifdef SOUP_TYPE_PASSWORD_MANAGER\n  /* Use GNOME keyring to store passwords. Only add the manager if we\n     are not using a private session, otherwise we want any new\n     password to expire when we exit *and* we don't want to use any\n     existing password in the keyring */\n  if (ephy_has_private_profile () == FALSE)\n    soup_session_add_feature_by_type (session, SOUP_TYPE_PASSWORD_MANAGER_GNOME);\n#endif\n\n  return TRUE;\n}",
        "target": 1
    },
    {
        "func": "static inline void kvm_load_fs(u16 sel)\n{\n\tasm(\"mov %0, %%fs\" : : \"rm\"(sel));\n}",
        "target": 1
    },
    {
        "func": "static inline u16 kvm_read_gs(void)\n{\n\tu16 seg;\n\tasm(\"mov %%gs, %0\" : \"=g\"(seg));\n\treturn seg;\n}",
        "target": 1
    },
    {
        "func": "static void __vmx_load_host_state(struct vcpu_vmx *vmx)\n{\n\tunsigned long flags;\n\n\tif (!vmx->host_state.loaded)\n\t\treturn;\n\n\t++vmx->vcpu.stat.host_state_reload;\n\tvmx->host_state.loaded = 0;\n\tif (vmx->host_state.fs_reload_needed)\n\t\tkvm_load_fs(vmx->host_state.fs_sel);\n\tif (vmx->host_state.gs_ldt_reload_needed) {\n\t\tkvm_load_ldt(vmx->host_state.ldt_sel);\n\t\t/*\n\t\t * If we have to reload gs, we must take care to\n\t\t * preserve our gs base.\n\t\t */\n\t\tlocal_irq_save(flags);\n\t\tkvm_load_gs(vmx->host_state.gs_sel);\n#ifdef CONFIG_X86_64\n\t\twrmsrl(MSR_GS_BASE, vmcs_readl(HOST_GS_BASE));\n#endif\n\t\tlocal_irq_restore(flags);\n\t}\n\treload_tss();\n#ifdef CONFIG_X86_64\n\tif (is_long_mode(&vmx->vcpu)) {\n\t\trdmsrl(MSR_KERNEL_GS_BASE, vmx->msr_guest_kernel_gs_base);\n\t\twrmsrl(MSR_KERNEL_GS_BASE, vmx->msr_host_kernel_gs_base);\n\t}\n#endif\n\tif (current_thread_info()->status & TS_USEDFPU)\n\t\tclts();\n\tload_gdt(&__get_cpu_var(host_gdt));\n}",
        "target": 1
    },
    {
        "func": "static int vmx_vcpu_setup(struct vcpu_vmx *vmx)\n{\n\tu32 host_sysenter_cs, msr_low, msr_high;\n\tu32 junk;\n\tu64 host_pat, tsc_this, tsc_base;\n\tunsigned long a;\n\tstruct desc_ptr dt;\n\tint i;\n\tunsigned long kvm_vmx_return;\n\tu32 exec_control;\n\n\t/* I/O */\n\tvmcs_write64(IO_BITMAP_A, __pa(vmx_io_bitmap_a));\n\tvmcs_write64(IO_BITMAP_B, __pa(vmx_io_bitmap_b));\n\n\tif (cpu_has_vmx_msr_bitmap())\n\t\tvmcs_write64(MSR_BITMAP, __pa(vmx_msr_bitmap_legacy));\n\n\tvmcs_write64(VMCS_LINK_POINTER, -1ull); /* 22.3.1.5 */\n\n\t/* Control */\n\tvmcs_write32(PIN_BASED_VM_EXEC_CONTROL,\n\t\tvmcs_config.pin_based_exec_ctrl);\n\n\texec_control = vmcs_config.cpu_based_exec_ctrl;\n\tif (!vm_need_tpr_shadow(vmx->vcpu.kvm)) {\n\t\texec_control &= ~CPU_BASED_TPR_SHADOW;\n#ifdef CONFIG_X86_64\n\t\texec_control |= CPU_BASED_CR8_STORE_EXITING |\n\t\t\t\tCPU_BASED_CR8_LOAD_EXITING;\n#endif\n\t}\n\tif (!enable_ept)\n\t\texec_control |= CPU_BASED_CR3_STORE_EXITING |\n\t\t\t\tCPU_BASED_CR3_LOAD_EXITING  |\n\t\t\t\tCPU_BASED_INVLPG_EXITING;\n\tvmcs_write32(CPU_BASED_VM_EXEC_CONTROL, exec_control);\n\n\tif (cpu_has_secondary_exec_ctrls()) {\n\t\texec_control = vmcs_config.cpu_based_2nd_exec_ctrl;\n\t\tif (!vm_need_virtualize_apic_accesses(vmx->vcpu.kvm))\n\t\t\texec_control &=\n\t\t\t\t~SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;\n\t\tif (vmx->vpid == 0)\n\t\t\texec_control &= ~SECONDARY_EXEC_ENABLE_VPID;\n\t\tif (!enable_ept) {\n\t\t\texec_control &= ~SECONDARY_EXEC_ENABLE_EPT;\n\t\t\tenable_unrestricted_guest = 0;\n\t\t}\n\t\tif (!enable_unrestricted_guest)\n\t\t\texec_control &= ~SECONDARY_EXEC_UNRESTRICTED_GUEST;\n\t\tif (!ple_gap)\n\t\t\texec_control &= ~SECONDARY_EXEC_PAUSE_LOOP_EXITING;\n\t\tvmcs_write32(SECONDARY_VM_EXEC_CONTROL, exec_control);\n\t}\n\n\tif (ple_gap) {\n\t\tvmcs_write32(PLE_GAP, ple_gap);\n\t\tvmcs_write32(PLE_WINDOW, ple_window);\n\t}\n\n\tvmcs_write32(PAGE_FAULT_ERROR_CODE_MASK, !!bypass_guest_pf);\n\tvmcs_write32(PAGE_FAULT_ERROR_CODE_MATCH, !!bypass_guest_pf);\n\tvmcs_write32(CR3_TARGET_COUNT, 0);           /* 22.2.1 */\n\n\tvmcs_writel(HOST_CR0, read_cr0() | X86_CR0_TS);  /* 22.2.3 */\n\tvmcs_writel(HOST_CR4, read_cr4());  /* 22.2.3, 22.2.5 */\n\tvmcs_writel(HOST_CR3, read_cr3());  /* 22.2.3  FIXME: shadow tables */\n\n\tvmcs_write16(HOST_CS_SELECTOR, __KERNEL_CS);  /* 22.2.4 */\n\tvmcs_write16(HOST_DS_SELECTOR, __KERNEL_DS);  /* 22.2.4 */\n\tvmcs_write16(HOST_ES_SELECTOR, __KERNEL_DS);  /* 22.2.4 */\n\tvmcs_write16(HOST_FS_SELECTOR, kvm_read_fs());    /* 22.2.4 */\n\tvmcs_write16(HOST_GS_SELECTOR, kvm_read_gs());    /* 22.2.4 */\n\tvmcs_write16(HOST_SS_SELECTOR, __KERNEL_DS);  /* 22.2.4 */\n#ifdef CONFIG_X86_64\n\trdmsrl(MSR_FS_BASE, a);\n\tvmcs_writel(HOST_FS_BASE, a); /* 22.2.4 */\n\trdmsrl(MSR_GS_BASE, a);\n\tvmcs_writel(HOST_GS_BASE, a); /* 22.2.4 */\n#else\n\tvmcs_writel(HOST_FS_BASE, 0); /* 22.2.4 */\n\tvmcs_writel(HOST_GS_BASE, 0); /* 22.2.4 */\n#endif\n\n\tvmcs_write16(HOST_TR_SELECTOR, GDT_ENTRY_TSS*8);  /* 22.2.4 */\n\n\tnative_store_idt(&dt);\n\tvmcs_writel(HOST_IDTR_BASE, dt.address);   /* 22.2.4 */\n\n\tasm(\"mov $.Lkvm_vmx_return, %0\" : \"=r\"(kvm_vmx_return));\n\tvmcs_writel(HOST_RIP, kvm_vmx_return); /* 22.2.5 */\n\tvmcs_write32(VM_EXIT_MSR_STORE_COUNT, 0);\n\tvmcs_write32(VM_EXIT_MSR_LOAD_COUNT, 0);\n\tvmcs_write64(VM_EXIT_MSR_LOAD_ADDR, __pa(vmx->msr_autoload.host));\n\tvmcs_write32(VM_ENTRY_MSR_LOAD_COUNT, 0);\n\tvmcs_write64(VM_ENTRY_MSR_LOAD_ADDR, __pa(vmx->msr_autoload.guest));\n\n\trdmsr(MSR_IA32_SYSENTER_CS, host_sysenter_cs, junk);\n\tvmcs_write32(HOST_IA32_SYSENTER_CS, host_sysenter_cs);\n\trdmsrl(MSR_IA32_SYSENTER_ESP, a);\n\tvmcs_writel(HOST_IA32_SYSENTER_ESP, a);   /* 22.2.3 */\n\trdmsrl(MSR_IA32_SYSENTER_EIP, a);\n\tvmcs_writel(HOST_IA32_SYSENTER_EIP, a);   /* 22.2.3 */\n\n\tif (vmcs_config.vmexit_ctrl & VM_EXIT_LOAD_IA32_PAT) {\n\t\trdmsr(MSR_IA32_CR_PAT, msr_low, msr_high);\n\t\thost_pat = msr_low | ((u64) msr_high << 32);\n\t\tvmcs_write64(HOST_IA32_PAT, host_pat);\n\t}\n\tif (vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_PAT) {\n\t\trdmsr(MSR_IA32_CR_PAT, msr_low, msr_high);\n\t\thost_pat = msr_low | ((u64) msr_high << 32);\n\t\t/* Write the default value follow host pat */\n\t\tvmcs_write64(GUEST_IA32_PAT, host_pat);\n\t\t/* Keep arch.pat sync with GUEST_IA32_PAT */\n\t\tvmx->vcpu.arch.pat = host_pat;\n\t}\n\n\tfor (i = 0; i < NR_VMX_MSR; ++i) {\n\t\tu32 index = vmx_msr_index[i];\n\t\tu32 data_low, data_high;\n\t\tint j = vmx->nmsrs;\n\n\t\tif (rdmsr_safe(index, &data_low, &data_high) < 0)\n\t\t\tcontinue;\n\t\tif (wrmsr_safe(index, data_low, data_high) < 0)\n\t\t\tcontinue;\n\t\tvmx->guest_msrs[j].index = i;\n\t\tvmx->guest_msrs[j].data = 0;\n\t\tvmx->guest_msrs[j].mask = -1ull;\n\t\t++vmx->nmsrs;\n\t}\n\n\tvmcs_write32(VM_EXIT_CONTROLS, vmcs_config.vmexit_ctrl);\n\n\t/* 22.2.1, 20.8.1 */\n\tvmcs_write32(VM_ENTRY_CONTROLS, vmcs_config.vmentry_ctrl);\n\n\tvmcs_writel(CR0_GUEST_HOST_MASK, ~0UL);\n\tvmx->vcpu.arch.cr4_guest_owned_bits = KVM_CR4_GUEST_OWNED_BITS;\n\tif (enable_ept)\n\t\tvmx->vcpu.arch.cr4_guest_owned_bits |= X86_CR4_PGE;\n\tvmcs_writel(CR4_GUEST_HOST_MASK, ~vmx->vcpu.arch.cr4_guest_owned_bits);\n\n\ttsc_base = vmx->vcpu.kvm->arch.vm_init_tsc;\n\trdtscll(tsc_this);\n\tif (tsc_this < vmx->vcpu.kvm->arch.vm_init_tsc)\n\t\ttsc_base = tsc_this;\n\n\tguest_write_tsc(0, tsc_base);\n\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static void vmx_save_host_state(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tint i;\n\n\tif (vmx->host_state.loaded)\n\t\treturn;\n\n\tvmx->host_state.loaded = 1;\n\t/*\n\t * Set host fs and gs selectors.  Unfortunately, 22.2.3 does not\n\t * allow segment selectors with cpl > 0 or ti == 1.\n\t */\n\tvmx->host_state.ldt_sel = kvm_read_ldt();\n\tvmx->host_state.gs_ldt_reload_needed = vmx->host_state.ldt_sel;\n\tvmx->host_state.fs_sel = kvm_read_fs();\n\tif (!(vmx->host_state.fs_sel & 7)) {\n\t\tvmcs_write16(HOST_FS_SELECTOR, vmx->host_state.fs_sel);\n\t\tvmx->host_state.fs_reload_needed = 0;\n\t} else {\n\t\tvmcs_write16(HOST_FS_SELECTOR, 0);\n\t\tvmx->host_state.fs_reload_needed = 1;\n\t}\n\tvmx->host_state.gs_sel = kvm_read_gs();\n\tif (!(vmx->host_state.gs_sel & 7))\n\t\tvmcs_write16(HOST_GS_SELECTOR, vmx->host_state.gs_sel);\n\telse {\n\t\tvmcs_write16(HOST_GS_SELECTOR, 0);\n\t\tvmx->host_state.gs_ldt_reload_needed = 1;\n\t}\n\n#ifdef CONFIG_X86_64\n\tvmcs_writel(HOST_FS_BASE, read_msr(MSR_FS_BASE));\n\tvmcs_writel(HOST_GS_BASE, read_msr(MSR_GS_BASE));\n#else\n\tvmcs_writel(HOST_FS_BASE, segment_base(vmx->host_state.fs_sel));\n\tvmcs_writel(HOST_GS_BASE, segment_base(vmx->host_state.gs_sel));\n#endif\n\n#ifdef CONFIG_X86_64\n\tif (is_long_mode(&vmx->vcpu)) {\n\t\trdmsrl(MSR_KERNEL_GS_BASE, vmx->msr_host_kernel_gs_base);\n\t\twrmsrl(MSR_KERNEL_GS_BASE, vmx->msr_guest_kernel_gs_base);\n\t}\n#endif\n\tfor (i = 0; i < vmx->save_nmsrs; ++i)\n\t\tkvm_set_shared_msr(vmx->guest_msrs[i].index,\n\t\t\t\t   vmx->guest_msrs[i].data,\n\t\t\t\t   vmx->guest_msrs[i].mask);\n}",
        "target": 1
    },
    {
        "func": "static inline u16 kvm_read_fs(void)\n{\n\tu16 seg;\n\tasm(\"mov %%fs, %0\" : \"=g\"(seg));\n\treturn seg;\n}",
        "target": 1
    },
    {
        "func": "static void svm_vcpu_run(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu16 fs_selector;\n\tu16 gs_selector;\n\tu16 ldt_selector;\n\n\tsvm->vmcb->save.rax = vcpu->arch.regs[VCPU_REGS_RAX];\n\tsvm->vmcb->save.rsp = vcpu->arch.regs[VCPU_REGS_RSP];\n\tsvm->vmcb->save.rip = vcpu->arch.regs[VCPU_REGS_RIP];\n\n\t/*\n\t * A vmexit emulation is required before the vcpu can be executed\n\t * again.\n\t */\n\tif (unlikely(svm->nested.exit_required))\n\t\treturn;\n\n\tpre_svm_run(svm);\n\n\tsync_lapic_to_cr8(vcpu);\n\n\tsave_host_msrs(vcpu);\n\tfs_selector = kvm_read_fs();\n\tgs_selector = kvm_read_gs();\n\tldt_selector = kvm_read_ldt();\n\tsvm->vmcb->save.cr2 = vcpu->arch.cr2;\n\t/* required for live migration with NPT */\n\tif (npt_enabled)\n\t\tsvm->vmcb->save.cr3 = vcpu->arch.cr3;\n\n\tclgi();\n\n\tlocal_irq_enable();\n\n\tasm volatile (\n\t\t\"push %%\"R\"bp; \\n\\t\"\n\t\t\"mov %c[rbx](%[svm]), %%\"R\"bx \\n\\t\"\n\t\t\"mov %c[rcx](%[svm]), %%\"R\"cx \\n\\t\"\n\t\t\"mov %c[rdx](%[svm]), %%\"R\"dx \\n\\t\"\n\t\t\"mov %c[rsi](%[svm]), %%\"R\"si \\n\\t\"\n\t\t\"mov %c[rdi](%[svm]), %%\"R\"di \\n\\t\"\n\t\t\"mov %c[rbp](%[svm]), %%\"R\"bp \\n\\t\"\n#ifdef CONFIG_X86_64\n\t\t\"mov %c[r8](%[svm]),  %%r8  \\n\\t\"\n\t\t\"mov %c[r9](%[svm]),  %%r9  \\n\\t\"\n\t\t\"mov %c[r10](%[svm]), %%r10 \\n\\t\"\n\t\t\"mov %c[r11](%[svm]), %%r11 \\n\\t\"\n\t\t\"mov %c[r12](%[svm]), %%r12 \\n\\t\"\n\t\t\"mov %c[r13](%[svm]), %%r13 \\n\\t\"\n\t\t\"mov %c[r14](%[svm]), %%r14 \\n\\t\"\n\t\t\"mov %c[r15](%[svm]), %%r15 \\n\\t\"\n#endif\n\n\t\t/* Enter guest mode */\n\t\t\"push %%\"R\"ax \\n\\t\"\n\t\t\"mov %c[vmcb](%[svm]), %%\"R\"ax \\n\\t\"\n\t\t__ex(SVM_VMLOAD) \"\\n\\t\"\n\t\t__ex(SVM_VMRUN) \"\\n\\t\"\n\t\t__ex(SVM_VMSAVE) \"\\n\\t\"\n\t\t\"pop %%\"R\"ax \\n\\t\"\n\n\t\t/* Save guest registers, load host registers */\n\t\t\"mov %%\"R\"bx, %c[rbx](%[svm]) \\n\\t\"\n\t\t\"mov %%\"R\"cx, %c[rcx](%[svm]) \\n\\t\"\n\t\t\"mov %%\"R\"dx, %c[rdx](%[svm]) \\n\\t\"\n\t\t\"mov %%\"R\"si, %c[rsi](%[svm]) \\n\\t\"\n\t\t\"mov %%\"R\"di, %c[rdi](%[svm]) \\n\\t\"\n\t\t\"mov %%\"R\"bp, %c[rbp](%[svm]) \\n\\t\"\n#ifdef CONFIG_X86_64\n\t\t\"mov %%r8,  %c[r8](%[svm]) \\n\\t\"\n\t\t\"mov %%r9,  %c[r9](%[svm]) \\n\\t\"\n\t\t\"mov %%r10, %c[r10](%[svm]) \\n\\t\"\n\t\t\"mov %%r11, %c[r11](%[svm]) \\n\\t\"\n\t\t\"mov %%r12, %c[r12](%[svm]) \\n\\t\"\n\t\t\"mov %%r13, %c[r13](%[svm]) \\n\\t\"\n\t\t\"mov %%r14, %c[r14](%[svm]) \\n\\t\"\n\t\t\"mov %%r15, %c[r15](%[svm]) \\n\\t\"\n#endif\n\t\t\"pop %%\"R\"bp\"\n\t\t:\n\t\t: [svm]\"a\"(svm),\n\t\t  [vmcb]\"i\"(offsetof(struct vcpu_svm, vmcb_pa)),\n\t\t  [rbx]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_RBX])),\n\t\t  [rcx]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_RCX])),\n\t\t  [rdx]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_RDX])),\n\t\t  [rsi]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_RSI])),\n\t\t  [rdi]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_RDI])),\n\t\t  [rbp]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_RBP]))\n#ifdef CONFIG_X86_64\n\t\t  , [r8]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R8])),\n\t\t  [r9]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R9])),\n\t\t  [r10]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R10])),\n\t\t  [r11]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R11])),\n\t\t  [r12]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R12])),\n\t\t  [r13]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R13])),\n\t\t  [r14]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R14])),\n\t\t  [r15]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R15]))\n#endif\n\t\t: \"cc\", \"memory\"\n\t\t, R\"bx\", R\"cx\", R\"dx\", R\"si\", R\"di\"\n#ifdef CONFIG_X86_64\n\t\t, \"r8\", \"r9\", \"r10\", \"r11\" , \"r12\", \"r13\", \"r14\", \"r15\"\n#endif\n\t\t);\n\n\tvcpu->arch.cr2 = svm->vmcb->save.cr2;\n\tvcpu->arch.regs[VCPU_REGS_RAX] = svm->vmcb->save.rax;\n\tvcpu->arch.regs[VCPU_REGS_RSP] = svm->vmcb->save.rsp;\n\tvcpu->arch.regs[VCPU_REGS_RIP] = svm->vmcb->save.rip;\n\n\tkvm_load_fs(fs_selector);\n\tkvm_load_gs(gs_selector);\n\tkvm_load_ldt(ldt_selector);\n\tload_host_msrs(vcpu);\n\n\treload_tss(vcpu);\n\n\tlocal_irq_disable();\n\n\tstgi();\n\n\tsync_cr8_to_lapic(vcpu);\n\n\tsvm->next_rip = 0;\n\n\tif (npt_enabled) {\n\t\tvcpu->arch.regs_avail &= ~(1 << VCPU_EXREG_PDPTR);\n\t\tvcpu->arch.regs_dirty &= ~(1 << VCPU_EXREG_PDPTR);\n\t}\n\n\t/*\n\t * We need to handle MC intercepts here before the vcpu has a chance to\n\t * change the physical cpu\n\t */\n\tif (unlikely(svm->vmcb->control.exit_code ==\n\t\t     SVM_EXIT_EXCP_BASE + MC_VECTOR))\n\t\tsvm_handle_mce(svm);\n}",
        "target": 1
    },
    {
        "func": "static inline void kvm_load_gs(u16 sel)\n{\n\tasm(\"mov %0, %%gs\" : : \"rm\"(sel));\n}",
        "target": 1
    },
    {
        "func": " */\nxmlNodePtr\nxmlXPathNextFollowing(xmlXPathParserContextPtr ctxt, xmlNodePtr cur) {\n    if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);\n    if (cur != NULL && cur->children != NULL)\n        return cur->children ;\n    if (cur == NULL) cur = ctxt->context->node;\n    if (cur == NULL) return(NULL) ; /* ERROR */\n    if (cur->next != NULL) return(cur->next) ;\n    do {\n        cur = cur->parent;\n        if (cur == NULL) break;\n        if (cur == (xmlNodePtr) ctxt->context->doc) return(NULL);\n        if (cur->next != NULL) return(cur->next);\n    } while (cur != NULL);",
        "target": 1
    },
    {
        "func": " */\nstatic xmlNodePtr\nxmlXPathNextPrecedingInternal(xmlXPathParserContextPtr ctxt,\n                              xmlNodePtr cur)\n{\n    if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);\n    if (cur == NULL) {\n        cur = ctxt->context->node;\n        if (cur == NULL)\n            return (NULL);\n\tif (cur->type == XML_NAMESPACE_DECL)\n\t    cur = (xmlNodePtr)((xmlNsPtr)cur)->next;\n        ctxt->ancestor = cur->parent;\n    }\n    if ((cur->prev != NULL) && (cur->prev->type == XML_DTD_NODE))\n\tcur = cur->prev;\n    while (cur->prev == NULL) {\n        cur = cur->parent;\n        if (cur == NULL)\n            return (NULL);\n        if (cur == ctxt->context->doc->children)\n            return (NULL);\n        if (cur != ctxt->ancestor)\n            return (cur);\n        ctxt->ancestor = cur->parent;\n    }\n    cur = cur->prev;\n    while (cur->last != NULL)\n        cur = cur->last;",
        "target": 1
    },
    {
        "func": " */\nxmlNodePtr\nxmlXPathNextPreceding(xmlXPathParserContextPtr ctxt, xmlNodePtr cur)\n{\n    if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);\n    if (cur == NULL)\n        cur = ctxt->context->node;\n    if (cur == NULL)\n\treturn (NULL);\n    if ((cur->prev != NULL) && (cur->prev->type == XML_DTD_NODE))\n\tcur = cur->prev;\n    do {\n        if (cur->prev != NULL) {\n            for (cur = cur->prev; cur->last != NULL; cur = cur->last) ;\n            return (cur);\n        }\n\n        cur = cur->parent;\n        if (cur == NULL)\n            return (NULL);\n        if (cur == ctxt->context->doc->children)\n            return (NULL);\n    } while (xmlXPathIsAncestor(cur, ctxt->context->node));",
        "target": 1
    },
    {
        "func": " */\nxmlNodePtr\nxmlXPathNextPreceding(xmlXPathParserContextPtr ctxt, xmlNodePtr cur)\n{\n    if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);\n    if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||\n\t(ctxt->context->node->type == XML_NAMESPACE_DECL))\n\treturn(NULL);\n    if (cur == NULL)\n        cur = ctxt->context->node;\n    if (cur == NULL)\n\treturn (NULL);\n    if ((cur->prev != NULL) && (cur->prev->type == XML_DTD_NODE))\n\tcur = cur->prev;\n    do {\n        if (cur->prev != NULL) {\n            for (cur = cur->prev; cur->last != NULL; cur = cur->last) ;\n            return (cur);\n        }\n\n        cur = cur->parent;\n        if (cur == NULL)\n            return (NULL);\n        if (cur == ctxt->context->doc->children)\n            return (NULL);\n    } while (xmlXPathIsAncestor(cur, ctxt->context->node));",
        "target": 1
    },
    {
        "func": " */\nstatic xmlNodePtr\nxmlXPathNextPrecedingInternal(xmlXPathParserContextPtr ctxt,\n                              xmlNodePtr cur)\n{\n    if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);\n    if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||\n\t(ctxt->context->node->type == XML_NAMESPACE_DECL))\n\treturn(NULL);\n    if (cur == NULL) {\n        cur = ctxt->context->node;\n        if (cur == NULL)\n            return (NULL);\n        ctxt->ancestor = cur->parent;\n    }\n    if ((cur->prev != NULL) && (cur->prev->type == XML_DTD_NODE))\n\tcur = cur->prev;\n    while (cur->prev == NULL) {\n        cur = cur->parent;\n        if (cur == NULL)\n            return (NULL);\n        if (cur == ctxt->context->doc->children)\n            return (NULL);\n        if (cur != ctxt->ancestor)\n            return (cur);\n        ctxt->ancestor = cur->parent;\n    }\n    cur = cur->prev;\n    while (cur->last != NULL)\n        cur = cur->last;",
        "target": 1
    },
    {
        "func": " */\nxmlNodePtr\nxmlXPathNextFollowing(xmlXPathParserContextPtr ctxt, xmlNodePtr cur) {\n    if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);\n    if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||\n\t(ctxt->context->node->type == XML_NAMESPACE_DECL))\n\treturn(NULL);\n    if (cur != NULL) {\n        if ((cur->type == XML_ATTRIBUTE_NODE) ||\n            (cur->type == XML_NAMESPACE_DECL))\n            return(NULL);\n        if (cur->children != NULL)\n            return cur->children ;\n    }\n    if (cur == NULL) cur = ctxt->context->node;\n    if (cur == NULL) return(NULL) ; /* ERROR */\n    if (cur->next != NULL) return(cur->next) ;\n    do {\n        cur = cur->parent;\n        if (cur == NULL) break;\n        if (cur == (xmlNodePtr) ctxt->context->doc) return(NULL);\n        if (cur->next != NULL) return(cur->next);\n    } while (cur != NULL);",
        "target": 1
    },
    {
        "func": "static int packet_getname_spkt(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t       int *uaddr_len, int peer)\n{\n\tstruct net_device *dev;\n\tstruct sock *sk\t= sock->sk;\n\n\tif (peer)\n\t\treturn -EOPNOTSUPP;\n\n\tuaddr->sa_family = AF_PACKET;\n\trcu_read_lock();\n\tdev = dev_get_by_index_rcu(sock_net(sk), pkt_sk(sk)->ifindex);\n\tif (dev)\n\t\tstrlcpy(uaddr->sa_data, dev->name, 15);\n\telse\n\t\tmemset(uaddr->sa_data, 0, 14);\n\trcu_read_unlock();\n\t*uaddr_len = sizeof(*uaddr);\n\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static int packet_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t  int *uaddr_len, int peer)\n{\n\tstruct net_device *dev;\n\tstruct sock *sk = sock->sk;\n\tstruct packet_sock *po = pkt_sk(sk);\n\tDECLARE_SOCKADDR(struct sockaddr_ll *, sll, uaddr);\n\n\tif (peer)\n\t\treturn -EOPNOTSUPP;\n\n\tsll->sll_family = AF_PACKET;\n\tsll->sll_ifindex = po->ifindex;\n\tsll->sll_protocol = po->num;\n\trcu_read_lock();\n\tdev = dev_get_by_index_rcu(sock_net(sk), po->ifindex);\n\tif (dev) {\n\t\tsll->sll_hatype = dev->type;\n\t\tsll->sll_halen = dev->addr_len;\n\t\tmemcpy(sll->sll_addr, dev->dev_addr, dev->addr_len);\n\t} else {\n\t\tsll->sll_hatype = 0;\t/* Bad: we have no ARPHRD_UNSPEC */\n\t\tsll->sll_halen = 0;\n\t}\n\trcu_read_unlock();\n\t*uaddr_len = offsetof(struct sockaddr_ll, sll_addr) + sll->sll_halen;\n\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static void kvm_vcpu_ioctl_x86_get_vcpu_events(struct kvm_vcpu *vcpu,\n\t\t\t\t\t       struct kvm_vcpu_events *events)\n{\n\tevents->exception.injected =\n\t\tvcpu->arch.exception.pending &&\n\t\t!kvm_exception_is_soft(vcpu->arch.exception.nr);\n\tevents->exception.nr = vcpu->arch.exception.nr;\n\tevents->exception.has_error_code = vcpu->arch.exception.has_error_code;\n\tevents->exception.error_code = vcpu->arch.exception.error_code;\n\n\tevents->interrupt.injected =\n\t\tvcpu->arch.interrupt.pending && !vcpu->arch.interrupt.soft;\n\tevents->interrupt.nr = vcpu->arch.interrupt.nr;\n\tevents->interrupt.soft = 0;\n\tevents->interrupt.shadow =\n\t\tkvm_x86_ops->get_interrupt_shadow(vcpu,\n\t\t\tKVM_X86_SHADOW_INT_MOV_SS | KVM_X86_SHADOW_INT_STI);\n\n\tevents->nmi.injected = vcpu->arch.nmi_injected;\n\tevents->nmi.pending = vcpu->arch.nmi_pending;\n\tevents->nmi.masked = kvm_x86_ops->get_nmi_mask(vcpu);\n\n\tevents->sipi_vector = vcpu->arch.sipi_vector;\n\n\tevents->flags = (KVM_VCPUEVENT_VALID_NMI_PENDING\n\t\t\t | KVM_VCPUEVENT_VALID_SIPI_VECTOR\n\t\t\t | KVM_VCPUEVENT_VALID_SHADOW);\n}",
        "target": 1
    },
    {
        "func": "static int kvm_vm_ioctl_get_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)\n{\n\tint r = 0;\n\n\tmutex_lock(&kvm->arch.vpit->pit_state.lock);\n\tmemcpy(ps->channels, &kvm->arch.vpit->pit_state.channels,\n\t\tsizeof(ps->channels));\n\tps->flags = kvm->arch.vpit->pit_state.flags;\n\tmutex_unlock(&kvm->arch.vpit->pit_state.lock);\n\treturn r;\n}",
        "target": 1
    },
    {
        "func": "static void kvm_vcpu_ioctl_x86_get_debugregs(struct kvm_vcpu *vcpu,\n\t\t\t\t\t     struct kvm_debugregs *dbgregs)\n{\n\tmemcpy(dbgregs->db, vcpu->arch.db, sizeof(vcpu->arch.db));\n\tdbgregs->dr6 = vcpu->arch.dr6;\n\tdbgregs->dr7 = vcpu->arch.dr7;\n\tdbgregs->flags = 0;\n}",
        "target": 1
    },
    {
        "func": "long kvm_arch_vm_ioctl(struct file *filp,\n\t\t       unsigned int ioctl, unsigned long arg)\n{\n\tstruct kvm *kvm = filp->private_data;\n\tvoid __user *argp = (void __user *)arg;\n\tint r = -ENOTTY;\n\t/*\n\t * This union makes it completely explicit to gcc-3.x\n\t * that these two variables' stack usage should be\n\t * combined, not added together.\n\t */\n\tunion {\n\t\tstruct kvm_pit_state ps;\n\t\tstruct kvm_pit_state2 ps2;\n\t\tstruct kvm_pit_config pit_config;\n\t} u;\n\n\tswitch (ioctl) {\n\tcase KVM_SET_TSS_ADDR:\n\t\tr = kvm_vm_ioctl_set_tss_addr(kvm, arg);\n\t\tif (r < 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KVM_SET_IDENTITY_MAP_ADDR: {\n\t\tu64 ident_addr;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&ident_addr, argp, sizeof ident_addr))\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_set_identity_map_addr(kvm, ident_addr);\n\t\tif (r < 0)\n\t\t\tgoto out;\n\t\tbreak;\n\t}\n\tcase KVM_SET_NR_MMU_PAGES:\n\t\tr = kvm_vm_ioctl_set_nr_mmu_pages(kvm, arg);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KVM_GET_NR_MMU_PAGES:\n\t\tr = kvm_vm_ioctl_get_nr_mmu_pages(kvm);\n\t\tbreak;\n\tcase KVM_CREATE_IRQCHIP: {\n\t\tstruct kvm_pic *vpic;\n\n\t\tmutex_lock(&kvm->lock);\n\t\tr = -EEXIST;\n\t\tif (kvm->arch.vpic)\n\t\t\tgoto create_irqchip_unlock;\n\t\tr = -ENOMEM;\n\t\tvpic = kvm_create_pic(kvm);\n\t\tif (vpic) {\n\t\t\tr = kvm_ioapic_init(kvm);\n\t\t\tif (r) {\n\t\t\t\tkvm_io_bus_unregister_dev(kvm, KVM_PIO_BUS,\n\t\t\t\t\t\t\t  &vpic->dev);\n\t\t\t\tkfree(vpic);\n\t\t\t\tgoto create_irqchip_unlock;\n\t\t\t}\n\t\t} else\n\t\t\tgoto create_irqchip_unlock;\n\t\tsmp_wmb();\n\t\tkvm->arch.vpic = vpic;\n\t\tsmp_wmb();\n\t\tr = kvm_setup_default_irq_routing(kvm);\n\t\tif (r) {\n\t\t\tmutex_lock(&kvm->irq_lock);\n\t\t\tkvm_ioapic_destroy(kvm);\n\t\t\tkvm_destroy_pic(kvm);\n\t\t\tmutex_unlock(&kvm->irq_lock);\n\t\t}\n\tcreate_irqchip_unlock:\n\t\tmutex_unlock(&kvm->lock);\n\t\tbreak;\n\t}\n\tcase KVM_CREATE_PIT:\n\t\tu.pit_config.flags = KVM_PIT_SPEAKER_DUMMY;\n\t\tgoto create_pit;\n\tcase KVM_CREATE_PIT2:\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&u.pit_config, argp,\n\t\t\t\t   sizeof(struct kvm_pit_config)))\n\t\t\tgoto out;\n\tcreate_pit:\n\t\tmutex_lock(&kvm->slots_lock);\n\t\tr = -EEXIST;\n\t\tif (kvm->arch.vpit)\n\t\t\tgoto create_pit_unlock;\n\t\tr = -ENOMEM;\n\t\tkvm->arch.vpit = kvm_create_pit(kvm, u.pit_config.flags);\n\t\tif (kvm->arch.vpit)\n\t\t\tr = 0;\n\tcreate_pit_unlock:\n\t\tmutex_unlock(&kvm->slots_lock);\n\t\tbreak;\n\tcase KVM_IRQ_LINE_STATUS:\n\tcase KVM_IRQ_LINE: {\n\t\tstruct kvm_irq_level irq_event;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&irq_event, argp, sizeof irq_event))\n\t\t\tgoto out;\n\t\tr = -ENXIO;\n\t\tif (irqchip_in_kernel(kvm)) {\n\t\t\t__s32 status;\n\t\t\tstatus = kvm_set_irq(kvm, KVM_USERSPACE_IRQ_SOURCE_ID,\n\t\t\t\t\tirq_event.irq, irq_event.level);\n\t\t\tif (ioctl == KVM_IRQ_LINE_STATUS) {\n\t\t\t\tr = -EFAULT;\n\t\t\t\tirq_event.status = status;\n\t\t\t\tif (copy_to_user(argp, &irq_event,\n\t\t\t\t\t\t\tsizeof irq_event))\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tr = 0;\n\t\t}\n\t\tbreak;\n\t}\n\tcase KVM_GET_IRQCHIP: {\n\t\t/* 0: PIC master, 1: PIC slave, 2: IOAPIC */\n\t\tstruct kvm_irqchip *chip = kmalloc(sizeof(*chip), GFP_KERNEL);\n\n\t\tr = -ENOMEM;\n\t\tif (!chip)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(chip, argp, sizeof *chip))\n\t\t\tgoto get_irqchip_out;\n\t\tr = -ENXIO;\n\t\tif (!irqchip_in_kernel(kvm))\n\t\t\tgoto get_irqchip_out;\n\t\tr = kvm_vm_ioctl_get_irqchip(kvm, chip);\n\t\tif (r)\n\t\t\tgoto get_irqchip_out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, chip, sizeof *chip))\n\t\t\tgoto get_irqchip_out;\n\t\tr = 0;\n\tget_irqchip_out:\n\t\tkfree(chip);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tbreak;\n\t}\n\tcase KVM_SET_IRQCHIP: {\n\t\t/* 0: PIC master, 1: PIC slave, 2: IOAPIC */\n\t\tstruct kvm_irqchip *chip = kmalloc(sizeof(*chip), GFP_KERNEL);\n\n\t\tr = -ENOMEM;\n\t\tif (!chip)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(chip, argp, sizeof *chip))\n\t\t\tgoto set_irqchip_out;\n\t\tr = -ENXIO;\n\t\tif (!irqchip_in_kernel(kvm))\n\t\t\tgoto set_irqchip_out;\n\t\tr = kvm_vm_ioctl_set_irqchip(kvm, chip);\n\t\tif (r)\n\t\t\tgoto set_irqchip_out;\n\t\tr = 0;\n\tset_irqchip_out:\n\t\tkfree(chip);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tbreak;\n\t}\n\tcase KVM_GET_PIT: {\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&u.ps, argp, sizeof(struct kvm_pit_state)))\n\t\t\tgoto out;\n\t\tr = -ENXIO;\n\t\tif (!kvm->arch.vpit)\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_get_pit(kvm, &u.ps);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &u.ps, sizeof(struct kvm_pit_state)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_PIT: {\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&u.ps, argp, sizeof u.ps))\n\t\t\tgoto out;\n\t\tr = -ENXIO;\n\t\tif (!kvm->arch.vpit)\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_set_pit(kvm, &u.ps);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_GET_PIT2: {\n\t\tr = -ENXIO;\n\t\tif (!kvm->arch.vpit)\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_get_pit2(kvm, &u.ps2);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &u.ps2, sizeof(u.ps2)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_PIT2: {\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&u.ps2, argp, sizeof(u.ps2)))\n\t\t\tgoto out;\n\t\tr = -ENXIO;\n\t\tif (!kvm->arch.vpit)\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_set_pit2(kvm, &u.ps2);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_REINJECT_CONTROL: {\n\t\tstruct kvm_reinject_control control;\n\t\tr =  -EFAULT;\n\t\tif (copy_from_user(&control, argp, sizeof(control)))\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_reinject(kvm, &control);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_XEN_HVM_CONFIG: {\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&kvm->arch.xen_hvm_config, argp,\n\t\t\t\t   sizeof(struct kvm_xen_hvm_config)))\n\t\t\tgoto out;\n\t\tr = -EINVAL;\n\t\tif (kvm->arch.xen_hvm_config.flags)\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_CLOCK: {\n\t\tstruct kvm_clock_data user_ns;\n\t\tu64 now_ns;\n\t\ts64 delta;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&user_ns, argp, sizeof(user_ns)))\n\t\t\tgoto out;\n\n\t\tr = -EINVAL;\n\t\tif (user_ns.flags)\n\t\t\tgoto out;\n\n\t\tr = 0;\n\t\tlocal_irq_disable();\n\t\tnow_ns = get_kernel_ns();\n\t\tdelta = user_ns.clock - now_ns;\n\t\tlocal_irq_enable();\n\t\tkvm->arch.kvmclock_offset = delta;\n\t\tbreak;\n\t}\n\tcase KVM_GET_CLOCK: {\n\t\tstruct kvm_clock_data user_ns;\n\t\tu64 now_ns;\n\n\t\tlocal_irq_disable();\n\t\tnow_ns = get_kernel_ns();\n\t\tuser_ns.clock = kvm->arch.kvmclock_offset + now_ns;\n\t\tlocal_irq_enable();\n\t\tuser_ns.flags = 0;\n\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &user_ns, sizeof(user_ns)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\t;\n\t}\nout:\n\treturn r;\n}",
        "target": 1
    },
    {
        "func": "mono_lookup_pinvoke_call (MonoMethod *method, const char **exc_class, const char **exc_arg)\n{\n\tMonoImage *image = method->klass->image;\n\tMonoMethodPInvoke *piinfo = (MonoMethodPInvoke *)method;\n\tMonoTableInfo *tables = image->tables;\n\tMonoTableInfo *im = &tables [MONO_TABLE_IMPLMAP];\n\tMonoTableInfo *mr = &tables [MONO_TABLE_MODULEREF];\n\tguint32 im_cols [MONO_IMPLMAP_SIZE];\n\tguint32 scope_token;\n\tconst char *import = NULL;\n\tconst char *orig_scope;\n\tconst char *new_scope;\n\tchar *error_msg;\n\tchar *full_name, *file_name;\n\tint i;\n\tMonoDl *module = NULL;\n\n\tg_assert (method->flags & METHOD_ATTRIBUTE_PINVOKE_IMPL);\n\n\tif (piinfo->addr)\n\t\treturn piinfo->addr;\n\n\tif (method->klass->image->dynamic) {\n\t\tMonoReflectionMethodAux *method_aux = \n\t\t\tg_hash_table_lookup (\n\t\t\t\t((MonoDynamicImage*)method->klass->image)->method_aux_hash, method);\n\t\tif (!method_aux)\n\t\t\treturn NULL;\n\n\t\timport = method_aux->dllentry;\n\t\torig_scope = method_aux->dll;\n\t}\n\telse {\n\t\tif (!piinfo->implmap_idx)\n\t\t\treturn NULL;\n\n\t\tmono_metadata_decode_row (im, piinfo->implmap_idx - 1, im_cols, MONO_IMPLMAP_SIZE);\n\n\t\tpiinfo->piflags = im_cols [MONO_IMPLMAP_FLAGS];\n\t\timport = mono_metadata_string_heap (image, im_cols [MONO_IMPLMAP_NAME]);\n\t\tscope_token = mono_metadata_decode_row_col (mr, im_cols [MONO_IMPLMAP_SCOPE] - 1, MONO_MODULEREF_NAME);\n\t\torig_scope = mono_metadata_string_heap (image, scope_token);\n\t}\n\n\tmono_dllmap_lookup (image, orig_scope, import, &new_scope, &import);\n\n\tmono_trace (G_LOG_LEVEL_INFO, MONO_TRACE_DLLIMPORT,\n\t\t\t\"DllImport attempting to load: '%s'.\", new_scope);\n\n\tif (exc_class) {\n\t\t*exc_class = NULL;\n\t\t*exc_arg = NULL;\n\t}\n\n\t/* we allow a special name to dlopen from the running process namespace */\n\tif (strcmp (new_scope, \"__Internal\") == 0)\n\t\tmodule = mono_dl_open (NULL, MONO_DL_LAZY, &error_msg);\n\n\t/*\n\t * Try loading the module using a variety of names\n\t */\n\tfor (i = 0; i < 4; ++i) {\n\t\tswitch (i) {\n\t\tcase 0:\n\t\t\t/* Try the original name */\n\t\t\tfile_name = g_strdup (new_scope);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t/* Try trimming the .dll extension */\n\t\t\tif (strstr (new_scope, \".dll\") == (new_scope + strlen (new_scope) - 4)) {\n\t\t\t\tfile_name = g_strdup (new_scope);\n\t\t\t\tfile_name [strlen (new_scope) - 4] = '\\0';\n\t\t\t}\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (strstr (new_scope, \"lib\") != new_scope) {\n\t\t\t\tfile_name = g_strdup_printf (\"lib%s\", new_scope);\n\t\t\t}\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tdefault:\n#ifndef TARGET_WIN32\n\t\t\tif (!g_ascii_strcasecmp (\"user32.dll\", new_scope) ||\n\t\t\t    !g_ascii_strcasecmp (\"kernel32.dll\", new_scope) ||\n\t\t\t    !g_ascii_strcasecmp (\"user32\", new_scope) ||\n\t\t\t    !g_ascii_strcasecmp (\"kernel\", new_scope)) {\n\t\t\t\tfile_name = g_strdup (\"libMonoSupportW.so\");\n\t\t\t} else\n#endif\n\t\t\t\t    continue;\n#ifndef TARGET_WIN32\n\t\t\tbreak;\n#endif\n\t\t}\n\n\t\tif (!module) {\n\t\t\tvoid *iter = NULL;\n\t\t\twhile ((full_name = mono_dl_build_path (NULL, file_name, &iter))) {\n\t\t\t\tmono_trace (G_LOG_LEVEL_INFO, MONO_TRACE_DLLIMPORT,\n\t\t\t\t\t\t\"DllImport loading location: '%s'.\", full_name);\n\t\t\t\tmodule = cached_module_load (full_name, MONO_DL_LAZY, &error_msg);\n\t\t\t\tif (!module) {\n\t\t\t\t\tmono_trace (G_LOG_LEVEL_INFO, MONO_TRACE_DLLIMPORT,\n\t\t\t\t\t\t\t\"DllImport error loading library: '%s'.\",\n\t\t\t\t\t\t\terror_msg);\n\t\t\t\t\tg_free (error_msg);\n\t\t\t\t}\n\t\t\t\tg_free (full_name);\n\t\t\t\tif (module)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!module) {\n\t\t\tvoid *iter = NULL;\n\t\t\twhile ((full_name = mono_dl_build_path (\".\", file_name, &iter))) {\n\t\t\t\tmono_trace (G_LOG_LEVEL_INFO, MONO_TRACE_DLLIMPORT,\n\t\t\t\t\t\"DllImport loading library: '%s'.\", full_name);\n\t\t\t\tmodule = cached_module_load (full_name, MONO_DL_LAZY, &error_msg);\n\t\t\t\tif (!module) {\n\t\t\t\t\tmono_trace (G_LOG_LEVEL_INFO, MONO_TRACE_DLLIMPORT,\n\t\t\t\t\t\t\"DllImport error loading library '%s'.\",\n\t\t\t\t\t\terror_msg);\n\t\t\t\t\tg_free (error_msg);\n\t\t\t\t}\n\t\t\t\tg_free (full_name);\n\t\t\t\tif (module)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!module) {\n\t\t\tmono_trace (G_LOG_LEVEL_INFO, MONO_TRACE_DLLIMPORT,\n\t\t\t\t\t\"DllImport loading: '%s'.\", file_name);\n\t\t\tmodule = cached_module_load (file_name, MONO_DL_LAZY, &error_msg);\n\t\t\tif (!module) {\n\t\t\t\tmono_trace (G_LOG_LEVEL_INFO, MONO_TRACE_DLLIMPORT,\n\t\t\t\t\t\t\"DllImport error loading library '%s'.\",\n\t\t\t\t\t\terror_msg);\n\t\t\t}\n\t\t}\n\n\t\tg_free (file_name);\n\n\t\tif (module)\n\t\t\tbreak;\n\t}\n\n\tif (!module) {\n\t\tmono_trace (G_LOG_LEVEL_WARNING, MONO_TRACE_DLLIMPORT,\n\t\t\t\t\"DllImport unable to load library '%s'.\",\n\t\t\t\terror_msg);\n\t\tg_free (error_msg);\n\n\t\tif (exc_class) {\n\t\t\t*exc_class = \"DllNotFoundException\";\n\t\t\t*exc_arg = new_scope;\n\t\t}\n\t\treturn NULL;\n\t}\n\n#ifdef TARGET_WIN32\n\tif (import && import [0] == '#' && isdigit (import [1])) {\n\t\tchar *end;\n\t\tlong id;\n\n\t\tid = strtol (import + 1, &end, 10);\n\t\tif (id > 0 && *end == '\\0')\n\t\t\timport++;\n\t}\n#endif\n\tmono_trace (G_LOG_LEVEL_INFO, MONO_TRACE_DLLIMPORT,\n\t\t\t\t\"Searching for '%s'.\", import);\n\n\tif (piinfo->piflags & PINVOKE_ATTRIBUTE_NO_MANGLE) {\n\t\terror_msg = mono_dl_symbol (module, import, &piinfo->addr); \n\t} else {\n\t\tchar *mangled_name = NULL, *mangled_name2 = NULL;\n\t\tint mangle_charset;\n\t\tint mangle_stdcall;\n\t\tint mangle_param_count;\n#ifdef TARGET_WIN32\n\t\tint param_count;\n#endif\n\n\t\t/*\n\t\t * Search using a variety of mangled names\n\t\t */\n\t\tfor (mangle_charset = 0; mangle_charset <= 1; mangle_charset ++) {\n\t\t\tfor (mangle_stdcall = 0; mangle_stdcall <= 1; mangle_stdcall ++) {\n\t\t\t\tgboolean need_param_count = FALSE;\n#ifdef TARGET_WIN32\n\t\t\t\tif (mangle_stdcall > 0)\n\t\t\t\t\tneed_param_count = TRUE;\n#endif\n\t\t\t\tfor (mangle_param_count = 0; mangle_param_count <= (need_param_count ? 256 : 0); mangle_param_count += 4) {\n\n\t\t\t\t\tif (piinfo->addr)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tmangled_name = (char*)import;\n\t\t\t\t\tswitch (piinfo->piflags & PINVOKE_ATTRIBUTE_CHAR_SET_MASK) {\n\t\t\t\t\tcase PINVOKE_ATTRIBUTE_CHAR_SET_UNICODE:\n\t\t\t\t\t\t/* Try the mangled name first */\n\t\t\t\t\t\tif (mangle_charset == 0)\n\t\t\t\t\t\t\tmangled_name = g_strconcat (import, \"W\", NULL);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PINVOKE_ATTRIBUTE_CHAR_SET_AUTO:\n#ifdef TARGET_WIN32\n\t\t\t\t\t\tif (mangle_charset == 0)\n\t\t\t\t\t\t\tmangled_name = g_strconcat (import, \"W\", NULL);\n#else\n\t\t\t\t\t\t/* Try the mangled name last */\n\t\t\t\t\t\tif (mangle_charset == 1)\n\t\t\t\t\t\t\tmangled_name = g_strconcat (import, \"A\", NULL);\n#endif\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PINVOKE_ATTRIBUTE_CHAR_SET_ANSI:\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t/* Try the mangled name last */\n\t\t\t\t\t\tif (mangle_charset == 1)\n\t\t\t\t\t\t\tmangled_name = g_strconcat (import, \"A\", NULL);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n#ifdef TARGET_WIN32\n\t\t\t\t\tif (mangle_param_count == 0)\n\t\t\t\t\t\tparam_count = mono_method_signature (method)->param_count * sizeof (gpointer);\n\t\t\t\t\telse\n\t\t\t\t\t\t/* Try brute force, since it would be very hard to compute the stack usage correctly */\n\t\t\t\t\t\tparam_count = mangle_param_count;\n\n\t\t\t\t\t/* Try the stdcall mangled name */\n\t\t\t\t\t/* \n\t\t\t\t\t * gcc under windows creates mangled names without the underscore, but MS.NET\n\t\t\t\t\t * doesn't support it, so we doesn't support it either.\n\t\t\t\t\t */\n\t\t\t\t\tif (mangle_stdcall == 1)\n\t\t\t\t\t\tmangled_name2 = g_strdup_printf (\"_%s@%d\", mangled_name, param_count);\n\t\t\t\t\telse\n\t\t\t\t\t\tmangled_name2 = mangled_name;\n#else\n\t\t\t\t\tmangled_name2 = mangled_name;\n#endif\n\n\t\t\t\t\tmono_trace (G_LOG_LEVEL_INFO, MONO_TRACE_DLLIMPORT,\n\t\t\t\t\t\t\t\t\"Probing '%s'.\", mangled_name2);\n\n\t\t\t\t\terror_msg = mono_dl_symbol (module, mangled_name2, &piinfo->addr);\n\n\t\t\t\t\tif (piinfo->addr)\n\t\t\t\t\t\tmono_trace (G_LOG_LEVEL_INFO, MONO_TRACE_DLLIMPORT,\n\t\t\t\t\t\t\t\t\t\"Found as '%s'.\", mangled_name2);\n\n\t\t\t\t\tif (mangled_name != mangled_name2)\n\t\t\t\t\t\tg_free (mangled_name2);\n\t\t\t\t\tif (mangled_name != import)\n\t\t\t\t\t\tg_free (mangled_name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!piinfo->addr) {\n\t\tg_free (error_msg);\n\t\tif (exc_class) {\n\t\t\t*exc_class = \"EntryPointNotFoundException\";\n\t\t\t*exc_arg = import;\n\t\t}\n\t\treturn NULL;\n\t}\n\treturn piinfo->addr;\n}",
        "target": 1
    },
    {
        "func": "int __udp6_lib_rcv(struct sk_buff *skb, struct udp_table *udptable,\n\t\t   int proto)\n{\n\tstruct net *net = dev_net(skb->dev);\n\tstruct sock *sk;\n\tstruct udphdr *uh;\n\tstruct in6_addr *saddr, *daddr;\n\tu32 ulen = 0;\n\n\tif (!pskb_may_pull(skb, sizeof(struct udphdr)))\n\t\tgoto short_packet;\n\n\tsaddr = &ipv6_hdr(skb)->saddr;\n\tdaddr = &ipv6_hdr(skb)->daddr;\n\tuh = udp_hdr(skb);\n\n\tulen = ntohs(uh->len);\n\tif (ulen > skb->len)\n\t\tgoto short_packet;\n\n\tif (proto == IPPROTO_UDP) {\n\t\t/* UDP validates ulen. */\n\n\t\t/* Check for jumbo payload */\n\t\tif (ulen == 0)\n\t\t\tulen = skb->len;\n\n\t\tif (ulen < sizeof(*uh))\n\t\t\tgoto short_packet;\n\n\t\tif (ulen < skb->len) {\n\t\t\tif (pskb_trim_rcsum(skb, ulen))\n\t\t\t\tgoto short_packet;\n\t\t\tsaddr = &ipv6_hdr(skb)->saddr;\n\t\t\tdaddr = &ipv6_hdr(skb)->daddr;\n\t\t\tuh = udp_hdr(skb);\n\t\t}\n\t}\n\n\tif (udp6_csum_init(skb, uh, proto))\n\t\tgoto discard;\n\n\t/*\n\t *\tMulticast receive code\n\t */\n\tif (ipv6_addr_is_multicast(daddr))\n\t\treturn __udp6_lib_mcast_deliver(net, skb,\n\t\t\t\tsaddr, daddr, udptable);\n\n\t/* Unicast */\n\n\t/*\n\t * check socket cache ... must talk to Alan about his plans\n\t * for sock caches... i'll skip this for now.\n\t */\n\tsk = __udp6_lib_lookup_skb(skb, uh->source, uh->dest, udptable);\n\n\tif (sk == NULL) {\n\t\tif (!xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb))\n\t\t\tgoto discard;\n\n\t\tif (udp_lib_checksum_complete(skb))\n\t\t\tgoto discard;\n\t\tUDP6_INC_STATS_BH(net, UDP_MIB_NOPORTS,\n\t\t\t\tproto == IPPROTO_UDPLITE);\n\n\t\ticmpv6_send(skb, ICMPV6_DEST_UNREACH, ICMPV6_PORT_UNREACH, 0);\n\n\t\tkfree_skb(skb);\n\t\treturn 0;\n\t}\n\n\t/* deliver */\n\n\tbh_lock_sock(sk);\n\tif (!sock_owned_by_user(sk))\n\t\tudpv6_queue_rcv_skb(sk, skb);\n\telse if (sk_add_backlog(sk, skb)) {\n\t\tatomic_inc(&sk->sk_drops);\n\t\tbh_unlock_sock(sk);\n\t\tsock_put(sk);\n\t\tgoto discard;\n\t}\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n\treturn 0;\n\nshort_packet:\n\tLIMIT_NETDEBUG(KERN_DEBUG \"UDP%sv6: short packet: %d/%u\\n\",\n\t\t       proto == IPPROTO_UDPLITE ? \"-Lite\" : \"\",\n\t\t       ulen, skb->len);\n\ndiscard:\n\tUDP6_INC_STATS_BH(net, UDP_MIB_INERRORS, proto == IPPROTO_UDPLITE);\n\tkfree_skb(skb);\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static void flush_stack(struct sock **stack, unsigned int count,\n\t\t\tstruct sk_buff *skb, unsigned int final)\n{\n\tunsigned int i;\n\tstruct sock *sk;\n\tstruct sk_buff *skb1;\n\n\tfor (i = 0; i < count; i++) {\n\t\tskb1 = (i == final) ? skb : skb_clone(skb, GFP_ATOMIC);\n\n\t\tsk = stack[i];\n\t\tif (skb1) {\n\t\t\tbh_lock_sock(sk);\n\t\t\tif (!sock_owned_by_user(sk))\n\t\t\t\tudpv6_queue_rcv_skb(sk, skb1);\n\t\t\telse if (sk_add_backlog(sk, skb1)) {\n\t\t\t\tkfree_skb(skb1);\n\t\t\t\tbh_unlock_sock(sk);\n\t\t\t\tgoto drop;\n\t\t\t}\n\t\t\tbh_unlock_sock(sk);\n\t\t\tcontinue;\n\t\t}\ndrop:\n\t\tatomic_inc(&sk->sk_drops);\n\t\tUDP6_INC_STATS_BH(sock_net(sk),\n\t\t\t\tUDP_MIB_RCVBUFERRORS, IS_UDPLITE(sk));\n\t\tUDP6_INC_STATS_BH(sock_net(sk),\n\t\t\t\tUDP_MIB_INERRORS, IS_UDPLITE(sk));\n\t}\n}",
        "target": 1
    },
    {
        "func": "int sk_receive_skb(struct sock *sk, struct sk_buff *skb, const int nested)\n{\n\tint rc = NET_RX_SUCCESS;\n\n\tif (sk_filter(sk, skb))\n\t\tgoto discard_and_relse;\n\n\tskb->dev = NULL;\n\n\tif (nested)\n\t\tbh_lock_sock_nested(sk);\n\telse\n\t\tbh_lock_sock(sk);\n\tif (!sock_owned_by_user(sk)) {\n\t\t/*\n\t\t * trylock + unlock semantics:\n\t\t */\n\t\tmutex_acquire(&sk->sk_lock.dep_map, 0, 1, _RET_IP_);\n\n\t\trc = sk_backlog_rcv(sk, skb);\n\n\t\tmutex_release(&sk->sk_lock.dep_map, 1, _RET_IP_);\n\t} else if (sk_add_backlog(sk, skb)) {\n\t\tbh_unlock_sock(sk);\n\t\tatomic_inc(&sk->sk_drops);\n\t\tgoto discard_and_relse;\n\t}\n\n\tbh_unlock_sock(sk);\nout:\n\tsock_put(sk);\n\treturn rc;\ndiscard_and_relse:\n\tkfree_skb(skb);\n\tgoto out;\n}",
        "target": 1
    },
    {
        "func": "int udp_queue_rcv_skb(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct udp_sock *up = udp_sk(sk);\n\tint rc;\n\tint is_udplite = IS_UDPLITE(sk);\n\n\t/*\n\t *\tCharge it to the socket, dropping if the queue is full.\n\t */\n\tif (!xfrm4_policy_check(sk, XFRM_POLICY_IN, skb))\n\t\tgoto drop;\n\tnf_reset(skb);\n\n\tif (up->encap_type) {\n\t\t/*\n\t\t * This is an encapsulation socket so pass the skb to\n\t\t * the socket's udp_encap_rcv() hook. Otherwise, just\n\t\t * fall through and pass this up the UDP socket.\n\t\t * up->encap_rcv() returns the following value:\n\t\t * =0 if skb was successfully passed to the encap\n\t\t *    handler or was discarded by it.\n\t\t * >0 if skb should be passed on to UDP.\n\t\t * <0 if skb should be resubmitted as proto -N\n\t\t */\n\n\t\t/* if we're overly short, let UDP handle it */\n\t\tif (skb->len > sizeof(struct udphdr) &&\n\t\t    up->encap_rcv != NULL) {\n\t\t\tint ret;\n\n\t\t\tret = (*up->encap_rcv)(sk, skb);\n\t\t\tif (ret <= 0) {\n\t\t\t\tUDP_INC_STATS_BH(sock_net(sk),\n\t\t\t\t\t\t UDP_MIB_INDATAGRAMS,\n\t\t\t\t\t\t is_udplite);\n\t\t\t\treturn -ret;\n\t\t\t}\n\t\t}\n\n\t\t/* FALLTHROUGH -- it's a UDP Packet */\n\t}\n\n\t/*\n\t * \tUDP-Lite specific tests, ignored on UDP sockets\n\t */\n\tif ((is_udplite & UDPLITE_RECV_CC)  &&  UDP_SKB_CB(skb)->partial_cov) {\n\n\t\t/*\n\t\t * MIB statistics other than incrementing the error count are\n\t\t * disabled for the following two types of errors: these depend\n\t\t * on the application settings, not on the functioning of the\n\t\t * protocol stack as such.\n\t\t *\n\t\t * RFC 3828 here recommends (sec 3.3): \"There should also be a\n\t\t * way ... to ... at least let the receiving application block\n\t\t * delivery of packets with coverage values less than a value\n\t\t * provided by the application.\"\n\t\t */\n\t\tif (up->pcrlen == 0) {          /* full coverage was set  */\n\t\t\tLIMIT_NETDEBUG(KERN_WARNING \"UDPLITE: partial coverage \"\n\t\t\t\t\"%d while full coverage %d requested\\n\",\n\t\t\t\tUDP_SKB_CB(skb)->cscov, skb->len);\n\t\t\tgoto drop;\n\t\t}\n\t\t/* The next case involves violating the min. coverage requested\n\t\t * by the receiver. This is subtle: if receiver wants x and x is\n\t\t * greater than the buffersize/MTU then receiver will complain\n\t\t * that it wants x while sender emits packets of smaller size y.\n\t\t * Therefore the above ...()->partial_cov statement is essential.\n\t\t */\n\t\tif (UDP_SKB_CB(skb)->cscov  <  up->pcrlen) {\n\t\t\tLIMIT_NETDEBUG(KERN_WARNING\n\t\t\t\t\"UDPLITE: coverage %d too small, need min %d\\n\",\n\t\t\t\tUDP_SKB_CB(skb)->cscov, up->pcrlen);\n\t\t\tgoto drop;\n\t\t}\n\t}\n\n\tif (sk->sk_filter) {\n\t\tif (udp_lib_checksum_complete(skb))\n\t\t\tgoto drop;\n\t}\n\n\trc = 0;\n\n\tbh_lock_sock(sk);\n\tif (!sock_owned_by_user(sk))\n\t\trc = __udp_queue_rcv_skb(sk, skb);\n\telse if (sk_add_backlog(sk, skb)) {\n\t\tbh_unlock_sock(sk);\n\t\tgoto drop;\n\t}\n\tbh_unlock_sock(sk);\n\n\treturn rc;\n\ndrop:\n\tUDP_INC_STATS_BH(sock_net(sk), UDP_MIB_INERRORS, is_udplite);\n\tatomic_inc(&sk->sk_drops);\n\tkfree_skb(skb);\n\treturn -1;\n}",
        "target": 1
    },
    {
        "func": "static inline __must_check int sk_add_backlog(struct sock *sk, struct sk_buff *skb)\n{\n\tif (sk->sk_backlog.len >= max(sk->sk_backlog.limit, sk->sk_rcvbuf << 1))\n\t\treturn -ENOBUFS;\n\n\t__sk_add_backlog(sk, skb);\n\tsk->sk_backlog.len += skb->truesize;\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "void sock_init_data(struct socket *sock, struct sock *sk)\n{\n\tskb_queue_head_init(&sk->sk_receive_queue);\n\tskb_queue_head_init(&sk->sk_write_queue);\n\tskb_queue_head_init(&sk->sk_error_queue);\n#ifdef CONFIG_NET_DMA\n\tskb_queue_head_init(&sk->sk_async_wait_queue);\n#endif\n\n\tsk->sk_send_head\t=\tNULL;\n\n\tinit_timer(&sk->sk_timer);\n\n\tsk->sk_allocation\t=\tGFP_KERNEL;\n\tsk->sk_rcvbuf\t\t=\tsysctl_rmem_default;\n\tsk->sk_sndbuf\t\t=\tsysctl_wmem_default;\n\tsk->sk_backlog.limit\t=\tsk->sk_rcvbuf << 1;\n\tsk->sk_state\t\t=\tTCP_CLOSE;\n\tsk_set_socket(sk, sock);\n\n\tsock_set_flag(sk, SOCK_ZAPPED);\n\n\tif (sock) {\n\t\tsk->sk_type\t=\tsock->type;\n\t\tsk->sk_sleep\t=\t&sock->wait;\n\t\tsock->sk\t=\tsk;\n\t} else\n\t\tsk->sk_sleep\t=\tNULL;\n\n\tspin_lock_init(&sk->sk_dst_lock);\n\trwlock_init(&sk->sk_callback_lock);\n\tlockdep_set_class_and_name(&sk->sk_callback_lock,\n\t\t\taf_callback_keys + sk->sk_family,\n\t\t\taf_family_clock_key_strings[sk->sk_family]);\n\n\tsk->sk_state_change\t=\tsock_def_wakeup;\n\tsk->sk_data_ready\t=\tsock_def_readable;\n\tsk->sk_write_space\t=\tsock_def_write_space;\n\tsk->sk_error_report\t=\tsock_def_error_report;\n\tsk->sk_destruct\t\t=\tsock_def_destruct;\n\n\tsk->sk_sndmsg_page\t=\tNULL;\n\tsk->sk_sndmsg_off\t=\t0;\n\n\tsk->sk_peercred.pid \t=\t0;\n\tsk->sk_peercred.uid\t=\t-1;\n\tsk->sk_peercred.gid\t=\t-1;\n\tsk->sk_write_pending\t=\t0;\n\tsk->sk_rcvlowat\t\t=\t1;\n\tsk->sk_rcvtimeo\t\t=\tMAX_SCHEDULE_TIMEOUT;\n\tsk->sk_sndtimeo\t\t=\tMAX_SCHEDULE_TIMEOUT;\n\n\tsk->sk_stamp = ktime_set(-1L, 0);\n\n\t/*\n\t * Before updating sk_refcnt, we must commit prior changes to memory\n\t * (Documentation/RCU/rculist_nulls.txt for details)\n\t */\n\tsmp_wmb();\n\tatomic_set(&sk->sk_refcnt, 1);\n\tatomic_set(&sk->sk_drops, 0);\n}",
        "target": 1
    },
    {
        "func": "SCTP_STATIC int sctp_init_sock(struct sock *sk)\n{\n\tstruct sctp_endpoint *ep;\n\tstruct sctp_sock *sp;\n\n\tSCTP_DEBUG_PRINTK(\"sctp_init_sock(sk: %p)\\n\", sk);\n\n\tsp = sctp_sk(sk);\n\n\t/* Initialize the SCTP per socket area.  */\n\tswitch (sk->sk_type) {\n\tcase SOCK_SEQPACKET:\n\t\tsp->type = SCTP_SOCKET_UDP;\n\t\tbreak;\n\tcase SOCK_STREAM:\n\t\tsp->type = SCTP_SOCKET_TCP;\n\t\tbreak;\n\tdefault:\n\t\treturn -ESOCKTNOSUPPORT;\n\t}\n\n\t/* Initialize default send parameters. These parameters can be\n\t * modified with the SCTP_DEFAULT_SEND_PARAM socket option.\n\t */\n\tsp->default_stream = 0;\n\tsp->default_ppid = 0;\n\tsp->default_flags = 0;\n\tsp->default_context = 0;\n\tsp->default_timetolive = 0;\n\n\tsp->default_rcv_context = 0;\n\tsp->max_burst = sctp_max_burst;\n\n\t/* Initialize default setup parameters. These parameters\n\t * can be modified with the SCTP_INITMSG socket option or\n\t * overridden by the SCTP_INIT CMSG.\n\t */\n\tsp->initmsg.sinit_num_ostreams   = sctp_max_outstreams;\n\tsp->initmsg.sinit_max_instreams  = sctp_max_instreams;\n\tsp->initmsg.sinit_max_attempts   = sctp_max_retrans_init;\n\tsp->initmsg.sinit_max_init_timeo = sctp_rto_max;\n\n\t/* Initialize default RTO related parameters.  These parameters can\n\t * be modified for with the SCTP_RTOINFO socket option.\n\t */\n\tsp->rtoinfo.srto_initial = sctp_rto_initial;\n\tsp->rtoinfo.srto_max     = sctp_rto_max;\n\tsp->rtoinfo.srto_min     = sctp_rto_min;\n\n\t/* Initialize default association related parameters. These parameters\n\t * can be modified with the SCTP_ASSOCINFO socket option.\n\t */\n\tsp->assocparams.sasoc_asocmaxrxt = sctp_max_retrans_association;\n\tsp->assocparams.sasoc_number_peer_destinations = 0;\n\tsp->assocparams.sasoc_peer_rwnd = 0;\n\tsp->assocparams.sasoc_local_rwnd = 0;\n\tsp->assocparams.sasoc_cookie_life = sctp_valid_cookie_life;\n\n\t/* Initialize default event subscriptions. By default, all the\n\t * options are off.\n\t */\n\tmemset(&sp->subscribe, 0, sizeof(struct sctp_event_subscribe));\n\n\t/* Default Peer Address Parameters.  These defaults can\n\t * be modified via SCTP_PEER_ADDR_PARAMS\n\t */\n\tsp->hbinterval  = sctp_hb_interval;\n\tsp->pathmaxrxt  = sctp_max_retrans_path;\n\tsp->pathmtu     = 0; // allow default discovery\n\tsp->sackdelay   = sctp_sack_timeout;\n\tsp->sackfreq\t= 2;\n\tsp->param_flags = SPP_HB_ENABLE |\n\t\t\t  SPP_PMTUD_ENABLE |\n\t\t\t  SPP_SACKDELAY_ENABLE;\n\n\t/* If enabled no SCTP message fragmentation will be performed.\n\t * Configure through SCTP_DISABLE_FRAGMENTS socket option.\n\t */\n\tsp->disable_fragments = 0;\n\n\t/* Enable Nagle algorithm by default.  */\n\tsp->nodelay           = 0;\n\n\t/* Enable by default. */\n\tsp->v4mapped          = 1;\n\n\t/* Auto-close idle associations after the configured\n\t * number of seconds.  A value of 0 disables this\n\t * feature.  Configure through the SCTP_AUTOCLOSE socket option,\n\t * for UDP-style sockets only.\n\t */\n\tsp->autoclose         = 0;\n\n\t/* User specified fragmentation limit. */\n\tsp->user_frag         = 0;\n\n\tsp->adaptation_ind = 0;\n\n\tsp->pf = sctp_get_pf_specific(sk->sk_family);\n\n\t/* Control variables for partial data delivery. */\n\tatomic_set(&sp->pd_mode, 0);\n\tskb_queue_head_init(&sp->pd_lobby);\n\tsp->frag_interleave = 0;\n\n\t/* Create a per socket endpoint structure.  Even if we\n\t * change the data structure relationships, this may still\n\t * be useful for storing pre-connect address information.\n\t */\n\tep = sctp_endpoint_new(sk, GFP_KERNEL);\n\tif (!ep)\n\t\treturn -ENOMEM;\n\n\tsp->ep = ep;\n\tsp->hmac = NULL;\n\n\tSCTP_DBG_OBJCNT_INC(sock);\n\tpercpu_counter_inc(&sctp_sockets_allocated);\n\n\t/* Set socket backlog limit. */\n\tsk->sk_backlog.limit = sysctl_sctp_rmem[1];\n\n\tlocal_bh_disable();\n\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, 1);\n\tlocal_bh_enable();\n\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "MonoReflectionMethod*\nmono_reflection_bind_generic_method_parameters (MonoReflectionMethod *rmethod, MonoArray *types)\n{\n\tMonoClass *klass;\n\tMonoMethod *method, *inflated;\n\tMonoMethodInflated *imethod;\n\tMonoGenericContext tmp_context;\n\tMonoGenericInst *ginst;\n\tMonoType **type_argv;\n\tint count, i;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (!strcmp (rmethod->object.vtable->klass->name, \"MethodBuilder\")) {\n#ifndef DISABLE_REFLECTION_EMIT\n\t\tMonoReflectionMethodBuilder *mb = NULL;\n\t\tMonoReflectionTypeBuilder *tb;\n\t\tMonoClass *klass;\n\n\t\tmb = (MonoReflectionMethodBuilder *) rmethod;\n\t\ttb = (MonoReflectionTypeBuilder *) mb->type;\n\t\tklass = mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)tb));\n\n\t\tmethod = methodbuilder_to_mono_method (klass, mb);\n#else\n\t\tg_assert_not_reached ();\n\t\tmethod = NULL;\n#endif\n\t} else {\n\t\tmethod = rmethod->method;\n\t}\n\n\tklass = method->klass;\n\n\tif (method->is_inflated)\n\t\tmethod = ((MonoMethodInflated *) method)->declaring;\n\n\tcount = mono_method_signature (method)->generic_param_count;\n\tif (count != mono_array_length (types))\n\t\treturn NULL;\n\n\ttype_argv = g_new0 (MonoType *, count);\n\tfor (i = 0; i < count; i++) {\n\t\tMonoReflectionType *garg = mono_array_get (types, gpointer, i);\n\t\ttype_argv [i] = mono_reflection_type_get_handle (garg);\n\t}\n\tginst = mono_metadata_get_generic_inst (count, type_argv);\n\tg_free (type_argv);\n\n\ttmp_context.class_inst = klass->generic_class ? klass->generic_class->context.class_inst : NULL;\n\ttmp_context.method_inst = ginst;\n\n\tinflated = mono_class_inflate_generic_method (method, &tmp_context);\n\timethod = (MonoMethodInflated *) inflated;\n\n\tif (method->klass->image->dynamic) {\n\t\tMonoDynamicImage *image = (MonoDynamicImage*)method->klass->image;\n\t\t/*\n\t\t * This table maps metadata structures representing inflated methods/fields\n\t\t * to the reflection objects representing their generic definitions.\n\t\t */\n\t\tmono_loader_lock ();\n\t\tmono_g_hash_table_insert (image->generic_def_objects, imethod, rmethod);\n\t\tmono_loader_unlock ();\n\t}\n\t\n\treturn mono_method_get_object (mono_object_domain (rmethod), inflated, NULL);",
        "target": 1
    },
    {
        "func": "MonoReflectionMethod*\nmono_reflection_bind_generic_method_parameters (MonoReflectionMethod *rmethod, MonoArray *types)\n{\n\tMonoClass *klass;\n\tMonoMethod *method, *inflated;\n\tMonoMethodInflated *imethod;\n\tMonoGenericContext tmp_context;\n\tMonoGenericInst *ginst;\n\tMonoType **type_argv;\n\tint count, i;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\t/*FIXME but this no longer should happen*/\n\tif (!strcmp (rmethod->object.vtable->klass->name, \"MethodBuilder\")) {\n#ifndef DISABLE_REFLECTION_EMIT\n\t\tMonoReflectionMethodBuilder *mb = NULL;\n\t\tMonoReflectionTypeBuilder *tb;\n\t\tMonoClass *klass;\n\n\t\tmb = (MonoReflectionMethodBuilder *) rmethod;\n\t\ttb = (MonoReflectionTypeBuilder *) mb->type;\n\t\tklass = mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)tb));\n\n\t\tmethod = methodbuilder_to_mono_method (klass, mb);\n#else\n\t\tg_assert_not_reached ();\n\t\tmethod = NULL;\n#endif\n\t} else {\n\t\tmethod = rmethod->method;\n\t}\n\n\tklass = method->klass;\n\n\tif (method->is_inflated)\n\t\tmethod = ((MonoMethodInflated *) method)->declaring;\n\n\tcount = mono_method_signature (method)->generic_param_count;\n\tif (count != mono_array_length (types))\n\t\treturn NULL;\n\n\ttype_argv = g_new0 (MonoType *, count);\n\tfor (i = 0; i < count; i++) {\n\t\tMonoReflectionType *garg = mono_array_get (types, gpointer, i);\n\t\ttype_argv [i] = mono_reflection_type_get_handle (garg);\n\t}\n\tginst = mono_metadata_get_generic_inst (count, type_argv);\n\tg_free (type_argv);\n\n\ttmp_context.class_inst = klass->generic_class ? klass->generic_class->context.class_inst : NULL;\n\ttmp_context.method_inst = ginst;\n\n\tinflated = mono_class_inflate_generic_method (method, &tmp_context);\n\timethod = (MonoMethodInflated *) inflated;\n\n\t/*FIXME but I think this is no longer necessary*/\n\tif (method->klass->image->dynamic) {\n\t\tMonoDynamicImage *image = (MonoDynamicImage*)method->klass->image;\n\t\t/*\n\t\t * This table maps metadata structures representing inflated methods/fields\n\t\t * to the reflection objects representing their generic definitions.\n\t\t */\n\t\tmono_loader_lock ();\n\t\tmono_g_hash_table_insert (image->generic_def_objects, imethod, rmethod);\n\t\tmono_loader_unlock ();\n\t}\n\t\n\treturn mono_method_get_object (mono_object_domain (rmethod), inflated, NULL);",
        "target": 1
    },
    {
        "func": "string_vformat(uschar *buffer, int buflen, char *format, va_list ap)\n{\nenum { L_NORMAL, L_SHORT, L_LONG, L_LONGLONG, L_LONGDOUBLE };\n\nBOOL yield = TRUE;\nint width, precision;\nchar *fp = format;             /* Deliberately not unsigned */\nuschar *p = buffer;\nuschar *last = buffer + buflen - 1;\n\nstring_datestamp_offset = -1;  /* Datestamp not inserted */\n\n/* Scan the format and handle the insertions */\n\nwhile (*fp != 0)\n  {\n  int length = L_NORMAL;\n  int *nptr;\n  int slen;\n  char *null = \"NULL\";         /* ) These variables */\n  char *item_start, *s;        /* ) are deliberately */\n  char newformat[16];          /* ) not unsigned */\n\n  /* Non-% characters just get copied verbatim */\n\n  if (*fp != '%')\n    {\n    if (p >= last) { yield = FALSE; break; }\n    *p++ = (uschar)*fp++;\n    continue;\n    }\n\n  /* Deal with % characters. Pick off the width and precision, for checking\n  strings, skipping over the flag and modifier characters. */\n\n  item_start = fp;\n  width = precision = -1;\n\n  if (strchr(\"-+ #0\", *(++fp)) != NULL)\n    {\n    if (*fp == '#') null = \"\";\n    fp++;\n    }\n\n  if (isdigit((uschar)*fp))\n    {\n    width = *fp++ - '0';\n    while (isdigit((uschar)*fp)) width = width * 10 + *fp++ - '0';\n    }\n  else if (*fp == '*')\n    {\n    width = va_arg(ap, int);\n    fp++;\n    }\n\n  if (*fp == '.')\n    {\n    if (*(++fp) == '*')\n      {\n      precision = va_arg(ap, int);\n      fp++;\n      }\n    else\n      {\n      precision = 0;\n      while (isdigit((uschar)*fp))\n        precision = precision*10 + *fp++ - '0';\n      }\n    }\n\n  /* Skip over 'h', 'L', 'l', and 'll', remembering the item length */\n\n  if (*fp == 'h')\n    { fp++; length = L_SHORT; }\n  else if (*fp == 'L')\n    { fp++; length = L_LONGDOUBLE; }\n  else if (*fp == 'l')\n    {\n    if (fp[1] == 'l')\n      {\n      fp += 2;\n      length = L_LONGLONG;\n      }\n    else\n      {\n      fp++;\n      length = L_LONG;\n      }\n    }\n\n  /* Handle each specific format type. */\n\n  switch (*fp++)\n    {\n    case 'n':\n    nptr = va_arg(ap, int *);\n    *nptr = p - buffer;\n    break;\n\n    case 'd':\n    case 'o':\n    case 'u':\n    case 'x':\n    case 'X':\n    if (p >= last - ((length > L_LONG)? 24 : 12))\n      { yield = FALSE; goto END_FORMAT; }\n    strncpy(newformat, item_start, fp - item_start);\n    newformat[fp - item_start] = 0;\n\n    /* Short int is promoted to int when passing through ..., so we must use\n    int for va_arg(). */\n\n    switch(length)\n      {\n      case L_SHORT:\n      case L_NORMAL:   sprintf(CS p, newformat, va_arg(ap, int)); break;\n      case L_LONG:     sprintf(CS p, newformat, va_arg(ap, long int)); break;\n      case L_LONGLONG: sprintf(CS p, newformat, va_arg(ap, LONGLONG_T)); break;\n      }\n    while (*p) p++;\n    break;\n\n    case 'p':\n    if (p >= last - 24) { yield = FALSE; goto END_FORMAT; }\n    strncpy(newformat, item_start, fp - item_start);\n    newformat[fp - item_start] = 0;\n    sprintf(CS p, newformat, va_arg(ap, void *));\n    while (*p) p++;\n    break;\n\n    /* %f format is inherently insecure if the numbers that it may be\n    handed are unknown (e.g. 1e300). However, in Exim, %f is used for\n    printing load averages, and these are actually stored as integers\n    (load average * 1000) so the size of the numbers is constrained.\n    It is also used for formatting sending rates, where the simplicity\n    of the format prevents overflow. */\n\n    case 'f':\n    case 'e':\n    case 'E':\n    case 'g':\n    case 'G':\n    if (precision < 0) precision = 6;\n    if (p >= last - precision - 8) { yield = FALSE; goto END_FORMAT; }\n    strncpy(newformat, item_start, fp - item_start);\n    newformat[fp-item_start] = 0;\n    if (length == L_LONGDOUBLE)\n      sprintf(CS p, newformat, va_arg(ap, long double));\n    else\n      sprintf(CS p, newformat, va_arg(ap, double));\n    while (*p) p++;\n    break;\n\n    /* String types */\n\n    case '%':\n    if (p >= last) { yield = FALSE; goto END_FORMAT; }\n    *p++ = '%';\n    break;\n\n    case 'c':\n    if (p >= last) { yield = FALSE; goto END_FORMAT; }\n    *p++ = va_arg(ap, int);\n    break;\n\n    case 'D':                   /* Insert datestamp for log file names */\n    s = CS tod_stamp(tod_log_datestamp);\n    string_datestamp_offset = p - buffer;   /* Passed back via global */\n    goto INSERT_STRING;\n\n    case 's':\n    case 'S':                   /* Forces *lower* case */\n    s = va_arg(ap, char *);\n\n    INSERT_STRING:              /* Come to from %D above */\n    if (s == NULL) s = null;\n    slen = Ustrlen(s);\n\n    /* If the width is specified, check that there is a precision\n    set; if not, set it to the width to prevent overruns of long\n    strings. */\n\n    if (width >= 0)\n      {\n      if (precision < 0) precision = width;\n      }\n\n    /* If a width is not specified and the precision is specified, set\n    the width to the precision, or the string length if shorted. */\n\n    else if (precision >= 0)\n      {\n      width = (precision < slen)? precision : slen;\n      }\n\n    /* If neither are specified, set them both to the string length. */\n\n    else width = precision = slen;\n\n    /* Check string space, and add the string to the buffer if ok. If\n    not OK, add part of the string (debugging uses this to show as\n    much as possible). */\n\n    if (p >= last - width)\n      {\n      yield = FALSE;\n      width = precision = last - p - 1;\n      }\n    sprintf(CS p, \"%*.*s\", width, precision, s);\n    if (fp[-1] == 'S')\n      while (*p) { *p = tolower(*p); p++; }\n    else\n      while (*p) p++;\n    if (!yield) goto END_FORMAT;\n    break;\n\n    /* Some things are never used in Exim; also catches junk. */\n\n    default:\n    strncpy(newformat, item_start, fp - item_start);\n    newformat[fp-item_start] = 0;\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"string_format: unsupported type \"\n      \"in \\\"%s\\\" in \\\"%s\\\"\", newformat, format);\n    break;\n    }\n  }\n\n/* Ensure string is complete; return TRUE if got to the end of the format */\n\nEND_FORMAT:\n\n*p = 0;\nreturn yield;\n}",
        "target": 1
    },
    {
        "func": "handle_smtp_call(int *listen_sockets, int listen_socket_count,\n  int accept_socket, struct sockaddr *accepted)\n{\npid_t pid;\nunion sockaddr_46 interface_sockaddr;\nEXIM_SOCKLEN_T ifsize = sizeof(interface_sockaddr);\nint dup_accept_socket = -1;\nint max_for_this_host = 0;\nint wfsize = 0;\nint wfptr = 0;\nint use_log_write_selector = log_write_selector;\nuschar *whofrom = NULL;\n\nvoid *reset_point = store_get(0);\n\n/* Make the address available in ASCII representation, and also fish out\nthe remote port. */\n\nsender_host_address = host_ntoa(-1, accepted, NULL, &sender_host_port);\nDEBUG(D_any) debug_printf(\"Connection request from %s port %d\\n\",\n  sender_host_address, sender_host_port);\n\n/* Set up the output stream, check the socket has duplicated, and set up the\ninput stream. These operations fail only the exceptional circumstances. Note\nthat never_error() won't use smtp_out if it is NULL. */\n\nsmtp_out = fdopen(accept_socket, \"wb\");\nif (smtp_out == NULL)\n  {\n  never_error(US\"daemon: fdopen() for smtp_out failed\", US\"\", errno);\n  goto ERROR_RETURN;\n  }\n\ndup_accept_socket = dup(accept_socket);\nif (dup_accept_socket < 0)\n  {\n  never_error(US\"daemon: couldn't dup socket descriptor\",\n    US\"Connection setup failed\", errno);\n  goto ERROR_RETURN;\n  }\n\nsmtp_in = fdopen(dup_accept_socket, \"rb\");\nif (smtp_in == NULL)\n  {\n  never_error(US\"daemon: fdopen() for smtp_in failed\",\n    US\"Connection setup failed\", errno);\n  goto ERROR_RETURN;\n  }\n\n/* Get the data for the local interface address. Panic for most errors, but\n\"connection reset by peer\" just means the connection went away. */\n\nif (getsockname(accept_socket, (struct sockaddr *)(&interface_sockaddr),\n     &ifsize) < 0)\n  {\n  log_write(0, LOG_MAIN | ((errno == ECONNRESET)? 0 : LOG_PANIC),\n    \"getsockname() failed: %s\", strerror(errno));\n  smtp_printf(\"421 Local problem: getsockname() failed; please try again later\\r\\n\");\n  goto ERROR_RETURN;\n  }\n\ninterface_address = host_ntoa(-1, &interface_sockaddr, NULL, &interface_port);\nDEBUG(D_interface) debug_printf(\"interface address=%s port=%d\\n\",\n  interface_address, interface_port);\n\n/* Build a string identifying the remote host and, if requested, the port and\nthe local interface data. This is for logging; at the end of this function the\nmemory is reclaimed. */\n\nwhofrom = string_append(whofrom, &wfsize, &wfptr, 3, \"[\", sender_host_address, \"]\");\n\nif ((log_extra_selector & LX_incoming_port) != 0)\n  whofrom = string_append(whofrom, &wfsize, &wfptr, 2, \":\", string_sprintf(\"%d\",\n    sender_host_port));\n\nif ((log_extra_selector & LX_incoming_interface) != 0)\n  whofrom = string_append(whofrom, &wfsize, &wfptr, 4, \" I=[\",\n    interface_address, \"]:\", string_sprintf(\"%d\", interface_port));\n\nwhofrom[wfptr] = 0;    /* Terminate the newly-built string */\n\n/* Check maximum number of connections. We do not check for reserved\nconnections or unacceptable hosts here. That is done in the subprocess because\nit might take some time. */\n\nif (smtp_accept_max > 0 && smtp_accept_count >= smtp_accept_max)\n  {\n  DEBUG(D_any) debug_printf(\"rejecting SMTP connection: count=%d max=%d\\n\",\n    smtp_accept_count, smtp_accept_max);\n  smtp_printf(\"421 Too many concurrent SMTP connections; \"\n    \"please try again later.\\r\\n\");\n  log_write(L_connection_reject,\n            LOG_MAIN, \"Connection from %s refused: too many connections\",\n    whofrom);\n  goto ERROR_RETURN;\n  }\n\n/* If a load limit above which only reserved hosts are acceptable is defined,\nget the load average here, and if there are in fact no reserved hosts, do\nthe test right away (saves a fork). If there are hosts, do the check in the\nsubprocess because it might take time. */\n\nif (smtp_load_reserve >= 0)\n  {\n  load_average = OS_GETLOADAVG();\n  if (smtp_reserve_hosts == NULL && load_average > smtp_load_reserve)\n    {\n    DEBUG(D_any) debug_printf(\"rejecting SMTP connection: load average = %.2f\\n\",\n      (double)load_average/1000.0);\n    smtp_printf(\"421 Too much load; please try again later.\\r\\n\");\n    log_write(L_connection_reject,\n              LOG_MAIN, \"Connection from %s refused: load average = %.2f\",\n      whofrom, (double)load_average/1000.0);\n    goto ERROR_RETURN;\n    }\n  }\n\n/* Check that one specific host (strictly, IP address) is not hogging\nresources. This is done here to prevent a denial of service attack by someone\nforcing you to fork lots of times before denying service. The value of\nsmtp_accept_max_per_host is a string which is expanded. This makes it possible\nto provide host-specific limits according to $sender_host address, but because\nthis is in the daemon mainline, only fast expansions (such as inline address\nchecks) should be used. The documentation is full of warnings. */\n\nif (smtp_accept_max_per_host != NULL)\n  {\n  uschar *expanded = expand_string(smtp_accept_max_per_host);\n  if (expanded == NULL)\n    {\n    if (!expand_string_forcedfail)\n      log_write(0, LOG_MAIN|LOG_PANIC, \"expansion of smtp_accept_max_per_host \"\n        \"failed for %s: %s\", whofrom, expand_string_message);\n    }\n  /* For speed, interpret a decimal number inline here */\n  else\n    {\n    uschar *s = expanded;\n    while (isdigit(*s))\n      max_for_this_host = max_for_this_host * 10 + *s++ - '0';\n    if (*s != 0)\n      log_write(0, LOG_MAIN|LOG_PANIC, \"expansion of smtp_accept_max_per_host \"\n        \"for %s contains non-digit: %s\", whofrom, expanded);\n    }\n  }\n\n/* If we have fewer connections than max_for_this_host, we can skip the tedious\nper host_address checks. Note that at this stage smtp_accept_count contains the\ncount of *other* connections, not including this one. */\n\nif ((max_for_this_host > 0) &&\n    (smtp_accept_count >= max_for_this_host))\n  {\n  int i;\n  int host_accept_count = 0;\n  int other_host_count = 0;    /* keep a count of non matches to optimise */\n\n  for (i = 0; i < smtp_accept_max; ++i)\n    {\n    if (smtp_slots[i].host_address != NULL)\n      {\n      if (Ustrcmp(sender_host_address, smtp_slots[i].host_address) == 0)\n       host_accept_count++;\n      else\n       other_host_count++;\n\n      /* Testing all these strings is expensive - see if we can drop out\n      early, either by hitting the target, or finding there are not enough\n      connections left to make the target. */\n\n      if ((host_accept_count >= max_for_this_host) ||\n         ((smtp_accept_count - other_host_count) < max_for_this_host))\n       break;\n      }\n    }\n\n  if (host_accept_count >= max_for_this_host)\n    {\n    DEBUG(D_any) debug_printf(\"rejecting SMTP connection: too many from this \"\n      \"IP address: count=%d max=%d\\n\",\n      host_accept_count, max_for_this_host);\n    smtp_printf(\"421 Too many concurrent SMTP connections \"\n      \"from this IP address; please try again later.\\r\\n\");\n    log_write(L_connection_reject,\n              LOG_MAIN, \"Connection from %s refused: too many connections \"\n      \"from that IP address\", whofrom);\n    goto ERROR_RETURN;\n    }\n  }\n\n/* OK, the connection count checks have been passed. Before we can fork the\naccepting process, we must first log the connection if requested. This logging\nused to happen in the subprocess, but doing that means that the value of\nsmtp_accept_count can be out of step by the time it is logged. So we have to do\nthe logging here and accept the performance cost. Note that smtp_accept_count\nhasn't yet been incremented to take account of this connection.\n\nIn order to minimize the cost (because this is going to happen for every\nconnection), do a preliminary selector test here. This saves ploughing through\nthe generalized logging code each time when the selector is false. If the\nselector is set, check whether the host is on the list for logging. If not,\narrange to unset the selector in the subprocess. */\n\nif ((log_write_selector & L_smtp_connection) != 0)\n  {\n  uschar *list = hosts_connection_nolog;\n  if (list != NULL && verify_check_host(&list) == OK)\n    use_log_write_selector &= ~L_smtp_connection;\n  else\n    log_write(L_smtp_connection, LOG_MAIN, \"SMTP connection from %s \"\n      \"(TCP/IP connection count = %d)\", whofrom, smtp_accept_count + 1);\n  }\n\n/* Now we can fork the accepting process; do a lookup tidy, just in case any\nexpansion above did a lookup. */\n\nsearch_tidyup();\npid = fork();\n\n/* Handle the child process */\n\nif (pid == 0)\n  {\n  int i;\n  int queue_only_reason = 0;\n  int old_pool = store_pool;\n  int save_debug_selector = debug_selector;\n  BOOL local_queue_only;\n  BOOL session_local_queue_only;\n  #ifdef SA_NOCLDWAIT\n  struct sigaction act;\n  #endif\n\n  smtp_accept_count++;    /* So that it includes this process */\n\n  /* May have been modified for the subprocess */\n\n  log_write_selector = use_log_write_selector;\n\n  /* Get the local interface address into permanent store */\n\n  store_pool = POOL_PERM;\n  interface_address = string_copy(interface_address);\n  store_pool = old_pool;\n\n  /* Check for a tls-on-connect port */\n\n  if (host_is_tls_on_connect_port(interface_port)) tls_on_connect = TRUE;\n\n  /* Expand smtp_active_hostname if required. We do not do this any earlier,\n  because it may depend on the local interface address (indeed, that is most\n  likely what it depends on.) */\n\n  smtp_active_hostname = primary_hostname;\n  if (raw_active_hostname != NULL)\n    {\n    uschar *nah = expand_string(raw_active_hostname);\n    if (nah == NULL)\n      {\n      if (!expand_string_forcedfail)\n        {\n        log_write(0, LOG_MAIN|LOG_PANIC, \"failed to expand \\\"%s\\\" \"\n          \"(smtp_active_hostname): %s\", raw_active_hostname,\n          expand_string_message);\n        smtp_printf(\"421 Local configuration error; \"\n          \"please try again later.\\r\\n\");\n        mac_smtp_fflush();\n        search_tidyup();\n        _exit(EXIT_FAILURE);\n        }\n      }\n    else if (nah[0] != 0) smtp_active_hostname = nah;\n    }\n\n  /* Initialize the queueing flags */\n\n  queue_check_only();\n  session_local_queue_only = queue_only;\n\n  /* Close the listening sockets, and set the SIGCHLD handler to SIG_IGN.\n  We also attempt to set things up so that children are automatically reaped,\n  but just in case this isn't available, there's a paranoid waitpid() in the\n  loop too (except for systems where we are sure it isn't needed). See the more\n  extensive comment before the reception loop in exim.c for a fuller\n  explanation of this logic. */\n\n  for (i = 0; i < listen_socket_count; i++) (void)close(listen_sockets[i]);\n\n  #ifdef SA_NOCLDWAIT\n  act.sa_handler = SIG_IGN;\n  sigemptyset(&(act.sa_mask));\n  act.sa_flags = SA_NOCLDWAIT;\n  sigaction(SIGCHLD, &act, NULL);\n  #else\n  signal(SIGCHLD, SIG_IGN);\n  #endif\n\n  /* Attempt to get an id from the sending machine via the RFC 1413\n  protocol. We do this in the sub-process in order not to hold up the\n  main process if there is any delay. Then set up the fullhost information\n  in case there is no HELO/EHLO.\n\n  If debugging is enabled only for the daemon, we must turn if off while\n  finding the id, but turn it on again afterwards so that information about the\n  incoming connection is output. */\n\n  if (debug_daemon) debug_selector = 0;\n  verify_get_ident(IDENT_PORT);\n  host_build_sender_fullhost();\n  debug_selector = save_debug_selector;\n\n  DEBUG(D_any)\n    debug_printf(\"Process %d is handling incoming connection from %s\\n\",\n      (int)getpid(), sender_fullhost);\n\n  /* Now disable debugging permanently if it's required only for the daemon\n  process. */\n\n  if (debug_daemon) debug_selector = 0;\n\n  /* If there are too many child processes for immediate delivery,\n  set the session_local_queue_only flag, which is initialized from the\n  configured value and may therefore already be TRUE. Leave logging\n  till later so it will have a message id attached. Note that there is no\n  possibility of re-calculating this per-message, because the value of\n  smtp_accept_count does not change in this subprocess. */\n\n  if (smtp_accept_queue > 0 && smtp_accept_count > smtp_accept_queue)\n    {\n    session_local_queue_only = TRUE;\n    queue_only_reason = 1;\n    }\n\n  /* Handle the start of the SMTP session, then loop, accepting incoming\n  messages from the SMTP connection. The end will come at the QUIT command,\n  when smtp_setup_msg() returns 0. A break in the connection causes the\n  process to die (see accept.c).\n\n  NOTE: We do *not* call smtp_log_no_mail() if smtp_start_session() fails,\n  because a log line has already been written for all its failure exists\n  (usually \"connection refused: <reason>\") and writing another one is\n  unnecessary clutter. */\n\n  if (!smtp_start_session())\n    {\n    mac_smtp_fflush();\n    search_tidyup();\n    _exit(EXIT_SUCCESS);\n    }\n\n  for (;;)\n    {\n    int rc;\n    message_id[0] = 0;            /* Clear out any previous message_id */\n    reset_point = store_get(0);   /* Save current store high water point */\n\n    DEBUG(D_any)\n      debug_printf(\"Process %d is ready for new message\\n\", (int)getpid());\n\n    /* Smtp_setup_msg() returns 0 on QUIT or if the call is from an\n    unacceptable host or if an ACL \"drop\" command was triggered, -1 on\n    connection lost, and +1 on validly reaching DATA. Receive_msg() almost\n    always returns TRUE when smtp_input is true; just retry if no message was\n    accepted (can happen for invalid message parameters). However, it can yield\n    FALSE if the connection was forcibly dropped by the DATA ACL. */\n\n    if ((rc = smtp_setup_msg()) > 0)\n      {\n      BOOL ok = receive_msg(FALSE);\n      search_tidyup();                    /* Close cached databases */\n      if (!ok)                            /* Connection was dropped */\n        {\n        mac_smtp_fflush();\n        smtp_log_no_mail();               /* Log no mail if configured */\n        _exit(EXIT_SUCCESS);\n        }\n      if (message_id[0] == 0) continue;   /* No message was accepted */\n      }\n    else\n      {\n      mac_smtp_fflush();\n      search_tidyup();\n      smtp_log_no_mail();                 /* Log no mail if configured */\n      _exit((rc == 0)? EXIT_SUCCESS : EXIT_FAILURE);\n      }\n\n    /* Show the recipients when debugging */\n\n    DEBUG(D_receive)\n      {\n      int i;\n      if (sender_address != NULL)\n        debug_printf(\"Sender: %s\\n\", sender_address);\n      if (recipients_list != NULL)\n        {\n        debug_printf(\"Recipients:\\n\");\n        for (i = 0; i < recipients_count; i++)\n          debug_printf(\"  %s\\n\", recipients_list[i].address);\n        }\n      }\n\n    /* A message has been accepted. Clean up any previous delivery processes\n    that have completed and are defunct, on systems where they don't go away\n    by themselves (see comments when setting SIG_IGN above). On such systems\n    (if any) these delivery processes hang around after termination until\n    the next message is received. */\n\n    #ifndef SIG_IGN_WORKS\n    while (waitpid(-1, NULL, WNOHANG) > 0);\n    #endif\n\n    /* Reclaim up the store used in accepting this message */\n\n    store_reset(reset_point);\n\n    /* If queue_only is set or if there are too many incoming connections in\n    existence, session_local_queue_only will be TRUE. If it is not, check\n    whether we have received too many messages in this session for immediate\n    delivery. */\n\n    if (!session_local_queue_only &&\n        smtp_accept_queue_per_connection > 0 &&\n        receive_messagecount > smtp_accept_queue_per_connection)\n      {\n      session_local_queue_only = TRUE;\n      queue_only_reason = 2;\n      }\n\n    /* Initialize local_queue_only from session_local_queue_only. If it is not\n    true, and queue_only_load is set, check that the load average is below it.\n    If local_queue_only is set by this means, we also set if for the session if\n    queue_only_load_latch is true (the default). This means that, once set,\n    local_queue_only remains set for any subsequent messages on the same SMTP\n    connection. This is a deliberate choice; even though the load average may\n    fall, it doesn't seem right to deliver later messages on the same call when\n    not delivering earlier ones. However, the are special circumstances such as\n    very long-lived connections from scanning appliances where this is not the\n    best strategy. In such cases, queue_only_load_latch should be set false. */\n\n    local_queue_only = session_local_queue_only;\n    if (!local_queue_only && queue_only_load >= 0)\n      {\n      local_queue_only = (load_average = OS_GETLOADAVG()) > queue_only_load;\n      if (local_queue_only)\n        {\n        queue_only_reason = 3;\n        if (queue_only_load_latch) session_local_queue_only = TRUE;\n        }\n      }\n\n    /* Log the queueing here, when it will get a message id attached, but\n    not if queue_only is set (case 0). */\n\n    if (local_queue_only) switch(queue_only_reason)\n      {\n      case 1:\n      log_write(L_delay_delivery,\n                LOG_MAIN, \"no immediate delivery: too many connections \"\n                \"(%d, max %d)\", smtp_accept_count, smtp_accept_queue);\n      break;\n\n      case 2:\n      log_write(L_delay_delivery,\n                LOG_MAIN, \"no immediate delivery: more than %d messages \"\n                \"received in one connection\", smtp_accept_queue_per_connection);\n      break;\n\n      case 3:\n      log_write(L_delay_delivery,\n                LOG_MAIN, \"no immediate delivery: load average %.2f\",\n                (double)load_average/1000.0);\n      break;\n      }\n\n    /* If a delivery attempt is required, spin off a new process to handle it.\n    If we are not root, we have to re-exec exim unless deliveries are being\n    done unprivileged. */\n\n    else if (!queue_only_policy && !deliver_freeze)\n      {\n      pid_t dpid;\n\n      /* Before forking, ensure that the C output buffer is flushed. Otherwise\n      anything that it in it will get duplicated, leading to duplicate copies\n      of the pending output. */\n\n      mac_smtp_fflush();\n\n      if ((dpid = fork()) == 0)\n        {\n        (void)fclose(smtp_in);\n        (void)fclose(smtp_out);\n\n        /* Don't ever molest the parent's SSL connection, but do clean up\n        the data structures if necessary. */\n\n        #ifdef SUPPORT_TLS\n        tls_close(FALSE);\n        #endif\n\n        /* Reset SIGHUP and SIGCHLD in the child in both cases. */\n\n        signal(SIGHUP,  SIG_DFL);\n        signal(SIGCHLD, SIG_DFL);\n\n        if (geteuid() != root_uid && !deliver_drop_privilege)\n          {\n          signal(SIGALRM, SIG_DFL);\n          (void)child_exec_exim(CEE_EXEC_PANIC, FALSE, NULL, FALSE, 2, US\"-Mc\",\n            message_id);\n          /* Control does not return here. */\n          }\n\n        /* No need to re-exec; SIGALRM remains set to the default handler */\n\n        (void)deliver_message(message_id, FALSE, FALSE);\n        search_tidyup();\n        _exit(EXIT_SUCCESS);\n        }\n\n      if (dpid > 0)\n        {\n        DEBUG(D_any) debug_printf(\"forked delivery process %d\\n\", (int)dpid);\n        }\n      else\n        {\n        log_write(0, LOG_MAIN|LOG_PANIC, \"daemon: delivery process fork \"\n          \"failed: %s\", strerror(errno));\n        }\n      }\n    }\n  }\n\n\n/* Carrying on in the parent daemon process... Can't do much if the fork\nfailed. Otherwise, keep count of the number of accepting processes and\nremember the pid for ticking off when the child completes. */\n\nif (pid < 0)\n  {\n  never_error(US\"daemon: accept process fork failed\", US\"Fork failed\", errno);\n  }\nelse\n  {\n  int i;\n  for (i = 0; i < smtp_accept_max; ++i)\n    {\n    if (smtp_slots[i].pid <= 0)\n      {\n      smtp_slots[i].pid = pid;\n      if (smtp_accept_max_per_host != NULL)\n        smtp_slots[i].host_address = string_copy_malloc(sender_host_address);\n      smtp_accept_count++;\n      break;\n      }\n    }\n  DEBUG(D_any) debug_printf(\"%d SMTP accept process%s running\\n\",\n    smtp_accept_count, (smtp_accept_count == 1)? \"\" : \"es\");\n  }\n\n/* Get here via goto in error cases */\n\nERROR_RETURN:\n\n/* Close the streams associated with the socket which will also close the\nsocket fds in this process. We can't do anything if fclose() fails, but\nlogging brings it to someone's attention. However, \"connection reset by peer\"\nisn't really a problem, so skip that one. On Solaris, a dropped connection can\nmanifest itself as a broken pipe, so drop that one too. If the streams don't\nexist, something went wrong while setting things up. Make sure the socket\ndescriptors are closed, in order to drop the connection. */\n\nif (smtp_out != NULL)\n  {\n  if (fclose(smtp_out) != 0 && errno != ECONNRESET && errno != EPIPE)\n    log_write(0, LOG_MAIN|LOG_PANIC, \"daemon: fclose(smtp_out) failed: %s\",\n      strerror(errno));\n  smtp_out = NULL;\n  }\nelse (void)close(accept_socket);\n\nif (smtp_in != NULL)\n  {\n  if (fclose(smtp_in) != 0 && errno != ECONNRESET && errno != EPIPE)\n    log_write(0, LOG_MAIN|LOG_PANIC, \"daemon: fclose(smtp_in) failed: %s\",\n      strerror(errno));\n  smtp_in = NULL;\n  }\nelse (void)close(dup_accept_socket);\n\n/* Release any store used in this process, including the store used for holding\nthe incoming host address and an expanded active_hostname. */\n\nstore_reset(reset_point);\nsender_host_address = NULL;\n}",
        "target": 1
    },
    {
        "func": "readconf_main(void)\n{\nint sep = 0;\nstruct stat statbuf;\nuschar *s, *filename;\nuschar *list = config_main_filelist;\n\n/* Loop through the possible file names */\n\nwhile((filename = string_nextinlist(&list, &sep, big_buffer, big_buffer_size))\n       != NULL)\n  {\n  /* Cut out all the fancy processing unless specifically wanted */\n\n  #if defined(CONFIGURE_FILE_USE_NODE) || defined(CONFIGURE_FILE_USE_EUID)\n  uschar *suffix = filename + Ustrlen(filename);\n\n  /* Try for the node-specific file if a node name exists */\n\n  #ifdef CONFIGURE_FILE_USE_NODE\n  struct utsname uts;\n  if (uname(&uts) >= 0)\n    {\n    #ifdef CONFIGURE_FILE_USE_EUID\n    sprintf(CS suffix, \".%ld.%.256s\", (long int)original_euid, uts.nodename);\n    config_file = Ufopen(filename, \"rb\");\n    if (config_file == NULL)\n    #endif  /* CONFIGURE_FILE_USE_EUID */\n      {\n      sprintf(CS suffix, \".%.256s\", uts.nodename);\n      config_file = Ufopen(filename, \"rb\");\n      }\n    }\n  #endif  /* CONFIGURE_FILE_USE_NODE */\n\n  /* Otherwise, try the generic name, possibly with the euid added */\n\n  #ifdef CONFIGURE_FILE_USE_EUID\n  if (config_file == NULL)\n    {\n    sprintf(CS suffix, \".%ld\", (long int)original_euid);\n    config_file = Ufopen(filename, \"rb\");\n    }\n  #endif  /* CONFIGURE_FILE_USE_EUID */\n\n  /* Finally, try the unadorned name */\n\n  if (config_file == NULL)\n    {\n    *suffix = 0;\n    config_file = Ufopen(filename, \"rb\");\n    }\n  #else  /* if neither defined */\n\n  /* This is the common case when the fancy processing is not included. */\n\n  config_file = Ufopen(filename, \"rb\");\n  #endif\n\n  /* If the file does not exist, continue to try any others. For any other\n  error, break out (and die). */\n\n  if (config_file != NULL || errno != ENOENT) break;\n  }\n\n/* On success, save the name for verification; config_filename is used when\nlogging configuration errors (it changes for .included files) whereas\nconfig_main_filename is the name shown by -bP. Failure to open a configuration\nfile is a serious disaster. */\n\nif (config_file != NULL)\n  {\n  config_filename = config_main_filename = string_copy(filename);\n  }\nelse\n  {\n  if (filename == NULL)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"non-existent configuration file(s): \"\n      \"%s\", config_main_filelist);\n  else\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"%s\", string_open_failed(errno,\n      \"configuration file %s\", filename));\n  }\n\n/* Check the status of the file we have opened, unless it was specified on\nthe command line, in which case privilege was given away at the start. */\n\nif (!config_changed)\n  {\n  if (fstat(fileno(config_file), &statbuf) != 0)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to stat configuration file %s\",\n      big_buffer);\n\n  if ((statbuf.st_uid != root_uid                /* owner not root */\n       #ifdef CONFIGURE_OWNER\n       && statbuf.st_uid != config_uid           /* owner not the special one */\n       #endif\n         ) ||                                    /* or */\n      (statbuf.st_gid != root_gid                /* group not root & */\n       #ifdef CONFIGURE_GROUP\n       && statbuf.st_gid != config_gid           /* group not the special one */\n       #endif\n       && (statbuf.st_mode & 020) != 0) ||       /* group writeable  */\n                                                 /* or */\n      ((statbuf.st_mode & 2) != 0))              /* world writeable  */\n\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"Exim configuration file %s has the \"\n      \"wrong owner, group, or mode\", big_buffer);\n  }\n\n/* Process the main configuration settings. They all begin with a lower case\nletter. If we see something starting with an upper case letter, it is taken as\na macro definition. */\n\nwhile ((s = get_config_line()) != NULL)\n  {\n  if (isupper(s[0])) read_macro_assignment(s);\n\n  else if (Ustrncmp(s, \"domainlist\", 10) == 0)\n    read_named_list(&domainlist_anchor, &domainlist_count,\n      MAX_NAMED_LIST, s+10, US\"domain list\");\n\n  else if (Ustrncmp(s, \"hostlist\", 8) == 0)\n    read_named_list(&hostlist_anchor, &hostlist_count,\n      MAX_NAMED_LIST, s+8, US\"host list\");\n\n  else if (Ustrncmp(s, US\"addresslist\", 11) == 0)\n    read_named_list(&addresslist_anchor, &addresslist_count,\n      MAX_NAMED_LIST, s+11, US\"address list\");\n\n  else if (Ustrncmp(s, US\"localpartlist\", 13) == 0)\n    read_named_list(&localpartlist_anchor, &localpartlist_count,\n      MAX_NAMED_LIST, s+13, US\"local part list\");\n\n  else\n    (void) readconf_handle_option(s, optionlist_config, optionlist_config_size,\n      NULL, US\"main option \\\"%s\\\" unknown\");\n  }\n\n\n/* If local_sender_retain is set, local_from_check must be unset. */\n\nif (local_sender_retain && local_from_check)\n  log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"both local_from_check and \"\n    \"local_sender_retain are set; this combination is not allowed\");\n\n/* If the timezone string is empty, set it to NULL, implying no TZ variable\nwanted. */\n\nif (timezone_string != NULL && *timezone_string == 0) timezone_string = NULL;\n\n/* The max retry interval must not be greater than 24 hours. */\n\nif (retry_interval_max > 24*60*60) retry_interval_max = 24*60*60;\n\n/* remote_max_parallel must be > 0 */\n\nif (remote_max_parallel <= 0) remote_max_parallel = 1;\n\n/* Save the configured setting of freeze_tell, so we can re-instate it at the\nstart of a new SMTP message. */\n\nfreeze_tell_config = freeze_tell;\n\n/* The primary host name may be required for expansion of spool_directory\nand log_file_path, so make sure it is set asap. It is obtained from uname(),\nbut if that yields an unqualified value, make a FQDN by using gethostbyname to\ncanonize it. Some people like upper case letters in their host names, so we\ndon't force the case. */\n\nif (primary_hostname == NULL)\n  {\n  uschar *hostname;\n  struct utsname uts;\n  if (uname(&uts) < 0)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"uname() failed to yield host name\");\n  hostname = US uts.nodename;\n\n  if (Ustrchr(hostname, '.') == NULL)\n    {\n    int af = AF_INET;\n    struct hostent *hostdata;\n\n    #if HAVE_IPV6\n    if (!disable_ipv6 && (dns_ipv4_lookup == NULL ||\n         match_isinlist(hostname, &dns_ipv4_lookup, 0, NULL, NULL, MCL_DOMAIN,\n           TRUE, NULL) != OK))\n      af = AF_INET6;\n    #else\n    af = AF_INET;\n    #endif\n\n    for (;;)\n      {\n      #if HAVE_IPV6\n        #if HAVE_GETIPNODEBYNAME\n        int error_num;\n        hostdata = getipnodebyname(CS hostname, af, 0, &error_num);\n        #else\n        hostdata = gethostbyname2(CS hostname, af);\n        #endif\n      #else\n      hostdata = gethostbyname(CS hostname);\n      #endif\n\n      if (hostdata != NULL)\n        {\n        hostname = US hostdata->h_name;\n        break;\n        }\n\n      if (af == AF_INET) break;\n      af = AF_INET;\n      }\n    }\n\n  primary_hostname = string_copy(hostname);\n  }\n\n/* Set up default value for smtp_active_hostname */\n\nsmtp_active_hostname = primary_hostname;\n\n/* If spool_directory wasn't set in the build-time configuration, it must have\ngot set above. Of course, writing to the log may not work if log_file_path is\nnot set, but it will at least get to syslog or somewhere, with any luck. */\n\nif (*spool_directory == 0)\n  log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"spool_directory undefined: cannot \"\n    \"proceed\");\n\n/* Expand the spool directory name; it may, for example, contain the primary\nhost name. Same comment about failure. */\n\ns = expand_string(spool_directory);\nif (s == NULL)\n  log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to expand spool_directory \"\n    \"\\\"%s\\\": %s\", spool_directory, expand_string_message);\nspool_directory = s;\n\n/* Expand log_file_path, which must contain \"%s\" in any component that isn't\nthe null string or \"syslog\". It is also allowed to contain one instance of %D.\nHowever, it must NOT contain % followed by anything else. */\n\nif (*log_file_path != 0)\n  {\n  uschar *ss, *sss;\n  int sep = ':';                       /* Fixed for log file path */\n  s = expand_string(log_file_path);\n  if (s == NULL)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to expand log_file_path \"\n      \"\\\"%s\\\": %s\", log_file_path, expand_string_message);\n\n  ss = s;\n  while ((sss = string_nextinlist(&ss,&sep,big_buffer,big_buffer_size)) != NULL)\n    {\n    uschar *t;\n    if (sss[0] == 0 || Ustrcmp(sss, \"syslog\") == 0) continue;\n    t = Ustrstr(sss, \"%s\");\n    if (t == NULL)\n      log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"log_file_path \\\"%s\\\" does not \"\n        \"contain \\\"%%s\\\"\", sss);\n    *t = 'X';\n    t = Ustrchr(sss, '%');\n    if (t != NULL)\n      {\n      if (t[1] != 'D' || Ustrchr(t+2, '%') != NULL)\n        log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"log_file_path \\\"%s\\\" contains \"\n          \"unexpected \\\"%%\\\" character\", s);\n      }\n    }\n\n  log_file_path = s;\n  }\n\n/* Interpret syslog_facility into an integer argument for 'ident' param to\nopenlog(). Default is LOG_MAIL set in globals.c. Allow the user to omit the\nleading \"log_\". */\n\nif (syslog_facility_str != NULL)\n  {\n  int i;\n  uschar *s = syslog_facility_str;\n\n  if ((Ustrlen(syslog_facility_str) >= 4) &&\n        (strncmpic(syslog_facility_str, US\"log_\", 4) == 0))\n    s += 4;\n\n  for (i = 0; i < syslog_list_size; i++)\n    {\n    if (strcmpic(s, syslog_list[i].name) == 0)\n      {\n      syslog_facility = syslog_list[i].value;\n      break;\n      }\n    }\n\n  if (i >= syslog_list_size)\n    {\n    log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n      \"failed to interpret syslog_facility \\\"%s\\\"\", syslog_facility_str);\n    }\n  }\n\n/* Expand pid_file_path */\n\nif (*pid_file_path != 0)\n  {\n  s = expand_string(pid_file_path);\n  if (s == NULL)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to expand pid_file_path \"\n      \"\\\"%s\\\": %s\", pid_file_path, expand_string_message);\n  pid_file_path = s;\n  }\n\n/* Compile the regex for matching a UUCP-style \"From_\" line in an incoming\nmessage. */\n\nregex_From = regex_must_compile(uucp_from_pattern, FALSE, TRUE);\n\n/* Unpick the SMTP rate limiting options, if set */\n\nif (smtp_ratelimit_mail != NULL)\n  {\n  unpick_ratelimit(smtp_ratelimit_mail, &smtp_rlm_threshold,\n    &smtp_rlm_base, &smtp_rlm_factor, &smtp_rlm_limit);\n  }\n\nif (smtp_ratelimit_rcpt != NULL)\n  {\n  unpick_ratelimit(smtp_ratelimit_rcpt, &smtp_rlr_threshold,\n    &smtp_rlr_base, &smtp_rlr_factor, &smtp_rlr_limit);\n  }\n\n/* The qualify domains default to the primary host name */\n\nif (qualify_domain_sender == NULL)\n  qualify_domain_sender = primary_hostname;\nif (qualify_domain_recipient == NULL)\n  qualify_domain_recipient = qualify_domain_sender;\n\n/* Setting system_filter_user in the configuration sets the gid as well if a\nname is given, but a numerical value does not. */\n\nif (system_filter_uid_set && !system_filter_gid_set)\n  {\n  struct passwd *pw = getpwuid(system_filter_uid);\n  if (pw == NULL)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"Failed to look up uid %ld\",\n      (long int)system_filter_uid);\n  system_filter_gid = pw->pw_gid;\n  system_filter_gid_set = TRUE;\n  }\n\n/* If the errors_reply_to field is set, check that it is syntactically valid\nand ensure it contains a domain. */\n\nif (errors_reply_to != NULL)\n  {\n  uschar *errmess;\n  int start, end, domain;\n  uschar *recipient = parse_extract_address(errors_reply_to, &errmess,\n    &start, &end, &domain, FALSE);\n\n  if (recipient == NULL)\n    log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n      \"error in errors_reply_to (%s): %s\", errors_reply_to, errmess);\n\n  if (domain == 0)\n    log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n      \"errors_reply_to (%s) does not contain a domain\", errors_reply_to);\n  }\n\n/* If smtp_accept_queue or smtp_accept_max_per_host is set, then\nsmtp_accept_max must also be set. */\n\nif (smtp_accept_max == 0 &&\n    (smtp_accept_queue > 0 || smtp_accept_max_per_host != NULL))\n  log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n    \"smtp_accept_max must be set if smtp_accept_queue or \"\n    \"smtp_accept_max_per_host is set\");\n\n/* Set up the host number if anything is specified. It is an expanded string\nso that it can be computed from the host name, for example. We do this last\nso as to ensure that everything else is set up before the expansion. */\n\nif (host_number_string != NULL)\n  {\n  uschar *end;\n  uschar *s = expand_string(host_number_string);\n  long int n = Ustrtol(s, &end, 0);\n  while (isspace(*end)) end++;\n  if (*end != 0)\n    log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n      \"localhost_number value is not a number: %s\", s);\n  if (n > LOCALHOST_MAX)\n    log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n      \"localhost_number is greater than the maximum allowed value (%d)\",\n        LOCALHOST_MAX);\n  host_number = n;\n  }\n\n#ifdef SUPPORT_TLS\n/* If tls_verify_hosts is set, tls_verify_certificates must also be set */\n\nif ((tls_verify_hosts != NULL || tls_try_verify_hosts != NULL) &&\n     tls_verify_certificates == NULL)\n  log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n    \"tls_%sverify_hosts is set, but tls_verify_certificates is not set\",\n    (tls_verify_hosts != NULL)? \"\" : \"try_\");\n\n/* If openssl_options is set, validate it */\nif (openssl_options != NULL)\n  {\n# ifdef USE_GNUTLS\n  log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n    \"openssl_options is set but we're using GnuTLS\");\n# else\n  long dummy;\n  if (!(tls_openssl_options_parse(openssl_options, &dummy)))\n    log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n      \"openssl_options parse error: %s\", openssl_options);\n# endif\n  }\n#endif\n}",
        "target": 1
    },
    {
        "func": "readconf_main(void)\n{\nint sep = 0;\nstruct stat statbuf;\nuschar *s, *filename;\nuschar *list = config_main_filelist;\n\n/* Loop through the possible file names */\n\nwhile((filename = string_nextinlist(&list, &sep, big_buffer, big_buffer_size))\n       != NULL)\n  {\n  /* Cut out all the fancy processing unless specifically wanted */\n\n  #if defined(CONFIGURE_FILE_USE_NODE) || defined(CONFIGURE_FILE_USE_EUID)\n  uschar *suffix = filename + Ustrlen(filename);\n\n  /* Try for the node-specific file if a node name exists */\n\n  #ifdef CONFIGURE_FILE_USE_NODE\n  struct utsname uts;\n  if (uname(&uts) >= 0)\n    {\n    #ifdef CONFIGURE_FILE_USE_EUID\n    sprintf(CS suffix, \".%ld.%.256s\", (long int)original_euid, uts.nodename);\n    config_file = Ufopen(filename, \"rb\");\n    if (config_file == NULL)\n    #endif  /* CONFIGURE_FILE_USE_EUID */\n      {\n      sprintf(CS suffix, \".%.256s\", uts.nodename);\n      config_file = Ufopen(filename, \"rb\");\n      }\n    }\n  #endif  /* CONFIGURE_FILE_USE_NODE */\n\n  /* Otherwise, try the generic name, possibly with the euid added */\n\n  #ifdef CONFIGURE_FILE_USE_EUID\n  if (config_file == NULL)\n    {\n    sprintf(CS suffix, \".%ld\", (long int)original_euid);\n    config_file = Ufopen(filename, \"rb\");\n    }\n  #endif  /* CONFIGURE_FILE_USE_EUID */\n\n  /* Finally, try the unadorned name */\n\n  if (config_file == NULL)\n    {\n    *suffix = 0;\n    config_file = Ufopen(filename, \"rb\");\n    }\n  #else  /* if neither defined */\n\n  /* This is the common case when the fancy processing is not included. */\n\n  config_file = Ufopen(filename, \"rb\");\n  #endif\n\n  /* If the file does not exist, continue to try any others. For any other\n  error, break out (and die). */\n\n  if (config_file != NULL || errno != ENOENT) break;\n  }\n\n/* On success, save the name for verification; config_filename is used when\nlogging configuration errors (it changes for .included files) whereas\nconfig_main_filename is the name shown by -bP. Failure to open a configuration\nfile is a serious disaster. */\n\nif (config_file != NULL)\n  {\n  config_filename = config_main_filename = string_copy(filename);\n  }\nelse\n  {\n  if (filename == NULL)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"non-existent configuration file(s): \"\n      \"%s\", config_main_filelist);\n  else\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"%s\", string_open_failed(errno,\n      \"configuration file %s\", filename));\n  }\n\n/* Check the status of the file we have opened, unless it was specified on\nthe command line, in which case privilege was given away at the start. */\n\nif (!config_changed)\n  {\n  if (fstat(fileno(config_file), &statbuf) != 0)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to stat configuration file %s\",\n      big_buffer);\n\n  if ((statbuf.st_uid != root_uid &&             /* owner not root */\n       statbuf.st_uid != exim_uid                /* owner not exim */\n       #ifdef CONFIGURE_OWNER\n       && statbuf.st_uid != config_uid           /* owner not the special one */\n       #endif\n         ) ||                                    /* or */\n      (statbuf.st_gid != exim_gid                /* group not exim & */\n       #ifdef CONFIGURE_GROUP\n       && statbuf.st_gid != config_gid           /* group not the special one */\n       #endif\n       && (statbuf.st_mode & 020) != 0) ||       /* group writeable  */\n                                                 /* or */\n      ((statbuf.st_mode & 2) != 0))              /* world writeable  */\n\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"Exim configuration file %s has the \"\n      \"wrong owner, group, or mode\", big_buffer);\n  }\n\n/* Process the main configuration settings. They all begin with a lower case\nletter. If we see something starting with an upper case letter, it is taken as\na macro definition. */\n\nwhile ((s = get_config_line()) != NULL)\n  {\n  if (isupper(s[0])) read_macro_assignment(s);\n\n  else if (Ustrncmp(s, \"domainlist\", 10) == 0)\n    read_named_list(&domainlist_anchor, &domainlist_count,\n      MAX_NAMED_LIST, s+10, US\"domain list\");\n\n  else if (Ustrncmp(s, \"hostlist\", 8) == 0)\n    read_named_list(&hostlist_anchor, &hostlist_count,\n      MAX_NAMED_LIST, s+8, US\"host list\");\n\n  else if (Ustrncmp(s, US\"addresslist\", 11) == 0)\n    read_named_list(&addresslist_anchor, &addresslist_count,\n      MAX_NAMED_LIST, s+11, US\"address list\");\n\n  else if (Ustrncmp(s, US\"localpartlist\", 13) == 0)\n    read_named_list(&localpartlist_anchor, &localpartlist_count,\n      MAX_NAMED_LIST, s+13, US\"local part list\");\n\n  else\n    (void) readconf_handle_option(s, optionlist_config, optionlist_config_size,\n      NULL, US\"main option \\\"%s\\\" unknown\");\n  }\n\n\n/* If local_sender_retain is set, local_from_check must be unset. */\n\nif (local_sender_retain && local_from_check)\n  log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"both local_from_check and \"\n    \"local_sender_retain are set; this combination is not allowed\");\n\n/* If the timezone string is empty, set it to NULL, implying no TZ variable\nwanted. */\n\nif (timezone_string != NULL && *timezone_string == 0) timezone_string = NULL;\n\n/* The max retry interval must not be greater than 24 hours. */\n\nif (retry_interval_max > 24*60*60) retry_interval_max = 24*60*60;\n\n/* remote_max_parallel must be > 0 */\n\nif (remote_max_parallel <= 0) remote_max_parallel = 1;\n\n/* Save the configured setting of freeze_tell, so we can re-instate it at the\nstart of a new SMTP message. */\n\nfreeze_tell_config = freeze_tell;\n\n/* The primary host name may be required for expansion of spool_directory\nand log_file_path, so make sure it is set asap. It is obtained from uname(),\nbut if that yields an unqualified value, make a FQDN by using gethostbyname to\ncanonize it. Some people like upper case letters in their host names, so we\ndon't force the case. */\n\nif (primary_hostname == NULL)\n  {\n  uschar *hostname;\n  struct utsname uts;\n  if (uname(&uts) < 0)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"uname() failed to yield host name\");\n  hostname = US uts.nodename;\n\n  if (Ustrchr(hostname, '.') == NULL)\n    {\n    int af = AF_INET;\n    struct hostent *hostdata;\n\n    #if HAVE_IPV6\n    if (!disable_ipv6 && (dns_ipv4_lookup == NULL ||\n         match_isinlist(hostname, &dns_ipv4_lookup, 0, NULL, NULL, MCL_DOMAIN,\n           TRUE, NULL) != OK))\n      af = AF_INET6;\n    #else\n    af = AF_INET;\n    #endif\n\n    for (;;)\n      {\n      #if HAVE_IPV6\n        #if HAVE_GETIPNODEBYNAME\n        int error_num;\n        hostdata = getipnodebyname(CS hostname, af, 0, &error_num);\n        #else\n        hostdata = gethostbyname2(CS hostname, af);\n        #endif\n      #else\n      hostdata = gethostbyname(CS hostname);\n      #endif\n\n      if (hostdata != NULL)\n        {\n        hostname = US hostdata->h_name;\n        break;\n        }\n\n      if (af == AF_INET) break;\n      af = AF_INET;\n      }\n    }\n\n  primary_hostname = string_copy(hostname);\n  }\n\n/* Set up default value for smtp_active_hostname */\n\nsmtp_active_hostname = primary_hostname;\n\n/* If spool_directory wasn't set in the build-time configuration, it must have\ngot set above. Of course, writing to the log may not work if log_file_path is\nnot set, but it will at least get to syslog or somewhere, with any luck. */\n\nif (*spool_directory == 0)\n  log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"spool_directory undefined: cannot \"\n    \"proceed\");\n\n/* Expand the spool directory name; it may, for example, contain the primary\nhost name. Same comment about failure. */\n\ns = expand_string(spool_directory);\nif (s == NULL)\n  log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to expand spool_directory \"\n    \"\\\"%s\\\": %s\", spool_directory, expand_string_message);\nspool_directory = s;\n\n/* Expand log_file_path, which must contain \"%s\" in any component that isn't\nthe null string or \"syslog\". It is also allowed to contain one instance of %D.\nHowever, it must NOT contain % followed by anything else. */\n\nif (*log_file_path != 0)\n  {\n  uschar *ss, *sss;\n  int sep = ':';                       /* Fixed for log file path */\n  s = expand_string(log_file_path);\n  if (s == NULL)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to expand log_file_path \"\n      \"\\\"%s\\\": %s\", log_file_path, expand_string_message);\n\n  ss = s;\n  while ((sss = string_nextinlist(&ss,&sep,big_buffer,big_buffer_size)) != NULL)\n    {\n    uschar *t;\n    if (sss[0] == 0 || Ustrcmp(sss, \"syslog\") == 0) continue;\n    t = Ustrstr(sss, \"%s\");\n    if (t == NULL)\n      log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"log_file_path \\\"%s\\\" does not \"\n        \"contain \\\"%%s\\\"\", sss);\n    *t = 'X';\n    t = Ustrchr(sss, '%');\n    if (t != NULL)\n      {\n      if (t[1] != 'D' || Ustrchr(t+2, '%') != NULL)\n        log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"log_file_path \\\"%s\\\" contains \"\n          \"unexpected \\\"%%\\\" character\", s);\n      }\n    }\n\n  log_file_path = s;\n  }\n\n/* Interpret syslog_facility into an integer argument for 'ident' param to\nopenlog(). Default is LOG_MAIL set in globals.c. Allow the user to omit the\nleading \"log_\". */\n\nif (syslog_facility_str != NULL)\n  {\n  int i;\n  uschar *s = syslog_facility_str;\n\n  if ((Ustrlen(syslog_facility_str) >= 4) &&\n        (strncmpic(syslog_facility_str, US\"log_\", 4) == 0))\n    s += 4;\n\n  for (i = 0; i < syslog_list_size; i++)\n    {\n    if (strcmpic(s, syslog_list[i].name) == 0)\n      {\n      syslog_facility = syslog_list[i].value;\n      break;\n      }\n    }\n\n  if (i >= syslog_list_size)\n    {\n    log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n      \"failed to interpret syslog_facility \\\"%s\\\"\", syslog_facility_str);\n    }\n  }\n\n/* Expand pid_file_path */\n\nif (*pid_file_path != 0)\n  {\n  s = expand_string(pid_file_path);\n  if (s == NULL)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to expand pid_file_path \"\n      \"\\\"%s\\\": %s\", pid_file_path, expand_string_message);\n  pid_file_path = s;\n  }\n\n/* Compile the regex for matching a UUCP-style \"From_\" line in an incoming\nmessage. */\n\nregex_From = regex_must_compile(uucp_from_pattern, FALSE, TRUE);\n\n/* Unpick the SMTP rate limiting options, if set */\n\nif (smtp_ratelimit_mail != NULL)\n  {\n  unpick_ratelimit(smtp_ratelimit_mail, &smtp_rlm_threshold,\n    &smtp_rlm_base, &smtp_rlm_factor, &smtp_rlm_limit);\n  }\n\nif (smtp_ratelimit_rcpt != NULL)\n  {\n  unpick_ratelimit(smtp_ratelimit_rcpt, &smtp_rlr_threshold,\n    &smtp_rlr_base, &smtp_rlr_factor, &smtp_rlr_limit);\n  }\n\n/* The qualify domains default to the primary host name */\n\nif (qualify_domain_sender == NULL)\n  qualify_domain_sender = primary_hostname;\nif (qualify_domain_recipient == NULL)\n  qualify_domain_recipient = qualify_domain_sender;\n\n/* Setting system_filter_user in the configuration sets the gid as well if a\nname is given, but a numerical value does not. */\n\nif (system_filter_uid_set && !system_filter_gid_set)\n  {\n  struct passwd *pw = getpwuid(system_filter_uid);\n  if (pw == NULL)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"Failed to look up uid %ld\",\n      (long int)system_filter_uid);\n  system_filter_gid = pw->pw_gid;\n  system_filter_gid_set = TRUE;\n  }\n\n/* If the errors_reply_to field is set, check that it is syntactically valid\nand ensure it contains a domain. */\n\nif (errors_reply_to != NULL)\n  {\n  uschar *errmess;\n  int start, end, domain;\n  uschar *recipient = parse_extract_address(errors_reply_to, &errmess,\n    &start, &end, &domain, FALSE);\n\n  if (recipient == NULL)\n    log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n      \"error in errors_reply_to (%s): %s\", errors_reply_to, errmess);\n\n  if (domain == 0)\n    log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n      \"errors_reply_to (%s) does not contain a domain\", errors_reply_to);\n  }\n\n/* If smtp_accept_queue or smtp_accept_max_per_host is set, then\nsmtp_accept_max must also be set. */\n\nif (smtp_accept_max == 0 &&\n    (smtp_accept_queue > 0 || smtp_accept_max_per_host != NULL))\n  log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n    \"smtp_accept_max must be set if smtp_accept_queue or \"\n    \"smtp_accept_max_per_host is set\");\n\n/* Set up the host number if anything is specified. It is an expanded string\nso that it can be computed from the host name, for example. We do this last\nso as to ensure that everything else is set up before the expansion. */\n\nif (host_number_string != NULL)\n  {\n  uschar *end;\n  uschar *s = expand_string(host_number_string);\n  long int n = Ustrtol(s, &end, 0);\n  while (isspace(*end)) end++;\n  if (*end != 0)\n    log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n      \"localhost_number value is not a number: %s\", s);\n  if (n > LOCALHOST_MAX)\n    log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n      \"localhost_number is greater than the maximum allowed value (%d)\",\n        LOCALHOST_MAX);\n  host_number = n;\n  }\n\n#ifdef SUPPORT_TLS\n/* If tls_verify_hosts is set, tls_verify_certificates must also be set */\n\nif ((tls_verify_hosts != NULL || tls_try_verify_hosts != NULL) &&\n     tls_verify_certificates == NULL)\n  log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n    \"tls_%sverify_hosts is set, but tls_verify_certificates is not set\",\n    (tls_verify_hosts != NULL)? \"\" : \"try_\");\n\n/* If openssl_options is set, validate it */\nif (openssl_options != NULL)\n  {\n# ifdef USE_GNUTLS\n  log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n    \"openssl_options is set but we're using GnuTLS\");\n# else\n  long dummy;\n  if (!(tls_openssl_options_parse(openssl_options, &dummy)))\n    log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n      \"openssl_options parse error: %s\", openssl_options);\n# endif\n  }\n#endif\n}",
        "target": 1
    },
    {
        "func": "\nstatic int\nxmlXPathCompOpEvalPositionalPredicate(xmlXPathParserContextPtr ctxt,\n\t\t\t\t      xmlXPathStepOpPtr op,\n\t\t\t\t      xmlNodeSetPtr set,\n\t\t\t\t      int contextSize,\n\t\t\t\t      int minPos,\n\t\t\t\t      int maxPos,\n\t\t\t\t      int hasNsNodes)\n{\n    if (op->ch1 != -1) {\n\txmlXPathCompExprPtr comp = ctxt->comp;\n\tif (comp->steps[op->ch1].op != XPATH_OP_PREDICATE) {\n\t    /*\n\t    * TODO: raise an internal error.\n\t    */\n\t}\n\tcontextSize = xmlXPathCompOpEvalPredicate(ctxt,\n\t    &comp->steps[op->ch1], set, contextSize, hasNsNodes);\n\tCHECK_ERROR0;\n\tif (contextSize <= 0)\n\t    return(0);\n    }\n    /*\n    * Check if the node set contains a sufficient number of nodes for\n    * the requested range.\n    */\n    if (contextSize < minPos) {\n\txmlXPathNodeSetClear(set, hasNsNodes);\n\treturn(0);\n    }\n    if (op->ch2 == -1) {\n\t/*\n\t* TODO: Can this ever happen?\n\t*/\n\treturn (contextSize);\n    } else {\n\txmlDocPtr oldContextDoc;\n\tint i, pos = 0, newContextSize = 0, contextPos = 0, res;\n\txmlXPathStepOpPtr exprOp;\n\txmlXPathObjectPtr contextObj = NULL, exprRes = NULL;\n\txmlNodePtr oldContextNode, contextNode = NULL;\n\txmlXPathContextPtr xpctxt = ctxt->context;\n\n#ifdef LIBXML_XPTR_ENABLED\n\t    /*\n\t    * URGENT TODO: Check the following:\n\t    *  We don't expect location sets if evaluating prediates, right?\n\t    *  Only filters should expect location sets, right?\n\t*/\n#endif /* LIBXML_XPTR_ENABLED */\n\n\t/*\n\t* Save old context.\n\t*/\n\toldContextNode = xpctxt->node;\n\toldContextDoc = xpctxt->doc;\n\t/*\n\t* Get the expression of this predicate.\n\t*/\n\texprOp = &ctxt->comp->steps[op->ch2];\n\tfor (i = 0; i < set->nodeNr; i++) {\n\t    if (set->nodeTab[i] == NULL)\n\t\tcontinue;\n\n\t    contextNode = set->nodeTab[i];\n\t    xpctxt->node = contextNode;\n\t    xpctxt->contextSize = contextSize;\n\t    xpctxt->proximityPosition = ++contextPos;\n\n\t    /*\n\t    * Initialize the new set.\n\t    * Also set the xpath document in case things like\n\t    * key() evaluation are attempted on the predicate\n\t    */\n\t    if ((contextNode->type != XML_NAMESPACE_DECL) &&\n\t\t(contextNode->doc != NULL))\n\t\txpctxt->doc = contextNode->doc;\n\t    /*\n\t    * Evaluate the predicate expression with 1 context node\n\t    * at a time; this node is packaged into a node set; this\n\t    * node set is handed over to the evaluation mechanism.\n\t    */\n\t    if (contextObj == NULL)\n\t\tcontextObj = xmlXPathCacheNewNodeSet(xpctxt, contextNode);\n\t    else\n\t\txmlXPathNodeSetAddUnique(contextObj->nodesetval,\n\t\t    contextNode);\n\n\t    valuePush(ctxt, contextObj);\n\t    res = xmlXPathCompOpEvalToBoolean(ctxt, exprOp, 1);\n\n\t    if ((ctxt->error != XPATH_EXPRESSION_OK) || (res == -1)) {\n\t        xmlXPathObjectPtr tmp;\n\t\t/* pop the result */\n\t\ttmp = valuePop(ctxt);\n\t\txmlXPathReleaseObject(xpctxt, tmp);\n\t\t/* then pop off contextObj, which will be freed later */\n\t\tvaluePop(ctxt);\n\t\tgoto evaluation_error;\n\t    }\n\n\t    if (res)\n\t\tpos++;\n\n\t    if (res && (pos >= minPos) && (pos <= maxPos)) {\n\t\t/*\n\t\t* Fits in the requested range.\n\t\t*/\n\t\tnewContextSize++;\n\t\tif (minPos == maxPos) {\n\t\t    /*\n\t\t    * Only 1 node was requested.\n\t\t    */\n\t\t    if (contextNode->type == XML_NAMESPACE_DECL) {\n\t\t\t/*\n\t\t\t* As always: take care of those nasty\n\t\t\t* namespace nodes.\n\t\t\t*/\n\t\t\tset->nodeTab[i] = NULL;\n\t\t    }\n\t\t    xmlXPathNodeSetClear(set, hasNsNodes);\n\t\t    set->nodeNr = 1;\n\t\t    set->nodeTab[0] = contextNode;\n\t\t    goto evaluation_exit;\n\t\t}\n\t\tif (pos == maxPos) {\n\t\t    /*\n\t\t    * We are done.\n\t\t    */\n\t\t    xmlXPathNodeSetClearFromPos(set, i +1, hasNsNodes);\n\t\t    goto evaluation_exit;\n\t\t}\n\t    } else {\n\t\t/*\n\t\t* Remove the entry from the initial node set.\n\t\t*/\n\t\tset->nodeTab[i] = NULL;\n\t\tif (contextNode->type == XML_NAMESPACE_DECL)\n\t\t    xmlXPathNodeSetFreeNs((xmlNsPtr) contextNode);\n\t    }\n\t    if (exprRes != NULL) {\n\t\txmlXPathReleaseObject(ctxt->context, exprRes);\n\t\texprRes = NULL;\n\t    }\n\t    if (ctxt->value == contextObj) {\n\t\t/*\n\t\t* Don't free the temporary XPath object holding the\n\t\t* context node, in order to avoid massive recreation\n\t\t* inside this loop.\n\t\t*/\n\t\tvaluePop(ctxt);\n\t\txmlXPathNodeSetClear(contextObj->nodesetval, hasNsNodes);\n\t    } else {\n\t\t/*\n\t\t* The object was lost in the evaluation machinery.\n\t\t* Can this happen? Maybe in case of internal-errors.\n\t\t*/\n\t\tcontextObj = NULL;\n\t    }\n\t}\n\tgoto evaluation_exit;\n\nevaluation_error:\n\txmlXPathNodeSetClear(set, hasNsNodes);\n\tnewContextSize = 0;\n\nevaluation_exit:\n\tif (contextObj != NULL) {\n\t    if (ctxt->value == contextObj)\n\t\tvaluePop(ctxt);\n\t    xmlXPathReleaseObject(xpctxt, contextObj);\n\t}\n\tif (exprRes != NULL)\n\t    xmlXPathReleaseObject(ctxt->context, exprRes);\n\t/*\n\t* Reset/invalidate the context.\n\t*/\n\txpctxt->node = oldContextNode;\n\txpctxt->doc = oldContextDoc;\n\txpctxt->contextSize = -1;\n\txpctxt->proximityPosition = -1;\n\treturn(newContextSize);\n    }",
        "target": 1
    },
    {
        "func": "int\ttfm_load_file(const char *filename, TFMInfo *info)\n{\n\tint\tlf, lh, bc, ec, nw, nh, nd, ne;\n\tint\ti, n;\n\tUchar\t*tfm;\n\tUchar\t*ptr;\n\tstruct stat st;\n\tint\tsize;\n\tFILE\t*in;\n\tInt32\t*cb;\n\tInt32\t*charinfo;\n\tInt32\t*widths;\n\tInt32\t*heights;\n\tInt32\t*depths;\n\tUint32\tchecksum;\n\n\tin = fopen(filename, \"rb\");\n\tif(in == NULL)\n\t\treturn -1;\n\ttfm = NULL;\n\n\tDEBUG((DBG_FONTS, \"(mt) reading TFM file `%s'\\n\",\n\t\tfilename));\n\t/* We read the entire TFM file into core */\n\tif(fstat(fileno(in), &st) < 0)\n\t\treturn -1;\n\tif(st.st_size == 0)\n\t\tgoto bad_tfm;\n\n\t/* allocate a word-aligned buffer to hold the file */\n\tsize = 4 * ROUND(st.st_size, 4);\n\tif(size != st.st_size)\n\t\tmdvi_warning(_(\"Warning: TFM file `%s' has suspicious size\\n\"), \n\t\t\t     filename);\n\ttfm = (Uchar *)mdvi_malloc(size);\n\tif(fread(tfm, st.st_size, 1, in) != 1)\n\t\tgoto error;\n\t/* we don't need this anymore */\n\tfclose(in);\n\tin = NULL;\n\n\t/* not a checksum, but serves a similar purpose */\n\tchecksum = 0;\n\t\n\tptr = tfm;\n\t/* get the counters */\n\tlf = muget2(ptr);\n\tlh = muget2(ptr); checksum += 6 + lh;\n\tbc = muget2(ptr); \n\tec = muget2(ptr); checksum += ec - bc + 1;\n\tnw = muget2(ptr); checksum += nw;\n\tnh = muget2(ptr); checksum += nh;\n\tnd = muget2(ptr); checksum += nd;\n\tchecksum += muget2(ptr); /* skip italics correction count */\n\tchecksum += muget2(ptr); /* skip lig/kern table size */\n\tchecksum += muget2(ptr); /* skip kern table size */\n\tne = muget2(ptr); checksum += ne;\n\tchecksum += muget2(ptr); /* skip # of font parameters */\n\n\tsize = ec - bc + 1;\n\tcb = (Int32 *)tfm; cb += 6 + lh;\n\tcharinfo    = cb;  cb += size;\n\twidths      = cb;  cb += nw;\n\theights     = cb;  cb += nh;\n\tdepths      = cb;\n\n\tif(widths[0] || heights[0] || depths[0] || \n\t   checksum != lf || bc - 1 > ec || ec > 255 || ne > 256)\n\t\tgoto bad_tfm;\n\n\t/* from this point on, no error checking is done */\n\n\t/* now we're at the header */\n\t/* get the checksum */\n\tinfo->checksum = muget4(ptr);\n\t/* get the design size */\n\tinfo->design = muget4(ptr);\n\t/* get the coding scheme */\n\tif(lh > 2) {\n\t\t/* get the coding scheme */\n\t\ti = n = msget1(ptr);\n\t\tif(n < 0 || n > 39) {\n\t\t\tmdvi_warning(_(\"%s: font coding scheme truncated to 40 bytes\\n\"),\n\t\t\t\t     filename);\n\t\t\tn = 39;\n\t\t}\n\t\tmemcpy(info->coding, ptr, n);\n\t\tinfo->coding[n] = 0;\n\t\tptr += i;\n\t} else\n\t\tstrcpy(info->coding, \"FontSpecific\");\n\t/* get the font family */\n\tif(lh > 12) {\n\t\tn = msget1(ptr);\n\t\tif(n > 0) {\n\t\t\ti = Max(n, 63);\n\t\t\tmemcpy(info->family, ptr, i);\n\t\t\tinfo->family[i] = 0;\n\t\t} else\n\t\t\tstrcpy(info->family, \"unspecified\");\n\t\tptr += n;\n\t}\n\t/* now we don't read from `ptr' anymore */\n\t\n\tinfo->loc = bc;\n\tinfo->hic = ec;\n\tinfo->type = DviFontTFM;\n\n\t/* allocate characters */\n\tinfo->chars = xnalloc(TFMChar, size);\n\n\n#ifdef WORD_LITTLE_ENDIAN\n\t/* byte-swap the three arrays at once (they are consecutive in memory) */\n\tswap_array((Uint32 *)widths, nw + nh + nd);\n#endif\n\n\t/* get the relevant data */\n\tptr = (Uchar *)charinfo;\n\tfor(i = bc; i <= ec; ptr += 3, i++) {\n\t\tint\tndx;\n\n\t\tndx = (int)*ptr; ptr++;\n\t\tinfo->chars[i-bc].advance = widths[ndx];\n\t\t/* TFM files lack this information */\n\t\tinfo->chars[i-bc].left = 0;\n\t\tinfo->chars[i-bc].right = widths[ndx];\n\t\tinfo->chars[i-bc].present = (ndx != 0);\n\t\tif(ndx) {\n\t\t\tndx = ((*ptr >> 4) & 0xf);\n\t\t\tinfo->chars[i-bc].height = heights[ndx];\n\t\t\tndx = (*ptr & 0xf);\n\t\t\tinfo->chars[i-bc].depth = depths[ndx];\n\t\t}\n\t}\n\n\t/* free everything */\n\tmdvi_free(tfm);\n\t\n\treturn 0;\n\nbad_tfm:\n\tmdvi_error(_(\"%s: File corrupted, or not a TFM file\\n\"), filename);\nerror:\n\tif(tfm) mdvi_free(tfm);\n\tif(in)  fclose(in);\n\treturn -1;\t\n}",
        "target": 1
    },
    {
        "func": "static int pk_load_font(DviParams *unused, DviFont *font)\n{\n\tint\ti;\n\tint\tflag_byte;\n\tint\tloc, hic, maxch;\n\tInt32\tchecksum;\n\tFILE\t*p;\n#ifndef NODEBUG\n\tchar\ts[256];\n#endif\n\tlong\talpha, beta, z;\n\n\tfont->chars = xnalloc(DviFontChar, 256);\n\tp = font->in;\n\tmemzero(font->chars, 256 * sizeof(DviFontChar));\n\tfor(i = 0; i < 256; i++)\n\t\tfont->chars[i].offset = 0;\n\n\t/* check the preamble */\n\tloc = fuget1(p); hic = fuget1(p);\n\tif(loc != PK_PRE || hic != PK_ID)\n\t\tgoto badpk;\n\ti = fuget1(p);\n#ifndef NODEBUG\n\tfor(loc = 0; loc < i; loc++)\n\t\ts[loc] = fuget1(p);\n\ts[loc] = 0;\n\tDEBUG((DBG_FONTS, \"(pk) %s: %s\\n\", font->fontname, s));\n#else\n\tfseek(in, (long)i, SEEK_CUR);\n#endif\n\t/* get the design size */\n\tfont->design = fuget4(p);\n\t/* get the checksum */\n\tchecksum = fuget4(p);\n\tif(checksum && font->checksum && font->checksum != checksum) {\n\t\tmdvi_warning(_(\"%s: checksum mismatch (expected %u, got %u)\\n\"),\n\t\t\t     font->fontname, font->checksum, checksum);\n\t} else if(!font->checksum)\n\t\tfont->checksum = checksum;\n\t/* skip pixel per point ratios */\n\tfuget4(p);\n\tfuget4(p);\n\tif(feof(p))\n\t\tgoto badpk;\t\n\n\t/* now start reading the font */\n\tloc = 256; hic = -1; maxch = 256;\n\t\n\t/* initialize alpha and beta for TFM width computation */\n\tTFMPREPARE(font->scale, z, alpha, beta);\n\n\twhile((flag_byte = fuget1(p)) != PK_POST) {\n\t\tif(feof(p))\n\t\t\tbreak;\n\t\tif(flag_byte >= PK_CMD_START) {\n\t\t\tswitch(flag_byte) {\n\t\t\tcase PK_X1:\n\t\t\tcase PK_X2:\n\t\t\tcase PK_X3:\n\t\t\tcase PK_X4: {\n#ifndef NODEBUG\n\t\t\t\tchar\t*t;\n\t\t\t\tint\tn;\n\t\t\t\t\n\t\t\t\ti = fugetn(p, flag_byte - PK_X1 + 1);\n\t\t\t\tif(i < 256)\n\t\t\t\t\tt = &s[0];\n\t\t\t\telse\n\t\t\t\t\tt = mdvi_malloc(i + 1);\n\t\t\t\tfor(n = 0; n < i; n++)\n\t\t\t\t\tt[n] = fuget1(p);\n\t\t\t\tt[n] = 0;\n\t\t\t\tDEBUG((DBG_SPECIAL, \"(pk) %s: Special \\\"%s\\\"\\n\",\n\t\t\t\t\tfont->fontname, t));\n\t\t\t\tif(t != &s[0])\n\t\t\t\t\tmdvi_free(t);\n#else\n\t\t\t\ti = fugetn(p, flag_byte - PK_X1 + 1);\n\t\t\t\twhile(i-- > 0)\n\t\t\t\t\tfuget1(p);\n#endif\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase PK_Y:\n\t\t\t\ti = fuget4(p);\n\t\t\t\tDEBUG((DBG_SPECIAL, \"(pk) %s: MF special %u\\n\",\n\t\t\t\t\tfont->fontname, (unsigned)i));\n\t\t\t\tbreak;\n\t\t\tcase PK_POST:\n\t\t\tcase PK_NOOP:\n\t\t\t\tbreak;\n\t\t\tcase PK_PRE:\n\t\t\t\tmdvi_error(_(\"%s: unexpected preamble\\n\"), font->fontname);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t} else {\n\t\t\tint\tpl;\n\t\t\tint\tcc;\n\t\t\tint\tw, h;\n\t\t\tint\tx, y;\n\t\t\tint\toffset;\n\t\t\tlong\ttfm;\n\t\t\t\n\t\t\tswitch(flag_byte & 0x7) {\n\t\t\tcase 7:\n\t\t\t\tpl = fuget4(p);\n\t\t\t\tcc = fuget4(p);\n\t\t\t\toffset = ftell(p) + pl;\n\t\t\t\ttfm = fuget4(p);\n\t\t\t\tfsget4(p); /* skip dx */\n\t\t\t\tfsget4(p); /* skip dy */\n\t\t\t\tw  = fuget4(p);\n\t\t\t\th  = fuget4(p); \n\t\t\t\tx  = fsget4(p);\n\t\t\t\ty  = fsget4(p);\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\tcase 5:\n\t\t\tcase 6:\t\t\t\t\n\t\t\t\tpl = (flag_byte % 4) * 65536 + fuget2(p);\n\t\t\t\tcc = fuget1(p);\n\t\t\t\toffset = ftell(p) + pl;\n\t\t\t\ttfm = fuget3(p);\n\t\t\t\tfsget2(p); /* skip dx */\n\t\t\t\t           /* dy assumed 0 */\n\t\t\t\tw = fuget2(p);\n\t\t\t\th = fuget2(p);\n\t\t\t\tx = fsget2(p);\n\t\t\t\ty = fsget2(p);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpl = (flag_byte % 4) * 256 + fuget1(p);\n\t\t\t\tcc = fuget1(p);\n\t\t\t\toffset = ftell(p) + pl;\n\t\t\t\ttfm = fuget3(p);\n\t\t\t\tfsget1(p); /* skip dx */\n\t\t\t\t           /* dy assumed 0 */\n\t\t\t\tw = fuget1(p);\n\t\t\t\th = fuget1(p);\n\t\t\t\tx = fsget1(p);\n\t\t\t\ty = fsget1(p);\n\t\t\t}\n\t\t\tif(feof(p))\n\t\t\t\tbreak;\n\t\t\tif(cc < loc)\n\t\t\t\tloc = cc;\n\t\t\tif(cc > hic)\n\t\t\t\thic = cc;\n\t\t\tif(cc > maxch) {\n\t\t\t\tfont->chars = xresize(font->chars, \n\t\t\t\t\tDviFontChar, cc + 16);\n\t\t\t\tfor(i = maxch; i < cc + 16; i++)\n\t\t\t\t\tfont->chars[i].offset = 0;\n\t\t\t\tmaxch = cc + 16;\n\t\t\t}\n\t\t\tfont->chars[cc].code = cc;\n\t\t\tfont->chars[cc].flags = flag_byte;\n\t\t\tfont->chars[cc].offset = ftell(p);\n\t\t\tfont->chars[cc].width = w;\n\t\t\tfont->chars[cc].height = h;\n\t\t\tfont->chars[cc].glyph.data = NULL;\n\t\t\tfont->chars[cc].x = x;\n\t\t\tfont->chars[cc].y = y;\n\t\t\tfont->chars[cc].glyph.x = x;\n\t\t\tfont->chars[cc].glyph.y = y;\n\t\t\tfont->chars[cc].glyph.w = w;\n\t\t\tfont->chars[cc].glyph.h = h;\n\t\t\tfont->chars[cc].grey.data = NULL;\n\t\t\tfont->chars[cc].shrunk.data = NULL;\n\t\t\tfont->chars[cc].tfmwidth = TFMSCALE(z, tfm, alpha, beta);\n\t\t\tfont->chars[cc].loaded = 0;\n\t\t\tfseek(p, (long)offset, SEEK_SET);\n\t\t}\n\t}\n\tif(flag_byte != PK_POST) {\n\t\tmdvi_error(_(\"%s: unexpected end of file (no postamble)\\n\"),\n\t\t\t   font->fontname);\n\t\tgoto error;\n\t}\n\twhile((flag_byte = fuget1(p)) != EOF) {\n\t\tif(flag_byte != PK_NOOP) {\n\t\t\tmdvi_error(_(\"invalid PK file! (junk in postamble)\\n\"));\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t/* resize font char data */\n\tif(loc > 0 || hic < maxch-1) {\n\t\tmemmove(font->chars, font->chars + loc, \n\t\t\t(hic - loc + 1) * sizeof(DviFontChar));\n\t\tfont->chars = xresize(font->chars,\n\t\t\tDviFontChar, hic - loc + 1);\n\t}\n\tfont->loc = loc;\n\tfont->hic = hic;\t\t\n\treturn 0;\n\nbadpk:\n\tmdvi_error(_(\"%s: File corrupted, or not a PK file\\n\"), font->fontname);\nerror:\n\tmdvi_free(font->chars);\n\tfont->chars = NULL;\n\tfont->loc = font->hic = 0;\n\treturn -1;\n}",
        "target": 1
    },
    {
        "func": "int\tspecial(DviContext *dvi, int opcode)\n{\n\tchar\t*s;\n\tInt32\targ;\n\t\n\targ = dugetn(dvi, opcode - DVI_XXX1 + 1);\n\ts = mdvi_malloc(arg + 1);\n\tdread(dvi, s, arg);\n\ts[arg] = 0;\n\tmdvi_do_special(dvi, s);\n\tSHOWCMD((dvi, \"XXXX\", opcode - DVI_XXX1 + 1,\n\t\t\"[%s]\", s));\n\tmdvi_free(s);\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static char *token(FILE *stream)\n{\n    int ch, idx;\n\n    /* skip over white space */\n    while ((ch = fgetc(stream)) == ' ' || ch == lineterm || \n            ch == ',' || ch == '\\t' || ch == ';');\n    \n    idx = 0;\n    while (ch != EOF && ch != ' ' && ch != lineterm \n           && ch != '\\t' && ch != ':' && ch != ';') \n    {\n        ident[idx++] = ch;\n        ch = fgetc(stream);\n    } /* while */\n\n    if (ch == EOF && idx < 1) return ((char *)NULL);\n    if (idx >= 1 && ch != ':' ) ungetc(ch, stream);\n    if (idx < 1 ) ident[idx++] = ch;\t/* single-character token */\n    ident[idx] = 0;\n    \n    return(ident);\t/* returns pointer to the token */\n\n} /* token */",
        "target": 1
    },
    {
        "func": "static int vf_load_font(DviParams *params, DviFont *font)\n{\n\tFILE\t*p;\n\tUchar\t*macros;\n\tint\tmsize;\n\tint\tmlen;\n\tInt32\tchecksum;\n\tlong\talpha, beta, z;\n\tint\top;\n\tint\ti;\n\tint\tnchars;\n\tint\tloc, hic;\n\tDviFontRef *last;\n\t\n\tmacros = NULL;\n\tmsize = mlen = 0;\n\tp = font->in;\n\t\n\tif(fuget1(p) != 247 || fuget1(p) != 202)\n\t\tgoto badvf;\n\tmlen = fuget1(p);\n\tfseek(p, (long)mlen, SEEK_CUR);\n\tchecksum = fuget4(p);\n\tif(checksum && font->checksum && checksum != font->checksum) {\n\t\tmdvi_warning(_(\"%s: Checksum mismatch (expected %u, got %u)\\n\"),\n\t\t\t     font->fontname, font->checksum, checksum);\n\t} else if(!font->checksum)\n\t\tfont->checksum = checksum;\n\tfont->design = fuget4(p);\n\t\n\t/* read all the fonts in the preamble */\n\tlast = NULL;\n\n\t/* initialize alpha, beta and z for TFM width computation */\n\tTFMPREPARE(font->scale, z, alpha, beta);\n\n\top = fuget1(p);\t\n\twhile(op >= DVI_FNT_DEF1 && op <= DVI_FNT_DEF4) {\n\t\tDviFontRef *ref;\n\t\tInt32\tscale, design;\n\t\tUint32\tchecksum;\n\t\tint\tid;\n\t\tint\tn;\n\t\tint\thdpi;\n\t\tint\tvdpi;\n\t\tchar\t*name;\n\t\t\n\t\t/* process fnt_def commands */\n\t\t\n\t\tid = fugetn(p, op - DVI_FNT_DEF1 + 1);\n\t\tchecksum = fuget4(p);\n\t\tscale = fuget4(p);\n\t\tdesign = fuget4(p);\n\n\t\t/* scale this font according to our parent's scale */\n\t\tscale = TFMSCALE(scale, z, alpha, beta);\n\t\tdesign = FROUND(params->tfm_conv * design);\n\n\t\t/* compute the resolution */\n\t\thdpi = FROUND(params->mag * params->dpi * scale / design);\n\t\tvdpi = FROUND(params->mag * params->vdpi * scale / design);\n\t\tn = fuget1(p) + fuget1(p);\n\t\tname = mdvi_malloc(n + 1);\n\t\tfread(name, 1, n, p);\n\t\tname[n] = 0;\n\t\tDEBUG((DBG_FONTS, \"(vf) %s: defined font `%s' at %.1fpt (%dx%d dpi)\\n\",\n\t\t\tfont->fontname, name, \n\t\t\t(double)scale / (params->tfm_conv * 0x100000), hdpi, vdpi));\n\n\t\t/* get the font */\n\t\tref = font_reference(params, id, name, checksum, hdpi, vdpi, scale);\n\t\tif(ref == NULL) {\n\t\t\tmdvi_error(_(\"(vf) %s: could not load font `%s'\\n\"), \n\t\t\t\t   font->fontname, name);\n\t\t\tgoto error;\n\t\t}\n\t\tmdvi_free(name);\n\t\tif(last == NULL)\n\t\t\tfont->subfonts = last = ref;\n\t\telse\n\t\t\tlast->next = ref;\n\t\tref->next = NULL;\n\t\top = fuget1(p);\n\t}\n\t\n\tif(op >= DVI_FNT_DEF1 && op <= DVI_FNT_DEF4)\n\t\tgoto error;\n\n\t/* This function correctly reads both .vf and .ovf files */\n\t\n\tfont->chars = xnalloc(DviFontChar, 256);\n\tfor(i = 0; i < 256; i++)\n\t\tfont->chars[i].offset = 0;\n\tnchars = 256;\n\tloc = -1; hic = -1;\n\t/* now read the characters themselves */\n\twhile(op <= 242) {\n\t\tint\tpl;\n\t\tInt32\tcc;\n\t\tInt32\ttfm;\n\t\t\n\t\tif(op == 242) {\n\t\t\tpl = fuget4(p);\n\t\t\tcc = fuget4(p);\n\t\t\ttfm = fuget4(p);\n\t\t} else {\n\t\t\tpl = op;\n\t\t\tcc = fuget1(p);\n\t\t\ttfm = fuget3(p);\n\t\t}\n\t\tif(loc < 0 || cc < loc)\n\t\t\tloc = cc;\n\t\tif(hic < 0 || cc > hic)\n\t\t\thic = cc;\n\t\tif(cc >= nchars) {\n\t\t\tfont->chars = xresize(font->chars, \n\t\t\t\tDviFontChar, cc + 16);\n\t\t\tfor(i = nchars; i < cc + 16; i++)\n\t\t\t\tfont->chars[i].offset = 0;\n\t\t\tnchars = cc + 16;\n\t\t}\n\t\tif(font->chars[cc].offset) {\n\t\t\tmdvi_error(_(\"(vf) %s: character %d redefined\\n\"),\n\t\t\t\t   font->fontname, cc);\n\t\t\tgoto error;\n\t\t}\n\t\t\t\t\n\t\tDEBUG((DBG_GLYPHS, \"(vf) %s: defined character %d (macro length %d)\\n\",\n\t\t\tfont->fontname, cc, pl));\n\t\tfont->chars[cc].width = pl + 1;\n\t\tfont->chars[cc].code = cc;\n\t\tfont->chars[cc].tfmwidth = TFMSCALE(tfm, z, alpha, beta);\n\t\tfont->chars[cc].offset = mlen;\n\t\tfont->chars[cc].loaded = 1;\n\t\tif(mlen + pl + 1 > msize) {\n\t\t\tmsize = mlen + pl + 256;\n\t\t\tmacros = xresize(macros, Uchar, msize);\n\t\t}\n\t\tif(pl && fread(macros + mlen, 1, pl, p) != pl)\n\t\t\tbreak;\n\t\tmacros[mlen+pl] = DVI_EOP;\n\t\tmlen += pl + 1;\n\t\top = fuget1(p);\n\t}\n\tif(op != 248) {\n\t\tmdvi_error(_(\"(vf) %s: no postamble\\n\"), font->fontname);\n\t\tgoto error;\n\t}\n\n\t/* make macro memory just big enough */\n\tif(msize > mlen) {\n\t\tmacros = xresize(macros, Uchar, mlen);\n\t\tmsize = mlen;\n\t}\n\t\n\tDEBUG((DBG_FONTS|DBG_GLYPHS, \n\t\t\"(vf) %s: macros use %d bytes\\n\", font->fontname, msize));\n\n\tif(loc > 0 || hic < nchars-1) {\n\t\tmemmove(font->chars, font->chars + loc,\n\t\t\t(hic - loc + 1) * sizeof(DviFontChar));\n\t\tfont->chars = xresize(font->chars,\n\t\t\tDviFontChar, hic - loc + 1);\n\t}\n\tfont->loc = loc;\n\tfont->hic = hic;\n\tfont->private = macros;\n\n\treturn 0;\n\t\nbadvf:\n\tmdvi_error(_(\"%s: File corrupted, or not a VF file.\\n\"), font->fontname);\nerror:\n\tif(font->chars)\n\t\tmdvi_free(font->chars);\n\tif(macros)\n\t\tmdvi_free(macros);\n\treturn -1;\n}",
        "target": 1
    },
    {
        "func": "AvahiDnsPacket *avahi_recv_dns_packet_ipv6(\n        int fd,\n        AvahiIPv6Address *ret_src_address,\n        uint16_t *ret_src_port,\n        AvahiIPv6Address *ret_dst_address,\n        AvahiIfIndex *ret_iface,\n        uint8_t *ret_ttl) {\n\n    AvahiDnsPacket *p = NULL;\n    struct msghdr msg;\n    struct iovec io;\n    size_t aux[1024 / sizeof(size_t)];\n    ssize_t l;\n    int ms;\n    struct cmsghdr *cmsg;\n    int found_ttl = 0, found_iface = 0;\n    struct sockaddr_in6 sa;\n\n    assert(fd >= 0);\n\n    if (ioctl(fd, FIONREAD, &ms) < 0) {\n        avahi_log_warn(\"ioctl(): %s\", strerror(errno));\n        goto fail;\n    }\n\n    if (ms < 0) {\n        avahi_log_warn(\"FIONREAD returned negative value.\");\n        goto fail;\n    }\n\n    /* For corrupt packets FIONREAD returns zero size (See rhbz #607297) */\n    if (!ms)\n        goto fail;\n\n    p = avahi_dns_packet_new(ms + AVAHI_DNS_PACKET_EXTRA_SIZE);\n\n    io.iov_base = AVAHI_DNS_PACKET_DATA(p);\n    io.iov_len = p->max_size;\n\n    memset(&msg, 0, sizeof(msg));\n    msg.msg_name = (struct sockaddr*) &sa;\n    msg.msg_namelen = sizeof(sa);\n\n    msg.msg_iov = &io;\n    msg.msg_iovlen = 1;\n    msg.msg_control = aux;\n    msg.msg_controllen = sizeof(aux);\n    msg.msg_flags = 0;\n\n    if ((l = recvmsg(fd, &msg, 0)) < 0) {\n        /* Linux returns EAGAIN when an invalid IP packet has been\n        received. We suppress warnings in this case because this might\n        create quite a bit of log traffic on machines with unstable\n        links. (See #60) */\n\n        if (errno != EAGAIN)\n            avahi_log_warn(\"recvmsg(): %s\", strerror(errno));\n\n        goto fail;\n    }\n\n    assert(!(msg.msg_flags & MSG_CTRUNC));\n    assert(!(msg.msg_flags & MSG_TRUNC));\n\n    p->size = (size_t) l;\n\n    if (ret_src_port)\n        *ret_src_port = avahi_port_from_sockaddr((struct sockaddr*) &sa);\n\n    if (ret_src_address) {\n        AvahiAddress a;\n        avahi_address_from_sockaddr((struct sockaddr*) &sa, &a);\n        *ret_src_address = a.data.ipv6;\n    }\n\n    for (cmsg = CMSG_FIRSTHDR(&msg); cmsg != NULL; cmsg = CMSG_NXTHDR(&msg, cmsg)) {\n\n        if (cmsg->cmsg_level == IPPROTO_IPV6) {\n\n            switch (cmsg->cmsg_type) {\n\n                case IPV6_HOPLIMIT:\n\n                    if (ret_ttl)\n                        *ret_ttl = (uint8_t) (*(int *) CMSG_DATA(cmsg));\n\n                    found_ttl = 1;\n\n                    break;\n\n                case IPV6_PKTINFO: {\n                    struct in6_pktinfo *i = (struct in6_pktinfo*) CMSG_DATA(cmsg);\n\n                    if (ret_iface)\n                        *ret_iface = i->ipi6_ifindex;\n\n                    if (ret_dst_address)\n                        memcpy(ret_dst_address->address, i->ipi6_addr.s6_addr, 16);\n\n                    found_iface = 1;\n                    break;\n                }\n\n                default:\n                    avahi_log_warn(\"Unhandled cmsg_type : %d\", cmsg->cmsg_type);\n                    break;\n            }\n        }\n    }\n\n    assert(found_iface);\n    assert(found_ttl);\n\n    return p;\n\nfail:\n    if (p)\n        avahi_dns_packet_free(p);\n\n    return NULL;\n}",
        "target": 1
    },
    {
        "func": "AvahiDnsPacket *avahi_recv_dns_packet_ipv4(\n        int fd,\n        AvahiIPv4Address *ret_src_address,\n        uint16_t *ret_src_port,\n        AvahiIPv4Address *ret_dst_address,\n        AvahiIfIndex *ret_iface,\n        uint8_t *ret_ttl) {\n\n    AvahiDnsPacket *p= NULL;\n    struct msghdr msg;\n    struct iovec io;\n    size_t aux[1024 / sizeof(size_t)]; /* for alignment on ia64 ! */\n    ssize_t l;\n    struct cmsghdr *cmsg;\n    int found_addr = 0;\n    int ms;\n    struct sockaddr_in sa;\n\n    assert(fd >= 0);\n\n    if (ioctl(fd, FIONREAD, &ms) < 0) {\n        avahi_log_warn(\"ioctl(): %s\", strerror(errno));\n        goto fail;\n    }\n\n    if (ms < 0) {\n        avahi_log_warn(\"FIONREAD returned negative value.\");\n        goto fail;\n    }\n\n    /* For corrupt packets FIONREAD returns zero size (See rhbz #607297) */\n    if (!ms)\n        goto fail;\n\n    p = avahi_dns_packet_new(ms + AVAHI_DNS_PACKET_EXTRA_SIZE);\n\n    io.iov_base = AVAHI_DNS_PACKET_DATA(p);\n    io.iov_len = p->max_size;\n\n    memset(&msg, 0, sizeof(msg));\n    msg.msg_name = &sa;\n    msg.msg_namelen = sizeof(sa);\n    msg.msg_iov = &io;\n    msg.msg_iovlen = 1;\n    msg.msg_control = aux;\n    msg.msg_controllen = sizeof(aux);\n    msg.msg_flags = 0;\n\n    if ((l = recvmsg(fd, &msg, 0)) < 0) {\n        /* Linux returns EAGAIN when an invalid IP packet has been\n        received. We suppress warnings in this case because this might\n        create quite a bit of log traffic on machines with unstable\n        links. (See #60) */\n\n        if (errno != EAGAIN)\n            avahi_log_warn(\"recvmsg(): %s\", strerror(errno));\n\n        goto fail;\n    }\n\n    if (sa.sin_addr.s_addr == INADDR_ANY) {\n        /* Linux 2.4 behaves very strangely sometimes! */\n        goto fail;\n    }\n\n    assert(!(msg.msg_flags & MSG_CTRUNC));\n    assert(!(msg.msg_flags & MSG_TRUNC));\n\n    p->size = (size_t) l;\n\n    if (ret_src_port)\n        *ret_src_port = avahi_port_from_sockaddr((struct sockaddr*) &sa);\n\n    if (ret_src_address) {\n        AvahiAddress a;\n        avahi_address_from_sockaddr((struct sockaddr*) &sa, &a);\n        *ret_src_address = a.data.ipv4;\n    }\n\n    if (ret_ttl)\n        *ret_ttl = 255;\n\n    if (ret_iface)\n        *ret_iface = AVAHI_IF_UNSPEC;\n\n    for (cmsg = CMSG_FIRSTHDR(&msg); cmsg != NULL; cmsg = CMSG_NXTHDR(&msg, cmsg)) {\n\n        if (cmsg->cmsg_level == IPPROTO_IP) {\n\n            switch (cmsg->cmsg_type) {\n#ifdef IP_RECVTTL\n                case IP_RECVTTL:\n#endif\n                case IP_TTL:\n                    if (ret_ttl)\n                        *ret_ttl = (uint8_t) (*(int *) CMSG_DATA(cmsg));\n\n                    break;\n\n#ifdef IP_PKTINFO\n                case IP_PKTINFO: {\n                    struct in_pktinfo *i = (struct in_pktinfo*) CMSG_DATA(cmsg);\n\n                    if (ret_iface)\n                        *ret_iface = (int) i->ipi_ifindex;\n\n                    if (ret_dst_address)\n                        ret_dst_address->address = i->ipi_addr.s_addr;\n\n                    found_addr = 1;\n\n                    break;\n                }\n#endif\n\n#ifdef IP_RECVIF\n                case IP_RECVIF: {\n                    struct sockaddr_dl *sdl = (struct sockaddr_dl *) CMSG_DATA (cmsg);\n\n                    if (ret_iface)\n#ifdef __sun\n                        *ret_iface = *(uint_t*) sdl;\n#else\n                        *ret_iface = (int) sdl->sdl_index;\n#endif\n\n                    break;\n                }\n#endif\n\n#ifdef IP_RECVDSTADDR\n                case IP_RECVDSTADDR:\n                    if (ret_dst_address)\n                        memcpy(&ret_dst_address->address, CMSG_DATA (cmsg), 4);\n\n                    found_addr = 1;\n                    break;\n#endif\n\n                default:\n                    avahi_log_warn(\"Unhandled cmsg_type : %d\", cmsg->cmsg_type);\n                    break;\n            }\n        }\n    }\n\n    assert(found_addr);\n\n    return p;\n\nfail:\n    if (p)\n        avahi_dns_packet_free(p);\n\n    return NULL;\n}",
        "target": 1
    },
    {
        "func": "strip_leading_slashes (char *name, int strip_leading)\n{\n  int s = strip_leading;\n  char *p, *n;\n\n  for (p = n = name;  *p;  p++)\n    {\n      if (ISSLASH (*p))\n\t{\n\t  while (ISSLASH (p[1]))\n\t    p++;\n\t  if (strip_leading < 0 || --s >= 0)\n\t      n = p+1;\n\t}\n    }\n  if ((strip_leading < 0 || s <= 0) && *n)\n    {\n      memmove (name, n, strlen (n) + 1);\n      return true;\n    }\n  else\n    return false;\n}",
        "target": 1
    },
    {
        "func": "int mainloop(CLIENT *client) {\n\tstruct nbd_request request;\n\tstruct nbd_reply reply;\n\tgboolean go_on=TRUE;\n#ifdef DODBG\n\tint i = 0;\n#endif\n\tnegotiate(client);\n\tDEBUG(\"Entering request loop!\\n\");\n\treply.magic = htonl(NBD_REPLY_MAGIC);\n\treply.error = 0;\n\twhile (go_on) {\n\t\tchar buf[BUFSIZE];\n\t\tsize_t len;\n#ifdef DODBG\n\t\ti++;\n\t\tprintf(\"%d: \", i);\n#endif\n\t\tif (client->server->timeout) \n\t\t\talarm(client->server->timeout);\n\t\treadit(client->net, &request, sizeof(request));\n\t\trequest.from = ntohll(request.from);\n\t\trequest.type = ntohl(request.type);\n\n\t\tif (request.type==NBD_CMD_DISC) {\n\t\t\tmsg2(LOG_INFO, \"Disconnect request received.\");\n\t\t\tif (client->difmap) g_free(client->difmap) ;\n                \tif (client->difffile>=0) { \n                \t\tclose(client->difffile);\n\t\t\t\tunlink(client->difffilename);\n\t\t\t\tfree(client->difffilename);\n\t\t\t}\n\t\t\tgo_on=FALSE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlen = ntohl(request.len);\n\n\t\tif (request.magic != htonl(NBD_REQUEST_MAGIC))\n\t\t\terr(\"Not enough magic.\");\n\t\tif (len > BUFSIZE)\n\t\t\terr(\"Request too big!\");\n#ifdef DODBG\n\t\tprintf(\"%s from %Lu (%Lu) len %d, \", request.type ? \"WRITE\" :\n\t\t\t\t\"READ\", (unsigned long long)request.from,\n\t\t\t\t(unsigned long long)request.from / 512, len);\n#endif\n\t\tmemcpy(reply.handle, request.handle, sizeof(reply.handle));\n\t\tif ((request.from + len) > (OFFT_MAX)) {\n\t\t\tDEBUG(\"[Number too large!]\");\n\t\t\tERROR(client, reply);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (((ssize_t)((off_t)request.from + len) > client->exportsize) ||\n\t\t    ((client->server->flags & F_READONLY) && request.type)) {\n\t\t\tDEBUG(\"[RANGE!]\");\n\t\t\tERROR(client, reply);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (request.type==NBD_CMD_WRITE) {\n\t\t\tDEBUG(\"wr: net->buf, \");\n\t\t\treadit(client->net, buf, len);\n\t\t\tDEBUG(\"buf->exp, \");\n\t\t\tif ((client->server->flags & F_AUTOREADONLY) ||\n\t\t\t\t\texpwrite(request.from, buf, len,\n\t\t\t\t\t\tclient)) {\n\t\t\t\tDEBUG(\"Write failed: %m\" );\n\t\t\t\tERROR(client, reply);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tSEND(client->net, reply);\n\t\t\tDEBUG(\"OK!\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\t/* READ */\n\n\t\tDEBUG(\"exp->buf, \");\n\t\tif (expread(request.from, buf + sizeof(struct nbd_reply), len, client)) {\n\t\t\tDEBUG(\"Read failed: %m\");\n\t\t\tERROR(client, reply);\n\t\t\tcontinue;\n\t\t}\n\n\t\tDEBUG(\"buf->net, \");\n\t\tmemcpy(buf, &reply, sizeof(struct nbd_reply));\n\t\twriteit(client->net, buf, len + sizeof(struct nbd_reply));\n\t\tDEBUG(\"OK!\\n\");\n\t}\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "int mainloop(CLIENT *client) {\n\tstruct nbd_request request;\n\tstruct nbd_reply reply;\n\tgboolean go_on=TRUE;\n#ifdef DODBG\n\tint i = 0;\n#endif\n\tnegotiate(client->net, client, NULL);\n\tDEBUG(\"Entering request loop!\\n\");\n\treply.magic = htonl(NBD_REPLY_MAGIC);\n\treply.error = 0;\n\twhile (go_on) {\n\t\tchar buf[BUFSIZE];\n\t\tsize_t len;\n#ifdef DODBG\n\t\ti++;\n\t\tprintf(\"%d: \", i);\n#endif\n\t\treadit(client->net, &request, sizeof(request));\n\t\trequest.from = ntohll(request.from);\n\t\trequest.type = ntohl(request.type);\n\n\t\tif (request.type==NBD_CMD_DISC) {\n\t\t\tmsg2(LOG_INFO, \"Disconnect request received.\");\n                \tif (client->server->flags & F_COPYONWRITE) { \n\t\t\t\tif (client->difmap) g_free(client->difmap) ;\n                \t\tclose(client->difffile);\n\t\t\t\tunlink(client->difffilename);\n\t\t\t\tfree(client->difffilename);\n\t\t\t}\n\t\t\tgo_on=FALSE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlen = ntohl(request.len);\n\n\t\tif (request.magic != htonl(NBD_REQUEST_MAGIC))\n\t\t\terr(\"Not enough magic.\");\n\t\tif (len > BUFSIZE + sizeof(struct nbd_reply))\n\t\t\terr(\"Request too big!\");\n#ifdef DODBG\n\t\tprintf(\"%s from %llu (%llu) len %d, \", request.type ? \"WRITE\" :\n\t\t\t\t\"READ\", (unsigned long long)request.from,\n\t\t\t\t(unsigned long long)request.from / 512, len);\n#endif\n\t\tmemcpy(reply.handle, request.handle, sizeof(reply.handle));\n\t\tif ((request.from + len) > (OFFT_MAX)) {\n\t\t\tDEBUG(\"[Number too large!]\");\n\t\t\tERROR(client, reply, EINVAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (((ssize_t)((off_t)request.from + len) > client->exportsize)) {\n\t\t\tDEBUG(\"[RANGE!]\");\n\t\t\tERROR(client, reply, EINVAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (request.type==NBD_CMD_WRITE) {\n\t\t\tDEBUG(\"wr: net->buf, \");\n\t\t\treadit(client->net, buf, len);\n\t\t\tDEBUG(\"buf->exp, \");\n\t\t\tif ((client->server->flags & F_READONLY) ||\n\t\t\t    (client->server->flags & F_AUTOREADONLY)) {\n\t\t\t\tDEBUG(\"[WRITE to READONLY!]\");\n\t\t\t\tERROR(client, reply, EPERM);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (expwrite(request.from, buf, len, client)) {\n\t\t\t\tDEBUG(\"Write failed: %m\" );\n\t\t\t\tERROR(client, reply, errno);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tSEND(client->net, reply);\n\t\t\tDEBUG(\"OK!\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\t/* READ */\n\n\t\tDEBUG(\"exp->buf, \");\n\t\tif (expread(request.from, buf + sizeof(struct nbd_reply), len, client)) {\n\t\t\tDEBUG(\"Read failed: %m\");\n\t\t\tERROR(client, reply, errno);\n\t\t\tcontinue;\n\t\t}\n\n\t\tDEBUG(\"buf->net, \");\n\t\tmemcpy(buf, &reply, sizeof(struct nbd_reply));\n\t\twriteit(client->net, buf, len + sizeof(struct nbd_reply));\n\t\tDEBUG(\"OK!\\n\");\n\t}\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "xfs_ioc_fsgeometry_v1(\n\txfs_mount_t\t\t*mp,\n\tvoid\t\t\t__user *arg)\n{\n\txfs_fsop_geom_v1_t\tfsgeo;\n\tint\t\t\terror;\n\n\terror = xfs_fs_geometry(mp, (xfs_fsop_geom_t *)&fsgeo, 3);\n\tif (error)\n\t\treturn -error;\n\n\tif (copy_to_user(arg, &fsgeo, sizeof(fsgeo)))\n\t\treturn -XFS_ERROR(EFAULT);\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "_hb_buffer_add_output_glyph_ids( HB_Buffer  buffer,\n\t\t\t      HB_UShort  num_in,\n\t\t\t      HB_UShort  num_out,\n\t\t\t      const GlyphID *glyph_data,\n\t\t\t      HB_UShort  component,\n\t\t\t      HB_UShort  ligID )\n{\n  HB_Error  error;\n  HB_UShort i;\n  HB_UInt properties;\n  HB_UInt cluster;\n\n  error = hb_buffer_ensure( buffer, buffer->out_pos + num_out );\n  if ( error )\n    return error;\n\n  if ( !buffer->separate_out )\n    {\n      error = hb_buffer_duplicate_out_buffer( buffer );\n      if ( error )\n\treturn error;\n    }\n\n  properties = buffer->in_string[buffer->in_pos].properties;\n  cluster = buffer->in_string[buffer->in_pos].cluster;\n  if ( component == 0xFFFF )\n    component = buffer->in_string[buffer->in_pos].component;\n  if ( ligID == 0xFFFF )\n    ligID = buffer->in_string[buffer->in_pos].ligID;\n\n  for ( i = 0; i < num_out; i++ )\n  {\n    HB_GlyphItem item = &buffer->out_string[buffer->out_pos + i];\n\n    item->gindex = glyph_data[i];\n    item->properties = properties;\n    item->cluster = cluster;\n    item->component = component;\n    item->ligID = ligID;\n    item->gproperty = HB_GLYPH_PROPERTY_UNKNOWN;\n  }\n\n  buffer->in_pos  += num_in;\n  buffer->out_pos += num_out;\n\n  buffer->out_length = buffer->out_pos;\n\n  return HB_Err_Ok;\n}",
        "target": 1
    },
    {
        "func": "hb_buffer_ensure( HB_Buffer buffer,\n\t\t   HB_UInt   size )\n{\n  HB_UInt new_allocated = buffer->allocated;\n\n  if (size > new_allocated)\n    {\n      HB_Error error;\n\n      while (size > new_allocated)\n\tnew_allocated += (new_allocated >> 1) + 8;\n\n      if ( buffer->positions )\n        {\n\t  if ( REALLOC_ARRAY( buffer->positions, new_allocated, HB_PositionRec ) )\n\t    return error;\n\t}\n\n      if ( REALLOC_ARRAY( buffer->in_string, new_allocated, HB_GlyphItemRec ) )\n\treturn error;\n\n      if ( buffer->separate_out )\n        {\n\t  if ( REALLOC_ARRAY( buffer->alt_string, new_allocated, HB_GlyphItemRec ) )\n\t    return error;\n\n\t  buffer->out_string = buffer->alt_string;\n\t}\n      else\n        {\n\t  buffer->out_string = buffer->in_string;\n\n\t  if ( buffer->alt_string )\n\t    {\n\t      if ( REALLOC_ARRAY( buffer->alt_string, new_allocated, HB_GlyphItemRec ) )\n\t\treturn error;\n\t    }\n\t}\n\n      buffer->allocated = new_allocated;\n    }\n\n  return HB_Err_Ok;\n}",
        "target": 1
    },
    {
        "func": "set_unicode_charmap (FT_Face face)\n{\n  int charmap;\n\n  for (charmap = 0; charmap < face->num_charmaps; charmap++)\n    if (face->charmaps[charmap]->encoding == ft_encoding_unicode)\n      {\n\tHB_Error error = FT_Set_Charmap(face, face->charmaps[charmap]);\n\treturn error == HB_Err_Ok;\n      }\n\n  return FALSE;\n}",
        "target": 1
    },
    {
        "func": "release_buffer (HB_Buffer buffer, gboolean free_buffer)\n{\n  if (G_LIKELY (!free_buffer))\n    {\n      hb_buffer_clear (buffer);\n      G_UNLOCK (cached_buffer);\n    }\n  else\n    hb_buffer_free (buffer);\n}",
        "target": 1
    },
    {
        "func": "acquire_buffer (gboolean *free_buffer)\n{\n  HB_Buffer buffer;\n\n  if (G_LIKELY (G_TRYLOCK (cached_buffer)))\n    {\n      if (G_UNLIKELY (!cached_buffer))\n\thb_buffer_new (&cached_buffer);\n\n      buffer = cached_buffer;\n      *free_buffer = FALSE;\n    }\n  else\n    {\n      hb_buffer_new (&buffer);\n      *free_buffer = TRUE;\n    }\n\n  return buffer;\n}",
        "target": 1
    },
    {
        "func": "_hb_buffer_next_glyph ( HB_Buffer buffer )\n{\n  HB_Error  error;\n\n  if ( buffer->separate_out )\n    {\n      error = hb_buffer_ensure( buffer, buffer->out_pos + 1 );\n      if ( error )\n\treturn error;\n\n      buffer->out_string[buffer->out_pos] = buffer->in_string[buffer->in_pos];\n    }\n\n  buffer->in_pos++;\n  buffer->out_pos++;\n  buffer->out_length = buffer->out_pos;\n\n  return HB_Err_Ok;\n}",
        "target": 1
    },
    {
        "func": "_hb_buffer_clear_output( HB_Buffer buffer )\n{\n  buffer->out_length = 0;\n  buffer->out_pos = 0;\n  buffer->out_string = buffer->in_string;\n  buffer->separate_out = FALSE;\n}",
        "target": 1
    },
    {
        "func": "_hb_buffer_add_output_glyph( HB_Buffer buffer,\n\t\t\t     HB_UInt   glyph_index,\n\t\t\t     HB_UShort component,\n\t\t\t     HB_UShort ligID )\n{\n  HB_UShort glyph_data =  glyph_index;\n\n  return _hb_buffer_add_output_glyphs ( buffer, 1, 1,\n\t\t\t\t\t&glyph_data, component, ligID );\n}",
        "target": 1
    },
    {
        "func": "_hb_buffer_add_output_glyphs( HB_Buffer  buffer,\n\t\t\t      HB_UShort  num_in,\n\t\t\t      HB_UShort  num_out,\n\t\t\t      HB_UShort *glyph_data,\n\t\t\t      HB_UShort  component,\n\t\t\t      HB_UShort  ligID )\n{\n  HB_Error  error;\n  HB_UShort i;\n  HB_UInt properties;\n  HB_UInt cluster;\n\n  error = hb_buffer_ensure( buffer, buffer->out_pos + num_out );\n  if ( error )\n    return error;\n\n  if ( !buffer->separate_out )\n    {\n      error = hb_buffer_duplicate_out_buffer( buffer );\n      if ( error )\n\treturn error;\n    }\n\n  properties = buffer->in_string[buffer->in_pos].properties;\n  cluster = buffer->in_string[buffer->in_pos].cluster;\n  if ( component == 0xFFFF )\n    component = buffer->in_string[buffer->in_pos].component;\n  if ( ligID == 0xFFFF )\n    ligID = buffer->in_string[buffer->in_pos].ligID;\n\n  for ( i = 0; i < num_out; i++ )\n  {\n    HB_GlyphItem item = &buffer->out_string[buffer->out_pos + i];\n\n    item->gindex = glyph_data[i];\n    item->properties = properties;\n    item->cluster = cluster;\n    item->component = component;\n    item->ligID = ligID;\n    item->gproperty = HB_GLYPH_PROPERTY_UNKNOWN;\n  }\n\n  buffer->in_pos  += num_in;\n  buffer->out_pos += num_out;\n\n  buffer->out_length = buffer->out_pos;\n\n  return HB_Err_Ok;\n}",
        "target": 1
    },
    {
        "func": "hb_buffer_new( HB_Buffer *pbuffer )\n{\n  HB_Buffer buffer;\n  HB_Error error;\n  \n  if ( ALLOC( buffer, sizeof( HB_BufferRec ) ) )\n    return error;\n\n  buffer->allocated = 0;\n  buffer->in_string = NULL;\n  buffer->alt_string = NULL;\n  buffer->positions = NULL;\n\n  hb_buffer_clear( buffer );\n\n  *pbuffer = buffer;\n\n  return HB_Err_Ok;\n}",
        "target": 1
    },
    {
        "func": "_pango_ot_info_position    (const PangoOTInfo    *info,\n\t\t\t    const PangoOTRuleset *ruleset,\n\t\t\t    PangoOTBuffer        *buffer)\n{\n  unsigned int i;\n\n  _hb_buffer_clear_positions (buffer->buffer);\n\n  hb_ot_layout_set_direction (info->layout,\n\t\t\t      buffer->rtl);\n  hb_ot_layout_set_hinting (info->layout,\n\t\t\t    buffer->font->is_hinted);\n  hb_ot_layout_set_scale (info->layout,\n\t\t\t  info->face->size->metrics.x_scale,\n\t\t\t  info->face->size->metrics.y_scale);\n  hb_ot_layout_set_ppem (info->layout,\n\t\t\t info->face->size->metrics.x_ppem,\n\t\t\t info->face->size->metrics.y_ppem);\n\n  for (i = 0; i < ruleset->rules->len; i++)\n    {\n      PangoOTRule *rule = &g_array_index (ruleset->rules, PangoOTRule, i);\n      hb_ot_layout_feature_mask_t mask;\n      unsigned int lookup_count, j;\n\n      if (rule->table_type != PANGO_OT_TABLE_GPOS)\n\tcontinue;\n\n      mask = rule->property_bit;\n      lookup_count = hb_ot_layout_feature_get_lookup_count (info->layout,\n\t\t\t\t\t\t\t    HB_OT_LAYOUT_TABLE_TYPE_GPOS,\n\t\t\t\t\t\t\t    rule->feature_index);\n\n      for (j = 0; j < lookup_count; j++)\n        {\n\t  unsigned int lookup_index;\n\n\t  lookup_index = hb_ot_layout_feature_get_lookup_index (info->layout,\n\t\t\t\t\t\t\t\tHB_OT_LAYOUT_TABLE_TYPE_GPOS,\n\t\t\t\t\t\t\t\trule->feature_index,\n\t\t\t\t\t\t\t\tj);\n\t  hb_ot_layout_position_lookup (info->layout,\n\t\t\t\t\tbuffer->buffer,\n\t\t\t\t\tlookup_index,\n\t\t\t\t\trule->property_bit);\n\t}\n\n    }\n\n    {\n      HB_UInt   i, j;\n      HB_Position positions = buffer->buffer->positions;\n\n      /* First handle all left-to-right connections */\n      for (j = 0; j < buffer->buffer->in_length; j++)\n      {\n\tif (positions[j].cursive_chain > 0)\n\t  positions[j].y_pos += positions[j - positions[j].cursive_chain].y_pos;\n      }\n\n      /* Then handle all right-to-left connections */\n      for (i = buffer->buffer->in_length; i > 0; i--)\n      {\n\tj = i - 1;\n\n\tif (positions[j].cursive_chain < 0)\n\t  positions[j].y_pos += positions[j - positions[j].cursive_chain].y_pos;\n      }\n    }\n\n   buffer->applied_gpos = TRUE;\n}",
        "target": 1
    },
    {
        "func": "hb_buffer_add_glyph( HB_Buffer buffer,\n\t\t      HB_UInt   glyph_index,\n\t\t      HB_UInt   properties,\n\t\t      HB_UInt   cluster )\n{\n  HB_Error error;\n  HB_GlyphItem glyph;\n  \n  error = hb_buffer_ensure( buffer, buffer->in_length + 1 );\n  if ( error )\n    return error;\n\n  glyph = &buffer->in_string[buffer->in_length];\n  glyph->gindex = glyph_index;\n  glyph->properties = properties;\n  glyph->cluster = cluster;\n  glyph->component = 0;\n  glyph->ligID = 0;\n  glyph->gproperty = HB_GLYPH_PROPERTY_UNKNOWN;\n  \n  buffer->in_length++;\n\n  return HB_Err_Ok;\n}",
        "target": 1
    },
    {
        "func": "_hb_buffer_replace_glyph( HB_Buffer buffer,\n\t\t\t  HB_UInt   glyph_index )\n{\n  if ( !buffer->separate_out )\n    {\n      buffer->out_string[buffer->out_pos].gindex = glyph_index;\n\n      buffer->in_pos++;\n      buffer->out_pos++;\n      buffer->out_length = buffer->out_pos;\n    }\n  else\n    {\n      return _hb_buffer_add_output_glyph( buffer, glyph_index, 0xFFFF, 0xFFFF );\n    }\n\n  return HB_Err_Ok;\n}",
        "target": 1
    },
    {
        "func": "get_glyph_class (gunichar   charcode,\n\t\t HB_UShort *class)\n{\n  /* For characters mapped into the Arabic Presentation forms, using properties\n   * derived as we apply GSUB substitutions will be more reliable\n   */\n  if ((charcode >= 0xFB50 && charcode <= 0xFDFF) || /* Arabic Presentation Forms-A */\n      (charcode >= 0xFE70 && charcode <= 0XFEFF))   /* Arabic Presentation Forms-B */\n    return FALSE;\n\n  switch ((int) g_unichar_type (charcode))\n    {\n    case G_UNICODE_COMBINING_MARK:\n    case G_UNICODE_ENCLOSING_MARK:\n    case G_UNICODE_NON_SPACING_MARK:\n      *class = 3;\t\t/* Mark glyph (non-spacing combining glyph) */\n      return TRUE;\n    case G_UNICODE_UNASSIGNED:\n    case G_UNICODE_PRIVATE_USE:\n      return FALSE;\t\t/* Unknown, don't assign a class; classes get\n\t\t\t\t * propagated during GSUB application */\n    default:\n      *class = 1;               /* Base glyph (single character, spacing glyph) */\n      return TRUE;\n    }\n}",
        "target": 1
    },
    {
        "func": "_hb_buffer_allocate_ligid( HB_Buffer buffer )\n{\n  return ++buffer->max_ligID;\n}",
        "target": 1
    },
    {
        "func": "hb_buffer_duplicate_out_buffer( HB_Buffer buffer )\n{\n  if ( !buffer->alt_string )\n    {\n      HB_Error error;\n\n      if ( ALLOC_ARRAY( buffer->alt_string, buffer->allocated, HB_GlyphItemRec ) )\n\treturn error;\n    }\n\n  buffer->out_string = buffer->alt_string;\n  memcpy( buffer->out_string, buffer->in_string, buffer->out_length * sizeof (buffer->out_string[0]) );\n  buffer->separate_out = TRUE;\n\n  return HB_Err_Ok;\n}",
        "target": 1
    },
    {
        "func": "_hb_buffer_swap( HB_Buffer buffer )\n{\n  HB_GlyphItem tmp_string;\n  int tmp_length;\n  int tmp_pos;\n\n  if ( buffer->separate_out )\n    {\n      tmp_string = buffer->in_string;\n      buffer->in_string = buffer->out_string;\n      buffer->out_string = tmp_string;\n      buffer->alt_string = buffer->out_string;\n    }\n\n  tmp_length = buffer->in_length;\n  buffer->in_length = buffer->out_length;\n  buffer->out_length = tmp_length;\n\n  tmp_pos = buffer->in_pos;\n  buffer->in_pos = buffer->out_pos;\n  buffer->out_pos = tmp_pos;\n}",
        "target": 1
    },
    {
        "func": "hb_buffer_free( HB_Buffer buffer )\n{\n  FREE( buffer->in_string );\n  FREE( buffer->alt_string );\n  buffer->out_string = NULL;\n  FREE( buffer->positions );\n  FREE( buffer );\n}",
        "target": 1
    },
    {
        "func": "_hb_buffer_clear_positions( HB_Buffer buffer )\n{\n  _hb_buffer_clear_output (buffer);\n\n  if ( !buffer->positions )\n    {\n      HB_Error error;\n\n      if ( ALLOC_ARRAY( buffer->positions, buffer->allocated, HB_PositionRec ) )\n\treturn error;\n    }\n\n  memset (buffer->positions, 0, sizeof (buffer->positions[0]) * buffer->in_length);\n\n  return HB_Err_Ok;\n}",
        "target": 1
    },
    {
        "func": "hb_buffer_clear( HB_Buffer buffer )\n{\n  buffer->in_length = 0;\n  buffer->out_length = 0;\n  buffer->in_pos = 0;\n  buffer->out_pos = 0;\n  buffer->out_string = buffer->in_string;\n  buffer->separate_out = FALSE;\n  buffer->max_ligID = 0;\n}",
        "target": 1
    },
    {
        "func": "static char *linetoken(FILE *stream)\n{\n    int ch, idx;\n\n    while ((ch = fgetc(stream)) == ' ' || ch == '\\t' ); \n    \n    idx = 0;\n    while (ch != EOF && ch != lineterm) \n    {\n        ident[idx++] = ch;\n        ch = fgetc(stream);\n    } /* while */\n    \n    ungetc(ch, stream);\n    ident[idx] = 0;\n\n    return(ident);\t/* returns pointer to the token */\n\n} /* linetoken */",
        "target": 1
    },
    {
        "func": "static char *token(FILE *stream)\n{\n    int ch, idx;\n\n    /* skip over white space */\n    while ((ch = fgetc(stream)) == ' ' || ch == lineterm || \n            ch == ',' || ch == '\\t' || ch == ';');\n    \n    idx = 0;\n    while (ch != EOF && ch != ' ' && ch != lineterm \n           && ch != '\\t' && ch != ':' && ch != ';' && idx < MAX_NAME)\n    {\n        ident[idx++] = ch;\n        ch = fgetc(stream);\n    } /* while */\n\n    if (ch == EOF && idx < 1) return ((char *)NULL);\n    if (idx >= 1 && ch != ':' ) ungetc(ch, stream);\n    if (idx < 1 ) ident[idx++] = ch;\t/* single-character token */\n    ident[idx] = 0;\n    \n    return(ident);\t/* returns pointer to the token */\n\n} /* token */",
        "target": 1
    },
    {
        "func": "static char *linetoken(FILE *stream)\n{\n    int ch, idx;\n\n    while ((ch = fgetc(stream)) == ' ' || ch == '\\t' ); \n    \n    idx = 0;\n    while (ch != EOF && ch != lineterm && idx < MAX_NAME)\n    {\n        ident[idx++] = ch;\n        ch = fgetc(stream);\n    } /* while */\n    \n    ungetc(ch, stream);\n    ident[idx] = 0;\n\n    return(ident);\t/* returns pointer to the token */\n\n} /* linetoken */",
        "target": 1
    },
    {
        "func": "vba_read_project_strings(int fd, int big_endian)\n{\n\tunsigned char *buf = NULL;\n\tuint16_t buflen = 0;\n\tint ret = 0;\n\n\tfor(;;) {\n\t\toff_t offset;\n\t\tuint16_t length;\n\t\tchar *name;\n\n\t\tif(!read_uint16(fd, &length, big_endian))\n\t\t\tbreak;\n\n\t\tif (length < 6) {\n\t\t\tlseek(fd, -2, SEEK_CUR);\n\t\t\tbreak;\n\t\t}\n\t\tif(length > buflen) {\n\t\t\tunsigned char *newbuf = (unsigned char *)cli_realloc(buf, length);\n\t\t\tif(newbuf == NULL) {\n\t\t\t\tif(buf)\n\t\t\t\t\tfree(buf);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbuflen = length;\n\t\t\tbuf = newbuf;\n\t\t}\n\n\t\toffset = lseek(fd, 0, SEEK_CUR);\n\n\t\tif(cli_readn(fd, buf, length) != (int)length) {\n\t\t\tcli_dbgmsg(\"read name failed - rewinding\\n\");\n\t\t\tlseek(fd, offset, SEEK_SET);\n\t\t\tbreak;\n\t\t}\n\t\tname = get_unicode_name((const char *)buf, length, big_endian);\n\t\tcli_dbgmsg(\"length: %d, name: %s\\n\", length, (name) ? name : \"[null]\");\n\n\t\tif((name == NULL) || (memcmp(\"*\\\\\", name, 2) != 0) ||\n\t\t   (strchr(\"ghcd\", name[2]) == NULL)) {\n\t\t\t/* Not a string */\n\t\t\tlseek(fd, -(length+2), SEEK_CUR);\n\t\t\tif(name)\n\t\t\t\tfree(name);\n\t\t\tbreak;\n\t\t}\n\t\tfree(name);\n\n\t\tif(!read_uint16(fd, &length, big_endian)) {\n\t\t\tif(buf)\n\t\t\t\tfree(buf);\n\t\t\tbreak;\n\t\t}\n\n\t\tret++;\n\n\t\tif ((length != 0) && (length != 65535)) {\n\t\t\tlseek(fd, -2, SEEK_CUR);\n\t\t\tcontinue;\n\t\t}\n\t\toffset = lseek(fd, 10, SEEK_CUR);\n\t\tcli_dbgmsg(\"offset: %lu\\n\", (unsigned long)offset);\n\t\tvba56_test_middle(fd);\n\t}\n\tif(buf)\n\t\tfree(buf);\n\treturn ret;\n}",
        "target": 1
    },
    {
        "func": "static int rds_loop_xmit(struct rds_connection *conn, struct rds_message *rm,\n\t\t\t unsigned int hdr_off, unsigned int sg,\n\t\t\t unsigned int off)\n{\n\t/* Do not send cong updates to loopback */\n\tif (rm->m_inc.i_hdr.h_flags & RDS_FLAG_CONG_BITMAP) {\n\t\trds_cong_map_updated(conn->c_fcong, ~(u64) 0);\n\t\treturn sizeof(struct rds_header) + RDS_CONG_MAP_BYTES;\n\t}\n\n\tBUG_ON(hdr_off || sg || off);\n\n\trds_inc_init(&rm->m_inc, conn, conn->c_laddr);\n\t/* For the embedded inc. Matching put is in loop_inc_free() */\n\trds_message_addref(rm);\n\n\trds_recv_incoming(conn, conn->c_laddr, conn->c_faddr, &rm->m_inc,\n\t\t\t  GFP_KERNEL, KM_USER0);\n\n\trds_send_drop_acked(conn, be64_to_cpu(rm->m_inc.i_hdr.h_sequence),\n\t\t\t    NULL);\n\n\trds_inc_put(&rm->m_inc);\n\n\treturn sizeof(struct rds_header) + be32_to_cpu(rm->m_inc.i_hdr.h_len);\n}",
        "target": 1
    },
    {
        "func": "int rds_ib_xmit(struct rds_connection *conn, struct rds_message *rm,\n\t\tunsigned int hdr_off, unsigned int sg, unsigned int off)\n{\n\tstruct rds_ib_connection *ic = conn->c_transport_data;\n\tstruct ib_device *dev = ic->i_cm_id->device;\n\tstruct rds_ib_send_work *send = NULL;\n\tstruct rds_ib_send_work *first;\n\tstruct rds_ib_send_work *prev;\n\tstruct ib_send_wr *failed_wr;\n\tstruct scatterlist *scat;\n\tu32 pos;\n\tu32 i;\n\tu32 work_alloc;\n\tu32 credit_alloc = 0;\n\tu32 posted;\n\tu32 adv_credits = 0;\n\tint send_flags = 0;\n\tint bytes_sent = 0;\n\tint ret;\n\tint flow_controlled = 0;\n\tint nr_sig = 0;\n\n\tBUG_ON(off % RDS_FRAG_SIZE);\n\tBUG_ON(hdr_off != 0 && hdr_off != sizeof(struct rds_header));\n\n\t/* Do not send cong updates to IB loopback */\n\tif (conn->c_loopback\n\t    && rm->m_inc.i_hdr.h_flags & RDS_FLAG_CONG_BITMAP) {\n\t\trds_cong_map_updated(conn->c_fcong, ~(u64) 0);\n\t\treturn sizeof(struct rds_header) + RDS_CONG_MAP_BYTES;\n\t}\n\n\t/* FIXME we may overallocate here */\n\tif (be32_to_cpu(rm->m_inc.i_hdr.h_len) == 0)\n\t\ti = 1;\n\telse\n\t\ti = ceil(be32_to_cpu(rm->m_inc.i_hdr.h_len), RDS_FRAG_SIZE);\n\n\twork_alloc = rds_ib_ring_alloc(&ic->i_send_ring, i, &pos);\n\tif (work_alloc == 0) {\n\t\tset_bit(RDS_LL_SEND_FULL, &conn->c_flags);\n\t\trds_ib_stats_inc(s_ib_tx_ring_full);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (ic->i_flowctl) {\n\t\tcredit_alloc = rds_ib_send_grab_credits(ic, work_alloc, &posted, 0, RDS_MAX_ADV_CREDIT);\n\t\tadv_credits += posted;\n\t\tif (credit_alloc < work_alloc) {\n\t\t\trds_ib_ring_unalloc(&ic->i_send_ring, work_alloc - credit_alloc);\n\t\t\twork_alloc = credit_alloc;\n\t\t\tflow_controlled = 1;\n\t\t}\n\t\tif (work_alloc == 0) {\n\t\t\tset_bit(RDS_LL_SEND_FULL, &conn->c_flags);\n\t\t\trds_ib_stats_inc(s_ib_tx_throttle);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* map the message the first time we see it */\n\tif (!ic->i_data_op) {\n\t\tif (rm->data.op_nents) {\n\t\t\trm->data.op_count = ib_dma_map_sg(dev,\n\t\t\t\t\t\t\t  rm->data.op_sg,\n\t\t\t\t\t\t\t  rm->data.op_nents,\n\t\t\t\t\t\t\t  DMA_TO_DEVICE);\n\t\t\trdsdebug(\"ic %p mapping rm %p: %d\\n\", ic, rm, rm->data.op_count);\n\t\t\tif (rm->data.op_count == 0) {\n\t\t\t\trds_ib_stats_inc(s_ib_tx_sg_mapping_failure);\n\t\t\t\trds_ib_ring_unalloc(&ic->i_send_ring, work_alloc);\n\t\t\t\tret = -ENOMEM; /* XXX ? */\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\trm->data.op_count = 0;\n\t\t}\n\n\t\trds_message_addref(rm);\n\t\tic->i_data_op = &rm->data;\n\n\t\t/* Finalize the header */\n\t\tif (test_bit(RDS_MSG_ACK_REQUIRED, &rm->m_flags))\n\t\t\trm->m_inc.i_hdr.h_flags |= RDS_FLAG_ACK_REQUIRED;\n\t\tif (test_bit(RDS_MSG_RETRANSMITTED, &rm->m_flags))\n\t\t\trm->m_inc.i_hdr.h_flags |= RDS_FLAG_RETRANSMITTED;\n\n\t\t/* If it has a RDMA op, tell the peer we did it. This is\n\t\t * used by the peer to release use-once RDMA MRs. */\n\t\tif (rm->rdma.op_active) {\n\t\t\tstruct rds_ext_header_rdma ext_hdr;\n\n\t\t\text_hdr.h_rdma_rkey = cpu_to_be32(rm->rdma.op_rkey);\n\t\t\trds_message_add_extension(&rm->m_inc.i_hdr,\n\t\t\t\t\tRDS_EXTHDR_RDMA, &ext_hdr, sizeof(ext_hdr));\n\t\t}\n\t\tif (rm->m_rdma_cookie) {\n\t\t\trds_message_add_rdma_dest_extension(&rm->m_inc.i_hdr,\n\t\t\t\t\trds_rdma_cookie_key(rm->m_rdma_cookie),\n\t\t\t\t\trds_rdma_cookie_offset(rm->m_rdma_cookie));\n\t\t}\n\n\t\t/* Note - rds_ib_piggyb_ack clears the ACK_REQUIRED bit, so\n\t\t * we should not do this unless we have a chance of at least\n\t\t * sticking the header into the send ring. Which is why we\n\t\t * should call rds_ib_ring_alloc first. */\n\t\trm->m_inc.i_hdr.h_ack = cpu_to_be64(rds_ib_piggyb_ack(ic));\n\t\trds_message_make_checksum(&rm->m_inc.i_hdr);\n\n\t\t/*\n\t\t * Update adv_credits since we reset the ACK_REQUIRED bit.\n\t\t */\n\t\tif (ic->i_flowctl) {\n\t\t\trds_ib_send_grab_credits(ic, 0, &posted, 1, RDS_MAX_ADV_CREDIT - adv_credits);\n\t\t\tadv_credits += posted;\n\t\t\tBUG_ON(adv_credits > 255);\n\t\t}\n\t}\n\n\t/* Sometimes you want to put a fence between an RDMA\n\t * READ and the following SEND.\n\t * We could either do this all the time\n\t * or when requested by the user. Right now, we let\n\t * the application choose.\n\t */\n\tif (rm->rdma.op_active && rm->rdma.op_fence)\n\t\tsend_flags = IB_SEND_FENCE;\n\n\t/* Each frag gets a header. Msgs may be 0 bytes */\n\tsend = &ic->i_sends[pos];\n\tfirst = send;\n\tprev = NULL;\n\tscat = &ic->i_data_op->op_sg[sg];\n\ti = 0;\n\tdo {\n\t\tunsigned int len = 0;\n\n\t\t/* Set up the header */\n\t\tsend->s_wr.send_flags = send_flags;\n\t\tsend->s_wr.opcode = IB_WR_SEND;\n\t\tsend->s_wr.num_sge = 1;\n\t\tsend->s_wr.next = NULL;\n\t\tsend->s_queued = jiffies;\n\t\tsend->s_op = NULL;\n\n\t\tsend->s_sge[0].addr = ic->i_send_hdrs_dma\n\t\t\t+ (pos * sizeof(struct rds_header));\n\t\tsend->s_sge[0].length = sizeof(struct rds_header);\n\n\t\tmemcpy(&ic->i_send_hdrs[pos], &rm->m_inc.i_hdr, sizeof(struct rds_header));\n\n\t\t/* Set up the data, if present */\n\t\tif (i < work_alloc\n\t\t    && scat != &rm->data.op_sg[rm->data.op_count]) {\n\t\t\tlen = min(RDS_FRAG_SIZE, ib_sg_dma_len(dev, scat) - off);\n\t\t\tsend->s_wr.num_sge = 2;\n\n\t\t\tsend->s_sge[1].addr = ib_sg_dma_address(dev, scat) + off;\n\t\t\tsend->s_sge[1].length = len;\n\n\t\t\tbytes_sent += len;\n\t\t\toff += len;\n\t\t\tif (off == ib_sg_dma_len(dev, scat)) {\n\t\t\t\tscat++;\n\t\t\t\toff = 0;\n\t\t\t}\n\t\t}\n\n\t\trds_ib_set_wr_signal_state(ic, send, 0);\n\n\t\t/*\n\t\t * Always signal the last one if we're stopping due to flow control.\n\t\t */\n\t\tif (ic->i_flowctl && flow_controlled && i == (work_alloc-1))\n\t\t\tsend->s_wr.send_flags |= IB_SEND_SIGNALED | IB_SEND_SOLICITED;\n\n\t\tif (send->s_wr.send_flags & IB_SEND_SIGNALED)\n\t\t\tnr_sig++;\n\n\t\trdsdebug(\"send %p wr %p num_sge %u next %p\\n\", send,\n\t\t\t &send->s_wr, send->s_wr.num_sge, send->s_wr.next);\n\n\t\tif (ic->i_flowctl && adv_credits) {\n\t\t\tstruct rds_header *hdr = &ic->i_send_hdrs[pos];\n\n\t\t\t/* add credit and redo the header checksum */\n\t\t\thdr->h_credit = adv_credits;\n\t\t\trds_message_make_checksum(hdr);\n\t\t\tadv_credits = 0;\n\t\t\trds_ib_stats_inc(s_ib_tx_credit_updates);\n\t\t}\n\n\t\tif (prev)\n\t\t\tprev->s_wr.next = &send->s_wr;\n\t\tprev = send;\n\n\t\tpos = (pos + 1) % ic->i_send_ring.w_nr;\n\t\tsend = &ic->i_sends[pos];\n\t\ti++;\n\n\t} while (i < work_alloc\n\t\t && scat != &rm->data.op_sg[rm->data.op_count]);\n\n\t/* Account the RDS header in the number of bytes we sent, but just once.\n\t * The caller has no concept of fragmentation. */\n\tif (hdr_off == 0)\n\t\tbytes_sent += sizeof(struct rds_header);\n\n\t/* if we finished the message then send completion owns it */\n\tif (scat == &rm->data.op_sg[rm->data.op_count]) {\n\t\tprev->s_op = ic->i_data_op;\n\t\tprev->s_wr.send_flags |= IB_SEND_SOLICITED;\n\t\tic->i_data_op = NULL;\n\t}\n\n\t/* Put back wrs & credits we didn't use */\n\tif (i < work_alloc) {\n\t\trds_ib_ring_unalloc(&ic->i_send_ring, work_alloc - i);\n\t\twork_alloc = i;\n\t}\n\tif (ic->i_flowctl && i < credit_alloc)\n\t\trds_ib_send_add_credits(conn, credit_alloc - i);\n\n\tif (nr_sig)\n\t\tatomic_add(nr_sig, &ic->i_signaled_sends);\n\n\t/* XXX need to worry about failed_wr and partial sends. */\n\tfailed_wr = &first->s_wr;\n\tret = ib_post_send(ic->i_cm_id->qp, &first->s_wr, &failed_wr);\n\trdsdebug(\"ic %p first %p (wr %p) ret %d wr %p\\n\", ic,\n\t\t first, &first->s_wr, ret, failed_wr);\n\tBUG_ON(failed_wr != &first->s_wr);\n\tif (ret) {\n\t\tprintk(KERN_WARNING \"RDS/IB: ib_post_send to %pI4 \"\n\t\t       \"returned %d\\n\", &conn->c_faddr, ret);\n\t\trds_ib_ring_unalloc(&ic->i_send_ring, work_alloc);\n\t\trds_ib_sub_signaled(ic, nr_sig);\n\t\tif (prev->s_op) {\n\t\t\tic->i_data_op = prev->s_op;\n\t\t\tprev->s_op = NULL;\n\t\t}\n\n\t\trds_ib_conn_error(ic->conn, \"ib_post_send failed\\n\");\n\t\tgoto out;\n\t}\n\n\tret = bytes_sent;\nout:\n\tBUG_ON(adv_credits);\n\treturn ret;\n}",
        "target": 1
    },
    {
        "func": "static struct kmem_cache *ccid_kmem_cache_create(int obj_size, char *slab_name_fmt, const char *fmt,...)\n{\n\tstruct kmem_cache *slab;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(slab_name_fmt, sizeof(slab_name_fmt), fmt, args);\n\tva_end(args);\n\n\tslab = kmem_cache_create(slab_name_fmt, sizeof(struct ccid) + obj_size, 0,\n\t\t\t\t SLAB_HWCACHE_ALIGN, NULL);\n\treturn slab;\n}",
        "target": 1
    },
    {
        "func": "xsltGenerateIdFunction(xmlXPathParserContextPtr ctxt, int nargs){\n    xmlNodePtr cur = NULL;\n    unsigned long val;\n    xmlChar str[20];\n\n    if (nargs == 0) {\n\tcur = ctxt->context->node;\n    } else if (nargs == 1) {\n\txmlXPathObjectPtr obj;\n\txmlNodeSetPtr nodelist;\n\tint i, ret;\n\n\tif ((ctxt->value == NULL) || (ctxt->value->type != XPATH_NODESET)) {\n\t    ctxt->error = XPATH_INVALID_TYPE;\n\t    xsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL,\n\t\t\"generate-id() : invalid arg expecting a node-set\\n\");\n\t    return;\n\t}\n\tobj = valuePop(ctxt);\n\tnodelist = obj->nodesetval;\n\tif ((nodelist == NULL) || (nodelist->nodeNr <= 0)) {\n\t    xmlXPathFreeObject(obj);\n\t    valuePush(ctxt, xmlXPathNewCString(\"\"));\n\t    return;\n\t}\n\tcur = nodelist->nodeTab[0];\n\tfor (i = 1;i < nodelist->nodeNr;i++) {\n\t    ret = xmlXPathCmpNodes(cur, nodelist->nodeTab[i]);\n\t    if (ret == -1)\n\t        cur = nodelist->nodeTab[i];\n\t}\n\txmlXPathFreeObject(obj);\n    } else {\n\txsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL,\n\t\t\"generate-id() : invalid number of args %d\\n\", nargs);\n\tctxt->error = XPATH_INVALID_ARITY;\n\treturn;\n    }\n    /*\n     * Okay this is ugly but should work, use the NodePtr address\n     * to forge the ID\n     */\n    val = (unsigned long)((char *)cur - (char *)0);\n    val /= sizeof(xmlNode);\n    sprintf((char *)str, \"id%ld\", val);\n    valuePush(ctxt, xmlXPathNewString(str));\n}",
        "target": 1
    },
    {
        "func": "int tpm_open(struct inode *inode, struct file *file)\n{\n\tint minor = iminor(inode);\n\tstruct tpm_chip *chip = NULL, *pos;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(pos, &tpm_chip_list, list) {\n\t\tif (pos->vendor.miscdev.minor == minor) {\n\t\t\tchip = pos;\n\t\t\tget_device(chip->dev);\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tif (!chip)\n\t\treturn -ENODEV;\n\n\tif (test_and_set_bit(0, &chip->is_open)) {\n\t\tdev_dbg(chip->dev, \"Another process owns this TPM\\n\");\n\t\tput_device(chip->dev);\n\t\treturn -EBUSY;\n\t}\n\n\tchip->data_buffer = kmalloc(TPM_BUFSIZE * sizeof(u8), GFP_KERNEL);\n\tif (chip->data_buffer == NULL) {\n\t\tclear_bit(0, &chip->is_open);\n\t\tput_device(chip->dev);\n\t\treturn -ENOMEM;\n\t}\n\n\tatomic_set(&chip->data_pending, 0);\n\n\tfile->private_data = chip;\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "_save_user_settings (GdmSessionWorker *worker,\n                     const char       *home_dir)\n{\n        GError *error;\n\n        if (!gdm_session_settings_is_loaded (worker->priv->user_settings)) {\n                return;\n        }\n\n        error = NULL;\n        if (!gdm_session_settings_save (worker->priv->user_settings,\n                                        home_dir, &error)) {\n                g_warning (\"could not save session and language settings: %s\",\n                           error->message);\n                g_error_free (error);\n        }\n}",
        "target": 1
    },
    {
        "func": "gdm_session_settings_load (GdmSessionSettings  *settings,\n                           const char          *home_directory,\n                           GError             **error)\n{\n        GKeyFile *key_file;\n        GError   *load_error;\n        gboolean  is_loaded;\n        char     *session_name;\n        char     *language_name;\n        char     *layout_name;\n        char     *filename;\n\n        g_return_val_if_fail (settings != NULL, FALSE);\n        g_return_val_if_fail (home_directory != NULL, FALSE);\n        g_return_val_if_fail (!gdm_session_settings_is_loaded (settings), FALSE);\n        filename = g_build_filename (home_directory, \".dmrc\", NULL);\n\n        is_loaded = FALSE;\n        key_file = g_key_file_new ();\n\n        load_error = NULL;\n        if (!g_key_file_load_from_file (key_file, filename,\n                                        G_KEY_FILE_NONE, &load_error)) {\n                g_propagate_error (error, load_error);\n                goto out;\n        }\n\n        session_name = g_key_file_get_string (key_file, \"Desktop\", \"Session\",\n                                              &load_error);\n\n        if (session_name != NULL) {\n                gdm_session_settings_set_session_name (settings, session_name);\n                g_free (session_name);\n        } else if (g_error_matches (load_error, G_KEY_FILE_ERROR, G_KEY_FILE_ERROR_KEY_NOT_FOUND)) {\n                g_error_free (load_error);\n                load_error = NULL;\n        } else {\n                g_propagate_error (error, load_error);\n                goto out;\n        }\n\n        language_name = g_key_file_get_string (key_file, \"Desktop\", \"Language\",\n                                               &load_error);\n\n        if (language_name != NULL) {\n                gdm_session_settings_set_language_name (settings, language_name);\n                g_free (language_name);\n        } else if (g_error_matches (load_error, G_KEY_FILE_ERROR, G_KEY_FILE_ERROR_KEY_NOT_FOUND)) {\n                g_error_free (load_error);\n                load_error = NULL;\n        } else {\n                g_propagate_error (error, load_error);\n                goto out;\n        }\n\n        layout_name = g_key_file_get_string (key_file, \"Desktop\", \"Layout\",\n                                             &load_error);\n\n        if (layout_name != NULL) {\n                gdm_session_settings_set_layout_name (settings, layout_name);\n                g_free (layout_name);\n        } else if (g_error_matches (load_error, G_KEY_FILE_ERROR, G_KEY_FILE_ERROR_KEY_NOT_FOUND)) {\n                g_error_free (load_error);\n                load_error = NULL;\n        } else {\n                g_propagate_error (error, load_error);\n                goto out;\n        }\n\n        is_loaded = TRUE;\nout:\n        g_key_file_free (key_file);\n        g_free (filename);\n\n        return is_loaded;\n}",
        "target": 1
    },
    {
        "func": "gdm_user_render_icon (GdmUser   *user,\n                      gint       icon_size)\n{\n        GdkPixbuf    *pixbuf;\n        GdkPixbuf    *framed;\n        char         *path;\n        char         *tmp;\n        gboolean      res;\n\n        g_return_val_if_fail (GDM_IS_USER (user), NULL);\n        g_return_val_if_fail (icon_size > 12, NULL);\n\n        path = NULL;\n\n        pixbuf = render_icon_from_home (user, icon_size);\n        if (pixbuf != NULL) {\n                goto out;\n        }\n\n        /* Try ${GlobalFaceDir}/${username} */\n        path = g_build_filename (GLOBAL_FACEDIR, user->user_name, NULL);\n        res = check_user_file (path,\n                               user->uid,\n                               MAX_FILE_SIZE,\n                               RELAX_GROUP,\n                               RELAX_OTHER);\n        if (res) {\n                pixbuf = gdk_pixbuf_new_from_file_at_size (path,\n                                                           icon_size,\n                                                           icon_size,\n                                                           NULL);\n        } else {\n                pixbuf = NULL;\n        }\n\n        g_free (path);\n        if (pixbuf != NULL) {\n                goto out;\n        }\n\n        /* Finally, ${GlobalFaceDir}/${username}.png */\n        tmp = g_strconcat (user->user_name, \".png\", NULL);\n        path = g_build_filename (GLOBAL_FACEDIR, tmp, NULL);\n        g_free (tmp);\n        res = check_user_file (path,\n                               user->uid,\n                               MAX_FILE_SIZE,\n                               RELAX_GROUP,\n                               RELAX_OTHER);\n        if (res) {\n                pixbuf = gdk_pixbuf_new_from_file_at_size (path,\n                                                           icon_size,\n                                                           icon_size,\n                                                           NULL);\n        } else {\n                pixbuf = NULL;\n        }\n        g_free (path);\n out:\n\n        if (pixbuf != NULL) {\n                framed = frame_pixbuf (pixbuf);\n                if (framed != NULL) {\n                        g_object_unref (pixbuf);\n                        pixbuf = framed;\n                }\n        }\n\n        return pixbuf;\n}",
        "target": 1
    },
    {
        "func": "gdm_session_worker_start_user_session (GdmSessionWorker  *worker,\n                                       GError           **error)\n{\n        struct passwd *passwd_entry;\n        pid_t session_pid;\n        int   error_code;\n\n        g_debug (\"GdmSessionWorker: querying pam for user environment\");\n        gdm_session_worker_update_environment_from_pam (worker);\n\n        register_ck_session (worker);\n\n        passwd_entry = getpwnam (worker->priv->username);\n\n#ifdef  HAVE_LOGINDEVPERM\n        /*\n         * Only do logindevperm processing if /dev/console or\n         * a device associated with a VT\n         */\n        if (worker->priv->display_device != NULL &&\n           (strncmp (worker->priv->display_device, \"/dev/vt/\", strlen (\"/dev/vt/\")) == 0 ||\n            strcmp  (worker->priv->display_device, \"/dev/console\") == 0)) {\n                g_debug (\"Logindevperm login for user %s, device %s\",\n                         worker->priv->username,\n                         worker->priv->display_device);\n                (void) di_devperm_login (worker->priv->display_device,\n                                         passwd_entry->pw_uid,\n                                         passwd_entry->pw_gid,\n                                         NULL);\n        }\n#endif  /* HAVE_LOGINDEVPERM */\n\n        g_debug (\"GdmSessionWorker: opening user session with program '%s'\",\n                 worker->priv->arguments[0]);\n\n        error_code = PAM_SUCCESS;\n\n        session_pid = fork ();\n\n        if (session_pid < 0) {\n                g_set_error (error,\n                             GDM_SESSION_WORKER_ERROR,\n                             GDM_SESSION_WORKER_ERROR_OPENING_SESSION,\n                             \"%s\", g_strerror (errno));\n                error_code = PAM_ABORT;\n                goto out;\n        }\n\n        if (session_pid == 0) {\n                char **environment;\n                char  *home_dir;\n                int    fd;\n\n                if (setuid (worker->priv->uid) < 0) {\n                        g_debug (\"GdmSessionWorker: could not reset uid - %s\", g_strerror (errno));\n                        _exit (1);\n                }\n\n                if (setsid () < 0) {\n                        g_debug (\"GdmSessionWorker: could not set pid '%u' as leader of new session and process group - %s\",\n                                 (guint) getpid (), g_strerror (errno));\n                        _exit (2);\n                }\n\n                environment = gdm_session_worker_get_environment (worker);\n\n                g_assert (geteuid () == getuid ());\n\n                home_dir = g_hash_table_lookup (worker->priv->environment,\n                                                \"HOME\");\n\n                if ((home_dir == NULL) || g_chdir (home_dir) < 0) {\n                        g_chdir (\"/\");\n                }\n\n                fd = open (\"/dev/null\", O_RDWR);\n                dup2 (fd, STDIN_FILENO);\n                close (fd);\n\n                fd = _open_session_log (home_dir);\n                dup2 (fd, STDOUT_FILENO);\n                dup2 (fd, STDERR_FILENO);\n                close (fd);\n\n                _save_user_settings (worker, home_dir);\n\n                gdm_session_execute (worker->priv->arguments[0],\n                                     worker->priv->arguments,\n                                     environment,\n                                     TRUE);\n\n                g_debug (\"GdmSessionWorker: child '%s' could not be started - %s\",\n                         worker->priv->arguments[0],\n                         g_strerror (errno));\n                g_strfreev (environment);\n\n                _exit (127);\n        }\n\n        worker->priv->child_pid = session_pid;\n\n        g_debug (\"GdmSessionWorker: session opened creating reply...\");\n        g_assert (sizeof (GPid) <= sizeof (int));\n\n        g_debug (\"GdmSessionWorker: state SESSION_STARTED\");\n        worker->priv->state = GDM_SESSION_WORKER_STATE_SESSION_STARTED;\n\n        gdm_session_worker_watch_child (worker);\n\n out:\n        if (error_code != PAM_SUCCESS) {\n                gdm_session_worker_uninitialize_pam (worker, error_code);\n                return FALSE;\n        }\n\n        return TRUE;\n}",
        "target": 1
    },
    {
        "func": "_change_user (GdmSessionWorker  *worker,\n              uid_t              uid,\n              gid_t              gid)\n{\n        gboolean ret;\n\n        ret = FALSE;\n\n#ifdef THE_MAN_PAGE_ISNT_LYING\n        /* pam_setcred wants to be called as the authenticated user\n         * but pam_open_session needs to be called as super-user.\n         *\n         * Set the real uid and gid to the user and give the user a\n         * temporary super-user effective id.\n         */\n        if (setreuid (uid, GDM_SESSION_ROOT_UID) < 0) {\n                return FALSE;\n        }\n#endif\n        worker->priv->uid = uid;\n\n        if (setgid (gid) < 0) {\n                return FALSE;\n        }\n\n        if (initgroups (worker->priv->username, gid) < 0) {\n                return FALSE;\n        }\n\n        return TRUE;\n}",
        "target": 1
    },
    {
        "func": "attempt_to_load_user_settings (GdmSessionWorker *worker,\n                               const char       *username)\n{\n        struct passwd *passwd_entry;\n        uid_t          old_uid;\n        gid_t          old_gid;\n\n        old_uid = geteuid ();\n        old_gid = getegid ();\n\n        passwd_entry = getpwnam (username);\n\n        /* User input isn't a valid username\n         */\n        if (passwd_entry == NULL) {\n                return;\n        }\n\n        /* We may get called late in the pam conversation after\n         * the user has already been authenticated.  This could\n         * happen if for instance, the user's home directory isn't\n         * available until late in the pam conversation so user\n         * settings couldn't get loaded until late in the conversation.\n         * If we get called late the seteuid/setgid calls here will fail,\n         * but that's okay, because we'll already be the uid/gid we want\n         * to be.\n         */\n        setegid (passwd_entry->pw_gid);\n        seteuid (passwd_entry->pw_uid);\n\n        gdm_session_settings_load (worker->priv->user_settings,\n                                   passwd_entry->pw_dir,\n                                   NULL);\n\n        seteuid (old_uid);\n        setegid (old_gid);\n}",
        "target": 1
    },
    {
        "func": "render_icon_from_home (GdmUser *user,\n                       int      icon_size)\n{\n        GdkPixbuf  *retval;\n        char       *path;\n        gboolean    is_local;\n        gboolean    is_autofs;\n        gboolean    res;\n        char       *filesystem_type;\n\n        is_local = FALSE;\n\n        /* special case: look at parent of home to detect autofs\n           this is so we don't try to trigger an automount */\n        path = g_path_get_dirname (user->home_dir);\n        filesystem_type = get_filesystem_type (path);\n        is_autofs = (filesystem_type != NULL && strcmp (filesystem_type, \"autofs\") == 0);\n        g_free (filesystem_type);\n        g_free (path);\n\n        if (is_autofs) {\n                return NULL;\n        }\n\n        /* now check that home dir itself is local */\n        filesystem_type = get_filesystem_type (user->home_dir);\n        is_local = ((filesystem_type != NULL) &&\n                    (strcmp (filesystem_type, \"nfs\") != 0) &&\n                    (strcmp (filesystem_type, \"afs\") != 0) &&\n                    (strcmp (filesystem_type, \"autofs\") != 0) &&\n                    (strcmp (filesystem_type, \"unknown\") != 0) &&\n                    (strcmp (filesystem_type, \"ncpfs\") != 0));\n        g_free (filesystem_type);\n\n        /* only look at local home directories so we don't try to\n           read from remote (e.g. NFS) volumes */\n        if (! is_local) {\n                return NULL;\n        }\n\n        /* First, try \"~/.face\" */\n        path = g_build_filename (user->home_dir, \".face\", NULL);\n        res = check_user_file (path,\n                               user->uid,\n                               MAX_FILE_SIZE,\n                               RELAX_GROUP,\n                               RELAX_OTHER);\n        if (res) {\n                retval = gdk_pixbuf_new_from_file_at_size (path,\n                                                           icon_size,\n                                                           icon_size,\n                                                           NULL);\n        } else {\n                retval = NULL;\n        }\n        g_free (path);\n\n        /* Next, try \"~/.face.icon\" */\n        if (retval == NULL) {\n                path = g_build_filename (user->home_dir,\n                                         \".face.icon\",\n                                         NULL);\n                res = check_user_file (path,\n                                       user->uid,\n                                       MAX_FILE_SIZE,\n                                       RELAX_GROUP,\n                                       RELAX_OTHER);\n                if (res) {\n                        retval = gdk_pixbuf_new_from_file_at_size (path,\n                                                                   icon_size,\n                                                                   icon_size,\n                                                                   NULL);\n                } else {\n                        retval = NULL;\n                }\n\n                g_free (path);\n        }\n\n        /* Still nothing, try the user's personal GDM config */\n        if (retval == NULL) {\n                path = g_build_filename (user->home_dir,\n                                         \".gnome\",\n                                         \"gdm\",\n                                         NULL);\n                res = check_user_file (path,\n                                       user->uid,\n                                       MAX_FILE_SIZE,\n                                       RELAX_GROUP,\n                                       RELAX_OTHER);\n                if (res) {\n                        GKeyFile *keyfile;\n                        char     *icon_path;\n\n                        keyfile = g_key_file_new ();\n                        g_key_file_load_from_file (keyfile,\n                                                   path,\n                                                   G_KEY_FILE_NONE,\n                                                   NULL);\n\n                        icon_path = g_key_file_get_string (keyfile,\n                                                           \"face\",\n                                                           \"picture\",\n                                                           NULL);\n                        res = check_user_file (icon_path,\n                                               user->uid,\n                                               MAX_FILE_SIZE,\n                                               RELAX_GROUP,\n                                               RELAX_OTHER);\n                        if (icon_path && res) {\n                                retval = gdk_pixbuf_new_from_file_at_size (path,\n                                                                           icon_size,\n                                                                           icon_size,\n                                                                           NULL);\n                        } else {\n                                retval = NULL;\n                        }\n\n                        g_free (icon_path);\n                        g_key_file_free (keyfile);\n                } else {\n                        retval = NULL;\n                }\n\n                g_free (path);\n        }\n\n        return retval;\n}",
        "target": 1
    },
    {
        "func": "gdm_session_worker_uninitialize_pam (GdmSessionWorker *worker,\n                                     int               status)\n{\n        g_debug (\"GdmSessionWorker: uninitializing PAM\");\n\n        if (worker->priv->pam_handle == NULL)\n                return;\n\n        if (worker->priv->state >= GDM_SESSION_WORKER_STATE_SESSION_OPENED) {\n                pam_close_session (worker->priv->pam_handle, 0);\n                gdm_session_auditor_report_logout (worker->priv->auditor);\n\n#ifdef  HAVE_LOGINDEVPERM\n                /*\n                 * Only do logindevperm processing if /dev/console or\n                 * a device associated with a VT\n                 */\n                if (worker->priv->display_device != NULL &&\n                   (strncmp (worker->priv->display_device, \"/dev/vt/\", strlen (\"/dev/vt/\")) == 0 ||\n                    strcmp  (worker->priv->display_device, \"/dev/console\") == 0)) {\n                        g_debug (\"Logindevperm logout for user %s, device %s\",\n                                 worker->priv->username,\n                                 worker->priv->display_device);\n                        (void) di_devperm_logout (worker->priv->display_device);\n                }\n#endif  /* HAVE_LOGINDEVPERM */\n\n        } else {\n                void *p;\n\n                if ((pam_get_item (worker->priv->pam_handle, PAM_USER, &p)) == PAM_SUCCESS) {\n                        gdm_session_auditor_set_username (worker->priv->auditor, (const char *)p);\n                }\n\n                gdm_session_auditor_report_login_failure (worker->priv->auditor,\n                                                          status,\n                                                          pam_strerror (worker->priv->pam_handle, status));\n        }\n\n        if (worker->priv->state >= GDM_SESSION_WORKER_STATE_ACCREDITED) {\n                pam_setcred (worker->priv->pam_handle, PAM_DELETE_CRED);\n        }\n\n        pam_end (worker->priv->pam_handle, status);\n        worker->priv->pam_handle = NULL;\n\n        gdm_session_worker_stop_auditor (worker);\n\n        g_debug (\"GdmSessionWorker: state NONE\");\n        worker->priv->state = GDM_SESSION_WORKER_STATE_NONE;\n}",
        "target": 1
    },
    {
        "func": "check_user_file (const char *filename,\n                 uid_t       user,\n                 gssize      max_file_size,\n                 gboolean    relax_group,\n                 gboolean    relax_other)\n{\n        struct stat fileinfo;\n\n        if (max_file_size < 0) {\n                max_file_size = G_MAXSIZE;\n        }\n\n        /* Exists/Readable? */\n        if (stat (filename, &fileinfo) < 0) {\n                return FALSE;\n        }\n\n        /* Is a regular file */\n        if (G_UNLIKELY (!S_ISREG (fileinfo.st_mode))) {\n                return FALSE;\n        }\n\n        /* Owned by user? */\n        if (G_UNLIKELY (fileinfo.st_uid != user)) {\n                return FALSE;\n        }\n\n        /* Group not writable or relax_group? */\n        if (G_UNLIKELY ((fileinfo.st_mode & S_IWGRP) == S_IWGRP && !relax_group)) {\n                return FALSE;\n        }\n\n        /* Other not writable or relax_other? */\n        if (G_UNLIKELY ((fileinfo.st_mode & S_IWOTH) == S_IWOTH && !relax_other)) {\n                return FALSE;\n        }\n\n        /* Size is kosher? */\n        if (G_UNLIKELY (fileinfo.st_size > max_file_size)) {\n                return FALSE;\n        }\n\n        return TRUE;\n}",
        "target": 1
    },
    {
        "func": "network_init ()\n{\n#ifdef HAVE_GNUTLS\n    char *ca_path, *ca_path2;\n\n    gnutls_global_init ();\n    gnutls_certificate_allocate_credentials (&gnutls_xcred);\n    \n    ca_path = string_expand_home (CONFIG_STRING(config_network_gnutls_ca_file));\n    if (ca_path)\n    {\n        ca_path2 = string_replace (ca_path, \"%h\", weechat_home);\n        if (ca_path2)\n        {\n            gnutls_certificate_set_x509_trust_file (gnutls_xcred, ca_path2,\n                                                    GNUTLS_X509_FMT_PEM);\n            free (ca_path2);\n        }\n        free (ca_path);\n    }\n    gnutls_certificate_client_set_retrieve_function (gnutls_xcred,\n                                                     &hook_connect_gnutls_set_certificates);\n    network_init_ok = 1;\n#endif\n#ifdef HAVE_GCRYPT\n    gcry_check_version (GCRYPT_VERSION);\n    gcry_control (GCRYCTL_DISABLE_SECMEM, 0);\n    gcry_control (GCRYCTL_INITIALIZATION_FINISHED, 0);\n#endif\n}",
        "target": 1
    },
    {
        "func": "irc_server_gnutls_callback (void *data, gnutls_session_t tls_session,\n                            const gnutls_datum_t *req_ca, int nreq,\n                            const gnutls_pk_algorithm_t *pk_algos,\n                            int pk_algos_len, gnutls_retr_st *answer)\n{\n    struct t_irc_server *server;\n    gnutls_retr_st tls_struct;\n    gnutls_x509_crt_t cert_temp;\n    const gnutls_datum_t *cert_list;\n    gnutls_datum_t filedatum;\n    unsigned int cert_list_len, status;\n    time_t cert_time;\n    char *cert_path0, *cert_path1, *cert_path2, *cert_str, *hostname;\n    const char *weechat_dir;\n    int rc, ret, i, j, hostname_match;\n#if LIBGNUTLS_VERSION_NUMBER >= 0x010706\n    gnutls_datum_t cinfo;\n    int rinfo;\n#endif\n\n    /* make C compiler happy */\n    (void) req_ca;\n    (void) nreq;\n    (void) pk_algos;\n    (void) pk_algos_len;\n    \n    rc = 0;\n    \n    if (!data)\n        return -1;\n    \n    server = (struct t_irc_server *) data;\n    hostname = server->current_address;\n    hostname_match = 0;\n    \n    weechat_printf (server->buffer,\n                    _(\"gnutls: connected using %d-bit Diffie-Hellman shared \"\n                      \"secret exchange\"),\n                    IRC_SERVER_OPTION_INTEGER (server,\n                                               IRC_SERVER_OPTION_SSL_DHKEY_SIZE));\n    if (gnutls_certificate_verify_peers2 (tls_session, &status) < 0)\n    {\n        weechat_printf (server->buffer,\n                        _(\"%sgnutls: error while checking peer's certificate\"),\n                        weechat_prefix (\"error\"));\n        rc = -1;\n    }\n    else\n    {\n        /* some checks */\n        if (status & GNUTLS_CERT_INVALID)\n        {\n            weechat_printf (server->buffer,\n                            _(\"%sgnutls: peer's certificate is NOT trusted\"),\n                            weechat_prefix (\"error\"));\n            rc = -1;\n        }\n        else\n        {\n            weechat_printf (server->buffer,\n                            _(\"gnutls: peer's certificate is trusted\"));\n        }\n        if (status & GNUTLS_CERT_SIGNER_NOT_FOUND)\n        {\n            weechat_printf (server->buffer,\n                            _(\"%sgnutls: peer's certificate issuer is unknown\"),\n                            weechat_prefix (\"error\"));\n            rc = -1;\n        }\n        if (status & GNUTLS_CERT_REVOKED)\n        {\n            weechat_printf (server->buffer,\n                            _(\"%sgnutls: the certificate has been revoked\"),\n                            weechat_prefix (\"error\"));\n            rc = -1;\n        }\n        \n        /* check certificates */\n        if (gnutls_x509_crt_init (&cert_temp) >= 0)\n        {\n            cert_list = gnutls_certificate_get_peers (tls_session, &cert_list_len);\n            if (cert_list)\n            {\n                weechat_printf (server->buffer,\n                                NG_(\"gnutls: receiving %d certificate\",\n                                    \"gnutls: receiving %d certificates\",\n                                    cert_list_len),\n                                cert_list_len);\n                for (i = 0, j = (int) cert_list_len; i < j; i++)\n                {\n                    if (gnutls_x509_crt_import (cert_temp, &cert_list[i], GNUTLS_X509_FMT_DER) >= 0)\n                    {\n                        /* checking if hostname matches in the first certificate */\n                        if (i == 0 && gnutls_x509_crt_check_hostname (cert_temp, hostname) != 0)\n                        {\n                            hostname_match = 1;\n                        }\n#if LIBGNUTLS_VERSION_NUMBER >= 0x010706\n                        /* displaying infos about certificate */\n#if LIBGNUTLS_VERSION_NUMBER < 0x020400\n                        rinfo = gnutls_x509_crt_print (cert_temp, GNUTLS_X509_CRT_ONELINE, &cinfo);\n#else\n                        rinfo = gnutls_x509_crt_print (cert_temp, GNUTLS_CRT_PRINT_ONELINE, &cinfo);\n#endif\n                        if (rinfo == 0)\n                        {\n                            weechat_printf (server->buffer,\n                                            _(\" - certificate[%d] info:\"), i + 1);\n                            weechat_printf (server->buffer,\n                                            \"   - %s\", cinfo.data);\n                            gnutls_free (cinfo.data);\n                        }\n#endif\n                        /* check expiration date */\n                        cert_time = gnutls_x509_crt_get_expiration_time (cert_temp);\n                        if (cert_time < time(NULL))\n                        {\n                            weechat_printf (server->buffer,\n                                            _(\"%sgnutls: certificate has expired\"),\n                                            weechat_prefix (\"error\"));\n                            rc = -1;\n                        }\n                        /* check expiration date */\n                        cert_time = gnutls_x509_crt_get_activation_time (cert_temp);\n                        if (cert_time > time(NULL))\n                        {\n                            weechat_printf (server->buffer,\n                                            _(\"%sgnutls: certificate is not yet activated\"),\n                                            weechat_prefix (\"error\"));\n                            rc = -1;\n                        }\n                    }\n                }\n                if (hostname_match == 0)\n                {\n                    weechat_printf (server->buffer,\n                                    _(\"%sgnutls: the hostname in the \"\n                                      \"certificate does NOT match \\\"%s\\\"\"),\n                                    weechat_prefix (\"error\"), hostname);\n                    rc = -1;\n                }\n            }\n        }\n    }\n    \n    /* using client certificate if it exists */\n    cert_path0 = (char *) IRC_SERVER_OPTION_STRING(server,\n                                                   IRC_SERVER_OPTION_SSL_CERT);\n    if (cert_path0 && cert_path0[0])\n    {\n        weechat_dir = weechat_info_get (\"weechat_dir\", \"\");\n        cert_path1 = weechat_string_replace (cert_path0, \"%h\", weechat_dir);\n        cert_path2 = (cert_path1) ?\n            weechat_string_expand_home (cert_path1) : NULL;\n        \n        if (cert_path2)\n        {\n            cert_str = weechat_file_get_content (cert_path2);\n            if (cert_str)\n            {\n                weechat_printf (server->buffer,\n                                _(\"gnutls: sending one certificate\"));\n                \n                filedatum.data = (unsigned char *) cert_str;\n                filedatum.size = strlen (cert_str);\n                \n                /* certificate */\n                gnutls_x509_crt_init (&server->tls_cert);\n                gnutls_x509_crt_import (server->tls_cert, &filedatum,\n                                        GNUTLS_X509_FMT_PEM);\n                \n                /* key */\n                gnutls_x509_privkey_init (&server->tls_cert_key);\n                ret = gnutls_x509_privkey_import (server->tls_cert_key,\n                                                  &filedatum,\n                                                  GNUTLS_X509_FMT_PEM);\n                if (ret < 0)\n                {\n                    ret = gnutls_x509_privkey_import_pkcs8 (server->tls_cert_key,\n                                                            &filedatum,\n                                                            GNUTLS_X509_FMT_PEM,\n                                                            NULL,\n                                                            GNUTLS_PKCS_PLAIN);\n                }\n                if (ret < 0)\n                {\n                    weechat_printf (server->buffer,\n                                    _(\"%sgnutls: invalid certificate \\\"%s\\\", \"\n                                      \"error: %s\"),\n                                    weechat_prefix (\"error\"), cert_path2,\n                                    gnutls_strerror (ret));\n                    rc = -1;\n                }\n                else\n                {\n                    tls_struct.type = GNUTLS_CRT_X509;\n                    tls_struct.ncerts = 1;\n                    tls_struct.deinit_all = 0;\n                    tls_struct.cert.x509 = &server->tls_cert;\n                    tls_struct.key.x509 = server->tls_cert_key;\n#if LIBGNUTLS_VERSION_NUMBER >= 0x010706\n                    /* client certificate info */\n#if LIBGNUTLS_VERSION_NUMBER < 0x020400\n                    rinfo = gnutls_x509_crt_print (server->tls_cert,\n                                                   GNUTLS_X509_CRT_ONELINE,\n                                                   &cinfo);\n#else\n                    rinfo = gnutls_x509_crt_print (server->tls_cert,\n                                                   GNUTLS_CRT_PRINT_ONELINE,\n                                                   &cinfo);\n#endif\n                    if (rinfo == 0)\n                    {\n                        weechat_printf (server->buffer,\n                                        _(\" - client certificate info (%s):\"),\n                                        cert_path2);\n                        weechat_printf (server->buffer, \"  - %s\", cinfo.data);\n                        gnutls_free (cinfo.data);\n                    }\n#endif\n                    memcpy (answer, &tls_struct, sizeof (gnutls_retr_st));\n                    free (cert_str);\n                }\n            }\n            else\n            {\n                weechat_printf (server->buffer,\n                                _(\"%sgnutls: unable to read certifcate \\\"%s\\\"\"),\n                                weechat_prefix (\"error\"), cert_path2);\n            }\n        }\n        \n        if (cert_path1)\n            free (cert_path1);\n        if (cert_path2)\n            free (cert_path2);\n    }\n    \n    /* an error should stop the handshake unless the user doesn't care */\n    if ((rc == -1)\n        && (IRC_SERVER_OPTION_BOOLEAN(server, IRC_SERVER_OPTION_SSL_VERIFY) == 0))\n    {\n        rc = 0;\n    }\n    \n    return rc;\n}",
        "target": 1
    },
    {
        "func": "hook_connect_gnutls_set_certificates (gnutls_session_t tls_session,\n                                      const gnutls_datum_t *req_ca, int nreq,\n                                      const gnutls_pk_algorithm_t *pk_algos,\n                                      int pk_algos_len,\n                                      gnutls_retr_st *answer)\n{\n    struct t_hook *ptr_hook;\n    int rc;\n    \n    rc = -1;\n    ptr_hook = weechat_hooks[HOOK_TYPE_CONNECT];\n    while (ptr_hook)\n    {\n        /* looking for the right hook using to the gnutls session pointer */\n        if (!ptr_hook->deleted\n            && HOOK_CONNECT(ptr_hook, gnutls_sess)\n            && (*(HOOK_CONNECT(ptr_hook, gnutls_sess)) == tls_session))\n        {\n            rc = (int) (HOOK_CONNECT(ptr_hook, gnutls_cb))\n                (ptr_hook->callback_data, tls_session, req_ca, nreq,\n                 pk_algos, pk_algos_len, answer);\n            break;\n        }\n        ptr_hook = ptr_hook->next_hook;\n    }\n    \n    return rc;\n}",
        "target": 1
    },
    {
        "func": "static int do_replace(struct net *net, const void __user *user,\n                      unsigned int len)\n{\n\tint ret;\n\tstruct arpt_replace tmp;\n\tstruct xt_table_info *newinfo;\n\tvoid *loc_cpu_entry;\n\tstruct arpt_entry *iter;\n\n\tif (copy_from_user(&tmp, user, sizeof(tmp)) != 0)\n\t\treturn -EFAULT;\n\n\t/* overflow check */\n\tif (tmp.num_counters >= INT_MAX / sizeof(struct xt_counters))\n\t\treturn -ENOMEM;\n\n\tnewinfo = xt_alloc_table_info(tmp.size);\n\tif (!newinfo)\n\t\treturn -ENOMEM;\n\n\t/* choose the copy that is on our node/cpu */\n\tloc_cpu_entry = newinfo->entries[raw_smp_processor_id()];\n\tif (copy_from_user(loc_cpu_entry, user + sizeof(tmp),\n\t\t\t   tmp.size) != 0) {\n\t\tret = -EFAULT;\n\t\tgoto free_newinfo;\n\t}\n\n\tret = translate_table(newinfo, loc_cpu_entry, &tmp);\n\tif (ret != 0)\n\t\tgoto free_newinfo;\n\n\tduprintf(\"arp_tables: Translated table\\n\");\n\n\tret = __do_replace(net, tmp.name, tmp.valid_hooks, newinfo,\n\t\t\t   tmp.num_counters, tmp.counters);\n\tif (ret)\n\t\tgoto free_newinfo_untrans;\n\treturn 0;\n\n free_newinfo_untrans:\n\txt_entry_foreach(iter, loc_cpu_entry, newinfo->size)\n\t\tcleanup_entry(iter);\n free_newinfo:\n\txt_free_table_info(newinfo);\n\treturn ret;\n}",
        "target": 1
    },
    {
        "func": "static int compat_do_replace(struct net *net, void __user *user,\n\t\t\t     unsigned int len)\n{\n\tint ret;\n\tstruct compat_arpt_replace tmp;\n\tstruct xt_table_info *newinfo;\n\tvoid *loc_cpu_entry;\n\tstruct arpt_entry *iter;\n\n\tif (copy_from_user(&tmp, user, sizeof(tmp)) != 0)\n\t\treturn -EFAULT;\n\n\t/* overflow check */\n\tif (tmp.size >= INT_MAX / num_possible_cpus())\n\t\treturn -ENOMEM;\n\tif (tmp.num_counters >= INT_MAX / sizeof(struct xt_counters))\n\t\treturn -ENOMEM;\n\n\tnewinfo = xt_alloc_table_info(tmp.size);\n\tif (!newinfo)\n\t\treturn -ENOMEM;\n\n\t/* choose the copy that is on our node/cpu */\n\tloc_cpu_entry = newinfo->entries[raw_smp_processor_id()];\n\tif (copy_from_user(loc_cpu_entry, user + sizeof(tmp), tmp.size) != 0) {\n\t\tret = -EFAULT;\n\t\tgoto free_newinfo;\n\t}\n\n\tret = translate_compat_table(tmp.name, tmp.valid_hooks,\n\t\t\t\t     &newinfo, &loc_cpu_entry, tmp.size,\n\t\t\t\t     tmp.num_entries, tmp.hook_entry,\n\t\t\t\t     tmp.underflow);\n\tif (ret != 0)\n\t\tgoto free_newinfo;\n\n\tduprintf(\"compat_do_replace: Translated table\\n\");\n\n\tret = __do_replace(net, tmp.name, tmp.valid_hooks, newinfo,\n\t\t\t   tmp.num_counters, compat_ptr(tmp.counters));\n\tif (ret)\n\t\tgoto free_newinfo_untrans;\n\treturn 0;\n\n free_newinfo_untrans:\n\txt_entry_foreach(iter, loc_cpu_entry, newinfo->size)\n\t\tcleanup_entry(iter);\n free_newinfo:\n\txt_free_table_info(newinfo);\n\treturn ret;\n}",
        "target": 1
    },
    {
        "func": "static int do_arpt_get_ctl(struct sock *sk, int cmd, void __user *user, int *len)\n{\n\tint ret;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tswitch (cmd) {\n\tcase ARPT_SO_GET_INFO:\n\t\tret = get_info(sock_net(sk), user, len, 0);\n\t\tbreak;\n\n\tcase ARPT_SO_GET_ENTRIES:\n\t\tret = get_entries(sock_net(sk), user, len);\n\t\tbreak;\n\n\tcase ARPT_SO_GET_REVISION_TARGET: {\n\t\tstruct xt_get_revision rev;\n\n\t\tif (*len != sizeof(rev)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (copy_from_user(&rev, user, sizeof(rev)) != 0) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\ttry_then_request_module(xt_find_revision(NFPROTO_ARP, rev.name,\n\t\t\t\t\t\t\t rev.revision, 1, &ret),\n\t\t\t\t\t\"arpt_%s\", rev.name);\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\tduprintf(\"do_arpt_get_ctl: unknown request %i\\n\", cmd);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}",
        "target": 1
    },
    {
        "func": "do_replace(struct net *net, const void __user *user, unsigned int len)\n{\n\tint ret;\n\tstruct ipt_replace tmp;\n\tstruct xt_table_info *newinfo;\n\tvoid *loc_cpu_entry;\n\tstruct ipt_entry *iter;\n\n\tif (copy_from_user(&tmp, user, sizeof(tmp)) != 0)\n\t\treturn -EFAULT;\n\n\t/* overflow check */\n\tif (tmp.num_counters >= INT_MAX / sizeof(struct xt_counters))\n\t\treturn -ENOMEM;\n\n\tnewinfo = xt_alloc_table_info(tmp.size);\n\tif (!newinfo)\n\t\treturn -ENOMEM;\n\n\t/* choose the copy that is on our node/cpu */\n\tloc_cpu_entry = newinfo->entries[raw_smp_processor_id()];\n\tif (copy_from_user(loc_cpu_entry, user + sizeof(tmp),\n\t\t\t   tmp.size) != 0) {\n\t\tret = -EFAULT;\n\t\tgoto free_newinfo;\n\t}\n\n\tret = translate_table(net, newinfo, loc_cpu_entry, &tmp);\n\tif (ret != 0)\n\t\tgoto free_newinfo;\n\n\tduprintf(\"Translated table\\n\");\n\n\tret = __do_replace(net, tmp.name, tmp.valid_hooks, newinfo,\n\t\t\t   tmp.num_counters, tmp.counters);\n\tif (ret)\n\t\tgoto free_newinfo_untrans;\n\treturn 0;\n\n free_newinfo_untrans:\n\txt_entry_foreach(iter, loc_cpu_entry, newinfo->size)\n\t\tcleanup_entry(iter, net);\n free_newinfo:\n\txt_free_table_info(newinfo);\n\treturn ret;\n}",
        "target": 1
    },
    {
        "func": "compat_do_replace(struct net *net, void __user *user, unsigned int len)\n{\n\tint ret;\n\tstruct compat_ipt_replace tmp;\n\tstruct xt_table_info *newinfo;\n\tvoid *loc_cpu_entry;\n\tstruct ipt_entry *iter;\n\n\tif (copy_from_user(&tmp, user, sizeof(tmp)) != 0)\n\t\treturn -EFAULT;\n\n\t/* overflow check */\n\tif (tmp.size >= INT_MAX / num_possible_cpus())\n\t\treturn -ENOMEM;\n\tif (tmp.num_counters >= INT_MAX / sizeof(struct xt_counters))\n\t\treturn -ENOMEM;\n\n\tnewinfo = xt_alloc_table_info(tmp.size);\n\tif (!newinfo)\n\t\treturn -ENOMEM;\n\n\t/* choose the copy that is on our node/cpu */\n\tloc_cpu_entry = newinfo->entries[raw_smp_processor_id()];\n\tif (copy_from_user(loc_cpu_entry, user + sizeof(tmp),\n\t\t\t   tmp.size) != 0) {\n\t\tret = -EFAULT;\n\t\tgoto free_newinfo;\n\t}\n\n\tret = translate_compat_table(net, tmp.name, tmp.valid_hooks,\n\t\t\t\t     &newinfo, &loc_cpu_entry, tmp.size,\n\t\t\t\t     tmp.num_entries, tmp.hook_entry,\n\t\t\t\t     tmp.underflow);\n\tif (ret != 0)\n\t\tgoto free_newinfo;\n\n\tduprintf(\"compat_do_replace: Translated table\\n\");\n\n\tret = __do_replace(net, tmp.name, tmp.valid_hooks, newinfo,\n\t\t\t   tmp.num_counters, compat_ptr(tmp.counters));\n\tif (ret)\n\t\tgoto free_newinfo_untrans;\n\treturn 0;\n\n free_newinfo_untrans:\n\txt_entry_foreach(iter, loc_cpu_entry, newinfo->size)\n\t\tcleanup_entry(iter, net);\n free_newinfo:\n\txt_free_table_info(newinfo);\n\treturn ret;\n}",
        "target": 1
    },
    {
        "func": "do_ipt_get_ctl(struct sock *sk, int cmd, void __user *user, int *len)\n{\n\tint ret;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tswitch (cmd) {\n\tcase IPT_SO_GET_INFO:\n\t\tret = get_info(sock_net(sk), user, len, 0);\n\t\tbreak;\n\n\tcase IPT_SO_GET_ENTRIES:\n\t\tret = get_entries(sock_net(sk), user, len);\n\t\tbreak;\n\n\tcase IPT_SO_GET_REVISION_MATCH:\n\tcase IPT_SO_GET_REVISION_TARGET: {\n\t\tstruct xt_get_revision rev;\n\t\tint target;\n\n\t\tif (*len != sizeof(rev)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (copy_from_user(&rev, user, sizeof(rev)) != 0) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (cmd == IPT_SO_GET_REVISION_TARGET)\n\t\t\ttarget = 1;\n\t\telse\n\t\t\ttarget = 0;\n\n\t\ttry_then_request_module(xt_find_revision(AF_INET, rev.name,\n\t\t\t\t\t\t\t rev.revision,\n\t\t\t\t\t\t\t target, &ret),\n\t\t\t\t\t\"ipt_%s\", rev.name);\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\tduprintf(\"do_ipt_get_ctl: unknown request %i\\n\", cmd);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}",
        "target": 1
    },
    {
        "func": "static ssize_t clusterip_proc_write(struct file *file, const char __user *input,\n\t\t\t\tsize_t size, loff_t *ofs)\n{\n\tstruct clusterip_config *c = PDE(file->f_path.dentry->d_inode)->data;\n#define PROC_WRITELEN\t10\n\tchar buffer[PROC_WRITELEN+1];\n\tunsigned long nodenum;\n\n\tif (copy_from_user(buffer, input, PROC_WRITELEN))\n\t\treturn -EFAULT;\n\n\tif (*buffer == '+') {\n\t\tnodenum = simple_strtoul(buffer+1, NULL, 10);\n\t\tif (clusterip_add_node(c, nodenum))\n\t\t\treturn -ENOMEM;\n\t} else if (*buffer == '-') {\n\t\tnodenum = simple_strtoul(buffer+1, NULL,10);\n\t\tif (clusterip_del_node(c, nodenum))\n\t\t\treturn -ENOENT;\n\t} else\n\t\treturn -EIO;\n\n\treturn size;\n}",
        "target": 1
    },
    {
        "func": "do_ip6t_get_ctl(struct sock *sk, int cmd, void __user *user, int *len)\n{\n\tint ret;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tswitch (cmd) {\n\tcase IP6T_SO_GET_INFO:\n\t\tret = get_info(sock_net(sk), user, len, 0);\n\t\tbreak;\n\n\tcase IP6T_SO_GET_ENTRIES:\n\t\tret = get_entries(sock_net(sk), user, len);\n\t\tbreak;\n\n\tcase IP6T_SO_GET_REVISION_MATCH:\n\tcase IP6T_SO_GET_REVISION_TARGET: {\n\t\tstruct xt_get_revision rev;\n\t\tint target;\n\n\t\tif (*len != sizeof(rev)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (copy_from_user(&rev, user, sizeof(rev)) != 0) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (cmd == IP6T_SO_GET_REVISION_TARGET)\n\t\t\ttarget = 1;\n\t\telse\n\t\t\ttarget = 0;\n\n\t\ttry_then_request_module(xt_find_revision(AF_INET6, rev.name,\n\t\t\t\t\t\t\t rev.revision,\n\t\t\t\t\t\t\t target, &ret),\n\t\t\t\t\t\"ip6t_%s\", rev.name);\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\tduprintf(\"do_ip6t_get_ctl: unknown request %i\\n\", cmd);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}",
        "target": 1
    },
    {
        "func": "compat_do_replace(struct net *net, void __user *user, unsigned int len)\n{\n\tint ret;\n\tstruct compat_ip6t_replace tmp;\n\tstruct xt_table_info *newinfo;\n\tvoid *loc_cpu_entry;\n\tstruct ip6t_entry *iter;\n\n\tif (copy_from_user(&tmp, user, sizeof(tmp)) != 0)\n\t\treturn -EFAULT;\n\n\t/* overflow check */\n\tif (tmp.size >= INT_MAX / num_possible_cpus())\n\t\treturn -ENOMEM;\n\tif (tmp.num_counters >= INT_MAX / sizeof(struct xt_counters))\n\t\treturn -ENOMEM;\n\n\tnewinfo = xt_alloc_table_info(tmp.size);\n\tif (!newinfo)\n\t\treturn -ENOMEM;\n\n\t/* choose the copy that is on our node/cpu */\n\tloc_cpu_entry = newinfo->entries[raw_smp_processor_id()];\n\tif (copy_from_user(loc_cpu_entry, user + sizeof(tmp),\n\t\t\t   tmp.size) != 0) {\n\t\tret = -EFAULT;\n\t\tgoto free_newinfo;\n\t}\n\n\tret = translate_compat_table(net, tmp.name, tmp.valid_hooks,\n\t\t\t\t     &newinfo, &loc_cpu_entry, tmp.size,\n\t\t\t\t     tmp.num_entries, tmp.hook_entry,\n\t\t\t\t     tmp.underflow);\n\tif (ret != 0)\n\t\tgoto free_newinfo;\n\n\tduprintf(\"compat_do_replace: Translated table\\n\");\n\n\tret = __do_replace(net, tmp.name, tmp.valid_hooks, newinfo,\n\t\t\t   tmp.num_counters, compat_ptr(tmp.counters));\n\tif (ret)\n\t\tgoto free_newinfo_untrans;\n\treturn 0;\n\n free_newinfo_untrans:\n\txt_entry_foreach(iter, loc_cpu_entry, newinfo->size)\n\t\tcleanup_entry(iter, net);\n free_newinfo:\n\txt_free_table_info(newinfo);\n\treturn ret;\n}",
        "target": 1
    },
    {
        "func": "do_replace(struct net *net, const void __user *user, unsigned int len)\n{\n\tint ret;\n\tstruct ip6t_replace tmp;\n\tstruct xt_table_info *newinfo;\n\tvoid *loc_cpu_entry;\n\tstruct ip6t_entry *iter;\n\n\tif (copy_from_user(&tmp, user, sizeof(tmp)) != 0)\n\t\treturn -EFAULT;\n\n\t/* overflow check */\n\tif (tmp.num_counters >= INT_MAX / sizeof(struct xt_counters))\n\t\treturn -ENOMEM;\n\n\tnewinfo = xt_alloc_table_info(tmp.size);\n\tif (!newinfo)\n\t\treturn -ENOMEM;\n\n\t/* choose the copy that is on our node/cpu */\n\tloc_cpu_entry = newinfo->entries[raw_smp_processor_id()];\n\tif (copy_from_user(loc_cpu_entry, user + sizeof(tmp),\n\t\t\t   tmp.size) != 0) {\n\t\tret = -EFAULT;\n\t\tgoto free_newinfo;\n\t}\n\n\tret = translate_table(net, newinfo, loc_cpu_entry, &tmp);\n\tif (ret != 0)\n\t\tgoto free_newinfo;\n\n\tduprintf(\"ip_tables: Translated table\\n\");\n\n\tret = __do_replace(net, tmp.name, tmp.valid_hooks, newinfo,\n\t\t\t   tmp.num_counters, tmp.counters);\n\tif (ret)\n\t\tgoto free_newinfo_untrans;\n\treturn 0;\n\n free_newinfo_untrans:\n\txt_entry_foreach(iter, loc_cpu_entry, newinfo->size)\n\t\tcleanup_entry(iter, net);\n free_newinfo:\n\txt_free_table_info(newinfo);\n\treturn ret;\n}",
        "target": 1
    },
    {
        "func": "load_image (const gchar  *filename,\n            GError      **error)\n{\n  FILE         *fd;\n  GimpDrawable *drawable;\n  GimpPixelRgn  pixel_rgn;\n  guint16       offset_x, offset_y, bytesperline;\n  gint32        width, height;\n  gint32        image, layer;\n  guchar       *dest, cmap[768];\n  guint8        header_buf[128];\n\n  fd = g_fopen (filename, \"rb\");\n\n  if (! fd)\n    {\n      g_set_error (error, G_FILE_ERROR, g_file_error_from_errno (errno),\n                   _(\"Could not open '%s' for reading: %s\"),\n                   gimp_filename_to_utf8 (filename), g_strerror (errno));\n      return -1;\n    }\n\n  gimp_progress_init_printf (_(\"Opening '%s'\"),\n                             gimp_filename_to_utf8 (filename));\n\n  if (fread (header_buf, 128, 1, fd) == 0)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"Could not read header from '%s'\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  pcx_header_from_buffer (header_buf);\n\n  if (pcx_header.manufacturer != 10)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"'%s' is not a PCX file\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  offset_x     = GUINT16_FROM_LE (pcx_header.x1);\n  offset_y     = GUINT16_FROM_LE (pcx_header.y1);\n  width        = GUINT16_FROM_LE (pcx_header.x2) - offset_x + 1;\n  height       = GUINT16_FROM_LE (pcx_header.y2) - offset_y + 1;\n  bytesperline = GUINT16_FROM_LE (pcx_header.bytesperline);\n\n  if ((width < 0) || (width > GIMP_MAX_IMAGE_SIZE))\n    {\n      g_message (_(\"Unsupported or invalid image width: %d\"), width);\n      return -1;\n    }\n  if ((height < 0) || (height > GIMP_MAX_IMAGE_SIZE))\n    {\n      g_message (_(\"Unsupported or invalid image height: %d\"), height);\n      return -1;\n    }\n  if (bytesperline < (width * pcx_header.bpp) / 8)\n    {\n      g_message (_(\"Invalid number of bytes per line in PCX header\"));\n      return -1;\n    }\n\n  /* Shield against potential buffer overflows in load_*() functions. */\n  if (G_MAXSIZE / width / height < 3)\n    {\n      g_message (_(\"Image dimensions too large: width %d x height %d\"), width, height);\n      return -1;\n    }\n\n  if (pcx_header.planes == 3 && pcx_header.bpp == 8)\n    {\n      image= gimp_image_new (width, height, GIMP_RGB);\n      layer= gimp_layer_new (image, _(\"Background\"), width, height,\n                             GIMP_RGB_IMAGE, 100, GIMP_NORMAL_MODE);\n    }\n  else\n    {\n      image= gimp_image_new (width, height, GIMP_INDEXED);\n      layer= gimp_layer_new (image, _(\"Background\"), width, height,\n                             GIMP_INDEXED_IMAGE, 100, GIMP_NORMAL_MODE);\n    }\n  gimp_image_set_filename (image, filename);\n  gimp_image_add_layer (image, layer, 0);\n  gimp_layer_set_offsets (layer, offset_x, offset_y);\n  drawable = gimp_drawable_get (layer);\n\n  if (pcx_header.planes == 1 && pcx_header.bpp == 1)\n    {\n      dest = g_new (guchar, width * height);\n      load_1 (fd, width, height, dest, bytesperline);\n      gimp_image_set_colormap (image, mono, 2);\n    }\n  else if (pcx_header.planes == 4 && pcx_header.bpp == 1)\n    {\n      dest = g_new (guchar, width * height);\n      load_4 (fd, width, height, dest, bytesperline);\n      gimp_image_set_colormap (image, pcx_header.colormap, 16);\n    }\n  else if (pcx_header.planes == 1 && pcx_header.bpp == 8)\n    {\n      dest = g_new (guchar, width * height);\n      load_8 (fd, width, height, dest, bytesperline);\n      fseek (fd, -768L, SEEK_END);\n      fread (cmap, 768, 1, fd);\n      gimp_image_set_colormap (image, cmap, 256);\n    }\n  else if (pcx_header.planes == 3 && pcx_header.bpp == 8)\n    {\n      dest = g_new (guchar, width * height * 3);\n      load_24 (fd, width, height, dest, bytesperline);\n    }\n  else\n    {\n      g_message (_(\"Unusual PCX flavour, giving up\"));\n      return -1;\n    }\n\n  gimp_pixel_rgn_init (&pixel_rgn, drawable, 0, 0, width, height, TRUE, FALSE);\n  gimp_pixel_rgn_set_rect (&pixel_rgn, dest, 0, 0, width, height);\n\n  g_free (dest);\n\n  gimp_drawable_flush (drawable);\n  gimp_drawable_detach (drawable);\n\n  return image;\n}",
        "target": 1
    },
    {
        "func": "long do_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig, siginfo_t *info)\n{\n\t/* This is only valid for single tasks */\n\tif (pid <= 0 || tgid <= 0)\n\t\treturn -EINVAL;\n\n\t/* Not even root can pretend to send signals from the kernel.\n\t   Nor can they impersonate a kill(), which adds source info.  */\n\tif (info->si_code >= 0)\n\t\treturn -EPERM;\n\tinfo->si_signo = sig;\n\n\treturn do_send_specific(tgid, pid, sig, info);\n}",
        "target": 1
    },
    {
        "func": "SYSCALL_DEFINE3(rt_sigqueueinfo, pid_t, pid, int, sig,\n\t\tsiginfo_t __user *, uinfo)\n{\n\tsiginfo_t info;\n\n\tif (copy_from_user(&info, uinfo, sizeof(siginfo_t)))\n\t\treturn -EFAULT;\n\n\t/* Not even root can pretend to send signals from the kernel.\n\t   Nor can they impersonate a kill(), which adds source info.  */\n\tif (info.si_code >= 0)\n\t\treturn -EPERM;\n\tinfo.si_signo = sig;\n\n\t/* POSIX.1b doesn't mention process groups.  */\n\treturn kill_proc_info(sig, &info, pid);\n}",
        "target": 1
    },
    {
        "func": "SYSCALL_DEFINE3(rt_sigqueueinfo, pid_t, pid, int, sig,\n\t\tsiginfo_t __user *, uinfo)\n{\n\tsiginfo_t info;\n\n\tif (copy_from_user(&info, uinfo, sizeof(siginfo_t)))\n\t\treturn -EFAULT;\n\n\t/* Not even root can pretend to send signals from the kernel.\n\t * Nor can they impersonate a kill()/tgkill(), which adds source info.\n\t */\n\tif (info.si_code != SI_QUEUE) {\n\t\t/* We used to allow any < 0 si_code */\n\t\tWARN_ON_ONCE(info.si_code < 0);\n\t\treturn -EPERM;\n\t}\n\tinfo.si_signo = sig;\n\n\t/* POSIX.1b doesn't mention process groups.  */\n\treturn kill_proc_info(sig, &info, pid);\n}",
        "target": 1
    },
    {
        "func": "long do_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig, siginfo_t *info)\n{\n\t/* This is only valid for single tasks */\n\tif (pid <= 0 || tgid <= 0)\n\t\treturn -EINVAL;\n\n\t/* Not even root can pretend to send signals from the kernel.\n\t * Nor can they impersonate a kill()/tgkill(), which adds source info.\n\t */\n\tif (info->si_code != SI_QUEUE) {\n\t\t/* We used to allow any < 0 si_code */\n\t\tWARN_ON_ONCE(info->si_code < 0);\n\t\treturn -EPERM;\n\t}\n\tinfo->si_signo = sig;\n\n\treturn do_send_specific(tgid, pid, sig, info);\n}",
        "target": 1
    },
    {
        "func": "static rsRetVal qAddDirect(qqueue_t *pThis, void* pUsr)\n{\n\tbatch_t singleBatch;\n\tbatch_obj_t batchObj;\n\tDEFiRet;\n\n\t//TODO: init batchObj (states _OK and new fields -- CHECK)\n\tASSERT(pThis != NULL);\n\n\t/* calling the consumer is quite different here than it is from a worker thread */\n\t/* we need to provide the consumer's return value back to the caller because in direct\n\t * mode the consumer probably has a lot to convey (which get's lost in the other modes\n\t * because they are asynchronous. But direct mode is deliberately synchronous.\n\t * rgerhards, 2008-02-12\n\t * We use our knowledge about the batch_t structure below, but without that, we\n\t * pay a too-large performance toll... -- rgerhards, 2009-04-22\n\t */\n\tmemset(&batchObj, 0, sizeof(batch_obj_t));\n\tmemset(&singleBatch, 0, sizeof(batch_t));\n\tbatchObj.state = BATCH_STATE_RDY;\n\tbatchObj.pUsrp = (obj_t*) pUsr;\n\tbatchObj.bFilterOK = 1;\n\tsingleBatch.nElem = 1; /* there always is only one in direct mode */\n\tsingleBatch.pElem = &batchObj;\n\tiRet = pThis->pConsumer(pThis->pUsr, &singleBatch, &pThis->bShutdownImmediate);\n\tobjDestruct(pUsr);\n\n\tRETiRet;\n}",
        "target": 1
    },
    {
        "func": "msg_t* MsgDup(msg_t* pOld)\n{\n\tmsg_t* pNew;\n\trsRetVal localRet;\n\n\tassert(pOld != NULL);\n\n\tBEGINfunc\n\tif(msgConstructWithTime(&pNew, &pOld->tTIMESTAMP, pOld->ttGenTime) != RS_RET_OK) {\n\t\treturn NULL;\n\t}\n\n\t/* now copy the message properties */\n\tpNew->iRefCount = 1;\n\tpNew->iSeverity = pOld->iSeverity;\n\tpNew->iFacility = pOld->iFacility;\n\tpNew->msgFlags = pOld->msgFlags;\n\tpNew->iProtocolVersion = pOld->iProtocolVersion;\n\tpNew->ttGenTime = pOld->ttGenTime;\n\tpNew->offMSG = pOld->offMSG;\n\tpNew->iLenRawMsg = pOld->iLenRawMsg;\n\tpNew->iLenMSG = pOld->iLenMSG;\n\tpNew->iLenTAG = pOld->iLenTAG;\n\tpNew->iLenHOSTNAME = pOld->iLenHOSTNAME;\n\tif((pOld->msgFlags & NEEDS_DNSRESOL) == 1) {\n\t\t\tlocalRet = msgSetFromSockinfo(pNew, pOld->rcvFrom.pfrominet);\n\t\t\tif(localRet != RS_RET_OK) {\n\t\t\t\t/* if something fails, we accept loss of this property, it is\n\t\t\t\t * better than losing the whole message.\n\t\t\t\t */\n\t\t\t\tpNew->msgFlags &= ~NEEDS_DNSRESOL;\n\t\t\t}\n\t} else {\n\t\tif(pOld->rcvFrom.pRcvFrom != NULL) {\n\t\t\tpNew->rcvFrom.pRcvFrom = pOld->rcvFrom.pRcvFrom;\n\t\t\tprop.AddRef(pNew->rcvFrom.pRcvFrom);\n\t\t}\n\t}\n\tif(pOld->pRcvFromIP != NULL) {\n\t\tpNew->pRcvFromIP = pOld->pRcvFromIP;\n\t\tprop.AddRef(pNew->pRcvFromIP);\n\t}\n\tif(pOld->pInputName != NULL) {\n\t\tpNew->pInputName = pOld->pInputName;\n\t\tprop.AddRef(pNew->pInputName);\n\t}\n\t/* enable this, if someone actually uses UxTradMsg, delete after some time has\n\t * passed and nobody complained -- rgerhards, 2009-06-16\n\tpNew->offAfterPRI = pOld->offAfterPRI;\n\t*/\n\tif(pOld->iLenTAG > 0) {\n\t\tif(pOld->iLenTAG < CONF_TAG_BUFSIZE) {\n\t\t\tmemcpy(pNew->TAG.szBuf, pOld->TAG.szBuf, pOld->iLenTAG);\n\t\t} else {\n\t\t\tif((pNew->TAG.pszTAG = srUtilStrDup(pOld->TAG.pszTAG, pOld->iLenTAG)) == NULL) {\n\t\t\t\tmsgDestruct(&pNew);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tpNew->iLenTAG = pOld->iLenTAG;\n\t\t}\n\t}\n\tif(pOld->iLenRawMsg < CONF_RAWMSG_BUFSIZE) {\n\t\tmemcpy(pNew->szRawMsg, pOld->szRawMsg, pOld->iLenRawMsg + 1);\n\t\tpNew->pszRawMsg = pNew->szRawMsg;\n\t} else {\n\t\ttmpCOPYSZ(RawMsg);\n\t}\n\tif(pOld->iLenHOSTNAME < CONF_HOSTNAME_BUFSIZE) {\n\t\tmemcpy(pNew->szHOSTNAME, pOld->szHOSTNAME, pOld->iLenHOSTNAME + 1);\n\t\tpNew->pszHOSTNAME = pNew->szHOSTNAME;\n\t} else {\n\t\ttmpCOPYSZ(HOSTNAME);\n\t}\n\n\ttmpCOPYCSTR(ProgName);\n\ttmpCOPYCSTR(StrucData);\n\ttmpCOPYCSTR(APPNAME);\n\ttmpCOPYCSTR(PROCID);\n\ttmpCOPYCSTR(MSGID);\n\n\t/* we do not copy all other cache properties, as we do not even know\n\t * if they are needed once again. So we let them re-create if needed.\n\t */\n\n\tENDfunc\n\treturn pNew;\n}",
        "target": 1
    },
    {
        "func": "processBatchMultiRuleset(batch_t *pBatch)\n{\n\truleset_t *currRuleset;\n\tbatch_t snglRuleBatch;\n\tint i;\n\tint iStart;\t/* start index of partial batch */\n\tint iNew;\t/* index for new (temporary) batch */\n\tDEFiRet;\n\n\tCHKiRet(batchInit(&snglRuleBatch, pBatch->nElem));\n\tsnglRuleBatch.pbShutdownImmediate = pBatch->pbShutdownImmediate;\n\n\twhile(1) { /* loop broken inside */\n\t\t/* search for first unprocessed element */\n\t\tfor(iStart = 0 ; iStart < pBatch->nElem && pBatch->pElem[iStart].state == BATCH_STATE_DISC ; ++iStart)\n\t\t\t/* just search, no action */;\n\n\t\tif(iStart == pBatch->nElem)\n\t\t\tFINALIZE; /* everything processed */\n\n\t\t/* prepare temporary batch */\n\t\tcurrRuleset = batchElemGetRuleset(pBatch, iStart);\n\t\tiNew = 0;\n\t\tfor(i = iStart ; i < pBatch->nElem ; ++i) {\n\t\t\tif(batchElemGetRuleset(pBatch, i) == currRuleset) {\n\t\t\t\tbatchCopyElem(&(snglRuleBatch.pElem[iNew++]), &(pBatch->pElem[i]));\n\t\t\t\t/* We indicate the element also as done, so it will not be processed again */\n\t\t\t\tpBatch->pElem[i].state = BATCH_STATE_DISC;\n\t\t\t}\n\t\t}\n\t\tsnglRuleBatch.nElem = iNew; /* was left just right by the for loop */\n\t\tbatchSetSingleRuleset(&snglRuleBatch, 1);\n\t\t/* process temp batch */\n\t\tprocessBatch(&snglRuleBatch);\n\t}\n\tbatchFree(&snglRuleBatch);\n\nfinalize_it:\n\tRETiRet;\n}",
        "target": 1
    },
    {
        "func": "batchInit(batch_t *pBatch, int maxElem) {\n\tDEFiRet;\n\tpBatch->maxElem = maxElem;\n\tCHKmalloc(pBatch->pElem = calloc((size_t)maxElem, sizeof(batch_obj_t)));\n\t// TODO: replace calloc by inidividual writes?\nfinalize_it:\n\tRETiRet;\n}",
        "target": 1
    },
    {
        "func": "batchCopyElem(batch_obj_t *pDest, batch_obj_t *pSrc) {\n\tmemcpy(pDest, pSrc, sizeof(batch_obj_t));\n}",
        "target": 1
    },
    {
        "func": "rfbSendFramebufferUpdate(rfbClientPtr cl,\n                         sraRegionPtr givenUpdateRegion)\n{\n    sraRectangleIterator* i=NULL;\n    sraRect rect;\n    int nUpdateRegionRects;\n    rfbFramebufferUpdateMsg *fu = (rfbFramebufferUpdateMsg *)cl->updateBuf;\n    sraRegionPtr updateRegion, updateCopyRegion, tmpRegion, cursorRegion;\n    sraRect cursorBounds = { 0, 0, 0, 0 };\n    int dx, dy;\n    rfbBool sendCursorShape = FALSE;\n    rfbBool sendCursorPos = FALSE;\n    rfbBool cursorIsDrawn = FALSE;\n\n    /*\n     * If framebuffer size was changed and the client supports NewFBSize\n     * encoding, just send NewFBSize marker and return.\n     */\n\n    if (cl->useNewFBSize && cl->newFBSizePending) {\n      LOCK(cl->updateMutex);\n      cl->newFBSizePending = FALSE;\n      UNLOCK(cl->updateMutex);\n      cl->rfbFramebufferUpdateMessagesSent++;\n      fu->type = rfbFramebufferUpdate;\n      fu->nRects = Swap16IfLE(1);\n      cl->ublen = sz_rfbFramebufferUpdateMsg;\n      if (!rfbSendNewFBSize(cl, cl->screen->width, cl->screen->height)) {\n        return FALSE;\n      }\n      return rfbSendUpdateBuf(cl);\n    }\n\n    LOCK(cl->updateMutex);\n\n    /*\n     * The modifiedRegion may overlap the destination copyRegion.  We remove\n     * any overlapping bits from the copyRegion (since they'd only be\n     * overwritten anyway).\n     */\n    \n    sraRgnSubtract(cl->copyRegion,cl->modifiedRegion);\n\n    updateRegion = sraRgnCreateRgn(givenUpdateRegion);\n    sraRgnOr(updateRegion,cl->copyRegion);\n\n    /*\n     * If the client doesn't support cursor updates, we want to draw\n     * the cursor locally, send the update and then undraw it.\n     * We only want to do this if the cursor has moved/changed or\n     * if it is contained in updateRegion\n     *\n     * We also want to send an update for the region where the cursor\n     * was last drawn, again only if the cursor has moved/changed.\n     */\n\n    LOCK(cl->screen->cursorMutex);\n\n    cursorRegion = NULL;\n    if (cl->enableCursorUpdates) {\n\tsendCursorShape = cl->cursorWasChanged;\n\tsendCursorPos   = cl->cursorWasMoved;\n    } else {\n\tsraRegionPtr lastDrawnCursorRegion;\n\n\tif (rfbGetCursorBounds(cl->screen, &cursorBounds)) {\n\t    cursorRegion = sraRgnCreateRect(cursorBounds.x1, cursorBounds.y1,\n\t\t\t\t\t    cursorBounds.x2, cursorBounds.y2);\n\t}\n\t\n\tlastDrawnCursorRegion = sraRgnCreateRect(cl->lastDrawnCursorBounds.x1,\n\t\t\t\t\t\t cl->lastDrawnCursorBounds.y1,\n\t\t\t\t\t\t cl->lastDrawnCursorBounds.x2,\n\t\t\t\t\t\t cl->lastDrawnCursorBounds.y2);\n\n\tif (cursorRegion) {\n\t    sraRgnOr(cursorRegion, lastDrawnCursorRegion);\n\t    sraRgnDestroy(lastDrawnCursorRegion);\n\t} else {\n\t    cursorRegion = lastDrawnCursorRegion;\n\t}\n\n\tif (cl->cursorWasChanged || cl->cursorWasMoved)\n\t    sraRgnOr(updateRegion, cursorRegion);\n    }\n\n    /*\n     * The client is interested in the region requestedRegion.  The region\n     * which should be updated now is the intersection of requestedRegion\n     * and the union of modifiedRegion and copyRegion.  If it's empty then\n     * no update is needed.\n     */\n\n    if (!sraRgnAnd(updateRegion, cl->requestedRegion) &&\n\t!sendCursorShape && !sendCursorPos) {\n\tsraRgnDestroy(updateRegion);\n\tif (cursorRegion)\n\t    sraRgnDestroy(cursorRegion);\n\tUNLOCK(cl->updateMutex);\n\tUNLOCK(cl->cursorMutex);\n\treturn TRUE;\n    }\n\n    /*\n     * Put up the cursor if any part of it is in updateRegion.\n     */\n\n    if (cursorRegion) {\n\ttmpRegion = sraRgnCreateRgn(cursorRegion);\n\n\tif (sraRgnAnd(tmpRegion, updateRegion)) {\n\t    rfbDrawCursor(cl->screen, &cursorBounds);\n\t    cursorIsDrawn = TRUE;\n\n\t    cl->cursorWasMoved = FALSE;\n\t    cl->cursorWasChanged = FALSE;\n\t    cl->lastDrawnCursorBounds = cursorBounds;\n\n\t    sraRgnOr(cl->modifiedRegion, cursorRegion);\n\t    \n\t    sraRgnOr(updateRegion, cursorRegion);\n\t    sraRgnAnd(updateRegion, cl->requestedRegion);\n\t}\n\n\tsraRgnDestroy(tmpRegion);\n\tsraRgnDestroy(cursorRegion);\n    }\n\n    /*\n     * We assume that the client doesn't have any pixel data outside the\n     * requestedRegion.  In other words, both the source and destination of a\n     * copy must lie within requestedRegion.  So the region we can send as a\n     * copy is the intersection of the copyRegion with both the requestedRegion\n     * and the requestedRegion translated by the amount of the copy.  We set\n     * updateCopyRegion to this.\n     */\n\n    updateCopyRegion = sraRgnCreateRgn(cl->copyRegion);\n    sraRgnAnd(updateCopyRegion,cl->requestedRegion);\n    tmpRegion = sraRgnCreateRgn(cl->requestedRegion);\n    sraRgnOffset(tmpRegion,cl->copyDX,cl->copyDY);\n    sraRgnAnd(updateCopyRegion,tmpRegion);\n    sraRgnDestroy(tmpRegion);\n    dx = cl->copyDX;\n    dy = cl->copyDY;\n\n    /*\n     * Next we remove updateCopyRegion from updateRegion so that updateRegion\n     * is the part of this update which is sent as ordinary pixel data (i.e not\n     * a copy).\n     */\n\n    sraRgnSubtract(updateRegion,updateCopyRegion);\n\n    /*\n     * Finally we leave modifiedRegion to be the remainder (if any) of parts of\n     * the screen which are modified but outside the requestedRegion.  We also\n     * empty both the requestedRegion and the copyRegion - note that we never\n     * carry over a copyRegion for a future update.\n     */\n\n     sraRgnOr(cl->modifiedRegion,cl->copyRegion);\n     sraRgnSubtract(cl->modifiedRegion,updateRegion);\n     sraRgnSubtract(cl->modifiedRegion,updateCopyRegion);\n\n     sraRgnMakeEmpty(cl->requestedRegion);\n     sraRgnMakeEmpty(cl->copyRegion);\n     cl->copyDX = 0;\n     cl->copyDY = 0;\n   \n     UNLOCK(cl->updateMutex);\n   \n   /*\n     * Now send the update.\n     */\n\n    cl->rfbFramebufferUpdateMessagesSent++;\n\n    if (cl->preferredEncoding == rfbEncodingCoRRE) {\n        nUpdateRegionRects = 0;\n\n        for(i = sraRgnGetIterator(updateRegion); sraRgnIteratorNext(i,&rect);){\n            int x = rect.x1;\n            int y = rect.y1;\n            int w = rect.x2 - x;\n            int h = rect.y2 - y;\n            nUpdateRegionRects += (((w-1) / cl->correMaxWidth + 1)\n                                     * ((h-1) / cl->correMaxHeight + 1));\n        }\n\tsraRgnReleaseIterator(i);\n#ifdef HAVE_LIBZ\n    } else if (cl->preferredEncoding == rfbEncodingZlib) {\n\tnUpdateRegionRects = 0;\n\n        for(i = sraRgnGetIterator(updateRegion); sraRgnIteratorNext(i,&rect);){\n            int x = rect.x1;\n            int y = rect.y1;\n            int w = rect.x2 - x;\n            int h = rect.y2 - y;\n\t    nUpdateRegionRects += (((h-1) / (ZLIB_MAX_SIZE( w ) / w)) + 1);\n\t}\n#ifdef HAVE_LIBJPEG\n    } else if (cl->preferredEncoding == rfbEncodingTight) {\n\tnUpdateRegionRects = 0;\n\n        for(i = sraRgnGetIterator(updateRegion); sraRgnIteratorNext(i,&rect);){\n            int x = rect.x1;\n            int y = rect.y1;\n            int w = rect.x2 - x;\n            int h = rect.y2 - y;\n\t    int n = rfbNumCodedRectsTight(cl, x, y, w, h);\n\t    if (n == 0) {\n\t\tnUpdateRegionRects = 0xFFFF;\n\t\tbreak;\n\t    }\n\t    nUpdateRegionRects += n;\n\t}\n\tsraRgnReleaseIterator(i);\n#endif\n#endif\n    } else {\n        nUpdateRegionRects = sraRgnCountRects(updateRegion);\n    }\n\n    fu->type = rfbFramebufferUpdate;\n    if (nUpdateRegionRects != 0xFFFF) {\n\tif(cl->screen->maxRectsPerUpdate>0\n\t   /* CoRRE splits the screen into smaller squares */\n\t   && cl->preferredEncoding != rfbEncodingCoRRE\n#ifdef HAVE_LIBZ\n\t   /* Zlib encoding splits rectangles up into smaller chunks */\n\t   && cl->preferredEncoding != rfbEncodingZlib\n#ifdef HAVE_LIBJPEG\n\t   /* Tight encoding counts the rectangles differently */\n\t   && cl->preferredEncoding != rfbEncodingTight\n#endif\n#endif /* HAVE_LIBZ */\n\t   && nUpdateRegionRects>cl->screen->maxRectsPerUpdate) {\n\t    sraRegion* newUpdateRegion = sraRgnBBox(updateRegion);\n\t    sraRgnDestroy(updateRegion);\n\t    updateRegion = newUpdateRegion;\n\t    nUpdateRegionRects = sraRgnCountRects(updateRegion);\n\t}\n\tfu->nRects = Swap16IfLE((uint16_t)(sraRgnCountRects(updateCopyRegion) +\n\t\t\t\t\t   nUpdateRegionRects +\n\t\t\t\t\t   !!sendCursorShape + !!sendCursorPos));\n    } else {\n\tfu->nRects = 0xFFFF;\n    }\n    cl->ublen = sz_rfbFramebufferUpdateMsg;\n\n    UNLOCK(cl->cursorMutex);\n\n   if (sendCursorShape) {\n\tcl->cursorWasChanged = FALSE;\n\tif (!rfbSendCursorShape(cl))\n\t    goto tx_error;\n    }\n   \n   if (sendCursorPos) {\n\tcl->cursorWasMoved = FALSE;\n\tif (!rfbSendCursorPos(cl))\n\t    goto tx_error;\n    }\n   \n    if (!sraRgnEmpty(updateCopyRegion)) {\n\tif (!rfbSendCopyRegion(cl,updateCopyRegion,dx,dy))\n\t    goto tx_error;\n    }\n\n    for(i = sraRgnGetIterator(updateRegion); sraRgnIteratorNext(i,&rect);){\n        int x = rect.x1;\n        int y = rect.y1;\n        int w = rect.x2 - x;\n        int h = rect.y2 - y;\n\n        cl->rfbRawBytesEquivalent += (sz_rfbFramebufferUpdateRectHeader\n                                      + w * (cl->format.bitsPerPixel / 8) * h);\n\n        switch (cl->preferredEncoding) {\n        case rfbEncodingRaw:\n            if (!rfbSendRectEncodingRaw(cl, x, y, w, h))\n\t\tgoto tx_error;\n            break;\n        case rfbEncodingRRE:\n            if (!rfbSendRectEncodingRRE(cl, x, y, w, h))\n\t\tgoto tx_error;\n            break;\n        case rfbEncodingCoRRE:\n            if (!rfbSendRectEncodingCoRRE(cl, x, y, w, h))\n\t\tgoto tx_error;\n            break;\n        case rfbEncodingHextile:\n            if (!rfbSendRectEncodingHextile(cl, x, y, w, h))\n\t\tgoto tx_error;\n            break;\n#ifdef HAVE_LIBZ\n\tcase rfbEncodingZlib:\n\t    if (!rfbSendRectEncodingZlib(cl, x, y, w, h))\n\t\tgoto tx_error;\n\t    break;\n#ifdef HAVE_LIBJPEG\n\tcase rfbEncodingTight:\n\t    if (!rfbSendRectEncodingTight(cl, x, y, w, h))\n\t\tgoto tx_error;\n\t    break;\n#endif\n#endif\n#ifdef HAVE_LIBZ\n       case rfbEncodingZRLE:\n           if (!rfbSendRectEncodingZRLE(cl, x, y, w, h))\n\t       goto tx_error;\n           break;\n#endif\n        }\n    }\n\n    if (cursorIsDrawn)\n\trfbUndrawCursor(cl->screen, &cursorBounds);\n\n    if ( nUpdateRegionRects == 0xFFFF &&\n\t !rfbSendLastRectMarker(cl) )\n\tgoto tx_error;\n\n    if (!rfbSendUpdateBuf(cl))\n\tgoto tx_error;\n\n    sraRgnReleaseIterator(i);\n    sraRgnDestroy(updateCopyRegion);\n    sraRgnDestroy(updateRegion);\n    \n    return TRUE;\n\n tx_error:\n    if (cursorIsDrawn)\n\trfbUndrawCursor(cl->screen, &cursorBounds);\n    if (i)\n\tsraRgnReleaseIterator(i);\n\n    sraRgnDestroy(updateCopyRegion);\n    sraRgnDestroy(updateRegion);\n\n    return FALSE;\n}",
        "target": 1
    },
    {
        "func": "rfbSendFramebufferUpdate(rfbClientPtr cl,\n                         sraRegionPtr givenUpdateRegion)\n{\n    sraRectangleIterator* i=NULL;\n    sraRect rect;\n    int nUpdateRegionRects;\n    rfbFramebufferUpdateMsg *fu = (rfbFramebufferUpdateMsg *)cl->updateBuf;\n    sraRegionPtr updateRegion, updateCopyRegion, tmpRegion, cursorRegion;\n    sraRect cursorBounds = { 0, 0, 0, 0 };\n    int dx, dy;\n    rfbBool sendCursorShape = FALSE;\n    rfbBool sendCursorPos = FALSE;\n    rfbBool cursorIsDrawn = FALSE;\n\n    /*\n     * If framebuffer size was changed and the client supports NewFBSize\n     * encoding, just send NewFBSize marker and return.\n     */\n\n    if (cl->useNewFBSize && cl->newFBSizePending) {\n      LOCK(cl->updateMutex);\n      cl->newFBSizePending = FALSE;\n      UNLOCK(cl->updateMutex);\n      cl->rfbFramebufferUpdateMessagesSent++;\n      fu->type = rfbFramebufferUpdate;\n      fu->nRects = Swap16IfLE(1);\n      cl->ublen = sz_rfbFramebufferUpdateMsg;\n      if (!rfbSendNewFBSize(cl, cl->screen->width, cl->screen->height)) {\n        return FALSE;\n      }\n      return rfbSendUpdateBuf(cl);\n    }\n\n    LOCK(cl->updateMutex);\n\n    /*\n     * The modifiedRegion may overlap the destination copyRegion.  We remove\n     * any overlapping bits from the copyRegion (since they'd only be\n     * overwritten anyway).\n     */\n    \n    sraRgnSubtract(cl->copyRegion,cl->modifiedRegion);\n\n    updateRegion = sraRgnCreateRgn(givenUpdateRegion);\n    sraRgnOr(updateRegion,cl->copyRegion);\n\n    /*\n     * If the client doesn't support cursor updates, we want to draw\n     * the cursor locally, send the update and then undraw it.\n     * We only want to do this if the cursor has moved/changed or\n     * if it is contained in updateRegion\n     *\n     * We also want to send an update for the region where the cursor\n     * was last drawn, again only if the cursor has moved/changed.\n     */\n\n    LOCK(cl->screen->cursorMutex);\n\n    cursorRegion = NULL;\n    if (cl->enableCursorUpdates) {\n\tsendCursorShape = cl->cursorWasChanged;\n\tsendCursorPos   = cl->cursorWasMoved;\n    } else {\n\tsraRegionPtr lastDrawnCursorRegion;\n\n\tif (rfbGetCursorBounds(cl->screen, &cursorBounds)) {\n\t    cursorRegion = sraRgnCreateRect(cursorBounds.x1, cursorBounds.y1,\n\t\t\t\t\t    cursorBounds.x2, cursorBounds.y2);\n\t}\n\t\n\tlastDrawnCursorRegion = sraRgnCreateRect(cl->lastDrawnCursorBounds.x1,\n\t\t\t\t\t\t cl->lastDrawnCursorBounds.y1,\n\t\t\t\t\t\t cl->lastDrawnCursorBounds.x2,\n\t\t\t\t\t\t cl->lastDrawnCursorBounds.y2);\n\n\tif (cursorRegion) {\n\t    sraRgnOr(cursorRegion, lastDrawnCursorRegion);\n\t    sraRgnDestroy(lastDrawnCursorRegion);\n\t} else {\n\t    cursorRegion = lastDrawnCursorRegion;\n\t}\n\n\tif (cl->cursorWasChanged || cl->cursorWasMoved)\n\t    sraRgnOr(updateRegion, cursorRegion);\n    }\n\n    /*\n     * The client is interested in the region requestedRegion.  The region\n     * which should be updated now is the intersection of requestedRegion\n     * and the union of modifiedRegion and copyRegion.  If it's empty then\n     * no update is needed.\n     */\n\n    if (!sraRgnAnd(updateRegion, cl->requestedRegion) &&\n\t!sendCursorShape && !sendCursorPos) {\n\tsraRgnDestroy(updateRegion);\n\tif (cursorRegion)\n\t    sraRgnDestroy(cursorRegion);\n\tUNLOCK(cl->updateMutex);\n\tUNLOCK(cl->cursorMutex);\n\treturn TRUE;\n    }\n\n    /*\n     * Put up the cursor if any part of it is in updateRegion.\n     */\n\n    if (cursorRegion) {\n\ttmpRegion = sraRgnCreateRgn(cursorRegion);\n\n\tif (sraRgnAnd(tmpRegion, updateRegion)) {\n\t    rfbDrawCursor(cl->screen, &cursorBounds);\n\t    cursorIsDrawn = TRUE;\n\n\t    cl->cursorWasMoved = FALSE;\n\t    cl->cursorWasChanged = FALSE;\n\t    cl->lastDrawnCursorBounds = cursorBounds;\n\n\t    sraRgnOr(cl->modifiedRegion, cursorRegion);\n\t    \n\t    sraRgnOr(updateRegion, cursorRegion);\n\t    sraRgnAnd(updateRegion, cl->requestedRegion);\n\t}\n\n\tsraRgnDestroy(tmpRegion);\n\tsraRgnDestroy(cursorRegion);\n    }\n\n    /*\n     * We assume that the client doesn't have any pixel data outside the\n     * requestedRegion.  In other words, both the source and destination of a\n     * copy must lie within requestedRegion.  So the region we can send as a\n     * copy is the intersection of the copyRegion with both the requestedRegion\n     * and the requestedRegion translated by the amount of the copy.  We set\n     * updateCopyRegion to this.\n     */\n\n    updateCopyRegion = sraRgnCreateRgn(cl->copyRegion);\n    sraRgnAnd(updateCopyRegion,cl->requestedRegion);\n    tmpRegion = sraRgnCreateRgn(cl->requestedRegion);\n    sraRgnOffset(tmpRegion,cl->copyDX,cl->copyDY);\n    sraRgnAnd(updateCopyRegion,tmpRegion);\n    sraRgnDestroy(tmpRegion);\n    dx = cl->copyDX;\n    dy = cl->copyDY;\n\n    /*\n     * Next we remove updateCopyRegion from updateRegion so that updateRegion\n     * is the part of this update which is sent as ordinary pixel data (i.e not\n     * a copy).\n     */\n\n    sraRgnSubtract(updateRegion,updateCopyRegion);\n\n    /*\n     * Finally we leave modifiedRegion to be the remainder (if any) of parts of\n     * the screen which are modified but outside the requestedRegion.  We also\n     * empty both the requestedRegion and the copyRegion - note that we never\n     * carry over a copyRegion for a future update.\n     */\n\n     sraRgnOr(cl->modifiedRegion,cl->copyRegion);\n     sraRgnSubtract(cl->modifiedRegion,updateRegion);\n     sraRgnSubtract(cl->modifiedRegion,updateCopyRegion);\n\n     sraRgnMakeEmpty(cl->requestedRegion);\n     sraRgnMakeEmpty(cl->copyRegion);\n     cl->copyDX = 0;\n     cl->copyDY = 0;\n   \n     UNLOCK(cl->updateMutex);\n   \n   /*\n     * Now send the update.\n     */\n\n    cl->rfbFramebufferUpdateMessagesSent++;\n\n    if (cl->preferredEncoding == rfbEncodingCoRRE) {\n        nUpdateRegionRects = 0;\n\n        for(i = sraRgnGetIterator(updateRegion); sraRgnIteratorNext(i,&rect);){\n            int x = rect.x1;\n            int y = rect.y1;\n            int w = rect.x2 - x;\n            int h = rect.y2 - y;\n            nUpdateRegionRects += (((w-1) / cl->correMaxWidth + 1)\n                                     * ((h-1) / cl->correMaxHeight + 1));\n        }\n\tsraRgnReleaseIterator(i);\n#ifdef VINO_HAVE_ZLIB\n    } else if (cl->preferredEncoding == rfbEncodingZlib) {\n\tnUpdateRegionRects = 0;\n\n        for(i = sraRgnGetIterator(updateRegion); sraRgnIteratorNext(i,&rect);){\n            int x = rect.x1;\n            int y = rect.y1;\n            int w = rect.x2 - x;\n            int h = rect.y2 - y;\n\t    nUpdateRegionRects += (((h-1) / (ZLIB_MAX_SIZE( w ) / w)) + 1);\n\t}\n#ifdef VINO_HAVE_JPEG\n    } else if (cl->preferredEncoding == rfbEncodingTight) {\n\tnUpdateRegionRects = 0;\n\n        for(i = sraRgnGetIterator(updateRegion); sraRgnIteratorNext(i,&rect);){\n            int x = rect.x1;\n            int y = rect.y1;\n            int w = rect.x2 - x;\n            int h = rect.y2 - y;\n\t    int n = rfbNumCodedRectsTight(cl, x, y, w, h);\n\t    if (n == 0) {\n\t\tnUpdateRegionRects = 0xFFFF;\n\t\tbreak;\n\t    }\n\t    nUpdateRegionRects += n;\n\t}\n\tsraRgnReleaseIterator(i);\n#endif\n#endif\n    } else {\n        nUpdateRegionRects = sraRgnCountRects(updateRegion);\n    }\n\n    fu->type = rfbFramebufferUpdate;\n    if (nUpdateRegionRects != 0xFFFF) {\n\tif(cl->screen->maxRectsPerUpdate>0\n\t   /* CoRRE splits the screen into smaller squares */\n\t   && cl->preferredEncoding != rfbEncodingCoRRE\n#ifdef VINO_HAVE_ZLIB\n\t   /* Zlib encoding splits rectangles up into smaller chunks */\n\t   && cl->preferredEncoding != rfbEncodingZlib\n#ifdef VINO_HAVE_JPEG\n\t   /* Tight encoding counts the rectangles differently */\n\t   && cl->preferredEncoding != rfbEncodingTight\n#endif\n#endif /* VINO_HAVE_ZLIB */\n\t   && nUpdateRegionRects>cl->screen->maxRectsPerUpdate) {\n\t    sraRegion* newUpdateRegion = sraRgnBBox(updateRegion);\n\t    sraRgnDestroy(updateRegion);\n\t    updateRegion = newUpdateRegion;\n\t    nUpdateRegionRects = sraRgnCountRects(updateRegion);\n\t}\n\tfu->nRects = Swap16IfLE((uint16_t)(sraRgnCountRects(updateCopyRegion) +\n\t\t\t\t\t   nUpdateRegionRects +\n\t\t\t\t\t   !!sendCursorShape + !!sendCursorPos));\n    } else {\n\tfu->nRects = 0xFFFF;\n    }\n    cl->ublen = sz_rfbFramebufferUpdateMsg;\n\n    UNLOCK(cl->cursorMutex);\n\n   if (sendCursorShape) {\n\tcl->cursorWasChanged = FALSE;\n\tif (!rfbSendCursorShape(cl))\n\t    goto tx_error;\n    }\n   \n   if (sendCursorPos) {\n\tcl->cursorWasMoved = FALSE;\n\tif (!rfbSendCursorPos(cl))\n\t    goto tx_error;\n    }\n   \n    if (!sraRgnEmpty(updateCopyRegion)) {\n\tif (!rfbSendCopyRegion(cl,updateCopyRegion,dx,dy))\n\t    goto tx_error;\n    }\n\n    for(i = sraRgnGetIterator(updateRegion); sraRgnIteratorNext(i,&rect);){\n        int x = rect.x1;\n        int y = rect.y1;\n        int w = rect.x2 - x;\n        int h = rect.y2 - y;\n\n        cl->rfbRawBytesEquivalent += (sz_rfbFramebufferUpdateRectHeader\n                                      + w * (cl->format.bitsPerPixel / 8) * h);\n\n        switch (cl->preferredEncoding) {\n        case rfbEncodingRaw:\n            if (!rfbSendRectEncodingRaw(cl, x, y, w, h))\n\t\tgoto tx_error;\n            break;\n        case rfbEncodingRRE:\n            if (!rfbSendRectEncodingRRE(cl, x, y, w, h))\n\t\tgoto tx_error;\n            break;\n        case rfbEncodingCoRRE:\n            if (!rfbSendRectEncodingCoRRE(cl, x, y, w, h))\n\t\tgoto tx_error;\n            break;\n        case rfbEncodingHextile:\n            if (!rfbSendRectEncodingHextile(cl, x, y, w, h))\n\t\tgoto tx_error;\n            break;\n#ifdef VINO_HAVE_ZLIB\n\tcase rfbEncodingZlib:\n\t    if (!rfbSendRectEncodingZlib(cl, x, y, w, h))\n\t\tgoto tx_error;\n\t    break;\n#ifdef VINO_HAVE_JPEG\n\tcase rfbEncodingTight:\n\t    if (!rfbSendRectEncodingTight(cl, x, y, w, h))\n\t\tgoto tx_error;\n\t    break;\n#endif\n#endif\n#ifdef VINO_HAVE_ZLIB\n       case rfbEncodingZRLE:\n           if (!rfbSendRectEncodingZRLE(cl, x, y, w, h))\n\t       goto tx_error;\n           break;\n#endif\n        }\n    }\n\n    if (cursorIsDrawn)\n\trfbUndrawCursor(cl->screen, &cursorBounds);\n\n    if ( nUpdateRegionRects == 0xFFFF &&\n\t !rfbSendLastRectMarker(cl) )\n\tgoto tx_error;\n\n    if (!rfbSendUpdateBuf(cl))\n\tgoto tx_error;\n\n    sraRgnReleaseIterator(i);\n    sraRgnDestroy(updateCopyRegion);\n    sraRgnDestroy(updateRegion);\n    \n    return TRUE;\n\n tx_error:\n    if (cursorIsDrawn)\n\trfbUndrawCursor(cl->screen, &cursorBounds);\n    if (i)\n\tsraRgnReleaseIterator(i);\n\n    sraRgnDestroy(updateCopyRegion);\n    sraRgnDestroy(updateRegion);\n\n    return FALSE;\n}",
        "target": 1
    },
    {
        "func": "void ves_icall_System_Threading_InternalThread_Thread_free_internal (MonoInternalThread *this, HANDLE thread)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\tTHREAD_DEBUG (g_message (\"%s: Closing thread %p, handle %p\", __func__, this, thread));\n\n\tif (thread)\n\t\tCloseHandle (thread);\n\n\tif (this->synch_cs) {\n\t\tDeleteCriticalSection (this->synch_cs);\n\t\tg_free (this->synch_cs);\n\t\tthis->synch_cs = NULL;\n\t}\n\n\tg_free (this->name);\n}",
        "target": 1
    },
    {
        "func": "ves_icall_System_Runtime_CompilerServices_RuntimeHelpers_InitializeArray (MonoArray *array, MonoClassField *field_handle)\n{\n\tMonoClass *klass = array->obj.vtable->klass;\n\tguint32 size = mono_array_element_size (klass);\n\tMonoType *type = mono_type_get_underlying_type (&klass->element_class->byval_arg);\n\tint align;\n\tconst char *field_data;\n\n\tif (MONO_TYPE_IS_REFERENCE (type) ||\n\t\t\t(type->type == MONO_TYPE_VALUETYPE &&\n\t\t\t\t(!mono_type_get_class (type) ||\n\t\t\t\tmono_type_get_class (type)->has_references))) {\n\t\tMonoException *exc = mono_get_exception_argument(\"array\",\n\t\t\t\"Cannot initialize array containing references\");\n\t\tmono_raise_exception (exc);\n\t}\n\n\tif (!(field_handle->type->attrs & FIELD_ATTRIBUTE_HAS_FIELD_RVA)) {\n\t\tMonoException *exc = mono_get_exception_argument(\"field_handle\",\n\t\t\t\"Field doesn't have an RVA\");\n\t\tmono_raise_exception (exc);\n\t}\n\n\tsize *= array->max_length;\n\tfield_data = mono_field_get_data (field_handle);\n\n\tif (size > mono_type_size (field_handle->type, &align)) {\n\t\tMonoException *exc = mono_get_exception_argument(\"field_handle\",\n\t\t\t\"Field not large enough to fill array\");\n\t\tmono_raise_exception (exc);\n\t}\n\n#if G_BYTE_ORDER != G_LITTLE_ENDIAN\n#define SWAP(n) {\\\n\tguint ## n *data = (guint ## n *) mono_array_addr (array, char, 0); \\\n\tguint ## n *src = (guint ## n *) field_data; \\\n\tguint ## n *end = (guint ## n *)((char*)src + size); \\\n\\\n\tfor (; src < end; data++, src++) { \\\n\t\t*data = read ## n (src); \\\n\t} \\\n}\n\n\t/* printf (\"Initialize array with elements of %s type\\n\", klass->element_class->name); */\n\n\tswitch (type->type) {\n\tcase MONO_TYPE_CHAR:\n\tcase MONO_TYPE_I2:\n\tcase MONO_TYPE_U2:\n\t\tSWAP (16);\n\t\tbreak;\n\tcase MONO_TYPE_I4:\n\tcase MONO_TYPE_U4:\n\tcase MONO_TYPE_R4:\n\t\tSWAP (32);\n\t\tbreak;\n\tcase MONO_TYPE_I8:\n\tcase MONO_TYPE_U8:\n\tcase MONO_TYPE_R8:\n\t\tSWAP (64);\n\t\tbreak;\n\tdefault:\n\t\tmemcpy (mono_array_addr (array, char, 0), field_data, size);\n\t\tbreak;\n\t}\n#else\n\tmemcpy (mono_array_addr (array, char, 0), field_data, size);\n#ifdef ARM_FPU_FPA\n\tif (klass->element_class->byval_arg.type == MONO_TYPE_R8) {\n\t\tgint i;\n\t\tdouble tmp;\n\t\tdouble *data = (double*)mono_array_addr (array, double, 0);\n\n\t\tfor (i = 0; i < size; i++, data++) {\n\t\t\treadr8 (data, &tmp);\n\t\t\t*data = tmp;\n\t\t}\n\t}\n#endif\n#endif\n}",
        "target": 1
    },
    {
        "func": "ves_icall_System_Array_FastCopy (MonoArray *source, int source_idx, MonoArray* dest, int dest_idx, int length)\n{\n\tint element_size;\n\tvoid * dest_addr;\n\tvoid * source_addr;\n\tMonoClass *src_class;\n\tMonoClass *dest_class;\n\tint i;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (source->obj.vtable->klass->rank != dest->obj.vtable->klass->rank)\n\t\treturn FALSE;\n\n\tif (source->bounds || dest->bounds)\n\t\treturn FALSE;\n\n\t/* there's no integer overflow since mono_array_length returns an unsigned integer */\n\tif ((dest_idx + length > mono_array_length (dest)) ||\n\t\t(source_idx + length > mono_array_length (source)))\n\t\treturn FALSE;\n\n\tsrc_class = source->obj.vtable->klass->element_class;\n\tdest_class = dest->obj.vtable->klass->element_class;\n\n\t/*\n\t * Handle common cases.\n\t */\n\n\t/* Case1: object[] -> valuetype[] (ArrayList::ToArray) */\n\tif (src_class == mono_defaults.object_class && dest_class->valuetype) {\n\t\tint has_refs = dest_class->has_references;\n\t\tfor (i = source_idx; i < source_idx + length; ++i) {\n\t\t\tMonoObject *elem = mono_array_get (source, MonoObject*, i);\n\t\t\tif (elem && !mono_object_isinst (elem, dest_class))\n\t\t\t\treturn FALSE;\n\t\t}\n\n\t\telement_size = mono_array_element_size (dest->obj.vtable->klass);\n\t\tmemset (mono_array_addr_with_size (dest, element_size, dest_idx), 0, element_size * length);\n\t\tfor (i = 0; i < length; ++i) {\n\t\t\tMonoObject *elem = mono_array_get (source, MonoObject*, source_idx + i);\n\t\t\tvoid *addr = mono_array_addr_with_size (dest, element_size, dest_idx + i);\n\t\t\tif (!elem)\n\t\t\t\tcontinue;\n\t\t\tif (has_refs)\n\t\t\t\tmono_value_copy (addr, (char *)elem + sizeof (MonoObject), dest_class);\n\t\t\telse\n\t\t\t\tmemcpy (addr, (char *)elem + sizeof (MonoObject), element_size);\n\t\t}\n\t\treturn TRUE;\n\t}\n\n\t/* Check if we're copying a char[] <==> (u)short[] */\n\tif (src_class != dest_class) {\n\t\tif (dest_class->valuetype || dest_class->enumtype || src_class->valuetype || src_class->enumtype)\n\t\t\treturn FALSE;\n\n\t\tif (mono_class_is_subclass_of (src_class, dest_class, FALSE))\n\t\t\t;\n\t\t/* Case2: object[] -> reftype[] (ArrayList::ToArray) */\n\t\telse if (mono_class_is_subclass_of (dest_class, src_class, FALSE))\n\t\t\tfor (i = source_idx; i < source_idx + length; ++i) {\n\t\t\t\tMonoObject *elem = mono_array_get (source, MonoObject*, i);\n\t\t\t\tif (elem && !mono_object_isinst (elem, dest_class))\n\t\t\t\t\treturn FALSE;\n\t\t\t}\n\t\telse\n\t\t\treturn FALSE;\n\t}\n\n\tif (dest_class->valuetype) {\n\t\telement_size = mono_array_element_size (source->obj.vtable->klass);\n\t\tsource_addr = mono_array_addr_with_size (source, element_size, source_idx);\n\t\tif (dest_class->has_references) {\n\t\t\tmono_value_copy_array (dest, dest_idx, source_addr, length);\n\t\t} else {\n\t\t\tdest_addr = mono_array_addr_with_size (dest, element_size, dest_idx);\n\t\t\tmemmove (dest_addr, source_addr, element_size * length);\n\t\t}\n\t} else {\n\t\tmono_array_memcpy_refs (dest, dest_idx, source, source_idx, length);\n\t}\n\n\treturn TRUE;\n}",
        "target": 1
    },
    {
        "func": "void\nmono_reflection_destroy_dynamic_method (MonoReflectionDynamicMethod *mb)\n{\n\tg_assert (mb);\n\n\tif (mb->mhandle)\n\t\tmono_runtime_free_method (\n\t\t\tmono_object_get_domain ((MonoObject*)mb), mb->mhandle);",
        "target": 1
    },
    {
        "func": "void \nmono_reflection_create_dynamic_method (MonoReflectionDynamicMethod *mb)\n{",
        "target": 1
    },
    {
        "func": "void \nmono_reflection_create_dynamic_method (MonoReflectionDynamicMethod *mb)\n{\n\tReflectionMethodBuilder rmb;\n\tMonoMethodSignature *sig;\n\tMonoClass *klass;\n\tGSList *l;\n\tint i;\n\n\tsig = dynamic_method_to_signature (mb);\n\n\treflection_methodbuilder_from_dynamic_method (&rmb, mb);\n\n\t/*\n\t * Resolve references.\n\t */\n\t/* \n\t * Every second entry in the refs array is reserved for storing handle_class,\n\t * which is needed by the ldtoken implementation in the JIT.\n\t */\n\trmb.nrefs = mb->nrefs;\n\trmb.refs = g_new0 (gpointer, mb->nrefs + 1);\n\tfor (i = 0; i < mb->nrefs; i += 2) {\n\t\tMonoClass *handle_class;\n\t\tgpointer ref;\n\t\tMonoObject *obj = mono_array_get (mb->refs, MonoObject*, i);\n\n\t\tif (strcmp (obj->vtable->klass->name, \"DynamicMethod\") == 0) {\n\t\t\tMonoReflectionDynamicMethod *method = (MonoReflectionDynamicMethod*)obj;\n\t\t\t/*\n\t\t\t * The referenced DynamicMethod should already be created by the managed\n\t\t\t * code, except in the case of circular references. In that case, we store\n\t\t\t * method in the refs array, and fix it up later when the referenced \n\t\t\t * DynamicMethod is created.\n\t\t\t */\n\t\t\tif (method->mhandle) {\n\t\t\t\tref = method->mhandle;\n\t\t\t} else {\n\t\t\t\t/* FIXME: GC object stored in unmanaged memory */\n\t\t\t\tref = method;\n\n\t\t\t\t/* FIXME: GC object stored in unmanaged memory */\n\t\t\t\tmethod->referenced_by = g_slist_append (method->referenced_by, mb);\n\t\t\t}\n\t\t\thandle_class = mono_defaults.methodhandle_class;\n\t\t} else {\n\t\t\tMonoException *ex = NULL;\n\t\t\tref = resolve_object (mb->module->image, obj, &handle_class, NULL);\n\t\t\tif (!ref)\n\t\t\t\tex = mono_get_exception_type_load (NULL, NULL);\n\t\t\telse if (mono_security_get_mode () == MONO_SECURITY_MODE_CORE_CLR)\n\t\t\t\tex = mono_security_core_clr_ensure_dynamic_method_resolved_object (ref, handle_class);\n\n\t\t\tif (ex) {\n\t\t\t\tg_free (rmb.refs);\n\t\t\t\tmono_raise_exception (ex);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\trmb.refs [i] = ref; /* FIXME: GC object stored in unmanaged memory (change also resolve_object() signature) */\n\t\trmb.refs [i + 1] = handle_class;\n\t}\t\t\n\n\tklass = mb->owner ? mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)mb->owner)) : mono_defaults.object_class;\n\n\tmb->mhandle = reflection_methodbuilder_to_mono_method (klass, &rmb, sig);\n\n\t/* Fix up refs entries pointing at us */\n\tfor (l = mb->referenced_by; l; l = l->next) {\n\t\tMonoReflectionDynamicMethod *method = (MonoReflectionDynamicMethod*)l->data;\n\t\tMonoMethodWrapper *wrapper = (MonoMethodWrapper*)method->mhandle;\n\t\tgpointer *data;\n\t\t\n\t\tg_assert (method->mhandle);\n\n\t\tdata = (gpointer*)wrapper->method_data;\n\t\tfor (i = 0; i < GPOINTER_TO_UINT (data [0]); i += 2) {\n\t\t\tif ((data [i + 1] == mb) && (data [i + 1 + 1] == mono_defaults.methodhandle_class))\n\t\t\t\tdata [i + 1] = mb->mhandle;\n\t\t}\n\t}\n\tg_slist_free (mb->referenced_by);\n\n\tg_free (rmb.refs);\n\n\t/* ilgen is no longer needed */\n\tmb->ilgen = NULL;",
        "target": 1
    },
    {
        "func": "mono_runtime_shutdown (void)\n{\n\tmono_domain_foreach (fire_process_exit_event, NULL);\n}",
        "target": 1
    },
    {
        "func": "mono_gc_init (void)\n{\n\tInitializeCriticalSection (&handle_section);\n\tInitializeCriticalSection (&allocator_section);\n\n\tInitializeCriticalSection (&finalizer_mutex);\n\n\tMONO_GC_REGISTER_ROOT_FIXED (gc_handles [HANDLE_NORMAL].entries);\n\tMONO_GC_REGISTER_ROOT_FIXED (gc_handles [HANDLE_PINNED].entries);\n\n\tmono_gc_base_init ();\n\n\tif (mono_gc_is_disabled ()) {\n\t\tgc_disabled = TRUE;\n\t\treturn;\n\t}\n\t\n\tfinalizer_event = CreateEvent (NULL, FALSE, FALSE, NULL);\n\tpending_done_event = CreateEvent (NULL, TRUE, FALSE, NULL);\n\tshutdown_event = CreateEvent (NULL, TRUE, FALSE, NULL);\n\tif (finalizer_event == NULL || pending_done_event == NULL || shutdown_event == NULL) {\n\t\tg_assert_not_reached ();\n\t}\n#ifdef MONO_HAS_SEMAPHORES\n\tMONO_SEM_INIT (&finalizer_sem, 0);\n#endif\n\n\tgc_thread = mono_thread_create_internal (mono_domain_get (), finalizer_thread, NULL, FALSE);\n\tves_icall_System_Threading_Thread_SetName_internal (gc_thread, mono_string_new (mono_domain_get (), \"Finalizer\"));\n}",
        "target": 1
    },
    {
        "func": "void mono_gc_cleanup (void)\n{\n}",
        "target": 1
    },
    {
        "func": "mono_gc_cleanup (void)\n{\n#ifdef DEBUG\n\tg_message (\"%s: cleaning up finalizer\", __func__);\n#endif\n\n\tif (!gc_disabled) {\n\t\tResetEvent (shutdown_event);\n\t\tfinished = TRUE;\n\t\tif (mono_thread_internal_current () != gc_thread) {\n\t\t\tmono_gc_finalize_notify ();\n\t\t\t/* Finishing the finalizer thread, so wait a little bit... */\n\t\t\t/* MS seems to wait for about 2 seconds */\n\t\t\tif (WaitForSingleObjectEx (shutdown_event, 2000, FALSE) == WAIT_TIMEOUT) {\n\t\t\t\tint ret;\n\n\t\t\t\t/* Set a flag which the finalizer thread can check */\n\t\t\t\tsuspend_finalizers = TRUE;\n\n\t\t\t\t/* Try to abort the thread, in the hope that it is running managed code */\n\t\t\t\tmono_thread_internal_stop (gc_thread);\n\n\t\t\t\t/* Wait for it to stop */\n\t\t\t\tret = WaitForSingleObjectEx (gc_thread->handle, 100, TRUE);\n\n\t\t\t\tif (ret == WAIT_TIMEOUT) {\n\t\t\t\t\t/* \n\t\t\t\t\t * The finalizer thread refused to die. There is not much we \n\t\t\t\t\t * can do here, since the runtime is shutting down so the \n\t\t\t\t\t * state the finalizer thread depends on will vanish.\n\t\t\t\t\t */\n\t\t\t\t\tg_warning (\"Shutting down finalizer thread timed out.\");\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\t * FIXME: On unix, when the above wait returns, the thread \n\t\t\t\t\t * might still be running io-layer code, or pthreads code.\n\t\t\t\t\t */\n\t\t\t\t\tSleep (100);\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tgc_thread = NULL;\n#ifdef HAVE_BOEHM_GC\n\t\tGC_finalizer_notifier = NULL;\n#endif\n\t}\n\n\tDeleteCriticalSection (&handle_section);\n\tDeleteCriticalSection (&allocator_section);\n\tDeleteCriticalSection (&finalizer_mutex);\n}",
        "target": 1
    },
    {
        "func": "void mono_gc_init (void)\n{\n\tInitializeCriticalSection (&handle_section);\n}",
        "target": 1
    },
    {
        "func": "finalizer_thread (gpointer unused)\n{\n\twhile (!finished) {\n\t\t/* Wait to be notified that there's at least one\n\t\t * finaliser to run\n\t\t */\n\n\t\tg_assert (mono_domain_get () == mono_get_root_domain ());\n\n#ifdef MONO_HAS_SEMAPHORES\n\t\tMONO_SEM_WAIT (&finalizer_sem);\n#else\n\t\t/* Use alertable=FALSE since we will be asked to exit using the event too */\n\t\tWaitForSingleObjectEx (finalizer_event, INFINITE, FALSE);\n#endif\n\n\t\tmono_console_handle_async_ops ();\n\n#ifndef DISABLE_ATTACH\n\t\tmono_attach_maybe_start ();\n#endif\n\n\t\tif (domains_to_finalize) {\n\t\t\tmono_finalizer_lock ();\n\t\t\tif (domains_to_finalize) {\n\t\t\t\tDomainFinalizationReq *req = domains_to_finalize->data;\n\t\t\t\tdomains_to_finalize = g_slist_remove (domains_to_finalize, req);\n\t\t\t\tmono_finalizer_unlock ();\n\n\t\t\t\tfinalize_domain_objects (req);\n\t\t\t} else {\n\t\t\t\tmono_finalizer_unlock ();\n\t\t\t}\n\t\t}\t\t\t\t\n\n\t\t/* If finished == TRUE, mono_gc_cleanup has been called (from mono_runtime_cleanup),\n\t\t * before the domain is unloaded.\n\t\t */\n\t\tmono_gc_invoke_finalizers ();\n\n\t\tSetEvent (pending_done_event);\n\t}\n\n\tSetEvent (shutdown_event);\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "add_mtab(char *devname, char *mountpoint, unsigned long flags, const char *fstype)\n{\n\tint rc = 0;\n\tuid_t uid;\n\tchar *mount_user = NULL;\n\tstruct mntent mountent;\n\tFILE *pmntfile;\n\tsigset_t mask, oldmask;\n\n\tuid = getuid();\n\tif (uid != 0)\n\t\tmount_user = getusername(uid);\n\n\t/*\n\t * Set the real uid to the effective uid. This prevents unprivileged\n\t * users from sending signals to this process, though ^c on controlling\n\t * terminal should still work.\n\t */\n\trc = setreuid(geteuid(), -1);\n\tif (rc != 0) {\n\t\tfprintf(stderr, \"Unable to set real uid to effective uid: %s\\n\",\n\t\t\t\tstrerror(errno));\n\t\treturn EX_FILEIO;\n\t}\n\n\trc = sigfillset(&mask);\n\tif (rc) {\n\t\tfprintf(stderr, \"Unable to set filled signal mask\\n\");\n\t\treturn EX_FILEIO;\n\t}\n\n\trc = sigprocmask(SIG_SETMASK, &mask, &oldmask);\n\tif (rc) {\n\t\tfprintf(stderr, \"Unable to make process ignore signals\\n\");\n\t\treturn EX_FILEIO;\n\t}\n\n\trc = toggle_dac_capability(1, 1);\n\tif (rc)\n\t\treturn EX_FILEIO;\n\n\tatexit(unlock_mtab);\n\trc = lock_mtab();\n\tif (rc) {\n\t\tfprintf(stderr, \"cannot lock mtab\");\n\t\trc = EX_FILEIO;\n\t\tgoto add_mtab_exit;\n\t}\n\n\tpmntfile = setmntent(MOUNTED, \"a+\");\n\tif (!pmntfile) {\n\t\tfprintf(stderr, \"could not update mount table\\n\");\n\t\tunlock_mtab();\n\t\trc = EX_FILEIO;\n\t\tgoto add_mtab_exit;\n\t}\n\n\tmountent.mnt_fsname = devname;\n\tmountent.mnt_dir = mountpoint;\n\tmountent.mnt_type = (char *)(void *)fstype;\n\tmountent.mnt_opts = (char *)calloc(MTAB_OPTIONS_LEN, 1);\n\tif (mountent.mnt_opts) {\n\t\tif (flags & MS_RDONLY)\n\t\t\tstrlcat(mountent.mnt_opts, \"ro\", MTAB_OPTIONS_LEN);\n\t\telse\n\t\t\tstrlcat(mountent.mnt_opts, \"rw\", MTAB_OPTIONS_LEN);\n\n\t\tif (flags & MS_MANDLOCK)\n\t\t\tstrlcat(mountent.mnt_opts, \",mand\", MTAB_OPTIONS_LEN);\n\t\tif (flags & MS_NOEXEC)\n\t\t\tstrlcat(mountent.mnt_opts, \",noexec\", MTAB_OPTIONS_LEN);\n\t\tif (flags & MS_NOSUID)\n\t\t\tstrlcat(mountent.mnt_opts, \",nosuid\", MTAB_OPTIONS_LEN);\n\t\tif (flags & MS_NODEV)\n\t\t\tstrlcat(mountent.mnt_opts, \",nodev\", MTAB_OPTIONS_LEN);\n\t\tif (flags & MS_SYNCHRONOUS)\n\t\t\tstrlcat(mountent.mnt_opts, \",sync\", MTAB_OPTIONS_LEN);\n\t\tif (mount_user) {\n\t\t\tstrlcat(mountent.mnt_opts, \",user=\", MTAB_OPTIONS_LEN);\n\t\t\tstrlcat(mountent.mnt_opts, mount_user,\n\t\t\t\tMTAB_OPTIONS_LEN);\n\t\t}\n\t}\n\tmountent.mnt_freq = 0;\n\tmountent.mnt_passno = 0;\n\trc = addmntent(pmntfile, &mountent);\n\tif (rc) {\n\t\tfprintf(stderr, \"unable to add mount entry to mtab\\n\");\n\t\trc = EX_FILEIO;\n\t}\n\tendmntent(pmntfile);\n\tunlock_mtab();\n\tSAFE_FREE(mountent.mnt_opts);\nadd_mtab_exit:\n\ttoggle_dac_capability(1, 0);\n\tsigprocmask(SIG_SETMASK, &oldmask, NULL);\n\n\treturn rc;\n}",
        "target": 1
    },
    {
        "func": "thunar_transfer_job_copy_node (ThunarTransferJob  *job,\n                               ThunarTransferNode *node,\n                               GFile              *target_file,\n                               GFile              *target_parent_file,\n                               GList             **target_file_list_return,\n                               GError            **error)\n{\n  ThunarThumbnailCache *thumbnail_cache;\n  ThunarApplication    *application;\n  ThunarJobResponse     response;\n  GFileInfo            *info;\n  GError               *err = NULL;\n  GFile                *real_target_file = NULL;\n  gchar                *base_name;\n\n  _thunar_return_if_fail (THUNAR_IS_TRANSFER_JOB (job));\n  _thunar_return_if_fail (node != NULL && G_IS_FILE (node->source_file));\n  _thunar_return_if_fail (target_file == NULL || node->next == NULL);\n  _thunar_return_if_fail ((target_file == NULL && target_parent_file != NULL) || (target_file != NULL && target_parent_file == NULL));\n  _thunar_return_if_fail (error == NULL || *error == NULL);\n\n  /* The caller can either provide a target_file or a target_parent_file, but not both. The toplevel\n   * transfer_nodes (for which next is NULL) should be called with target_file, to get proper behavior\n   * wrt restoring files from the trash. Other transfer_nodes will be called with target_parent_file.\n   */\n\n  /* take a reference on the thumbnail cache */\n  application = thunar_application_get ();\n  thumbnail_cache = thunar_application_get_thumbnail_cache (application);\n  g_object_unref (application);\n\n  for (; err == NULL && node != NULL; node = node->next)\n    {\n      /* guess the target file for this node (unless already provided) */\n      if (G_LIKELY (target_file == NULL))\n        {\n          base_name = g_file_get_basename (node->source_file);\n          target_file = g_file_get_child (target_parent_file, base_name);\n          g_free (base_name);\n        }\n      else\n        target_file = g_object_ref (target_file);\n\n      /* query file info */\n      info = g_file_query_info (node->source_file,\n                                G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME,\n                                G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                exo_job_get_cancellable (EXO_JOB (job)),\n                                &err);\n\n      /* abort on error or cancellation */\n      if (info == NULL)\n        {\n          g_object_unref (target_file);\n          break;\n        }\n\n      /* update progress information */\n      exo_job_info_message (EXO_JOB (job), g_file_info_get_display_name (info));\n\nretry_copy:\n      /* copy the item specified by this node (not recursively) */\n      real_target_file = thunar_transfer_job_copy_file (job, node->source_file, \n                                                        target_file, &err);\n      if (G_LIKELY (real_target_file != NULL))\n        {\n          /* node->source_file == real_target_file means to skip the file */\n          if (G_LIKELY (node->source_file != real_target_file))\n            {\n              /* notify the thumbnail cache of the copy operation */\n              thunar_thumbnail_cache_copy_file (thumbnail_cache, \n                                                node->source_file, \n                                                real_target_file);\n\n              /* check if we have children to copy */\n              if (node->children != NULL)\n                {\n                  /* copy all children of this node */\n                  thunar_transfer_job_copy_node (job, node->children, NULL, real_target_file, NULL, &err);\n\n                  /* free resources allocted for the children */\n                  thunar_transfer_node_free (node->children);\n                  node->children = NULL;\n                }\n\n              /* check if the child copy failed */\n              if (G_UNLIKELY (err != NULL))\n                {\n                  /* outa here, freeing the target paths */\n                  g_object_unref (real_target_file);\n                  g_object_unref (target_file);\n                  break;\n                }\n\n              /* add the real target file to the return list */\n              if (G_LIKELY (target_file_list_return != NULL))\n                {\n                  *target_file_list_return = \n                    thunar_g_file_list_prepend (*target_file_list_return, \n                                                real_target_file);\n                }\n\nretry_remove:\n              /* try to remove the source directory if we are on copy+remove fallback for move */\n              if (job->type == THUNAR_TRANSFER_JOB_MOVE)\n                {\n                  if (g_file_delete (node->source_file, \n                                     exo_job_get_cancellable (EXO_JOB (job)), \n                                     &err))\n                    {\n                      /* notify the thumbnail cache of the delete operation */\n                      thunar_thumbnail_cache_delete_file (thumbnail_cache, \n                                                          node->source_file);\n                    }\n                  else\n                    {\n                      /* ask the user to retry */\n                      response = thunar_job_ask_skip (THUNAR_JOB (job), \"%s\", \n                                                      err->message);\n\n                      /* reset the error */\n                      g_clear_error (&err);\n\n                      /* check whether to retry */\n                      if (G_UNLIKELY (response == THUNAR_JOB_RESPONSE_RETRY))\n                        goto retry_remove;\n                    }\n                }\n            }\n\n          g_object_unref (real_target_file);\n        }\n      else if (err != NULL)\n        { \n          /* we can only skip if there is space left on the device */\n          if (err->domain != G_IO_ERROR || err->code != G_IO_ERROR_NO_SPACE) \n            {\n              /* ask the user to skip this node and all subnodes */\n              response = thunar_job_ask_skip (THUNAR_JOB (job), \"%s\", err->message);\n\n              /* reset the error */\n              g_clear_error (&err);\n\n              /* check whether to retry */\n              if (G_UNLIKELY (response == THUNAR_JOB_RESPONSE_RETRY))\n                goto retry_copy;\n            }\n        }\n\n      /* release the guessed target file */\n      g_object_unref (target_file);\n      target_file = NULL;\n\n      /* release file info */\n      g_object_unref (info);\n    }\n\n  /* release the thumbnail cache */\n  g_object_unref (thumbnail_cache);\n\n  /* propagate error if we failed or the job was cancelled */\n  if (G_UNLIKELY (err != NULL))\n    g_propagate_error (error, err);\n}",
        "target": 1
    },
    {
        "func": "static void virtio_blk_handle_read(VirtIOBlockReq *req)\n{\n    BlockDriverAIOCB *acb;\n    uint64_t sector;\n\n    sector = ldq_p(&req->out->sector);\n\n    if (sector & req->dev->sector_mask) {\n        virtio_blk_rw_complete(req, -EIO);\n        return;\n    }\n\n    acb = bdrv_aio_readv(req->dev->bs, sector, &req->qiov,\n                         req->qiov.size / BDRV_SECTOR_SIZE,\n                         virtio_blk_rw_complete, req);\n    if (!acb) {\n        virtio_blk_rw_complete(req, -EIO);\n    }\n}",
        "target": 1
    },
    {
        "func": "static void virtio_blk_handle_write(VirtIOBlockReq *req, MultiReqBuffer *mrb)\n{\n    BlockRequest *blkreq;\n    uint64_t sector;\n\n    sector = ldq_p(&req->out->sector);\n\n    trace_virtio_blk_handle_write(req, sector, req->qiov.size / 512);\n\n    if (sector & req->dev->sector_mask) {\n        virtio_blk_rw_complete(req, -EIO);\n        return;\n    }\n\n    if (mrb->num_writes == 32) {\n        virtio_submit_multiwrite(req->dev->bs, mrb);\n    }\n\n    blkreq = &mrb->blkreq[mrb->num_writes];\n    blkreq->sector = sector;\n    blkreq->nb_sectors = req->qiov.size / BDRV_SECTOR_SIZE;\n    blkreq->qiov = &req->qiov;\n    blkreq->cb = virtio_blk_rw_complete;\n    blkreq->opaque = req;\n    blkreq->error = 0;\n\n    mrb->num_writes++;\n}",
        "target": 1
    },
    {
        "func": "int agp_generic_insert_memory(struct agp_memory * mem, off_t pg_start, int type)\n{\n\tint num_entries;\n\tsize_t i;\n\toff_t j;\n\tvoid *temp;\n\tstruct agp_bridge_data *bridge;\n\tint mask_type;\n\n\tbridge = mem->bridge;\n\tif (!bridge)\n\t\treturn -EINVAL;\n\n\tif (mem->page_count == 0)\n\t\treturn 0;\n\n\ttemp = bridge->current_size;\n\n\tswitch (bridge->driver->size_type) {\n\tcase U8_APER_SIZE:\n\t\tnum_entries = A_SIZE_8(temp)->num_entries;\n\t\tbreak;\n\tcase U16_APER_SIZE:\n\t\tnum_entries = A_SIZE_16(temp)->num_entries;\n\t\tbreak;\n\tcase U32_APER_SIZE:\n\t\tnum_entries = A_SIZE_32(temp)->num_entries;\n\t\tbreak;\n\tcase FIXED_APER_SIZE:\n\t\tnum_entries = A_SIZE_FIX(temp)->num_entries;\n\t\tbreak;\n\tcase LVL2_APER_SIZE:\n\t\t/* The generic routines can't deal with 2 level gatt's */\n\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\tnum_entries = 0;\n\t\tbreak;\n\t}\n\n\tnum_entries -= agp_memory_reserved/PAGE_SIZE;\n\tif (num_entries < 0) num_entries = 0;\n\n\tif (type != mem->type)\n\t\treturn -EINVAL;\n\n\tmask_type = bridge->driver->agp_type_to_mask_type(bridge, type);\n\tif (mask_type != 0) {\n\t\t/* The generic routines know nothing of memory types */\n\t\treturn -EINVAL;\n\t}\n\n\t/* AK: could wrap */\n\tif ((pg_start + mem->page_count) > num_entries)\n\t\treturn -EINVAL;\n\n\tj = pg_start;\n\n\twhile (j < (pg_start + mem->page_count)) {\n\t\tif (!PGE_EMPTY(bridge, readl(bridge->gatt_table+j)))\n\t\t\treturn -EBUSY;\n\t\tj++;\n\t}\n\n\tif (!mem->is_flushed) {\n\t\tbridge->driver->cache_flush();\n\t\tmem->is_flushed = true;\n\t}\n\n\tfor (i = 0, j = pg_start; i < mem->page_count; i++, j++) {\n\t\twritel(bridge->driver->mask_memory(bridge,\n\t\t\t\t\t\t   page_to_phys(mem->pages[i]),\n\t\t\t\t\t\t   mask_type),\n\t\t       bridge->gatt_table+j);\n\t}\n\treadl(bridge->gatt_table+j-1);\t/* PCI Posting. */\n\n\tbridge->driver->tlb_flush(mem);\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "int agp_generic_remove_memory(struct agp_memory *mem, off_t pg_start, int type)\n{\n\tsize_t i;\n\tstruct agp_bridge_data *bridge;\n\tint mask_type;\n\n\tbridge = mem->bridge;\n\tif (!bridge)\n\t\treturn -EINVAL;\n\n\tif (mem->page_count == 0)\n\t\treturn 0;\n\n\tif (type != mem->type)\n\t\treturn -EINVAL;\n\n\tmask_type = bridge->driver->agp_type_to_mask_type(bridge, type);\n\tif (mask_type != 0) {\n\t\t/* The generic routines know nothing of memory types */\n\t\treturn -EINVAL;\n\t}\n\n\t/* AK: bogus, should encode addresses > 4GB */\n\tfor (i = pg_start; i < (mem->page_count + pg_start); i++) {\n\t\twritel(bridge->scratch_page, bridge->gatt_table+i);\n\t}\n\treadl(bridge->gatt_table+i-1);\t/* PCI Posting. */\n\n\tbridge->driver->tlb_flush(mem);\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static void krb5_save_ccname_done(struct tevent_req *req)\n{\n    struct krb5_auth_state *state = tevent_req_data(req, struct krb5_auth_state);\n    struct krb5child_req *kr = state->kr;\n    struct pam_data *pd = state->pd;\n    int ret;\n    char *password = NULL;\n\n    if (kr->is_offline) {\n        if (dp_opt_get_bool(kr->krb5_ctx->opts,KRB5_STORE_PASSWORD_IF_OFFLINE)) {\n            krb5_pam_handler_cache_auth_step(req);\n            return;\n        }\n\n        DEBUG(4, (\"Backend is marked offline, retry later!\\n\"));\n        state->pam_status = PAM_AUTHINFO_UNAVAIL;\n        state->dp_err = DP_ERR_OFFLINE;\n        ret = EOK;\n        goto done;\n    }\n\n    if (state->be_ctx->domain->cache_credentials == TRUE) {\n\n        /* password caching failures are not fatal errors */\n        state->pam_status = PAM_SUCCESS;\n        state->dp_err = DP_ERR_OK;\n\n        switch(pd->cmd) {\n            case SSS_PAM_AUTHENTICATE:\n            case SSS_CMD_RENEW:\n            case SSS_PAM_CHAUTHTOK_PRELIM:\n                password = talloc_size(state, pd->authtok_size + 1);\n                if (password != NULL) {\n                    memcpy(password, pd->authtok, pd->authtok_size);\n                    password[pd->authtok_size] = '\\0';\n                }\n                break;\n            case SSS_PAM_CHAUTHTOK:\n                password = talloc_size(state, pd->newauthtok_size + 1);\n                if (password != NULL) {\n                    memcpy(password, pd->newauthtok, pd->newauthtok_size);\n                    password[pd->newauthtok_size] = '\\0';\n                }\n                break;\n            default:\n                DEBUG(0, (\"unsupported PAM command [%d].\\n\", pd->cmd));\n        }\n\n        if (password == NULL) {\n            DEBUG(0, (\"password not available, offline auth may not work.\\n\"));\n            ret = EOK; /* password caching failures are not fatal errors */\n            goto done;\n        }\n\n        talloc_set_destructor((TALLOC_CTX *)password, password_destructor);\n\n        ret = sysdb_cache_password(state, state->be_ctx->sysdb,\n                                   state->be_ctx->domain, pd->user,\n                                   password);\n        if (ret) {\n            DEBUG(2, (\"Failed to cache password, offline auth may not work.\"\n                      \" (%d)[%s]!?\\n\", ret, strerror(ret)));\n        }\n    }\n\n    state->pam_status = PAM_SUCCESS;\n    state->dp_err = DP_ERR_OK;\n    ret = EOK;\n\ndone:\n    if (ret == EOK) {\n        tevent_req_done(req);\n    } else {\n        tevent_req_error(req, ret);\n    }\n\n}",
        "target": 1
    },
    {
        "func": "static void __exit ipgre_fini(void)\n{\n\trtnl_link_unregister(&ipgre_tap_ops);\n\trtnl_link_unregister(&ipgre_link_ops);\n\tunregister_pernet_device(&ipgre_net_ops);\n\tif (inet_del_protocol(&ipgre_protocol, IPPROTO_GRE) < 0)\n\t\tprintk(KERN_INFO \"ipgre close: can't remove protocol\\n\");\n}",
        "target": 1
    },
    {
        "func": "static int __init ipgre_init(void)\n{\n\tint err;\n\n\tprintk(KERN_INFO \"GRE over IPv4 tunneling driver\\n\");\n\n\tif (inet_add_protocol(&ipgre_protocol, IPPROTO_GRE) < 0) {\n\t\tprintk(KERN_INFO \"ipgre init: can't add protocol\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\terr = register_pernet_device(&ipgre_net_ops);\n\tif (err < 0)\n\t\tgoto gen_device_failed;\n\n\terr = rtnl_link_register(&ipgre_link_ops);\n\tif (err < 0)\n\t\tgoto rtnl_link_failed;\n\n\terr = rtnl_link_register(&ipgre_tap_ops);\n\tif (err < 0)\n\t\tgoto tap_ops_failed;\n\nout:\n\treturn err;\n\ntap_ops_failed:\n\trtnl_link_unregister(&ipgre_link_ops);\nrtnl_link_failed:\n\tunregister_pernet_device(&ipgre_net_ops);\ngen_device_failed:\n\tinet_del_protocol(&ipgre_protocol, IPPROTO_GRE);\n\tgoto out;\n}",
        "target": 1
    },
    {
        "func": "static int __init ip6_tunnel_init(void)\n{\n\tint  err;\n\n\tif (xfrm6_tunnel_register(&ip4ip6_handler, AF_INET)) {\n\t\tprintk(KERN_ERR \"ip6_tunnel init: can't register ip4ip6\\n\");\n\t\terr = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tif (xfrm6_tunnel_register(&ip6ip6_handler, AF_INET6)) {\n\t\tprintk(KERN_ERR \"ip6_tunnel init: can't register ip6ip6\\n\");\n\t\terr = -EAGAIN;\n\t\tgoto unreg_ip4ip6;\n\t}\n\n\terr = register_pernet_device(&ip6_tnl_net_ops);\n\tif (err < 0)\n\t\tgoto err_pernet;\n\treturn 0;\nerr_pernet:\n\txfrm6_tunnel_deregister(&ip6ip6_handler, AF_INET6);\nunreg_ip4ip6:\n\txfrm6_tunnel_deregister(&ip4ip6_handler, AF_INET);\nout:\n\treturn err;\n}",
        "target": 1
    },
    {
        "func": "static int __init xfrm6_tunnel_init(void)\n{\n\tint rv;\n\n\trv = xfrm_register_type(&xfrm6_tunnel_type, AF_INET6);\n\tif (rv < 0)\n\t\tgoto err;\n\trv = xfrm6_tunnel_register(&xfrm6_tunnel_handler, AF_INET6);\n\tif (rv < 0)\n\t\tgoto unreg;\n\trv = xfrm6_tunnel_register(&xfrm46_tunnel_handler, AF_INET);\n\tif (rv < 0)\n\t\tgoto dereg6;\n\trv = xfrm6_tunnel_spi_init();\n\tif (rv < 0)\n\t\tgoto dereg46;\n\trv = register_pernet_subsys(&xfrm6_tunnel_net_ops);\n\tif (rv < 0)\n\t\tgoto deregspi;\n\treturn 0;\n\nderegspi:\n\txfrm6_tunnel_spi_fini();\ndereg46:\n\txfrm6_tunnel_deregister(&xfrm46_tunnel_handler, AF_INET);\ndereg6:\n\txfrm6_tunnel_deregister(&xfrm6_tunnel_handler, AF_INET6);\nunreg:\n\txfrm_unregister_type(&xfrm6_tunnel_type, AF_INET6);\nerr:\n\treturn rv;\n}",
        "target": 1
    },
    {
        "func": "static void __exit xfrm6_tunnel_fini(void)\n{\n\tunregister_pernet_subsys(&xfrm6_tunnel_net_ops);\n\txfrm6_tunnel_spi_fini();\n\txfrm6_tunnel_deregister(&xfrm46_tunnel_handler, AF_INET);\n\txfrm6_tunnel_deregister(&xfrm6_tunnel_handler, AF_INET6);\n\txfrm_unregister_type(&xfrm6_tunnel_type, AF_INET6);\n}",
        "target": 1
    },
    {
        "func": "static int __init xfrm6_tunnel_spi_init(void)\n{\n\txfrm6_tunnel_spi_kmem = kmem_cache_create(\"xfrm6_tunnel_spi\",\n\t\t\t\t\t\t  sizeof(struct xfrm6_tunnel_spi),\n\t\t\t\t\t\t  0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t\t  NULL);\n\tif (!xfrm6_tunnel_spi_kmem)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static void xfrm6_tunnel_spi_fini(void)\n{\n\tkmem_cache_destroy(xfrm6_tunnel_spi_kmem);\n}",
        "target": 1
    },
    {
        "func": "static int __init sit_init(void)\n{\n\tint err;\n\n\tprintk(KERN_INFO \"IPv6 over IPv4 tunneling driver\\n\");\n\n\tif (xfrm4_tunnel_register(&sit_handler, AF_INET6) < 0) {\n\t\tprintk(KERN_INFO \"sit init: Can't add protocol\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\terr = register_pernet_device(&sit_net_ops);\n\tif (err < 0)\n\t\txfrm4_tunnel_deregister(&sit_handler, AF_INET6);\n\n\treturn err;\n}",
        "target": 1
    },
    {
        "func": "static int __init ipip_init(void)\n{\n\tint err;\n\n\tprintk(banner);\n\n\tif (xfrm4_tunnel_register(&ipip_handler, AF_INET)) {\n\t\tprintk(KERN_INFO \"ipip init: can't register tunnel\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\terr = register_pernet_device(&ipip_net_ops);\n\tif (err)\n\t\txfrm4_tunnel_deregister(&ipip_handler, AF_INET);\n\n\treturn err;\n}",
        "target": 1
    },
    {
        "func": "void dkim_exim_verify_finish(void) {\n  pdkim_signature *sig = NULL;\n  int dkim_signers_size = 0;\n  int dkim_signers_ptr = 0;\n  dkim_signers = NULL;\n\n  /* Delete eventual previous signature chain */\n  dkim_signatures = NULL;\n\n  /* If we have arrived here with dkim_collect_input == FALSE, it\n     means there was a processing error somewhere along the way.\n     Log the incident and disable futher verification. */\n  if (!dkim_collect_input) {\n    log_write(0, LOG_MAIN, \"DKIM: Error while running this message through validation, disabling signature verification.\");\n    dkim_disable_verify = TRUE;\n    return;\n  }\n  dkim_collect_input = FALSE;\n\n  /* Finish DKIM operation and fetch link to signatures chain */\n  if (pdkim_feed_finish(dkim_verify_ctx,&dkim_signatures) != PDKIM_OK) return;\n\n  sig = dkim_signatures;\n  while (sig != NULL) {\n    int size = 0;\n    int ptr = 0;\n    /* Log a line for each signature */\n    uschar *logmsg = string_append(NULL, &size, &ptr, 5,\n\n      string_sprintf( \"DKIM: d=%s s=%s c=%s/%s a=%s \",\n                      sig->domain,\n                      sig->selector,\n                      (sig->canon_headers == PDKIM_CANON_SIMPLE)?\"simple\":\"relaxed\",\n                      (sig->canon_body    == PDKIM_CANON_SIMPLE)?\"simple\":\"relaxed\",\n                      (sig->algo          == PDKIM_ALGO_RSA_SHA256)?\"rsa-sha256\":\"rsa-sha1\"\n                    ),\n      ((sig->identity != NULL)?\n        string_sprintf(\"i=%s \", sig->identity)\n        :\n        US\"\"\n      ),\n      ((sig->created > 0)?\n        string_sprintf(\"t=%lu \", sig->created)\n        :\n        US\"\"\n      ),\n      ((sig->expires > 0)?\n        string_sprintf(\"x=%lu \", sig->expires)\n        :\n        US\"\"\n      ),\n      ((sig->bodylength > -1)?\n        string_sprintf(\"l=%lu \", sig->bodylength)\n        :\n        US\"\"\n      )\n    );\n\n    switch(sig->verify_status) {\n      case PDKIM_VERIFY_NONE:\n        logmsg = string_append(logmsg, &size, &ptr, 1, \"[not verified]\");\n      break;\n      case PDKIM_VERIFY_INVALID:\n        logmsg = string_append(logmsg, &size, &ptr, 1, \"[invalid - \");\n        switch (sig->verify_ext_status) {\n          case PDKIM_VERIFY_INVALID_PUBKEY_UNAVAILABLE:\n            logmsg = string_append(logmsg, &size, &ptr, 1, \"public key record (currently?) unavailable]\");\n          break;\n          case PDKIM_VERIFY_INVALID_BUFFER_SIZE:\n            logmsg = string_append(logmsg, &size, &ptr, 1, \"overlong public key record]\");\n          break;\n          case PDKIM_VERIFY_INVALID_PUBKEY_PARSING:\n            logmsg = string_append(logmsg, &size, &ptr, 1, \"syntax error in public key record]\");\n          break;\n          default:\n            logmsg = string_append(logmsg, &size, &ptr, 1, \"unspecified problem]\");\n        }\n      break;\n      case PDKIM_VERIFY_FAIL:\n        logmsg = string_append(logmsg, &size, &ptr, 1, \"[verification failed - \");\n        switch (sig->verify_ext_status) {\n          case PDKIM_VERIFY_FAIL_BODY:\n            logmsg = string_append(logmsg, &size, &ptr, 1, \"body hash mismatch (body probably modified in transit)]\");\n          break;\n          case PDKIM_VERIFY_FAIL_MESSAGE:\n            logmsg = string_append(logmsg, &size, &ptr, 1, \"signature did not verify (headers probably modified in transit)]\");\n          break;\n          default:\n            logmsg = string_append(logmsg, &size, &ptr, 1, \"unspecified reason]\");\n        }\n      break;\n      case PDKIM_VERIFY_PASS:\n        logmsg = string_append(logmsg, &size, &ptr, 1, \"[verification succeeded]\");\n      break;\n    }\n\n    logmsg[ptr] = '\\0';\n    log_write(0, LOG_MAIN, (char *)logmsg);\n\n    /* Build a colon-separated list of signing domains (and identities, if present) in dkim_signers */\n    dkim_signers = string_append(dkim_signers,\n                                 &dkim_signers_size,\n                                 &dkim_signers_ptr,\n                                 2,\n                                 sig->domain,\n                                 \":\"\n                                );\n\n    if (sig->identity != NULL) {\n      dkim_signers = string_append(dkim_signers,\n                                   &dkim_signers_size,\n                                   &dkim_signers_ptr,\n                                   2,\n                                   sig->identity,\n                                   \":\"\n                                  );\n    }\n\n    /* Process next signature */\n    sig = sig->next;\n  }\n\n  /* NULL-terminate and chop the last colon from the domain list */\n  if (dkim_signers != NULL) {\n    dkim_signers[dkim_signers_ptr] = '\\0';\n    if (Ustrlen(dkim_signers) > 0)\n      dkim_signers[Ustrlen(dkim_signers)-1] = '\\0';\n  }\n}",
        "target": 1
    },
    {
        "func": "read_channel_data (FILE       *f,\n                   PSPimage   *ia,\n                   guchar    **pixels,\n                   guint       bytespp,\n                   guint       offset,\n                   GimpDrawable  *drawable,\n                   guint32     compressed_len)\n{\n  gint i, y, width = drawable->width, height = drawable->height;\n  gint npixels = width * height;\n  guchar *buf, *p, *q, *endq;\n  guchar *buf2 = NULL;  /* please the compiler */\n  guchar runcount, byte;\n  z_stream zstream;\n\n  switch (ia->compression)\n    {\n    case PSP_COMP_NONE:\n      if (bytespp == 1)\n        {\n          if ((width % 4) == 0)\n            fread (pixels[0], height * width, 1, f);\n          else\n            {\n              for (y = 0; y < height; y++)\n                {\n                  fread (pixels[y], width, 1, f);\n                  fseek (f, 4 - (width % 4), SEEK_CUR);\n                }\n            }\n        }\n      else\n        {\n          buf = g_malloc (width);\n          for (y = 0; y < height; y++)\n            {\n              fread (buf, width, 1, f);\n              if (width % 4)\n                fseek (f, 4 - (width % 4), SEEK_CUR);\n              p = buf;\n              q = pixels[y] + offset;\n              for (i = 0; i < width; i++)\n                {\n                  *q = *p++;\n                  q += bytespp;\n                }\n            }\n          g_free (buf);\n        }\n      break;\n\n    case PSP_COMP_RLE:\n      q = pixels[0] + offset;\n      endq = q + npixels * bytespp;\n      buf = g_malloc (127);\n      while (q < endq)\n        {\n          p = buf;\n          fread (&runcount, 1, 1, f);\n          if (runcount > 128)\n            {\n              runcount -= 128;\n              fread (&byte, 1, 1, f);\n              memset (buf, byte, runcount);\n            }\n          else\n            fread (buf, runcount, 1, f);\n          if (bytespp == 1)\n            {\n              memmove (q, buf, runcount);\n              q += runcount;\n            }\n          else\n            {\n              p = buf;\n              for (i = 0; i < runcount; i++)\n                {\n                  *q = *p++;\n                  q += bytespp;\n                }\n            }\n        }\n      g_free (buf);\n      break;\n\n    case PSP_COMP_LZ77:\n      buf = g_malloc (compressed_len);\n      fread (buf, compressed_len, 1, f);\n      zstream.next_in = buf;\n      zstream.avail_in = compressed_len;\n      zstream.zalloc = psp_zalloc;\n      zstream.zfree = psp_zfree;\n      zstream.opaque = f;\n      if (inflateInit (&zstream) != Z_OK)\n        {\n          g_message (\"zlib error\");\n          return -1;\n        }\n      if (bytespp == 1)\n        zstream.next_out = pixels[0];\n      else\n        {\n          buf2 = g_malloc (npixels);\n          zstream.next_out = buf2;\n        }\n      zstream.avail_out = npixels;\n      if (inflate (&zstream, Z_FINISH) != Z_STREAM_END)\n        {\n          g_message (\"zlib error\");\n          inflateEnd (&zstream);\n          return -1;\n        }\n      inflateEnd (&zstream);\n      g_free (buf);\n\n      if (bytespp > 1)\n        {\n          p = buf2;\n          q = pixels[0] + offset;\n          for (i = 0; i < npixels; i++)\n            {\n              *q = *p++;\n              q += bytespp;\n            }\n          g_free (buf2);\n        }\n      break;\n    }\n\n  return 0;\n}",
        "target": 1
    },
    {
        "func": "policy_summarize(smartlist_t *policy)\n{\n  smartlist_t *summary = policy_summary_create();\n  smartlist_t *accepts, *rejects;\n  int i, last, start_prt;\n  size_t accepts_len, rejects_len, shorter_len, final_size;\n  char *accepts_str = NULL, *rejects_str = NULL, *shorter_str, *result;\n  const char *prefix;\n\n  tor_assert(policy);\n\n  /* Create the summary list */\n  SMARTLIST_FOREACH(policy, addr_policy_t *, p, {\n    policy_summary_add_item(summary, p);\n  });\n\n  /* Now create two lists of strings, one for accepted and one\n   * for rejected ports.  We take care to merge ranges so that\n   * we avoid getting stuff like \"1-4,5-9,10\", instead we want\n   * \"1-10\"\n   */\n  i = 0;\n  start_prt = 1;\n  accepts = smartlist_create();\n  rejects = smartlist_create();\n  while (1) {\n    last = i == smartlist_len(summary)-1;\n    if (last ||\n        AT(i)->accepted != AT(i+1)->accepted) {\n      char buf[POLICY_BUF_LEN];\n\n      if (start_prt == AT(i)->prt_max)\n        tor_snprintf(buf, sizeof(buf), \"%d\", start_prt);\n      else\n        tor_snprintf(buf, sizeof(buf), \"%d-%d\", start_prt, AT(i)->prt_max);\n\n      if (AT(i)->accepted)\n        smartlist_add(accepts, tor_strdup(buf));\n      else\n        smartlist_add(rejects, tor_strdup(buf));\n\n      if (last)\n        break;\n\n      start_prt = AT(i+1)->prt_min;\n    };\n    i++;\n  };\n\n  /* Figure out which of the two stringlists will be shorter and use\n   * that to build the result\n   */\n  if (smartlist_len(accepts) == 0) { /* no exits at all */\n    result = tor_strdup(\"reject 1-65535\");\n    goto cleanup;\n  }\n  if (smartlist_len(rejects) == 0) { /* no rejects at all */\n    result = tor_strdup(\"accept 1-65535\");\n    goto cleanup;\n  }\n\n  accepts_str = smartlist_join_strings(accepts, \",\", 0, &accepts_len);\n  rejects_str = smartlist_join_strings(rejects, \",\", 0, &rejects_len);\n\n  if (rejects_len > MAX_EXITPOLICY_SUMMARY_LEN &&\n      accepts_len > MAX_EXITPOLICY_SUMMARY_LEN) {\n    char *c;\n    shorter_str = accepts_str;\n    prefix = \"accept\";\n\n    c = shorter_str + (MAX_EXITPOLICY_SUMMARY_LEN-strlen(prefix)-1);\n    while (*c != ',' && c >= shorter_str)\n      c--;\n    tor_assert(c >= shorter_str);\n    tor_assert(*c == ',');\n    *c = '\\0';\n\n    shorter_len = strlen(shorter_str);\n  } else if (rejects_len < accepts_len) {\n    shorter_str = rejects_str;\n    shorter_len = rejects_len;\n    prefix = \"reject\";\n  } else {\n    shorter_str = accepts_str;\n    shorter_len = accepts_len;\n    prefix = \"accept\";\n  }\n\n  final_size = strlen(prefix)+1+shorter_len+1;\n  tor_assert(final_size <= MAX_EXITPOLICY_SUMMARY_LEN+1);\n  result = tor_malloc(final_size);\n  tor_snprintf(result, final_size, \"%s %s\", prefix, shorter_str);\n\ncleanup:\n  /* cleanup */\n  SMARTLIST_FOREACH(summary, policy_summary_item_t *, s, tor_free(s));\n  smartlist_free(summary);\n\n  tor_free(accepts_str);\n  SMARTLIST_FOREACH(accepts, char *, s, tor_free(s));\n  smartlist_free(accepts);\n\n  tor_free(rejects_str);\n  SMARTLIST_FOREACH(rejects, char *, s, tor_free(s));\n  smartlist_free(rejects);\n\n  return result;\n}",
        "target": 1
    },
    {
        "func": "rfbNewTCPOrUDPClient(rfbScreenInfoPtr rfbScreen,\n                     int sock,\n                     rfbBool isUDP)\n{\n    rfbProtocolVersionMsg pv;\n    rfbClientIteratorPtr iterator;\n    rfbClientPtr cl,cl_;\n    struct sockaddr_in addr;\n    socklen_t addrlen = sizeof(struct sockaddr_in);\n    rfbProtocolExtension* extension;\n\n    cl = (rfbClientPtr)calloc(sizeof(rfbClientRec),1);\n\n    cl->screen = rfbScreen;\n    cl->sock = sock;\n    cl->viewOnly = FALSE;\n    /* setup pseudo scaling */\n    cl->scaledScreen = rfbScreen;\n    cl->scaledScreen->scaledScreenRefCount++;\n\n    rfbResetStats(cl);\n\n    cl->clientData = NULL;\n    cl->clientGoneHook = rfbDoNothingWithClient;\n\n    if(isUDP) {\n      rfbLog(\" accepted UDP client\\n\");\n    } else {\n      int one=1;\n\n      getpeername(sock, (struct sockaddr *)&addr, &addrlen);\n      cl->host = strdup(inet_ntoa(addr.sin_addr));\n\n      rfbLog(\"  other clients:\\n\");\n      iterator = rfbGetClientIterator(rfbScreen);\n      while ((cl_ = rfbClientIteratorNext(iterator)) != NULL) {\n        rfbLog(\"     %s\\n\",cl_->host);\n      }\n      rfbReleaseClientIterator(iterator);\n\n#ifndef WIN32\n      if (fcntl(sock, F_SETFL, O_NONBLOCK) < 0) {\n\trfbLogPerror(\"fcntl failed\");\n\tclose(sock);\n\treturn NULL;\n      }\n#endif\n\n      if (setsockopt(sock, IPPROTO_TCP, TCP_NODELAY,\n\t\t     (char *)&one, sizeof(one)) < 0) {\n\trfbLogPerror(\"setsockopt failed\");\n\tclose(sock);\n\treturn NULL;\n      }\n\n      FD_SET(sock,&(rfbScreen->allFds));\n\t\trfbScreen->maxFd = max(sock,rfbScreen->maxFd);\n\n      INIT_MUTEX(cl->outputMutex);\n      INIT_MUTEX(cl->refCountMutex);\n      INIT_COND(cl->deleteCond);\n\n      cl->state = RFB_PROTOCOL_VERSION;\n\n      cl->reverseConnection = FALSE;\n      cl->readyForSetColourMapEntries = FALSE;\n      cl->useCopyRect = FALSE;\n      cl->preferredEncoding = -1;\n      cl->correMaxWidth = 48;\n      cl->correMaxHeight = 48;\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n      cl->zrleData = NULL;\n#endif\n\n      cl->copyRegion = sraRgnCreate();\n      cl->copyDX = 0;\n      cl->copyDY = 0;\n   \n      cl->modifiedRegion =\n\tsraRgnCreateRect(0,0,rfbScreen->width,rfbScreen->height);\n\n      INIT_MUTEX(cl->updateMutex);\n      INIT_COND(cl->updateCond);\n\n      cl->requestedRegion = sraRgnCreate();\n\n      cl->format = cl->screen->serverFormat;\n      cl->translateFn = rfbTranslateNone;\n      cl->translateLookupTable = NULL;\n\n      LOCK(rfbClientListMutex);\n\n      IF_PTHREADS(cl->refCount = 0);\n      cl->next = rfbScreen->clientHead;\n      cl->prev = NULL;\n      if (rfbScreen->clientHead)\n        rfbScreen->clientHead->prev = cl;\n\n      rfbScreen->clientHead = cl;\n      UNLOCK(rfbClientListMutex);\n\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n      cl->tightQualityLevel = -1;\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n      cl->tightCompressLevel = TIGHT_DEFAULT_COMPRESSION;\n      {\n\tint i;\n\tfor (i = 0; i < 4; i++)\n          cl->zsActive[i] = FALSE;\n      }\n#endif\n#endif\n\n      cl->fileTransfer.fd = -1;\n\n      cl->enableCursorShapeUpdates = FALSE;\n      cl->enableCursorPosUpdates = FALSE;\n      cl->useRichCursorEncoding = FALSE;\n      cl->enableLastRectEncoding = FALSE;\n      cl->enableKeyboardLedState = FALSE;\n      cl->enableSupportedMessages = FALSE;\n      cl->enableSupportedEncodings = FALSE;\n      cl->enableServerIdentity = FALSE;\n      cl->lastKeyboardLedState = -1;\n      cl->cursorX = rfbScreen->cursorX;\n      cl->cursorY = rfbScreen->cursorY;\n      cl->useNewFBSize = FALSE;\n\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n      cl->compStreamInited = FALSE;\n      cl->compStream.total_in = 0;\n      cl->compStream.total_out = 0;\n      cl->compStream.zalloc = Z_NULL;\n      cl->compStream.zfree = Z_NULL;\n      cl->compStream.opaque = Z_NULL;\n\n      cl->zlibCompressLevel = 5;\n#endif\n\n      cl->progressiveSliceY = 0;\n\n      cl->extensions = NULL;\n\n      cl->lastPtrX = -1;\n\n      sprintf(pv,rfbProtocolVersionFormat,rfbScreen->protocolMajorVersion, \n              rfbScreen->protocolMinorVersion);\n\n      if (rfbWriteExact(cl, pv, sz_rfbProtocolVersionMsg) < 0) {\n        rfbLogPerror(\"rfbNewClient: write\");\n        rfbCloseClient(cl);\n\trfbClientConnectionGone(cl);\n        return NULL;\n      }\n    }\n\n    for(extension = rfbGetExtensionIterator(); extension;\n\t    extension=extension->next) {\n\tvoid* data = NULL;\n\t/* if the extension does not have a newClient method, it wants\n\t * to be initialized later. */\n\tif(extension->newClient && extension->newClient(cl, &data))\n\t\trfbEnableExtension(cl, extension, data);\n    }\n    rfbReleaseExtensionIterator();\n\n    switch (cl->screen->newClientHook(cl)) {\n    case RFB_CLIENT_ON_HOLD:\n\t    cl->onHold = TRUE;\n\t    break;\n    case RFB_CLIENT_ACCEPT:\n\t    cl->onHold = FALSE;\n\t    break;\n    case RFB_CLIENT_REFUSE:\n\t    rfbCloseClient(cl);\n\t    rfbClientConnectionGone(cl);\n\t    cl = NULL;\n\t    break;\n    }\n    return cl;\n}",
        "target": 1
    },
    {
        "func": "rfbClientConnectionGone(rfbClientPtr cl)\n{\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n    int i;\n#endif\n\n    LOCK(rfbClientListMutex);\n\n    if (cl->prev)\n        cl->prev->next = cl->next;\n    else\n        cl->screen->clientHead = cl->next;\n    if (cl->next)\n        cl->next->prev = cl->prev;\n\n    if(cl->sock>0)\n\tclose(cl->sock);\n\n    if (cl->scaledScreen!=NULL)\n        cl->scaledScreen->scaledScreenRefCount--;\n\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n    rfbFreeZrleData(cl);\n#endif\n\n    rfbFreeUltraData(cl);\n\n#ifdef LIBVNCSERVER_HAVE_LIBPTHREAD\n    if(cl->screen->backgroundLoop != FALSE) {\n      int i;\n      do {\n\tLOCK(cl->refCountMutex);\n\ti=cl->refCount;\n\tif(i>0)\n\t  WAIT(cl->deleteCond,cl->refCountMutex);\n\tUNLOCK(cl->refCountMutex);\n      } while(i>0);\n    }\n#endif\n\n    UNLOCK(rfbClientListMutex);\n\n    if(cl->sock>=0)\n       FD_CLR(cl->sock,&(cl->screen->allFds));\n\n    cl->clientGoneHook(cl);\n\n    rfbLog(\"Client %s gone\\n\",cl->host);\n    free(cl->host);\n\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n    /* Release the compression state structures if any. */\n    if ( cl->compStreamInited ) {\n\tdeflateEnd( &(cl->compStream) );\n    }\n\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n    for (i = 0; i < 4; i++) {\n\tif (cl->zsActive[i])\n\t    deflateEnd(&cl->zsStruct[i]);\n    }\n#endif\n#endif\n\n    if (cl->screen->pointerClient == cl)\n        cl->screen->pointerClient = NULL;\n\n    sraRgnDestroy(cl->modifiedRegion);\n    sraRgnDestroy(cl->requestedRegion);\n    sraRgnDestroy(cl->copyRegion);\n\n    if (cl->translateLookupTable) free(cl->translateLookupTable);\n\n    TINI_COND(cl->updateCond);\n    TINI_MUTEX(cl->updateMutex);\n\n    /* make sure outputMutex is unlocked before destroying */\n    LOCK(cl->outputMutex);\n    UNLOCK(cl->outputMutex);\n    TINI_MUTEX(cl->outputMutex);\n\n#ifdef CORBA\n    destroyConnection(cl);\n#endif\n\n    rfbPrintStats(cl);\n\n    free(cl);\n}",
        "target": 1
    },
    {
        "func": "void rfbTightCleanup(rfbScreenInfoPtr screen)\n{\n  if(tightBeforeBufSize) {\n    free(tightBeforeBuf);\n    tightBeforeBufSize=0;\n  }\n  if(tightAfterBufSize) {\n    free(tightAfterBuf);\n    tightAfterBufSize=0;\n  }\n}",
        "target": 1
    },
    {
        "func": "rfbProcessClientNormalMessage(rfbClientPtr cl)\n{\n    int n=0;\n    rfbClientToServerMsg msg;\n    char *str;\n    int i;\n    uint32_t enc=0;\n    uint32_t lastPreferredEncoding = -1;\n    char encBuf[64];\n    char encBuf2[64];\n\n    if ((n = rfbReadExact(cl, (char *)&msg, 1)) <= 0) {\n        if (n != 0)\n            rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n        rfbCloseClient(cl);\n        return;\n    }\n\n    switch (msg.type) {\n\n    case rfbSetPixelFormat:\n\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                           sz_rfbSetPixelFormatMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n\n        cl->format.bitsPerPixel = msg.spf.format.bitsPerPixel;\n        cl->format.depth = msg.spf.format.depth;\n        cl->format.bigEndian = (msg.spf.format.bigEndian ? TRUE : FALSE);\n        cl->format.trueColour = (msg.spf.format.trueColour ? TRUE : FALSE);\n        cl->format.redMax = Swap16IfLE(msg.spf.format.redMax);\n        cl->format.greenMax = Swap16IfLE(msg.spf.format.greenMax);\n        cl->format.blueMax = Swap16IfLE(msg.spf.format.blueMax);\n        cl->format.redShift = msg.spf.format.redShift;\n        cl->format.greenShift = msg.spf.format.greenShift;\n        cl->format.blueShift = msg.spf.format.blueShift;\n\n\tcl->readyForSetColourMapEntries = TRUE;\n        cl->screen->setTranslateFunction(cl);\n\n        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetPixelFormatMsg, sz_rfbSetPixelFormatMsg);\n\n        return;\n\n\n    case rfbFixColourMapEntries:\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                           sz_rfbFixColourMapEntriesMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetPixelFormatMsg, sz_rfbSetPixelFormatMsg);\n        rfbLog(\"rfbProcessClientNormalMessage: %s\",\n                \"FixColourMapEntries unsupported\\n\");\n        rfbCloseClient(cl);\n        return;\n\n\n    /* NOTE: Some clients send us a set of encodings (ie: PointerPos) designed to enable/disable features...\n     * We may want to look into this...\n     * Example:\n     *     case rfbEncodingXCursor:\n     *         cl->enableCursorShapeUpdates = TRUE;\n     *\n     * Currently: cl->enableCursorShapeUpdates can *never* be turned off...\n     */\n    case rfbSetEncodings:\n    {\n\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                           sz_rfbSetEncodingsMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n\n        msg.se.nEncodings = Swap16IfLE(msg.se.nEncodings);\n\n        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetEncodingsMsg+(msg.se.nEncodings*4),sz_rfbSetEncodingsMsg+(msg.se.nEncodings*4));\n\n        /*\n         * UltraVNC Client has the ability to adapt to changing network environments\n         * So, let's give it a change to tell us what it wants now!\n         */\n        if (cl->preferredEncoding!=-1)\n            lastPreferredEncoding = cl->preferredEncoding;\n\n        /* Reset all flags to defaults (allows us to switch between PointerPos and Server Drawn Cursors) */\n        cl->preferredEncoding=-1;\n        cl->useCopyRect              = FALSE;\n        cl->useNewFBSize             = FALSE;\n        cl->cursorWasChanged         = FALSE;\n        cl->useRichCursorEncoding    = FALSE;\n        cl->enableCursorPosUpdates   = FALSE;\n        cl->enableCursorShapeUpdates = FALSE;\n        cl->enableCursorShapeUpdates = FALSE;\n        cl->enableLastRectEncoding   = FALSE;\n        cl->enableKeyboardLedState   = FALSE;\n        cl->enableSupportedMessages  = FALSE;\n        cl->enableSupportedEncodings = FALSE;\n        cl->enableServerIdentity     = FALSE;\n\n\n        for (i = 0; i < msg.se.nEncodings; i++) {\n            if ((n = rfbReadExact(cl, (char *)&enc, 4)) <= 0) {\n                if (n != 0)\n                    rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n                rfbCloseClient(cl);\n                return;\n            }\n            enc = Swap32IfLE(enc);\n\n            switch (enc) {\n\n            case rfbEncodingCopyRect:\n\t\tcl->useCopyRect = TRUE;\n                break;\n            case rfbEncodingRaw:\n            case rfbEncodingRRE:\n            case rfbEncodingCoRRE:\n            case rfbEncodingHextile:\n            case rfbEncodingUltra:\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n\t    case rfbEncodingZlib:\n            case rfbEncodingZRLE:\n            case rfbEncodingZYWRLE:\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n\t    case rfbEncodingTight:\n#endif\n#endif\n            /* The first supported encoding is the 'preferred' encoding */\n                if (cl->preferredEncoding == -1)\n                    cl->preferredEncoding = enc;\n\n\n                break;\n\t    case rfbEncodingXCursor:\n\t\tif(!cl->screen->dontConvertRichCursorToXCursor) {\n\t\t    rfbLog(\"Enabling X-style cursor updates for client %s\\n\",\n\t\t\t   cl->host);\n\t\t    /* if cursor was drawn, hide the cursor */\n\t\t    if(!cl->enableCursorShapeUpdates)\n\t\t        rfbRedrawAfterHideCursor(cl,NULL);\n\n\t\t    cl->enableCursorShapeUpdates = TRUE;\n\t\t    cl->cursorWasChanged = TRUE;\n\t\t}\n\t\tbreak;\n\t    case rfbEncodingRichCursor:\n\t        rfbLog(\"Enabling full-color cursor updates for client %s\\n\",\n\t\t       cl->host);\n\t\t/* if cursor was drawn, hide the cursor */\n\t\tif(!cl->enableCursorShapeUpdates)\n\t\t    rfbRedrawAfterHideCursor(cl,NULL);\n\n\t        cl->enableCursorShapeUpdates = TRUE;\n\t        cl->useRichCursorEncoding = TRUE;\n\t        cl->cursorWasChanged = TRUE;\n\t        break;\n\t    case rfbEncodingPointerPos:\n\t\tif (!cl->enableCursorPosUpdates) {\n\t\t    rfbLog(\"Enabling cursor position updates for client %s\\n\",\n\t\t\t   cl->host);\n\t\t    cl->enableCursorPosUpdates = TRUE;\n\t\t    cl->cursorWasMoved = TRUE;\n\t\t}\n\t        break;\n\t    case rfbEncodingLastRect:\n\t\tif (!cl->enableLastRectEncoding) {\n\t\t    rfbLog(\"Enabling LastRect protocol extension for client \"\n\t\t\t   \"%s\\n\", cl->host);\n\t\t    cl->enableLastRectEncoding = TRUE;\n\t\t}\n\t\tbreak;\n\t    case rfbEncodingNewFBSize:\n\t\tif (!cl->useNewFBSize) {\n\t\t    rfbLog(\"Enabling NewFBSize protocol extension for client \"\n\t\t\t   \"%s\\n\", cl->host);\n\t\t    cl->useNewFBSize = TRUE;\n\t\t}\n\t\tbreak;\n            case rfbEncodingKeyboardLedState:\n                if (!cl->enableKeyboardLedState) {\n                  rfbLog(\"Enabling KeyboardLedState protocol extension for client \"\n                          \"%s\\n\", cl->host);\n                  cl->enableKeyboardLedState = TRUE;\n                }\n                break;           \n            case rfbEncodingSupportedMessages:\n                if (!cl->enableSupportedMessages) {\n                  rfbLog(\"Enabling SupportedMessages protocol extension for client \"\n                          \"%s\\n\", cl->host);\n                  cl->enableSupportedMessages = TRUE;\n                }\n                break;           \n            case rfbEncodingSupportedEncodings:\n                if (!cl->enableSupportedEncodings) {\n                  rfbLog(\"Enabling SupportedEncodings protocol extension for client \"\n                          \"%s\\n\", cl->host);\n                  cl->enableSupportedEncodings = TRUE;\n                }\n                break;           \n            case rfbEncodingServerIdentity:\n                if (!cl->enableServerIdentity) {\n                  rfbLog(\"Enabling ServerIdentity protocol extension for client \"\n                          \"%s\\n\", cl->host);\n                  cl->enableServerIdentity = TRUE;\n                }\n                break;           \n            default:\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n\t\tif ( enc >= (uint32_t)rfbEncodingCompressLevel0 &&\n\t\t     enc <= (uint32_t)rfbEncodingCompressLevel9 ) {\n\t\t    cl->zlibCompressLevel = enc & 0x0F;\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n\t\t    cl->tightCompressLevel = enc & 0x0F;\n\t\t    rfbLog(\"Using compression level %d for client %s\\n\",\n\t\t\t   cl->tightCompressLevel, cl->host);\n#endif\n\t\t} else if ( enc >= (uint32_t)rfbEncodingQualityLevel0 &&\n\t\t\t    enc <= (uint32_t)rfbEncodingQualityLevel9 ) {\n\t\t    cl->tightQualityLevel = enc & 0x0F;\n\t\t    rfbLog(\"Using image quality level %d for client %s\\n\",\n\t\t\t   cl->tightQualityLevel, cl->host);\n\t\t} else\n#endif\n\t\t{\n\t\t\trfbExtensionData* e;\n\t\t\tfor(e = cl->extensions; e;) {\n\t\t\t\trfbExtensionData* next = e->next;\n\t\t\t\tif(e->extension->enablePseudoEncoding &&\n\t\t\t\t\te->extension->enablePseudoEncoding(cl,\n\t\t\t\t\t\t&e->data, (int)enc))\n\t\t\t\t\t/* ext handles this encoding */\n\t\t\t\t\tbreak;\n\t\t\t\te = next;\n\t\t\t}\n\t\t\tif(e == NULL) {\n\t\t\t\trfbBool handled = FALSE;\n\t\t\t\t/* if the pseudo encoding is not handled by the\n\t\t\t\t   enabled extensions, search through all\n\t\t\t\t   extensions. */\n\t\t\t\trfbProtocolExtension* e;\n\n\t\t\t\tfor(e = rfbGetExtensionIterator(); e;) {\n\t\t\t\t\tint* encs = e->pseudoEncodings;\n\t\t\t\t\twhile(encs && *encs!=0) {\n\t\t\t\t\t\tif(*encs==(int)enc) {\n\t\t\t\t\t\t\tvoid* data = NULL;\n\t\t\t\t\t\t\tif(!e->enablePseudoEncoding(cl, &data, (int)enc)) {\n\t\t\t\t\t\t\t\trfbLog(\"Installed extension pretends to handle pseudo encoding 0x%x, but does not!\\n\",(int)enc);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\trfbEnableExtension(cl, e, data);\n\t\t\t\t\t\t\t\thandled = TRUE;\n\t\t\t\t\t\t\t\te = NULL;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tencs++;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(e)\n\t\t\t\t\t\te = e->next;\n\t\t\t\t}\n\t\t\t\trfbReleaseExtensionIterator();\n\n\t\t\t\tif(!handled)\n\t\t\t\t\trfbLog(\"rfbProcessClientNormalMessage: \"\n\t\t\t\t\t    \"ignoring unsupported encoding type %s\\n\",\n\t\t\t\t\t    encodingName(enc,encBuf,sizeof(encBuf)));\n\t\t\t}\n\t\t}\n            }\n        }\n\n\n\n        if (cl->preferredEncoding == -1) {\n            if (lastPreferredEncoding==-1) {\n                cl->preferredEncoding = rfbEncodingRaw;\n                rfbLog(\"Defaulting to %s encoding for client %s\\n\", encodingName(cl->preferredEncoding,encBuf,sizeof(encBuf)),cl->host);\n            }\n            else {\n                cl->preferredEncoding = lastPreferredEncoding;\n                rfbLog(\"Sticking with %s encoding for client %s\\n\", encodingName(cl->preferredEncoding,encBuf,sizeof(encBuf)),cl->host);\n            }\n        }\n        else\n        {\n          if (lastPreferredEncoding==-1) {\n              rfbLog(\"Using %s encoding for client %s\\n\", encodingName(cl->preferredEncoding,encBuf,sizeof(encBuf)),cl->host);\n          } else {\n              rfbLog(\"Switching from %s to %s Encoding for client %s\\n\", \n                  encodingName(lastPreferredEncoding,encBuf2,sizeof(encBuf2)),\n                  encodingName(cl->preferredEncoding,encBuf,sizeof(encBuf)), cl->host);\n          }\n        }\n        \n\tif (cl->enableCursorPosUpdates && !cl->enableCursorShapeUpdates) {\n\t  rfbLog(\"Disabling cursor position updates for client %s\\n\",\n\t\t cl->host);\n\t  cl->enableCursorPosUpdates = FALSE;\n\t}\n\n        return;\n    }\n\n\n    case rfbFramebufferUpdateRequest:\n    {\n        sraRegionPtr tmpRegion;\n\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                           sz_rfbFramebufferUpdateRequestMsg-1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n\n        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbFramebufferUpdateRequestMsg,sz_rfbFramebufferUpdateRequestMsg);\n\n        /* The values come in based on the scaled screen, we need to convert them to\n         * values based on the main screen's coordinate system\n         */\n\tif(!rectSwapIfLEAndClip(&msg.fur.x,&msg.fur.y,&msg.fur.w,&msg.fur.h,cl))\n\t{\n\t        rfbLog(\"Warning, ignoring rfbFramebufferUpdateRequest: %dXx%dY-%dWx%dH\\n\",msg.fur.x, msg.fur.y, msg.fur.w, msg.fur.h);\n\t\treturn;\n        }\n \n        \n\ttmpRegion =\n\t  sraRgnCreateRect(msg.fur.x,\n\t\t\t   msg.fur.y,\n\t\t\t   msg.fur.x+msg.fur.w,\n\t\t\t   msg.fur.y+msg.fur.h);\n\n        LOCK(cl->updateMutex);\n\tsraRgnOr(cl->requestedRegion,tmpRegion);\n\n\tif (!cl->readyForSetColourMapEntries) {\n\t    /* client hasn't sent a SetPixelFormat so is using server's */\n\t    cl->readyForSetColourMapEntries = TRUE;\n\t    if (!cl->format.trueColour) {\n\t\tif (!rfbSetClientColourMap(cl, 0, 0)) {\n\t\t    sraRgnDestroy(tmpRegion);\n\t\t    UNLOCK(cl->updateMutex);\n\t\t    return;\n\t\t}\n\t    }\n\t}\n\n       if (!msg.fur.incremental) {\n\t    sraRgnOr(cl->modifiedRegion,tmpRegion);\n\t    sraRgnSubtract(cl->copyRegion,tmpRegion);\n       }\n       TSIGNAL(cl->updateCond);\n       UNLOCK(cl->updateMutex);\n\n       sraRgnDestroy(tmpRegion);\n\n       return;\n    }\n\n    case rfbKeyEvent:\n\n\tif ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n\t\t\t   sz_rfbKeyEventMsg - 1)) <= 0) {\n\t    if (n != 0)\n\t\trfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n\n\trfbStatRecordMessageRcvd(cl, msg.type, sz_rfbKeyEventMsg, sz_rfbKeyEventMsg);\n\n\tif(!cl->viewOnly) {\n\t    cl->screen->kbdAddEvent(msg.ke.down, (rfbKeySym)Swap32IfLE(msg.ke.key), cl);\n\t}\n\n        return;\n\n\n    case rfbPointerEvent:\n\n\tif ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n\t\t\t   sz_rfbPointerEventMsg - 1)) <= 0) {\n\t    if (n != 0)\n\t\trfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n\n\trfbStatRecordMessageRcvd(cl, msg.type, sz_rfbPointerEventMsg, sz_rfbPointerEventMsg);\n\t\n\tif (cl->screen->pointerClient && cl->screen->pointerClient != cl)\n\t    return;\n\n\tif (msg.pe.buttonMask == 0)\n\t    cl->screen->pointerClient = NULL;\n\telse\n\t    cl->screen->pointerClient = cl;\n\n\tif(!cl->viewOnly) {\n\t    if (msg.pe.buttonMask != cl->lastPtrButtons ||\n\t\t    cl->screen->deferPtrUpdateTime == 0) {\n\t\tcl->screen->ptrAddEvent(msg.pe.buttonMask,\n\t\t\tScaleX(cl->scaledScreen, cl->screen, Swap16IfLE(msg.pe.x)), \n\t\t\tScaleY(cl->scaledScreen, cl->screen, Swap16IfLE(msg.pe.y)),\n\t\t\tcl);\n\t\tcl->lastPtrButtons = msg.pe.buttonMask;\n\t    } else {\n\t\tcl->lastPtrX = ScaleX(cl->scaledScreen, cl->screen, Swap16IfLE(msg.pe.x));\n\t\tcl->lastPtrY = ScaleY(cl->scaledScreen, cl->screen, Swap16IfLE(msg.pe.y));\n\t\tcl->lastPtrButtons = msg.pe.buttonMask;\n\t    }\n      }      \n      return;\n\n\n    case rfbFileTransfer:\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                              sz_rfbFileTransferMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n        msg.ft.size         = Swap32IfLE(msg.ft.size);\n        msg.ft.length       = Swap32IfLE(msg.ft.length);\n        /* record statistics in rfbProcessFileTransfer as length is filled with garbage when it is not valid */\n        rfbProcessFileTransfer(cl, msg.ft.contentType, msg.ft.contentParam, msg.ft.size, msg.ft.length);\n        return;\n\n    case rfbSetSW:\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                              sz_rfbSetSWMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n        msg.sw.x = Swap16IfLE(msg.sw.x);\n        msg.sw.y = Swap16IfLE(msg.sw.y);\n        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetSWMsg, sz_rfbSetSWMsg);\n        /* msg.sw.status is not initialized in the ultraVNC viewer and contains random numbers (why???) */\n\n        rfbLog(\"Received a rfbSetSingleWindow(%d x, %d y)\\n\", msg.sw.x, msg.sw.y);\n        if (cl->screen->setSingleWindow!=NULL)\n            cl->screen->setSingleWindow(cl, msg.sw.x, msg.sw.y);\n        return;\n\n    case rfbSetServerInput:\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                              sz_rfbSetServerInputMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetServerInputMsg, sz_rfbSetServerInputMsg);\n\n        /* msg.sim.pad is not initialized in the ultraVNC viewer and contains random numbers (why???) */\n        /* msg.sim.pad = Swap16IfLE(msg.sim.pad); */\n\n        rfbLog(\"Received a rfbSetServerInput(%d status)\\n\", msg.sim.status);\n        if (cl->screen->setServerInput!=NULL)\n            cl->screen->setServerInput(cl, msg.sim.status);\n        return;\n        \n    case rfbTextChat:\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                              sz_rfbTextChatMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n        \n        msg.tc.pad2   = Swap16IfLE(msg.tc.pad2);\n        msg.tc.length = Swap32IfLE(msg.tc.length);\n\n        switch (msg.tc.length) {\n        case rfbTextChatOpen:\n        case rfbTextChatClose:\n        case rfbTextChatFinished:\n            /* commands do not have text following */\n            /* Why couldn't they have used the pad byte??? */\n            str=NULL;\n            rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbTextChatMsg, sz_rfbTextChatMsg);\n            break;\n        default:\n            if ((msg.tc.length>0) && (msg.tc.length<rfbTextMaxSize))\n            {\n                str = (char *)malloc(msg.tc.length);\n                if (str==NULL)\n                {\n                    rfbLog(\"Unable to malloc %d bytes for a TextChat Message\\n\", msg.tc.length);\n                    rfbCloseClient(cl);\n                    return;\n                }\n                if ((n = rfbReadExact(cl, str, msg.tc.length)) <= 0) {\n                    if (n != 0)\n                        rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n                    free(str);\n                    rfbCloseClient(cl);\n                    return;\n                }\n                rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbTextChatMsg+msg.tc.length, sz_rfbTextChatMsg+msg.tc.length);\n            }\n            else\n            {\n                /* This should never happen */\n                rfbLog(\"client sent us a Text Message that is too big %d>%d\\n\", msg.tc.length, rfbTextMaxSize);\n                rfbCloseClient(cl);\n                return;\n            }\n        }\n\n        /* Note: length can be commands: rfbTextChatOpen, rfbTextChatClose, and rfbTextChatFinished\n         * at which point, the str is NULL (as it is not sent)\n         */\n        if (cl->screen->setTextChat!=NULL)\n            cl->screen->setTextChat(cl, msg.tc.length, str);\n\n        free(str);\n        return;\n\n\n    case rfbClientCutText:\n\n\tif ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n\t\t\t   sz_rfbClientCutTextMsg - 1)) <= 0) {\n\t    if (n != 0)\n\t\trfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n\n\tmsg.cct.length = Swap32IfLE(msg.cct.length);\n\n\tstr = (char *)malloc(msg.cct.length);\n\n\tif ((n = rfbReadExact(cl, str, msg.cct.length)) <= 0) {\n\t    if (n != 0)\n\t        rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n\t    free(str);\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n\trfbStatRecordMessageRcvd(cl, msg.type, sz_rfbClientCutTextMsg+msg.cct.length, sz_rfbClientCutTextMsg+msg.cct.length);\n\tif(!cl->viewOnly) {\n\t    cl->screen->setXCutText(str, msg.cct.length, cl);\n\t}\n\tfree(str);\n\n        return;\n\n    case rfbPalmVNCSetScaleFactor:\n      cl->PalmVNC = TRUE;\n      if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n          sz_rfbSetScaleMsg - 1)) <= 0) {\n          if (n != 0)\n            rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n          rfbCloseClient(cl);\n          return;\n      }\n      rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetScaleMsg, sz_rfbSetScaleMsg);\n      rfbLog(\"rfbSetScale(%d)\\n\", msg.ssc.scale);\n      rfbScalingSetup(cl,cl->screen->width/msg.ssc.scale, cl->screen->height/msg.ssc.scale);\n\n      rfbSendNewScaleSize(cl);\n      return;\n      \n    case rfbSetScale:\n\n      if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n          sz_rfbSetScaleMsg - 1)) <= 0) {\n          if (n != 0)\n            rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n          rfbCloseClient(cl);\n          return;\n      }\n      rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetScaleMsg, sz_rfbSetScaleMsg);\n      rfbLog(\"rfbSetScale(%d)\\n\", msg.ssc.scale);\n      rfbScalingSetup(cl,cl->screen->width/msg.ssc.scale, cl->screen->height/msg.ssc.scale);\n\n      rfbSendNewScaleSize(cl);\n      return;\n\n    default:\n\t{\n\t    rfbExtensionData *e,*next;\n\n\t    for(e=cl->extensions; e;) {\n\t\tnext = e->next;\n\t\tif(e->extension->handleMessage &&\n\t\t\te->extension->handleMessage(cl, e->data, &msg))\n                {\n                    rfbStatRecordMessageRcvd(cl, msg.type, 0, 0); /* Extension should handle this */\n\t\t    return;\n                }\n\t\te = next;\n\t    }\n\n\t    rfbLog(\"rfbProcessClientNormalMessage: unknown message type %d\\n\",\n\t\t    msg.type);\n\t    rfbLog(\" ... closing connection\\n\");\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n    }\n}",
        "target": 1
    },
    {
        "func": "static void ZRLE_ENCODE (int x, int y, int w, int h,\n\t\t  zrleOutStream* os, void* buf\n                  EXTRA_ARGS\n                  )\n{\n  int ty;\n  for (ty = y; ty < y+h; ty += rfbZRLETileHeight) {\n    int tx, th = rfbZRLETileHeight;\n    if (th > y+h-ty) th = y+h-ty;\n    for (tx = x; tx < x+w; tx += rfbZRLETileWidth) {\n      int tw = rfbZRLETileWidth;\n      if (tw > x+w-tx) tw = x+w-tx;\n\n      GET_IMAGE_INTO_BUF(tx,ty,tw,th,buf);\n\n      ZRLE_ENCODE_TILE((PIXEL_T*)buf, tw, th, os,\n\t\t      cl->zywrleLevel, cl->zywrleBuf);\n    }\n  }\n  zrleOutStreamFlush(os);\n}",
        "target": 1
    },
    {
        "func": "rfbSendBell(rfbScreenInfoPtr rfbScreen)\n{\n    rfbClientIteratorPtr i;\n    rfbClientPtr cl;\n    rfbBellMsg b;\n\n    i = rfbGetClientIterator(rfbScreen);\n    while((cl=rfbClientIteratorNext(i))) {\n\tb.type = rfbBell;\n\tif (rfbWriteExact(cl, (char *)&b, sz_rfbBellMsg) < 0) {\n\t    rfbLogPerror(\"rfbSendBell: write\");\n\t    rfbCloseClient(cl);\n\t}\n    }\n    rfbStatRecordMessageSent(cl, rfbBell, sz_rfbBellMsg, sz_rfbBellMsg);\n    rfbReleaseClientIterator(i);\n}",
        "target": 1
    },
    {
        "func": "rfbBool rfbSendRectEncodingZRLE(rfbClientPtr cl, int x, int y, int w, int h)\n{\n  zrleOutStream* zos;\n  rfbFramebufferUpdateRectHeader rect;\n  rfbZRLEHeader hdr;\n  int i;\n\n  if (cl->preferredEncoding == rfbEncodingZYWRLE) {\n\t  if (cl->tightQualityLevel < 0) {\n\t\t  cl->zywrleLevel = 1;\n\t  } else if (cl->tightQualityLevel < 3) {\n\t\t  cl->zywrleLevel = 3;\n\t  } else if (cl->tightQualityLevel < 6) {\n\t\t  cl->zywrleLevel = 2;\n\t  } else {\n\t\t  cl->zywrleLevel = 1;\n\t  }\n  } else\n\t  cl->zywrleLevel = 0;\n\n  if (!cl->zrleData)\n    cl->zrleData = zrleOutStreamNew();\n  zos = cl->zrleData;\n  zos->in.ptr = zos->in.start;\n  zos->out.ptr = zos->out.start;\n\n  switch (cl->format.bitsPerPixel) {\n\n  case 8:\n    zrleEncode8NE(x, y, w, h, zos, zrleBeforeBuf, cl);\n    break;\n\n  case 16:\n\tif (cl->format.greenMax > 0x1F) {\n\t\tif (cl->format.bigEndian)\n\t\t  zrleEncode16BE(x, y, w, h, zos, zrleBeforeBuf, cl);\n\t\telse\n\t\t  zrleEncode16LE(x, y, w, h, zos, zrleBeforeBuf, cl);\n\t} else {\n\t\tif (cl->format.bigEndian)\n\t\t  zrleEncode15BE(x, y, w, h, zos, zrleBeforeBuf, cl);\n\t\telse\n\t\t  zrleEncode15LE(x, y, w, h, zos, zrleBeforeBuf, cl);\n\t}\n    break;\n\n  case 32: {\n    rfbBool fitsInLS3Bytes\n      = ((cl->format.redMax   << cl->format.redShift)   < (1<<24) &&\n         (cl->format.greenMax << cl->format.greenShift) < (1<<24) &&\n         (cl->format.blueMax  << cl->format.blueShift)  < (1<<24));\n\n    rfbBool fitsInMS3Bytes = (cl->format.redShift   > 7  &&\n                           cl->format.greenShift > 7  &&\n                           cl->format.blueShift  > 7);\n\n    if ((fitsInLS3Bytes && !cl->format.bigEndian) ||\n        (fitsInMS3Bytes && cl->format.bigEndian)) {\n\tif (cl->format.bigEndian)\n\t\tzrleEncode24ABE(x, y, w, h, zos, zrleBeforeBuf, cl);\n\telse\n\t\tzrleEncode24ALE(x, y, w, h, zos, zrleBeforeBuf, cl);\n    }\n    else if ((fitsInLS3Bytes && cl->format.bigEndian) ||\n             (fitsInMS3Bytes && !cl->format.bigEndian)) {\n\tif (cl->format.bigEndian)\n\t\tzrleEncode24BBE(x, y, w, h, zos, zrleBeforeBuf, cl);\n\telse\n\t\tzrleEncode24BLE(x, y, w, h, zos, zrleBeforeBuf, cl);\n    }\n    else {\n\tif (cl->format.bigEndian)\n\t\tzrleEncode32BE(x, y, w, h, zos, zrleBeforeBuf, cl);\n\telse\n\t\tzrleEncode32LE(x, y, w, h, zos, zrleBeforeBuf, cl);\n    }\n  }\n    break;\n  }\n\n  rfbStatRecordEncodingSent(cl, rfbEncodingZRLE, sz_rfbFramebufferUpdateRectHeader + sz_rfbZRLEHeader + ZRLE_BUFFER_LENGTH(&zos->out),\n      + w * (cl->format.bitsPerPixel / 8) * h);\n\n  if (cl->ublen + sz_rfbFramebufferUpdateRectHeader + sz_rfbZRLEHeader\n      > UPDATE_BUF_SIZE)\n    {\n      if (!rfbSendUpdateBuf(cl))\n        return FALSE;\n    }\n\n  rect.r.x = Swap16IfLE(x);\n  rect.r.y = Swap16IfLE(y);\n  rect.r.w = Swap16IfLE(w);\n  rect.r.h = Swap16IfLE(h);\n  rect.encoding = Swap32IfLE(cl->preferredEncoding);\n\n  memcpy(cl->updateBuf+cl->ublen, (char *)&rect,\n         sz_rfbFramebufferUpdateRectHeader);\n  cl->ublen += sz_rfbFramebufferUpdateRectHeader;\n\n  hdr.length = Swap32IfLE(ZRLE_BUFFER_LENGTH(&zos->out));\n\n  memcpy(cl->updateBuf+cl->ublen, (char *)&hdr, sz_rfbZRLEHeader);\n  cl->ublen += sz_rfbZRLEHeader;\n\n  /* copy into updateBuf and send from there.  Maybe should send directly? */\n\n  for (i = 0; i < ZRLE_BUFFER_LENGTH(&zos->out);) {\n\n    int bytesToCopy = UPDATE_BUF_SIZE - cl->ublen;\n\n    if (i + bytesToCopy > ZRLE_BUFFER_LENGTH(&zos->out)) {\n      bytesToCopy = ZRLE_BUFFER_LENGTH(&zos->out) - i;\n    }\n\n    memcpy(cl->updateBuf+cl->ublen, (uint8_t*)zos->out.start + i, bytesToCopy);\n\n    cl->ublen += bytesToCopy;\n    i += bytesToCopy;\n\n    if (cl->ublen == UPDATE_BUF_SIZE) {\n      if (!rfbSendUpdateBuf(cl))\n        return FALSE;\n    }\n  }\n\n  return TRUE;\n}",
        "target": 1
    },
    {
        "func": "rfbBool rfbProcessFileTransfer(rfbClientPtr cl, uint8_t contentType, uint8_t contentParam, uint32_t size, uint32_t length)\n{\n    char *buffer=NULL, *p=NULL;\n    int retval=0;\n    char filename1[MAX_PATH];\n    char filename2[MAX_PATH];\n    char szFileTime[MAX_PATH];\n    struct stat statbuf;\n    uint32_t sizeHtmp=0;\n    int n=0;\n    char timespec[64];\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n    unsigned char compBuff[sz_rfbBlockSize];\n    unsigned long nRawBytes = sz_rfbBlockSize;\n    int nRet = 0;\n#endif\n\n    FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN(\"\", cl, FALSE);\n        \n    /*\n    rfbLog(\"rfbProcessFileTransfer(%dtype, %dparam, %dsize, %dlen)\\n\", contentType, contentParam, size, length);\n    */\n\n    switch (contentType) {\n    case rfbDirContentRequest:\n        switch (contentParam) {\n        case rfbRDrivesList: /* Client requests the List of Local Drives */\n            /*\n            rfbLog(\"rfbProcessFileTransfer() rfbDirContentRequest: rfbRDrivesList:\\n\");\n            */\n            /* Format when filled : \"C:\\<NULL>D:\\<NULL>....Z:\\<NULL><NULL>\n             *\n             * We replace the \"\\\" char following the drive letter and \":\"\n             * with a char corresponding to the type of drive\n             * We obtain something like \"C:l<NULL>D:c<NULL>....Z:n\\<NULL><NULL>\"\n             *  Isn't it ugly ?\n             * DRIVE_FIXED = 'l'     (local?)\n             * DRIVE_REMOVABLE = 'f' (floppy?)\n             * DRIVE_CDROM = 'c'\n             * DRIVE_REMOTE = 'n'\n             */\n            \n            /* in unix, there are no 'drives'  (We could list mount points though)\n             * We fake the root as a \"C:\" for the Winblows users\n             */\n            filename2[0]='C';\n            filename2[1]=':';\n            filename2[2]='l';\n            filename2[3]=0;\n            filename2[4]=0;\n            retval = rfbSendFileTransferMessage(cl, rfbDirPacket, rfbADrivesList, 0, 5, filename2);\n            if (buffer!=NULL) free(buffer);\n            return retval;\n            break;\n        case rfbRDirContent: /* Client requests the content of a directory */\n            /*\n            rfbLog(\"rfbProcessFileTransfer() rfbDirContentRequest: rfbRDirContent\\n\");\n            */\n            if ((buffer = rfbProcessFileTransferReadBuffer(cl, length))==NULL) return FALSE;\n            retval = rfbSendDirContent(cl, length, buffer);\n            if (buffer!=NULL) free(buffer);\n            return retval;\n        }\n        break;\n\n    case rfbDirPacket:\n        rfbLog(\"rfbProcessFileTransfer() rfbDirPacket\\n\");\n        break;\n    case rfbFileAcceptHeader:\n        rfbLog(\"rfbProcessFileTransfer() rfbFileAcceptHeader\\n\");\n        break;\n    case rfbCommandReturn:\n        rfbLog(\"rfbProcessFileTransfer() rfbCommandReturn\\n\");\n        break;\n    case rfbFileChecksums:\n        /* Destination file already exists - the viewer sends the checksums */\n        rfbLog(\"rfbProcessFileTransfer() rfbFileChecksums\\n\");\n        break;\n    case rfbFileTransferAccess:\n        rfbLog(\"rfbProcessFileTransfer() rfbFileTransferAccess\\n\");\n        break;\n\n    /*\n     * sending from the server to the viewer\n     */\n\n    case rfbFileTransferRequest:\n        /*\n        rfbLog(\"rfbProcessFileTransfer() rfbFileTransferRequest:\\n\");\n        */\n        /* add some space to the end of the buffer as we will be adding a timespec to it */\n        if ((buffer = rfbProcessFileTransferReadBuffer(cl, length))==NULL) return FALSE;\n        /* The client requests a File */\n        rfbFilenameTranslate2UNIX(cl, buffer, filename1);\n        cl->fileTransfer.fd=open(filename1, O_RDONLY, 0744);\n\n        /*\n        */\n        if (DB) rfbLog(\"rfbProcessFileTransfer() rfbFileTransferRequest(\\\"%s\\\"->\\\"%s\\\") Open: %s fd=%d\\n\", buffer, filename1, (cl->fileTransfer.fd==-1?\"Failed\":\"Success\"), cl->fileTransfer.fd);\n        \n        if (cl->fileTransfer.fd!=-1) {\n            if (fstat(cl->fileTransfer.fd, &statbuf)!=0) {\n                close(cl->fileTransfer.fd);\n                cl->fileTransfer.fd=-1;\n            }\n            else\n            {\n              /* Add the File Time Stamp to the filename */\n              strftime(timespec, sizeof(timespec), \"%m/%d/%Y %H:%M\",gmtime(&statbuf.st_ctime));\n              buffer=realloc(buffer, length + strlen(timespec) + 2); /* comma, and Null term */\n              if (buffer==NULL) {\n                  rfbLog(\"rfbProcessFileTransfer() rfbFileTransferRequest: Failed to malloc %d bytes\\n\", length + strlen(timespec) + 2);\n                  return FALSE;\n              }\n              strcat(buffer,\",\");\n              strcat(buffer, timespec);\n              length = strlen(buffer);\n              if (DB) rfbLog(\"rfbProcessFileTransfer() buffer is now: \\\"%s\\\"\\n\", buffer);\n            }\n        }\n\n        /* The viewer supports compression if size==1 */\n        cl->fileTransfer.compressionEnabled = (size==1);\n\n        /*\n        rfbLog(\"rfbProcessFileTransfer() rfbFileTransferRequest(\\\"%s\\\"->\\\"%s\\\")%s\\n\", buffer, filename1, (size==1?\" <Compression Enabled>\":\"\"));\n        */\n\n        /* File Size in bytes, 0xFFFFFFFF (-1) means error */\n        retval = rfbSendFileTransferMessage(cl, rfbFileHeader, 0, (cl->fileTransfer.fd==-1 ? -1 : statbuf.st_size), length, buffer);\n\n        if (cl->fileTransfer.fd==-1)\n        {\n            if (buffer!=NULL) free(buffer);\n            return retval;\n        }\n        /* setup filetransfer stuff */\n        cl->fileTransfer.fileSize = statbuf.st_size;\n        cl->fileTransfer.numPackets = statbuf.st_size / sz_rfbBlockSize;\n        cl->fileTransfer.receiving = 0;\n        cl->fileTransfer.sending = 0; /* set when we receive a rfbFileHeader: */\n\n        /* TODO: finish 64-bit file size support */\n        sizeHtmp = 0;        \n        if (rfbWriteExact(cl, (char *)&sizeHtmp, 4) < 0) {\n          rfbLogPerror(\"rfbProcessFileTransfer: write\");\n          rfbCloseClient(cl);\n          if (buffer!=NULL) free(buffer);\n          return FALSE;\n        }\n        break;\n\n    case rfbFileHeader:\n        /* Destination file (viewer side) is ready for reception (size > 0) or not (size = -1) */\n        if (size==-1) {\n            rfbLog(\"rfbProcessFileTransfer() rfbFileHeader (error, aborting)\\n\");\n            close(cl->fileTransfer.fd);\n            cl->fileTransfer.fd=-1;\n            return TRUE;\n        }\n\n        /*\n        rfbLog(\"rfbProcessFileTransfer() rfbFileHeader (%d bytes of a file)\\n\", size);\n        */\n\n        /* Starts the transfer! */\n        cl->fileTransfer.sending=1;\n        return rfbSendFileTransferChunk(cl);\n        break;\n\n\n    /*\n     * sending from the viewer to the server\n     */\n\n    case rfbFileTransferOffer:\n        /* client is sending a file to us */\n        /* buffer contains full path name (plus FileTime) */\n        /* size contains size of the file */\n        /*\n        rfbLog(\"rfbProcessFileTransfer() rfbFileTransferOffer:\\n\");\n        */\n        if ((buffer = rfbProcessFileTransferReadBuffer(cl, length))==NULL) return FALSE;\n\n        /* Parse the FileTime */\n        p = strrchr(buffer, ',');\n        if (p!=NULL) {\n            *p = '\\0';\n            strcpy(szFileTime, p+1);\n        } else\n            szFileTime[0]=0;\n\n\n\n        /* Need to read in sizeHtmp */\n        if ((n = rfbReadExact(cl, (char *)&sizeHtmp, 4)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessFileTransfer: read sizeHtmp\");\n            rfbCloseClient(cl);\n            /* NOTE: don't forget to free(buffer) if you return early! */\n            if (buffer!=NULL) free(buffer);\n            return FALSE;\n        }\n        sizeHtmp = Swap32IfLE(sizeHtmp);\n        \n        rfbFilenameTranslate2UNIX(cl, buffer, filename1);\n\n        /* If the file exists... We can send a rfbFileChecksums back to the client before we send an rfbFileAcceptHeader */\n        /* TODO: Delta Transfer */\n\n        cl->fileTransfer.fd=open(filename1, O_CREAT|O_WRONLY|O_TRUNC, 0744);\n        if (DB) rfbLog(\"rfbProcessFileTransfer() rfbFileTransferOffer(\\\"%s\\\"->\\\"%s\\\") %s %s fd=%d\\n\", buffer, filename1, (cl->fileTransfer.fd==-1?\"Failed\":\"Success\"), (cl->fileTransfer.fd==-1?strerror(errno):\"\"), cl->fileTransfer.fd);\n        /*\n        */\n        \n        /* File Size in bytes, 0xFFFFFFFF (-1) means error */\n        retval = rfbSendFileTransferMessage(cl, rfbFileAcceptHeader, 0, (cl->fileTransfer.fd==-1 ? -1 : 0), length, buffer);\n        if (cl->fileTransfer.fd==-1) {\n            free(buffer);\n            return retval;\n        }\n        \n        /* setup filetransfer stuff */\n        cl->fileTransfer.fileSize = size;\n        cl->fileTransfer.numPackets = size / sz_rfbBlockSize;\n        cl->fileTransfer.receiving = 1;\n        cl->fileTransfer.sending = 0;\n        break;\n\n    case rfbFilePacket:\n        /*\n        rfbLog(\"rfbProcessFileTransfer() rfbFilePacket:\\n\");\n        */\n        if ((buffer = rfbProcessFileTransferReadBuffer(cl, length))==NULL) return FALSE;\n        if (cl->fileTransfer.fd!=-1) {\n            /* buffer contains the contents of the file */\n            if (size==0)\n                retval=write(cl->fileTransfer.fd, buffer, length);\n            else\n            {\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n                /* compressed packet */\n                nRet = uncompress(compBuff,&nRawBytes,(const unsigned char*)buffer, length);\n                retval=write(cl->fileTransfer.fd, compBuff, nRawBytes);\n#else\n                /* Write the file out as received... */\n                retval=write(cl->fileTransfer.fd, buffer, length);\n#endif\n            }\n            if (retval==-1)\n            {\n                close(cl->fileTransfer.fd);\n                cl->fileTransfer.fd=-1;\n                cl->fileTransfer.sending   = 0;\n                cl->fileTransfer.receiving = 0;\n            }\n        }\n        break;\n\n    case rfbEndOfFile:\n        if (DB) rfbLog(\"rfbProcessFileTransfer() rfbEndOfFile\\n\");\n        /*\n        */\n        if (cl->fileTransfer.fd!=-1)\n            close(cl->fileTransfer.fd);\n        cl->fileTransfer.fd=-1;\n        cl->fileTransfer.sending   = 0;\n        cl->fileTransfer.receiving = 0;\n        break;\n\n    case rfbAbortFileTransfer:\n        if (DB) rfbLog(\"rfbProcessFileTransfer() rfbAbortFileTransfer\\n\");\n        /*\n        */\n        if (cl->fileTransfer.fd!=-1)\n        {\n            close(cl->fileTransfer.fd);\n            cl->fileTransfer.fd=-1;\n            cl->fileTransfer.sending   = 0;\n            cl->fileTransfer.receiving = 0;\n        }\n        else\n        {\n            /* We use this message for FileTransfer rights (<=RC18 versions)\n             * The client asks for FileTransfer permission\n             */\n            if (contentParam == 0)\n            {\n                rfbLog(\"rfbProcessFileTransfer() File Transfer Permission DENIED! (Client Version <=RC18)\\n\");\n                /* Old method for FileTransfer handshake perimssion (<=RC18) (Deny it)*/\n                return rfbSendFileTransferMessage(cl, rfbAbortFileTransfer, 0, -1, 0, \"\");\n            }\n            /* New method is allowed */\n            if (cl->screen->getFileTransferPermission!=NULL)\n            {\n                if (cl->screen->getFileTransferPermission(cl)==TRUE)\n                {\n                    rfbLog(\"rfbProcessFileTransfer() File Transfer Permission Granted!\\n\");\n                    return rfbSendFileTransferMessage(cl, rfbFileTransferAccess, 0, 1 , 0, \"\"); /* Permit */\n                }\n                else\n                {\n                    rfbLog(\"rfbProcessFileTransfer() File Transfer Permission DENIED!\\n\");\n                    return rfbSendFileTransferMessage(cl, rfbFileTransferAccess, 0, -1 , 0, \"\"); /* Deny */\n                }\n            }\n            else\n            {\n                if (cl->screen->permitFileTransfer)\n                {\n                    rfbLog(\"rfbProcessFileTransfer() File Transfer Permission Granted!\\n\");\n                    return rfbSendFileTransferMessage(cl, rfbFileTransferAccess, 0, 1 , 0, \"\"); /* Permit */\n                }\n                else\n                {\n                    rfbLog(\"rfbProcessFileTransfer() File Transfer Permission DENIED by default!\\n\");\n                    return rfbSendFileTransferMessage(cl, rfbFileTransferAccess, 0, -1 , 0, \"\"); /* DEFAULT: DENY (for security) */\n                }\n                \n            }\n        }\n        break;\n\n\n    case rfbCommand:\n        /*\n        rfbLog(\"rfbProcessFileTransfer() rfbCommand:\\n\");\n        */\n        if ((buffer = rfbProcessFileTransferReadBuffer(cl, length))==NULL) return FALSE;\n        switch (contentParam) {\n        case rfbCDirCreate:  /* Client requests the creation of a directory */\n            rfbFilenameTranslate2UNIX(cl, buffer, filename1);\n            retval = mkdir(filename1, 0755);\n            if (DB) rfbLog(\"rfbProcessFileTransfer() rfbCommand: rfbCDirCreate(\\\"%s\\\"->\\\"%s\\\") %s\\n\", buffer, filename1, (retval==-1?\"Failed\":\"Success\"));\n            /*\n            */\n            retval = rfbSendFileTransferMessage(cl, rfbCommandReturn, rfbADirCreate, retval, length, buffer);\n            if (buffer!=NULL) free(buffer);\n            return retval;\n        case rfbCFileDelete: /* Client requests the deletion of a file */\n            rfbFilenameTranslate2UNIX(cl, buffer, filename1);\n            if (stat(filename1,&statbuf)==0)\n            {\n                if (S_ISDIR(statbuf.st_mode))\n                    retval = rmdir(filename1);\n                else\n                    retval = unlink(filename1);\n            }\n            else retval=-1;\n            retval = rfbSendFileTransferMessage(cl, rfbCommandReturn, rfbAFileDelete, retval, length, buffer);\n            if (buffer!=NULL) free(buffer);\n            return retval;\n        case rfbCFileRename: /* Client requests the Renaming of a file/directory */\n            p = strrchr(buffer, '*');\n            if (p != NULL)\n            {\n                /* Split into 2 filenames ('*' is a seperator) */\n                *p = '\\0';\n                rfbFilenameTranslate2UNIX(cl, buffer, filename1);\n                rfbFilenameTranslate2UNIX(cl, p+1,    filename2);\n                retval = rename(filename1,filename2);\n                if (DB) rfbLog(\"rfbProcessFileTransfer() rfbCommand: rfbCFileRename(\\\"%s\\\"->\\\"%s\\\" -->> \\\"%s\\\"->\\\"%s\\\") %s\\n\", buffer, filename1, p+1, filename2, (retval==-1?\"Failed\":\"Success\"));\n                /*\n                */\n                /* Restore the buffer so the reply is good */\n                *p = '*';\n                retval = rfbSendFileTransferMessage(cl, rfbCommandReturn, rfbAFileRename, retval, length, buffer);\n                if (buffer!=NULL) free(buffer);\n                return retval;\n            }\n            break;\n        }\n    \n        break;\n    }\n\n    /* NOTE: don't forget to free(buffer) if you return early! */\n    if (buffer!=NULL) free(buffer);\n    return TRUE;\n}",
        "target": 1
    },
    {
        "func": "clientOutput(void *data)\n{\n    rfbClientPtr cl = (rfbClientPtr)data;\n    rfbBool haveUpdate;\n    sraRegion* updateRegion;\n\n    while (1) {\n        haveUpdate = false;\n        while (!haveUpdate) {\n            if (cl->sock == -1) {\n                /* Client has disconnected. */\n                return NULL;\n            }\n\t    LOCK(cl->updateMutex);\n\t    haveUpdate = FB_UPDATE_PENDING(cl);\n\t    if(!haveUpdate) {\n\t\tupdateRegion = sraRgnCreateRgn(cl->modifiedRegion);\n\t\thaveUpdate = sraRgnAnd(updateRegion,cl->requestedRegion);\n\t\tsraRgnDestroy(updateRegion);\n\t    }\n\n            if (!haveUpdate) {\n                WAIT(cl->updateCond, cl->updateMutex);\n            }\n\t    UNLOCK(cl->updateMutex);\n        }\n        \n        /* OK, now, to save bandwidth, wait a little while for more\n           updates to come along. */\n        usleep(cl->screen->deferUpdateTime * 1000);\n\n        /* Now, get the region we're going to update, and remove\n           it from cl->modifiedRegion _before_ we send the update.\n           That way, if anything that overlaps the region we're sending\n           is updated, we'll be sure to do another update later. */\n        LOCK(cl->updateMutex);\n\tupdateRegion = sraRgnCreateRgn(cl->modifiedRegion);\n        UNLOCK(cl->updateMutex);\n\n        /* Now actually send the update. */\n\trfbIncrClientRef(cl);\n        rfbSendFramebufferUpdate(cl, updateRegion);\n\trfbDecrClientRef(cl);\n\n\tsraRgnDestroy(updateRegion);\n    }\n\n    /* Not reached. */\n    return NULL;\n}",
        "target": 1
    },
    {
        "func": "rfbSendServerCutText(rfbScreenInfoPtr rfbScreen,char *str, int len)\n{\n    rfbClientPtr cl;\n    rfbServerCutTextMsg sct;\n    rfbClientIteratorPtr iterator;\n\n    iterator = rfbGetClientIterator(rfbScreen);\n    while ((cl = rfbClientIteratorNext(iterator)) != NULL) {\n        sct.type = rfbServerCutText;\n        sct.length = Swap32IfLE(len);\n        if (rfbWriteExact(cl, (char *)&sct,\n                       sz_rfbServerCutTextMsg) < 0) {\n            rfbLogPerror(\"rfbSendServerCutText: write\");\n            rfbCloseClient(cl);\n            continue;\n        }\n        if (rfbWriteExact(cl, str, len) < 0) {\n            rfbLogPerror(\"rfbSendServerCutText: write\");\n            rfbCloseClient(cl);\n        }\n        rfbStatRecordMessageSent(cl, rfbServerCutText, sz_rfbServerCutTextMsg+len, sz_rfbServerCutTextMsg+len);\n    }\n    rfbReleaseClientIterator(iterator);\n}",
        "target": 1
    },
    {
        "func": "void ZRLE_ENCODE_TILE(PIXEL_T* data, int w, int h, zrleOutStream* os,\n\tint zywrle_level, int *zywrleBuf)\n{\n  /* First find the palette and the number of runs */\n\n  zrlePaletteHelper *ph;\n\n  int runs = 0;\n  int singlePixels = 0;\n\n  rfbBool useRle;\n  rfbBool usePalette;\n\n  int estimatedBytes;\n  int plainRleBytes;\n  int i;\n\n  PIXEL_T* ptr = data;\n  PIXEL_T* end = ptr + h * w;\n  *end = ~*(end-1); /* one past the end is different so the while loop ends */\n\n  ph = &paletteHelper;\n  zrlePaletteHelperInit(ph);\n\n  while (ptr < end) {\n    PIXEL_T pix = *ptr;\n    if (*++ptr != pix) {\n      singlePixels++;\n    } else {\n      while (*++ptr == pix) ;\n      runs++;\n    }\n    zrlePaletteHelperInsert(ph, pix);\n  }\n\n  /* Solid tile is a special case */\n\n  if (ph->size == 1) {\n    zrleOutStreamWriteU8(os, 1);\n    zrleOutStreamWRITE_PIXEL(os, ph->palette[0]);\n    return;\n  }\n\n  /* Try to work out whether to use RLE and/or a palette.  We do this by\n     estimating the number of bytes which will be generated and picking the\n     method which results in the fewest bytes.  Of course this may not result\n     in the fewest bytes after compression... */\n\n  useRle = FALSE;\n  usePalette = FALSE;\n\n  estimatedBytes = w * h * (BPPOUT/8); /* start assuming raw */\n\n#if BPP!=8\n  if (zywrle_level > 0 && !(zywrle_level & 0x80))\n\t  estimatedBytes >>= zywrle_level;\n#endif\n\n  plainRleBytes = ((BPPOUT/8)+1) * (runs + singlePixels);\n\n  if (plainRleBytes < estimatedBytes) {\n    useRle = TRUE;\n    estimatedBytes = plainRleBytes;\n  }\n\n  if (ph->size < 128) {\n    int paletteRleBytes = (BPPOUT/8) * ph->size + 2 * runs + singlePixels;\n\n    if (paletteRleBytes < estimatedBytes) {\n      useRle = TRUE;\n      usePalette = TRUE;\n      estimatedBytes = paletteRleBytes;\n    }\n\n    if (ph->size < 17) {\n      int packedBytes = ((BPPOUT/8) * ph->size +\n                         w * h * bitsPerPackedPixel[ph->size-1] / 8);\n\n      if (packedBytes < estimatedBytes) {\n        useRle = FALSE;\n        usePalette = TRUE;\n        estimatedBytes = packedBytes;\n      }\n    }\n  }\n\n  if (!usePalette) ph->size = 0;\n\n  zrleOutStreamWriteU8(os, (useRle ? 128 : 0) | ph->size);\n\n  for (i = 0; i < ph->size; i++) {\n    zrleOutStreamWRITE_PIXEL(os, ph->palette[i]);\n  }\n\n  if (useRle) {\n\n    PIXEL_T* ptr = data;\n    PIXEL_T* end = ptr + w * h;\n    PIXEL_T* runStart;\n    PIXEL_T pix;\n    while (ptr < end) {\n      int len;\n      runStart = ptr;\n      pix = *ptr++;\n      while (*ptr == pix && ptr < end)\n        ptr++;\n      len = ptr - runStart;\n      if (len <= 2 && usePalette) {\n        int index = zrlePaletteHelperLookup(ph, pix);\n        if (len == 2)\n          zrleOutStreamWriteU8(os, index);\n        zrleOutStreamWriteU8(os, index);\n        continue;\n      }\n      if (usePalette) {\n        int index = zrlePaletteHelperLookup(ph, pix);\n        zrleOutStreamWriteU8(os, index | 128);\n      } else {\n        zrleOutStreamWRITE_PIXEL(os, pix);\n      }\n      len -= 1;\n      while (len >= 255) {\n        zrleOutStreamWriteU8(os, 255);\n        len -= 255;\n      }\n      zrleOutStreamWriteU8(os, len);\n    }\n\n  } else {\n\n    /* no RLE */\n\n    if (usePalette) {\n      int bppp;\n      PIXEL_T* ptr = data;\n\n      /* packed pixels */\n\n      assert (ph->size < 17);\n\n      bppp = bitsPerPackedPixel[ph->size-1];\n\n      for (i = 0; i < h; i++) {\n        zrle_U8 nbits = 0;\n        zrle_U8 byte = 0;\n\n        PIXEL_T* eol = ptr + w;\n\n        while (ptr < eol) {\n          PIXEL_T pix = *ptr++;\n          zrle_U8 index = zrlePaletteHelperLookup(ph, pix);\n          byte = (byte << bppp) | index;\n          nbits += bppp;\n          if (nbits >= 8) {\n            zrleOutStreamWriteU8(os, byte);\n            nbits = 0;\n          }\n        }\n        if (nbits > 0) {\n          byte <<= 8 - nbits;\n          zrleOutStreamWriteU8(os, byte);\n        }\n      }\n    } else {\n\n      /* raw */\n\n#if BPP!=8\n      if (zywrle_level > 0 && !(zywrle_level & 0x80)) {\n        ZYWRLE_ANALYZE(data, data, w, h, w, zywrle_level, zywrleBuf);\n\tZRLE_ENCODE_TILE(data, w, h, os, zywrle_level | 0x80, zywrleBuf);\n      }\n      else\n#endif\n      {\n#ifdef CPIXEL\n        PIXEL_T *ptr;\n        for (ptr = data; ptr < data+w*h; ptr++)\n          zrleOutStreamWRITE_PIXEL(os, *ptr);\n#else\n        zrleOutStreamWriteBytes(os, (zrle_U8 *)data, w*h*(BPP/8));\n#endif\n      }\n    }\n  }\n}",
        "target": 1
    },
    {
        "func": "rfbSendAuthCaps(rfbClientPtr cl)\n{\n    rfbAuthenticationCapsMsg caps;\n    rfbCapabilityInfo caplist[MAX_AUTH_CAPS];\n    int count = 0;\n    rfbTightClientPtr rtcp = rfbGetTightClientData(cl);\n\n    rfbLog(\"tightvnc-filetransfer/rfbSendAuthCaps\\n\");\n\n    if(rtcp == NULL)\n\treturn;\n\n    if (cl->screen->authPasswdData && !cl->reverseConnection) {\n\t/* chk if this condition is valid or not. */\n\t    SetCapInfo(&caplist[count], rfbAuthVNC, rfbStandardVendor);\n\t    rtcp->authCaps[count++] = rfbAuthVNC;\n    }\n\n    rtcp->nAuthCaps = count;\n    caps.nAuthTypes = Swap32IfLE((uint32_t)count);\n    if (rfbWriteExact(cl, (char *)&caps, sz_rfbAuthenticationCapsMsg) < 0) {\n\trfbLogPerror(\"rfbSendAuthCaps: write\");\n\trfbCloseClient(cl);\n\treturn;\n    }\n\n    if (count) {\n\tif (rfbWriteExact(cl, (char *)&caplist[0],\n\t\t       count * sz_rfbCapabilityInfo) < 0) {\n\t    rfbLogPerror(\"rfbSendAuthCaps: write\");\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n\t/* Dispatch client input to rfbProcessClientAuthType. */\n\t/* Call the function for authentication from here */\n\trfbProcessClientAuthType(cl);\n    } else {\n\t/* Dispatch client input to rfbProcessClientInitMessage. */\n\tcl->state = RFB_INITIALISATION;\n    }\n}",
        "target": 1
    },
    {
        "func": "void rfbFreeZrleData(rfbClientPtr cl)\n{\n  if (cl->zrleData)\n    zrleOutStreamFree(cl->zrleData);\n  cl->zrleData = NULL;\n}",
        "target": 1
    },
    {
        "func": "rfbBool rfbSendFileTransferMessage(rfbClientPtr cl, uint8_t contentType, uint8_t contentParam, uint32_t size, uint32_t length, char *buffer)\n{\n    rfbFileTransferMsg ft;\n    ft.type = rfbFileTransfer;\n    ft.contentType = contentType;\n    ft.contentParam = contentParam;\n    ft.pad          = 0; /* UltraVNC did not Swap16LE(ft.contentParam) (Looks like it might be BigEndian) */\n    ft.size         = Swap32IfLE(size);\n    ft.length       = Swap32IfLE(length);\n    \n    FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN(\"\", cl, FALSE);\n    /*\n    rfbLog(\"rfbSendFileTransferMessage( %dtype, %dparam, %dsize, %dlen, %p)\\n\", contentType, contentParam, size, length, buffer);\n    */\n    if (rfbWriteExact(cl, (char *)&ft, sz_rfbFileTransferMsg) < 0) {\n        rfbLogPerror(\"rfbSendFileTransferMessage: write\");\n        rfbCloseClient(cl);\n        return FALSE;\n    }\n\n    if (length>0)\n    {\n        if (rfbWriteExact(cl, buffer, length) < 0) {\n            rfbLogPerror(\"rfbSendFileTransferMessage: write\");\n            rfbCloseClient(cl);\n            return FALSE;\n        }\n    }\n\n    rfbStatRecordMessageSent(cl, rfbFileTransfer, sz_rfbFileTransferMsg+length, sz_rfbFileTransferMsg+length);\n\n    return TRUE;\n}",
        "target": 1
    },
    {
        "func": "rfbProcessClientAuthType(rfbClientPtr cl)\n{\n    uint32_t auth_type;\n    int n, i;\n    rfbTightClientPtr rtcp = rfbGetTightClientData(cl);\n\n    rfbLog(\"tightvnc-filetransfer/rfbProcessClientAuthType\\n\");\n\n    if(rtcp == NULL)\n\treturn;\n\n    /* Read authentication type selected by the client. */\n    n = rfbReadExact(cl, (char *)&auth_type, sizeof(auth_type));\n    if (n <= 0) {\n\tif (n == 0)\n\t    rfbLog(\"rfbProcessClientAuthType: client gone\\n\");\n\telse\n\t    rfbLogPerror(\"rfbProcessClientAuthType: read\");\n\trfbCloseClient(cl);\n\treturn;\n    }\n    auth_type = Swap32IfLE(auth_type);\n\n    /* Make sure it was present in the list sent by the server. */\n    for (i = 0; i < rtcp->nAuthCaps; i++) {\n\tif (auth_type == rtcp->authCaps[i])\n\t    break;\n    }\n    if (i >= rtcp->nAuthCaps) {\n\trfbLog(\"rfbProcessClientAuthType: \"\n\t       \"wrong authentication type requested\\n\");\n\trfbCloseClient(cl);\n\treturn;\n    }\n\n    switch (auth_type) {\n    case rfbAuthNone:\n\t/* Dispatch client input to rfbProcessClientInitMessage. */\n\tcl->state = RFB_INITIALISATION;\n\tbreak;\n    case rfbAuthVNC:\n\trfbVncAuthSendChallenge(cl);\n\tbreak;\n    default:\n\trfbLog(\"rfbProcessClientAuthType: unknown authentication scheme\\n\");\n\trfbCloseClient(cl);\n    }\n}",
        "target": 1
    },
    {
        "func": "rfbSendSetColourMapEntries(rfbClientPtr cl,\n                           int firstColour,\n                           int nColours)\n{\n    char buf[sz_rfbSetColourMapEntriesMsg + 256 * 3 * 2];\n    char *wbuf = buf;\n    rfbSetColourMapEntriesMsg *scme;\n    uint16_t *rgb;\n    rfbColourMap* cm = &cl->screen->colourMap;\n    int i, len;\n\n    if (nColours > 256) {\n\t/* some rare hardware has, e.g., 4096 colors cells: PseudoColor:12 */\n    \twbuf = (char *) malloc(sz_rfbSetColourMapEntriesMsg + nColours * 3 * 2);\n    }\n\n    scme = (rfbSetColourMapEntriesMsg *)wbuf;\n    rgb = (uint16_t *)(&wbuf[sz_rfbSetColourMapEntriesMsg]);\n\n    scme->type = rfbSetColourMapEntries;\n\n    scme->firstColour = Swap16IfLE(firstColour);\n    scme->nColours = Swap16IfLE(nColours);\n\n    len = sz_rfbSetColourMapEntriesMsg;\n\n    for (i = 0; i < nColours; i++) {\n      if(i<(int)cm->count) {\n\tif(cm->is16) {\n\t  rgb[i*3] = Swap16IfLE(cm->data.shorts[i*3]);\n\t  rgb[i*3+1] = Swap16IfLE(cm->data.shorts[i*3+1]);\n\t  rgb[i*3+2] = Swap16IfLE(cm->data.shorts[i*3+2]);\n\t} else {\n\t  rgb[i*3] = Swap16IfLE((unsigned short)cm->data.bytes[i*3]);\n\t  rgb[i*3+1] = Swap16IfLE((unsigned short)cm->data.bytes[i*3+1]);\n\t  rgb[i*3+2] = Swap16IfLE((unsigned short)cm->data.bytes[i*3+2]);\n\t}\n      }\n    }\n\n    len += nColours * 3 * 2;\n\n    if (rfbWriteExact(cl, wbuf, len) < 0) {\n\trfbLogPerror(\"rfbSendSetColourMapEntries: write\");\n\trfbCloseClient(cl);\n        if (wbuf != buf) free(wbuf);\n\treturn FALSE;\n    }\n\n    rfbStatRecordMessageSent(cl, rfbSetColourMapEntries, len, len);\n    if (wbuf != buf) free(wbuf);\n    return TRUE;\n}",
        "target": 1
    },
    {
        "func": "xmlXPathNodeSetAddNs(xmlNodeSetPtr cur, xmlNodePtr node, xmlNsPtr ns) {\n    int i;\n\n\n    if ((cur == NULL) || (ns == NULL) || (node == NULL) ||\n        (ns->type != XML_NAMESPACE_DECL) ||\n\t(node->type != XML_ELEMENT_NODE))\n\treturn;\n\n    /* @@ with_ns to check whether namespace nodes should be looked at @@ */\n    /*\n     * prevent duplicates\n     */\n    for (i = 0;i < cur->nodeNr;i++) {\n        if ((cur->nodeTab[i] != NULL) &&\n\t    (cur->nodeTab[i]->type == XML_NAMESPACE_DECL) &&\n\t    (((xmlNsPtr)cur->nodeTab[i])->next == (xmlNsPtr) node) &&\n\t    (xmlStrEqual(ns->prefix, ((xmlNsPtr)cur->nodeTab[i])->prefix)))\n\t    return;\n    }\n\n    /*\n     * grow the nodeTab if needed\n     */\n    if (cur->nodeMax == 0) {\n        cur->nodeTab = (xmlNodePtr *) xmlMalloc(XML_NODESET_DEFAULT *\n\t\t\t\t\t     sizeof(xmlNodePtr));\n\tif (cur->nodeTab == NULL) {\n\t    xmlXPathErrMemory(NULL, \"growing nodeset\\n\");\n\t    return;\n\t}\n\tmemset(cur->nodeTab, 0 ,\n\t       XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));\n        cur->nodeMax = XML_NODESET_DEFAULT;\n    } else if (cur->nodeNr == cur->nodeMax) {\n        xmlNodePtr *temp;\n\n        cur->nodeMax *= 2;\n\ttemp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax *\n\t\t\t\t      sizeof(xmlNodePtr));\n\tif (temp == NULL) {\n\t    xmlXPathErrMemory(NULL, \"growing nodeset\\n\");\n\t    return;\n\t}\n\tcur->nodeTab = temp;\n    }\n    cur->nodeTab[cur->nodeNr++] = xmlXPathNodeSetDupNs(node, ns);\n}",
        "target": 1
    },
    {
        "func": "xmlXPathNodeSetMerge(xmlNodeSetPtr val1, xmlNodeSetPtr val2) {\n    int i, j, initNr, skip;\n    xmlNodePtr n1, n2;\n\n    if (val2 == NULL) return(val1);\n    if (val1 == NULL) {\n\tval1 = xmlXPathNodeSetCreate(NULL);\n    if (val1 == NULL)\n        return (NULL);\n#if 0\n\t/*\n\t* TODO: The optimization won't work in every case, since\n\t*  those nasty namespace nodes need to be added with\n\t*  xmlXPathNodeSetDupNs() to the set; thus a pure\n\t*  memcpy is not possible.\n\t*  If there was a flag on the nodesetval, indicating that\n\t*  some temporary nodes are in, that would be helpfull.\n\t*/\n\t/*\n\t* Optimization: Create an equally sized node-set\n\t* and memcpy the content.\n\t*/\n\tval1 = xmlXPathNodeSetCreateSize(val2->nodeNr);\n\tif (val1 == NULL)\n\t    return(NULL);\n\tif (val2->nodeNr != 0) {\n\t    if (val2->nodeNr == 1)\n\t\t*(val1->nodeTab) = *(val2->nodeTab);\n\t    else {\n\t\tmemcpy(val1->nodeTab, val2->nodeTab,\n\t\t    val2->nodeNr * sizeof(xmlNodePtr));\n\t    }\n\t    val1->nodeNr = val2->nodeNr;\n\t}\n\treturn(val1);\n#endif\n    }\n\n    /* @@ with_ns to check whether namespace nodes should be looked at @@ */\n    initNr = val1->nodeNr;\n\n    for (i = 0;i < val2->nodeNr;i++) {\n\tn2 = val2->nodeTab[i];\n\t/*\n\t * check against duplicates\n\t */\n\tskip = 0;\n\tfor (j = 0; j < initNr; j++) {\n\t    n1 = val1->nodeTab[j];\n\t    if (n1 == n2) {\n\t\tskip = 1;\n\t\tbreak;\n\t    } else if ((n1->type == XML_NAMESPACE_DECL) &&\n\t\t       (n2->type == XML_NAMESPACE_DECL)) {\n\t\tif ((((xmlNsPtr) n1)->next == ((xmlNsPtr) n2)->next) &&\n\t\t    (xmlStrEqual(((xmlNsPtr) n1)->prefix,\n\t\t\t((xmlNsPtr) n2)->prefix)))\n\t\t{\n\t\t    skip = 1;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\tif (skip)\n\t    continue;\n\n\t/*\n\t * grow the nodeTab if needed\n\t */\n\tif (val1->nodeMax == 0) {\n\t    val1->nodeTab = (xmlNodePtr *) xmlMalloc(XML_NODESET_DEFAULT *\n\t\t\t\t\t\t    sizeof(xmlNodePtr));\n\t    if (val1->nodeTab == NULL) {\n\t        xmlXPathErrMemory(NULL, \"merging nodeset\\n\");\n\t\treturn(NULL);\n\t    }\n\t    memset(val1->nodeTab, 0 ,\n\t\t   XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));\n\t    val1->nodeMax = XML_NODESET_DEFAULT;\n\t} else if (val1->nodeNr == val1->nodeMax) {\n\t    xmlNodePtr *temp;\n\n\t    val1->nodeMax *= 2;\n\t    temp = (xmlNodePtr *) xmlRealloc(val1->nodeTab, val1->nodeMax *\n\t\t\t\t\t     sizeof(xmlNodePtr));\n\t    if (temp == NULL) {\n\t        xmlXPathErrMemory(NULL, \"merging nodeset\\n\");\n\t\treturn(NULL);\n\t    }\n\t    val1->nodeTab = temp;\n\t}\n\tif (n2->type == XML_NAMESPACE_DECL) {\n\t    xmlNsPtr ns = (xmlNsPtr) n2;\n\n\t    val1->nodeTab[val1->nodeNr++] =\n\t\txmlXPathNodeSetDupNs((xmlNodePtr) ns->next, ns);\n\t} else\n\t    val1->nodeTab[val1->nodeNr++] = n2;\n    }\n\n    return(val1);\n}",
        "target": 1
    },
    {
        "func": "xmlXPathNodeSetAddUnique(xmlNodeSetPtr cur, xmlNodePtr val) {\n    if ((cur == NULL) || (val == NULL)) return;\n\n#if 0\n    if ((val->type == XML_ELEMENT_NODE) && (val->name[0] == ' '))\n\treturn;\t/* an XSLT fake node */\n#endif\n\n    /* @@ with_ns to check whether namespace nodes should be looked at @@ */\n    /*\n     * grow the nodeTab if needed\n     */\n    if (cur->nodeMax == 0) {\n        cur->nodeTab = (xmlNodePtr *) xmlMalloc(XML_NODESET_DEFAULT *\n\t\t\t\t\t     sizeof(xmlNodePtr));\n\tif (cur->nodeTab == NULL) {\n\t    xmlXPathErrMemory(NULL, \"growing nodeset\\n\");\n\t    return;\n\t}\n\tmemset(cur->nodeTab, 0 ,\n\t       XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));\n        cur->nodeMax = XML_NODESET_DEFAULT;\n    } else if (cur->nodeNr == cur->nodeMax) {\n        xmlNodePtr *temp;\n\n        cur->nodeMax *= 2;\n\ttemp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax *\n\t\t\t\t      sizeof(xmlNodePtr));\n\tif (temp == NULL) {\n\t    xmlXPathErrMemory(NULL, \"growing nodeset\\n\");\n\t    return;\n\t}\n\tcur->nodeTab = temp;\n    }\n    if (val->type == XML_NAMESPACE_DECL) {\n\txmlNsPtr ns = (xmlNsPtr) val;\n\n\tcur->nodeTab[cur->nodeNr++] =\n\t    xmlXPathNodeSetDupNs((xmlNodePtr) ns->next, ns);\n    } else\n\tcur->nodeTab[cur->nodeNr++] = val;\n}",
        "target": 1
    },
    {
        "func": "xmlXPathNodeSetMergeAndClearNoDupls(xmlNodeSetPtr set1, xmlNodeSetPtr set2,\n\t\t\t\t    int hasNullEntries)\n{\n    if (set2 == NULL)\n\treturn(set1);\n    if ((set1 == NULL) && (hasNullEntries == 0)) {\n\t/*\n\t* Note that doing a memcpy of the list, namespace nodes are\n\t* just assigned to set1, since set2 is cleared anyway.\n\t*/\n\tset1 = xmlXPathNodeSetCreateSize(set2->nodeNr);\n\tif (set1 == NULL)\n\t    return(NULL);\n\tif (set2->nodeNr != 0) {\n\t    memcpy(set1->nodeTab, set2->nodeTab,\n\t\tset2->nodeNr * sizeof(xmlNodePtr));\n\t    set1->nodeNr = set2->nodeNr;\n\t}\n    } else {\n\tint i;\n\txmlNodePtr n2;\n\n\tif (set1 == NULL)\n\t    set1 = xmlXPathNodeSetCreate(NULL);\n        if (set1 == NULL)\n            return (NULL);\n\n\tfor (i = 0;i < set2->nodeNr;i++) {\n\t    n2 = set2->nodeTab[i];\n\t    /*\n\t    * Skip NULLed entries.\n\t    */\n\t    if (n2 == NULL)\n\t\tcontinue;\n\t    if (set1->nodeMax == 0) {\n\t\tset1->nodeTab = (xmlNodePtr *) xmlMalloc(\n\t\t    XML_NODESET_DEFAULT * sizeof(xmlNodePtr));\n\t\tif (set1->nodeTab == NULL) {\n\t\t    xmlXPathErrMemory(NULL, \"merging nodeset\\n\");\n\t\t    return(NULL);\n\t\t}\n\t\tmemset(set1->nodeTab, 0,\n\t\t    XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));\n\t\tset1->nodeMax = XML_NODESET_DEFAULT;\n\t    } else if (set1->nodeNr >= set1->nodeMax) {\n\t\txmlNodePtr *temp;\n\n\t\tset1->nodeMax *= 2;\n\t\ttemp = (xmlNodePtr *) xmlRealloc(\n\t\t    set1->nodeTab, set1->nodeMax * sizeof(xmlNodePtr));\n\t\tif (temp == NULL) {\n\t\t    xmlXPathErrMemory(NULL, \"merging nodeset\\n\");\n\t\t    return(NULL);\n\t\t}\n\t\tset1->nodeTab = temp;\n\t    }\n\t    set1->nodeTab[set1->nodeNr++] = n2;\n\t}\n    }\n    set2->nodeNr = 0;\n    return(set1);\n}",
        "target": 1
    },
    {
        "func": "xmlXPathNodeSetMergeAndClear(xmlNodeSetPtr set1, xmlNodeSetPtr set2,\n\t\t\t     int hasNullEntries)\n{\n    if ((set1 == NULL) && (hasNullEntries == 0)) {\n\t/*\n\t* Note that doing a memcpy of the list, namespace nodes are\n\t* just assigned to set1, since set2 is cleared anyway.\n\t*/\n\tset1 = xmlXPathNodeSetCreateSize(set2->nodeNr);\n\tif (set1 == NULL)\n\t    return(NULL);\n\tif (set2->nodeNr != 0) {\n\t    memcpy(set1->nodeTab, set2->nodeTab,\n\t\tset2->nodeNr * sizeof(xmlNodePtr));\n\t    set1->nodeNr = set2->nodeNr;\n\t}\n    } else {\n\tint i, j, initNbSet1;\n\txmlNodePtr n1, n2;\n\n\tif (set1 == NULL)\n            set1 = xmlXPathNodeSetCreate(NULL);\n        if (set1 == NULL)\n            return (NULL);\n\n\tinitNbSet1 = set1->nodeNr;\n\tfor (i = 0;i < set2->nodeNr;i++) {\n\t    n2 = set2->nodeTab[i];\n\t    /*\n\t    * Skip NULLed entries.\n\t    */\n\t    if (n2 == NULL)\n\t\tcontinue;\n\t    /*\n\t    * Skip duplicates.\n\t    */\n\t    for (j = 0; j < initNbSet1; j++) {\n\t\tn1 = set1->nodeTab[j];\n\t\tif (n1 == n2) {\n\t\t    goto skip_node;\n\t\t} else if ((n1->type == XML_NAMESPACE_DECL) &&\n\t\t    (n2->type == XML_NAMESPACE_DECL))\n\t\t{\n\t\t    if ((((xmlNsPtr) n1)->next == ((xmlNsPtr) n2)->next) &&\n\t\t\t(xmlStrEqual(((xmlNsPtr) n1)->prefix,\n\t\t\t((xmlNsPtr) n2)->prefix)))\n\t\t    {\n\t\t\t/*\n\t\t\t* Free the namespace node.\n\t\t\t*/\n\t\t\tset2->nodeTab[i] = NULL;\n\t\t\txmlXPathNodeSetFreeNs((xmlNsPtr) n2);\n\t\t\tgoto skip_node;\n\t\t    }\n\t\t}\n\t    }\n\t    /*\n\t    * grow the nodeTab if needed\n\t    */\n\t    if (set1->nodeMax == 0) {\n\t\tset1->nodeTab = (xmlNodePtr *) xmlMalloc(\n\t\t    XML_NODESET_DEFAULT * sizeof(xmlNodePtr));\n\t\tif (set1->nodeTab == NULL) {\n\t\t    xmlXPathErrMemory(NULL, \"merging nodeset\\n\");\n\t\t    return(NULL);\n\t\t}\n\t\tmemset(set1->nodeTab, 0,\n\t\t    XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));\n\t\tset1->nodeMax = XML_NODESET_DEFAULT;\n\t    } else if (set1->nodeNr >= set1->nodeMax) {\n\t\txmlNodePtr *temp;\n\n\t\tset1->nodeMax *= 2;\n\t\ttemp = (xmlNodePtr *) xmlRealloc(\n\t\t    set1->nodeTab, set1->nodeMax * sizeof(xmlNodePtr));\n\t\tif (temp == NULL) {\n\t\t    xmlXPathErrMemory(NULL, \"merging nodeset\\n\");\n\t\t    return(NULL);\n\t\t}\n\t\tset1->nodeTab = temp;\n\t    }\n\t    if (n2->type == XML_NAMESPACE_DECL) {\n\t\txmlNsPtr ns = (xmlNsPtr) n2;\n\n\t\tset1->nodeTab[set1->nodeNr++] =\n\t\t    xmlXPathNodeSetDupNs((xmlNodePtr) ns->next, ns);\n\t    } else\n\t\tset1->nodeTab[set1->nodeNr++] = n2;\nskip_node:\n\t    {}\n\t}\n    }\n    set2->nodeNr = 0;\n    return(set1);\n}",
        "target": 1
    },
    {
        "func": "struct hfs_btree *hfs_btree_open(struct super_block *sb, u32 id, btree_keycmp keycmp)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_btree_header_rec *head;\n\tstruct address_space *mapping;\n\tstruct page *page;\n\tunsigned int size;\n\n\ttree = kzalloc(sizeof(*tree), GFP_KERNEL);\n\tif (!tree)\n\t\treturn NULL;\n\n\tmutex_init(&tree->tree_lock);\n\tspin_lock_init(&tree->hash_lock);\n\t/* Set the correct compare function */\n\ttree->sb = sb;\n\ttree->cnid = id;\n\ttree->keycmp = keycmp;\n\n\ttree->inode = iget_locked(sb, id);\n\tif (!tree->inode)\n\t\tgoto free_tree;\n\tBUG_ON(!(tree->inode->i_state & I_NEW));\n\t{\n\tstruct hfs_mdb *mdb = HFS_SB(sb)->mdb;\n\tHFS_I(tree->inode)->flags = 0;\n\tmutex_init(&HFS_I(tree->inode)->extents_lock);\n\tswitch (id) {\n\tcase HFS_EXT_CNID:\n\t\thfs_inode_read_fork(tree->inode, mdb->drXTExtRec, mdb->drXTFlSize,\n\t\t\t\t    mdb->drXTFlSize, be32_to_cpu(mdb->drXTClpSiz));\n\t\ttree->inode->i_mapping->a_ops = &hfs_btree_aops;\n\t\tbreak;\n\tcase HFS_CAT_CNID:\n\t\thfs_inode_read_fork(tree->inode, mdb->drCTExtRec, mdb->drCTFlSize,\n\t\t\t\t    mdb->drCTFlSize, be32_to_cpu(mdb->drCTClpSiz));\n\t\ttree->inode->i_mapping->a_ops = &hfs_btree_aops;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\t}\n\tunlock_new_inode(tree->inode);\n\n\tif (!HFS_I(tree->inode)->first_blocks) {\n\t\tprintk(KERN_ERR \"hfs: invalid btree extent records (0 size).\\n\");\n\t\tgoto free_inode;\n\t}\n\n\tmapping = tree->inode->i_mapping;\n\tpage = read_mapping_page(mapping, 0, NULL);\n\tif (IS_ERR(page))\n\t\tgoto free_inode;\n\n\t/* Load the header */\n\thead = (struct hfs_btree_header_rec *)(kmap(page) + sizeof(struct hfs_bnode_desc));\n\ttree->root = be32_to_cpu(head->root);\n\ttree->leaf_count = be32_to_cpu(head->leaf_count);\n\ttree->leaf_head = be32_to_cpu(head->leaf_head);\n\ttree->leaf_tail = be32_to_cpu(head->leaf_tail);\n\ttree->node_count = be32_to_cpu(head->node_count);\n\ttree->free_nodes = be32_to_cpu(head->free_nodes);\n\ttree->attributes = be32_to_cpu(head->attributes);\n\ttree->node_size = be16_to_cpu(head->node_size);\n\ttree->max_key_len = be16_to_cpu(head->max_key_len);\n\ttree->depth = be16_to_cpu(head->depth);\n\n\tsize = tree->node_size;\n\tif (!is_power_of_2(size))\n\t\tgoto fail_page;\n\tif (!tree->node_count)\n\t\tgoto fail_page;\n\tswitch (id) {\n\tcase HFS_EXT_CNID:\n\t\tif (tree->max_key_len != HFS_MAX_EXT_KEYLEN) {\n\t\t\tprintk(KERN_ERR \"hfs: invalid extent max_key_len %d\\n\",\n\t\t\t\ttree->max_key_len);\n\t\t\tgoto fail_page;\n\t\t}\n\t\tbreak;\n\tcase HFS_CAT_CNID:\n\t\tif (tree->max_key_len != HFS_MAX_CAT_KEYLEN) {\n\t\t\tprintk(KERN_ERR \"hfs: invalid catalog max_key_len %d\\n\",\n\t\t\t\ttree->max_key_len);\n\t\t\tgoto fail_page;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\ttree->node_size_shift = ffs(size) - 1;\n\ttree->pages_per_bnode = (tree->node_size + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;\n\n\tkunmap(page);\n\tpage_cache_release(page);\n\treturn tree;\n\nfail_page:\n\tpage_cache_release(page);\nfree_inode:\n\ttree->inode->i_mapping->a_ops = &hfs_aops;\n\tiput(tree->inode);\nfree_tree:\n\tkfree(tree);\n\treturn NULL;\n}",
        "target": 1
    },
    {
        "func": "gdk_pixbuf__gif_image_load (FILE *file, GError **error)\n{\n\tGifContext *context;\n\tGdkPixbuf *pixbuf;\n\n\tg_return_val_if_fail (file != NULL, NULL);\n\n\tcontext = new_context ();\n\n        if (context == NULL) {\n                g_set_error_literal (error,\n                                     GDK_PIXBUF_ERROR,\n                                     GDK_PIXBUF_ERROR_INSUFFICIENT_MEMORY,\n                                     _(\"Not enough memory to load GIF file\"));\n                return NULL;\n        }\n        \n\tcontext->file = file;\n        context->error = error;\n        context->stop_after_first_frame = TRUE;\n\n\tif (gif_main_loop (context) == -1 || context->animation->frames == NULL) {\n                if (context->error && *(context->error) == NULL)\n                        g_set_error_literal (context->error,\n                                             GDK_PIXBUF_ERROR,\n                                             GDK_PIXBUF_ERROR_CORRUPT_IMAGE,\n                                             _(\"GIF file was missing some data (perhaps it was truncated somehow?)\"));\n        }\n        \n        pixbuf = gdk_pixbuf_animation_get_static_image (GDK_PIXBUF_ANIMATION (context->animation));\n\n        if (pixbuf)\n                g_object_ref (pixbuf);\n\n        g_object_unref (context->animation);\n        \n        g_free (context->buf);\n\tg_free (context);\n \n\treturn pixbuf;\n}",
        "target": 1
    },
    {
        "func": "const char *string_of_NPPVariable(int variable)\n{\n  const char *str;\n\n  switch (variable) {\n#define _(VAL) case VAL: str = #VAL; break;\n\t_(NPPVpluginNameString);\n\t_(NPPVpluginDescriptionString);\n\t_(NPPVpluginWindowBool);\n\t_(NPPVpluginTransparentBool);\n\t_(NPPVjavaClass);\n\t_(NPPVpluginWindowSize);\n\t_(NPPVpluginTimerInterval);\n\t_(NPPVpluginScriptableInstance);\n\t_(NPPVpluginScriptableIID);\n\t_(NPPVjavascriptPushCallerBool);\n\t_(NPPVpluginKeepLibraryInMemory);\n\t_(NPPVpluginNeedsXEmbed);\n\t_(NPPVpluginScriptableNPObject);\n\t_(NPPVformValue);\n#undef _\n  default:\n\tswitch (variable & 0xff) {\n#define _(VAL, VAR) case VAL: str = #VAR; break\n\t  _(10, NPPVpluginScriptableInstance);\n#undef _\n\tdefault:\n\t  str = \"<unknown variable>\";\n\t  break;\n\t}\n\tbreak;\n  }\n\n  return str;\n}",
        "target": 1
    },
    {
        "func": "const char *string_of_NPNVariable(int variable)\n{\n  const char *str;\n\n  switch (variable) {\n#define _(VAL) case VAL: str = #VAL; break;\n\t_(NPNVxDisplay);\n\t_(NPNVxtAppContext);\n\t_(NPNVnetscapeWindow);\n\t_(NPNVjavascriptEnabledBool);\n\t_(NPNVasdEnabledBool);\n\t_(NPNVisOfflineBool);\n\t_(NPNVserviceManager);\n\t_(NPNVDOMElement);\n\t_(NPNVDOMWindow);\n\t_(NPNVToolkit);\n\t_(NPNVSupportsXEmbedBool);\n\t_(NPNVWindowNPObject);\n\t_(NPNVPluginElementNPObject);\n\t_(NPNVSupportsWindowless);\n#undef _\n  default:\n\tswitch (variable & 0xff) {\n#define _(VAL, VAR) case VAL: str = #VAR; break\n\t  _(10, NPNVserviceManager);\n\t  _(11, NPNVDOMElement);\n\t  _(12, NPNVDOMWindow);\n\t  _(13, NPNVToolkit);\n#undef _\n\tdefault:\n\t  str = \"<unknown variable>\";\n\t  break;\n\t}\n\tbreak;\n  }\n\n  return str;\n}",
        "target": 1
    },
    {
        "func": "g_NPN_GetValue(NPP instance, NPNVariable variable, void *value)\n{\n  D(bug(\"NPN_GetValue instance=%p, variable=%d [%s]\\n\", instance, variable, string_of_NPNVariable(variable)));\n\n  if (!thread_check()) {\n\tnpw_printf(\"WARNING: NPN_GetValue not called from the main thread\\n\");\n\treturn NPERR_INVALID_INSTANCE_ERROR;\n  }\n\n  PluginInstance *plugin = NULL;\n  if (instance)\n\tplugin = PLUGIN_INSTANCE(instance);\n\n  switch (variable) {\n  case NPNVxDisplay:\n\t*(void **)value = x_display;\n\tbreak;\n  case NPNVxtAppContext:\n\t*(void **)value = XtDisplayToApplicationContext(x_display);\n\tbreak;\n  case NPNVToolkit:\n\t*(NPNToolkitType *)value = NPW_TOOLKIT;\n\tbreak;\n#if USE_XPCOM\n  case NPNVserviceManager: {\n\tnsIServiceManager *sm;\n\tint ret = NS_GetServiceManager(&sm);\n\tif (NS_FAILED(ret)) {\n\t  npw_printf(\"WARNING: NS_GetServiceManager failed\\n\");\n\t  return NPERR_GENERIC_ERROR;\n\t}\n\t*(nsIServiceManager **)value = sm;\n\tbreak;\n  }\n  case NPNVDOMWindow:\n  case NPNVDOMElement:\n\tnpw_printf(\"WARNING: %s is not supported by NPN_GetValue()\\n\", string_of_NPNVariable(variable));\n\treturn NPERR_INVALID_PARAM;\n#endif\n  case NPNVnetscapeWindow:\n\tif (plugin == NULL) {\n\t  npw_printf(\"ERROR: NPNVnetscapeWindow requires a non NULL instance\\n\");\n\t  return NPERR_INVALID_INSTANCE_ERROR;\n\t}\n\tif (plugin->browser_toplevel == NULL) {\n\t  GdkNativeWindow netscape_xid = None;\n\t  NPError error = g_NPN_GetValue_real(instance, variable, &netscape_xid);\n\t  if (error != NPERR_NO_ERROR)\n\t\treturn error;\n\t  if (netscape_xid == None)\n\t\treturn NPERR_GENERIC_ERROR;\n\t  plugin->browser_toplevel = gdk_window_foreign_new(netscape_xid);\n\t  if (plugin->browser_toplevel == NULL)\n\t\treturn NPERR_GENERIC_ERROR;\n\t}\n\t*((GdkNativeWindow *)value) = GDK_WINDOW_XWINDOW(plugin->browser_toplevel);\n\tbreak;\n#if ALLOW_WINDOWLESS_PLUGINS\n  case NPNVSupportsWindowless:\n#endif\n  case NPNVSupportsXEmbedBool:\n  case NPNVWindowNPObject:\n  case NPNVPluginElementNPObject:\n\treturn g_NPN_GetValue_real(instance, variable, value);\n  default:\n\tswitch (variable & 0xff) {\n\tcase 13: /* NPNVToolkit */\n\t  if (NPW_TOOLKIT == NPNVGtk2) {\n\t\t// Gtk2 does not need to depend on a specific C++ ABI\n\t\t*(NPNToolkitType *)value = NPW_TOOLKIT;\n\t\treturn NPERR_NO_ERROR;\n\t  }\n\t  break;\n\t}\n\tD(bug(\"WARNING: unhandled variable %d (%s) in NPN_GetValue()\\n\", variable, string_of_NPNVariable(variable)));\n\treturn NPERR_INVALID_PARAM;\n  }\n\n  return NPERR_NO_ERROR;\n}",
        "target": 1
    },
    {
        "func": "int rpc_type_of_NPPVariable(int variable)\n{\n  int type;\n  switch (variable) {\n  case NPPVpluginNameString:\n  case NPPVpluginDescriptionString:\n  case NPPVformValue: // byte values of 0 does not appear in the UTF-8 encoding but for U+0000\n\ttype = RPC_TYPE_STRING;\n\tbreak;\n  case NPPVpluginWindowSize:\n  case NPPVpluginTimerInterval:\n\ttype = RPC_TYPE_INT32;\n\tbreak;\n  case NPPVpluginNeedsXEmbed:\n  case NPPVpluginWindowBool:\n  case NPPVpluginTransparentBool:\n  case NPPVjavascriptPushCallerBool:\n  case NPPVpluginKeepLibraryInMemory:\n\ttype = RPC_TYPE_BOOLEAN;\n\tbreak;\n  case NPPVpluginScriptableNPObject:\n\ttype = RPC_TYPE_NP_OBJECT;\n\tbreak;\n  default:\n\ttype = RPC_ERROR_GENERIC;\n\tbreak;\n  }\n  return type;\n}",
        "target": 1
    },
    {
        "func": "int rpc_type_of_NPNVariable(int variable)\n{\n  int type;\n  switch (variable) {\n  case NPNVjavascriptEnabledBool:\n  case NPNVasdEnabledBool:\n  case NPNVisOfflineBool:\n  case NPNVSupportsXEmbedBool:\n  case NPNVSupportsWindowless:\n\ttype = RPC_TYPE_BOOLEAN;\n\tbreak;\n  case NPNVToolkit:\n  case NPNVnetscapeWindow:\n\ttype = RPC_TYPE_UINT32;\n\tbreak;\n  case NPNVWindowNPObject:\n  case NPNVPluginElementNPObject:\n\ttype = RPC_TYPE_NP_OBJECT;\n\tbreak;\n  default:\n\ttype = RPC_ERROR_GENERIC;\n\tbreak;\n  }\n  return type;\n}",
        "target": 1
    },
    {
        "func": "xmlCharEncFirstLineInt(xmlCharEncodingHandler *handler, xmlBufferPtr out,\n                       xmlBufferPtr in, int len) {\n    int ret = -2;\n    int written;\n    int toconv;\n\n    if (handler == NULL) return(-1);\n    if (out == NULL) return(-1);\n    if (in == NULL) return(-1);\n\n    /* calculate space available */\n    written = out->size - out->use;\n    toconv = in->use;\n    /*\n     * echo '<?xml version=\"1.0\" encoding=\"UCS4\"?>' | wc -c => 38\n     * 45 chars should be sufficient to reach the end of the encoding\n     * declaration without going too far inside the document content.\n     * on UTF-16 this means 90bytes, on UCS4 this means 180\n     * The actual value depending on guessed encoding is passed as @len\n     * if provided\n     */\n    if (len >= 0) {\n        if (toconv > len)\n            toconv = len;\n    } else {\n        if (toconv > 180)\n            toconv = 180;\n    }\n    if (toconv * 2 >= written) {\n        xmlBufferGrow(out, toconv);\n\twritten = out->size - out->use - 1;\n    }\n\n    if (handler->input != NULL) {\n\tret = handler->input(&out->content[out->use], &written,\n\t                     in->content, &toconv);\n\txmlBufferShrink(in, toconv);\n\tout->use += written;\n\tout->content[out->use] = 0;\n    }\n#ifdef LIBXML_ICONV_ENABLED\n    else if (handler->iconv_in != NULL) {\n\tret = xmlIconvWrapper(handler->iconv_in, &out->content[out->use],\n\t                      &written, in->content, &toconv);\n\txmlBufferShrink(in, toconv);\n\tout->use += written;\n\tout->content[out->use] = 0;\n\tif (ret == -1) ret = -3;\n    }\n#endif /* LIBXML_ICONV_ENABLED */\n#ifdef LIBXML_ICU_ENABLED\n    else if (handler->uconv_in != NULL) {\n\tret = xmlUconvWrapper(handler->uconv_in, 1, &out->content[out->use],\n\t                      &written, in->content, &toconv);\n\txmlBufferShrink(in, toconv);\n\tout->use += written;\n\tout->content[out->use] = 0;\n\tif (ret == -1) ret = -3;\n    }\n#endif /* LIBXML_ICU_ENABLED */\n#ifdef DEBUG_ENCODING\n    switch (ret) {\n        case 0:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"converted %d bytes to %d bytes of input\\n\",\n\t            toconv, written);\n\t    break;\n        case -1:\n\t    xmlGenericError(xmlGenericErrorContext,\"converted %d bytes to %d bytes of input, %d left\\n\",\n\t            toconv, written, in->use);\n\t    break;\n        case -2:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"input conversion failed due to input error\\n\");\n\t    break;\n        case -3:\n\t    xmlGenericError(xmlGenericErrorContext,\"converted %d bytes to %d bytes of input, %d left\\n\",\n\t            toconv, written, in->use);\n\t    break;\n\tdefault:\n\t    xmlGenericError(xmlGenericErrorContext,\"Unknown input conversion failed %d\\n\", ret);\n    }\n#endif /* DEBUG_ENCODING */\n    /*\n     * Ignore when input buffer is not on a boundary\n     */\n    if (ret == -3) ret = 0;\n    if (ret == -1) ret = 0;\n    return(ret);\n}",
        "target": 1
    },
    {
        "func": "xmlCharEncInFunc(xmlCharEncodingHandler * handler, xmlBufferPtr out,\n                 xmlBufferPtr in)\n{\n    int ret = -2;\n    int written;\n    int toconv;\n\n    if (handler == NULL)\n        return (-1);\n    if (out == NULL)\n        return (-1);\n    if (in == NULL)\n        return (-1);\n\n    toconv = in->use;\n    if (toconv == 0)\n        return (0);\n    written = out->size - out->use;\n    if (toconv * 2 >= written) {\n        xmlBufferGrow(out, out->size + toconv * 2);\n        written = out->size - out->use - 1;\n    }\n    if (handler->input != NULL) {\n        ret = handler->input(&out->content[out->use], &written,\n                             in->content, &toconv);\n        xmlBufferShrink(in, toconv);\n        out->use += written;\n        out->content[out->use] = 0;\n    }\n#ifdef LIBXML_ICONV_ENABLED\n    else if (handler->iconv_in != NULL) {\n        ret = xmlIconvWrapper(handler->iconv_in, &out->content[out->use],\n                              &written, in->content, &toconv);\n        xmlBufferShrink(in, toconv);\n        out->use += written;\n        out->content[out->use] = 0;\n        if (ret == -1)\n            ret = -3;\n    }\n#endif /* LIBXML_ICONV_ENABLED */\n#ifdef LIBXML_ICU_ENABLED\n    else if (handler->uconv_in != NULL) {\n        ret = xmlUconvWrapper(handler->uconv_in, 1, &out->content[out->use],\n                              &written, in->content, &toconv);\n        xmlBufferShrink(in, toconv);\n        out->use += written;\n        out->content[out->use] = 0;\n        if (ret == -1)\n            ret = -3;\n    }\n#endif /* LIBXML_ICU_ENABLED */\n    switch (ret) {\n        case 0:\n#ifdef DEBUG_ENCODING\n            xmlGenericError(xmlGenericErrorContext,\n                            \"converted %d bytes to %d bytes of input\\n\",\n                            toconv, written);\n#endif\n            break;\n        case -1:\n#ifdef DEBUG_ENCODING\n            xmlGenericError(xmlGenericErrorContext,\n                         \"converted %d bytes to %d bytes of input, %d left\\n\",\n                            toconv, written, in->use);\n#endif\n            break;\n        case -3:\n#ifdef DEBUG_ENCODING\n            xmlGenericError(xmlGenericErrorContext,\n                        \"converted %d bytes to %d bytes of input, %d left\\n\",\n                            toconv, written, in->use);\n#endif\n            break;\n        case -2: {\n            char buf[50];\n\n\t    snprintf(&buf[0], 49, \"0x%02X 0x%02X 0x%02X 0x%02X\",\n\t\t     in->content[0], in->content[1],\n\t\t     in->content[2], in->content[3]);\n\t    buf[49] = 0;\n\t    xmlEncodingErr(XML_I18N_CONV_FAILED,\n\t\t    \"input conversion failed due to input error, bytes %s\\n\",\n\t\t           buf);\n        }\n    }\n    /*\n     * Ignore when input buffer is not on a boundary\n     */\n    if (ret == -3)\n        ret = 0;\n    return (written? written : ret);\n}",
        "target": 1
    },
    {
        "func": "static char **fill_envp(struct dhcp_packet *packet)\n{\n\tint envc;\n\tint i;\n\tchar **envp, **curr;\n\tconst char *opt_name;\n\tuint8_t *temp;\n\tuint8_t overload = 0;\n\n#define BITMAP unsigned\n#define BBITS (sizeof(BITMAP) * 8)\n#define BMASK(i) (1 << (i & (sizeof(BITMAP) * 8 - 1)))\n#define FOUND_OPTS(i) (found_opts[(unsigned)i / BBITS])\n\tBITMAP found_opts[256 / BBITS];\n\n\tmemset(found_opts, 0, sizeof(found_opts));\n\n\t/* We need 6 elements for:\n\t * \"interface=IFACE\"\n\t * \"ip=N.N.N.N\" from packet->yiaddr\n\t * \"siaddr=IP\" from packet->siaddr_nip (unless 0)\n\t * \"boot_file=FILE\" from packet->file (unless overloaded)\n\t * \"sname=SERVER_HOSTNAME\" from packet->sname (unless overloaded)\n\t * terminating NULL\n\t */\n\tenvc = 6;\n\t/* +1 element for each option, +2 for subnet option: */\n\tif (packet) {\n\t\t/* note: do not search for \"pad\" (0) and \"end\" (255) options */\n\t\tfor (i = 1; i < 255; i++) {\n\t\t\ttemp = udhcp_get_option(packet, i);\n\t\t\tif (temp) {\n\t\t\t\tif (i == DHCP_OPTION_OVERLOAD)\n\t\t\t\t\toverload = *temp;\n\t\t\t\telse if (i == DHCP_SUBNET)\n\t\t\t\t\tenvc++; /* for $mask */\n\t\t\t\tenvc++;\n\t\t\t\t/*if (i != DHCP_MESSAGE_TYPE)*/\n\t\t\t\tFOUND_OPTS(i) |= BMASK(i);\n\t\t\t}\n\t\t}\n\t}\n\tcurr = envp = xzalloc(sizeof(envp[0]) * envc);\n\n\t*curr = xasprintf(\"interface=%s\", client_config.interface);\n\tputenv(*curr++);\n\n\tif (!packet)\n\t\treturn envp;\n\n\t/* Export BOOTP fields. Fields we don't (yet?) export:\n\t * uint8_t op;      // always BOOTREPLY\n\t * uint8_t htype;   // hardware address type. 1 = 10mb ethernet\n\t * uint8_t hlen;    // hardware address length\n\t * uint8_t hops;    // used by relay agents only\n\t * uint32_t xid;\n\t * uint16_t secs;   // elapsed since client began acquisition/renewal\n\t * uint16_t flags;  // only one flag so far: bcast. Never set by server\n\t * uint32_t ciaddr; // client IP (usually == yiaddr. can it be different\n\t *                  // if during renew server wants to give us differn IP?)\n\t * uint32_t gateway_nip; // relay agent IP address\n\t * uint8_t chaddr[16]; // link-layer client hardware address (MAC)\n\t * TODO: export gateway_nip as $giaddr?\n\t */\n\t/* Most important one: yiaddr as $ip */\n\t*curr = xmalloc(sizeof(\"ip=255.255.255.255\"));\n\tsprint_nip(*curr, \"ip=\", (uint8_t *) &packet->yiaddr);\n\tputenv(*curr++);\n\tif (packet->siaddr_nip) {\n\t\t/* IP address of next server to use in bootstrap */\n\t\t*curr = xmalloc(sizeof(\"siaddr=255.255.255.255\"));\n\t\tsprint_nip(*curr, \"siaddr=\", (uint8_t *) &packet->siaddr_nip);\n\t\tputenv(*curr++);\n\t}\n\tif (!(overload & FILE_FIELD) && packet->file[0]) {\n\t\t/* watch out for invalid packets */\n\t\t*curr = xasprintf(\"boot_file=%.\"DHCP_PKT_FILE_LEN_STR\"s\", packet->file);\n\t\tputenv(*curr++);\n\t}\n\tif (!(overload & SNAME_FIELD) && packet->sname[0]) {\n\t\t/* watch out for invalid packets */\n\t\t*curr = xasprintf(\"sname=%.\"DHCP_PKT_SNAME_LEN_STR\"s\", packet->sname);\n\t\tputenv(*curr++);\n\t}\n\n\t/* Export known DHCP options */\n\topt_name = dhcp_option_strings;\n\ti = 0;\n\twhile (*opt_name) {\n\t\tuint8_t code = dhcp_optflags[i].code;\n\t\tBITMAP *found_ptr = &FOUND_OPTS(code);\n\t\tBITMAP found_mask = BMASK(code);\n\t\tif (!(*found_ptr & found_mask))\n\t\t\tgoto next;\n\t\t*found_ptr &= ~found_mask; /* leave only unknown options */\n\t\ttemp = udhcp_get_option(packet, code);\n\t\t*curr = xmalloc_optname_optval(temp, &dhcp_optflags[i], opt_name);\n\t\tputenv(*curr++);\n\t\tif (code == DHCP_SUBNET) {\n\t\t\t/* Subnet option: make things like \"$ip/$mask\" possible */\n\t\t\tuint32_t subnet;\n\t\t\tmove_from_unaligned32(subnet, temp);\n\t\t\t*curr = xasprintf(\"mask=%u\", mton(subnet));\n\t\t\tputenv(*curr++);\n\t\t}\n next:\n\t\topt_name += strlen(opt_name) + 1;\n\t\ti++;\n\t}\n\t/* Export unknown options */\n\tfor (i = 0; i < 256;) {\n\t\tBITMAP bitmap = FOUND_OPTS(i);\n\t\tif (!bitmap) {\n\t\t\ti += BBITS;\n\t\t\tcontinue;\n\t\t}\n\t\tif (bitmap & BMASK(i)) {\n\t\t\tunsigned len, ofs;\n\n\t\t\ttemp = udhcp_get_option(packet, i);\n\t\t\t/* udhcp_get_option returns ptr to data portion,\n\t\t\t * need to go back to get len\n\t\t\t */\n\t\t\tlen = temp[-OPT_DATA + OPT_LEN];\n\t\t\t*curr = xmalloc(sizeof(\"optNNN=\") + 1 + len*2);\n\t\t\tofs = sprintf(*curr, \"opt%u=\", i);\n\t\t\t*bin2hex(*curr + ofs, (void*) temp, len) = '\\0';\n\t\t\tputenv(*curr++);\n\t\t}\n\t\ti++;\n\t}\n\n\treturn envp;\n}",
        "target": 1
    },
    {
        "func": "static NOINLINE char *xmalloc_optname_optval(uint8_t *option, const struct dhcp_optflag *optflag, const char *opt_name)\n{\n\tunsigned upper_length;\n\tint len, type, optlen;\n\tchar *dest, *ret;\n\n\t/* option points to OPT_DATA, need to go back to get OPT_LEN */\n\tlen = option[-OPT_DATA + OPT_LEN];\n\n\ttype = optflag->flags & OPTION_TYPE_MASK;\n\toptlen = dhcp_option_lengths[type];\n\tupper_length = len_of_option_as_string[type]\n\t\t* ((unsigned)(len + optlen - 1) / (unsigned)optlen);\n\n\tdest = ret = xmalloc(upper_length + strlen(opt_name) + 2);\n\tdest += sprintf(ret, \"%s=\", opt_name);\n\n\twhile (len >= optlen) {\n\t\tswitch (type) {\n\t\tcase OPTION_IP:\n\t\tcase OPTION_IP_PAIR:\n\t\t\tdest += sprint_nip(dest, \"\", option);\n\t\t\tif (type == OPTION_IP)\n\t\t\t\tbreak;\n\t\t\tdest += sprint_nip(dest, \"/\", option + 4);\n\t\t\tbreak;\n//\t\tcase OPTION_BOOLEAN:\n//\t\t\tdest += sprintf(dest, *option ? \"yes\" : \"no\");\n//\t\t\tbreak;\n\t\tcase OPTION_U8:\n\t\t\tdest += sprintf(dest, \"%u\", *option);\n\t\t\tbreak;\n//\t\tcase OPTION_S16:\n\t\tcase OPTION_U16: {\n\t\t\tuint16_t val_u16;\n\t\t\tmove_from_unaligned16(val_u16, option);\n\t\t\tdest += sprintf(dest, \"%u\", ntohs(val_u16));\n\t\t\tbreak;\n\t\t}\n\t\tcase OPTION_S32:\n\t\tcase OPTION_U32: {\n\t\t\tuint32_t val_u32;\n\t\t\tmove_from_unaligned32(val_u32, option);\n\t\t\tdest += sprintf(dest, type == OPTION_U32 ? \"%lu\" : \"%ld\", (unsigned long) ntohl(val_u32));\n\t\t\tbreak;\n\t\t}\n\t\t/* Note: options which use 'return' instead of 'break'\n\t\t * (for example, OPTION_STRING) skip the code which handles\n\t\t * the case of list of options.\n\t\t */\n\t\tcase OPTION_STRING:\n\t\t\tmemcpy(dest, option, len);\n\t\t\tdest[len] = '\\0';\n\t\t\treturn ret;\n\t\tcase OPTION_STATIC_ROUTES: {\n\t\t\t/* Option binary format:\n\t\t\t * mask [one byte, 0..32]\n\t\t\t * ip [big endian, 0..4 bytes depending on mask]\n\t\t\t * router [big endian, 4 bytes]\n\t\t\t * may be repeated\n\t\t\t *\n\t\t\t * We convert it to a string \"IP/MASK ROUTER IP2/MASK2 ROUTER2\"\n\t\t\t */\n\t\t\tconst char *pfx = \"\";\n\n\t\t\twhile (len >= 1 + 4) { /* mask + 0-byte ip + router */\n\t\t\t\tuint32_t nip;\n\t\t\t\tuint8_t *p;\n\t\t\t\tunsigned mask;\n\t\t\t\tint bytes;\n\n\t\t\t\tmask = *option++;\n\t\t\t\tif (mask > 32)\n\t\t\t\t\tbreak;\n\t\t\t\tlen--;\n\n\t\t\t\tnip = 0;\n\t\t\t\tp = (void*) &nip;\n\t\t\t\tbytes = (mask + 7) / 8; /* 0 -> 0, 1..8 -> 1, 9..16 -> 2 etc */\n\t\t\t\twhile (--bytes >= 0) {\n\t\t\t\t\t*p++ = *option++;\n\t\t\t\t\tlen--;\n\t\t\t\t}\n\t\t\t\tif (len < 4)\n\t\t\t\t\tbreak;\n\n\t\t\t\t/* print ip/mask */\n\t\t\t\tdest += sprint_nip(dest, pfx, (void*) &nip);\n\t\t\t\tpfx = \" \";\n\t\t\t\tdest += sprintf(dest, \"/%u \", mask);\n\t\t\t\t/* print router */\n\t\t\t\tdest += sprint_nip(dest, \"\", option);\n\t\t\t\toption += 4;\n\t\t\t\tlen -= 4;\n\t\t\t}\n\n\t\t\treturn ret;\n\t\t}\n\t\tcase OPTION_6RD:\n\t\t\t/* Option binary format (see RFC 5969):\n\t\t\t *  0                   1                   2                   3\n\t\t\t *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\t\t\t * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t\t\t * |  OPTION_6RD   | option-length |  IPv4MaskLen  |  6rdPrefixLen |\n\t\t\t * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t\t\t * |                           6rdPrefix                           |\n\t\t\t * ...                        (16 octets)                        ...\n\t\t\t * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t\t\t * ...                   6rdBRIPv4Address(es)                    ...\n\t\t\t * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t\t\t * We convert it to a string\n\t\t\t * \"IPv4MaskLen 6rdPrefixLen 6rdPrefix 6rdBRIPv4Address...\"\n\t\t\t *\n\t\t\t * Sanity check: ensure that our length is at least 22 bytes, that\n\t\t\t * IPv4MaskLen <= 32,\n\t\t\t * 6rdPrefixLen <= 128,\n\t\t\t * 6rdPrefixLen + (32 - IPv4MaskLen) <= 128\n\t\t\t * (2nd condition need no check - it follows from 1st and 3rd).\n\t\t\t * Else, return envvar with empty value (\"optname=\")\n\t\t\t */\n\t\t\tif (len >= (1 + 1 + 16 + 4)\n\t\t\t && option[0] <= 32\n\t\t\t && (option[1] + 32 - option[0]) <= 128\n\t\t\t) {\n\t\t\t\t/* IPv4MaskLen */\n\t\t\t\tdest += sprintf(dest, \"%u \", *option++);\n\t\t\t\t/* 6rdPrefixLen */\n\t\t\t\tdest += sprintf(dest, \"%u \", *option++);\n\t\t\t\t/* 6rdPrefix */\n\t\t\t\tdest += sprint_nip6(dest, /* \"\", */ option);\n\t\t\t\toption += 16;\n\t\t\t\tlen -= 1 + 1 + 16 + 4;\n\t\t\t\t/* \"+ 4\" above corresponds to the length of IPv4 addr\n\t\t\t\t * we consume in the loop below */\n\t\t\t\twhile (1) {\n\t\t\t\t\t/* 6rdBRIPv4Address(es) */\n\t\t\t\t\tdest += sprint_nip(dest, \" \", option);\n\t\t\t\t\toption += 4;\n\t\t\t\t\tlen -= 4; /* do we have yet another 4+ bytes? */\n\t\t\t\t\tif (len < 0)\n\t\t\t\t\t\tbreak; /* no */\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn ret;\n#if ENABLE_FEATURE_UDHCP_RFC3397\n\t\tcase OPTION_DNS_STRING:\n\t\t\t/* unpack option into dest; use ret for prefix (i.e., \"optname=\") */\n\t\t\tdest = dname_dec(option, len, ret);\n\t\t\tif (dest) {\n\t\t\t\tfree(ret);\n\t\t\t\treturn dest;\n\t\t\t}\n\t\t\t/* error. return \"optname=\" string */\n\t\t\treturn ret;\n\t\tcase OPTION_SIP_SERVERS:\n\t\t\t/* Option binary format:\n\t\t\t * type: byte\n\t\t\t * type=0: domain names, dns-compressed\n\t\t\t * type=1: IP addrs\n\t\t\t */\n\t\t\toption++;\n\t\t\tlen--;\n\t\t\tif (option[-1] == 0) {\n\t\t\t\tdest = dname_dec(option, len, ret);\n\t\t\t\tif (dest) {\n\t\t\t\t\tfree(ret);\n\t\t\t\t\treturn dest;\n\t\t\t\t}\n\t\t\t} else\n\t\t\tif (option[-1] == 1) {\n\t\t\t\tconst char *pfx = \"\";\n\t\t\t\twhile (1) {\n\t\t\t\t\tlen -= 4;\n\t\t\t\t\tif (len < 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdest += sprint_nip(dest, pfx, option);\n\t\t\t\t\tpfx = \" \";\n\t\t\t\t\toption += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n#endif\n\t\t} /* switch */\n\n\t\t/* If we are here, try to format any remaining data\n\t\t * in the option as another, similarly-formatted option\n\t\t */\n\t\toption += optlen;\n\t\tlen -= optlen;\n// TODO: it can be a list only if (optflag->flags & OPTION_LIST).\n// Should we bail out/warn if we see multi-ip option which is\n// not allowed to be such (for example, DHCP_BROADCAST)? -\n\t\tif (len < optlen /* || !(optflag->flags & OPTION_LIST) */)\n\t\t\tbreak;\n\t\t*dest++ = ' ';\n\t\t*dest = '\\0';\n\t} /* while */\n\n\treturn ret;\n}",
        "target": 1
    },
    {
        "func": "int FAST_FUNC udhcp_str2optset(const char *const_str, void *arg)\n{\n\tstruct option_set **opt_list = arg;\n\tchar *opt, *val, *endptr;\n\tchar *str;\n\tconst struct dhcp_optflag *optflag;\n\tstruct dhcp_optflag bin_optflag;\n\tunsigned optcode;\n\tint retval, length;\n\tchar buffer[8] ALIGNED(4);\n\tuint16_t *result_u16 = (uint16_t *) buffer;\n\tuint32_t *result_u32 = (uint32_t *) buffer;\n\n\t/* Cheat, the only *const* str possible is \"\" */\n\tstr = (char *) const_str;\n\topt = strtok(str, \" \\t=\");\n\tif (!opt)\n\t\treturn 0;\n\n\toptcode = bb_strtou(opt, NULL, 0);\n\tif (!errno && optcode < 255) {\n\t\t/* Raw (numeric) option code */\n\t\tbin_optflag.flags = OPTION_BIN;\n\t\tbin_optflag.code = optcode;\n\t\toptflag = &bin_optflag;\n\t} else {\n\t\toptflag = &dhcp_optflags[udhcp_option_idx(opt)];\n\t}\n\n\tretval = 0;\n\tdo {\n\t\tval = strtok(NULL, \", \\t\");\n\t\tif (!val)\n\t\t\tbreak;\n\t\tlength = dhcp_option_lengths[optflag->flags & OPTION_TYPE_MASK];\n\t\tretval = 0;\n\t\topt = buffer; /* new meaning for variable opt */\n\t\tswitch (optflag->flags & OPTION_TYPE_MASK) {\n\t\tcase OPTION_IP:\n\t\t\tretval = udhcp_str2nip(val, buffer);\n\t\t\tbreak;\n\t\tcase OPTION_IP_PAIR:\n\t\t\tretval = udhcp_str2nip(val, buffer);\n\t\t\tval = strtok(NULL, \", \\t/-\");\n\t\t\tif (!val)\n\t\t\t\tretval = 0;\n\t\t\tif (retval)\n\t\t\t\tretval = udhcp_str2nip(val, buffer + 4);\n\t\t\tbreak;\n\t\tcase OPTION_STRING:\n#if ENABLE_FEATURE_UDHCP_RFC3397\n\t\tcase OPTION_DNS_STRING:\n#endif\n\t\t\tlength = strnlen(val, 254);\n\t\t\tif (length > 0) {\n\t\t\t\topt = val;\n\t\t\t\tretval = 1;\n\t\t\t}\n\t\t\tbreak;\n//\t\tcase OPTION_BOOLEAN: {\n//\t\t\tstatic const char no_yes[] ALIGN1 = \"no\\0yes\\0\";\n//\t\t\tbuffer[0] = retval = index_in_strings(no_yes, val);\n//\t\t\tretval++; /* 0 - bad; 1: \"no\" 2: \"yes\" */\n//\t\t\tbreak;\n//\t\t}\n\t\tcase OPTION_U8:\n\t\t\tbuffer[0] = strtoul(val, &endptr, 0);\n\t\t\tretval = (endptr[0] == '\\0');\n\t\t\tbreak;\n\t\t/* htonX are macros in older libc's, using temp var\n\t\t * in code below for safety */\n\t\t/* TODO: use bb_strtoX? */\n\t\tcase OPTION_U16: {\n\t\t\tunsigned long tmp = strtoul(val, &endptr, 0);\n\t\t\t*result_u16 = htons(tmp);\n\t\t\tretval = (endptr[0] == '\\0' /*&& tmp < 0x10000*/);\n\t\t\tbreak;\n\t\t}\n//\t\tcase OPTION_S16: {\n//\t\t\tlong tmp = strtol(val, &endptr, 0);\n//\t\t\t*result_u16 = htons(tmp);\n//\t\t\tretval = (endptr[0] == '\\0');\n//\t\t\tbreak;\n//\t\t}\n\t\tcase OPTION_U32: {\n\t\t\tunsigned long tmp = strtoul(val, &endptr, 0);\n\t\t\t*result_u32 = htonl(tmp);\n\t\t\tretval = (endptr[0] == '\\0');\n\t\t\tbreak;\n\t\t}\n\t\tcase OPTION_S32: {\n\t\t\tlong tmp = strtol(val, &endptr, 0);\n\t\t\t*result_u32 = htonl(tmp);\n\t\t\tretval = (endptr[0] == '\\0');\n\t\t\tbreak;\n\t\t}\n\t\tcase OPTION_BIN: /* handled in attach_option() */\n\t\t\topt = val;\n\t\t\tretval = 1;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (retval)\n\t\t\tattach_option(opt_list, optflag, opt, length);\n\t} while (retval && optflag->flags & OPTION_LIST);\n\n\treturn retval;\n}",
        "target": 1
    },
    {
        "func": "static NOINLINE void attach_option(\n\t\tstruct option_set **opt_list,\n\t\tconst struct dhcp_optflag *optflag,\n\t\tchar *buffer,\n\t\tint length)\n{\n\tstruct option_set *existing, *new, **curr;\n\tchar *allocated = NULL;\n\n\texisting = udhcp_find_option(*opt_list, optflag->code);\n\tif (!existing) {\n\t\tlog2(\"Attaching option %02x to list\", optflag->code);\n\t\tallocated = allocate_tempopt_if_needed(optflag, buffer, &length);\n#if ENABLE_FEATURE_UDHCP_RFC3397\n\t\tif ((optflag->flags & OPTION_TYPE_MASK) == OPTION_DNS_STRING) {\n\t\t\t/* reuse buffer and length for RFC1035-formatted string */\n\t\t\tallocated = buffer = (char *)dname_enc(NULL, 0, buffer, &length);\n\t\t}\n#endif\n\t\t/* make a new option */\n\t\tnew = xmalloc(sizeof(*new));\n\t\tnew->data = xmalloc(length + OPT_DATA);\n\t\tnew->data[OPT_CODE] = optflag->code;\n\t\tnew->data[OPT_LEN] = length;\n\t\tmemcpy(new->data + OPT_DATA, (allocated ? allocated : buffer), length);\n\n\t\tcurr = opt_list;\n\t\twhile (*curr && (*curr)->data[OPT_CODE] < optflag->code)\n\t\t\tcurr = &(*curr)->next;\n\n\t\tnew->next = *curr;\n\t\t*curr = new;\n\t\tgoto ret;\n\t}\n\n\tif (optflag->flags & OPTION_LIST) {\n\t\tunsigned old_len;\n\n\t\t/* add it to an existing option */\n\t\tlog2(\"Attaching option %02x to existing member of list\", optflag->code);\n\t\tallocated = allocate_tempopt_if_needed(optflag, buffer, &length);\n\t\told_len = existing->data[OPT_LEN];\n#if ENABLE_FEATURE_UDHCP_RFC3397\n\t\tif ((optflag->flags & OPTION_TYPE_MASK) == OPTION_DNS_STRING) {\n\t\t\t/* reuse buffer and length for RFC1035-formatted string */\n\t\t\tallocated = buffer = (char *)dname_enc(existing->data + OPT_DATA, old_len, buffer, &length);\n\t\t}\n#endif\n\t\tif (old_len + length < 255) {\n\t\t\t/* actually 255 is ok too, but adding a space can overlow it */\n\n\t\t\texisting->data = xrealloc(existing->data, OPT_DATA + 1 + old_len + length);\n\t\t\tif ((optflag->flags & OPTION_TYPE_MASK) == OPTION_STRING) {\n\t\t\t\t/* add space separator between STRING options in a list */\n\t\t\t\texisting->data[OPT_DATA + old_len] = ' ';\n\t\t\t\told_len++;\n\t\t\t}\n\t\t\tmemcpy(existing->data + OPT_DATA + old_len, buffer, length);\n\t\t\texisting->data[OPT_LEN] = old_len + length;\n\t\t} /* else, ignore the data, we could put this in a second option in the future */\n\t} /* else, ignore the new data */\n\n ret:\n\tfree(allocated);\n}",
        "target": 1
    },
    {
        "func": "int cli_hm_scan(const unsigned char *digest, uint32_t size, const char **virname, const struct cli_matcher *root, enum CLI_HASH_TYPE type) {\n    const struct cli_htu32_element *item;\n    unsigned int keylen;\n    struct cli_sz_hash *szh;\n    size_t l, r;\n\n    if(!digest || !size || size == 0xffffffff || !root || !root->hm.sizehashes[type].capacity)\n\treturn CL_CLEAN;\n\n    item = cli_htu32_find(&root->hm.sizehashes[type], size);\n    if(!item)\n\treturn CL_CLEAN;\n\n    szh = (struct cli_sz_hash *)item->data.as_ptr;\n    keylen = hashlen[type];\n\n    l = 0;\n    r = szh->items;\n    while(l <= r) {\n\tsize_t c = (l + r) / 2;\n\tint res = hm_cmp(digest, &szh->hash_array[keylen * c], keylen);\n\n\tif(res < 0) {\n\t    if(!c)\n\t\tbreak;\n\t    r = c - 1;\n\t} else if(res > 0)\n\t    l = c + 1;\n\telse {\n\t    if(virname)\n\t\t*virname = szh->virusnames[c];\n\t    return CL_VIRUS;\n\t}\n    }\n    return CL_CLEAN;\n}",
        "target": 1
    },
    {
        "func": "static int check_mtab(const char *progname, const char *devname,\n\t\t      const char *dir)\n{\n\tif (check_newline(progname, devname) == -1 ||\n\t    check_newline(progname, dir) == -1)\n\t\treturn EX_USAGE;\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "gdk_pixbuf__tiff_image_begin_load (ModulePreparedNotifyFunc prepare_func,\n\t\t\t\t   ModuleUpdatedNotifyFunc update_func,\n\t\t\t\t   gpointer user_data,\n                                   GError **error)\n{\n\tTiffData *context;\n\tgint fd;\n\n\tcontext = g_new (TiffData, 1);\n\tcontext->prepare_func = prepare_func;\n\tcontext->update_func = update_func;\n\tcontext->user_data = user_data;\n\tcontext->all_okay = TRUE;\n\tfd = g_file_open_tmp (\"gdkpixbuf-tif-tmp.XXXXXX\", &context->tempname,\n\t\t\t      NULL);\n\tif (fd < 0) {\n\t\tg_free (context);\n\t\treturn NULL;\n\t}\n\n\tcontext->file = fdopen (fd, \"w\");\n\tif (context->file == NULL) {\n                g_free (context->tempname);\n\t\tg_free (context);\n\t\treturn NULL;\n\t}\n\n\treturn context;\n}",
        "target": 1
    },
    {
        "func": "gdk_pixbuf__png_image_stop_load (gpointer context, GError **error)\n{\n        LoadContext* lc = context;\n\n        g_return_val_if_fail(lc != NULL, TRUE);\n\n        /* FIXME this thing needs to report errors if\n         * we have unused image data\n         */\n        \n        gdk_pixbuf_unref(lc->pixbuf);\n        \n        png_destroy_read_struct(&lc->png_read_ptr, NULL, NULL);\n        g_free(lc);\n\n        return TRUE;\n}",
        "target": 1
    },
    {
        "func": "gdk_pixbuf__gif_image_load_animation (FILE *file,\n                                      GError **error)\n{\n\tGifContext *context;\n\tGdkPixbufAnimation *animation;\n\n\tg_return_val_if_fail (file != NULL, NULL);\n\n\tcontext = new_context ();\n\n        context->error = error;\n\tcontext->file = file;\n\n\tif (gif_main_loop (context) == -1 || context->animation->frames == NULL) {\n                if (context->error && *(context->error) == NULL)\n                        g_set_error (context->error,\n                                     GDK_PIXBUF_ERROR,\n                                     GDK_PIXBUF_ERROR_CORRUPT_IMAGE,\n                                     _(\"GIF file was missing some data (perhaps it was truncated somehow?)\"));\n\n                g_object_unref (G_OBJECT (context->animation));\n                context->animation = NULL;\n        }\n\n        if (context->animation)\n                animation = GDK_PIXBUF_ANIMATION (context->animation);\n        else\n                animation = NULL;\n\n        if (context->error && *(context->error))\n                g_print (\"%s\\n\", (*(context->error))->message);\n        \n        g_free (context->buf);\n\tg_free (context);\n\treturn animation;\n}",
        "target": 1
    },
    {
        "func": "lzw_read_byte (GifContext *context)\n{\n\tint code, incode;\n\tgint retval;\n\tgint my_retval;\n\tregister int i;\n\n\tif (context->lzw_code_pending != -1) {\n\t\tretval = context->lzw_code_pending;\n\t\tcontext->lzw_code_pending = -1;\n\t\treturn retval;\n\t}\n\n\tif (context->lzw_fresh) {\n\t\tcontext->lzw_fresh = FALSE;\n\t\tdo {\n\t\t\tretval = get_code (context, context->lzw_code_size);\n\t\t\tif (retval < 0) {\n\t\t\t\treturn retval;\n\t\t\t}\n\n\t\t\tcontext->lzw_firstcode = context->lzw_oldcode = retval;\n\t\t} while (context->lzw_firstcode == context->lzw_clear_code);\n\t\treturn context->lzw_firstcode;\n\t}\n\n\tif (context->lzw_sp > context->lzw_stack) {\n\t\tmy_retval = *--(context->lzw_sp);\n\t\treturn my_retval;\n\t}\n\n\twhile ((code = get_code (context, context->lzw_code_size)) >= 0) {\n\t\tif (code == context->lzw_clear_code) {\n\t\t\tfor (i = 0; i < context->lzw_clear_code; ++i) {\n\t\t\t\tcontext->lzw_table[0][i] = 0;\n\t\t\t\tcontext->lzw_table[1][i] = i;\n\t\t\t}\n\t\t\tfor (; i < (1 << MAX_LZW_BITS); ++i)\n\t\t\t\tcontext->lzw_table[0][i] = context->lzw_table[1][i] = 0;\n\t\t\tcontext->lzw_code_size = context->lzw_set_code_size + 1;\n\t\t\tcontext->lzw_max_code_size = 2 * context->lzw_clear_code;\n\t\t\tcontext->lzw_max_code = context->lzw_clear_code + 2;\n\t\t\tcontext->lzw_sp = context->lzw_stack;\n\n\t\t\tset_gif_lzw_clear_code (context);\n\t\t\treturn -3;\n\t\t} else if (code == context->lzw_end_code) {\n\t\t\tint count;\n\t\t\tunsigned char buf[260];\n\n\t\t\t/*g_error (\" DID WE EVER EVER GET HERE\\n\");*/\n\t\t\tg_warning (\"Unhandled Case.  If you have an image that causes this, let me <jrb@redhat.com> know.\\n\");\n\n\t\t\tif (ZeroDataBlock) {\n\t\t\t\treturn -2;\n\t\t\t}\n\n\t\t\twhile ((count = GetDataBlock (context, buf)) > 0)\n\t\t\t\t;\n\n\t\t\tif (count != 0) {\n\t\t\t\t/*g_print (_(\"GIF: missing EOD in data stream (common occurence)\"));*/\n\t\t\t\treturn -2;\n\t\t\t}\n\t\t}\n\n\t\tincode = code;\n\n\t\tif (code >= context->lzw_max_code) {\n\t\t\t*(context->lzw_sp)++ = context->lzw_firstcode;\n\t\t\tcode = context->lzw_oldcode;\n\t\t}\n\n\t\twhile (code >= context->lzw_clear_code) {\n\t\t\t*(context->lzw_sp)++ = context->lzw_table[1][code];\n\n\t\t\tif (code == context->lzw_table[0][code]) {\n                                g_set_error (context->error,\n                                             GDK_PIXBUF_ERROR,\n                                             GDK_PIXBUF_ERROR_CORRUPT_IMAGE,\n                                             _(\"Circular table entry in GIF file\"));\n\t\t\t\treturn -2;\n\t\t\t}\n\t\t\tcode = context->lzw_table[0][code];\n\t\t}\n\n\t\t*(context->lzw_sp)++ = context->lzw_firstcode = context->lzw_table[1][code];\n\n\t\tif ((code = context->lzw_max_code) < (1 << MAX_LZW_BITS)) {\n\t\t\tcontext->lzw_table[0][code] = context->lzw_oldcode;\n\t\t\tcontext->lzw_table[1][code] = context->lzw_firstcode;\n\t\t\t++context->lzw_max_code;\n\t\t\tif ((context->lzw_max_code >= context->lzw_max_code_size) &&\n\t\t\t    (context->lzw_max_code_size < (1 << MAX_LZW_BITS))) {\n\t\t\t\tcontext->lzw_max_code_size *= 2;\n\t\t\t\t++context->lzw_code_size;\n\t\t\t}\n\t\t}\n\n\t\tcontext->lzw_oldcode = incode;\n\n\t\tif (context->lzw_sp > context->lzw_stack) {\n\t\t\tmy_retval = *--(context->lzw_sp);\n\t\t\treturn my_retval;\n\t\t}\n\t}\n\treturn code;\n}",
        "target": 1
    },
    {
        "func": "gif_get_lzw (GifContext *context)\n{\n\tguchar *dest, *temp;\n\tgint lower_bound, upper_bound; /* bounds for emitting the area_updated signal */\n\tgboolean bound_flag;\n\tgint first_pass; /* bounds for emitting the area_updated signal */\n\tgint v;\n\n\tif (context->frame == NULL) {\n                context->frame = g_new (GdkPixbufFrame, 1);\n\n                context->frame->composited = NULL;\n                context->frame->revert = NULL;\n                \n                context->frame->pixbuf =\n                        gdk_pixbuf_new (GDK_COLORSPACE_RGB,\n                                        TRUE,\n                                        8,\n                                        context->frame_len,\n                                        context->frame_height);\n                \n                context->frame->x_offset = context->x_offset;\n                context->frame->y_offset = context->y_offset;\n                context->frame->need_recomposite = TRUE;\n                \n                /* GIF delay is in hundredths, we want thousandths */\n                context->frame->delay_time = context->gif89.delay_time * 10;\n                context->frame->elapsed = context->animation->total_time;\n                context->animation->total_time += context->frame->delay_time;\n                \n                switch (context->gif89.disposal) {\n                case 0:\n                case 1:\n                        context->frame->action = GDK_PIXBUF_FRAME_RETAIN;\n                        break;\n                case 2:\n                        context->frame->action = GDK_PIXBUF_FRAME_DISPOSE;\n                        break;\n                case 3:\n                        context->frame->action = GDK_PIXBUF_FRAME_REVERT;\n                        break;\n                default:\n                        context->frame->action = GDK_PIXBUF_FRAME_RETAIN;\n                        break;\n                }\n\n                context->frame->bg_transparent = (context->gif89.transparent == context->background_index);\n                \n                {\n                        /* Update animation size */\n                        int w, h;\n                        \n                        context->animation->n_frames ++;\n                        context->animation->frames = g_list_append (context->animation->frames, context->frame);\n\n                        w = context->frame->x_offset +\n                                gdk_pixbuf_get_width (context->frame->pixbuf);\n                        h = context->frame->y_offset +\n                                gdk_pixbuf_get_height (context->frame->pixbuf);\n                        if (w > context->animation->width)\n                                context->animation->width = w;\n                        if (h > context->animation->height)\n                                context->animation->height = h;\n                }\n\n                /* Only call prepare_func for the first frame */\n\t\tif (context->animation->frames->next == NULL) { \n                        if (context->prepare_func)\n                                (* context->prepare_func) (context->frame->pixbuf,\n                                                           GDK_PIXBUF_ANIMATION (context->animation),\n                                                           context->user_data);\n                } else {\n                        /* Otherwise init frame with last frame */\n                        GList *link;\n                        GdkPixbufFrame *prev_frame;\n                        \n                        link = g_list_find (context->animation->frames, context->frame);\n\n                        prev_frame = link->prev->data;\n\n                        gdk_pixbuf_gif_anim_frame_composite (context->animation, prev_frame);\n\n                        gdk_pixbuf_copy_area (prev_frame->composited,\n                                              context->frame->x_offset,\n                                              context->frame->y_offset,\n                                              gdk_pixbuf_get_width (context->frame->pixbuf),\n                                              gdk_pixbuf_get_height (context->frame->pixbuf),\n                                              context->frame->pixbuf,\n                                              0, 0);\n                }\n        }\n\n\tdest = gdk_pixbuf_get_pixels (context->frame->pixbuf);\n\n\tbound_flag = FALSE;\n\tlower_bound = upper_bound = context->draw_ypos;\n\tfirst_pass = context->draw_pass;\n\n\twhile (TRUE) {\n                guchar (*cmap)[MAXCOLORMAPSIZE];\n\n                if (context->frame_cmap_active)\n                        cmap = context->frame_color_map;\n                else\n                        cmap = context->global_color_map;\n                \n\t\tv = lzw_read_byte (context);\n\t\tif (v < 0) {\n\t\t\tgoto finished_data;\n\t\t}\n\t\tbound_flag = TRUE;\n\n                g_assert (gdk_pixbuf_get_has_alpha (context->frame->pixbuf));\n                \n                temp = dest + context->draw_ypos * gdk_pixbuf_get_rowstride (context->frame->pixbuf) + context->draw_xpos * 4;\n                *temp = cmap [0][(guchar) v];\n                *(temp+1) = cmap [1][(guchar) v];\n                *(temp+2) = cmap [2][(guchar) v];\n                *(temp+3) = (guchar) ((v == context->gif89.transparent) ? 0 : 255);\n\n\t\tif (context->prepare_func && context->frame_interlace)\n\t\t\tgif_fill_in_lines (context, dest, v);\n\n\t\tcontext->draw_xpos++;\n                \n\t\tif (context->draw_xpos == context->frame_len) {\n\t\t\tcontext->draw_xpos = 0;\n\t\t\tif (context->frame_interlace) {\n\t\t\t\tswitch (context->draw_pass) {\n\t\t\t\tcase 0:\n\t\t\t\tcase 1:\n\t\t\t\t\tcontext->draw_ypos += 8;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tcontext->draw_ypos += 4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tcontext->draw_ypos += 2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (context->draw_ypos >= context->frame_height) {\n\t\t\t\t\tcontext->draw_pass++;\n\t\t\t\t\tswitch (context->draw_pass) {\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tcontext->draw_ypos = 4;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tcontext->draw_ypos = 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tcontext->draw_ypos = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcontext->draw_ypos++;\n\t\t\t}\n\t\t\tif (context->draw_pass != first_pass) {\n\t\t\t\tif (context->draw_ypos > lower_bound) {\n\t\t\t\t\tlower_bound = 0;\n\t\t\t\t\tupper_bound = context->frame_height;\n\t\t\t\t} else {\n                                        \n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tupper_bound = context->draw_ypos;\n\t\t}\n\t\tif (context->draw_ypos >= context->frame_height)\n\t\t\tbreak;\n\t}\n\n done:\n\n        context->state = GIF_GET_NEXT_STEP;\n\n        v = 0;\n\n finished_data:\n        \n        if (bound_flag)\n                context->frame->need_recomposite = TRUE;\n        \n\tif (bound_flag && context->update_func) {\n\t\tif (lower_bound <= upper_bound && first_pass == context->draw_pass) {\n\t\t\t(* context->update_func)\n\t\t\t\t(context->frame->pixbuf,\n\t\t\t\t 0, lower_bound,\n\t\t\t\t gdk_pixbuf_get_width (context->frame->pixbuf),\n\t\t\t\t upper_bound - lower_bound,\n\t\t\t\t context->user_data);\n\t\t} else {\n\t\t\tif (lower_bound <= upper_bound) {\n\t\t\t\t(* context->update_func)\n\t\t\t\t\t(context->frame->pixbuf,\n\t\t\t\t\t context->frame->x_offset,\n                                         context->frame->y_offset,\n\t\t\t\t\t gdk_pixbuf_get_width (context->frame->pixbuf),\n\t\t\t\t\t gdk_pixbuf_get_height (context->frame->pixbuf),\n\t\t\t\t\t context->user_data);\n\t\t\t} else {\n\t\t\t\t(* context->update_func)\n\t\t\t\t\t(context->frame->pixbuf,\n\t\t\t\t\t context->frame->x_offset,\n                                         context->frame->y_offset,\n\t\t\t\t\t gdk_pixbuf_get_width (context->frame->pixbuf),\n\t\t\t\t\t upper_bound,\n\t\t\t\t\t context->user_data);\n\t\t\t\t(* context->update_func)\n\t\t\t\t\t(context->frame->pixbuf,\n\t\t\t\t\t context->frame->x_offset,\n                                         lower_bound + context->frame->y_offset,\n\t\t\t\t\t gdk_pixbuf_get_width (context->frame->pixbuf),\n\t\t\t\t\t gdk_pixbuf_get_height (context->frame->pixbuf),\n\t\t\t\t\t context->user_data);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (context->state == GIF_GET_NEXT_STEP) {\n                /* Will be freed with context->animation, we are just\n                 * marking that we're done with it (no current frame)\n                 */\n\t\tcontext->frame = NULL;\n                context->frame_cmap_active = FALSE;\n\t}\n\t\n\treturn v;\n}",
        "target": 1
    },
    {
        "func": "gdk_pixbuf_loader_close (GdkPixbufLoader *loader,\n                         GError         **error)\n{\n  GdkPixbufLoaderPrivate *priv;\n  gboolean retval = TRUE;\n  \n  g_return_val_if_fail (loader != NULL, TRUE);\n  g_return_val_if_fail (GDK_IS_PIXBUF_LOADER (loader), TRUE);\n  \n  priv = loader->priv;\n  \n  /* we expect it's not closed */\n  g_return_val_if_fail (priv->closed == FALSE, TRUE);\n  \n  /* We have less the 128 bytes in the image.  Flush it, and keep going. */\n  if (priv->image_module == NULL)\n    gdk_pixbuf_loader_load_module (loader, NULL, NULL);\n  \n  if (priv->image_module && priv->image_module->stop_load)\n    retval = priv->image_module->stop_load (priv->context, error);\n  \n  priv->closed = TRUE;\n  \n  g_signal_emit (G_OBJECT (loader), pixbuf_loader_signals[CLOSED], 0);\n\n  return retval;\n}",
        "target": 1
    },
    {
        "func": "png_error_callback(png_structp png_read_ptr,\n                   png_const_charp error_msg)\n{\n        LoadContext* lc;\n        \n        lc = png_get_error_ptr(png_read_ptr);\n        \n        lc->fatal_error_occurred = TRUE;\n\n        /* I don't trust libpng to call the error callback only once,\n         * so check for already-set error\n         */\n        if (lc->error && *lc->error == NULL) {\n                g_set_error (lc->error,\n                             GDK_PIXBUF_ERROR,\n                             GDK_PIXBUF_ERROR_CORRUPT_IMAGE,\n                             _(\"Fatal error reading PNG image file: %s\"),\n                             error_msg);\n        }\n}",
        "target": 1
    },
    {
        "func": "gif_read (GifContext *context, guchar *buffer, size_t len)\n{\n\tgint retval;\n#ifdef IO_GIFDEBUG\n\tgint i;\n#endif\n\tif (context->file) {\n#ifdef IO_GIFDEBUG\n\t\tcount += len;\n\t\tg_print (\"Fsize :%d\\tcount :%d\\t\", len, count);\n#endif\n\t\tretval = (fread(buffer, len, 1, context->file) != 0);\n\n                if (!retval && ferror (context->file))\n                        g_set_error (context->error,\n                                     G_FILE_ERROR,\n                                     g_file_error_from_errno (errno),\n                                     _(\"Failure reading GIF: %s\"), strerror (errno));\n                \n#ifdef IO_GIFDEBUG\n\t\tif (len < 100) {\n\t\t\tfor (i = 0; i < len; i++)\n\t\t\t\tg_print (\"%d \", buffer[i]);\n\t\t}\n\t\tg_print (\"\\n\");\n#endif\n                \n\t\treturn retval;\n\t} else {\n#ifdef IO_GIFDEBUG\n/*  \t\tg_print (\"\\tlooking for %d bytes.  size == %d, ptr == %d\\n\", len, context->size, context->ptr); */\n#endif\n\t\tif ((context->size - context->ptr) >= len) {\n#ifdef IO_GIFDEBUG\n\t\t\tcount += len;\n#endif\n\t\t\tmemcpy (buffer, context->buf + context->ptr, len);\n\t\t\tcontext->ptr += len;\n\t\t\tcontext->amount_needed = 0;\n#ifdef IO_GIFDEBUG\n\t\t\tg_print (\"Psize :%d\\tcount :%d\\t\", len, count);\n\t\t\tif (len < 100) {\n\t\t\t\tfor (i = 0; i < len; i++)\n\t\t\t\t\tg_print (\"%d \", buffer[i]);\n\t\t\t}\n\t\t\tg_print (\"\\n\");\n#endif\n\t\t\treturn TRUE;\n\t\t}\n\t\tcontext->amount_needed = len - (context->size - context->ptr);\n\t}\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "gdk_pixbuf__tiff_image_load (FILE *f, GError **error)\n{\n\treturn gdk_pixbuf__tiff_image_load_real (f, NULL, error);\n}",
        "target": 1
    },
    {
        "func": "gdk_pixbuf__tiff_fill_vtable (GdkPixbufModule *module)\n{\n  module->load = gdk_pixbuf__tiff_image_load;\n  module->begin_load = gdk_pixbuf__tiff_image_begin_load;\n  module->stop_load = gdk_pixbuf__tiff_image_stop_load;\n  module->load_increment = gdk_pixbuf__tiff_image_load_increment;\n}",
        "target": 1
    },
    {
        "func": "gdk_pixbuf__tiff_image_load_real (FILE *f, TiffData *context, GError **error)\n{\n\tTIFF *tiff;\n\tguchar *pixels = NULL;\n\tguchar *tmppix;\n\tgint w, h, x, y, num_pixs, fd;\n\tuint32 *rast, *tmp_rast;\n\tGdkPixbuf *pixbuf;\n\t\n\tfd = fileno (f);\n\ttiff = TIFFFdOpen (fd, \"libpixbuf-tiff\", \"r\");\n\n\tif (!tiff) {\n                g_set_error (error,\n                             GDK_PIXBUF_ERROR,\n                             GDK_PIXBUF_ERROR_CORRUPT_IMAGE,\n                             _(\"Failed to open TIFF image\"));\n\t\treturn NULL;\n        }\n                \n\tTIFFGetField (tiff, TIFFTAG_IMAGEWIDTH, &w);\n\tTIFFGetField (tiff, TIFFTAG_IMAGELENGTH, &h);\n\tnum_pixs = w * h;\n\tpixbuf = gdk_pixbuf_new (GDK_COLORSPACE_RGB, TRUE, 8, w, h);\n\n        if (!pixbuf) {\n                g_set_error (error,\n                             GDK_PIXBUF_ERROR,\n                             GDK_PIXBUF_ERROR_INSUFFICIENT_MEMORY,\n                             _(\"Insufficient memory to open TIFF file\"));\n\t\tTIFFClose (tiff);\n\t\treturn NULL;\n        }\n        \n\tif (context)\n\t\t(* context->prepare_func) (pixbuf, NULL, context->user_data);\n\n\t/* Yes, it needs to be _TIFFMalloc... */\n\trast = (uint32 *) _TIFFmalloc (num_pixs * sizeof (uint32));\n\n\tif (!rast) {\n                g_set_error (error,\n                             GDK_PIXBUF_ERROR,\n                             GDK_PIXBUF_ERROR_INSUFFICIENT_MEMORY,\n                             _(\"Insufficient memory to open TIFF file\"));\n\t\tTIFFClose (tiff);\n\t\treturn NULL;\n\t}\n\n\tif (TIFFReadRGBAImage (tiff, w, h, rast, 0)) {\n\t\tpixels = gdk_pixbuf_get_pixels (pixbuf);\n\n                g_assert (pixels);\n                \n\t\ttmppix = pixels;\n\n\t\tfor (y = 0; y < h; y++) {\n\t\t\t/* Unexplainable...are tiffs backwards? */\n\t\t\t/* Also looking at the GIMP plugin, this\n\t\t\t * whole reading thing can be a bit more\n\t\t\t * robust.\n\t\t\t */\n\t\t\ttmp_rast = rast + ((h - y - 1) * w);\n\t\t\tfor (x = 0; x < w; x++) {\n\t\t\t\ttmppix[0] = TIFFGetR (*tmp_rast);\n\t\t\t\ttmppix[1] = TIFFGetG (*tmp_rast);\n\t\t\t\ttmppix[2] = TIFFGetB (*tmp_rast);\n\t\t\t\ttmppix[3] = TIFFGetA (*tmp_rast);\n\t\t\t\ttmp_rast++;\n\t\t\t\ttmppix += 4;\n\t\t\t}\n\t\t}\n\t}\n\t_TIFFfree (rast);\n\tTIFFClose (tiff);\n\n\tif (context) {\n\t\t(* context->update_func) (pixbuf, 0, 0, w, h, context->user_data);\n\t\tgdk_pixbuf_unref (pixbuf);\n\t}\n\n\treturn pixbuf;\n}",
        "target": 1
    },
    {
        "func": "gdk_pixbuf__tiff_image_load_increment (gpointer data, const guchar *buf,\n                                       guint size, GError **error)\n{\n\tTiffData *context = (TiffData *) data;\n\n\tg_return_val_if_fail (data != NULL, FALSE);\n\n\tif (fwrite (buf, sizeof (guchar), size, context->file) != size) {\n\t\tcontext->all_okay = FALSE;\n                g_set_error (error,\n                             G_FILE_ERROR,\n                             g_file_error_from_errno (errno),\n                             _(\"Failed to write to temporary file when loading TIFF image\"));\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}",
        "target": 1
    },
    {
        "func": "gdk_pixbuf_loader_write (GdkPixbufLoader *loader,\n\t\t\t const guchar    *buf,\n\t\t\t gsize            count,\n                         GError         **error)\n{\n  GdkPixbufLoaderPrivate *priv;\n  \n  g_return_val_if_fail (loader != NULL, FALSE);\n  g_return_val_if_fail (GDK_IS_PIXBUF_LOADER (loader), FALSE);\n  \n  g_return_val_if_fail (buf != NULL, FALSE);\n  g_return_val_if_fail (count >= 0, FALSE);\n  \n  priv = loader->priv;\n  \n  /* we expect it's not to be closed */\n  g_return_val_if_fail (priv->closed == FALSE, FALSE);\n  \n  if (priv->image_module == NULL)\n    {\n      gint eaten;\n      \n      eaten = gdk_pixbuf_loader_eat_header_write (loader, buf, count, error);\n      if (eaten <= 0)\n\treturn FALSE;\n      \n      count -= eaten;\n      buf += eaten;\n    }\n  \n  if (count > 0 && priv->image_module->load_increment)\n    {\n      gboolean retval;\n      retval = priv->image_module->load_increment (priv->context, buf, count,\n                                                   error);\n      if (!retval && error && *error == NULL)\n        {\n          /* Fix up busted image loader */\n          g_warning (\"Bug! loader '%s' didn't set an error on failure\",\n                     priv->image_module->module_name);\n          g_set_error (error,\n                       GDK_PIXBUF_ERROR,\n                       GDK_PIXBUF_ERROR_FAILED,\n                       _(\"Internal error: Image loader module '%s'\"\n                         \" failed to begin loading an image, but didn't\"\n                         \" give a reason for the failure\"),\n                       priv->image_module->module_name);\n        }\n\n      return retval;\n    }\n      \n  return TRUE;\n}",
        "target": 1
    },
    {
        "func": "gdk_pixbuf__gif_image_begin_load (ModulePreparedNotifyFunc prepare_func,\n\t\t\t\t  ModuleUpdatedNotifyFunc update_func,\n\t\t\t\t  gpointer user_data,\n                                  GError **error)\n{\n\tGifContext *context;\n\n#ifdef IO_GIFDEBUG\n\tcount = 0;\n#endif\n\tcontext = new_context ();\n        context->error = error;\n\tcontext->prepare_func = prepare_func;\n\tcontext->update_func = update_func;\n\tcontext->user_data = user_data;\n\n\treturn (gpointer) context;\n}",
        "target": 1
    },
    {
        "func": "gdk_pixbuf__gif_image_load (FILE *file, GError **error)\n{\n\tGifContext *context;\n\tGdkPixbuf *pixbuf;\n\n\tg_return_val_if_fail (file != NULL, NULL);\n\n\tcontext = new_context ();\n\tcontext->file = file;\n        context->error = error;\n        \n\tif (gif_main_loop (context) == -1 || context->animation->frames == NULL) {\n                if (context->error && *(context->error) == NULL)\n                        g_set_error (context->error,\n                                     GDK_PIXBUF_ERROR,\n                                     GDK_PIXBUF_ERROR_CORRUPT_IMAGE,\n                                     _(\"GIF file was missing some data (perhaps it was truncated somehow?)\"));\n        }\n        \n        pixbuf = gdk_pixbuf_animation_get_static_image (GDK_PIXBUF_ANIMATION (context->animation));\n\n        if (pixbuf)\n                g_object_ref (G_OBJECT (pixbuf));\n\n        g_object_unref (G_OBJECT (context->animation));\n        \n        g_free (context->buf);\n\tg_free (context);\n \n\treturn pixbuf;\n}",
        "target": 1
    },
    {
        "func": "gdk_pixbuf__png_image_save (FILE          *f, \n                            GdkPixbuf     *pixbuf, \n                            gchar        **keys,\n                            gchar        **values,\n                            GError       **error)\n{\n       png_structp png_ptr;\n       png_infop info_ptr;\n       guchar *ptr;\n       guchar *pixels;\n       int x, y, j;\n       png_bytep row_ptr, data = NULL;\n       png_color_8 sig_bit;\n       int w, h, rowstride;\n       int has_alpha;\n       int bpc;\n\n       if (keys && *keys) {\n               g_warning (\"Bad option name '%s' passed to PNG saver\",\n                          *keys);\n               return FALSE;\n#if 0\n               gchar **kiter = keys;\n               gchar **viter = values;\n\n               \n               while (*kiter) {\n                       \n                       ++kiter;\n                       ++viter;\n               }\n#endif\n       }\n       \n       bpc = gdk_pixbuf_get_bits_per_sample (pixbuf);\n       w = gdk_pixbuf_get_width (pixbuf);\n       h = gdk_pixbuf_get_height (pixbuf);\n       rowstride = gdk_pixbuf_get_rowstride (pixbuf);\n       has_alpha = gdk_pixbuf_get_has_alpha (pixbuf);\n       pixels = gdk_pixbuf_get_pixels (pixbuf);\n\n       png_ptr = png_create_write_struct (PNG_LIBPNG_VER_STRING,\n                                          error,\n                                          png_simple_error_callback,\n                                          png_simple_warning_callback);\n\n       g_return_val_if_fail (png_ptr != NULL, FALSE);\n\n       info_ptr = png_create_info_struct (png_ptr);\n       if (info_ptr == NULL) {\n               png_destroy_write_struct (&png_ptr, (png_infopp) NULL);\n               return FALSE;\n       }\n       if (setjmp (png_ptr->jmpbuf)) {\n               png_destroy_write_struct (&png_ptr, (png_infopp) NULL);\n               return FALSE;\n       }\n       png_init_io (png_ptr, f);\n       if (has_alpha) {\n               png_set_IHDR (png_ptr, info_ptr, w, h, bpc,\n                             PNG_COLOR_TYPE_RGB_ALPHA, PNG_INTERLACE_NONE,\n                             PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);\n#ifdef WORDS_BIGENDIAN\n               png_set_swap_alpha (png_ptr);\n#else\n               png_set_bgr (png_ptr);\n#endif\n       } else {\n               png_set_IHDR (png_ptr, info_ptr, w, h, bpc,\n                             PNG_COLOR_TYPE_RGB, PNG_INTERLACE_NONE,\n                             PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);\n               data = g_try_malloc (w * 3 * sizeof (char));\n\n               if (data == NULL) {\n                       /* Check error NULL, normally this would be broken,\n                        * but libpng makes me want to code defensively.\n                        */\n                       if (error && *error == NULL) {\n                               g_set_error (error,\n                                            GDK_PIXBUF_ERROR,\n                                            GDK_PIXBUF_ERROR_INSUFFICIENT_MEMORY,\n                                            _(\"Insufficient memory to save PNG file\"));\n                       }\n                       png_destroy_write_struct (&png_ptr, (png_infopp) NULL);\n                       return FALSE;\n               }\n       }\n       sig_bit.red = bpc;\n       sig_bit.green = bpc;\n       sig_bit.blue = bpc;\n       sig_bit.alpha = bpc;\n       png_set_sBIT (png_ptr, info_ptr, &sig_bit);\n       png_write_info (png_ptr, info_ptr);\n       png_set_shift (png_ptr, &sig_bit);\n       png_set_packing (png_ptr);\n\n       ptr = pixels;\n       for (y = 0; y < h; y++) {\n               if (has_alpha)\n                       row_ptr = (png_bytep)ptr;\n               else {\n                       for (j = 0, x = 0; x < w; x++)\n                               memcpy (&(data[x*3]), &(ptr[x*3]), 3);\n\n                       row_ptr = (png_bytep)data;\n               }\n               png_write_rows (png_ptr, &row_ptr, 1);\n               ptr += rowstride;\n       }\n\n       if (data)\n               g_free (data);\n\n       png_write_end (png_ptr, info_ptr);\n       png_destroy_write_struct (&png_ptr, (png_infopp) NULL);\n\n       return TRUE;\n}",
        "target": 1
    },
    {
        "func": "new_context (void)\n{\n\tGifContext *context;\n\n\tcontext = g_new0 (GifContext, 1);\n\n        context->animation = g_object_new (GDK_TYPE_PIXBUF_GIF_ANIM, NULL);        \n\tcontext->frame = NULL;\n\tcontext->file = NULL;\n\tcontext->state = GIF_START;\n\tcontext->prepare_func = NULL;\n\tcontext->update_func = NULL;\n\tcontext->user_data = NULL;\n\tcontext->buf = NULL;\n\tcontext->amount_needed = 0;\n\tcontext->gif89.transparent = -1;\n\tcontext->gif89.delay_time = -1;\n\tcontext->gif89.input_flag = -1;\n\tcontext->gif89.disposal = -1;\n\n\treturn context;\n}",
        "target": 1
    },
    {
        "func": "gdk_pixbuf__gif_image_load_increment (gpointer data,\n                                      const guchar *buf, guint size,\n                                      GError **error)\n{\n\tgint retval;\n\tGifContext *context = (GifContext *) data;\n\n        context->error = error;\n        \n\tif (context->amount_needed == 0) {\n\t\t/* we aren't looking for some bytes. */\n\t\t/* we can use buf now, but we don't want to keep it around at all.\n\t\t * it will be gone by the end of the call. */\n\t\tcontext->buf = (guchar*) buf; /* very dubious const cast */\n\t\tcontext->ptr = 0;\n\t\tcontext->size = size;\n\t} else {\n\t\t/* we need some bytes */\n\t\tif (size < context->amount_needed) {\n\t\t\tcontext->amount_needed -= size;\n\t\t\t/* copy it over and return */\n\t\t\tmemcpy (context->buf + context->size, buf, size);\n\t\t\tcontext->size += size;\n\t\t\treturn TRUE;\n\t\t} else if (size == context->amount_needed) {\n\t\t\tmemcpy (context->buf + context->size, buf, size);\n\t\t\tcontext->size += size;\n\t\t} else {\n\t\t\tcontext->buf = g_realloc (context->buf, context->size + size);\n\t\t\tmemcpy (context->buf + context->size, buf, size);\n\t\t\tcontext->size += size;\n\t\t}\n\t}\n\n\tretval = gif_main_loop (context);\n\n\tif (retval == -2)\n\t\treturn FALSE;\n\tif (retval == -1) {\n\t\t/* we didn't have enough memory */\n\t\t/* prepare for the next image_load_increment */\n\t\tif (context->buf == buf) {\n\t\t\tg_assert (context->size == size);\n\t\t\tcontext->buf = (guchar *)g_new (guchar, context->amount_needed + (context->size - context->ptr));\n\t\t\tmemcpy (context->buf, buf + context->ptr, context->size - context->ptr);\n\t\t} else {\n\t\t\t/* copy the left overs to the begining of the buffer */\n\t\t\t/* and realloc the memory */\n\t\t\tmemmove (context->buf, context->buf + context->ptr, context->size - context->ptr);\n\t\t\tcontext->buf = g_realloc (context->buf, context->amount_needed + (context->size - context->ptr));\n\t\t}\n\t\tcontext->size = context->size - context->ptr;\n\t\tcontext->ptr = 0;\n\t} else {\n\t\t/* we are prolly all done */\n\t\tif (context->buf == buf)\n\t\t\tcontext->buf = NULL;\n\t}\n\treturn TRUE;\n}",
        "target": 1
    },
    {
        "func": "gdk_pixbuf__tiff_image_stop_load (gpointer data,\n                                  GError **error)\n{\n\tTiffData *context = (TiffData*) data;\n        gboolean retval = FALSE;\n        \n\tg_return_val_if_fail (data != NULL, TRUE);\n\n\tfflush (context->file);\n\trewind (context->file);\n\tif (context->all_okay) {\n                GdkPixbuf *pixbuf;\n\t\tpixbuf = gdk_pixbuf__tiff_image_load_real (context->file, context, error);\n                if (pixbuf != NULL)\n                        retval = TRUE;\n        }\n\n\tfclose (context->file);\n\tunlink (context->tempname);\n\tg_free (context->tempname);\n\tg_free ((TiffData *) context);\n\n        return TRUE;\n}",
        "target": 1
    },
    {
        "func": "gif_prepare_lzw (GifContext *context)\n{\n\tgint i;\n\n\tif (!gif_read (context, &(context->lzw_set_code_size), 1)) {\n\t\t/*g_message (_(\"GIF: EOF / read error on image data\\n\"));*/\n\t\treturn -1;\n\t}\n\n\tcontext->lzw_code_size = context->lzw_set_code_size + 1;\n\tcontext->lzw_clear_code = 1 << context->lzw_set_code_size;\n\tcontext->lzw_end_code = context->lzw_clear_code + 1;\n\tcontext->lzw_max_code_size = 2 * context->lzw_clear_code;\n\tcontext->lzw_max_code = context->lzw_clear_code + 2;\n\tcontext->lzw_fresh = TRUE;\n\tcontext->code_curbit = 0;\n\tcontext->code_lastbit = 0;\n\tcontext->code_last_byte = 0;\n\tcontext->code_done = FALSE;\n\n\tfor (i = 0; i < context->lzw_clear_code; ++i) {\n\t\tcontext->lzw_table[0][i] = 0;\n\t\tcontext->lzw_table[1][i] = i;\n\t}\n\tfor (; i < (1 << MAX_LZW_BITS); ++i)\n\t\tcontext->lzw_table[0][i] = context->lzw_table[1][0] = 0;\n\n\tcontext->lzw_sp = context->lzw_stack;\n\tgif_set_get_lzw (context);\n\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "load_image (gchar *filename)\n{\n  FILE *fd;\n  char * name_buf;\n  unsigned char buf[16];\n  unsigned char c;\n  CMap localColorMap;\n  int grayScale;\n  int useGlobalColormap;\n  int bitPixel;\n  int imageCount = 0;\n  char version[4];\n  gint32 image_ID = -1;\n\n  fd = fopen (filename, \"rb\");\n  if (!fd)\n    {\n      g_message (\"GIF: can't open \\\"%s\\\"\\n\", filename);\n      return -1;\n    }\n\n  if (run_mode != GIMP_RUN_NONINTERACTIVE)\n    {\n      name_buf = g_strdup_printf (_(\"Loading %s:\"), filename);\n      gimp_progress_init (name_buf);\n      g_free (name_buf);\n    }\n\n  if (!ReadOK (fd, buf, 6))\n    {\n      g_message (\"GIF: error reading magic number\\n\");\n      return -1;\n    }\n\n  if (strncmp ((char *) buf, \"GIF\", 3) != 0)\n    {\n      g_message (\"GIF: not a GIF file\\n\");\n      return -1;\n    }\n\n  strncpy (version, (char *) buf + 3, 3);\n  version[3] = '\\0';\n\n  if ((strcmp (version, \"87a\") != 0) && (strcmp (version, \"89a\") != 0))\n    {\n      g_message (\"GIF: bad version number, not '87a' or '89a'\\n\");\n      return -1;\n    }\n\n  if (!ReadOK (fd, buf, 7))\n    {\n      g_message (\"GIF: failed to read screen descriptor\\n\");\n      return -1;\n    }\n\n  GifScreen.Width = LM_to_uint (buf[0], buf[1]);\n  GifScreen.Height = LM_to_uint (buf[2], buf[3]);\n  GifScreen.BitPixel = 2 << (buf[4] & 0x07);\n  GifScreen.ColorResolution = (((buf[4] & 0x70) >> 3) + 1);\n  GifScreen.Background = buf[5];\n  GifScreen.AspectRatio = buf[6];\n\n  if (BitSet (buf[4], LOCALCOLORMAP))\n    {\n      /* Global Colormap */\n      if (ReadColorMap (fd, GifScreen.BitPixel, GifScreen.ColorMap, &GifScreen.GrayScale))\n\t{\n\t  g_message (\"GIF: error reading global colormap\\n\");\n\t  return -1;\n\t}\n    }\n\n  if (GifScreen.AspectRatio != 0 && GifScreen.AspectRatio != 49)\n    {\n      g_message (\"GIF: warning - non-square pixels\\n\");\n    }\n\n\n  highest_used_index = 0;\n      \n\n  for (;;)\n    {\n      if (!ReadOK (fd, &c, 1))\n\t{\n\t  g_message (\"GIF: EOF / read error on image data\\n\");\n\t  return image_ID; /* will be -1 if failed on first image! */\n\t}\n\n      if (c == ';')\n\t{\n\t  /* GIF terminator */\n\t  return image_ID;\n\t}\n\n      if (c == '!')\n\t{\n\t  /* Extension */\n\t  if (!ReadOK (fd, &c, 1))\n\t    {\n\t      g_message (\"GIF: EOF / read error on extension function code\\n\");\n\t      return image_ID; /* will be -1 if failed on first image! */\n\t    }\n\t  DoExtension (fd, c);\n\t  continue;\n\t}\n\n      if (c != ',')\n\t{\n\t  /* Not a valid start character */\n\t  g_warning (\"GIF: bogus character 0x%02x, ignoring\\n\", (int) c);\n\t  continue;\n\t}\n\n      ++imageCount;\n\n      if (!ReadOK (fd, buf, 9))\n\t{\n\t  g_message (\"GIF: couldn't read left/top/width/height\\n\");\n\t  return image_ID; /* will be -1 if failed on first image! */\n\t}\n\n      useGlobalColormap = !BitSet (buf[8], LOCALCOLORMAP);\n\n      bitPixel = 1 << ((buf[8] & 0x07) + 1);\n\n      if (!useGlobalColormap)\n\t{\n\t  if (ReadColorMap (fd, bitPixel, localColorMap, &grayScale))\n\t    {\n\t      g_message (\"GIF: error reading local colormap\\n\");\n\t      return image_ID; /* will be -1 if failed on first image! */\n\t    }\n\t  image_ID = ReadImage (fd, filename, LM_to_uint (buf[4], buf[5]),\n\t\t\t\tLM_to_uint (buf[6], buf[7]),\n\t\t\t\tlocalColorMap, bitPixel,\n\t\t\t\tgrayScale,\n\t\t\t\tBitSet (buf[8], INTERLACE), imageCount,\n\t\t\t\t(guint) LM_to_uint (buf[0], buf[1]),\n\t\t\t\t(guint) LM_to_uint (buf[2], buf[3]),\n\t\t\t\tGifScreen.Width,\n\t\t\t\tGifScreen.Height\n\t\t\t\t);\n\t}\n      else\n\t{\n\t  image_ID = ReadImage (fd, filename, LM_to_uint (buf[4], buf[5]),\n\t\t\t\tLM_to_uint (buf[6], buf[7]),\n\t\t\t\tGifScreen.ColorMap, GifScreen.BitPixel,\n\t\t\t\tGifScreen.GrayScale,\n\t\t\t\tBitSet (buf[8], INTERLACE), imageCount,\n\t\t\t\t(guint) LM_to_uint (buf[0], buf[1]),\n\t\t\t\t(guint) LM_to_uint (buf[2], buf[3]),\n\t\t\t\tGifScreen.Width,\n\t\t\t\tGifScreen.Height\n\t\t\t\t);\n\t}\n\n#ifdef FACEHUGGERS\n      if (comment_parasite != NULL)\n\t{\n\t  gimp_image_parasite_attach (image_ID, comment_parasite);\n\t  gimp_parasite_free (comment_parasite);\n\t  comment_parasite = NULL;\n\t}\n#endif\n\n    }\n\n  return image_ID;\n}",
        "target": 1
    },
    {
        "func": "LZWReadByte (FILE *fd,\n\t     int   flag,\n\t     int   input_code_size)\n{\n  static int fresh = FALSE;\n  int code, incode;\n  static int code_size, set_code_size;\n  static int max_code, max_code_size;\n  static int firstcode, oldcode;\n  static int clear_code, end_code;\n  static int table[2][(1 << MAX_LZW_BITS)];\n  static int stack[(1 << (MAX_LZW_BITS)) * 2], *sp;\n  register int i;\n\n  if (flag)\n    {\n      set_code_size = input_code_size;\n      code_size = set_code_size + 1;\n      clear_code = 1 << set_code_size;\n      end_code = clear_code + 1;\n      max_code_size = 2 * clear_code;\n      max_code = clear_code + 2;\n\n      GetCode (fd, 0, TRUE);\n\n      fresh = TRUE;\n\n      for (i = 0; i < clear_code; ++i)\n\t{\n\t  table[0][i] = 0;\n\t  table[1][i] = i;\n\t}\n      for (; i < (1 << MAX_LZW_BITS); ++i)\n\ttable[0][i] = table[1][0] = 0;\n\n      sp = stack;\n\n      return 0;\n    }\n  else if (fresh)\n    {\n      fresh = FALSE;\n      do\n\t{\n\t  firstcode = oldcode =\n\t    GetCode (fd, code_size, FALSE);\n\t}\n      while (firstcode == clear_code);\n      return firstcode;\n    }\n\n  if (sp > stack)\n    return *--sp;\n\n  while ((code = GetCode (fd, code_size, FALSE)) >= 0)\n    {\n      if (code == clear_code)\n\t{\n\t  for (i = 0; i < clear_code; ++i)\n\t    {\n\t      table[0][i] = 0;\n\t      table[1][i] = i;\n\t    }\n\t  for (; i < (1 << MAX_LZW_BITS); ++i)\n\t    table[0][i] = table[1][i] = 0;\n\t  code_size = set_code_size + 1;\n\t  max_code_size = 2 * clear_code;\n\t  max_code = clear_code + 2;\n\t  sp = stack;\n\t  firstcode = oldcode =\n\t    GetCode (fd, code_size, FALSE);\n\t  return firstcode;\n\t}\n      else if (code == end_code)\n\t{\n\t  int count;\n\t  unsigned char buf[260];\n\n\t  if (ZeroDataBlock)\n\t    return -2;\n\n\t  while ((count = GetDataBlock (fd, buf)) > 0)\n\t    ;\n\n\t  if (count != 0)\n\t    g_print (\"GIF: missing EOD in data stream (common occurence)\");\n\t  return -2;\n\t}\n\n      incode = code;\n\n      if (code >= max_code)\n\t{\n\t  *sp++ = firstcode;\n\t  code = oldcode;\n\t}\n\n      while (code >= clear_code)\n\t{\n\t  *sp++ = table[1][code];\n\t  if (code == table[0][code])\n\t    {\n\t      g_message (\"GIF: circular table entry BIG ERROR\\n\");\n\t      gimp_quit ();\n\t    }\n\t  code = table[0][code];\n\t}\n\n      *sp++ = firstcode = table[1][code];\n\n      if ((code = max_code) < (1 << MAX_LZW_BITS))\n\t{\n\t  table[0][code] = oldcode;\n\t  table[1][code] = firstcode;\n\t  ++max_code;\n\t  if ((max_code >= max_code_size) &&\n\t      (max_code_size < (1 << MAX_LZW_BITS)))\n\t    {\n\t      max_code_size *= 2;\n\t      ++code_size;\n\t    }\n\t}\n\n      oldcode = incode;\n\n      if (sp > stack)\n\treturn *--sp;\n    }\n  return code;\n}",
        "target": 1
    },
    {
        "func": "int parseLegacySyslogMsg(msg_t *pMsg, int flags)\n{\n\tuchar *p2parse;\n\tint lenMsg;\n\tint i;\t/* general index for parsing */\n\tuchar bufParseTAG[CONF_TAG_MAXSIZE];\n\tuchar bufParseHOSTNAME[CONF_HOSTNAME_MAXSIZE];\n\tBEGINfunc\n\n\tassert(pMsg != NULL);\n\tassert(pMsg->pszRawMsg != NULL);\n\tlenMsg = pMsg->iLenRawMsg - pMsg->offAfterPRI; /* note: offAfterPRI is already the number of PRI chars (do not add one!) */\n\tp2parse = pMsg->pszRawMsg + pMsg->offAfterPRI; /* point to start of text, after PRI */\n\n\t/* Check to see if msg contains a timestamp. We start by assuming\n\t * that the message timestamp is the time of reception (which we \n\t * generated ourselfs and then try to actually find one inside the\n\t * message. There we go from high-to low precison and are done\n\t * when we find a matching one. -- rgerhards, 2008-09-16\n\t */\n\tif(datetime.ParseTIMESTAMP3339(&(pMsg->tTIMESTAMP), &p2parse, &lenMsg) == RS_RET_OK) {\n\t\t/* we are done - parse pointer is moved by ParseTIMESTAMP3339 */;\n\t} else if(datetime.ParseTIMESTAMP3164(&(pMsg->tTIMESTAMP), &p2parse, &lenMsg) == RS_RET_OK) {\n\t\t/* we are done - parse pointer is moved by ParseTIMESTAMP3164 */;\n\t} else if(*p2parse == ' ' && lenMsg > 1) { /* try to see if it is slighly malformed - HP procurve seems to do that sometimes */\n\t\t++p2parse;\t/* move over space */\n\t\t--lenMsg;\n\t\tif(datetime.ParseTIMESTAMP3164(&(pMsg->tTIMESTAMP), &p2parse, &lenMsg) == RS_RET_OK) {\n\t\t\t/* indeed, we got it! */\n\t\t\t/* we are done - parse pointer is moved by ParseTIMESTAMP3164 */;\n\t\t} else {/* parse pointer needs to be restored, as we moved it off-by-one\n\t\t\t * for this try.\n\t\t\t */\n\t\t\t--p2parse;\n\t\t\t++lenMsg;\n\t\t}\n\t}\n\n\tif(flags & IGNDATE) {\n\t\t/* we need to ignore the msg data, so simply copy over reception date */\n\t\tmemcpy(&pMsg->tTIMESTAMP, &pMsg->tRcvdAt, sizeof(struct syslogTime));\n\t}\n\n\t/* rgerhards, 2006-03-13: next, we parse the hostname and tag. But we \n\t * do this only when the user has not forbidden this. I now introduce some\n\t * code that allows a user to configure rsyslogd to treat the rest of the\n\t * message as MSG part completely. In this case, the hostname will be the\n\t * machine that we received the message from and the tag will be empty. This\n\t * is meant to be an interim solution, but for now it is in the code.\n\t */\n\tif(bParseHOSTNAMEandTAG && !(flags & INTERNAL_MSG)) {\n\t\t/* parse HOSTNAME - but only if this is network-received!\n\t\t * rger, 2005-11-14: we still have a problem with BSD messages. These messages\n\t\t * do NOT include a host name. In most cases, this leads to the TAG to be treated\n\t\t * as hostname and the first word of the message as the TAG. Clearly, this is not\n\t\t * of advantage ;) I think I have now found a way to handle this situation: there\n\t\t * are certain characters which are frequently used in TAG (e.g. ':'), which are\n\t\t * *invalid* in host names. So while parsing the hostname, I check for these characters.\n\t\t * If I find them, I set a simple flag but continue. After parsing, I check the flag.\n\t\t * If it was set, then we most probably do not have a hostname but a TAG. Thus, I change\n\t\t * the fields. I think this logic shall work with any type of syslog message.\n\t\t * rgerhards, 2009-06-23: and I now have extended this logic to every character\n\t\t * that is not a valid hostname.\n\t\t */\n\t\tif(lenMsg > 0 && flags & PARSE_HOSTNAME) {\n\t\t\ti = 0;\n\t\t\twhile(i < lenMsg && (isalnum(p2parse[i]) || p2parse[i] == '.' || p2parse[i] == '.'\n\t\t\t\t|| p2parse[i] == '_' || p2parse[i] == '-') && i < (CONF_HOSTNAME_MAXSIZE - 1)) {\n\t\t\t\tbufParseHOSTNAME[i] = p2parse[i];\n\t\t\t\t++i;\n\t\t\t}\n\n\t\t\tif(i == lenMsg) {\n\t\t\t\t/* we have a message that is empty immediately after the hostname,\n\t\t\t\t * but the hostname thus is valid! -- rgerhards, 2010-02-22\n\t\t\t\t */\n\t\t\t\tp2parse += i;\n\t\t\t\tlenMsg -= i;\n\t\t\t\tbufParseHOSTNAME[i] = '\\0';\n\t\t\t\tMsgSetHOSTNAME(pMsg, bufParseHOSTNAME, i);\n\t\t\t} else if(i > 0 && p2parse[i] == ' ' && isalnum(p2parse[i-1])) {\n\t\t\t\t/* we got a hostname! */\n\t\t\t\tp2parse += i + 1; /* \"eat\" it (including SP delimiter) */\n\t\t\t\tlenMsg -= i + 1;\n\t\t\t\tbufParseHOSTNAME[i] = '\\0';\n\t\t\t\tMsgSetHOSTNAME(pMsg, bufParseHOSTNAME, i);\n\t\t\t}\n\t\t}\n\n\t\t/* now parse TAG - that should be present in message from all sources.\n\t\t * This code is somewhat not compliant with RFC 3164. As of 3164,\n\t\t * the TAG field is ended by any non-alphanumeric character. In\n\t\t * practice, however, the TAG often contains dashes and other things,\n\t\t * which would end the TAG. So it is not desirable. As such, we only\n\t\t * accept colon and SP to be terminators. Even there is a slight difference:\n\t\t * a colon is PART of the TAG, while a SP is NOT part of the tag\n\t\t * (it is CONTENT). Starting 2008-04-04, we have removed the 32 character\n\t\t * size limit (from RFC3164) on the tag. This had bad effects on existing\n\t\t * envrionments, as sysklogd didn't obey it either (probably another bug\n\t\t * in RFC3164...). We now receive the full size, but will modify the\n\t\t * outputs so that only 32 characters max are used by default.\n\t\t */\n\t\ti = 0;\n\t\twhile(lenMsg > 0 && *p2parse != ':' && *p2parse != ' ' && i < CONF_TAG_MAXSIZE) {\n\t\t\tbufParseTAG[i++] = *p2parse++;\n\t\t\t--lenMsg;\n\t\t}\n\t\tif(lenMsg > 0 && *p2parse == ':') {\n\t\t\t++p2parse; \n\t\t\t--lenMsg;\n\t\t\tbufParseTAG[i++] = ':';\n\t\t}\n\n\t\t/* no TAG can only be detected if the message immediatly ends, in which case an empty TAG\n\t\t * is considered OK. So we do not need to check for empty TAG. -- rgerhards, 2009-06-23\n\t\t */\n\t\tbufParseTAG[i] = '\\0';\t/* terminate string */\n\t\tMsgSetTAG(pMsg, bufParseTAG, i);\n\t} else {/* we enter this code area when the user has instructed rsyslog NOT\n\t\t * to parse HOSTNAME and TAG - rgerhards, 2006-03-13\n\t\t */\n\t\tif(!(flags & INTERNAL_MSG)) {\n\t\t\tDBGPRINTF(\"HOSTNAME and TAG not parsed by user configuraton.\\n\");\n\t\t}\n\t}\n\n\t/* The rest is the actual MSG */\n\tMsgSetMSGoffs(pMsg, p2parse - pMsg->pszRawMsg);\n\n\tENDfunc\n\treturn 0; /* all ok */\n}",
        "target": 1
    },
    {
        "func": "LZWReadByte (FILE *fd,\n             gint  just_reset_LZW,\n             gint  input_code_size)\n{\n  static gint fresh = FALSE;\n  gint        code, incode;\n  static gint code_size, set_code_size;\n  static gint max_code, max_code_size;\n  static gint firstcode, oldcode;\n  static gint clear_code, end_code;\n  static gint table[2][(1 << MAX_LZW_BITS)];\n  static gint stack[(1 << (MAX_LZW_BITS)) * 2], *sp;\n  gint        i;\n\n  if (just_reset_LZW)\n    {\n      if (input_code_size > MAX_LZW_BITS)\n        {\n          g_message (\"Value out of range for code size (corrupted file?)\");\n          return -1;\n        }\n\n      set_code_size = input_code_size;\n      code_size     = set_code_size + 1;\n      clear_code    = 1 << set_code_size;\n      end_code      = clear_code + 1;\n      max_code_size = 2 * clear_code;\n      max_code      = clear_code + 2;\n\n      GetCode (fd, 0, TRUE);\n\n      fresh = TRUE;\n\n      sp = stack;\n\n      for (i = 0; i < clear_code; ++i)\n        {\n          table[0][i] = 0;\n          table[1][i] = i;\n        }\n      for (; i < (1 << MAX_LZW_BITS); ++i)\n        {\n          table[0][i] = 0;\n          table[1][i] = 0;\n        }\n\n      return 0;\n    }\n  else if (fresh)\n    {\n      fresh = FALSE;\n      do\n        {\n          firstcode = oldcode = GetCode (fd, code_size, FALSE);\n        }\n      while (firstcode == clear_code);\n\n      return firstcode & 255;\n    }\n\n  if (sp > stack)\n    return (*--sp) & 255;\n\n  while ((code = GetCode (fd, code_size, FALSE)) >= 0)\n    {\n      if (code == clear_code)\n        {\n          for (i = 0; i < clear_code; ++i)\n            {\n              table[0][i] = 0;\n              table[1][i] = i;\n            }\n          for (; i < (1 << MAX_LZW_BITS); ++i)\n            {\n              table[0][i] = 0;\n              table[1][i] = 0;\n            }\n\n          code_size     = set_code_size + 1;\n          max_code_size = 2 * clear_code;\n          max_code      = clear_code + 2;\n          sp            = stack;\n          firstcode     = oldcode = GetCode (fd, code_size, FALSE);\n\n          return firstcode & 255;\n        }\n      else if (code == end_code)\n        {\n          gint   count;\n          guchar buf[260];\n\n          if (ZeroDataBlock)\n            return -2;\n\n          while ((count = GetDataBlock (fd, buf)) > 0)\n            ;\n\n          if (count != 0)\n            g_print (\"GIF: missing EOD in data stream (common occurence)\");\n\n          return -2;\n        }\n\n      incode = code;\n\n      if (code >= max_code)\n        {\n          *sp++ = firstcode;\n          code = oldcode;\n        }\n\n      while (code >= clear_code)\n        {\n          *sp++ = table[1][code];\n          if (code == table[0][code])\n            {\n              g_message (\"Circular table entry.  Corrupt file.\");\n              gimp_quit ();\n            }\n          code = table[0][code];\n        }\n\n      *sp++ = firstcode = table[1][code];\n\n      if ((code = max_code) < (1 << MAX_LZW_BITS))\n        {\n          table[0][code] = oldcode;\n          table[1][code] = firstcode;\n          ++max_code;\n          if ((max_code >= max_code_size) &&\n              (max_code_size < (1 << MAX_LZW_BITS)))\n            {\n              max_code_size *= 2;\n              ++code_size;\n            }\n        }\n\n      oldcode = incode;\n\n      if (sp > stack)\n        return (*--sp) & 255;\n    }\n\n  return code & 255;\n}",
        "target": 1
    },
    {
        "func": "ssize_t tpm_write(struct file *file, const char __user *buf,\n\t\t  size_t size, loff_t *off)\n{\n\tstruct tpm_chip *chip = file->private_data;\n\tsize_t in_size = size, out_size;\n\n\t/* cannot perform a write until the read has cleared\n\t   either via tpm_read or a user_read_timer timeout */\n\twhile (atomic_read(&chip->data_pending) != 0)\n\t\tmsleep(TPM_TIMEOUT);\n\n\tmutex_lock(&chip->buffer_mutex);\n\n\tif (in_size > TPM_BUFSIZE)\n\t\tin_size = TPM_BUFSIZE;\n\n\tif (copy_from_user\n\t    (chip->data_buffer, (void __user *) buf, in_size)) {\n\t\tmutex_unlock(&chip->buffer_mutex);\n\t\treturn -EFAULT;\n\t}\n\n\t/* atomic tpm command send and result receive */\n\tout_size = tpm_transmit(chip, chip->data_buffer, TPM_BUFSIZE);\n\n\tatomic_set(&chip->data_pending, out_size);\n\tmutex_unlock(&chip->buffer_mutex);\n\n\t/* Set a timeout by which the reader must come claim the result */\n\tmod_timer(&chip->user_read_timer, jiffies + (60 * HZ));\n\n\treturn in_size;\n}",
        "target": 1
    },
    {
        "func": "static ssize_t tpm_transmit(struct tpm_chip *chip, const char *buf,\n\t\t\t    size_t bufsiz)\n{\n\tssize_t rc;\n\tu32 count, ordinal;\n\tunsigned long stop;\n\n\tcount = be32_to_cpu(*((__be32 *) (buf + 2)));\n\tordinal = be32_to_cpu(*((__be32 *) (buf + 6)));\n\tif (count == 0)\n\t\treturn -ENODATA;\n\tif (count > bufsiz) {\n\t\tdev_err(chip->dev,\n\t\t\t\"invalid count value %x %zx \\n\", count, bufsiz);\n\t\treturn -E2BIG;\n\t}\n\n\tmutex_lock(&chip->tpm_mutex);\n\n\tif ((rc = chip->vendor.send(chip, (u8 *) buf, count)) < 0) {\n\t\tdev_err(chip->dev,\n\t\t\t\"tpm_transmit: tpm_send: error %zd\\n\", rc);\n\t\tgoto out;\n\t}\n\n\tif (chip->vendor.irq)\n\t\tgoto out_recv;\n\n\tstop = jiffies + tpm_calc_ordinal_duration(chip, ordinal);\n\tdo {\n\t\tu8 status = chip->vendor.status(chip);\n\t\tif ((status & chip->vendor.req_complete_mask) ==\n\t\t    chip->vendor.req_complete_val)\n\t\t\tgoto out_recv;\n\n\t\tif ((status == chip->vendor.req_canceled)) {\n\t\t\tdev_err(chip->dev, \"Operation Canceled\\n\");\n\t\t\trc = -ECANCELED;\n\t\t\tgoto out;\n\t\t}\n\n\t\tmsleep(TPM_TIMEOUT);\t/* CHECK */\n\t\trmb();\n\t} while (time_before(jiffies, stop));\n\n\tchip->vendor.cancel(chip);\n\tdev_err(chip->dev, \"Operation Timed out\\n\");\n\trc = -ETIME;\n\tgoto out;\n\nout_recv:\n\trc = chip->vendor.recv(chip, (u8 *) buf, bufsiz);\n\tif (rc < 0)\n\t\tdev_err(chip->dev,\n\t\t\t\"tpm_transmit: tpm_recv: error %zd\\n\", rc);\nout:\n\tmutex_unlock(&chip->tpm_mutex);\n\treturn rc;\n}",
        "target": 1
    },
    {
        "func": "ssize_t tpm_read(struct file *file, char __user *buf,\n\t\t size_t size, loff_t *off)\n{\n\tstruct tpm_chip *chip = file->private_data;\n\tssize_t ret_size;\n\n\tdel_singleshot_timer_sync(&chip->user_read_timer);\n\tflush_work_sync(&chip->work);\n\tret_size = atomic_read(&chip->data_pending);\n\tatomic_set(&chip->data_pending, 0);\n\tif (ret_size > 0) {\t/* relay data */\n\t\tif (size < ret_size)\n\t\t\tret_size = size;\n\n\t\tmutex_lock(&chip->buffer_mutex);\n\t\tif (copy_to_user(buf, chip->data_buffer, ret_size))\n\t\t\tret_size = -EFAULT;\n\t\tmutex_unlock(&chip->buffer_mutex);\n\t}\n\n\treturn ret_size;\n}",
        "target": 1
    },
    {
        "func": "jiffies_to_timespec(const unsigned long jiffies, struct timespec *value)\n{\n\t/*\n\t * Convert jiffies to nanoseconds and separate with\n\t * one divide.\n\t */\n\tu64 nsec = (u64)jiffies * TICK_NSEC;\n\tvalue->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &value->tv_nsec);\n}",
        "target": 1
    },
    {
        "func": "jiffies_to_compat_timeval(unsigned long jiffies, struct compat_timeval *value)\n{\n\t/*\n\t * Convert jiffies to nanoseconds and separate with\n\t * one divide.\n\t */\n\tu64 nsec = (u64)jiffies * TICK_NSEC;\n\tlong rem;\n\tvalue->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &rem);\n\tvalue->tv_usec = rem / NSEC_PER_USEC;\n}",
        "target": 1
    },
    {
        "func": "static inline unsigned long do_div_llr(const long long dividend,\n\t\t\t\t       const long divisor, long *remainder)\n{\n\tu64 result = dividend;\n\n\t*(remainder) = do_div(result, divisor);\n\treturn (unsigned long) result;\n}",
        "target": 1
    },
    {
        "func": "static void sgi_timer_get(struct k_itimer *timr, struct itimerspec *cur_setting)\n{\n\n\tif (timr->it.mmtimer.clock == TIMER_OFF) {\n\t\tcur_setting->it_interval.tv_nsec = 0;\n\t\tcur_setting->it_interval.tv_sec = 0;\n\t\tcur_setting->it_value.tv_nsec = 0;\n\t\tcur_setting->it_value.tv_sec =0;\n\t\treturn;\n\t}\n\n\tns_to_timespec(cur_setting->it_interval, timr->it.mmtimer.incr * sgi_clock_period);\n\tns_to_timespec(cur_setting->it_value, (timr->it.mmtimer.expires - rtc_time())* sgi_clock_period);\n\treturn;\n}",
        "target": 1
    },
    {
        "func": "static int sgi_clock_get(clockid_t clockid, struct timespec *tp)\n{\n\tu64 nsec;\n\n\tnsec = rtc_time() * sgi_clock_period\n\t\t\t+ sgi_clock_offset.tv_nsec;\n\ttp->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &tp->tv_nsec)\n\t\t\t+ sgi_clock_offset.tv_sec;\n\treturn 0;\n};",
        "target": 1
    },
    {
        "func": "int do_adjtimex(struct timex *txc)\n{\n\tlong mtemp, save_adjust, rem;\n\ts64 freq_adj;\n\tint result;\n\n\t/* In order to modify anything, you gotta be super-user! */\n\tif (txc->modes && !capable(CAP_SYS_TIME))\n\t\treturn -EPERM;\n\n\t/* Now we validate the data before disabling interrupts */\n\n\tif ((txc->modes & ADJ_OFFSET_SINGLESHOT) == ADJ_OFFSET_SINGLESHOT) {\n\t  /* singleshot must not be used with any other mode bits */\n\t\tif (txc->modes != ADJ_OFFSET_SINGLESHOT &&\n\t\t\t\t\ttxc->modes != ADJ_OFFSET_SS_READ)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (txc->modes != ADJ_OFFSET_SINGLESHOT && (txc->modes & ADJ_OFFSET))\n\t  /* adjustment Offset limited to +- .512 seconds */\n\t\tif (txc->offset <= - MAXPHASE || txc->offset >= MAXPHASE )\n\t\t\treturn -EINVAL;\n\n\t/* if the quartz is off by more than 10% something is VERY wrong ! */\n\tif (txc->modes & ADJ_TICK)\n\t\tif (txc->tick <  900000/USER_HZ ||\n\t\t    txc->tick > 1100000/USER_HZ)\n\t\t\treturn -EINVAL;\n\n\twrite_seqlock_irq(&xtime_lock);\n\tresult = time_state;\t/* mostly `TIME_OK' */\n\n\t/* Save for later - semantics of adjtime is to return old value */\n\tsave_adjust = time_adjust;\n\n#if 0\t/* STA_CLOCKERR is never set yet */\n\ttime_status &= ~STA_CLOCKERR;\t\t/* reset STA_CLOCKERR */\n#endif\n\t/* If there are input parameters, then process them */\n\tif (txc->modes)\n\t{\n\t    if (txc->modes & ADJ_STATUS)\t/* only set allowed bits */\n\t\ttime_status =  (txc->status & ~STA_RONLY) |\n\t\t\t      (time_status & STA_RONLY);\n\n\t    if (txc->modes & ADJ_FREQUENCY) {\t/* p. 22 */\n\t\tif (txc->freq > MAXFREQ || txc->freq < -MAXFREQ) {\n\t\t    result = -EINVAL;\n\t\t    goto leave;\n\t\t}\n\t\ttime_freq = ((s64)txc->freq * NSEC_PER_USEC)\n\t\t\t\t>> (SHIFT_USEC - SHIFT_NSEC);\n\t    }\n\n\t    if (txc->modes & ADJ_MAXERROR) {\n\t\tif (txc->maxerror < 0 || txc->maxerror >= NTP_PHASE_LIMIT) {\n\t\t    result = -EINVAL;\n\t\t    goto leave;\n\t\t}\n\t\ttime_maxerror = txc->maxerror;\n\t    }\n\n\t    if (txc->modes & ADJ_ESTERROR) {\n\t\tif (txc->esterror < 0 || txc->esterror >= NTP_PHASE_LIMIT) {\n\t\t    result = -EINVAL;\n\t\t    goto leave;\n\t\t}\n\t\ttime_esterror = txc->esterror;\n\t    }\n\n\t    if (txc->modes & ADJ_TIMECONST) {\t/* p. 24 */\n\t\tif (txc->constant < 0) {\t/* NTP v4 uses values > 6 */\n\t\t    result = -EINVAL;\n\t\t    goto leave;\n\t\t}\n\t\ttime_constant = min(txc->constant + 4, (long)MAXTC);\n\t    }\n\n\t    if (txc->modes & ADJ_OFFSET) {\t/* values checked earlier */\n\t\tif (txc->modes == ADJ_OFFSET_SINGLESHOT) {\n\t\t    /* adjtime() is independent from ntp_adjtime() */\n\t\t    time_adjust = txc->offset;\n\t\t}\n\t\telse if (time_status & STA_PLL) {\n\t\t    time_offset = txc->offset * NSEC_PER_USEC;\n\n\t\t    /*\n\t\t     * Scale the phase adjustment and\n\t\t     * clamp to the operating range.\n\t\t     */\n\t\t    time_offset = min(time_offset, (s64)MAXPHASE * NSEC_PER_USEC);\n\t\t    time_offset = max(time_offset, (s64)-MAXPHASE * NSEC_PER_USEC);\n\n\t\t    /*\n\t\t     * Select whether the frequency is to be controlled\n\t\t     * and in which mode (PLL or FLL). Clamp to the operating\n\t\t     * range. Ugly multiply/divide should be replaced someday.\n\t\t     */\n\n\t\t    if (time_status & STA_FREQHOLD || time_reftime == 0)\n\t\t        time_reftime = xtime.tv_sec;\n\t\t    mtemp = xtime.tv_sec - time_reftime;\n\t\t    time_reftime = xtime.tv_sec;\n\n\t\t    freq_adj = time_offset * mtemp;\n\t\t    freq_adj = shift_right(freq_adj, time_constant * 2 +\n\t\t\t\t\t   (SHIFT_PLL + 2) * 2 - SHIFT_NSEC);\n\t\t    if (mtemp >= MINSEC && (time_status & STA_FLL || mtemp > MAXSEC))\n\t\t\tfreq_adj += div_s64(time_offset << (SHIFT_NSEC - SHIFT_FLL), mtemp);\n\t\t    freq_adj += time_freq;\n\t\t    freq_adj = min(freq_adj, (s64)MAXFREQ_NSEC);\n\t\t    time_freq = max(freq_adj, (s64)-MAXFREQ_NSEC);\n\t\t    time_offset = div_long_long_rem_signed(time_offset,\n\t\t\t\t\t\t\t   NTP_INTERVAL_FREQ,\n\t\t\t\t\t\t\t   &rem);\n\t\t    time_offset <<= SHIFT_UPDATE;\n\t\t} /* STA_PLL */\n\t    } /* txc->modes & ADJ_OFFSET */\n\t    if (txc->modes & ADJ_TICK)\n\t\ttick_usec = txc->tick;\n\n\t    if (txc->modes & (ADJ_TICK|ADJ_FREQUENCY|ADJ_OFFSET))\n\t\t    ntp_update_frequency();\n\t} /* txc->modes */\nleave:\tif ((time_status & (STA_UNSYNC|STA_CLOCKERR)) != 0)\n\t\tresult = TIME_ERROR;\n\n\tif ((txc->modes == ADJ_OFFSET_SINGLESHOT) ||\n\t\t\t(txc->modes == ADJ_OFFSET_SS_READ))\n\t\ttxc->offset = save_adjust;\n\telse\n\t\ttxc->offset = ((long)shift_right(time_offset, SHIFT_UPDATE)) *\n\t    \t\t\tNTP_INTERVAL_FREQ / 1000;\n\ttxc->freq\t   = (time_freq / NSEC_PER_USEC) <<\n\t\t\t\t(SHIFT_USEC - SHIFT_NSEC);\n\ttxc->maxerror\t   = time_maxerror;\n\ttxc->esterror\t   = time_esterror;\n\ttxc->status\t   = time_status;\n\ttxc->constant\t   = time_constant;\n\ttxc->precision\t   = 1;\n\ttxc->tolerance\t   = MAXFREQ;\n\ttxc->tick\t   = tick_usec;\n\n\t/* PPS is not implemented, so these are zero */\n\ttxc->ppsfreq\t   = 0;\n\ttxc->jitter\t   = 0;\n\ttxc->shift\t   = 0;\n\ttxc->stabil\t   = 0;\n\ttxc->jitcnt\t   = 0;\n\ttxc->calcnt\t   = 0;\n\ttxc->errcnt\t   = 0;\n\ttxc->stbcnt\t   = 0;\n\twrite_sequnlock_irq(&xtime_lock);\n\tdo_gettimeofday(&txc->time);\n\tnotify_cmos_timer();\n\treturn(result);\n}",
        "target": 1
    },
    {
        "func": "static int sgi_clock_set(clockid_t clockid, struct timespec *tp)\n{\n\n\tu64 nsec;\n\tu64 rem;\n\n\tnsec = rtc_time() * sgi_clock_period;\n\n\tsgi_clock_offset.tv_sec = tp->tv_sec - div_long_long_rem(nsec, NSEC_PER_SEC, &rem);\n\n\tif (rem <= tp->tv_nsec)\n\t\tsgi_clock_offset.tv_nsec = tp->tv_sec - rem;\n\telse {\n\t\tsgi_clock_offset.tv_nsec = tp->tv_sec + NSEC_PER_SEC - rem;\n\t\tsgi_clock_offset.tv_sec--;\n\t}\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "void jiffies_to_timeval(const unsigned long jiffies, struct timeval *value)\n{\n\t/*\n\t * Convert jiffies to nanoseconds and separate with\n\t * one divide.\n\t */\n\tu64 nsec = (u64)jiffies * TICK_NSEC;\n\tlong tv_usec;\n\n\tvalue->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &tv_usec);\n\ttv_usec /= NSEC_PER_USEC;\n\tvalue->tv_usec = tv_usec;\n}",
        "target": 1
    },
    {
        "func": "static inline long div_ll_X_l_rem(long long divs, long div, long *rem)\n{\n\tlong dum2;\n\tasm(\"divl %2\":\"=a\"(dum2), \"=d\"(*rem)\n\t    : \"rm\"(div), \"A\"(divs));\n\n\treturn dum2;\n\n}",
        "target": 1
    },
    {
        "func": "static inline long div_long_long_rem_signed(const long long dividend,\n\t\t\t\t\t    const long divisor, long *remainder)\n{\n\tlong res;\n\n\tif (unlikely(dividend < 0)) {\n\t\tres = -div_long_long_rem(-dividend, divisor, remainder);\n\t\t*remainder = -(*remainder);\n\t} else\n\t\tres = div_long_long_rem(dividend, divisor, remainder);\n\n\treturn res;\n}",
        "target": 1
    },
    {
        "func": "static int sgi_timer_set(struct k_itimer *timr, int flags,\n\tstruct itimerspec * new_setting,\n\tstruct itimerspec * old_setting)\n{\n\tunsigned long when, period, irqflags;\n\tint err = 0;\n\tcnodeid_t nodeid;\n\tstruct mmtimer *base;\n\tstruct rb_node *n;\n\n\tif (old_setting)\n\t\tsgi_timer_get(timr, old_setting);\n\n\tsgi_timer_del(timr);\n\twhen = timespec_to_ns(new_setting->it_value);\n\tperiod = timespec_to_ns(new_setting->it_interval);\n\n\tif (when == 0)\n\t\t/* Clear timer */\n\t\treturn 0;\n\n\tbase = kmalloc(sizeof(struct mmtimer), GFP_KERNEL);\n\tif (base == NULL)\n\t\treturn -ENOMEM;\n\n\tif (flags & TIMER_ABSTIME) {\n\t\tstruct timespec n;\n\t\tunsigned long now;\n\n\t\tgetnstimeofday(&n);\n\t\tnow = timespec_to_ns(n);\n\t\tif (when > now)\n\t\t\twhen -= now;\n\t\telse\n\t\t\t/* Fire the timer immediately */\n\t\t\twhen = 0;\n\t}\n\n\t/*\n\t * Convert to sgi clock period. Need to keep rtc_time() as near as possible\n\t * to getnstimeofday() in order to be as faithful as possible to the time\n\t * specified.\n\t */\n\twhen = (when + sgi_clock_period - 1) / sgi_clock_period + rtc_time();\n\tperiod = (period + sgi_clock_period - 1)  / sgi_clock_period;\n\n\t/*\n\t * We are allocating a local SHub comparator. If we would be moved to another\n\t * cpu then another SHub may be local to us. Prohibit that by switching off\n\t * preemption.\n\t */\n\tpreempt_disable();\n\n\tnodeid =  cpu_to_node(smp_processor_id());\n\n\t/* Lock the node timer structure */\n\tspin_lock_irqsave(&timers[nodeid].lock, irqflags);\n\n\tbase->timer = timr;\n\tbase->cpu = smp_processor_id();\n\n\ttimr->it.mmtimer.clock = TIMER_SET;\n\ttimr->it.mmtimer.node = nodeid;\n\ttimr->it.mmtimer.incr = period;\n\ttimr->it.mmtimer.expires = when;\n\n\tn = timers[nodeid].next;\n\n\t/* Add the new struct mmtimer to node's timer list */\n\tmmtimer_add_list(base);\n\n\tif (timers[nodeid].next == n) {\n\t\t/* No need to reprogram comparator for now */\n\t\tspin_unlock_irqrestore(&timers[nodeid].lock, irqflags);\n\t\tpreempt_enable();\n\t\treturn err;\n\t}\n\n\t/* We need to reprogram the comparator */\n\tif (n)\n\t\tmmtimer_disable_int(cnodeid_to_nasid(nodeid), COMPARATOR);\n\n\tmmtimer_set_next_timer(nodeid);\n\n\t/* Unlock the node timer structure */\n\tspin_unlock_irqrestore(&timers[nodeid].lock, irqflags);\n\n\tpreempt_enable();\n\n\treturn err;\n}",
        "target": 1
    },
    {
        "func": "static void sample_to_timespec(const clockid_t which_clock,\n\t\t\t       union cpu_time_count cpu,\n\t\t\t       struct timespec *tp)\n{\n\tif (CPUCLOCK_WHICH(which_clock) == CPUCLOCK_SCHED) {\n\t\ttp->tv_sec = div_long_long_rem(cpu.sched,\n\t\t\t\t\t       NSEC_PER_SEC, &tp->tv_nsec);\n\t} else {\n\t\tcputime_to_timespec(cpu.cpu, tp);\n\t}\n}",
        "target": 1
    },
    {
        "func": "static int list_locations(struct kmem_cache *s, char *buf,\n\t\t\t\t\tenum track_item alloc)\n{\n\tint len = 0;\n\tunsigned long i;\n\tstruct loc_track t = { 0, 0, NULL };\n\tint node;\n\n\tif (!alloc_loc_track(&t, PAGE_SIZE / sizeof(struct location),\n\t\t\tGFP_TEMPORARY))\n\t\treturn sprintf(buf, \"Out of memory\\n\");\n\n\t/* Push back cpu slabs */\n\tflush_all(s);\n\n\tfor_each_node_state(node, N_NORMAL_MEMORY) {\n\t\tstruct kmem_cache_node *n = get_node(s, node);\n\t\tunsigned long flags;\n\t\tstruct page *page;\n\n\t\tif (!atomic_long_read(&n->nr_slabs))\n\t\t\tcontinue;\n\n\t\tspin_lock_irqsave(&n->list_lock, flags);\n\t\tlist_for_each_entry(page, &n->partial, lru)\n\t\t\tprocess_slab(&t, s, page, alloc);\n\t\tlist_for_each_entry(page, &n->full, lru)\n\t\t\tprocess_slab(&t, s, page, alloc);\n\t\tspin_unlock_irqrestore(&n->list_lock, flags);\n\t}\n\n\tfor (i = 0; i < t.count; i++) {\n\t\tstruct location *l = &t.loc[i];\n\n\t\tif (len > PAGE_SIZE - 100)\n\t\t\tbreak;\n\t\tlen += sprintf(buf + len, \"%7ld \", l->count);\n\n\t\tif (l->addr)\n\t\t\tlen += sprint_symbol(buf + len, (unsigned long)l->addr);\n\t\telse\n\t\t\tlen += sprintf(buf + len, \"<not-available>\");\n\n\t\tif (l->sum_time != l->min_time) {\n\t\t\tunsigned long remainder;\n\n\t\t\tlen += sprintf(buf + len, \" age=%ld/%ld/%ld\",\n\t\t\tl->min_time,\n\t\t\tdiv_long_long_rem(l->sum_time, l->count, &remainder),\n\t\t\tl->max_time);\n\t\t} else\n\t\t\tlen += sprintf(buf + len, \" age=%ld\",\n\t\t\t\tl->min_time);\n\n\t\tif (l->min_pid != l->max_pid)\n\t\t\tlen += sprintf(buf + len, \" pid=%ld-%ld\",\n\t\t\t\tl->min_pid, l->max_pid);\n\t\telse\n\t\t\tlen += sprintf(buf + len, \" pid=%ld\",\n\t\t\t\tl->min_pid);\n\n\t\tif (num_online_cpus() > 1 && !cpus_empty(l->cpus) &&\n\t\t\t\tlen < PAGE_SIZE - 60) {\n\t\t\tlen += sprintf(buf + len, \" cpus=\");\n\t\t\tlen += cpulist_scnprintf(buf + len, PAGE_SIZE - len - 50,\n\t\t\t\t\tl->cpus);\n\t\t}\n\n\t\tif (num_online_nodes() > 1 && !nodes_empty(l->nodes) &&\n\t\t\t\tlen < PAGE_SIZE - 60) {\n\t\t\tlen += sprintf(buf + len, \" nodes=\");\n\t\t\tlen += nodelist_scnprintf(buf + len, PAGE_SIZE - len - 50,\n\t\t\t\t\tl->nodes);\n\t\t}\n\n\t\tlen += sprintf(buf + len, \"\\n\");\n\t}\n\n\tfree_loc_track(&t);\n\tif (!t.count)\n\t\tlen += sprintf(buf, \"No data\\n\");\n\treturn len;\n}",
        "target": 1
    },
    {
        "func": "struct timespec ns_to_timespec(const s64 nsec)\n{\n\tstruct timespec ts;\n\n\tif (!nsec)\n\t\treturn (struct timespec) {0, 0};\n\n\tts.tv_sec = div_long_long_rem_signed(nsec, NSEC_PER_SEC, &ts.tv_nsec);\n\tif (unlikely(nsec < 0))\n\t\tset_normalized_timespec(&ts, ts.tv_sec, ts.tv_nsec);\n\n\treturn ts;\n}",
        "target": 1
    },
    {
        "func": "pam_sm_authenticate (pam_handle_t * pamh,\n\t\t     int flags, int argc, const char **argv)\n{\n  int retval, rc;\n  const char *user = NULL;\n  const char *password = NULL;\n  char otp[MAX_TOKEN_ID_LEN + TOKEN_OTP_LEN + 1] = { 0 };\n  char otp_id[MAX_TOKEN_ID_LEN + 1] = { 0 };\n  int password_len = 0;\n  int skip_bytes = 0;\n  int valid_token = 0;\n  struct pam_conv *conv;\n  struct pam_message *pmsg[1], msg[1];\n  struct pam_response *resp;\n  int nargs = 1;\n  ykclient_t *ykc = NULL;\n  struct cfg cfg_st;\n  struct cfg *cfg = &cfg_st; /* for DBG macro */\n\n  parse_cfg (flags, argc, argv, cfg);\n\n  retval = pam_get_user (pamh, &user, NULL);\n  if (retval != PAM_SUCCESS)\n    {\n      DBG ((\"get user returned error: %s\", pam_strerror (pamh, retval)));\n      goto done;\n    }\n  DBG ((\"get user returned: %s\", user));\n\n  if (cfg->mode == CHRESP) {\n#if HAVE_LIBYKPERS_1\n    return do_challenge_response(pamh, cfg, user);\n#else\n    DBG ((\"no support for challenge/response\"));\n    retval = PAM_AUTH_ERR;\n    goto done;\n#endif\n  }\n\n  if (cfg->try_first_pass || cfg->use_first_pass)\n    {\n      retval = pam_get_item (pamh, PAM_AUTHTOK, (const void **) &password);\n      if (retval != PAM_SUCCESS)\n\t{\n\t  DBG ((\"get password returned error: %s\",\n\t      pam_strerror (pamh, retval)));\n\t  goto done;\n\t}\n      DBG ((\"get password returned: %s\", password));\n    }\n\n  if (cfg->use_first_pass && password == NULL)\n    {\n      DBG ((\"use_first_pass set and no password, giving up\"));\n      retval = PAM_AUTH_ERR;\n      goto done;\n    }\n\n  rc = ykclient_init (&ykc);\n  if (rc != YKCLIENT_OK)\n    {\n      DBG ((\"ykclient_init() failed (%d): %s\", rc, ykclient_strerror (rc)));\n      retval = PAM_AUTHINFO_UNAVAIL;\n      goto done;\n    }\n\n  rc = ykclient_set_client_b64 (ykc, cfg->client_id, cfg->client_key);\n  if (rc != YKCLIENT_OK)\n    {\n      DBG ((\"ykclient_set_client_b64() failed (%d): %s\",\n\t    rc, ykclient_strerror (rc)));\n      retval = PAM_AUTHINFO_UNAVAIL;\n      goto done;\n    }\n\n  if (cfg->capath)\n    ykclient_set_ca_path (ykc, cfg->capath);\n\n  if (cfg->url)\n    ykclient_set_url_template (ykc, cfg->url);\n\n  if (password == NULL)\n    {\n      retval = pam_get_item (pamh, PAM_CONV, (const void **) &conv);\n      if (retval != PAM_SUCCESS)\n\t{\n\t  DBG ((\"get conv returned error: %s\", pam_strerror (pamh, retval)));\n\t  goto done;\n\t}\n\n      pmsg[0] = &msg[0];\n      {\n\tconst char *query_template = \"Yubikey for `%s': \";\n\tsize_t len = strlen (query_template) + strlen (user);\n\tsize_t wrote;\n\n\tmsg[0].msg = malloc (len);\n\tif (!msg[0].msg)\n\t  {\n\t    retval = PAM_BUF_ERR;\n\t    goto done;\n\t  }\n\n\twrote = snprintf ((char *) msg[0].msg, len, query_template, user);\n\tif (wrote < 0 || wrote >= len)\n\t  {\n\t    retval = PAM_BUF_ERR;\n\t    goto done;\n\t  }\n      }\n      msg[0].msg_style = cfg->verbose_otp ? PAM_PROMPT_ECHO_ON : PAM_PROMPT_ECHO_OFF;\n      resp = NULL;\n\n      retval = conv->conv (nargs, (const struct pam_message **) pmsg,\n\t\t\t   &resp, conv->appdata_ptr);\n\n      free ((char *) msg[0].msg);\n\n      if (retval != PAM_SUCCESS)\n\t{\n\t  DBG ((\"conv returned error: %s\", pam_strerror (pamh, retval)));\n\t  goto done;\n\t}\n\n      if (resp->resp == NULL)\n\t{\n\t  DBG ((\"conv returned NULL passwd?\"));\n\t  goto done;\n\t}\n\n      DBG ((\"conv returned %i bytes\", strlen(resp->resp)));\n\n      password = resp->resp;\n    }\n\n  password_len = strlen (password);\n  if (password_len < (cfg->token_id_length + TOKEN_OTP_LEN))\n    {\n      DBG ((\"OTP too short to be considered : %i < %i\", password_len, (cfg->token_id_length + TOKEN_OTP_LEN)));\n      retval = PAM_AUTH_ERR;\n      goto done;\n    }\n\n  /* In case the input was systempassword+YubiKeyOTP, we want to skip over\n     \"systempassword\" when copying the token_id and OTP to separate buffers */\n  skip_bytes = password_len - (cfg->token_id_length + TOKEN_OTP_LEN);\n\n  DBG ((\"Skipping first %i bytes. Length is %i, token_id set to %i and token OTP always %i.\",\n\tskip_bytes, password_len, cfg->token_id_length, TOKEN_OTP_LEN));\n\n  /* Copy full YubiKey output (public ID + OTP) into otp */\n  strncpy (otp, password + skip_bytes, sizeof (otp) - 1);\n  /* Copy only public ID into otp_id. Destination buffer is zeroed. */\n  strncpy (otp_id, password + skip_bytes, cfg->token_id_length);\n\n  DBG ((\"OTP: %s ID: %s \", otp, otp_id));\n\n  /* user entered their system password followed by generated OTP? */\n  if (password_len > TOKEN_OTP_LEN + cfg->token_id_length)\n    {\n      char *onlypasswd = strdup (password);\n\n      onlypasswd[password_len - (TOKEN_OTP_LEN + cfg->token_id_length)] = '\\0';\n\n      DBG ((\"Extracted a probable system password entered before the OTP - \"\n\t    \"setting item PAM_AUTHTOK\"));\n\n      retval = pam_set_item (pamh, PAM_AUTHTOK, onlypasswd);\n      free (onlypasswd);\n      if (retval != PAM_SUCCESS)\n\t{\n\t  DBG ((\"set_item returned error: %s\", pam_strerror (pamh, retval)));\n\t  goto done;\n\t}\n    }\n  else\n    password = NULL;\n\n  rc = ykclient_request (ykc, otp);\n\n  DBG ((\"ykclient return value (%d): %s\", rc,\n\tykclient_strerror (rc)));\n\n  switch (rc)\n    {\n    case YKCLIENT_OK:\n      break;\n\n    case YKCLIENT_BAD_OTP:\n    case YKCLIENT_REPLAYED_OTP:\n      retval = PAM_AUTH_ERR;\n      goto done;\n\n    default:\n      retval = PAM_AUTHINFO_UNAVAIL;\n      goto done;\n    }\n\n  /* authorize the user with supplied token id */\n  if (cfg->ldapserver != NULL || cfg->ldap_uri != NULL)\n    valid_token = authorize_user_token_ldap (cfg, user, otp_id);\n  else\n    valid_token = authorize_user_token (cfg, user, otp_id);\n\n  if (valid_token == 0)\n    {\n      DBG ((\"Yubikey not authorized to login as user\"));\n      retval = PAM_AUTHINFO_UNAVAIL;\n      goto done;\n    }\n\n  retval = PAM_SUCCESS;\n\ndone:\n  if (ykc)\n    ykclient_done (&ykc);\n  if (cfg->alwaysok && retval != PAM_SUCCESS)\n    {\n      DBG ((\"alwaysok needed (otherwise return with %d)\", retval));\n      retval = PAM_SUCCESS;\n    }\n  DBG ((\"done. [%s]\", pam_strerror (pamh, retval)));\n  pam_set_data (pamh, \"yubico_setcred_return\", (void*) (intptr_t) retval, NULL);\n\n  return retval;\n}",
        "target": 1
    },
    {
        "func": "static struct wildmat *split_wildmats(char *str)\n{\n    const char *prefix;\n    char pattern[MAX_MAILBOX_BUFFER] = \"\", *p, *c;\n    struct wildmat *wild = NULL;\n    int n = 0;\n\n    if ((prefix = config_getstring(IMAPOPT_NEWSPREFIX)))\n\tsnprintf(pattern, sizeof(pattern), \"%s.\", prefix);\n    p = pattern + strlen(pattern);\n\n    /*\n     * split the list of wildmats\n     *\n     * we split them right to left because this is the order in which\n     * we want to test them (per RFC3977 section 4.2)\n     */\n    do {\n\tif ((c = strrchr(str, ',')))\n\t    *c++ = '\\0';\n\telse\n\t    c = str;\n\n\tif (!(n % 10)) /* alloc some more */\n\t    wild = xrealloc(wild, (n + 11) * sizeof(struct wildmat));\n\n\tif (*c == '!') wild[n].not = 1;\t\t/* not */\n\telse if (*c == '@') wild[n].not = -1;\t/* absolute not (feeding) */\n\telse wild[n].not = 0;\n\n\tstrcpy(p, wild[n].not ? c + 1 : c);\n\twild[n++].pat = xstrdup(pattern);\n    } while (c != str);\n    wild[n].pat = NULL;\n\n    return wild;\n}",
        "target": 1
    },
    {
        "func": "xmlXPtrEvalXPointer(xmlXPathParserContextPtr ctxt) {\n    if (ctxt->valueTab == NULL) {\n\t/* Allocate the value stack */\n\tctxt->valueTab = (xmlXPathObjectPtr *) \n\t\t\t xmlMalloc(10 * sizeof(xmlXPathObjectPtr));\n\tif (ctxt->valueTab == NULL) {\n\t    xmlXPtrErrMemory(\"allocating evaluation context\");\n\t    return;\n\t}\n\tctxt->valueNr = 0;\n\tctxt->valueMax = 10;\n\tctxt->value = NULL;\n    }\n    SKIP_BLANKS;\n    if (CUR == '/') {\n\txmlXPathRoot(ctxt);\n        xmlXPtrEvalChildSeq(ctxt, NULL);\n    } else {\n\txmlChar *name;\n\n\tname = xmlXPathParseName(ctxt);\n\tif (name == NULL)\n\t    XP_ERROR(XPATH_EXPR_ERROR);\n\tif (CUR == '(') {\n\t    xmlXPtrEvalFullXPtr(ctxt, name);\n\t    /* Short evaluation */\n\t    return;\n\t} else {\n\t    /* this handle both Bare Names and Child Sequences */\n\t    xmlXPtrEvalChildSeq(ctxt, name);\n\t}\n    }\n    SKIP_BLANKS;\n    if (CUR != 0)\n\tXP_ERROR(XPATH_EXPR_ERROR);\n}",
        "target": 1
    },
    {
        "func": " */\nstatic int\nxmlXPathRunEval(xmlXPathParserContextPtr ctxt, int toBool)\n{\n    xmlXPathCompExprPtr comp;\n\n    if ((ctxt == NULL) || (ctxt->comp == NULL))\n\treturn(-1);\n\n    if (ctxt->valueTab == NULL) {\n\t/* Allocate the value stack */\n\tctxt->valueTab = (xmlXPathObjectPtr *)\n\t\t\t xmlMalloc(10 * sizeof(xmlXPathObjectPtr));\n\tif (ctxt->valueTab == NULL) {\n\t    xmlXPathPErrMemory(ctxt, \"creating evaluation context\\n\");\n\t    xmlFree(ctxt);\n\t}\n\tctxt->valueNr = 0;\n\tctxt->valueMax = 10;\n\tctxt->value = NULL;\n    }\n#ifdef XPATH_STREAMING\n    if (ctxt->comp->stream) {\n\tint res;\n\n\tif (toBool) {\n\t    /*\n\t    * Evaluation to boolean result.\n\t    */\n\t    res = xmlXPathRunStreamEval(ctxt->context,\n\t\tctxt->comp->stream, NULL, 1);\n\t    if (res != -1)\n\t\treturn(res);\n\t} else {\n\t    xmlXPathObjectPtr resObj = NULL;\n\n\t    /*\n\t    * Evaluation to a sequence.\n\t    */\n\t    res = xmlXPathRunStreamEval(ctxt->context,\n\t\tctxt->comp->stream, &resObj, 0);\n\n\t    if ((res != -1) && (resObj != NULL)) {\n\t\tvaluePush(ctxt, resObj);\n\t\treturn(0);\n\t    }\n\t    if (resObj != NULL)\n\t\txmlXPathReleaseObject(ctxt->context, resObj);\n\t}\n\t/*\n\t* QUESTION TODO: This falls back to normal XPath evaluation\n\t* if res == -1. Is this intended?\n\t*/\n    }\n#endif\n    comp = ctxt->comp;\n    if (comp->last < 0) {\n\txmlGenericError(xmlGenericErrorContext,\n\t    \"xmlXPathRunEval: last is less than zero\\n\");\n\treturn(-1);\n    }\n    if (toBool)\n\treturn(xmlXPathCompOpEvalToBoolean(ctxt,\n\t    &comp->steps[comp->last], 0));\n    else\n\txmlXPathCompOpEval(ctxt, &comp->steps[comp->last]);\n",
        "target": 1
    },
    {
        "func": "\nstatic int\nxmlXPathCompOpEvalPositionalPredicate(xmlXPathParserContextPtr ctxt,\n\t\t\t\t      xmlXPathStepOpPtr op,\n\t\t\t\t      xmlNodeSetPtr set,\n\t\t\t\t      int contextSize,\n\t\t\t\t      int minPos,\n\t\t\t\t      int maxPos,\n\t\t\t\t      int hasNsNodes)\n{\n    if (op->ch1 != -1) {\n\txmlXPathCompExprPtr comp = ctxt->comp;\n\tif (comp->steps[op->ch1].op != XPATH_OP_PREDICATE) {\n\t    /*\n\t    * TODO: raise an internal error.\n\t    */\n\t}\n\tcontextSize = xmlXPathCompOpEvalPredicate(ctxt,\n\t    &comp->steps[op->ch1], set, contextSize, hasNsNodes);\n\tCHECK_ERROR0;\n\tif (contextSize <= 0)\n\t    return(0);\n    }\n    /*\n    * Check if the node set contains a sufficient number of nodes for\n    * the requested range.\n    */\n    if (contextSize < minPos) {\n\txmlXPathNodeSetClear(set, hasNsNodes);\n\treturn(0);\n    }\n    if (op->ch2 == -1) {\n\t/*\n\t* TODO: Can this ever happen?\n\t*/\n\treturn (contextSize);\n    } else {\n\txmlDocPtr oldContextDoc;\n\tint i, pos = 0, newContextSize = 0, contextPos = 0, res;\n\txmlXPathStepOpPtr exprOp;\n\txmlXPathObjectPtr contextObj = NULL, exprRes = NULL;\n\txmlNodePtr oldContextNode, contextNode = NULL;\n\txmlXPathContextPtr xpctxt = ctxt->context;\n\n#ifdef LIBXML_XPTR_ENABLED\n\t    /*\n\t    * URGENT TODO: Check the following:\n\t    *  We don't expect location sets if evaluating prediates, right?\n\t    *  Only filters should expect location sets, right?\n\t*/\n#endif /* LIBXML_XPTR_ENABLED */\n\n\t/*\n\t* Save old context.\n\t*/\n\toldContextNode = xpctxt->node;\n\toldContextDoc = xpctxt->doc;\n\t/*\n\t* Get the expression of this predicate.\n\t*/\n\texprOp = &ctxt->comp->steps[op->ch2];\n\tfor (i = 0; i < set->nodeNr; i++) {\n\t    if (set->nodeTab[i] == NULL)\n\t\tcontinue;\n\n\t    contextNode = set->nodeTab[i];\n\t    xpctxt->node = contextNode;\n\t    xpctxt->contextSize = contextSize;\n\t    xpctxt->proximityPosition = ++contextPos;\n\n\t    /*\n\t    * Initialize the new set.\n\t    * Also set the xpath document in case things like\n\t    * key() evaluation are attempted on the predicate\n\t    */\n\t    if ((contextNode->type != XML_NAMESPACE_DECL) &&\n\t\t(contextNode->doc != NULL))\n\t\txpctxt->doc = contextNode->doc;\n\t    /*\n\t    * Evaluate the predicate expression with 1 context node\n\t    * at a time; this node is packaged into a node set; this\n\t    * node set is handed over to the evaluation mechanism.\n\t    */\n\t    if (contextObj == NULL)\n\t\tcontextObj = xmlXPathCacheNewNodeSet(xpctxt, contextNode);\n\t    else\n\t\txmlXPathNodeSetAddUnique(contextObj->nodesetval,\n\t\t    contextNode);\n\n\t    valuePush(ctxt, contextObj);\n\t    res = xmlXPathCompOpEvalToBoolean(ctxt, exprOp, 1);\n\n\t    if ((ctxt->error != XPATH_EXPRESSION_OK) || (res == -1)) {\n\t        xmlXPathObjectPtr tmp;\n\t\t/* pop the result if any */\n\t\ttmp = valuePop(ctxt);\n                if (tmp != contextObj) {\n                    /*\n                     * Free up the result\n                     * then pop off contextObj, which will be freed later\n                     */\n                    xmlXPathReleaseObject(xpctxt, tmp);\n                    valuePop(ctxt);\n                }\n\t\tgoto evaluation_error;\n\t    }\n\n\t    if (res)\n\t\tpos++;\n\n\t    if (res && (pos >= minPos) && (pos <= maxPos)) {\n\t\t/*\n\t\t* Fits in the requested range.\n\t\t*/\n\t\tnewContextSize++;\n\t\tif (minPos == maxPos) {\n\t\t    /*\n\t\t    * Only 1 node was requested.\n\t\t    */\n\t\t    if (contextNode->type == XML_NAMESPACE_DECL) {\n\t\t\t/*\n\t\t\t* As always: take care of those nasty\n\t\t\t* namespace nodes.\n\t\t\t*/\n\t\t\tset->nodeTab[i] = NULL;\n\t\t    }\n\t\t    xmlXPathNodeSetClear(set, hasNsNodes);\n\t\t    set->nodeNr = 1;\n\t\t    set->nodeTab[0] = contextNode;\n\t\t    goto evaluation_exit;\n\t\t}\n\t\tif (pos == maxPos) {\n\t\t    /*\n\t\t    * We are done.\n\t\t    */\n\t\t    xmlXPathNodeSetClearFromPos(set, i +1, hasNsNodes);\n\t\t    goto evaluation_exit;\n\t\t}\n\t    } else {\n\t\t/*\n\t\t* Remove the entry from the initial node set.\n\t\t*/\n\t\tset->nodeTab[i] = NULL;\n\t\tif (contextNode->type == XML_NAMESPACE_DECL)\n\t\t    xmlXPathNodeSetFreeNs((xmlNsPtr) contextNode);\n\t    }\n\t    if (exprRes != NULL) {\n\t\txmlXPathReleaseObject(ctxt->context, exprRes);\n\t\texprRes = NULL;\n\t    }\n\t    if (ctxt->value == contextObj) {\n\t\t/*\n\t\t* Don't free the temporary XPath object holding the\n\t\t* context node, in order to avoid massive recreation\n\t\t* inside this loop.\n\t\t*/\n\t\tvaluePop(ctxt);\n\t\txmlXPathNodeSetClear(contextObj->nodesetval, hasNsNodes);\n\t    } else {\n\t\t/*\n\t\t* The object was lost in the evaluation machinery.\n\t\t* Can this happen? Maybe in case of internal-errors.\n\t\t*/\n\t\tcontextObj = NULL;\n\t    }\n\t}\n\tgoto evaluation_exit;\n\nevaluation_error:\n\txmlXPathNodeSetClear(set, hasNsNodes);\n\tnewContextSize = 0;\n\nevaluation_exit:\n\tif (contextObj != NULL) {\n\t    if (ctxt->value == contextObj)\n\t\tvaluePop(ctxt);\n\t    xmlXPathReleaseObject(xpctxt, contextObj);\n\t}\n\tif (exprRes != NULL)\n\t    xmlXPathReleaseObject(ctxt->context, exprRes);\n\t/*\n\t* Reset/invalidate the context.\n\t*/\n\txpctxt->node = oldContextNode;\n\txpctxt->doc = oldContextDoc;\n\txpctxt->contextSize = -1;\n\txpctxt->proximityPosition = -1;\n\treturn(newContextSize);\n    }",
        "target": 1
    },
    {
        "func": " */\nstatic xmlXPathParserContextPtr\nxmlXPathCompParserContext(xmlXPathCompExprPtr comp, xmlXPathContextPtr ctxt) {\n    xmlXPathParserContextPtr ret;\n\n    ret = (xmlXPathParserContextPtr) xmlMalloc(sizeof(xmlXPathParserContext));\n    if (ret == NULL) {\n        xmlXPathErrMemory(ctxt, \"creating evaluation context\\n\");\n\treturn(NULL);\n    }\n    memset(ret, 0 , (size_t) sizeof(xmlXPathParserContext));\n\n    /* Allocate the value stack */\n    ret->valueTab = (xmlXPathObjectPtr *)\n                     xmlMalloc(10 * sizeof(xmlXPathObjectPtr));\n    if (ret->valueTab == NULL) {\n\txmlFree(ret);\n\txmlXPathErrMemory(ctxt, \"creating evaluation context\\n\");\n\treturn(NULL);\n    }\n    ret->valueNr = 0;\n    ret->valueMax = 10;\n    ret->value = NULL;\n\n    ret->context = ctxt;\n    ret->comp = comp;\n",
        "target": 1
    },
    {
        "func": " */\nstatic int\nxmlXPathCompOpEval(xmlXPathParserContextPtr ctxt, xmlXPathStepOpPtr op)\n{\n    int total = 0;\n    int equal, ret;\n    xmlXPathCompExprPtr comp;\n    xmlXPathObjectPtr arg1, arg2;\n    xmlNodePtr bak;\n    xmlDocPtr bakd;\n    int pp;\n    int cs;\n\n    CHECK_ERROR0;\n    comp = ctxt->comp;\n    switch (op->op) {\n        case XPATH_OP_END:\n            return (0);\n        case XPATH_OP_AND:\n\t    bakd = ctxt->context->doc;\n\t    bak = ctxt->context->node;\n\t    pp = ctxt->context->proximityPosition;\n\t    cs = ctxt->context->contextSize;\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t    CHECK_ERROR0;\n            xmlXPathBooleanFunction(ctxt, 1);\n            if ((ctxt->value == NULL) || (ctxt->value->boolval == 0))\n                return (total);\n            arg2 = valuePop(ctxt);\n\t    ctxt->context->doc = bakd;\n\t    ctxt->context->node = bak;\n\t    ctxt->context->proximityPosition = pp;\n\t    ctxt->context->contextSize = cs;\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);\n\t    if (ctxt->error) {\n\t\txmlXPathFreeObject(arg2);\n\t\treturn(0);\n\t    }\n            xmlXPathBooleanFunction(ctxt, 1);\n            arg1 = valuePop(ctxt);\n            arg1->boolval &= arg2->boolval;\n            valuePush(ctxt, arg1);\n\t    xmlXPathReleaseObject(ctxt->context, arg2);\n            return (total);\n        case XPATH_OP_OR:\n\t    bakd = ctxt->context->doc;\n\t    bak = ctxt->context->node;\n\t    pp = ctxt->context->proximityPosition;\n\t    cs = ctxt->context->contextSize;\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t    CHECK_ERROR0;\n            xmlXPathBooleanFunction(ctxt, 1);\n            if ((ctxt->value == NULL) || (ctxt->value->boolval == 1))\n                return (total);\n            arg2 = valuePop(ctxt);\n\t    ctxt->context->doc = bakd;\n\t    ctxt->context->node = bak;\n\t    ctxt->context->proximityPosition = pp;\n\t    ctxt->context->contextSize = cs;\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);\n\t    if (ctxt->error) {\n\t\txmlXPathFreeObject(arg2);\n\t\treturn(0);\n\t    }\n            xmlXPathBooleanFunction(ctxt, 1);\n            arg1 = valuePop(ctxt);\n            arg1->boolval |= arg2->boolval;\n            valuePush(ctxt, arg1);\n\t    xmlXPathReleaseObject(ctxt->context, arg2);\n            return (total);\n        case XPATH_OP_EQUAL:\n\t    bakd = ctxt->context->doc;\n\t    bak = ctxt->context->node;\n\t    pp = ctxt->context->proximityPosition;\n\t    cs = ctxt->context->contextSize;\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t    CHECK_ERROR0;\n\t    ctxt->context->doc = bakd;\n\t    ctxt->context->node = bak;\n\t    ctxt->context->proximityPosition = pp;\n\t    ctxt->context->contextSize = cs;\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);\n\t    CHECK_ERROR0;\n\t    if (op->value)\n\t\tequal = xmlXPathEqualValues(ctxt);\n\t    else\n\t\tequal = xmlXPathNotEqualValues(ctxt);\n\t    valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt->context, equal));\n            return (total);\n        case XPATH_OP_CMP:\n\t    bakd = ctxt->context->doc;\n\t    bak = ctxt->context->node;\n\t    pp = ctxt->context->proximityPosition;\n\t    cs = ctxt->context->contextSize;\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t    CHECK_ERROR0;\n\t    ctxt->context->doc = bakd;\n\t    ctxt->context->node = bak;\n\t    ctxt->context->proximityPosition = pp;\n\t    ctxt->context->contextSize = cs;\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);\n\t    CHECK_ERROR0;\n            ret = xmlXPathCompareValues(ctxt, op->value, op->value2);\n\t    valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt->context, ret));\n            return (total);\n        case XPATH_OP_PLUS:\n\t    bakd = ctxt->context->doc;\n\t    bak = ctxt->context->node;\n\t    pp = ctxt->context->proximityPosition;\n\t    cs = ctxt->context->contextSize;\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t    CHECK_ERROR0;\n            if (op->ch2 != -1) {\n\t\tctxt->context->doc = bakd;\n\t\tctxt->context->node = bak;\n\t\tctxt->context->proximityPosition = pp;\n\t\tctxt->context->contextSize = cs;\n                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);\n\t    }\n\t    CHECK_ERROR0;\n            if (op->value == 0)\n                xmlXPathSubValues(ctxt);\n            else if (op->value == 1)\n                xmlXPathAddValues(ctxt);\n            else if (op->value == 2)\n                xmlXPathValueFlipSign(ctxt);\n            else if (op->value == 3) {\n                CAST_TO_NUMBER;\n                CHECK_TYPE0(XPATH_NUMBER);\n            }\n            return (total);\n        case XPATH_OP_MULT:\n\t    bakd = ctxt->context->doc;\n\t    bak = ctxt->context->node;\n\t    pp = ctxt->context->proximityPosition;\n\t    cs = ctxt->context->contextSize;\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t    CHECK_ERROR0;\n\t    ctxt->context->doc = bakd;\n\t    ctxt->context->node = bak;\n\t    ctxt->context->proximityPosition = pp;\n\t    ctxt->context->contextSize = cs;\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);\n\t    CHECK_ERROR0;\n            if (op->value == 0)\n                xmlXPathMultValues(ctxt);\n            else if (op->value == 1)\n                xmlXPathDivValues(ctxt);\n            else if (op->value == 2)\n                xmlXPathModValues(ctxt);\n            return (total);\n        case XPATH_OP_UNION:\n\t    bakd = ctxt->context->doc;\n\t    bak = ctxt->context->node;\n\t    pp = ctxt->context->proximityPosition;\n\t    cs = ctxt->context->contextSize;\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t    CHECK_ERROR0;\n\t    ctxt->context->doc = bakd;\n\t    ctxt->context->node = bak;\n\t    ctxt->context->proximityPosition = pp;\n\t    ctxt->context->contextSize = cs;\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);\n\t    CHECK_ERROR0;\n            CHECK_TYPE0(XPATH_NODESET);\n            arg2 = valuePop(ctxt);\n\n            CHECK_TYPE0(XPATH_NODESET);\n            arg1 = valuePop(ctxt);\n\n\t    if ((arg1->nodesetval == NULL) ||\n\t\t((arg2->nodesetval != NULL) &&\n\t\t (arg2->nodesetval->nodeNr != 0)))\n\t    {\n\t\targ1->nodesetval = xmlXPathNodeSetMerge(arg1->nodesetval,\n\t\t\t\t\t\t\targ2->nodesetval);\n\t    }\n\n            valuePush(ctxt, arg1);\n\t    xmlXPathReleaseObject(ctxt->context, arg2);\n            return (total);\n        case XPATH_OP_ROOT:\n            xmlXPathRoot(ctxt);\n            return (total);\n        case XPATH_OP_NODE:\n            if (op->ch1 != -1)\n                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t    CHECK_ERROR0;\n            if (op->ch2 != -1)\n                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);\n\t    CHECK_ERROR0;\n\t    valuePush(ctxt, xmlXPathCacheNewNodeSet(ctxt->context,\n\t\tctxt->context->node));\n            return (total);\n        case XPATH_OP_RESET:\n            if (op->ch1 != -1)\n                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t    CHECK_ERROR0;\n            if (op->ch2 != -1)\n                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);\n\t    CHECK_ERROR0;\n            ctxt->context->node = NULL;\n            return (total);\n        case XPATH_OP_COLLECT:{\n                if (op->ch1 == -1)\n                    return (total);\n\n                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t\tCHECK_ERROR0;\n\n                total += xmlXPathNodeCollectAndTest(ctxt, op, NULL, NULL, 0);\n                return (total);\n            }\n        case XPATH_OP_VALUE:\n            valuePush(ctxt,\n                      xmlXPathCacheObjectCopy(ctxt->context,\n\t\t\t(xmlXPathObjectPtr) op->value4));\n            return (total);\n        case XPATH_OP_VARIABLE:{\n\t\txmlXPathObjectPtr val;\n\n                if (op->ch1 != -1)\n                    total +=\n                        xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n                if (op->value5 == NULL) {\n\t\t    val = xmlXPathVariableLookup(ctxt->context, op->value4);\n\t\t    if (val == NULL) {\n\t\t\tctxt->error = XPATH_UNDEF_VARIABLE_ERROR;\n\t\t\treturn(0);\n\t\t    }\n                    valuePush(ctxt, val);\n\t\t} else {\n                    const xmlChar *URI;\n\n                    URI = xmlXPathNsLookup(ctxt->context, op->value5);\n                    if (URI == NULL) {\n                        xmlGenericError(xmlGenericErrorContext,\n            \"xmlXPathCompOpEval: variable %s bound to undefined prefix %s\\n\",\n                                    (char *) op->value4, (char *)op->value5);\n                        return (total);\n                    }\n\t\t    val = xmlXPathVariableLookupNS(ctxt->context,\n                                                       op->value4, URI);\n\t\t    if (val == NULL) {\n\t\t\tctxt->error = XPATH_UNDEF_VARIABLE_ERROR;\n\t\t\treturn(0);\n\t\t    }\n                    valuePush(ctxt, val);\n                }\n                return (total);\n            }\n        case XPATH_OP_FUNCTION:{\n                xmlXPathFunction func;\n                const xmlChar *oldFunc, *oldFuncURI;\n\t\tint i;\n\n                if (op->ch1 != -1)\n                    total +=\n                        xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t\tif (ctxt->valueNr < op->value) {\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"xmlXPathCompOpEval: parameter error\\n\");\n\t\t    ctxt->error = XPATH_INVALID_OPERAND;\n\t\t    return (total);\n\t\t}\n\t\tfor (i = 0; i < op->value; i++)\n\t\t    if (ctxt->valueTab[(ctxt->valueNr - 1) - i] == NULL) {\n\t\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\t\"xmlXPathCompOpEval: parameter error\\n\");\n\t\t\tctxt->error = XPATH_INVALID_OPERAND;\n\t\t\treturn (total);\n\t\t    }\n                if (op->cache != NULL)\n                    XML_CAST_FPTR(func) = op->cache;\n                else {\n                    const xmlChar *URI = NULL;\n\n                    if (op->value5 == NULL)\n                        func =\n                            xmlXPathFunctionLookup(ctxt->context,\n                                                   op->value4);\n                    else {\n                        URI = xmlXPathNsLookup(ctxt->context, op->value5);\n                        if (URI == NULL) {\n                            xmlGenericError(xmlGenericErrorContext,\n            \"xmlXPathCompOpEval: function %s bound to undefined prefix %s\\n\",\n                                    (char *)op->value4, (char *)op->value5);\n                            return (total);\n                        }\n                        func = xmlXPathFunctionLookupNS(ctxt->context,\n                                                        op->value4, URI);\n                    }\n                    if (func == NULL) {\n                        xmlGenericError(xmlGenericErrorContext,\n                                \"xmlXPathCompOpEval: function %s not found\\n\",\n                                        (char *)op->value4);\n                        XP_ERROR0(XPATH_UNKNOWN_FUNC_ERROR);\n                    }\n                    op->cache = XML_CAST_FPTR(func);\n                    op->cacheURI = (void *) URI;\n                }\n                oldFunc = ctxt->context->function;\n                oldFuncURI = ctxt->context->functionURI;\n                ctxt->context->function = op->value4;\n                ctxt->context->functionURI = op->cacheURI;\n                func(ctxt, op->value);\n                ctxt->context->function = oldFunc;\n                ctxt->context->functionURI = oldFuncURI;\n                return (total);\n            }\n        case XPATH_OP_ARG:\n\t    bakd = ctxt->context->doc;\n\t    bak = ctxt->context->node;\n\t    pp = ctxt->context->proximityPosition;\n\t    cs = ctxt->context->contextSize;\n            if (op->ch1 != -1)\n                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t    ctxt->context->contextSize = cs;\n\t    ctxt->context->proximityPosition = pp;\n\t    ctxt->context->node = bak;\n\t    ctxt->context->doc = bakd;\n\t    CHECK_ERROR0;\n            if (op->ch2 != -1) {\n                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);\n\t        ctxt->context->doc = bakd;\n\t        ctxt->context->node = bak;\n\t        CHECK_ERROR0;\n\t    }\n            return (total);\n        case XPATH_OP_PREDICATE:\n        case XPATH_OP_FILTER:{\n                xmlXPathObjectPtr res;\n                xmlXPathObjectPtr obj, tmp;\n                xmlNodeSetPtr newset = NULL;\n                xmlNodeSetPtr oldset;\n                xmlNodePtr oldnode;\n\t\txmlDocPtr oldDoc;\n                int i;\n\n                /*\n                 * Optimization for ()[1] selection i.e. the first elem\n                 */\n                if ((op->ch1 != -1) && (op->ch2 != -1) &&\n#ifdef XP_OPTIMIZED_FILTER_FIRST\n\t\t    /*\n\t\t    * FILTER TODO: Can we assume that the inner processing\n\t\t    *  will result in an ordered list if we have an\n\t\t    *  XPATH_OP_FILTER?\n\t\t    *  What about an additional field or flag on\n\t\t    *  xmlXPathObject like @sorted ? This way we wouln'd need\n\t\t    *  to assume anything, so it would be more robust and\n\t\t    *  easier to optimize.\n\t\t    */\n                    ((comp->steps[op->ch1].op == XPATH_OP_SORT) || /* 18 */\n\t\t     (comp->steps[op->ch1].op == XPATH_OP_FILTER)) && /* 17 */\n#else\n\t\t    (comp->steps[op->ch1].op == XPATH_OP_SORT) &&\n#endif\n                    (comp->steps[op->ch2].op == XPATH_OP_VALUE)) { /* 12 */\n                    xmlXPathObjectPtr val;\n\n                    val = comp->steps[op->ch2].value4;\n                    if ((val != NULL) && (val->type == XPATH_NUMBER) &&\n                        (val->floatval == 1.0)) {\n                        xmlNodePtr first = NULL;\n\n                        total +=\n                            xmlXPathCompOpEvalFirst(ctxt,\n                                                    &comp->steps[op->ch1],\n                                                    &first);\n\t\t\tCHECK_ERROR0;\n                        /*\n                         * The nodeset should be in document order,\n                         * Keep only the first value\n                         */\n                        if ((ctxt->value != NULL) &&\n                            (ctxt->value->type == XPATH_NODESET) &&\n                            (ctxt->value->nodesetval != NULL) &&\n                            (ctxt->value->nodesetval->nodeNr > 1))\n                            ctxt->value->nodesetval->nodeNr = 1;\n                        return (total);\n                    }\n                }\n                /*\n                 * Optimization for ()[last()] selection i.e. the last elem\n                 */\n                if ((op->ch1 != -1) && (op->ch2 != -1) &&\n                    (comp->steps[op->ch1].op == XPATH_OP_SORT) &&\n                    (comp->steps[op->ch2].op == XPATH_OP_SORT)) {\n                    int f = comp->steps[op->ch2].ch1;\n\n                    if ((f != -1) &&\n                        (comp->steps[f].op == XPATH_OP_FUNCTION) &&\n                        (comp->steps[f].value5 == NULL) &&\n                        (comp->steps[f].value == 0) &&\n                        (comp->steps[f].value4 != NULL) &&\n                        (xmlStrEqual\n                         (comp->steps[f].value4, BAD_CAST \"last\"))) {\n                        xmlNodePtr last = NULL;\n\n                        total +=\n                            xmlXPathCompOpEvalLast(ctxt,\n                                                   &comp->steps[op->ch1],\n                                                   &last);\n\t\t\tCHECK_ERROR0;\n                        /*\n                         * The nodeset should be in document order,\n                         * Keep only the last value\n                         */\n                        if ((ctxt->value != NULL) &&\n                            (ctxt->value->type == XPATH_NODESET) &&\n                            (ctxt->value->nodesetval != NULL) &&\n                            (ctxt->value->nodesetval->nodeTab != NULL) &&\n                            (ctxt->value->nodesetval->nodeNr > 1)) {\n                            ctxt->value->nodesetval->nodeTab[0] =\n                                ctxt->value->nodesetval->nodeTab[ctxt->\n                                                                 value->\n                                                                 nodesetval->\n                                                                 nodeNr -\n                                                                 1];\n                            ctxt->value->nodesetval->nodeNr = 1;\n                        }\n                        return (total);\n                    }\n                }\n\t\t/*\n\t\t* Process inner predicates first.\n\t\t* Example \"index[parent::book][1]\":\n\t\t* ...\n\t\t*   PREDICATE   <-- we are here \"[1]\"\n\t\t*     PREDICATE <-- process \"[parent::book]\" first\n\t\t*       SORT\n\t\t*         COLLECT  'parent' 'name' 'node' book\n\t\t*           NODE\n\t\t*     ELEM Object is a number : 1\n\t\t*/\n                if (op->ch1 != -1)\n                    total +=\n                        xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t\tCHECK_ERROR0;\n                if (op->ch2 == -1)\n                    return (total);\n                if (ctxt->value == NULL)\n                    return (total);\n\n                oldnode = ctxt->context->node;\n\n#ifdef LIBXML_XPTR_ENABLED\n                /*\n                 * Hum are we filtering the result of an XPointer expression\n                 */\n                if (ctxt->value->type == XPATH_LOCATIONSET) {\n                    xmlLocationSetPtr newlocset = NULL;\n                    xmlLocationSetPtr oldlocset;\n\n                    /*\n                     * Extract the old locset, and then evaluate the result of the\n                     * expression for all the element in the locset. use it to grow\n                     * up a new locset.\n                     */\n                    CHECK_TYPE0(XPATH_LOCATIONSET);\n                    obj = valuePop(ctxt);\n                    oldlocset = obj->user;\n                    ctxt->context->node = NULL;\n\n                    if ((oldlocset == NULL) || (oldlocset->locNr == 0)) {\n                        ctxt->context->contextSize = 0;\n                        ctxt->context->proximityPosition = 0;\n                        if (op->ch2 != -1)\n                            total +=\n                                xmlXPathCompOpEval(ctxt,\n                                                   &comp->steps[op->ch2]);\n                        res = valuePop(ctxt);\n                        if (res != NULL) {\n\t\t\t    xmlXPathReleaseObject(ctxt->context, res);\n\t\t\t}\n                        valuePush(ctxt, obj);\n                        CHECK_ERROR0;\n                        return (total);\n                    }\n                    newlocset = xmlXPtrLocationSetCreate(NULL);\n\n                    for (i = 0; i < oldlocset->locNr; i++) {\n                        /*\n                         * Run the evaluation with a node list made of a\n                         * single item in the nodelocset.\n                         */\n                        ctxt->context->node = oldlocset->locTab[i]->user;\n                        ctxt->context->contextSize = oldlocset->locNr;\n                        ctxt->context->proximityPosition = i + 1;\n\t\t\ttmp = xmlXPathCacheNewNodeSet(ctxt->context,\n\t\t\t    ctxt->context->node);\n                        valuePush(ctxt, tmp);\n\n                        if (op->ch2 != -1)\n                            total +=\n                                xmlXPathCompOpEval(ctxt,\n                                                   &comp->steps[op->ch2]);\n\t\t\tif (ctxt->error != XPATH_EXPRESSION_OK) {\n\t\t\t    xmlXPathFreeObject(obj);\n\t\t\t    return(0);\n\t\t\t}\n\n                        /*\n                         * The result of the evaluation need to be tested to\n                         * decided whether the filter succeeded or not\n                         */\n                        res = valuePop(ctxt);\n                        if (xmlXPathEvaluatePredicateResult(ctxt, res)) {\n                            xmlXPtrLocationSetAdd(newlocset,\n                                                  xmlXPathObjectCopy\n                                                  (oldlocset->locTab[i]));\n                        }\n\n                        /*\n                         * Cleanup\n                         */\n                        if (res != NULL) {\n\t\t\t    xmlXPathReleaseObject(ctxt->context, res);\n\t\t\t}\n                        if (ctxt->value == tmp) {\n                            res = valuePop(ctxt);\n\t\t\t    xmlXPathReleaseObject(ctxt->context, res);\n                        }\n\n                        ctxt->context->node = NULL;\n                    }\n\n                    /*\n                     * The result is used as the new evaluation locset.\n                     */\n\t\t    xmlXPathReleaseObject(ctxt->context, obj);\n                    ctxt->context->node = NULL;\n                    ctxt->context->contextSize = -1;\n                    ctxt->context->proximityPosition = -1;\n                    valuePush(ctxt, xmlXPtrWrapLocationSet(newlocset));\n                    ctxt->context->node = oldnode;\n                    return (total);\n                }\n#endif /* LIBXML_XPTR_ENABLED */\n\n                /*\n                 * Extract the old set, and then evaluate the result of the\n                 * expression for all the element in the set. use it to grow\n                 * up a new set.\n                 */\n                CHECK_TYPE0(XPATH_NODESET);\n                obj = valuePop(ctxt);\n                oldset = obj->nodesetval;\n\n                oldnode = ctxt->context->node;\n\t\toldDoc = ctxt->context->doc;\n                ctxt->context->node = NULL;\n\n                if ((oldset == NULL) || (oldset->nodeNr == 0)) {\n                    ctxt->context->contextSize = 0;\n                    ctxt->context->proximityPosition = 0;\n/*\n                    if (op->ch2 != -1)\n                        total +=\n                            xmlXPathCompOpEval(ctxt,\n                                               &comp->steps[op->ch2]);\n\t\t    CHECK_ERROR0;\n                    res = valuePop(ctxt);\n                    if (res != NULL)\n                        xmlXPathFreeObject(res);\n*/\n                    valuePush(ctxt, obj);\n                    ctxt->context->node = oldnode;\n                    CHECK_ERROR0;\n                } else {\n\t\t    tmp = NULL;\n                    /*\n                     * Initialize the new set.\n\t\t     * Also set the xpath document in case things like\n\t\t     * key() evaluation are attempted on the predicate\n                     */\n                    newset = xmlXPathNodeSetCreate(NULL);\n\t\t    /*\n\t\t    * SPEC XPath 1.0:\n\t\t    *  \"For each node in the node-set to be filtered, the\n\t\t    *  PredicateExpr is evaluated with that node as the\n\t\t    *  context node, with the number of nodes in the\n\t\t    *  node-set as the context size, and with the proximity\n\t\t    *  position of the node in the node-set with respect to\n\t\t    *  the axis as the context position;\"\n\t\t    * @oldset is the node-set\" to be filtered.\n\t\t    *\n\t\t    * SPEC XPath 1.0:\n\t\t    *  \"only predicates change the context position and\n\t\t    *  context size (see [2.4 Predicates]).\"\n\t\t    * Example:\n\t\t    *   node-set  context pos\n\t\t    *    nA         1\n\t\t    *    nB         2\n\t\t    *    nC         3\n\t\t    *   After applying predicate [position() > 1] :\n\t\t    *   node-set  context pos\n\t\t    *    nB         1\n\t\t    *    nC         2\n\t\t    *\n\t\t    * removed the first node in the node-set, then\n\t\t    * the context position of the\n\t\t    */\n                    for (i = 0; i < oldset->nodeNr; i++) {\n                        /*\n                         * Run the evaluation with a node list made of\n                         * a single item in the nodeset.\n                         */\n                        ctxt->context->node = oldset->nodeTab[i];\n\t\t\tif ((oldset->nodeTab[i]->type != XML_NAMESPACE_DECL) &&\n\t\t\t    (oldset->nodeTab[i]->doc != NULL))\n\t\t            ctxt->context->doc = oldset->nodeTab[i]->doc;\n\t\t\tif (tmp == NULL) {\n\t\t\t    tmp = xmlXPathCacheNewNodeSet(ctxt->context,\n\t\t\t\tctxt->context->node);\n\t\t\t} else {\n\t\t\t    xmlXPathNodeSetAddUnique(tmp->nodesetval,\n\t\t\t\tctxt->context->node);\n\t\t\t}\n                        valuePush(ctxt, tmp);\n                        ctxt->context->contextSize = oldset->nodeNr;\n                        ctxt->context->proximityPosition = i + 1;\n\t\t\t/*\n\t\t\t* Evaluate the predicate against the context node.\n\t\t\t* Can/should we optimize position() predicates\n\t\t\t* here (e.g. \"[1]\")?\n\t\t\t*/\n                        if (op->ch2 != -1)\n                            total +=\n                                xmlXPathCompOpEval(ctxt,\n                                                   &comp->steps[op->ch2]);\n\t\t\tif (ctxt->error != XPATH_EXPRESSION_OK) {\n\t\t\t    xmlXPathFreeNodeSet(newset);\n\t\t\t    xmlXPathFreeObject(obj);\n\t\t\t    return(0);\n\t\t\t}\n\n                        /*\n                         * The result of the evaluation needs to be tested to\n                         * decide whether the filter succeeded or not\n                         */\n\t\t\t/*\n\t\t\t* OPTIMIZE TODO: Can we use\n\t\t\t* xmlXPathNodeSetAdd*Unique()* instead?\n\t\t\t*/\n                        res = valuePop(ctxt);\n                        if (xmlXPathEvaluatePredicateResult(ctxt, res)) {\n                            xmlXPathNodeSetAdd(newset, oldset->nodeTab[i]);\n                        }\n\n                        /*\n                         * Cleanup\n                         */\n                        if (res != NULL) {\n\t\t\t    xmlXPathReleaseObject(ctxt->context, res);\n\t\t\t}\n                        if (ctxt->value == tmp) {\n                            valuePop(ctxt);\n\t\t\t    xmlXPathNodeSetClear(tmp->nodesetval, 1);\n\t\t\t    /*\n\t\t\t    * Don't free the temporary nodeset\n\t\t\t    * in order to avoid massive recreation inside this\n\t\t\t    * loop.\n\t\t\t    */\n                        } else\n\t\t\t    tmp = NULL;\n                        ctxt->context->node = NULL;\n                    }\n\t\t    if (tmp != NULL)\n\t\t\txmlXPathReleaseObject(ctxt->context, tmp);\n                    /*\n                     * The result is used as the new evaluation set.\n                     */\n\t\t    xmlXPathReleaseObject(ctxt->context, obj);\n                    ctxt->context->node = NULL;\n                    ctxt->context->contextSize = -1;\n                    ctxt->context->proximityPosition = -1;\n\t\t    /* may want to move this past the '}' later */\n\t\t    ctxt->context->doc = oldDoc;\n\t\t    valuePush(ctxt,\n\t\t\txmlXPathCacheWrapNodeSet(ctxt->context, newset));\n                }\n                ctxt->context->node = oldnode;\n                return (total);\n            }\n        case XPATH_OP_SORT:\n            if (op->ch1 != -1)\n                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t    CHECK_ERROR0;\n            if ((ctxt->value != NULL) &&\n                (ctxt->value->type == XPATH_NODESET) &&\n                (ctxt->value->nodesetval != NULL) &&\n\t\t(ctxt->value->nodesetval->nodeNr > 1))\n\t    {\n                xmlXPathNodeSetSort(ctxt->value->nodesetval);\n\t    }\n            return (total);\n#ifdef LIBXML_XPTR_ENABLED\n        case XPATH_OP_RANGETO:{\n                xmlXPathObjectPtr range;\n                xmlXPathObjectPtr res, obj;\n                xmlXPathObjectPtr tmp;\n                xmlLocationSetPtr newlocset = NULL;\n\t\t    xmlLocationSetPtr oldlocset;\n                xmlNodeSetPtr oldset;\n                int i, j;\n\n                if (op->ch1 != -1)\n                    total +=\n                        xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n                if (op->ch2 == -1)\n                    return (total);\n\n                if (ctxt->value->type == XPATH_LOCATIONSET) {\n                    /*\n                     * Extract the old locset, and then evaluate the result of the\n                     * expression for all the element in the locset. use it to grow\n                     * up a new locset.\n                     */\n                    CHECK_TYPE0(XPATH_LOCATIONSET);\n                    obj = valuePop(ctxt);\n                    oldlocset = obj->user;\n\n                    if ((oldlocset == NULL) || (oldlocset->locNr == 0)) {\n\t\t        ctxt->context->node = NULL;\n                        ctxt->context->contextSize = 0;\n                        ctxt->context->proximityPosition = 0;\n                        total += xmlXPathCompOpEval(ctxt,&comp->steps[op->ch2]);\n                        res = valuePop(ctxt);\n                        if (res != NULL) {\n\t\t\t    xmlXPathReleaseObject(ctxt->context, res);\n\t\t\t}\n                        valuePush(ctxt, obj);\n                        CHECK_ERROR0;\n                        return (total);\n                    }\n                    newlocset = xmlXPtrLocationSetCreate(NULL);\n\n                    for (i = 0; i < oldlocset->locNr; i++) {\n                        /*\n                         * Run the evaluation with a node list made of a\n                         * single item in the nodelocset.\n                         */\n                        ctxt->context->node = oldlocset->locTab[i]->user;\n                        ctxt->context->contextSize = oldlocset->locNr;\n                        ctxt->context->proximityPosition = i + 1;\n\t\t\ttmp = xmlXPathCacheNewNodeSet(ctxt->context,\n\t\t\t    ctxt->context->node);\n                        valuePush(ctxt, tmp);\n\n                        if (op->ch2 != -1)\n                            total +=\n                                xmlXPathCompOpEval(ctxt,\n                                                   &comp->steps[op->ch2]);\n\t\t\tif (ctxt->error != XPATH_EXPRESSION_OK) {\n\t\t\t    xmlXPathFreeObject(obj);\n\t\t\t    return(0);\n\t\t\t}\n\n                        res = valuePop(ctxt);\n\t\t\tif (res->type == XPATH_LOCATIONSET) {\n\t\t\t    xmlLocationSetPtr rloc =\n\t\t\t        (xmlLocationSetPtr)res->user;\n\t\t\t    for (j=0; j<rloc->locNr; j++) {\n\t\t\t        range = xmlXPtrNewRange(\n\t\t\t\t  oldlocset->locTab[i]->user,\n\t\t\t\t  oldlocset->locTab[i]->index,\n\t\t\t\t  rloc->locTab[j]->user2,\n\t\t\t\t  rloc->locTab[j]->index2);\n\t\t\t\tif (range != NULL) {\n\t\t\t\t    xmlXPtrLocationSetAdd(newlocset, range);\n\t\t\t\t}\n\t\t\t    }\n\t\t\t} else {\n\t\t\t    range = xmlXPtrNewRangeNodeObject(\n\t\t\t\t(xmlNodePtr)oldlocset->locTab[i]->user, res);\n                            if (range != NULL) {\n                                xmlXPtrLocationSetAdd(newlocset,range);\n\t\t\t    }\n                        }\n\n                        /*\n                         * Cleanup\n                         */\n                        if (res != NULL) {\n\t\t\t    xmlXPathReleaseObject(ctxt->context, res);\n\t\t\t}\n                        if (ctxt->value == tmp) {\n                            res = valuePop(ctxt);\n\t\t\t    xmlXPathReleaseObject(ctxt->context, res);\n                        }\n\n                        ctxt->context->node = NULL;\n                    }\n\t\t} else {\t/* Not a location set */\n                    CHECK_TYPE0(XPATH_NODESET);\n                    obj = valuePop(ctxt);\n                    oldset = obj->nodesetval;\n                    ctxt->context->node = NULL;\n\n                    newlocset = xmlXPtrLocationSetCreate(NULL);\n\n                    if (oldset != NULL) {\n                        for (i = 0; i < oldset->nodeNr; i++) {\n                            /*\n                             * Run the evaluation with a node list made of a single item\n                             * in the nodeset.\n                             */\n                            ctxt->context->node = oldset->nodeTab[i];\n\t\t\t    /*\n\t\t\t    * OPTIMIZE TODO: Avoid recreation for every iteration.\n\t\t\t    */\n\t\t\t    tmp = xmlXPathCacheNewNodeSet(ctxt->context,\n\t\t\t\tctxt->context->node);\n                            valuePush(ctxt, tmp);\n\n                            if (op->ch2 != -1)\n                                total +=\n                                    xmlXPathCompOpEval(ctxt,\n                                                   &comp->steps[op->ch2]);\n\t\t\t    if (ctxt->error != XPATH_EXPRESSION_OK) {\n\t\t\t\txmlXPathFreeObject(obj);\n\t\t\t\treturn(0);\n\t\t\t    }\n\n                            res = valuePop(ctxt);\n                            range =\n                                xmlXPtrNewRangeNodeObject(oldset->nodeTab[i],\n                                                      res);\n                            if (range != NULL) {\n                                xmlXPtrLocationSetAdd(newlocset, range);\n                            }\n\n                            /*\n                             * Cleanup\n                             */\n                            if (res != NULL) {\n\t\t\t\txmlXPathReleaseObject(ctxt->context, res);\n\t\t\t    }\n                            if (ctxt->value == tmp) {\n                                res = valuePop(ctxt);\n\t\t\t\txmlXPathReleaseObject(ctxt->context, res);\n                            }\n\n                            ctxt->context->node = NULL;\n                        }\n                    }\n                }\n\n                /*\n                 * The result is used as the new evaluation set.\n                 */\n\t\txmlXPathReleaseObject(ctxt->context, obj);\n                ctxt->context->node = NULL;\n                ctxt->context->contextSize = -1;\n                ctxt->context->proximityPosition = -1;\n                valuePush(ctxt, xmlXPtrWrapLocationSet(newlocset));\n                return (total);\n            }\n#endif /* LIBXML_XPTR_ENABLED */\n    }\n    xmlGenericError(xmlGenericErrorContext,\n                    \"XPath: unknown precompiled operation %d\\n\", op->op);",
        "target": 1
    },
    {
        "func": "valuePop(xmlXPathParserContextPtr ctxt)\n{\n    xmlXPathObjectPtr ret;\n\n    if ((ctxt == NULL) || (ctxt->valueNr <= 0))\n        return (NULL);\n    ctxt->valueNr--;\n    if (ctxt->valueNr > 0)\n        ctxt->value = ctxt->valueTab[ctxt->valueNr - 1];\n    else\n        ctxt->value = NULL;\n    ret = ctxt->valueTab[ctxt->valueNr];\n    ctxt->valueTab[ctxt->valueNr] = NULL;\n    return (ret);\n}",
        "target": 1
    },
    {
        "func": "static void scsi_read_data(SCSIRequest *req)\n{\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n    uint32_t n;\n\n    if (r->sector_count == (uint32_t)-1) {\n        DPRINTF(\"Read buf_len=%zd\\n\", r->iov.iov_len);\n        r->sector_count = 0;\n        scsi_req_data(&r->req, r->iov.iov_len);\n        return;\n    }\n    DPRINTF(\"Read sector_count=%d\\n\", r->sector_count);\n    if (r->sector_count == 0) {\n        /* This also clears the sense buffer for REQUEST SENSE.  */\n        scsi_req_complete(&r->req, GOOD);\n        return;\n    }\n\n    /* No data transfer may already be in progress */\n    assert(r->req.aiocb == NULL);\n\n    if (r->req.cmd.mode == SCSI_XFER_TO_DEV) {\n        DPRINTF(\"Data transfer direction invalid\\n\");\n        scsi_read_complete(r, -EINVAL);\n        return;\n    }\n\n    n = r->sector_count;\n    if (n > SCSI_DMA_BUF_SIZE / 512)\n        n = SCSI_DMA_BUF_SIZE / 512;\n\n    if (s->tray_open) {\n        scsi_read_complete(r, -ENOMEDIUM);\n    }\n    r->iov.iov_len = n * 512;\n    qemu_iovec_init_external(&r->qiov, &r->iov, 1);\n\n    bdrv_acct_start(s->bs, &r->acct, n * BDRV_SECTOR_SIZE, BDRV_ACCT_READ);\n    r->req.aiocb = bdrv_aio_readv(s->bs, r->sector, &r->qiov, n,\n                              scsi_read_complete, r);\n    if (r->req.aiocb == NULL) {\n        scsi_read_complete(r, -EIO);\n    }\n}",
        "target": 1
    },
    {
        "func": "static void scsi_write_complete(void * opaque, int ret)\n{\n    SCSIDiskReq *r = (SCSIDiskReq *)opaque;\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n    uint32_t len;\n    uint32_t n;\n\n    if (r->req.aiocb != NULL) {\n        r->req.aiocb = NULL;\n        bdrv_acct_done(s->bs, &r->acct);\n    }\n\n    if (ret) {\n        if (scsi_handle_rw_error(r, -ret, SCSI_REQ_STATUS_RETRY_WRITE)) {\n            return;\n        }\n    }\n\n    n = r->iov.iov_len / 512;\n    r->sector += n;\n    r->sector_count -= n;\n    if (r->sector_count == 0) {\n        scsi_req_complete(&r->req, GOOD);\n    } else {\n        len = r->sector_count * 512;\n        if (len > SCSI_DMA_BUF_SIZE) {\n            len = SCSI_DMA_BUF_SIZE;\n        }\n        r->iov.iov_len = len;\n        DPRINTF(\"Write complete tag=0x%x more=%d\\n\", r->req.tag, len);\n        scsi_req_data(&r->req, len);\n    }\n}",
        "target": 1
    },
    {
        "func": "static void scsi_read_complete(void * opaque, int ret)\n{\n    SCSIDiskReq *r = (SCSIDiskReq *)opaque;\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n    int n;\n\n    if (r->req.aiocb != NULL) {\n        r->req.aiocb = NULL;\n        bdrv_acct_done(s->bs, &r->acct);\n    }\n\n    if (ret) {\n        if (scsi_handle_rw_error(r, -ret, SCSI_REQ_STATUS_RETRY_READ)) {\n            return;\n        }\n    }\n\n    DPRINTF(\"Data ready tag=0x%x len=%zd\\n\", r->req.tag, r->iov.iov_len);\n\n    n = r->iov.iov_len / 512;\n    r->sector += n;\n    r->sector_count -= n;\n    scsi_req_data(&r->req, r->iov.iov_len);\n}",
        "target": 1
    },
    {
        "func": "static void scsi_write_data(SCSIRequest *req)\n{\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n    uint32_t n;\n\n    /* No data transfer may already be in progress */\n    assert(r->req.aiocb == NULL);\n\n    if (r->req.cmd.mode != SCSI_XFER_TO_DEV) {\n        DPRINTF(\"Data transfer direction invalid\\n\");\n        scsi_write_complete(r, -EINVAL);\n        return;\n    }\n\n    n = r->iov.iov_len / 512;\n    if (n) {\n        if (s->tray_open) {\n            scsi_write_complete(r, -ENOMEDIUM);\n        }\n        qemu_iovec_init_external(&r->qiov, &r->iov, 1);\n\n        bdrv_acct_start(s->bs, &r->acct, n * BDRV_SECTOR_SIZE, BDRV_ACCT_WRITE);\n        r->req.aiocb = bdrv_aio_writev(s->bs, r->sector, &r->qiov, n,\n                                   scsi_write_complete, r);\n        if (r->req.aiocb == NULL) {\n            scsi_write_complete(r, -ENOMEM);\n        }\n    } else {\n        /* Invoke completion routine to fetch data from host.  */\n        scsi_write_complete(r, 0);\n    }\n}",
        "target": 1
    },
    {
        "func": "static void scsi_free_request(SCSIRequest *req)\n{\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n\n    qemu_vfree(r->iov.iov_base);\n}",
        "target": 1
    },
    {
        "func": "static void scsi_dma_restart_bh(void *opaque)\n{\n    SCSIDiskState *s = opaque;\n    SCSIRequest *req;\n    SCSIDiskReq *r;\n\n    qemu_bh_delete(s->bh);\n    s->bh = NULL;\n\n    QTAILQ_FOREACH(req, &s->qdev.requests, next) {\n        r = DO_UPCAST(SCSIDiskReq, req, req);\n        if (r->status & SCSI_REQ_STATUS_RETRY) {\n            int status = r->status;\n            int ret;\n\n            r->status &=\n                ~(SCSI_REQ_STATUS_RETRY | SCSI_REQ_STATUS_RETRY_TYPE_MASK);\n\n            switch (status & SCSI_REQ_STATUS_RETRY_TYPE_MASK) {\n            case SCSI_REQ_STATUS_RETRY_READ:\n                scsi_read_data(&r->req);\n                break;\n            case SCSI_REQ_STATUS_RETRY_WRITE:\n                scsi_write_data(&r->req);\n                break;\n            case SCSI_REQ_STATUS_RETRY_FLUSH:\n                ret = scsi_disk_emulate_command(r, r->iov.iov_base);\n                if (ret == 0) {\n                    scsi_req_complete(&r->req, GOOD);\n                }\n            }\n        }\n    }\n}",
        "target": 1
    },
    {
        "func": "static uint32_t scsi_init_iovec(SCSIDiskReq *r)\n{\n    r->iov.iov_len = MIN(r->sector_count * 512, SCSI_DMA_BUF_SIZE);\n    qemu_iovec_init_external(&r->qiov, &r->iov, 1);\n    return r->qiov.size / 512;\n}",
        "target": 1
    },
    {
        "func": "static int scsi_disk_emulate_command(SCSIDiskReq *r, uint8_t *outbuf)\n{\n    SCSIRequest *req = &r->req;\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n    uint64_t nb_sectors;\n    int buflen = 0;\n\n    switch (req->cmd.buf[0]) {\n    case TEST_UNIT_READY:\n        if (s->tray_open || !bdrv_is_inserted(s->bs))\n            goto not_ready;\n        break;\n    case INQUIRY:\n        buflen = scsi_disk_emulate_inquiry(req, outbuf);\n        if (buflen < 0)\n            goto illegal_request;\n        break;\n    case MODE_SENSE:\n    case MODE_SENSE_10:\n        buflen = scsi_disk_emulate_mode_sense(r, outbuf);\n        if (buflen < 0)\n            goto illegal_request;\n        break;\n    case READ_TOC:\n        buflen = scsi_disk_emulate_read_toc(req, outbuf);\n        if (buflen < 0)\n            goto illegal_request;\n        break;\n    case RESERVE:\n        if (req->cmd.buf[1] & 1)\n            goto illegal_request;\n        break;\n    case RESERVE_10:\n        if (req->cmd.buf[1] & 3)\n            goto illegal_request;\n        break;\n    case RELEASE:\n        if (req->cmd.buf[1] & 1)\n            goto illegal_request;\n        break;\n    case RELEASE_10:\n        if (req->cmd.buf[1] & 3)\n            goto illegal_request;\n        break;\n    case START_STOP:\n        if (scsi_disk_emulate_start_stop(r) < 0) {\n            return -1;\n        }\n        break;\n    case ALLOW_MEDIUM_REMOVAL:\n        s->tray_locked = req->cmd.buf[4] & 1;\n        bdrv_lock_medium(s->bs, req->cmd.buf[4] & 1);\n        break;\n    case READ_CAPACITY_10:\n        /* The normal LEN field for this command is zero.  */\n        memset(outbuf, 0, 8);\n        bdrv_get_geometry(s->bs, &nb_sectors);\n        if (!nb_sectors)\n            goto not_ready;\n        nb_sectors /= s->cluster_size;\n        /* Returned value is the address of the last sector.  */\n        nb_sectors--;\n        /* Remember the new size for read/write sanity checking. */\n        s->max_lba = nb_sectors;\n        /* Clip to 2TB, instead of returning capacity modulo 2TB. */\n        if (nb_sectors > UINT32_MAX)\n            nb_sectors = UINT32_MAX;\n        outbuf[0] = (nb_sectors >> 24) & 0xff;\n        outbuf[1] = (nb_sectors >> 16) & 0xff;\n        outbuf[2] = (nb_sectors >> 8) & 0xff;\n        outbuf[3] = nb_sectors & 0xff;\n        outbuf[4] = 0;\n        outbuf[5] = 0;\n        outbuf[6] = s->cluster_size * 2;\n        outbuf[7] = 0;\n        buflen = 8;\n        break;\n    case GET_CONFIGURATION:\n        memset(outbuf, 0, 8);\n        /* ??? This should probably return much more information.  For now\n           just return the basic header indicating the CD-ROM profile.  */\n        outbuf[7] = 8; // CD-ROM\n        buflen = 8;\n        break;\n    case SERVICE_ACTION_IN_16:\n        /* Service Action In subcommands. */\n        if ((req->cmd.buf[1] & 31) == SAI_READ_CAPACITY_16) {\n            DPRINTF(\"SAI READ CAPACITY(16)\\n\");\n            memset(outbuf, 0, req->cmd.xfer);\n            bdrv_get_geometry(s->bs, &nb_sectors);\n            if (!nb_sectors)\n                goto not_ready;\n            nb_sectors /= s->cluster_size;\n            /* Returned value is the address of the last sector.  */\n            nb_sectors--;\n            /* Remember the new size for read/write sanity checking. */\n            s->max_lba = nb_sectors;\n            outbuf[0] = (nb_sectors >> 56) & 0xff;\n            outbuf[1] = (nb_sectors >> 48) & 0xff;\n            outbuf[2] = (nb_sectors >> 40) & 0xff;\n            outbuf[3] = (nb_sectors >> 32) & 0xff;\n            outbuf[4] = (nb_sectors >> 24) & 0xff;\n            outbuf[5] = (nb_sectors >> 16) & 0xff;\n            outbuf[6] = (nb_sectors >> 8) & 0xff;\n            outbuf[7] = nb_sectors & 0xff;\n            outbuf[8] = 0;\n            outbuf[9] = 0;\n            outbuf[10] = s->cluster_size * 2;\n            outbuf[11] = 0;\n            outbuf[12] = 0;\n            outbuf[13] = get_physical_block_exp(&s->qdev.conf);\n\n            /* set TPE bit if the format supports discard */\n            if (s->qdev.conf.discard_granularity) {\n                outbuf[14] = 0x80;\n            }\n\n            /* Protection, exponent and lowest lba field left blank. */\n            buflen = req->cmd.xfer;\n            break;\n        }\n        DPRINTF(\"Unsupported Service Action In\\n\");\n        goto illegal_request;\n    case VERIFY_10:\n        break;\n    default:\n        scsi_check_condition(r, SENSE_CODE(INVALID_OPCODE));\n        return -1;\n    }\n    return buflen;\n\nnot_ready:\n    if (s->tray_open || !bdrv_is_inserted(s->bs)) {\n        scsi_check_condition(r, SENSE_CODE(NO_MEDIUM));\n    } else {\n        scsi_check_condition(r, SENSE_CODE(LUN_NOT_READY));\n    }\n    return -1;\n\nillegal_request:\n    if (r->req.status == -1) {\n        scsi_check_condition(r, SENSE_CODE(INVALID_FIELD));\n    }\n    return -1;\n}",
        "target": 1
    },
    {
        "func": "static SCSIRequest *scsi_new_request(SCSIDevice *d, uint32_t tag,\n                                     uint32_t lun, void *hba_private)\n{\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, d);\n    SCSIRequest *req;\n    SCSIDiskReq *r;\n\n    req = scsi_req_alloc(&scsi_disk_reqops, &s->qdev, tag, lun, hba_private);\n    r = DO_UPCAST(SCSIDiskReq, req, req);\n    r->iov.iov_base = qemu_blockalign(s->bs, SCSI_DMA_BUF_SIZE);\n    return req;\n}",
        "target": 1
    },
    {
        "func": "static int32_t scsi_send_command(SCSIRequest *req, uint8_t *buf)\n{\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n    int32_t len;\n    uint8_t command;\n    uint8_t *outbuf;\n    int rc;\n\n    command = buf[0];\n    outbuf = (uint8_t *)r->iov.iov_base;\n    DPRINTF(\"Command: lun=%d tag=0x%x data=0x%02x\", req->lun, req->tag, buf[0]);\n\n#ifdef DEBUG_SCSI\n    {\n        int i;\n        for (i = 1; i < r->req.cmd.len; i++) {\n            printf(\" 0x%02x\", buf[i]);\n        }\n        printf(\"\\n\");\n    }\n#endif\n\n    switch (command) {\n    case TEST_UNIT_READY:\n    case INQUIRY:\n    case MODE_SENSE:\n    case MODE_SENSE_10:\n    case RESERVE:\n    case RESERVE_10:\n    case RELEASE:\n    case RELEASE_10:\n    case START_STOP:\n    case ALLOW_MEDIUM_REMOVAL:\n    case READ_CAPACITY_10:\n    case READ_TOC:\n    case GET_CONFIGURATION:\n    case SERVICE_ACTION_IN_16:\n    case VERIFY_10:\n        rc = scsi_disk_emulate_command(r, outbuf);\n        if (rc < 0) {\n            return 0;\n        }\n\n        r->iov.iov_len = rc;\n        break;\n    case SYNCHRONIZE_CACHE:\n        bdrv_acct_start(s->bs, &r->acct, 0, BDRV_ACCT_FLUSH);\n        r->req.aiocb = bdrv_aio_flush(s->bs, scsi_flush_complete, r);\n        if (r->req.aiocb == NULL) {\n            scsi_flush_complete(r, -EIO);\n        }\n        return 0;\n    case READ_6:\n    case READ_10:\n    case READ_12:\n    case READ_16:\n        len = r->req.cmd.xfer / s->qdev.blocksize;\n        DPRINTF(\"Read (sector %\" PRId64 \", count %d)\\n\", r->req.cmd.lba, len);\n        if (r->req.cmd.lba > s->max_lba)\n            goto illegal_lba;\n        r->sector = r->req.cmd.lba * s->cluster_size;\n        r->sector_count = len * s->cluster_size;\n        break;\n    case WRITE_6:\n    case WRITE_10:\n    case WRITE_12:\n    case WRITE_16:\n    case WRITE_VERIFY_10:\n    case WRITE_VERIFY_12:\n    case WRITE_VERIFY_16:\n        len = r->req.cmd.xfer / s->qdev.blocksize;\n        DPRINTF(\"Write %s(sector %\" PRId64 \", count %d)\\n\",\n                (command & 0xe) == 0xe ? \"And Verify \" : \"\",\n                r->req.cmd.lba, len);\n        if (r->req.cmd.lba > s->max_lba)\n            goto illegal_lba;\n        r->sector = r->req.cmd.lba * s->cluster_size;\n        r->sector_count = len * s->cluster_size;\n        break;\n    case MODE_SELECT:\n        DPRINTF(\"Mode Select(6) (len %lu)\\n\", (long)r->req.cmd.xfer);\n        /* We don't support mode parameter changes.\n           Allow the mode parameter header + block descriptors only. */\n        if (r->req.cmd.xfer > 12) {\n            goto fail;\n        }\n        break;\n    case MODE_SELECT_10:\n        DPRINTF(\"Mode Select(10) (len %lu)\\n\", (long)r->req.cmd.xfer);\n        /* We don't support mode parameter changes.\n           Allow the mode parameter header + block descriptors only. */\n        if (r->req.cmd.xfer > 16) {\n            goto fail;\n        }\n        break;\n    case SEEK_6:\n    case SEEK_10:\n        DPRINTF(\"Seek(%d) (sector %\" PRId64 \")\\n\", command == SEEK_6 ? 6 : 10,\n                r->req.cmd.lba);\n        if (r->req.cmd.lba > s->max_lba) {\n            goto illegal_lba;\n        }\n        break;\n    case WRITE_SAME_16:\n        len = r->req.cmd.xfer / s->qdev.blocksize;\n\n        DPRINTF(\"WRITE SAME(16) (sector %\" PRId64 \", count %d)\\n\",\n                r->req.cmd.lba, len);\n\n        if (r->req.cmd.lba > s->max_lba) {\n            goto illegal_lba;\n        }\n\n        /*\n         * We only support WRITE SAME with the unmap bit set for now.\n         */\n        if (!(buf[1] & 0x8)) {\n            goto fail;\n        }\n\n        rc = bdrv_discard(s->bs, r->req.cmd.lba * s->cluster_size,\n                          len * s->cluster_size);\n        if (rc < 0) {\n            /* XXX: better error code ?*/\n            goto fail;\n        }\n\n        break;\n    case REQUEST_SENSE:\n        abort();\n    default:\n        DPRINTF(\"Unknown SCSI command (%2.2x)\\n\", buf[0]);\n        scsi_check_condition(r, SENSE_CODE(INVALID_OPCODE));\n        return 0;\n    fail:\n        scsi_check_condition(r, SENSE_CODE(INVALID_FIELD));\n        return 0;\n    illegal_lba:\n        scsi_check_condition(r, SENSE_CODE(LBA_OUT_OF_RANGE));\n        return 0;\n    }\n    if (r->sector_count == 0 && r->iov.iov_len == 0) {\n        scsi_req_complete(&r->req, GOOD);\n    }\n    len = r->sector_count * 512 + r->iov.iov_len;\n    if (r->req.cmd.mode == SCSI_XFER_TO_DEV) {\n        return -len;\n    } else {\n        if (!r->sector_count)\n            r->sector_count = -1;\n        return len;\n    }\n}",
        "target": 1
    },
    {
        "func": "static int fuse_notify_inval_entry(struct fuse_conn *fc, unsigned int size,\n\t\t\t\t   struct fuse_copy_state *cs)\n{\n\tstruct fuse_notify_inval_entry_out outarg;\n\tint err = -ENOMEM;\n\tchar *buf;\n\tstruct qstr name;\n\n\tbuf = kzalloc(FUSE_NAME_MAX + 1, GFP_KERNEL);\n\tif (!buf)\n\t\tgoto err;\n\n\terr = -EINVAL;\n\tif (size < sizeof(outarg))\n\t\tgoto err;\n\n\terr = fuse_copy_one(cs, &outarg, sizeof(outarg));\n\tif (err)\n\t\tgoto err;\n\n\terr = -ENAMETOOLONG;\n\tif (outarg.namelen > FUSE_NAME_MAX)\n\t\tgoto err;\n\n\tname.name = buf;\n\tname.len = outarg.namelen;\n\terr = fuse_copy_one(cs, buf, outarg.namelen + 1);\n\tif (err)\n\t\tgoto err;\n\tfuse_copy_finish(cs);\n\tbuf[outarg.namelen] = 0;\n\tname.hash = full_name_hash(name.name, name.len);\n\n\tdown_read(&fc->killsb);\n\terr = -ENOENT;\n\tif (fc->sb)\n\t\terr = fuse_reverse_inval_entry(fc->sb, outarg.parent, &name);\n\tup_read(&fc->killsb);\n\tkfree(buf);\n\treturn err;\n\nerr:\n\tkfree(buf);\n\tfuse_copy_finish(cs);\n\treturn err;\n}",
        "target": 1
    },
    {
        "func": "void CtcpParser::packedReply(CoreNetwork *net, const QString &bufname, const QList<QByteArray> &replies) {\n  QList<QByteArray> params;\n\n  int answerSize = 0;\n  for(int i = 0; i < replies.count(); i++) {\n    answerSize += replies.at(i).size();\n  }\n\n  QByteArray quotedReply(answerSize, 0);\n  int nextPos = 0;\n  QByteArray &reply = quotedReply;\n  for(int i = 0; i < replies.count(); i++) {\n    reply = replies.at(i);\n    quotedReply.replace(nextPos, reply.size(), reply);\n    nextPos += reply.size();\n  }\n\n  params << net->serverEncode(bufname) << quotedReply;\n  // FIXME user proper event\n  net->putCmd(\"NOTICE\", params);\n}",
        "target": 1
    },
    {
        "func": "cifs_mount(struct super_block *sb, struct cifs_sb_info *cifs_sb,\n\t\tchar *mount_data_global, const char *devname)\n{\n\tint rc;\n\tint xid;\n\tstruct smb_vol *volume_info;\n\tstruct cifsSesInfo *pSesInfo;\n\tstruct cifsTconInfo *tcon;\n\tstruct TCP_Server_Info *srvTcp;\n\tchar   *full_path;\n\tchar *mount_data = mount_data_global;\n\tstruct tcon_link *tlink;\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\tstruct dfs_info3_param *referrals = NULL;\n\tunsigned int num_referrals = 0;\n\tint referral_walks_count = 0;\ntry_mount_again:\n#endif\n\trc = 0;\n\ttcon = NULL;\n\tpSesInfo = NULL;\n\tsrvTcp = NULL;\n\tfull_path = NULL;\n\ttlink = NULL;\n\n\txid = GetXid();\n\n\tvolume_info = kzalloc(sizeof(struct smb_vol), GFP_KERNEL);\n\tif (!volume_info) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (cifs_parse_mount_options(mount_data, devname, volume_info)) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (volume_info->nullauth) {\n\t\tcFYI(1, \"null user\");\n\t\tvolume_info->username = \"\";\n\t} else if (volume_info->username) {\n\t\t/* BB fixme parse for domain name here */\n\t\tcFYI(1, \"Username: %s\", volume_info->username);\n\t} else {\n\t\tcifserror(\"No username specified\");\n\t/* In userspace mount helper we can get user name from alternate\n\t   locations such as env variables and files on disk */\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* this is needed for ASCII cp to Unicode converts */\n\tif (volume_info->iocharset == NULL) {\n\t\t/* load_nls_default cannot return null */\n\t\tvolume_info->local_nls = load_nls_default();\n\t} else {\n\t\tvolume_info->local_nls = load_nls(volume_info->iocharset);\n\t\tif (volume_info->local_nls == NULL) {\n\t\t\tcERROR(1, \"CIFS mount error: iocharset %s not found\",\n\t\t\t\t volume_info->iocharset);\n\t\t\trc = -ELIBACC;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tcifs_sb->local_nls = volume_info->local_nls;\n\n\t/* get a reference to a tcp session */\n\tsrvTcp = cifs_get_tcp_session(volume_info);\n\tif (IS_ERR(srvTcp)) {\n\t\trc = PTR_ERR(srvTcp);\n\t\tgoto out;\n\t}\n\n\t/* get a reference to a SMB session */\n\tpSesInfo = cifs_get_smb_ses(srvTcp, volume_info);\n\tif (IS_ERR(pSesInfo)) {\n\t\trc = PTR_ERR(pSesInfo);\n\t\tpSesInfo = NULL;\n\t\tgoto mount_fail_check;\n\t}\n\n\tsetup_cifs_sb(volume_info, cifs_sb);\n\tif (pSesInfo->capabilities & CAP_LARGE_FILES)\n\t\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\telse\n\t\tsb->s_maxbytes = MAX_NON_LFS;\n\n\t/* BB FIXME fix time_gran to be larger for LANMAN sessions */\n\tsb->s_time_gran = 100;\n\n\t/* search for existing tcon to this server share */\n\ttcon = cifs_get_tcon(pSesInfo, volume_info);\n\tif (IS_ERR(tcon)) {\n\t\trc = PTR_ERR(tcon);\n\t\ttcon = NULL;\n\t\tgoto remote_path_check;\n\t}\n\n\t/* do not care if following two calls succeed - informational */\n\tif (!tcon->ipc) {\n\t\tCIFSSMBQFSDeviceInfo(xid, tcon);\n\t\tCIFSSMBQFSAttributeInfo(xid, tcon);\n\t}\n\n\t/* tell server which Unix caps we support */\n\tif (tcon->ses->capabilities & CAP_UNIX)\n\t\t/* reset of caps checks mount to see if unix extensions\n\t\t   disabled for just this mount */\n\t\treset_cifs_unix_caps(xid, tcon, sb, volume_info);\n\telse\n\t\ttcon->unix_ext = 0; /* server does not support them */\n\n\t/* convert forward to back slashes in prepath here if needed */\n\tif ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS) == 0)\n\t\tconvert_delimiter(cifs_sb->prepath, CIFS_DIR_SEP(cifs_sb));\n\n\tif ((tcon->unix_ext == 0) && (cifs_sb->rsize > (1024 * 127))) {\n\t\tcifs_sb->rsize = 1024 * 127;\n\t\tcFYI(DBG2, \"no very large read support, rsize now 127K\");\n\t}\n\tif (!(tcon->ses->capabilities & CAP_LARGE_WRITE_X))\n\t\tcifs_sb->wsize = min(cifs_sb->wsize,\n\t\t\t       (tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE));\n\tif (!(tcon->ses->capabilities & CAP_LARGE_READ_X))\n\t\tcifs_sb->rsize = min(cifs_sb->rsize,\n\t\t\t       (tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE));\n\nremote_path_check:\n\t/* check if a whole path (including prepath) is not remote */\n\tif (!rc && cifs_sb->prepathlen && tcon) {\n\t\t/* build_path_to_root works only when we have a valid tcon */\n\t\tfull_path = cifs_build_path_to_root(cifs_sb, tcon);\n\t\tif (full_path == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto mount_fail_check;\n\t\t}\n\t\trc = is_path_accessible(xid, tcon, cifs_sb, full_path);\n\t\tif (rc != 0 && rc != -EREMOTE) {\n\t\t\tkfree(full_path);\n\t\t\tgoto mount_fail_check;\n\t\t}\n\t\tkfree(full_path);\n\t}\n\n\t/* get referral if needed */\n\tif (rc == -EREMOTE) {\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\t\tif (referral_walks_count > MAX_NESTED_LINKS) {\n\t\t\t/*\n\t\t\t * BB: when we implement proper loop detection,\n\t\t\t *     we will remove this check. But now we need it\n\t\t\t *     to prevent an indefinite loop if 'DFS tree' is\n\t\t\t *     misconfigured (i.e. has loops).\n\t\t\t */\n\t\t\trc = -ELOOP;\n\t\t\tgoto mount_fail_check;\n\t\t}\n\t\t/* convert forward to back slashes in prepath here if needed */\n\t\tif ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS) == 0)\n\t\t\tconvert_delimiter(cifs_sb->prepath,\n\t\t\t\t\tCIFS_DIR_SEP(cifs_sb));\n\t\tfull_path = build_unc_path_to_root(volume_info, cifs_sb);\n\t\tif (IS_ERR(full_path)) {\n\t\t\trc = PTR_ERR(full_path);\n\t\t\tgoto mount_fail_check;\n\t\t}\n\n\t\tcFYI(1, \"Getting referral for: %s\", full_path);\n\t\trc = get_dfs_path(xid, pSesInfo , full_path + 1,\n\t\t\tcifs_sb->local_nls, &num_referrals, &referrals,\n\t\t\tcifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR);\n\t\tif (!rc && num_referrals > 0) {\n\t\t\tchar *fake_devname = NULL;\n\n\t\t\tif (mount_data != mount_data_global)\n\t\t\t\tkfree(mount_data);\n\n\t\t\tmount_data = cifs_compose_mount_options(\n\t\t\t\t\tcifs_sb->mountdata, full_path + 1,\n\t\t\t\t\treferrals, &fake_devname);\n\n\t\t\tfree_dfs_info_array(referrals, num_referrals);\n\t\t\tkfree(fake_devname);\n\t\t\tkfree(full_path);\n\n\t\t\tif (IS_ERR(mount_data)) {\n\t\t\t\trc = PTR_ERR(mount_data);\n\t\t\t\tmount_data = NULL;\n\t\t\t\tgoto mount_fail_check;\n\t\t\t}\n\n\t\t\tif (tcon)\n\t\t\t\tcifs_put_tcon(tcon);\n\t\t\telse if (pSesInfo)\n\t\t\t\tcifs_put_smb_ses(pSesInfo);\n\n\t\t\tcleanup_volume_info(&volume_info);\n\t\t\treferral_walks_count++;\n\t\t\tFreeXid(xid);\n\t\t\tgoto try_mount_again;\n\t\t}\n#else /* No DFS support, return error on mount */\n\t\trc = -EOPNOTSUPP;\n#endif\n\t}\n\n\tif (rc)\n\t\tgoto mount_fail_check;\n\n\t/* now, hang the tcon off of the superblock */\n\ttlink = kzalloc(sizeof *tlink, GFP_KERNEL);\n\tif (tlink == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto mount_fail_check;\n\t}\n\n\ttlink->tl_uid = pSesInfo->linux_uid;\n\ttlink->tl_tcon = tcon;\n\ttlink->tl_time = jiffies;\n\tset_bit(TCON_LINK_MASTER, &tlink->tl_flags);\n\tset_bit(TCON_LINK_IN_TREE, &tlink->tl_flags);\n\n\tcifs_sb->master_tlink = tlink;\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tqueue_delayed_work(system_nrt_wq, &cifs_sb->prune_tlinks,\n\t\t\t\tTLINK_IDLE_EXPIRE);\n\nmount_fail_check:\n\t/* on error free sesinfo and tcon struct if needed */\n\tif (rc) {\n\t\tif (mount_data != mount_data_global)\n\t\t\tkfree(mount_data);\n\t\t/* If find_unc succeeded then rc == 0 so we can not end */\n\t\t/* up accidentally freeing someone elses tcon struct */\n\t\tif (tcon)\n\t\t\tcifs_put_tcon(tcon);\n\t\telse if (pSesInfo)\n\t\t\tcifs_put_smb_ses(pSesInfo);\n\t\telse\n\t\t\tcifs_put_tcp_session(srvTcp);\n\t\tgoto out;\n\t}\n\n\t/* volume_info->password is freed above when existing session found\n\t(in which case it is not needed anymore) but when new sesion is created\n\tthe password ptr is put in the new session structure (in which case the\n\tpassword will be freed at unmount time) */\nout:\n\t/* zero out password before freeing */\n\tcleanup_volume_info(&volume_info);\n\tFreeXid(xid);\n\treturn rc;\n}",
        "target": 1
    },
    {
        "func": "static void cmd_list(char *arg1, char *arg2)\n{\n    if (!arg1)\n\targ1 = \"active\";\n    else\n\tlcase(arg1);\n\n    if (!strcmp(arg1, \"active\")) {\n\tchar pattern[MAX_MAILBOX_BUFFER];\n\tstruct list_rock lrock;\n\tstruct enum_rock erock;\n\n\tif (!arg2) arg2 = \"*\";\n\n\terock.cmd = \"ACTIVE\";\n\terock.wild = xstrdup(arg2); /* make a copy before we munge it */\n\n\tlrock.proc = do_active;\n\tlrock.wild = split_wildmats(arg2); /* split the list of wildmats */\n\n\t/* xxx better way to determine a size for this table? */\n\tconstruct_hash_table(&lrock.server_table, 10, 1);\n\n\tprot_printf(nntp_out, \"215 List of newsgroups follows:\\r\\n\");\n\n\tstrcpy(pattern, newsprefix);\n\tstrcat(pattern, \"*\");\n\tlist_cb(NULL, 0, 0, NULL);\n\tmboxlist_findall(NULL, pattern, 0, nntp_userid, nntp_authstate,\n\t\t\t list_cb, &lrock);\n\n\t/* proxy to the backends */\n\thash_enumerate(&lrock.server_table, list_proxy, &erock);\n\n\tprot_printf(nntp_out, \".\\r\\n\");\n\n\t/* free the hash table */\n\tfree_hash_table(&lrock.server_table, NULL);\n\n\t/* free the wildmats */\n\tfree_wildmats(lrock.wild);\n\tfree(erock.wild);\n\n\tif (group_state)\n\t    index_close(&group_state);\n    }\n    else if (!(nntp_capa & MODE_READ)) {\n\tprot_printf(nntp_out, \"502 Permission denied\\r\\n\");\n\treturn;\n    }\n    else if (!nntp_userid && !allowanonymous) {\n\tprot_printf(nntp_out, \"480 Authentication required\\r\\n\");\n\treturn;\n    }\n    else if (!strcmp(arg1, \"headers\")) {\n\tif (arg2 && strcmp(arg2, \"msgid\") && strcmp(arg2, \"range\")) {\n\t    prot_printf(nntp_out, \"501 Unexpected extra argument\\r\\n\");\n\t    return;\n\t}\n\n\tprot_printf(nntp_out, \"215 Header and metadata list follows:\\r\\n\");\n\tprot_printf(nntp_out, \":\\r\\n\"); /* all headers */\n\tprot_printf(nntp_out, \":bytes\\r\\n\");\n\tprot_printf(nntp_out, \":lines\\r\\n\");\n\tprot_printf(nntp_out, \".\\r\\n\");\n    }\n    else if (!strcmp(arg1, \"newsgroups\")) {\n\tchar pattern[MAX_MAILBOX_BUFFER];\n\tstruct list_rock lrock;\n\tstruct enum_rock erock;\n\n\tif (!arg2) arg2 = \"*\";\n\n\terock.cmd = \"NEWSGROUPS\";\n\terock.wild = xstrdup(arg2); /* make a copy before we munge it */\n\n\tlrock.proc = do_newsgroups;\n\tlrock.wild = split_wildmats(arg2); /* split the list of wildmats */\n\n\t/* xxx better way to determine a size for this table? */\n\tconstruct_hash_table(&lrock.server_table, 10, 1);\n\n\tprot_printf(nntp_out, \"215 List of newsgroups follows:\\r\\n\");\n\n\tstrcpy(pattern, newsprefix);\n\tstrcat(pattern, \"*\");\n\tlist_cb(NULL, 0, 0, NULL);\n\tmboxlist_findall(NULL, pattern, 0, nntp_userid, nntp_authstate,\n\t\t\t list_cb, &lrock);\n\n\t/* proxy to the backends */\n\thash_enumerate(&lrock.server_table, list_proxy, &erock);\n\n\tstrcpy(pattern, newsprefix);\n\tstrcat(pattern, \"*\");\n\tannotatemore_findall(pattern, \"/comment\",\n\t\t\t     newsgroups_cb, lrock.wild, NULL);\n\n\tprot_printf(nntp_out, \".\\r\\n\");\n\n\t/* free the hash table */\n\tfree_hash_table(&lrock.server_table, NULL);\n\n\t/* free the wildmats */\n\tfree_wildmats(lrock.wild);\n\tfree(erock.wild);\n    }\n    else if (!strcmp(arg1, \"overview.fmt\")) {\n\tif (arg2) {\n\t    prot_printf(nntp_out, \"501 Unexpected extra argument\\r\\n\");\n\t    return;\n\t}\n\n\tprot_printf(nntp_out, \"215 Order of overview fields follows:\\r\\n\");\n\tprot_printf(nntp_out, \"Subject:\\r\\n\");\n\tprot_printf(nntp_out, \"From:\\r\\n\");\n\tprot_printf(nntp_out, \"Date:\\r\\n\");\n\tprot_printf(nntp_out, \"Message-ID:\\r\\n\");\n\tprot_printf(nntp_out, \"References:\\r\\n\");\n\tif (did_capabilities) {\n\t    /* new OVER format */\n\t    prot_printf(nntp_out, \":bytes\\r\\n\");\n\t    prot_printf(nntp_out, \":lines\\r\\n\");\n\t} else {\n\t    /* old XOVER format */\n\t    prot_printf(nntp_out, \"Bytes:\\r\\n\");\n\t    prot_printf(nntp_out, \"Lines:\\r\\n\");\n\t}\n\tprot_printf(nntp_out, \"Xref:full\\r\\n\");\n\tprot_printf(nntp_out, \".\\r\\n\");\n    }\n    else if (!strcmp(arg1, \"active.times\") || !strcmp(arg1, \"distributions\") ||\n\t     !strcmp(arg1, \"distrib.pats\")) {\n\tprot_printf(nntp_out, \"503 Unsupported LIST command\\r\\n\");\n    }\n    else {\n\tprot_printf(nntp_out, \"501 Unrecognized LIST command\\r\\n\");\n    }\n    prot_flush(nntp_out);\n}",
        "target": 1
    },
    {
        "func": "static int deliver(message_data_t *msg)\n{\n    int n, r = 0, myrights;\n    char *rcpt = NULL, *local_rcpt = NULL, *server, *acl;\n    unsigned long uid;\n    struct body *body = NULL;\n    struct dest *dlist = NULL;\n    duplicate_key_t dkey = {msg->id, NULL, msg->date};\n\n    /* check ACLs of all mailboxes */\n    for (n = 0; n < msg->rcpt_num; n++) {\n\trcpt = msg->rcpt[n];\n\n\t/* look it up */\n\tr = mlookup(rcpt, &server, &acl, NULL);\n\tdkey.to = rcpt;\n\tif (r) return IMAP_MAILBOX_NONEXISTENT;\n\n\tif (!(acl && (myrights = cyrus_acl_myrights(nntp_authstate, acl)) &&\n\t      (myrights & ACL_POST)))\n\t    return IMAP_PERMISSION_DENIED;\n\n\tif (server) {\n\t    /* remote group */\n\t    proxy_adddest(&dlist, NULL, 0, server, \"\");\n\t}\n\telse {\n\t    /* local group */\n\t    struct appendstate as;\n\n\t    if (msg->id && \n\t\tduplicate_check(&dkey)) {\n\t\t/* duplicate message */\n\t\tduplicate_log(&dkey, \"nntp delivery\");\n\t\tcontinue;\n\t    }\n\n\t    r = append_setup(&as, rcpt, nntp_userid, nntp_authstate, ACL_POST, 0);\n\n\t    if (!r) {\n\t\tprot_rewind(msg->data);\n\t\tif (stage) {\n\t\t    r = append_fromstage(&as, &body, stage, 0,\n\t\t\t\t\t (const char **) NULL, 0, !singleinstance);\n\t\t} else {\n\t\t    /* XXX should never get here */\n\t\t    r = append_fromstream(&as, &body, msg->data, msg->size, 0,\n\t\t\t\t\t  (const char **) NULL, 0);\n\t\t}\n\t\tif (r || ( msg->id && duplicate_check(&dkey) ) ) {    \n\t\t    append_abort(&as);\n                   \n\t\t    if (!r) {\n\t\t\t/* duplicate message */\n\t\t\tduplicate_log(&dkey, \"nntp delivery\");\n\t\t\tcontinue;\n\t\t    }            \n\t\t}                \n\t\telse {           \n\t\t    r = append_commit(&as, 0, NULL, &uid, NULL, NULL);\n\t\t}\n\t    }\n\n\t    if (!r && msg->id)\n\t\tduplicate_mark(&dkey, time(NULL), uid);\n\n\t    if (r) return r;\n\n\t    local_rcpt = rcpt;\n\t}\n    }\n\n    if (body) {\n\tmessage_free_body(body);\n\tfree(body);\n    }\n\n    if (dlist) {\n\tstruct dest *d;\n\n\t/* run the txns */\n\tr = deliver_remote(msg, dlist);\n\n\t/* free the destination list */\n\td = dlist;\n\twhile (d) {\n\t    struct dest *nextd = d->next;\n\t    free(d);\n\t    d = nextd;\n\t}\n    }\n\n    return r;\n}",
        "target": 1
    },
    {
        "func": "static void cmdloop(void)\n{\n    int c, r = 0, mode;\n    static struct buf cmd, arg1, arg2, arg3, arg4;\n    char *p, *result, buf[1024];\n    const char *err;\n    uint32_t uid, last;\n    struct backend *be;\n    char curgroup[MAX_MAILBOX_BUFFER] = \"\";\n\n    allowanonymous = config_getswitch(IMAPOPT_ALLOWANONYMOUSLOGIN);\n\n    for (;;) {\n\t/* Flush any buffered output */\n\tprot_flush(nntp_out);\n\tif (backend_current) prot_flush(backend_current->out);\n\n\t/* Check for shutdown file */\n\tif (shutdown_file(buf, sizeof(buf)) ||\n\t    (nntp_userid &&\n\t     userdeny(nntp_userid, config_ident, buf, sizeof(buf)))) {\n\t    prot_printf(nntp_out, \"400 %s\\r\\n\", buf);\n\t    shut_down(0);\n\t}\n\n\tsignals_poll();\n\n\tif (!proxy_check_input(protin, nntp_in, nntp_out,\n\t\t\t       backend_current ? backend_current->in : NULL,\n\t\t\t       NULL, 0)) {\n\t    /* No input from client */\n\t    continue;\n\t}\n\n\tif (group_state &&\n\t    config_getswitch(IMAPOPT_DISCONNECT_ON_VANISHED_MAILBOX)) {\n\t    if (group_state->mailbox->i.options & OPT_MAILBOX_DELETED) {\n\t\t/* Mailbox has been (re)moved */\n\t\tsyslog(LOG_WARNING,\n\t\t       \"Newsgroup %s has been (re)moved out from under client\",\n\t\t       group_state->mailbox->name);\n\t\tprot_printf(nntp_out,\n\t\t\t    \"400 Newsgroup has been (re)moved\\r\\n\");\n\t\tshut_down(0);\n\t    }\n\t}\n\n\t/* Parse command name */\n\tc = getword(nntp_in, &cmd);\n\tif (c == EOF) {\n\t    if ((err = prot_error(nntp_in)) != NULL\n\t\t && strcmp(err, PROT_EOF_STRING)) {\n\t\tsyslog(LOG_WARNING, \"%s, closing connection\", err);\n\t\tprot_printf(nntp_out, \"400 %s\\r\\n\", err);\n\t    }\n\t    return;\n\t}\n\tif (!cmd.s[0]) {\n\t    prot_printf(nntp_out, \"501 Empty command\\r\\n\");\n\t    eatline(nntp_in, c);\n\t    continue;\n\t}\n\tif (Uislower(cmd.s[0])) \n\t    cmd.s[0] = toupper((unsigned char) cmd.s[0]);\n\tfor (p = &cmd.s[1]; *p; p++) {\n\t    if (Uisupper(*p)) *p = tolower((unsigned char) *p);\n\t}\n\n\t/* Ihave/Takethis only allowed for feeders */\n\tif (!(nntp_capa & MODE_FEED) &&\n\t    strchr(\"IT\", cmd.s[0])) goto noperm;\n    \n\t/* Body/Date/Group/Newgroups/Newnews/Next/Over/Post/Xhdr/Xover/Xpat\n\t   only allowed for readers */\n\tif (!(nntp_capa & MODE_READ) &&\n\t    strchr(\"BDGNOPX\", cmd.s[0])) goto noperm;\n    \n\t/* Only Authinfo/Capabilities/Check/Head/Help/Ihave/List Active/\n\t   Mode/Quit/Starttls/Stat/Takethis allowed when not logged in */\n\tif (!nntp_userid && !allowanonymous &&\n\t    !strchr(\"ACHILMQST\", cmd.s[0])) goto nologin;\n\n\t/* In case a [LIST]GROUP fails or\n\t   a retrieval by msgid makes us switch groups */\n\tstrcpy(curgroup, group_state ? group_state->mailbox->name : \"\");\n\n\tswitch (cmd.s[0]) {\n\tcase 'A':\n\t    if (!strcmp(cmd.s, \"Authinfo\")) {\n\t\tif (c != ' ') goto missingargs;\n\t\tc = getword(nntp_in, &arg1); /* subcommand */\n\t\tif (c == EOF) goto missingargs;\n\n\t\tlcase(arg1.s);\n\n\t\tif (!strcmp(arg1.s, \"user\") || !strcmp(arg1.s, \"pass\")) {\n\t\t    if (c != ' ') goto missingargs;\n\t\t    c = getuserpass(nntp_in, &arg2); /* user/pass */\n\t\t    if (c == EOF) goto missingargs;\n\n\t\t    if (c == '\\r') c = prot_getc(nntp_in);\n\t\t    if (c != '\\n') goto extraargs;\n\n\t\t    if (arg1.s[0] == 'u')\n\t\t\tcmd_authinfo_user(arg2.s);\n\t\t    else\n\t\t\tcmd_authinfo_pass(arg2.s);\n\t\t}\n\t\telse if (!strcmp(arg1.s, \"sasl\") || !strcmp(arg1.s, \"generic\")) {\n\t\t    arg2.len = arg3.len = 0;\n\n\t\t    /* mech name required for SASL but not GENERIC */\n\t\t    if ((arg1.s[0] == 's') && (c != ' ')) goto missingargs;\n\n\t\t    if (c == ' ') {\n\t\t\tc = getword(nntp_in, &arg2); /* mech name */\n\t\t\tif (c == EOF) goto missingargs;\n\n\t\t\tif (c == ' ') {\n\t\t\t    c = getword(nntp_in, &arg3); /* init response */\n\t\t\t    if (c == EOF) goto missingargs;\n\t\t\t}\n\t\t    }\n\n\t\t    if (c == '\\r') c = prot_getc(nntp_in);\n\t\t    if (c != '\\n') goto extraargs;\n\n\t\t    cmd_authinfo_sasl(arg1.s, arg2.len ? arg2.s : NULL,\n\t\t\t\t      arg3.len ? arg3.s : NULL);\n\t\t}\n\t\telse\n\t\t    prot_printf(nntp_out,\n\t\t\t\t\"501 Unrecognized AUTHINFO command\\r\\n\");\n\t    }\n\t    else if (!(nntp_capa & MODE_READ)) goto noperm;\n\t    else if (!nntp_userid && !allowanonymous) goto nologin;\n\t    else if (!strcmp(cmd.s, \"Article\")) {\n\t\tchar *msgid;\n\n\t\tmode = ARTICLE_ALL;\n\n\t      article:\n\t\tif (arg1.s) *arg1.s = 0;\n\n\t\tif (c == ' ') {\n\t\t    c = getword(nntp_in, &arg1); /* number/msgid (optional) */\n\t\t    if (c == EOF) goto missingargs;\n\t\t}\n\t\tif (c == '\\r') c = prot_getc(nntp_in);\n\t\tif (c != '\\n') goto extraargs;\n\n\t\tif (parserange(arg1.s, &uid, NULL, &msgid, &be) != -1) {\n\t\t    if (be) {\n\t\t\tif (arg1.s && *arg1.s)\n\t\t\t    prot_printf(be->out, \"%s %s\\r\\n\", cmd.s, arg1.s);\n\t\t\telse\n\t\t\t    prot_printf(be->out, \"%s\\r\\n\", cmd.s);\n\n\t\t\tif (be != backend_current) {\n\t\t\t    r = read_response(be, 0, &result);\n\t\t\t    if (r) goto noopengroup;\n\n\t\t\t    prot_printf(nntp_out, \"%s\", result);\n\t\t\t    if (!strncmp(result, \"22\", 2) &&\n\t\t\t\tmode != ARTICLE_STAT) {\n\t\t\t\tpipe_to_end_of_response(be, 0);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t\tcmd_article(mode, msgid, uid);\n\t\t}\n\n\t\tif (msgid) goto prevgroup;\n\t    }\n\t    else goto badcmd;\n\t    break;\n\n\tcase 'B':\n\t    if (!strcmp(cmd.s, \"Body\")) {\n\t\tmode = ARTICLE_BODY;\n\t\tgoto article;\n\t    }\n\t    else goto badcmd;\n\t    break;\n\n\tcase 'C':\n\t    if (!strcmp(cmd.s, \"Capabilities\")) {\n\t\targ1.len = 0;\n\n\t\tif (c == ' ') {\n\t\t    c = getword(nntp_in, &arg1); /* keyword (optional) */\n\t\t    if (c == EOF) goto missingargs;\n\t\t}\n\t\tif (c == '\\r') c = prot_getc(nntp_in);\n\t\tif (c != '\\n') goto extraargs;\n\n\t\tcmd_capabilities(arg1.s);\n\t    }\n\t    else if (!(nntp_capa & MODE_FEED)) goto noperm;\n\t    else if (!strcmp(cmd.s, \"Check\")) {\n\t\tmode = POST_CHECK;\n\t\tgoto ihave;\n\t    }\n\t    else goto badcmd;\n\t    break;\n\n\tcase 'D':\n\t    if (!strcmp(cmd.s, \"Date\")) {\n\t\ttime_t now = time(NULL);\n\t\tstruct tm *my_tm = gmtime(&now);\n\t\tchar buf[15];\n\n\t\tif (c == '\\r') c = prot_getc(nntp_in);\n\t\tif (c != '\\n') goto extraargs;\n\n\t\tstrftime(buf, sizeof(buf), \"%Y%m%d%H%M%S\", my_tm);\n\t\tprot_printf(nntp_out, \"111 %s\\r\\n\", buf);\n\t    }\n\t    else goto badcmd;\n\t    break;\n\n\tcase 'G':\n\t    if (!strcmp(cmd.s, \"Group\")) {\n\t\targ2.len = 0; /* GROUP command (no range) */\n\n\t      group:\n#define LISTGROUP (arg2.len)\n\n\t\tif (!LISTGROUP && c != ' ') goto missingargs;\n\t\tif (c == ' ') {\n\t\t    c = getword(nntp_in, &arg1); /* group */\n\t\t    if (c == EOF) goto missingargs;\n\t\t}\n\t\tif (LISTGROUP && c == ' ') {\n\t\t    c = getword(nntp_in, &arg2); /* range (optional) */\n\t\t    if (c == EOF) goto missingargs;\n\t\t}\n\t\tif (c == '\\r') c = prot_getc(nntp_in);\n\t\tif (c != '\\n') goto extraargs;\n\n\t\tbe = backend_current;\n\t\tif (arg1.len &&\n\t\t    (!is_newsgroup(arg1.s) ||\n\t\t     (r = open_group(arg1.s, 1, &be, NULL)))) goto nogroup;\n\t\telse if (be) {\n\t\t    prot_printf(be->out, \"%s\", cmd.s);\n\t\t    if (arg1.len) {\n\t\t\tprot_printf(be->out, \" %s\", arg1.s);\n\t\t\t  if (LISTGROUP) prot_printf(be->out, \" %s\", arg2.s);\n\t\t    }\n\t\t    prot_printf(be->out, \"\\r\\n\");\n\n\t\t    r = read_response(be, 0, &result);\n\t\t    if (r) goto nogroup;\n\n\t\t    prot_printf(nntp_out, \"%s\", result);\n\n\t\t    if (!strncmp(result, \"211\", 3)) {\n\t\t\tif (LISTGROUP) pipe_to_end_of_response(be, 0);\n\n\t\t\tif (backend_current && backend_current != be) {\n\t\t\t    /* remove backend_current from the protgroup */\n\t\t\t    protgroup_delete(protin, backend_current->in);\n\t\t\t}\n\t\t\tbackend_current = be;\n\n\t\t\t/* add backend_current to the protgroup */\n\t\t\tprotgroup_insert(protin, backend_current->in);\n\t\t    }\n\t\t}\n\t\telse if (!group_state) goto noopengroup;\n\t\telse if (LISTGROUP &&\n\t\t\t parserange(arg2.s, &uid, &last, NULL, NULL) != 0) {\n\t\t    /* parserange() will handle error code -- do nothing */\n\t\t}\n\t\telse {\n\t\t    if (backend_current) {\n\t\t\t/* remove backend_current from the protgroup */\n\t\t\tprotgroup_delete(protin, backend_current->in);\n\t\t    }\n\t\t    backend_current = NULL;\n\n\t\t    nntp_exists = group_state->exists;\n\t\t    nntp_current = nntp_exists > 0;\n\n\t\t    prot_printf(nntp_out, \"211 %u %lu %lu %s\\r\\n\",\n\t\t\t\tnntp_exists,\n\t\t\t\tnntp_exists ? index_getuid(group_state, 1) :\n\t\t\t\tgroup_state->last_uid+1,\n\t\t\t\tnntp_exists ? index_getuid(group_state, nntp_exists) :\n\t\t\t\tgroup_state->last_uid,\n\t\t\t\tgroup_state->mailbox->name + strlen(newsprefix));\n\n\t\t    if (LISTGROUP) {\n\t\t\tint msgno, last_msgno;\n\n\t\t\tmsgno = index_finduid(group_state, uid);\n\t\t\tif (!msgno || index_getuid(group_state, msgno) != uid) {\n\t\t\t    msgno++;\n\t\t\t}\n\t\t\tlast_msgno = index_finduid(group_state, last);\n\n\t\t\tfor (; msgno <= last_msgno; msgno++) {\n\t\t\t    prot_printf(nntp_out, \"%u\\r\\n\",\n\t\t\t\t\tindex_getuid(group_state, msgno));\n\t\t\t}\n\t\t\tprot_printf(nntp_out, \".\\r\\n\");\n\t\t    }\n\t\t}\n#undef LISTGROUP\n\t    }\n\t    else goto badcmd;\n\t    break;\n\n\tcase 'H':\n\t    if (!strcmp(cmd.s, \"Head\")) {\n\t\tmode = ARTICLE_HEAD;\n\t\tgoto article;\n\t    }\n\t    else if (!strcmp(cmd.s, \"Help\")) {\n\t\tif (c == '\\r') c = prot_getc(nntp_in);\n\t\tif (c != '\\n') goto extraargs;\n\n\t\tcmd_help();\n\t    }\n\t    else if (!(nntp_capa & MODE_READ)) goto noperm;\n\t    else if (!nntp_userid && !allowanonymous) goto nologin;\n\t    else if (!strcmp(cmd.s, \"Hdr\")) {\n\t\tchar *msgid;\n\n\t      hdr:\n\t\tif (arg2.s) *arg2.s = 0;\n\n\t\tif (c != ' ') goto missingargs;\n\t\tc = getword(nntp_in, &arg1); /* header */\n\t\tif (c == EOF) goto missingargs;\n\t\tif (c == ' ') {\n\t\t    c = getword(nntp_in, &arg2); /* range (optional) */\n\t\t    if (c == EOF) goto missingargs;\n\t\t}\n\t\tif (c == '\\r') c = prot_getc(nntp_in);\n\t\tif (c != '\\n') goto extraargs;\n\n\t\tif (parserange(arg2.s, &uid, &last, &msgid, &be) != -1) {\n\t\t    if (be) {\n\t\t\tif (arg2.s && *arg2.s)\n\t\t\t    prot_printf(be->out, \"%s %s %s\\r\\n\",\n\t\t\t\t\tcmd.s, arg1.s, arg2.s);\n\t\t\telse\n\t\t\t    prot_printf(be->out, \"%s %s\\r\\n\", cmd.s, arg1.s);\n\n\t\t\tif (be != backend_current) {\n\t\t\t    r = read_response(be, 0, &result);\n\t\t\t    if (r) goto noopengroup;\n\n\t\t\t    prot_printf(nntp_out, \"%s\", result);\n\t\t\t    if (!strncmp(result, \"22\", 2)) { /* 221 or 225 */\n\t\t\t\tpipe_to_end_of_response(be, 0);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t\tcmd_hdr(cmd.s, arg1.s, NULL, msgid, uid, last);\n\t\t}\n\n\t\tif (msgid) goto prevgroup;\n\t    }\n\t    else goto badcmd;\n\t    break;\n\n\tcase 'I':\n\t    if (!strcmp(cmd.s, \"Ihave\")) {\n\t\tmode = POST_IHAVE;\n\n\t      ihave:\n\t\tif (c != ' ') goto missingargs;\n\t\tc = getword(nntp_in, &arg1); /* msgid */\n\t\tif (c == EOF) goto missingargs;\n\t\tif (c == '\\r') c = prot_getc(nntp_in);\n\t\tif (c != '\\n') goto extraargs;\n\n\t\tcmd_post(arg1.s, mode);\n\t    }\n\t    else goto badcmd;\n\t    break;\n\n\tcase 'L':\n\t    if (!strcmp(cmd.s, \"List\")) {\n\t\targ1.len = arg2.len = 0;\n\t\tif (c == ' ') {\n\t\t    c = getword(nntp_in, &arg1); /* subcommand (optional) */\n\t\t    if (c == EOF) goto missingargs;\n\t\t    if (c == ' ') {\n\t\t\tc = getword(nntp_in, &arg2); /* argument (optional) */\n\t\t\tif (c == EOF) goto missingargs;\n\t\t    }\n\t\t}\n\t\tif (c == '\\r') c = prot_getc(nntp_in);\n\t\tif (c != '\\n') goto extraargs;\n\n\t\tcmd_list(arg1.len ? arg1.s : NULL, arg2.len ? arg2.s : NULL);\n\n\t\tgoto prevgroup;  /* In case we did LIST [ACTIVE] */\n\t    }\n\t    else if (!(nntp_capa & MODE_READ)) goto noperm;\n\t    else if (!nntp_userid && !allowanonymous) goto nologin;\n\t    else if (!strcmp(cmd.s, \"Last\")) {\n\t\tif (c == '\\r') c = prot_getc(nntp_in);\n\t\tif (c != '\\n') goto extraargs;\n\n\t\tif (backend_current) {\n\t\t    prot_printf(backend_current->out, \"LAST\\r\\n\");\n\t\t}\n\t\telse if (!group_state) goto noopengroup;\n\t\telse if (!nntp_current) goto nocurrent;\n\t\telse if (nntp_current == 1) {\n\t\t    prot_printf(nntp_out,\n\t\t\t\t\"422 No previous article in this group\\r\\n\");\n\t\t}\n\t\telse {\n\t\t    char *msgid = index_get_msgid(group_state, --nntp_current);\n\n\t\t    prot_printf(nntp_out, \"223 %u %s\\r\\n\",\n\t\t\t\tindex_getuid(group_state, nntp_current),\n\t\t\t\tmsgid ? msgid : \"<0>\");\n\n\t\t    if (msgid) free(msgid);\n\t\t}\n\t    }\n\t    else if (!strcmp(cmd.s, \"Listgroup\")) {\n\t\targ1.len = 0;   \t   /* group is optional */\n\t\tbuf_setcstr(&arg2, \"1-\");  /* default range is all */\n\t\tbuf_cstring(&arg2);\t   /* appends a '\\0' */\n\t\tgoto group;\n\t    }\n\t    else goto badcmd;\n\t    break;\n\n\tcase 'M':\n\t    if (!strcmp(cmd.s, \"Mode\")) {\n\t\tif (c != ' ') goto missingargs;\n\t\tc = getword(nntp_in, &arg1); /* mode */\n\t\tif (c == EOF) goto missingargs;\n\t\tif (c == '\\r') c = prot_getc(nntp_in);\n\t\tif (c != '\\n') goto extraargs;\n\n\t\tcmd_mode(arg1.s);\n\t    }\n\t    else goto badcmd;\n\t    break;\n\n\tcase 'N':\n\t    if (!strcmp(cmd.s, \"Newgroups\")) {\n\t\ttime_t tstamp;\n\n\t\targ3.len = 0;\n\t\tif (c != ' ') goto missingargs;\n\t\tc = getword(nntp_in, &arg1); /* date */\n\t\tif (c != ' ') goto missingargs;\n\t\tc = getword(nntp_in, &arg2); /* time */\n\t\tif (c == EOF) goto missingargs;\n\t\tif (c == ' ') {\n\t\t    c = getword(nntp_in, &arg3); /* \"GMT\" (optional) */\n\t\t    if (c == EOF) goto missingargs;\n\t\t}\n\t\tif (c == '\\r') c = prot_getc(nntp_in);\n\t\tif (c != '\\n') goto extraargs;\n\n\t\tif ((tstamp = parse_datetime(arg1.s, arg2.s,\n\t\t\t\t\t     arg3.len ? arg3.s : NULL)) < 0)\n\t\t    goto baddatetime;\n\n\t\tcmd_newgroups(tstamp);\n\t    }\n\t    else if (!strcmp(cmd.s, \"Newnews\")) {\n\t\ttime_t tstamp;\n\n\t\tif (!config_getswitch(IMAPOPT_ALLOWNEWNEWS))\n\t\t    goto cmddisabled;\n\n\t\targ4.len = 0;\n\t\tif (c != ' ') goto missingargs;\n\t\tc = getword(nntp_in, &arg1); /* wildmat */\n\t\tif (c != ' ') goto missingargs;\n\t\tc = getword(nntp_in, &arg2); /* date */\n\t\tif (c != ' ') goto missingargs;\n\t\tc = getword(nntp_in, &arg3); /* time */\n\t\tif (c == EOF) goto missingargs;\n\t\tif (c == ' ') {\n\t\t    c = getword(nntp_in, &arg4); /* \"GMT\" (optional) */\n\t\t    if (c == EOF) goto missingargs;\n\t\t}\n\t\tif (c == '\\r') c = prot_getc(nntp_in);\n\t\tif (c != '\\n') goto extraargs;\n\n\t\tif ((tstamp = parse_datetime(arg2.s, arg3.s,\n\t\t\t\t\t     arg4.len ? arg4.s : NULL)) < 0)\n\t\t    goto baddatetime;\n\n\t\tcmd_newnews(arg1.s, tstamp);\n\t    }\n\t    else if (!strcmp(cmd.s, \"Next\")) {\n\t\tif (c == '\\r') c = prot_getc(nntp_in);\n\t\tif (c != '\\n') goto extraargs;\n\n\t\tif (backend_current) {\n\t\t    prot_printf(backend_current->out, \"NEXT\\r\\n\");\n\t\t}\n\t\telse if (!group_state) goto noopengroup;\n\t\telse if (!nntp_current) goto nocurrent;\n\t\telse if (nntp_current == nntp_exists) {\n\t\t    prot_printf(nntp_out,\n\t\t\t\t\"421 No next article in this group\\r\\n\");\n\t\t}\n\t\telse {\n\t\t    char *msgid = index_get_msgid(group_state, ++nntp_current);\n\n\t\t    prot_printf(nntp_out, \"223 %u %s\\r\\n\",\n\t\t\t\tindex_getuid(group_state, nntp_current),\n\t\t\t\tmsgid ? msgid : \"<0>\");\n\n\t\t    if (msgid) free(msgid);\n\t\t}\n\t    }\n\t    else goto badcmd;\n\t    break;\n\n\tcase 'O':\n\t    if (!strcmp(cmd.s, \"Over\")) {\n\t\tchar *msgid;\n\n\t      over:\n\t\tif (arg1.s) *arg1.s = 0;\n\n\t\tif (c == ' ') {\n\t\t    c = getword(nntp_in, &arg1); /* range/msgid (optional) */\n\t\t    if (c == EOF) goto missingargs;\n\t\t}\n\t\tif (c == '\\r') c = prot_getc(nntp_in);\n\t\tif (c != '\\n') goto extraargs;\n\n\t\tmsgid = NULL;\n\t\tif (parserange(arg1.s, &uid, &last,\n\t\t\t       /* XOVER doesn't accept message-id */\n\t\t\t       (cmd.s[0] == 'X' ? NULL : &msgid), &be) != -1) {\n\t\t    if (be) {\n\t\t\tif (arg1.s && *arg1.s)\n\t\t\t    prot_printf(be->out, \"%s %s\\r\\n\", cmd.s, arg1.s);\n\t\t\telse\n\t\t\t    prot_printf(be->out, \"%s\\r\\n\", cmd.s);\n\n\t\t\tif (be != backend_current) {\n\t\t\t    r = read_response(be, 0, &result);\n\t\t\t    if (r) goto noopengroup;\n\n\t\t\t    prot_printf(nntp_out, \"%s\", result);\n\t\t\t    if (!strncmp(result, \"224\", 3)) {\n\t\t\t\tpipe_to_end_of_response(be, 0);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t\tcmd_over(msgid, uid, last);\n\t\t}\n\n\t\tif (msgid) goto prevgroup;\n\t    }\n\t    else goto badcmd;\n\t    break;\n\n\tcase 'P':\n\t    if (!strcmp(cmd.s, \"Post\")) {\n\t\tif (c == '\\r') c = prot_getc(nntp_in);\n\t\tif (c != '\\n') goto extraargs;\n\n\t\tcmd_post(NULL, POST_POST);\n\t    }\n\t    else goto badcmd;\n\t    break;\n\n\tcase 'Q':\n\t    if (!strcmp(cmd.s, \"Quit\")) {\n\t\tif (c == '\\r') c = prot_getc(nntp_in);\n\t\tif (c != '\\n') goto extraargs;\n\n\t\tprot_printf(nntp_out, \"205 Connection closing\\r\\n\");\n\t\treturn;\n\t    }\n\t    else goto badcmd;\n\t    break;\n\n\tcase 'S':\n\t    if (!strcmp(cmd.s, \"Starttls\") && tls_enabled()) {\n\t\tif (c == '\\r') c = prot_getc(nntp_in);\n\t\tif (c != '\\n') goto extraargs;\n\n\t\t/* XXX  discard any input pipelined after STARTTLS */\n\t\tprot_flush(nntp_in);\n\n\t\tcmd_starttls(0);\n\t    }\n\t    else if (!strcmp(cmd.s, \"Stat\")) {\n\t\tmode = ARTICLE_STAT;\n\t\tgoto article;\n\t    }\n\t    else if (!nntp_userid && !allowanonymous) goto nologin;\n\t    else if (!strcmp(cmd.s, \"Slave\")) {\t\n\t\tif (c == '\\r') c = prot_getc(nntp_in);\n\t\tif (c != '\\n') goto extraargs;\n\n\t\tprot_printf(nntp_out, \"202 Slave status noted\\r\\n\");\n\t    }\n\t    else goto badcmd;\n\t    break;\n\n\tcase 'T':\n\t    if (!strcmp(cmd.s, \"Takethis\")) {\n\t\tmode = POST_TAKETHIS;\n\t\tgoto ihave;\n\t    }\n\t    else goto badcmd;\n\t    break;\n\n\tcase 'X':\n\t    if (!strcmp(cmd.s, \"Xhdr\")) {\n\t\tgoto hdr;\n\t    }\n\t    else if (!strcmp(cmd.s, \"Xover\")) {\n\t\tgoto over;\n\t    }\n\t    else if (!strcmp(cmd.s, \"Xpat\")) {\n\t\tchar *msgid;\n\n\t\tif (c != ' ') goto missingargs;\n\t\tc = getword(nntp_in, &arg1); /* header */\n\t\tif (c != ' ') goto missingargs;\n\n\t\t/* gobble extra whitespace (hack for Mozilla) */\n\t\twhile ((c = prot_getc(nntp_in)) == ' ');\n\t\tprot_ungetc(c, nntp_in);\n\n\t\tc = getword(nntp_in, &arg2); /* range */\n\t\tif (c != ' ') goto missingargs;\n\t\tc = getword(nntp_in, &arg3); /* wildmat */\n\t\tif (c == EOF) goto missingargs;\n\n\t\t/* XXX per RFC 2980, we can have multiple patterns */\n\n\t\tif (c == '\\r') c = prot_getc(nntp_in);\n\t\tif (c != '\\n') goto extraargs;\n\n\t\tif (parserange(arg2.s, &uid, &last, &msgid, &be) != -1) {\n\t\t    if (be) {\n\t\t\tprot_printf(be->out, \"%s %s %s %s\\r\\n\",\n\t\t\t\t    cmd.s, arg1.s, arg2.s, arg3.s);\n\n\t\t\tif (be != backend_current) {\n\t\t\t    r = read_response(be, 0, &result);\n\t\t\t    if (r) goto noopengroup;\n\n\t\t\t    prot_printf(nntp_out, \"%s\", result);\n\t\t\t    if (!strncmp(result, \"221\", 3)) {\n\t\t\t\tpipe_to_end_of_response(be, 0);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t\tcmd_hdr(cmd.s, arg1.s, arg3.s, msgid, uid, last);\n\t\t}\n\n\t\tif (msgid) goto prevgroup;\n\t    }\n\t    else goto badcmd;\n\t    break;\n\n\tdefault:\n\t  badcmd:\n\t    prot_printf(nntp_out, \"500 Unrecognized command\\r\\n\");\n\t    eatline(nntp_in, c);\n\t}\n\n\tcontinue;\n\n      noperm:\n\tprot_printf(nntp_out, \"502 Permission denied\\r\\n\");\n\teatline(nntp_in, c);\n\tcontinue;\n\n      nologin:\n\tprot_printf(nntp_out, \"480 Authentication required\\r\\n\");\n\teatline(nntp_in, c);\n\tcontinue;\n\n      cmddisabled:\n\tprot_printf(nntp_out, \"503 \\\"%s\\\" disabled\\r\\n\", cmd.s);\n\teatline(nntp_in, c);\n\tcontinue;\n\n      extraargs:\n\tprot_printf(nntp_out, \"501 Unexpected extra argument\\r\\n\");\n\teatline(nntp_in, c);\n\tcontinue;\n\n      missingargs:\n\tprot_printf(nntp_out, \"501 Missing argument\\r\\n\");\n\teatline(nntp_in, c);\n\tcontinue;\n\n      baddatetime:\n\tprot_printf(nntp_out, \"501 Bad date/time\\r\\n\");\n\tcontinue;\n\n      nogroup:\n\tprot_printf(nntp_out, \"411 No such newsgroup (%s)\\r\\n\",\n\t\t    error_message(r));\n\n      prevgroup:\n\t/* Return to previously selected group */\n\tif (*curgroup &&\n\t    (!group_state || strcmp(curgroup, group_state->mailbox->name))) {\n\t    open_group(curgroup, 1, NULL, NULL);\n\t}\n\n\tcontinue;\n\n      noopengroup:\n\tprot_printf(nntp_out, \"412 No newsgroup selected\\r\\n\");\n\tcontinue;\n\n      nocurrent:\n\tprot_printf(nntp_out, \"420 Current article number is invalid\\r\\n\");\n\tcontinue;\n    }\n}",
        "target": 1
    },
    {
        "func": "static void cmd_capabilities(char *keyword __attribute__((unused)))\n{\n    const char *mechlist;\n    int mechcount = 0;\n\n    prot_printf(nntp_out, \"101 Capability list follows:\\r\\n\");\n    prot_printf(nntp_out, \"VERSION 2\\r\\n\");\n    if (nntp_authstate || (config_serverinfo == IMAP_ENUM_SERVERINFO_ON)) {\n\tprot_printf(nntp_out,\n\t\t    \"IMPLEMENTATION Cyrus NNTP%s %s\\r\\n\",\n\t\t    config_mupdate_server ? \" Murder\" : \"\", cyrus_version());\n    }\n\n    /* add STARTTLS */\n    if (tls_enabled() && !nntp_starttls_done && !nntp_authstate)\n\tprot_printf(nntp_out, \"STARTTLS\\r\\n\");\n\n    /* check for SASL mechs */\n    sasl_listmech(nntp_saslconn, NULL, \"SASL \", \" \", \"\\r\\n\",\n\t\t  &mechlist, NULL, &mechcount);\n\n    /* add the AUTHINFO variants */\n    if (!nntp_authstate) {\n\tprot_printf(nntp_out, \"AUTHINFO%s%s\\r\\n\",\n\t\t    (nntp_starttls_done || (extprops_ssf > 1) ||\n\t\t     config_getswitch(IMAPOPT_ALLOWPLAINTEXT)) ?\n\t\t    \" USER\" : \"\", mechcount ? \" SASL\" : \"\");\n    }\n\n    /* add the SASL mechs */\n    if (mechcount) prot_printf(nntp_out, \"%s\", mechlist);\n\n    /* add the reader capabilities/extensions */\n    if ((nntp_capa & MODE_READ) && (nntp_userid || allowanonymous)) {\n\tprot_printf(nntp_out, \"READER\\r\\n\");\n\tprot_printf(nntp_out, \"POST\\r\\n\");\n\tif (config_getswitch(IMAPOPT_ALLOWNEWNEWS))\n\t    prot_printf(nntp_out, \"NEWNEWS\\r\\n\");\n\tprot_printf(nntp_out, \"HDR\\r\\n\");\n\tprot_printf(nntp_out, \"OVER\\r\\n\");\n\tprot_printf(nntp_out, \"XPAT\\r\\n\");\n    }\n\n    /* add the feeder capabilities/extensions */\n    if (nntp_capa & MODE_FEED) {\n\tprot_printf(nntp_out, \"IHAVE\\r\\n\");\n\tprot_printf(nntp_out, \"STREAMING\\r\\n\");\n    }\n\n    /* add the LIST variants */\n    prot_printf(nntp_out, \"LIST ACTIVE%s\\r\\n\",\n\t\t((nntp_capa & MODE_READ) && (nntp_userid || allowanonymous)) ?\n\t\t\" HEADERS NEWSGROUPS OVERVIEW.FMT\" : \"\");\n\n    prot_printf(nntp_out, \".\\r\\n\");\n\n    did_capabilities = 1;\n}",
        "target": 1
    },
    {
        "func": "static int open_group(char *name, int has_prefix, struct backend **ret,\n\t\t      int *postable /* used for LIST ACTIVE only */)\n{\n    char mailboxname[MAX_MAILBOX_BUFFER];\n    int r = 0;\n    char *acl, *newserver;\n    struct backend *backend_next = NULL;\n\n    /* close local group */\n    if (group_state) \n\tindex_close(&group_state);\n\n    if (!has_prefix) {\n\tsnprintf(mailboxname, sizeof(mailboxname), \"%s%s\", newsprefix, name);\n\tname = mailboxname;\n    }\n\n    if (!r) r = mlookup(name, &newserver, &acl, NULL);\n\n    if (!r && acl) {\n\tint myrights = cyrus_acl_myrights(nntp_authstate, acl);\n\n\tif (postable) *postable = myrights & ACL_POST;\n\tif (!postable && /* allow limited 'r' for LIST ACTIVE */\n\t    !(myrights & ACL_READ)) {\n\t    r = (myrights & ACL_LOOKUP) ?\n\t\tIMAP_PERMISSION_DENIED : IMAP_MAILBOX_NONEXISTENT;\n\t}\n    }\n\n    if (r) return r;\n\n    if (newserver) {\n\t/* remote group */\n\tbackend_next = proxy_findserver(newserver, &nntp_protocol,\n\t\t\t\t\tnntp_userid ? nntp_userid : \"anonymous\",\n\t\t\t\t\t&backend_cached, &backend_current,\n\t\t\t\t\tNULL, nntp_in);\n\tif (!backend_next) return IMAP_SERVER_UNAVAILABLE;\n\n\t*ret = backend_next;\n    }\n    else {\n\t/* local group */\n\tstruct index_init init;\n\tmemset(&init, 0, sizeof(struct index_init));\n\tinit.userid = nntp_userid;\n\tinit.authstate = nntp_authstate;\n\tr = index_open(name, &init, &group_state);\n\tif (r) return r;\n\n\tif (ret) *ret = NULL;\n    }\n\n    syslog(LOG_DEBUG, \"open: user %s opened %s\",\n\t   nntp_userid ? nntp_userid : \"anonymous\", name);\n\n    return 0;\n}",
        "target": 1
    },
    {
        "func": "static void cmd_help(void)\n{\n    prot_printf(nntp_out, \"100 Supported commands:\\r\\n\");\n\n    if ((nntp_capa & MODE_READ) && (nntp_userid || allowanonymous)) {\n\tprot_printf(nntp_out, \"\\tARTICLE [ message-id | number ]\\r\\n\"\n\t\t    \"\\t\\tRetrieve entirety of the specified article.\\r\\n\");\n    }\n    if (!nntp_authstate) {\n\tif (!nntp_userid) {\n\t    prot_printf(nntp_out, \"\\tAUTHINFO SASL mechanism [initial-response]\\r\\n\"\n\t\t\t\"\\t\\tPerform an authentication exchange using the specified\\r\\n\"\n\t\t\t\"\\t\\tSASL mechanism.\\r\\n\");\n\t    prot_printf(nntp_out, \"\\tAUTHINFO USER username\\r\\n\"\n\t\t\t\"\\t\\tPresent username for authentication.\\r\\n\");\n\t}\n\tprot_printf(nntp_out, \"\\tAUTHINFO PASS password\\r\\n\"\n\t\t    \"\\t\\tPresent clear-text password for authentication.\\r\\n\");\n    }\n    if ((nntp_capa & MODE_READ) && (nntp_userid || allowanonymous)) {\n\tprot_printf(nntp_out, \"\\tBODY [ message-id | number ]\\r\\n\"\n\t\t    \"\\t\\tRetrieve body of the specified article.\\r\\n\");\n    }\n    prot_printf(nntp_out, \"\\tCAPABILITIES\\r\\n\"\n\t\t\"\\t\\tList the current server capabilities.\\r\\n\");\n    if (nntp_capa & MODE_FEED) {\n\tprot_printf(nntp_out, \"\\tCHECK message-id\\r\\n\"\n\t\t    \"\\t\\tCheck if the server wants the specified article.\\r\\n\");\n    }\n    if ((nntp_capa & MODE_READ) && (nntp_userid || allowanonymous)) {\n\tprot_printf(nntp_out, \"\\tDATE\\r\\n\"\n\t\t    \"\\t\\tRequest the current server UTC date and time.\\r\\n\");\n\tprot_printf(nntp_out, \"\\tGROUP group\\r\\n\"\n\t\t    \"\\t\\tSelect a newsgroup for article retrieval.\\r\\n\");\n\tprot_printf(nntp_out, \"\\tHDR header [ message-id | range ]\\r\\n\"\n\t\t    \"\\t\\tRetrieve the specified header/metadata from the\\r\\n\"\n\t\t    \"\\t\\tspecified article(s).\\r\\n\");\n    }\n    prot_printf(nntp_out, \"\\tHEAD [ message-id | number ]\\r\\n\"\n\t\t\"\\t\\tRetrieve the headers of the specified article.\\r\\n\");\n    prot_printf(nntp_out, \"\\tHELP\\r\\n\"\n\t\t\"\\t\\tRequest command summary (this text).\\r\\n\");\n    if (nntp_capa & MODE_FEED) {\n\tprot_printf(nntp_out, \"\\tIHAVE message-id\\r\\n\"\n\t\t    \"\\t\\tPresent/transfer the specified article to the server.\\r\\n\");\n    }\n    if ((nntp_capa & MODE_READ) && (nntp_userid || allowanonymous)) {\n\tprot_printf(nntp_out, \"\\tLAST\\r\\n\"\n\t\t    \"\\t\\tSelect the previous article.\\r\\n\");\n    }\n    prot_printf(nntp_out, \"\\tLIST [ ACTIVE wildmat ]\\r\\n\"\n\t\t\"\\t\\tList the (subset of) valid newsgroups.\\r\\n\");\n    if ((nntp_capa & MODE_READ) && (nntp_userid || allowanonymous)) {\n\tprot_printf(nntp_out, \"\\tLIST HEADERS [ MSGID | RANGE ]\\r\\n\"\n\t\t    \"\\t\\tList the headers and metadata items available via HDR.\\r\\n\");\n\tprot_printf(nntp_out, \"\\tLIST NEWSGROUPS [wildmat]\\r\\n\"\n\t\t    \"\\t\\tList the descriptions of the specified newsgroups.\\r\\n\");\n\tprot_printf(nntp_out, \"\\tLIST OVERVIEW.FMT\\r\\n\"\n\t\t    \"\\t\\tList the headers and metadata items available via OVER.\\r\\n\");\n\tprot_printf(nntp_out, \"\\tLISTGROUP [group [range]]\\r\\n\"\n\t\t    \"\\t\\tList the article numbers in the specified newsgroup.\\r\\n\");\n\tif (config_getswitch(IMAPOPT_ALLOWNEWNEWS))\n\t    prot_printf(nntp_out, \"\\tNEWNEWS wildmat date time [GMT]\\r\\n\"\n\t\t\t\"\\t\\tList the newly arrived articles in the specified newsgroup(s)\\r\\n\"\n\t\t\t\"\\t\\tsince the specified date and time.\\r\\n\");\n\tprot_printf(nntp_out, \"\\tNEXT\\r\\n\"\n\t\t    \"\\t\\tSelect the next article.\\r\\n\");\n\tprot_printf(nntp_out, \"\\tOVER [ message-id | range ]\\r\\n\"\n\t\t    \"\\t\\tRetrieve the overview information for the specified article(s).\\r\\n\");\n\tprot_printf(nntp_out, \"\\tPOST\\r\\n\"\n\t\t    \"\\t\\tPost an article to the server.\\r\\n\");\n    }\n\n    prot_printf(nntp_out, \"\\tQUIT\\r\\n\"\n\t\t\"\\t\\tTerminate the session.\\r\\n\");\n    if (tls_enabled() && !nntp_starttls_done && !nntp_authstate) {\n\tprot_printf(nntp_out, \"\\tSTARTTLS\\r\\n\"\n\t\t    \"\\t\\tStart a TLS negotiation.\\r\\n\");\n    }\n    prot_printf(nntp_out, \"\\tSTAT [ message-id | number ]\\r\\n\"\n\t\t\"\\t\\tCheck if the specified article exists.\\r\\n\");\n    if (nntp_capa & MODE_FEED) {\n\tprot_printf(nntp_out, \"\\tTAKETHIS message-id\\r\\n\"\n\t\t    \"\\t\\tTransfer the specified article to the server.\\r\\n\");\n    }\n    if ((nntp_capa & MODE_READ) && (nntp_userid || allowanonymous)) {\n\tprot_printf(nntp_out, \"\\tXPAT header message-id|range wildmat\\r\\n\"\n\t\t    \"\\t\\tList the specified article(s) in which the contents\\r\\n\"\n\t\t    \"\\t\\tof the specified header/metadata matches the wildmat.\\r\\n\");\n    }\n    prot_printf(nntp_out, \".\\r\\n\");\n}",
        "target": 1
    },
    {
        "func": "void list_proxy(char *server, void *data __attribute__((unused)), void *rock)\n{\n    struct enum_rock *erock = (struct enum_rock *) rock;\n    struct backend *be;\n    int r;\n    char *result;\n\n    be = proxy_findserver(server, &nntp_protocol,\n\t\t\t  nntp_userid ? nntp_userid : \"anonymous\",\n\t\t\t  &backend_cached, &backend_current, NULL, nntp_in);\n    if (!be) return;\n\n    prot_printf(be->out, \"LIST %s %s\\r\\n\", erock->cmd, erock->wild);\n\n    r = read_response(be, 0, &result);\n    if (!r && !strncmp(result, \"215 \", 4)) {\n\twhile (!(r = read_response(be, 0, &result)) && result[0] != '.') {\n\t    prot_printf(nntp_out, \"%s\", result);\n\t}\n    }\n}",
        "target": 1
    },
    {
        "func": "static int deliver_remote(message_data_t *msg, struct dest *dlist)\n{\n    struct dest *d;\n\n    /* run the txns */\n    for (d = dlist; d; d = d->next) {\n\tstruct backend *be;\n\tchar buf[4096];\n\n\tbe = proxy_findserver(d->server, &nntp_protocol,\n\t\t\t      nntp_userid ? nntp_userid : \"anonymous\",\n\t\t\t      &backend_cached, &backend_current,\n\t\t\t      NULL, nntp_in);\n\tif (!be) return IMAP_SERVER_UNAVAILABLE;\n\n\t/* tell the backend about our new article */\n\tprot_printf(be->out, \"IHAVE %s\\r\\n\", msg->id);\n\tprot_flush(be->out);\n\n\tif (!prot_fgets(buf, sizeof(buf), be->in) ||\n\t    strncmp(\"335\", buf, 3)) {\n\t    syslog(LOG_NOTICE, \"backend doesn't want article %s\", msg->id);\n\t    continue;\n\t}\n\n\t/* send the article */\n\trewind(msg->f);\n\twhile (fgets(buf, sizeof(buf), msg->f)) {\n\t    if (buf[0] == '.') prot_putc('.', be->out);\n\t    do {\n\t\tprot_printf(be->out, \"%s\", buf);\n\t    } while (buf[strlen(buf)-1] != '\\n' &&\n\t\t     fgets(buf, sizeof(buf), msg->f));\n\t}\n\n\t/* Protect against messages not ending in CRLF */\n\tif (buf[strlen(buf)-1] != '\\n') prot_printf(be->out, \"\\r\\n\");\n\n\tprot_printf(be->out, \".\\r\\n\");\n\n\tif (!prot_fgets(buf, sizeof(buf), be->in) ||\n\t    strncmp(\"235\", buf, 3)) {\n\t    syslog(LOG_WARNING, \"article %s transfer to backend failed\",\n\t\t   msg->id);\n\t    return NNTP_FAIL_TRANSFER;\n\t}\n    }\n\n    return 0;\n}",
        "target": 1
    },
    {
        "func": "httpSpecialDoSide(HTTPRequestPtr requestor)\n{\n    HTTPConnectionPtr client = requestor->connection;\n\n    if(client->reqlen - client->reqbegin >= client->bodylen) {\n        AtomPtr data;\n        data = internAtomN(client->reqbuf + client->reqbegin,\n                           client->reqlen - client->reqbegin);\n        client->reqbegin = 0;\n        client->reqlen = 0;\n        if(data == NULL) {\n            do_log(L_ERROR, \"Couldn't allocate data.\\n\");\n            httpClientError(requestor, 500,\n                            internAtom(\"Couldn't allocate data\"));\n            return 1;\n        }\n        httpSpecialDoSideFinish(data, requestor);\n        return 1;\n    }\n\n    if(client->reqlen - client->reqbegin >= CHUNK_SIZE) {\n        httpClientError(requestor, 500, internAtom(\"POST too large\"));\n        return 1;\n    }\n\n    if(client->reqbegin > 0 && client->reqlen > client->reqbegin) {\n        memmove(client->reqbuf, client->reqbuf + client->reqbegin,\n                client->reqlen - client->reqbegin);\n    }\n    client->reqlen -= client->reqbegin;\n    client->reqbegin = 0;\n\n    do_stream(IO_READ | IO_NOTNOW, client->fd,\n              client->reqlen, client->reqbuf, CHUNK_SIZE,\n              httpSpecialClientSideHandler, client);\n    return 1;\n}",
        "target": 1
    },
    {
        "func": "httpSpecialClientSideHandler(int status,\n                             FdEventHandlerPtr event,\n                             StreamRequestPtr srequest)\n{\n    HTTPConnectionPtr connection = srequest->data;\n    HTTPRequestPtr request = connection->request;\n    int push;\n\n    if((request->object->flags & OBJECT_ABORTED) || \n       !(request->object->flags & OBJECT_INPROGRESS)) {\n        httpClientDiscardBody(connection);\n        httpClientError(request, 503, internAtom(\"Post aborted\"));\n        return 1;\n    }\n        \n    if(status < 0) {\n        do_log_error(L_ERROR, -status, \"Reading from client\");\n        if(status == -EDOGRACEFUL)\n            httpClientFinish(connection, 1);\n        else\n            httpClientFinish(connection, 2);\n        return 1;\n    }\n\n    push = MIN(srequest->offset - connection->reqlen,\n               connection->bodylen - connection->reqoffset);\n    if(push > 0) {\n        connection->reqlen += push;\n        httpSpecialDoSide(request);\n    }\n\n    do_log(L_ERROR, \"Incomplete client request.\\n\");\n    connection->flags &= ~CONN_READER;\n    httpClientRawError(connection, 502,\n                       internAtom(\"Incomplete client request\"), 1);\n    return 1;\n}",
        "target": 1
    },
    {
        "func": "httpSpecialSideRequest(ObjectPtr object, int method, int from, int to,\n                       HTTPRequestPtr requestor, void *closure)\n{\n    HTTPConnectionPtr client = requestor->connection;\n\n    assert(client->request == requestor);\n\n    if(method != METHOD_POST) {\n        httpClientError(requestor, 405, internAtom(\"Method not allowed\"));\n        requestor->connection->flags &= ~CONN_READER;\n        return 1;\n    }\n\n    return httpSpecialDoSide(requestor);\n}",
        "target": 1
    },
    {
        "func": "httpLocalRequest(ObjectPtr object, int method, int from, int to,\n                 HTTPRequestPtr requestor, void *closure)\n{\n    if(object->requestor == NULL)\n        object->requestor = requestor;\n\n    if(!disableLocalInterface && urlIsSpecial(object->key, object->key_size))\n        return httpSpecialRequest(object, method, from, to, \n                                  requestor, closure);\n\n    if(method >= METHOD_POST) {\n        httpClientError(requestor, 405, internAtom(\"Method not allowed\"));\n        requestor->connection->flags &= ~CONN_READER;\n        return 1;\n    }\n\n    /* objectFillFromDisk already did the real work but we have to\n       make sure we don't get into an infinite loop. */\n    if(object->flags & OBJECT_INITIAL) {\n        abortObject(object, 404, internAtom(\"Not found\"));\n    }\n    object->age = current_time.tv_sec;\n    object->date = current_time.tv_sec;\n\n    object->flags &= ~OBJECT_VALIDATING;\n    notifyObject(object);\n    return 1;\n}",
        "target": 1
    },
    {
        "func": "httpClientDiscardBody(HTTPConnectionPtr connection)\n{\n    TimeEventHandlerPtr handler;\n\n    assert(connection->reqoffset == 0);\n    assert(connection->flags & CONN_READER);\n\n    if(connection->reqte != TE_IDENTITY)\n        goto fail;\n\n    if(connection->bodylen < 0)\n        goto fail;\n\n    if(connection->bodylen < connection->reqlen - connection->reqbegin) {\n        connection->reqbegin += connection->bodylen;\n        connection->bodylen = 0;\n    } else {\n        connection->bodylen -= connection->reqlen - connection->reqbegin;\n        connection->reqbegin = 0;\n        connection->reqlen = 0;\n        httpConnectionDestroyReqbuf(connection);\n    }\n    connection->reqte = TE_UNKNOWN;\n\n    if(connection->bodylen > 0) {\n        httpSetTimeout(connection, clientTimeout);\n        do_stream_buf(IO_READ | IO_NOTNOW,\n                      connection->fd, connection->reqlen,\n                      &connection->reqbuf, CHUNK_SIZE,\n                      httpClientDiscardHandler, connection);\n        return 1;\n    }\n\n    if(connection->reqlen > connection->reqbegin &&\n       (connection->reqlen - connection->reqbegin) > 0) {\n        memmove(connection->reqbuf, connection->reqbuf + connection->reqbegin,\n                connection->reqlen - connection->reqbegin);\n        connection->reqlen -= connection->reqbegin;\n        connection->reqbegin = 0;\n    } else {\n        connection->reqlen = 0;\n        connection->reqbegin = 0;\n    }\n\n    httpSetTimeout(connection, clientTimeout);\n    /* We need to delay in order to make sure the previous request\n       gets queued on the server side.  IO_NOTNOW isn't strong enough\n       for that due to IO_IMMEDIATE. */\n    handler = scheduleTimeEvent(-1, httpClientDelayed,\n                                sizeof(connection), &connection);\n    if(handler == NULL) {\n        do_log(L_ERROR, \"Couldn't schedule reading from client.\");\n        goto fail;\n    }\n    return 1;\n\n fail:\n    connection->reqlen = 0;\n    connection->reqbegin = 0;\n    connection->bodylen = 0;\n    connection->reqte = TE_UNKNOWN;\n    shutdown(connection->fd, 2);\n    handler = scheduleTimeEvent(-1, httpClientDelayed,\n                                sizeof(connection), &connection);\n    if(handler == NULL) {\n        do_log(L_ERROR, \"Couldn't schedule reading from client.\");\n        connection->flags &= ~CONN_READER;\n    }\n    return 1;\n}",
        "target": 1
    },
    {
        "func": "httpSpecialDoSideFinish(AtomPtr data, HTTPRequestPtr requestor)\n{\n    ObjectPtr object = requestor->object;\n\n    if(matchUrl(\"/polipo/config\", object)) {\n        AtomListPtr list = NULL;\n        int i, rc;\n\n        if(disableConfiguration) {\n            abortObject(object, 403, internAtom(\"Action not allowed\"));\n            goto out;\n        }\n\n        list = urlDecode(data->string, data->length);\n        if(list == NULL) {\n            abortObject(object, 400,\n                        internAtom(\"Couldn't parse variable to set\"));\n            goto out;\n        }\n        for(i = 0; i < list->length; i++) {\n            rc = parseConfigLine(list->list[i]->string, NULL, 0, 1);\n            if(rc < 0) {\n                abortObject(object, 400,\n                            rc == -1 ?\n                            internAtom(\"Couldn't parse variable to set\") :\n                            internAtom(\"Variable is not settable\"));\n                destroyAtomList(list);\n                goto out;\n            }\n        }\n        destroyAtomList(list);\n        object->date = current_time.tv_sec;\n        object->age = current_time.tv_sec;\n        object->headers = internAtom(\"\\r\\nLocation: /polipo/config?\");\n        object->code = 303;\n        object->message = internAtom(\"Done\");\n        object->flags &= ~OBJECT_INITIAL;\n        object->length = 0;\n    } else if(matchUrl(\"/polipo/status\", object)) {\n        AtomListPtr list = NULL;\n        int i;\n\n        if(disableConfiguration) {\n            abortObject(object, 403, internAtom(\"Action not allowed\"));\n            goto out;\n        }\n\n        list = urlDecode(data->string, data->length);\n        if(list == NULL) {\n            abortObject(object, 400,\n                        internAtom(\"Couldn't parse action\"));\n            goto out;\n        }\n        for(i = 0; i < list->length; i++) {\n            char *equals = \n                memchr(list->list[i]->string, '=', list->list[i]->length);\n            AtomPtr name = \n                equals ? \n                internAtomN(list->list[i]->string, \n                            equals - list->list[i]->string) :\n                retainAtom(list->list[i]);\n            if(name == atomInitForbidden)\n                initForbidden();\n            else if(name == atomReopenLog)\n                reopenLog();\n            else if(name == atomDiscardObjects)\n                discardObjects(1, 0);\n            else if(name == atomWriteoutObjects)\n                writeoutObjects(1);\n            else if(name == atomFreeChunkArenas)\n                free_chunk_arenas();\n            else {\n                abortObject(object, 400, internAtomF(\"Unknown action %s\",\n                                                     name->string));\n                releaseAtom(name);\n                destroyAtomList(list);\n                goto out;\n            }\n            releaseAtom(name);\n        }\n        destroyAtomList(list);\n        object->date = current_time.tv_sec;\n        object->age = current_time.tv_sec;\n        object->headers = internAtom(\"\\r\\nLocation: /polipo/status?\");\n        object->code = 303;\n        object->message = internAtom(\"Done\");\n        object->flags &= ~OBJECT_INITIAL;\n        object->length = 0;\n    } else {\n        abortObject(object, 405, internAtom(\"Method not allowed\"));\n    }\n\n out:\n    releaseAtom(data);\n    notifyObject(object);\n    requestor->connection->flags &= ~CONN_READER;\n    return 1;\n}",
        "target": 1
    },
    {
        "func": "static char *getusername(void)\n{\n\tchar *username = NULL;\n\tstruct passwd *password = getpwuid(getuid());\n\n\tif (password)\n\t\tusername = password->pw_name;\n\treturn username;\n}",
        "target": 1
    },
    {
        "func": "assemble_mountinfo(struct parsed_mount_info *parsed_info,\n\t\t   const char *thisprogram, const char *mountpoint,\n\t\t   const char *orig_dev, char *orgoptions)\n{\n\tint rc;\n\n\trc = drop_child_privs();\n\tif (rc)\n\t\tgoto assemble_exit;\n\n\tif (getuid()) {\n\t\trc = check_fstab(thisprogram, mountpoint, orig_dev,\n\t\t\t\t &orgoptions);\n\t\tif (rc)\n\t\t\tgoto assemble_exit;\n\n\t\t/* enable any default user mount flags */\n\t\tparsed_info->flags |= CIFS_SETUID_FLAGS;\n\t}\n\n\trc = get_pw_from_env(parsed_info);\n\tif (rc)\n\t\tgoto assemble_exit;\n\n\tif (orgoptions) {\n\t\trc = parse_options(orgoptions, parsed_info);\n\t\tif (rc)\n\t\t\tgoto assemble_exit;\n\t}\n\n\tif (getuid()) {\n\t\tif (!(parsed_info->flags & (MS_USERS | MS_USER))) {\n\t\t\tfprintf(stderr, \"%s: permission denied\\n\", thisprogram);\n\t\t\trc = EX_USAGE;\n\t\t\tgoto assemble_exit;\n\t\t}\n\t}\n\n\tparsed_info->flags &= ~(MS_USERS | MS_USER);\n\n\trc = parse_unc(orig_dev, parsed_info);\n\tif (rc)\n\t\tgoto assemble_exit;\n\n\trc = resolve_host(parsed_info);\n\tif (rc)\n\t\tgoto assemble_exit;\n\n\tif (!parsed_info->got_user) {\n\t\t/*\n\t\t * Note that the password will not be retrieved from the\n\t\t * USER env variable (ie user%password form) as there is\n\t\t * already a PASSWD environment varaible\n\t\t */\n\t\tif (getenv(\"USER\"))\n\t\t\tstrlcpy(parsed_info->username, getenv(\"USER\"),\n\t\t\t\tsizeof(parsed_info->username));\n\t\telse\n\t\t\tstrlcpy(parsed_info->username, getusername(),\n\t\t\t\tsizeof(parsed_info->username));\n\t\tparsed_info->got_user = 1;\n\t}\n\n\tif (!parsed_info->got_password) {\n\t\t/* getpass is obsolete, but there's apparently nothing that replaces it */\n\t\tchar *tmp_pass = getpass(\"Password: \");\n\t\tif (!tmp_pass) {\n\t\t\tfprintf(stderr, \"Error reading password, exiting\\n\");\n\t\t\trc = EX_SYSERR;\n\t\t\tgoto assemble_exit;\n\t\t}\n\t\trc = set_password(parsed_info, tmp_pass);\n\t\tif (rc)\n\t\t\tgoto assemble_exit;\n\t}\n\n\t/* copy in ver= string. It's not really needed, but what the hell */\n\tstrlcat(parsed_info->options, \",ver=\", sizeof(parsed_info->options));\n\tstrlcat(parsed_info->options, OPTIONS_VERSION, sizeof(parsed_info->options));\n\n\t/* copy in user= string */\n\tif (parsed_info->got_user) {\n\t\tstrlcat(parsed_info->options, \",user=\",\n\t\t\tsizeof(parsed_info->options));\n\t\tstrlcat(parsed_info->options, parsed_info->username,\n\t\t\tsizeof(parsed_info->options));\n\t}\n\n\tif (*parsed_info->domain) {\n\t\tstrlcat(parsed_info->options, \",domain=\",\n\t\t\tsizeof(parsed_info->options));\n\t\tstrlcat(parsed_info->options, parsed_info->domain,\n\t\t\tsizeof(parsed_info->options));\n\t}\n\nassemble_exit:\n\treturn rc;\n}",
        "target": 1
    },
    {
        "func": "add_mtab(char *devname, char *mountpoint, unsigned long flags)\n{\n\tint rc = 0;\n\tchar *mount_user;\n\tstruct mntent mountent;\n\tFILE *pmntfile;\n\n\tatexit(unlock_mtab);\n\trc = lock_mtab();\n\tif (rc) {\n\t\tfprintf(stderr, \"cannot lock mtab\");\n\t\trc = EX_FILEIO;\n\t\tgoto add_mtab_exit;\n\t}\n\n\tpmntfile = setmntent(MOUNTED, \"a+\");\n\tif (!pmntfile) {\n\t\tfprintf(stderr, \"could not update mount table\\n\");\n\t\tunlock_mtab();\n\t\trc = EX_FILEIO;\n\t\tgoto add_mtab_exit;\n\t}\n\n\tmountent.mnt_fsname = devname;\n\tmountent.mnt_dir = mountpoint;\n\tmountent.mnt_type = (char *)(void *)cifs_fstype;\n\tmountent.mnt_opts = (char *)calloc(MTAB_OPTIONS_LEN, 1);\n\tif (mountent.mnt_opts) {\n\t\tif (flags & MS_RDONLY)\n\t\t\tstrlcat(mountent.mnt_opts, \"ro\", MTAB_OPTIONS_LEN);\n\t\telse\n\t\t\tstrlcat(mountent.mnt_opts, \"rw\", MTAB_OPTIONS_LEN);\n\n\t\tif (flags & MS_MANDLOCK)\n\t\t\tstrlcat(mountent.mnt_opts, \",mand\", MTAB_OPTIONS_LEN);\n\t\tif (flags & MS_NOEXEC)\n\t\t\tstrlcat(mountent.mnt_opts, \",noexec\", MTAB_OPTIONS_LEN);\n\t\tif (flags & MS_NOSUID)\n\t\t\tstrlcat(mountent.mnt_opts, \",nosuid\", MTAB_OPTIONS_LEN);\n\t\tif (flags & MS_NODEV)\n\t\t\tstrlcat(mountent.mnt_opts, \",nodev\", MTAB_OPTIONS_LEN);\n\t\tif (flags & MS_SYNCHRONOUS)\n\t\t\tstrlcat(mountent.mnt_opts, \",sync\", MTAB_OPTIONS_LEN);\n\t\tif (getuid() != 0) {\n\t\t\tstrlcat(mountent.mnt_opts, \",user=\", MTAB_OPTIONS_LEN);\n\t\t\tmount_user = getusername();\n\t\t\tif (mount_user)\n\t\t\t\tstrlcat(mountent.mnt_opts, mount_user,\n\t\t\t\t\tMTAB_OPTIONS_LEN);\n\t\t}\n\t}\n\tmountent.mnt_freq = 0;\n\tmountent.mnt_passno = 0;\n\trc = addmntent(pmntfile, &mountent);\n\tendmntent(pmntfile);\n\tunlock_mtab();\n\tSAFE_FREE(mountent.mnt_opts);\nadd_mtab_exit:\n\tif (rc) {\n\t\tfprintf(stderr, \"unable to add mount entry to mtab\\n\");\n\t\trc = EX_FILEIO;\n\t}\n\n\treturn rc;\n}",
        "target": 1
    },
    {
        "func": "process_ra(struct Interface *iface, unsigned char *msg, int len,\n\tstruct sockaddr_in6 *addr)\n{\n\tstruct nd_router_advert *radvert;\n\tchar addr_str[INET6_ADDRSTRLEN];\n\tuint8_t *opt_str;\n\n\tprint_addr(&addr->sin6_addr, addr_str);\n\n\tradvert = (struct nd_router_advert *) msg;\n\n\tif ((radvert->nd_ra_curhoplimit && iface->AdvCurHopLimit) &&\n\t   (radvert->nd_ra_curhoplimit != iface->AdvCurHopLimit))\n\t{\n\t\tflog(LOG_WARNING, \"our AdvCurHopLimit on %s doesn't agree with %s\",\n\t\t\tiface->Name, addr_str);\n\t}\n\n\tif ((radvert->nd_ra_flags_reserved & ND_RA_FLAG_MANAGED) && !iface->AdvManagedFlag)\n\t{\n\t\tflog(LOG_WARNING, \"our AdvManagedFlag on %s doesn't agree with %s\",\n\t\t\tiface->Name, addr_str);\n\t}\n\n\tif ((radvert->nd_ra_flags_reserved & ND_RA_FLAG_OTHER) && !iface->AdvOtherConfigFlag)\n\t{\n\t\tflog(LOG_WARNING, \"our AdvOtherConfigFlag on %s doesn't agree with %s\",\n\t\t\tiface->Name, addr_str);\n\t}\n\n\t/* note: we don't check the default router preference here, because they're likely different */\n\n\tif ((radvert->nd_ra_reachable && iface->AdvReachableTime) &&\n\t   (ntohl(radvert->nd_ra_reachable) != iface->AdvReachableTime))\n\t{\n\t\tflog(LOG_WARNING, \"our AdvReachableTime on %s doesn't agree with %s\",\n\t\t\tiface->Name, addr_str);\n\t}\n\n\tif ((radvert->nd_ra_retransmit && iface->AdvRetransTimer) &&\n\t   (ntohl(radvert->nd_ra_retransmit) != iface->AdvRetransTimer))\n\t{\n\t\tflog(LOG_WARNING, \"our AdvRetransTimer on %s doesn't agree with %s\",\n\t\t\tiface->Name, addr_str);\n\t}\n\n\tlen -= sizeof(struct nd_router_advert);\n\n\tif (len == 0)\n\t\treturn;\n\n\topt_str = (uint8_t *)(msg + sizeof(struct nd_router_advert));\n\n\twhile (len > 0)\n\t{\n\t\tint optlen;\n\t\tstruct nd_opt_prefix_info *pinfo;\n\t\tstruct nd_opt_rdnss_info_local *rdnssinfo;\n\t\tstruct nd_opt_dnssl_info_local *dnsslinfo;\n\t\tstruct nd_opt_mtu *mtu;\n\t\tstruct AdvPrefix *prefix;\n\t\tstruct AdvRDNSS *rdnss;\n\t\tchar prefix_str[INET6_ADDRSTRLEN];\n\t\tchar rdnss_str[INET6_ADDRSTRLEN];\n\t\tchar suffix[256];\n\t\tint offset, label_len;\n\t\tuint32_t preferred, valid, count;\n\n\t\tif (len < 2)\n\t\t{\n\t\t\tflog(LOG_ERR, \"trailing garbage in RA on %s from %s\",\n\t\t\t\tiface->Name, addr_str);\n\t\t\tbreak;\n\t\t}\n\n\t\toptlen = (opt_str[1] << 3);\n\n\t\tif (optlen == 0)\n\t\t{\n\t\t\tflog(LOG_ERR, \"zero length option in RA on %s from %s\",\n\t\t\t\tiface->Name, addr_str);\n\t\t\tbreak;\n\t\t}\n\t\telse if (optlen > len)\n\t\t{\n\t\t\tflog(LOG_ERR, \"option length greater than total\"\n\t\t\t\t\" length in RA on %s from %s\",\n\t\t\t\tiface->Name, addr_str);\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (*opt_str)\n\t\t{\n\t\tcase ND_OPT_MTU:\n\t\t\tmtu = (struct nd_opt_mtu *)opt_str;\n\n\t\t\tif (iface->AdvLinkMTU && (ntohl(mtu->nd_opt_mtu_mtu) != iface->AdvLinkMTU))\n\t\t\t{\n\t\t\t\tflog(LOG_WARNING, \"our AdvLinkMTU on %s doesn't agree with %s\",\n\t\t\t\t\tiface->Name, addr_str);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ND_OPT_PREFIX_INFORMATION:\n\t\t\tpinfo = (struct nd_opt_prefix_info *) opt_str;\n\t\t\tpreferred = ntohl(pinfo->nd_opt_pi_preferred_time);\n\t\t\tvalid = ntohl(pinfo->nd_opt_pi_valid_time);\n\n\t\t\tprefix = iface->AdvPrefixList;\n\t\t\twhile (prefix)\n\t\t\t{\n\t\t\t\tif (prefix->enabled &&\n\t\t\t\t    (prefix->PrefixLen == pinfo->nd_opt_pi_prefix_len) &&\n\t\t\t\t    addr_match(&prefix->Prefix, &pinfo->nd_opt_pi_prefix,\n\t\t\t\t    \t prefix->PrefixLen))\n\t\t\t\t{\n\t\t\t\t\tprint_addr(&prefix->Prefix, prefix_str);\n\n\t\t\t\t\tif (!prefix->DecrementLifetimesFlag && valid != prefix->AdvValidLifetime)\n\t\t\t\t\t{\n\t\t\t\t\t\tflog(LOG_WARNING, \"our AdvValidLifetime on\"\n\t\t\t\t\t\t \" %s for %s doesn't agree with %s\",\n\t\t\t\t\t\t iface->Name,\n\t\t\t\t\t\t prefix_str,\n\t\t\t\t\t\t addr_str\n\t\t\t\t\t\t );\n\t\t\t\t\t}\n\t\t\t\t\tif (!prefix->DecrementLifetimesFlag && preferred != prefix->AdvPreferredLifetime)\n\t\t\t\t\t{\n\t\t\t\t\t\tflog(LOG_WARNING, \"our AdvPreferredLifetime on\"\n\t\t\t\t\t\t \" %s for %s doesn't agree with %s\",\n\t\t\t\t\t\t iface->Name,\n\t\t\t\t\t\t prefix_str,\n\t\t\t\t\t\t addr_str\n\t\t\t\t\t\t );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tprefix = prefix->next;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ND_OPT_ROUTE_INFORMATION:\n\t\t\t/* not checked: these will very likely vary a lot */\n\t\t\tbreak;\n\t\tcase ND_OPT_SOURCE_LINKADDR:\n\t\t\t/* not checked */\n\t\t\tbreak;\n\t\tcase ND_OPT_TARGET_LINKADDR:\n\t\tcase ND_OPT_REDIRECTED_HEADER:\n\t\t\tflog(LOG_ERR, \"invalid option %d in RA on %s from %s\",\n\t\t\t\t(int)*opt_str, iface->Name, addr_str);\n\t\t\tbreak;\n\t\t/* Mobile IPv6 extensions */\n\t\tcase ND_OPT_RTR_ADV_INTERVAL:\n\t\tcase ND_OPT_HOME_AGENT_INFO:\n\t\t\t/* not checked */\n\t\t\tbreak;\n\t\tcase ND_OPT_RDNSS_INFORMATION:\n\t\t\trdnssinfo = (struct nd_opt_rdnss_info_local *) opt_str;\n\t\t\tcount = rdnssinfo->nd_opt_rdnssi_len;\n\n\t\t\t/* Check the RNDSS addresses received */\n\t\t\tswitch (count) {\n\t\t\t\tcase 7:\n\t\t\t\t\trdnss = iface->AdvRDNSSList;\n\t\t\t\t\tif (!check_rdnss_presence(rdnss, &rdnssinfo->nd_opt_rdnssi_addr3 )) {\n\t\t\t\t\t\t/* no match found in iface->AdvRDNSSList */\n\t\t\t\t\t\tprint_addr(&rdnssinfo->nd_opt_rdnssi_addr3, rdnss_str);\n\t\t\t\t\t\tflog(LOG_WARNING, \"RDNSS address %s received on %s from %s is not advertised by us\",\n\t\t\t\t\t\t\trdnss_str, iface->Name, addr_str);\n\t\t\t\t\t}\n\t\t\t\t\t/* FALLTHROUGH */\n\t\t\t\tcase 5:\n\t\t\t\t\trdnss = iface->AdvRDNSSList;\n\t\t\t\t\tif (!check_rdnss_presence(rdnss, &rdnssinfo->nd_opt_rdnssi_addr2 )) {\n\t\t\t\t\t\t/* no match found in iface->AdvRDNSSList */\n\t\t\t\t\t\tprint_addr(&rdnssinfo->nd_opt_rdnssi_addr2, rdnss_str);\n\t\t\t\t\t\tflog(LOG_WARNING, \"RDNSS address %s received on %s from %s is not advertised by us\",\n\t\t\t\t\t\t\trdnss_str, iface->Name, addr_str);\n\t\t\t\t\t}\n\t\t\t\t\t/* FALLTHROUGH */\n\t\t\t\tcase 3:\n\t\t\t\t\trdnss = iface->AdvRDNSSList;\n\t\t\t\t\tif (!check_rdnss_presence(rdnss, &rdnssinfo->nd_opt_rdnssi_addr1 )) {\n\t\t\t\t\t\t/* no match found in iface->AdvRDNSSList */\n\t\t\t\t\t\tprint_addr(&rdnssinfo->nd_opt_rdnssi_addr1, rdnss_str);\n\t\t\t\t\t\tflog(LOG_WARNING, \"RDNSS address %s received on %s from %s is not advertised by us\",\n\t\t\t\t\t\t\trdnss_str, iface->Name, addr_str);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tflog(LOG_ERR, \"invalid len %i in RDNSS option on %s from %s\",\n\t\t\t\t\t\t\tcount, iface->Name, addr_str);\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase ND_OPT_DNSSL_INFORMATION:\n\t\t\tdnsslinfo = (struct nd_opt_dnssl_info_local *) opt_str;\n\t\t\tsuffix[0] = '\\0';\n\t\t\tfor (offset = 0; offset < (dnsslinfo->nd_opt_dnssli_len-1)*8;) {\n\t\t\t\tlabel_len = dnsslinfo->nd_opt_dnssli_suffixes[offset++];\n\n\t\t\t\tif (label_len == 0) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Ignore empty suffixes. They're\n\t\t\t\t\t * probably just padding...\n\t\t\t\t\t */\n\t\t\t\t\tif (suffix[0] == '\\0')\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (!check_dnssl_presence(iface->AdvDNSSLList, suffix)) {\n\t\t\t\t\t\tflog(LOG_WARNING, \"DNSSL suffix %s received on %s from %s is not advertised by us\",\n\t\t\t\t\t\t\tsuffix, iface->Name, addr_str);\n\t\t\t\t\t}\n\n\t\t\t\t\tsuffix[0] = '\\0';\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif ((sizeof(suffix) - strlen(suffix)) < (label_len + 2)) {\n\t\t\t\t\tflog(LOG_ERR, \"oversized suffix in DNSSL option on %s from %s\",\n\t\t\t\t\t\t\tiface->Name, addr_str);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (suffix[0] != '\\0')\n\t\t\t\t\tstrcat(suffix, \".\");\n\t\t\t\tstrncat(suffix, &dnsslinfo->nd_opt_dnssli_suffixes[offset], label_len);\n\t\t\t\toffset += label_len;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdlog(LOG_DEBUG, 1, \"unknown option %d in RA on %s from %s\",\n\t\t\t\t(int)*opt_str, iface->Name, addr_str);\n\t\t\tbreak;\n\t\t}\n\n\t\tlen -= optlen;\n\t\topt_str += optlen;\n\t}\n}",
        "target": 1
    },
    {
        "func": "set_interface_var(const char *iface,\n\t\t  const char *var, const char *name,\n\t\t  uint32_t val)\n{\n\tFILE *fp;\n\tchar spath[64+IFNAMSIZ];\t/* XXX: magic constant */\n\tif (snprintf(spath, sizeof(spath), var, iface) >= sizeof(spath))\n\t\treturn -1;\n\n\tif (access(spath, F_OK) != 0)\n\t\treturn -1;\n\n\tfp = fopen(spath, \"w\");\n\tif (!fp) {\n\t\tif (name)\n\t\t\tflog(LOG_ERR, \"failed to set %s (%u) for %s: %s\",\n\t\t\t     name, val, iface, strerror(errno));\n\t\treturn -1;\n\t}\n\tfprintf(fp, \"%u\", val);\n\tfclose(fp);\n\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "main(int argc, char *argv[])\n{\n\tchar pidstr[16];\n\tssize_t ret;\n\tint c, log_method;\n\tchar *logfile, *pidfile;\n\tint facility, fd;\n\tchar *username = NULL;\n\tchar *chrootdir = NULL;\n\tint configtest = 0;\n\tint singleprocess = 0;\n#ifdef HAVE_GETOPT_LONG\n\tint opt_idx;\n#endif\n\n\tpname = ((pname=strrchr(argv[0],'/')) != NULL)?pname+1:argv[0];\n\n\tsrand((unsigned int)time(NULL));\n\n\tlog_method = L_STDERR_SYSLOG;\n\tlogfile = PATH_RADVD_LOG;\n\tconf_file = PATH_RADVD_CONF;\n\tfacility = LOG_FACILITY;\n\tpidfile = PATH_RADVD_PID;\n\n\t/* parse args */\n#define OPTIONS_STR \"d:C:l:m:p:t:u:vhcs\"\n#ifdef HAVE_GETOPT_LONG\n\twhile ((c = getopt_long(argc, argv, OPTIONS_STR, prog_opt, &opt_idx)) > 0)\n#else\n\twhile ((c = getopt(argc, argv, OPTIONS_STR)) > 0)\n#endif\n\t{\n\t\tswitch (c) {\n\t\tcase 'C':\n\t\t\tconf_file = optarg;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tset_debuglevel(atoi(optarg));\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tfacility = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tlogfile = optarg;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tpidfile = optarg;\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tif (!strcmp(optarg, \"syslog\"))\n\t\t\t{\n\t\t\t\tlog_method = L_SYSLOG;\n\t\t\t}\n\t\t\telse if (!strcmp(optarg, \"stderr_syslog\"))\n\t\t\t{\n\t\t\t\tlog_method = L_STDERR_SYSLOG;\n\t\t\t}\n\t\t\telse if (!strcmp(optarg, \"stderr\"))\n\t\t\t{\n\t\t\t\tlog_method = L_STDERR;\n\t\t\t}\n\t\t\telse if (!strcmp(optarg, \"logfile\"))\n\t\t\t{\n\t\t\t\tlog_method = L_LOGFILE;\n\t\t\t}\n\t\t\telse if (!strcmp(optarg, \"none\"))\n\t\t\t{\n\t\t\t\tlog_method = L_NONE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfprintf(stderr, \"%s: unknown log method: %s\\n\", pname, optarg);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tchrootdir = strdup(optarg);\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tusername = strdup(optarg);\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tversion();\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tconfigtest = 1;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tsingleprocess = 1;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage();\n#ifdef HAVE_GETOPT_LONG\n\t\tcase ':':\n\t\t\tfprintf(stderr, \"%s: option %s: parameter expected\\n\", pname,\n\t\t\t\tprog_opt[opt_idx].name);\n\t\t\texit(1);\n#endif\n\t\tcase '?':\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tif (chrootdir) {\n\t\tif (!username) {\n\t\t\tfprintf(stderr, \"Chroot as root is not safe, exiting\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\tif (chroot(chrootdir) == -1) {\n\t\t\tperror(\"chroot\");\n\t\t\texit (1);\n\t\t}\n\n\t\tif (chdir(\"/\") == -1) {\n\t\t\tperror(\"chdir\");\n\t\t\texit (1);\n\t\t}\n\t\t/* username will be switched later */\n\t}\n\n\tif (configtest) {\n\t\tlog_method = L_STDERR;\n\t}\n\n\tif (log_open(log_method, pname, logfile, facility) < 0) {\n\t\tperror(\"log_open\");\n\t\texit(1);\n\t}\n\n\tif (!configtest) {\n\t\tflog(LOG_INFO, \"version %s started\", VERSION);\n\t}\n\n\t/* get a raw socket for sending and receiving ICMPv6 messages */\n\tsock = open_icmpv6_socket();\n\tif (sock < 0) {\n\t\tperror(\"open_icmpv6_socket\");\n\t\texit(1);\n\t}\n\n\t/* check that 'other' cannot write the file\n         * for non-root, also that self/own group can't either\n         */\n\tif (check_conffile_perm(username, conf_file) < 0) {\n\t\tif (get_debuglevel() == 0) {\n\t\t\tflog(LOG_ERR, \"Exiting, permissions on conf_file invalid.\\n\");\n\t\t\texit(1);\n\t\t}\n\t\telse\n\t\t\tflog(LOG_WARNING, \"Insecure file permissions, but continuing anyway\");\n\t}\n\n\t/* if we know how to do it, check whether forwarding is enabled */\n\tif (check_ip6_forwarding()) {\n\t\tflog(LOG_WARNING, \"IPv6 forwarding seems to be disabled, but continuing anyway.\");\n\t}\n\n\t/* parse config file */\n\tif (readin_config(conf_file) < 0) {\n\t\tflog(LOG_ERR, \"Exiting, failed to read config file.\\n\");\n\t\texit(1);\n\t}\n\n\tif (configtest) {\n\t\tfprintf(stderr, \"Syntax OK\\n\");\n\t\texit(0);\n\t}\n\n\t/* drop root privileges if requested. */\n\tif (username) {\n\t\tif (!singleprocess) {\n\t\t \tdlog(LOG_DEBUG, 3, \"Initializing privsep\");\n\t\t \tif (privsep_init() < 0)\n\t\t\t\tflog(LOG_WARNING, \"Failed to initialize privsep.\");\n\t\t}\n\n\t\tif (drop_root_privileges(username) < 0) {\n\t\t\tperror(\"drop_root_privileges\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tif ((fd = open(pidfile, O_RDONLY, 0)) > 0)\n\t{\n\t\tret = read(fd, pidstr, sizeof(pidstr) - 1);\n\t\tif (ret < 0)\n\t\t{\n\t\t\tflog(LOG_ERR, \"cannot read radvd pid file, terminating: %s\", strerror(errno));\n\t\t\texit(1);\n\t\t}\n\t\tpidstr[ret] = '\\0';\n\t\tif (!kill((pid_t)atol(pidstr), 0))\n\t\t{\n\t\t\tflog(LOG_ERR, \"radvd already running, terminating.\");\n\t\t\texit(1);\n\t\t}\n\t\tclose(fd);\n\t\tfd = open(pidfile, O_CREAT|O_TRUNC|O_WRONLY, 0644);\n\t}\n\telse\t/* FIXME: not atomic if pidfile is on an NFS mounted volume */\n\t\tfd = open(pidfile, O_CREAT|O_EXCL|O_WRONLY, 0644);\n\n\tif (fd < 0)\n\t{\n\t\tflog(LOG_ERR, \"cannot create radvd pid file, terminating: %s\", strerror(errno));\n\t\texit(1);\n\t}\n\n\t/*\n\t * okay, config file is read in, socket and stuff is setup, so\n\t * lets fork now...\n\t */\n\n\tif (get_debuglevel() == 0) {\n\n\t\t/* Detach from controlling terminal */\n\t\tif (daemon(0, 0) < 0)\n\t\t\tperror(\"daemon\");\n\n\t\t/* close old logfiles, including stderr */\n\t\tlog_close();\n\n\t\t/* reopen logfiles, but don't log to stderr unless explicitly requested */\n\t\tif (log_method == L_STDERR_SYSLOG)\n\t\t\tlog_method = L_SYSLOG;\n\t\tif (log_open(log_method, pname, logfile, facility) < 0) {\n\t\t\tperror(\"log_open\");\n\t\t\texit(1);\n\t\t}\n\n\t}\n\n\t/*\n\t *\tconfig signal handlers\n\t */\n\tsignal(SIGHUP, sighup_handler);\n\tsignal(SIGTERM, sigterm_handler);\n\tsignal(SIGINT, sigint_handler);\n\tsignal(SIGUSR1, sigusr1_handler);\n\n\tsnprintf(pidstr, sizeof(pidstr), \"%ld\\n\", (long)getpid());\n\n\tret = write(fd, pidstr, strlen(pidstr));\n\tif (ret != strlen(pidstr))\n\t{\n\t\tflog(LOG_ERR, \"cannot write radvd pid file, terminating: %s\", strerror(errno));\n\t\texit(1);\n\t}\n\n\tclose(fd);\n\n\tconfig_interface();\n\tkickoff_adverts();\n\tmain_loop();\n\tstop_adverts();\n\tunlink(pidfile);\n\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "privsep_read_loop(void)\n{\n\tstruct privsep_command cmd;\n\tint ret;\n\n\twhile (1) {\n\t\tret = readn(pfd, &cmd, sizeof(cmd));\n\t\tif (ret <= 0) {\n\t\t\t/* Error or EOF, give up */\n\t\t\tif (ret < 0) {\n\t\t\t\tflog(LOG_ERR, \"Exiting, privsep_read_loop had readn error: %s\\n\",\n\t\t\t\t     strerror(errno));\n\t\t\t} else {\n\t\t\t\tflog(LOG_ERR, \"Exiting, privsep_read_loop had readn return 0 bytes\\n\");\n\t\t\t}\n\t\t\tclose(pfd);\n\t\t\t_exit(0);\n\t\t}\n\t\tif (ret != sizeof(cmd)) {\n\t\t\t/* Short read, ignore */\n\t\t\tcontinue;\n\t\t}\n\n\t\tcmd.iface[IFNAMSIZ-1] = '\\0';\n\n\t\tswitch(cmd.type) {\n\n\t\tcase SET_INTERFACE_LINKMTU:\n\t\t\tif (cmd.val < MIN_AdvLinkMTU || cmd.val > MAX_AdvLinkMTU) {\n\t\t\t\tflog(LOG_ERR, \"(privsep) %s: LinkMTU (%u) is not within the defined bounds, ignoring\", cmd.iface, cmd.val);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tret = set_interface_var(cmd.iface, PROC_SYS_IP6_LINKMTU, \"LinkMTU\", cmd.val);\n\t\t\tbreak;\n\n\t\tcase SET_INTERFACE_CURHLIM:\n\t\t\tif (cmd.val < MIN_AdvCurHopLimit || cmd.val > MAX_AdvCurHopLimit) {\n\t\t\t\tflog(LOG_ERR, \"(privsep) %s: CurHopLimit (%u) is not within the defined bounds, ignoring\", cmd.iface, cmd.val);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tret = set_interface_var(cmd.iface, PROC_SYS_IP6_CURHLIM, \"CurHopLimit\", cmd.val);\n\t\t\tbreak;\n\n\t\tcase SET_INTERFACE_REACHTIME:\n\t\t\tif (cmd.val < MIN_AdvReachableTime || cmd.val > MAX_AdvReachableTime) {\n\t\t\t\tflog(LOG_ERR, \"(privsep) %s: BaseReachableTimer (%u) is not within the defined bounds, ignoring\", cmd.iface, cmd.val);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tret = set_interface_var(cmd.iface, PROC_SYS_IP6_BASEREACHTIME_MS, \"BaseReachableTimer (ms)\", cmd.val);\n\t\t\tif (ret == 0)\n\t\t\t\tbreak;\n\t\t\tset_interface_var(cmd.iface, PROC_SYS_IP6_BASEREACHTIME, \"BaseReachableTimer\", cmd.val / 1000);\n\t\t\tbreak;\n\n\t\tcase SET_INTERFACE_RETRANSTIMER:\n\t\t\tif (cmd.val < MIN_AdvRetransTimer || cmd.val > MAX_AdvRetransTimer) {\n\t\t\t\tflog(LOG_ERR, \"(privsep) %s: RetransTimer (%u) is not within the defined bounds, ignoring\", cmd.iface, cmd.val);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tret = set_interface_var(cmd.iface, PROC_SYS_IP6_RETRANSTIMER_MS, \"RetransTimer (ms)\", cmd.val);\n\t\t\tif (ret == 0)\n\t\t\t\tbreak;\n\t\t\tset_interface_var(cmd.iface, PROC_SYS_IP6_RETRANSTIMER, \"RetransTimer\", cmd.val / 1000 * USER_HZ); /* XXX user_hz */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* Bad command */\n\t\t\tbreak;\n\t\t}\n\t}\n}",
        "target": 1
    },
    {
        "func": "main(int argc, char *argv[])\n{\n\tchar pidstr[16];\n\tssize_t ret;\n\tint c, log_method;\n\tchar *logfile, *pidfile;\n\tint facility, fd;\n\tchar *username = NULL;\n\tchar *chrootdir = NULL;\n\tint configtest = 0;\n\tint singleprocess = 0;\n#ifdef HAVE_GETOPT_LONG\n\tint opt_idx;\n#endif\n\n\tpname = ((pname=strrchr(argv[0],'/')) != NULL)?pname+1:argv[0];\n\n\tsrand((unsigned int)time(NULL));\n\n\tlog_method = L_STDERR_SYSLOG;\n\tlogfile = PATH_RADVD_LOG;\n\tconf_file = PATH_RADVD_CONF;\n\tfacility = LOG_FACILITY;\n\tpidfile = PATH_RADVD_PID;\n\n\t/* parse args */\n#define OPTIONS_STR \"d:C:l:m:p:t:u:vhcs\"\n#ifdef HAVE_GETOPT_LONG\n\twhile ((c = getopt_long(argc, argv, OPTIONS_STR, prog_opt, &opt_idx)) > 0)\n#else\n\twhile ((c = getopt(argc, argv, OPTIONS_STR)) > 0)\n#endif\n\t{\n\t\tswitch (c) {\n\t\tcase 'C':\n\t\t\tconf_file = optarg;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tset_debuglevel(atoi(optarg));\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tfacility = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tlogfile = optarg;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tpidfile = optarg;\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tif (!strcmp(optarg, \"syslog\"))\n\t\t\t{\n\t\t\t\tlog_method = L_SYSLOG;\n\t\t\t}\n\t\t\telse if (!strcmp(optarg, \"stderr_syslog\"))\n\t\t\t{\n\t\t\t\tlog_method = L_STDERR_SYSLOG;\n\t\t\t}\n\t\t\telse if (!strcmp(optarg, \"stderr\"))\n\t\t\t{\n\t\t\t\tlog_method = L_STDERR;\n\t\t\t}\n\t\t\telse if (!strcmp(optarg, \"logfile\"))\n\t\t\t{\n\t\t\t\tlog_method = L_LOGFILE;\n\t\t\t}\n\t\t\telse if (!strcmp(optarg, \"none\"))\n\t\t\t{\n\t\t\t\tlog_method = L_NONE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfprintf(stderr, \"%s: unknown log method: %s\\n\", pname, optarg);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tchrootdir = strdup(optarg);\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tusername = strdup(optarg);\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tversion();\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tconfigtest = 1;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tsingleprocess = 1;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage();\n#ifdef HAVE_GETOPT_LONG\n\t\tcase ':':\n\t\t\tfprintf(stderr, \"%s: option %s: parameter expected\\n\", pname,\n\t\t\t\tprog_opt[opt_idx].name);\n\t\t\texit(1);\n#endif\n\t\tcase '?':\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tif (chrootdir) {\n\t\tif (!username) {\n\t\t\tfprintf(stderr, \"Chroot as root is not safe, exiting\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\tif (chroot(chrootdir) == -1) {\n\t\t\tperror(\"chroot\");\n\t\t\texit (1);\n\t\t}\n\n\t\tif (chdir(\"/\") == -1) {\n\t\t\tperror(\"chdir\");\n\t\t\texit (1);\n\t\t}\n\t\t/* username will be switched later */\n\t}\n\n\tif (configtest) {\n\t\tlog_method = L_STDERR;\n\t}\n\n\tif (log_open(log_method, pname, logfile, facility) < 0) {\n\t\tperror(\"log_open\");\n\t\texit(1);\n\t}\n\n\tif (!configtest) {\n\t\tflog(LOG_INFO, \"version %s started\", VERSION);\n\t}\n\n\t/* get a raw socket for sending and receiving ICMPv6 messages */\n\tsock = open_icmpv6_socket();\n\tif (sock < 0) {\n\t\tperror(\"open_icmpv6_socket\");\n\t\texit(1);\n\t}\n\n\t/* check that 'other' cannot write the file\n         * for non-root, also that self/own group can't either\n         */\n\tif (check_conffile_perm(username, conf_file) < 0) {\n\t\tif (get_debuglevel() == 0) {\n\t\t\tflog(LOG_ERR, \"Exiting, permissions on conf_file invalid.\\n\");\n\t\t\texit(1);\n\t\t}\n\t\telse\n\t\t\tflog(LOG_WARNING, \"Insecure file permissions, but continuing anyway\");\n\t}\n\n\t/* if we know how to do it, check whether forwarding is enabled */\n\tif (check_ip6_forwarding()) {\n\t\tflog(LOG_WARNING, \"IPv6 forwarding seems to be disabled, but continuing anyway.\");\n\t}\n\n\t/* parse config file */\n\tif (readin_config(conf_file) < 0) {\n\t\tflog(LOG_ERR, \"Exiting, failed to read config file.\\n\");\n\t\texit(1);\n\t}\n\n\tif (configtest) {\n\t\tfprintf(stderr, \"Syntax OK\\n\");\n\t\texit(0);\n\t}\n\n\t/* drop root privileges if requested. */\n\tif (username) {\n\t\tif (!singleprocess) {\n\t\t \tdlog(LOG_DEBUG, 3, \"Initializing privsep\");\n\t\t \tif (privsep_init() < 0)\n\t\t\t\tperror(\"Failed to initialize privsep.\");\n\t\t}\n\n\t\tif (drop_root_privileges(username) < 0) {\n\t\t\tperror(\"drop_root_privileges\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tif ((fd = open(pidfile, O_RDONLY, 0)) > 0)\n\t{\n\t\tret = read(fd, pidstr, sizeof(pidstr) - 1);\n\t\tif (ret < 0)\n\t\t{\n\t\t\tflog(LOG_ERR, \"cannot read radvd pid file, terminating: %s\", strerror(errno));\n\t\t\texit(1);\n\t\t}\n\t\tpidstr[ret] = '\\0';\n\t\tif (!kill((pid_t)atol(pidstr), 0))\n\t\t{\n\t\t\tflog(LOG_ERR, \"radvd already running, terminating.\");\n\t\t\texit(1);\n\t\t}\n\t\tclose(fd);\n\t\tfd = open(pidfile, O_CREAT|O_TRUNC|O_WRONLY, 0644);\n\t}\n\telse\t/* FIXME: not atomic if pidfile is on an NFS mounted volume */\n\t\tfd = open(pidfile, O_CREAT|O_EXCL|O_WRONLY, 0644);\n\n\tif (fd < 0)\n\t{\n\t\tflog(LOG_ERR, \"cannot create radvd pid file, terminating: %s\", strerror(errno));\n\t\texit(1);\n\t}\n\n\t/*\n\t * okay, config file is read in, socket and stuff is setup, so\n\t * lets fork now...\n\t */\n\n\tif (get_debuglevel() == 0) {\n\n\t\t/* Detach from controlling terminal */\n\t\tif (daemon(0, 0) < 0)\n\t\t\tperror(\"daemon\");\n\n\t\t/* close old logfiles, including stderr */\n\t\tlog_close();\n\n\t\t/* reopen logfiles, but don't log to stderr unless explicitly requested */\n\t\tif (log_method == L_STDERR_SYSLOG)\n\t\t\tlog_method = L_SYSLOG;\n\t\tif (log_open(log_method, pname, logfile, facility) < 0) {\n\t\t\tperror(\"log_open\");\n\t\t\texit(1);\n\t\t}\n\n\t}\n\n\t/*\n\t *\tconfig signal handlers\n\t */\n\tsignal(SIGHUP, sighup_handler);\n\tsignal(SIGTERM, sigterm_handler);\n\tsignal(SIGINT, sigint_handler);\n\tsignal(SIGUSR1, sigusr1_handler);\n\n\tsnprintf(pidstr, sizeof(pidstr), \"%ld\\n\", (long)getpid());\n\n\tret = write(fd, pidstr, strlen(pidstr));\n\tif (ret != strlen(pidstr))\n\t{\n\t\tflog(LOG_ERR, \"cannot write radvd pid file, terminating: %s\", strerror(errno));\n\t\texit(1);\n\t}\n\n\tclose(fd);\n\n\tconfig_interface();\n\tkickoff_adverts();\n\tmain_loop();\n\tstop_adverts();\n\tunlink(pidfile);\n\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "process_ra(struct Interface *iface, unsigned char *msg, int len,\n\tstruct sockaddr_in6 *addr)\n{\n\tstruct nd_router_advert *radvert;\n\tchar addr_str[INET6_ADDRSTRLEN];\n\tuint8_t *opt_str;\n\n\tprint_addr(&addr->sin6_addr, addr_str);\n\n\tradvert = (struct nd_router_advert *) msg;\n\n\tif ((radvert->nd_ra_curhoplimit && iface->AdvCurHopLimit) &&\n\t   (radvert->nd_ra_curhoplimit != iface->AdvCurHopLimit))\n\t{\n\t\tflog(LOG_WARNING, \"our AdvCurHopLimit on %s doesn't agree with %s\",\n\t\t\tiface->Name, addr_str);\n\t}\n\n\tif ((radvert->nd_ra_flags_reserved & ND_RA_FLAG_MANAGED) && !iface->AdvManagedFlag)\n\t{\n\t\tflog(LOG_WARNING, \"our AdvManagedFlag on %s doesn't agree with %s\",\n\t\t\tiface->Name, addr_str);\n\t}\n\n\tif ((radvert->nd_ra_flags_reserved & ND_RA_FLAG_OTHER) && !iface->AdvOtherConfigFlag)\n\t{\n\t\tflog(LOG_WARNING, \"our AdvOtherConfigFlag on %s doesn't agree with %s\",\n\t\t\tiface->Name, addr_str);\n\t}\n\n\t/* note: we don't check the default router preference here, because they're likely different */\n\n\tif ((radvert->nd_ra_reachable && iface->AdvReachableTime) &&\n\t   (ntohl(radvert->nd_ra_reachable) != iface->AdvReachableTime))\n\t{\n\t\tflog(LOG_WARNING, \"our AdvReachableTime on %s doesn't agree with %s\",\n\t\t\tiface->Name, addr_str);\n\t}\n\n\tif ((radvert->nd_ra_retransmit && iface->AdvRetransTimer) &&\n\t   (ntohl(radvert->nd_ra_retransmit) != iface->AdvRetransTimer))\n\t{\n\t\tflog(LOG_WARNING, \"our AdvRetransTimer on %s doesn't agree with %s\",\n\t\t\tiface->Name, addr_str);\n\t}\n\n\tlen -= sizeof(struct nd_router_advert);\n\n\tif (len == 0)\n\t\treturn;\n\n\topt_str = (uint8_t *)(msg + sizeof(struct nd_router_advert));\n\n\twhile (len > 0)\n\t{\n\t\tint optlen;\n\t\tstruct nd_opt_prefix_info *pinfo;\n\t\tstruct nd_opt_rdnss_info_local *rdnssinfo;\n\t\tstruct nd_opt_dnssl_info_local *dnsslinfo;\n\t\tstruct nd_opt_mtu *mtu;\n\t\tstruct AdvPrefix *prefix;\n\t\tstruct AdvRDNSS *rdnss;\n\t\tchar prefix_str[INET6_ADDRSTRLEN];\n\t\tchar rdnss_str[INET6_ADDRSTRLEN];\n\t\tchar suffix[256];\n\t\tunsigned int offset, label_len;\n\t\tuint32_t preferred, valid, count;\n\n\t\tif (len < 2)\n\t\t{\n\t\t\tflog(LOG_ERR, \"trailing garbage in RA on %s from %s\",\n\t\t\t\tiface->Name, addr_str);\n\t\t\tbreak;\n\t\t}\n\n\t\toptlen = (opt_str[1] << 3);\n\n\t\tif (optlen == 0)\n\t\t{\n\t\t\tflog(LOG_ERR, \"zero length option in RA on %s from %s\",\n\t\t\t\tiface->Name, addr_str);\n\t\t\tbreak;\n\t\t}\n\t\telse if (optlen > len)\n\t\t{\n\t\t\tflog(LOG_ERR, \"option length greater than total\"\n\t\t\t\t\" length in RA on %s from %s\",\n\t\t\t\tiface->Name, addr_str);\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (*opt_str)\n\t\t{\n\t\tcase ND_OPT_MTU:\n\t\t\tmtu = (struct nd_opt_mtu *)opt_str;\n\n\t\t\tif (iface->AdvLinkMTU && (ntohl(mtu->nd_opt_mtu_mtu) != iface->AdvLinkMTU))\n\t\t\t{\n\t\t\t\tflog(LOG_WARNING, \"our AdvLinkMTU on %s doesn't agree with %s\",\n\t\t\t\t\tiface->Name, addr_str);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ND_OPT_PREFIX_INFORMATION:\n\t\t\tpinfo = (struct nd_opt_prefix_info *) opt_str;\n\t\t\tpreferred = ntohl(pinfo->nd_opt_pi_preferred_time);\n\t\t\tvalid = ntohl(pinfo->nd_opt_pi_valid_time);\n\n\t\t\tprefix = iface->AdvPrefixList;\n\t\t\twhile (prefix)\n\t\t\t{\n\t\t\t\tif (prefix->enabled &&\n\t\t\t\t    (prefix->PrefixLen == pinfo->nd_opt_pi_prefix_len) &&\n\t\t\t\t    addr_match(&prefix->Prefix, &pinfo->nd_opt_pi_prefix,\n\t\t\t\t    \t prefix->PrefixLen))\n\t\t\t\t{\n\t\t\t\t\tprint_addr(&prefix->Prefix, prefix_str);\n\n\t\t\t\t\tif (!prefix->DecrementLifetimesFlag && valid != prefix->AdvValidLifetime)\n\t\t\t\t\t{\n\t\t\t\t\t\tflog(LOG_WARNING, \"our AdvValidLifetime on\"\n\t\t\t\t\t\t \" %s for %s doesn't agree with %s\",\n\t\t\t\t\t\t iface->Name,\n\t\t\t\t\t\t prefix_str,\n\t\t\t\t\t\t addr_str\n\t\t\t\t\t\t );\n\t\t\t\t\t}\n\t\t\t\t\tif (!prefix->DecrementLifetimesFlag && preferred != prefix->AdvPreferredLifetime)\n\t\t\t\t\t{\n\t\t\t\t\t\tflog(LOG_WARNING, \"our AdvPreferredLifetime on\"\n\t\t\t\t\t\t \" %s for %s doesn't agree with %s\",\n\t\t\t\t\t\t iface->Name,\n\t\t\t\t\t\t prefix_str,\n\t\t\t\t\t\t addr_str\n\t\t\t\t\t\t );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tprefix = prefix->next;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ND_OPT_ROUTE_INFORMATION:\n\t\t\t/* not checked: these will very likely vary a lot */\n\t\t\tbreak;\n\t\tcase ND_OPT_SOURCE_LINKADDR:\n\t\t\t/* not checked */\n\t\t\tbreak;\n\t\tcase ND_OPT_TARGET_LINKADDR:\n\t\tcase ND_OPT_REDIRECTED_HEADER:\n\t\t\tflog(LOG_ERR, \"invalid option %d in RA on %s from %s\",\n\t\t\t\t(int)*opt_str, iface->Name, addr_str);\n\t\t\tbreak;\n\t\t/* Mobile IPv6 extensions */\n\t\tcase ND_OPT_RTR_ADV_INTERVAL:\n\t\tcase ND_OPT_HOME_AGENT_INFO:\n\t\t\t/* not checked */\n\t\t\tbreak;\n\t\tcase ND_OPT_RDNSS_INFORMATION:\n\t\t\trdnssinfo = (struct nd_opt_rdnss_info_local *) opt_str;\n\t\t\tcount = rdnssinfo->nd_opt_rdnssi_len;\n\n\t\t\t/* Check the RNDSS addresses received */\n\t\t\tswitch (count) {\n\t\t\t\tcase 7:\n\t\t\t\t\trdnss = iface->AdvRDNSSList;\n\t\t\t\t\tif (!check_rdnss_presence(rdnss, &rdnssinfo->nd_opt_rdnssi_addr3 )) {\n\t\t\t\t\t\t/* no match found in iface->AdvRDNSSList */\n\t\t\t\t\t\tprint_addr(&rdnssinfo->nd_opt_rdnssi_addr3, rdnss_str);\n\t\t\t\t\t\tflog(LOG_WARNING, \"RDNSS address %s received on %s from %s is not advertised by us\",\n\t\t\t\t\t\t\trdnss_str, iface->Name, addr_str);\n\t\t\t\t\t}\n\t\t\t\t\t/* FALLTHROUGH */\n\t\t\t\tcase 5:\n\t\t\t\t\trdnss = iface->AdvRDNSSList;\n\t\t\t\t\tif (!check_rdnss_presence(rdnss, &rdnssinfo->nd_opt_rdnssi_addr2 )) {\n\t\t\t\t\t\t/* no match found in iface->AdvRDNSSList */\n\t\t\t\t\t\tprint_addr(&rdnssinfo->nd_opt_rdnssi_addr2, rdnss_str);\n\t\t\t\t\t\tflog(LOG_WARNING, \"RDNSS address %s received on %s from %s is not advertised by us\",\n\t\t\t\t\t\t\trdnss_str, iface->Name, addr_str);\n\t\t\t\t\t}\n\t\t\t\t\t/* FALLTHROUGH */\n\t\t\t\tcase 3:\n\t\t\t\t\trdnss = iface->AdvRDNSSList;\n\t\t\t\t\tif (!check_rdnss_presence(rdnss, &rdnssinfo->nd_opt_rdnssi_addr1 )) {\n\t\t\t\t\t\t/* no match found in iface->AdvRDNSSList */\n\t\t\t\t\t\tprint_addr(&rdnssinfo->nd_opt_rdnssi_addr1, rdnss_str);\n\t\t\t\t\t\tflog(LOG_WARNING, \"RDNSS address %s received on %s from %s is not advertised by us\",\n\t\t\t\t\t\t\trdnss_str, iface->Name, addr_str);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tflog(LOG_ERR, \"invalid len %i in RDNSS option on %s from %s\",\n\t\t\t\t\t\t\tcount, iface->Name, addr_str);\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase ND_OPT_DNSSL_INFORMATION:\n\t\t\tdnsslinfo = (struct nd_opt_dnssl_info_local *) opt_str;\n\t\t\tsuffix[0] = '\\0';\n\t\t\tfor (offset = 0; offset < (dnsslinfo->nd_opt_dnssli_len-1)*8;) {\n\t\t\t\tlabel_len = dnsslinfo->nd_opt_dnssli_suffixes[offset++];\n\n\t\t\t\tif (label_len == 0) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Ignore empty suffixes. They're\n\t\t\t\t\t * probably just padding...\n\t\t\t\t\t */\n\t\t\t\t\tif (suffix[0] == '\\0')\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (!check_dnssl_presence(iface->AdvDNSSLList, suffix)) {\n\t\t\t\t\t\tflog(LOG_WARNING, \"DNSSL suffix %s received on %s from %s is not advertised by us\",\n\t\t\t\t\t\t\tsuffix, iface->Name, addr_str);\n\t\t\t\t\t}\n\n\t\t\t\t\tsuffix[0] = '\\0';\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * 1) must not overflow int: label + 2, offset + label_len\n\t\t\t\t * 2) last byte of dnssli_suffix must not overflow opt_str + len\n\t\t\t\t */\n\t\t\t\tif ((sizeof(suffix) - strlen(suffix)) < (label_len + 2) ||\n\t\t\t\t    label_len > label_len + 2 ||\n\t\t\t\t    &dnsslinfo->nd_opt_dnssli_suffixes[offset+label_len] - (char*)opt_str >= len ||\n\t\t\t\t    offset + label_len < offset) {\n\t\t\t\t\tflog(LOG_ERR, \"oversized suffix in DNSSL option on %s from %s\",\n\t\t\t\t\t\t\tiface->Name, addr_str);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (suffix[0] != '\\0')\n\t\t\t\t\tstrcat(suffix, \".\");\n\t\t\t\tstrncat(suffix, &dnsslinfo->nd_opt_dnssli_suffixes[offset], label_len);\n\t\t\t\toffset += label_len;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdlog(LOG_DEBUG, 1, \"unknown option %d in RA on %s from %s\",\n\t\t\t\t(int)*opt_str, iface->Name, addr_str);\n\t\t\tbreak;\n\t\t}\n\n\t\tlen -= optlen;\n\t\topt_str += optlen;\n\t}\n}",
        "target": 1
    },
    {
        "func": "process_rs(struct Interface *iface, unsigned char *msg, int len,\n\tstruct sockaddr_in6 *addr)\n{\n\tdouble delay;\n\tdouble next;\n\tstruct timeval tv;\n\tuint8_t *opt_str;\n\n\t/* validation */\n\tlen -= sizeof(struct nd_router_solicit);\n\n\topt_str = (uint8_t *)(msg + sizeof(struct nd_router_solicit));\n\n\twhile (len > 0)\n\t{\n\t\tint optlen;\n\n\t\tif (len < 2)\n\t\t{\n\t\t\tflog(LOG_WARNING, \"trailing garbage in RS\");\n\t\t\treturn;\n\t\t}\n\n\t\toptlen = (opt_str[1] << 3);\n\n\t\tif (optlen == 0)\n\t\t{\n\t\t\tflog(LOG_WARNING, \"zero length option in RS\");\n\t\t\treturn;\n\t\t}\n\t\telse if (optlen > len)\n\t\t{\n\t\t\tflog(LOG_WARNING, \"option length greater than total length in RS\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (*opt_str == ND_OPT_SOURCE_LINKADDR &&\n\t\t    IN6_IS_ADDR_UNSPECIFIED(&addr->sin6_addr)) {\n\t\t\tflog(LOG_WARNING, \"received icmpv6 RS packet with unspecified source address and there is a lladdr option\");\n\t\t\treturn;\n\t\t}\n\n\t\tlen -= optlen;\n\t\topt_str += optlen;\n\t}\n\n\tgettimeofday(&tv, NULL);\n\n\tdelay = MAX_RA_DELAY_TIME * rand() / (RAND_MAX +1.0);\n\n\tif (iface->UnicastOnly) {\n\t\tdlog(LOG_DEBUG, 5, \"random mdelay for %s: %g seconds.\", iface->Name, delay/1000.0);\n\t\tmdelay(delay);\n\t\tsend_ra_forall(iface, &addr->sin6_addr);\n\t}\n\telse if ( timevaldiff(&tv, &iface->last_multicast) / 1000.0 < iface->MinDelayBetweenRAs ) {\n\t\t/* last RA was sent only a few moments ago, don't send another immediately. */\n\t\tnext = iface->MinDelayBetweenRAs - (tv.tv_sec + tv.tv_usec / 1000000.0) + (iface->last_multicast.tv_sec + iface->last_multicast.tv_usec / 1000000.0) + delay/1000.0;\n\t\tiface->next_multicast = next_timeval(next);\n\t}\n\telse {\n\t\t/* no RA sent in a while, send a multicast reply */\n\t\tsend_ra_forall(iface, NULL);\n\t\tnext = rand_between(iface->MinRtrAdvInterval, iface->MaxRtrAdvInterval);\n\t\tiface->next_multicast = next_timeval(next);\n\t}\n}",
        "target": 1
    },
    {
        "func": "static int _assemble_line(FILE *f, char *buffer, int buf_len)\n{\n    char *p = buffer;\n    char *s, *os;\n    int used = 0;\n\n    /* loop broken with a 'break' when a non-'\\\\n' ended line is read */\n\n    D((\"called.\"));\n    for (;;) {\n\tif (used >= buf_len) {\n\t    /* Overflow */\n\t    D((\"_assemble_line: overflow\"));\n\t    return -1;\n\t}\n\tif (fgets(p, buf_len - used, f) == NULL) {\n\t    if (used) {\n\t\t/* Incomplete read */\n\t\treturn -1;\n\t    } else {\n\t\t/* EOF */\n\t\treturn 0;\n\t    }\n\t}\n\n\t/* skip leading spaces --- line may be blank */\n\n\ts = p + strspn(p, \" \\n\\t\");\n\tif (*s && (*s != '#')) {\n\t    os = s;\n\n\t    /*\n\t     * we are only interested in characters before the first '#'\n\t     * character\n\t     */\n\n\t    while (*s && *s != '#')\n\t\t ++s;\n\t    if (*s == '#') {\n\t\t *s = '\\0';\n\t\t used += strlen(os);\n\t\t break;                /* the line has been read */\n\t    }\n\n\t    s = os;\n\n\t    /*\n\t     * Check for backslash by scanning back from the end of\n\t     * the entered line, the '\\n' has been included since\n\t     * normally a line is terminated with this\n\t     * character. fgets() should only return one though!\n\t     */\n\n\t    s += strlen(s);\n\t    while (s > os && ((*--s == ' ') || (*s == '\\t')\n\t\t\t      || (*s == '\\n')));\n\n\t    /* check if it ends with a backslash */\n\t    if (*s == '\\\\') {\n\t\t*s = '\\0';              /* truncate the line here */\n\t\tused += strlen(os);\n\t\tp = s;                  /* there is more ... */\n\t    } else {\n\t\t/* End of the line! */\n\t\tused += strlen(os);\n\t\tbreak;                  /* this is the complete line */\n\t    }\n\n\t} else {\n\t    /* Nothing in this line */\n\t    /* Don't move p         */\n\t}\n    }\n\n    return used;\n}",
        "target": 1
    },
    {
        "func": "static int _expand_arg(pam_handle_t *pamh, char **value)\n{\n  const char *orig=*value, *tmpptr=NULL;\n  char *ptr;       /*\n\t\t    * Sure would be nice to use tmpptr but it needs to be\n\t\t    * a constant so that the compiler will shut up when I\n\t\t    * call pam_getenv and _pam_get_item_byname -- sigh\n\t\t    */\n\n  /* No unexpanded variable can be bigger than BUF_SIZE */\n  char type, tmpval[BUF_SIZE];\n\n  /* I know this shouldn't be hard-coded but it's so much easier this way */\n  char tmp[MAX_ENV];\n\n  D((\"Remember to initialize tmp!\"));\n  memset(tmp, 0, MAX_ENV);\n\n  /*\n   * (possibly non-existent) environment variables can be used as values\n   * by prepending a \"$\" and wrapping in {} (ie: ${HOST}), can escape with \"\\\"\n   * (possibly non-existent) PAM items can be used as values\n   * by prepending a \"@\" and wrapping in {} (ie: @{PAM_RHOST}, can escape\n   *\n   */\n  D((\"Expanding <%s>\",orig));\n  while (*orig) {     /* while there is some input to deal with */\n    if ('\\\\' == *orig) {\n      ++orig;\n      if ('$' != *orig && '@' != *orig) {\n\tD((\"Unrecognized escaped character: <%c> - ignoring\", *orig));\n\tpam_syslog(pamh, LOG_ERR,\n\t\t   \"Unrecognized escaped character: <%c> - ignoring\",\n\t\t   *orig);\n      } else if ((strlen(tmp) + 1) < MAX_ENV) {\n\ttmp[strlen(tmp)] = *orig++;        /* Note the increment */\n      } else {\n\t/* is it really a good idea to try to log this? */\n\tD((\"Variable buffer overflow: <%s> + <%s>\", tmp, tmpptr));\n\tpam_syslog (pamh, LOG_ERR, \"Variable buffer overflow: <%s> + <%s>\",\n\t\t tmp, tmpptr);\n      }\n      continue;\n    }\n    if ('$' == *orig || '@' == *orig) {\n      if ('{' != *(orig+1)) {\n\tD((\"Expandable variables must be wrapped in {}\"\n\t   \" <%s> - ignoring\", orig));\n\tpam_syslog(pamh, LOG_ERR, \"Expandable variables must be wrapped in {}\"\n\t\t \" <%s> - ignoring\", orig);\n\tif ((strlen(tmp) + 1) < MAX_ENV) {\n\t  tmp[strlen(tmp)] = *orig++;        /* Note the increment */\n\t}\n\tcontinue;\n      } else {\n\tD((\"Expandable argument: <%s>\", orig));\n\ttype = *orig;\n\torig+=2;     /* skip the ${ or @{ characters */\n\tptr = strchr(orig, '}');\n\tif (ptr) {\n\t  *ptr++ = '\\0';\n\t} else {\n\t  D((\"Unterminated expandable variable: <%s>\", orig-2));\n\t  pam_syslog(pamh, LOG_ERR,\n\t\t     \"Unterminated expandable variable: <%s>\", orig-2);\n\t  return PAM_ABORT;\n\t}\n\tstrncpy(tmpval, orig, sizeof(tmpval));\n\ttmpval[sizeof(tmpval)-1] = '\\0';\n\torig=ptr;\n\t/*\n\t * so, we know we need to expand tmpval, it is either\n\t * an environment variable or a PAM_ITEM. type will tell us which\n\t */\n\tswitch (type) {\n\n\tcase '$':\n\t  D((\"Expanding env var: <%s>\",tmpval));\n\t  tmpptr = pam_getenv(pamh, tmpval);\n\t  D((\"Expanded to <%s>\", tmpptr));\n\t  break;\n\n\tcase '@':\n\t  D((\"Expanding pam item: <%s>\",tmpval));\n\t  tmpptr = _pam_get_item_byname(pamh, tmpval);\n\t  D((\"Expanded to <%s>\", tmpptr));\n\t  break;\n\n\tdefault:\n\t  D((\"Impossible error, type == <%c>\", type));\n\t  pam_syslog(pamh, LOG_CRIT, \"Impossible error, type == <%c>\", type);\n\t  return PAM_ABORT;\n\t}         /* switch */\n\n\tif (tmpptr) {\n\t  if ((strlen(tmp) + strlen(tmpptr)) < MAX_ENV) {\n\t    strcat(tmp, tmpptr);\n\t  } else {\n\t    /* is it really a good idea to try to log this? */\n\t    D((\"Variable buffer overflow: <%s> + <%s>\", tmp, tmpptr));\n\t    pam_syslog (pamh, LOG_ERR,\n\t\t\t\"Variable buffer overflow: <%s> + <%s>\", tmp, tmpptr);\n\t  }\n\t}\n      }           /* if ('{' != *orig++) */\n    } else {      /* if ( '$' == *orig || '@' == *orig) */\n      if ((strlen(tmp) + 1) < MAX_ENV) {\n\ttmp[strlen(tmp)] = *orig++;        /* Note the increment */\n      } else {\n\t/* is it really a good idea to try to log this? */\n\tD((\"Variable buffer overflow: <%s> + <%s>\", tmp, tmpptr));\n\tpam_syslog(pamh, LOG_ERR,\n\t\t   \"Variable buffer overflow: <%s> + <%s>\", tmp, tmpptr);\n      }\n    }\n  }              /* for (;*orig;) */\n\n  if (strlen(tmp) > strlen(*value)) {\n    free(*value);\n    if ((*value = malloc(strlen(tmp) +1)) == NULL) {\n      D((\"Couldn't malloc %d bytes for expanded var\", strlen(tmp)+1));\n      pam_syslog (pamh, LOG_ERR, \"Couldn't malloc %lu bytes for expanded var\",\n\t       (unsigned long)strlen(tmp)+1);\n      return PAM_BUF_ERR;\n    }\n  }\n  strcpy(*value, tmp);\n  memset(tmp,'\\0',sizeof(tmp));\n  D((\"Exit.\"));\n\n  return PAM_SUCCESS;\n}",
        "target": 1
    },
    {
        "func": "int32_t cli_bcapi_extract_new(struct cli_bc_ctx *ctx, int32_t id)\n{\n    cli_ctx *cctx;\n    int res = -1;\n\n    cli_event_count(EV, BCEV_EXTRACTED);\n    cli_dbgmsg(\"previous tempfile had %u bytes\\n\", ctx->written);\n    if (!ctx->written)\n\treturn 0;\n    if (ctx->ctx && cli_updatelimits(ctx->ctx, ctx->written))\n\treturn -1;\n    ctx->written = 0;\n    lseek(ctx->outfd, 0, SEEK_SET);\n    cli_dbgmsg(\"bytecode: scanning extracted file %s\\n\", ctx->tempfile);\n    cctx = (cli_ctx*)ctx->ctx;\n    if (cctx) {\n\tcli_file_t current = cctx->container_type;\n\tif (ctx->containertype != CL_TYPE_ANY)\n\t    cctx->container_type = ctx->containertype;\n\tres = cli_magic_scandesc(ctx->outfd, cctx);\n\tcctx->container_type = current;\n\tif (res == CL_VIRUS) {\n\t    if (cctx->virname)\n\t\tctx->virname = *cctx->virname;\n\t    ctx->found = 1;\n\t}\n    }\n    if ((cctx && cctx->engine->keeptmp) ||\n\t(ftruncate(ctx->outfd, 0) == -1)) {\n\n\tclose(ctx->outfd);\n\tif (!(cctx && cctx->engine->keeptmp) && ctx->tempfile)\n\t    cli_unlink(ctx->tempfile);\n\tfree(ctx->tempfile);\n\tctx->tempfile = NULL;\n\tctx->outfd = 0;\n    }\n    cli_dbgmsg(\"bytecode: extracting new file with id %u\\n\", id);\n    return res;\n}",
        "target": 1
    },
    {
        "func": "int cli_bytecode_runhook(cli_ctx *cctx, const struct cl_engine *engine, struct cli_bc_ctx *ctx,\n\t\t\t unsigned id, fmap_t *map, const char **virname)\n{\n    const unsigned *hooks = engine->hooks[id - _BC_START_HOOKS];\n    unsigned i, hooks_cnt = engine->hooks_cnt[id - _BC_START_HOOKS];\n    int ret;\n    unsigned executed = 0, breakflag = 0, errorflag = 0;\n\n    cli_dbgmsg(\"Bytecode executing hook id %u (%u hooks)\\n\", id, hooks_cnt);\n    /* restore match counts */\n    cli_bytecode_context_setfile(ctx, map);\n    ctx->hooks.match_counts = ctx->lsigcnt;\n    ctx->hooks.match_offsets = ctx->lsigoff;\n    for (i=0;i < hooks_cnt;i++) {\n\tconst struct cli_bc *bc = &engine->bcs.all_bcs[hooks[i]];\n\tif (bc->lsig) {\n\t    if (!cctx->hook_lsig_matches ||\n\t\t!cli_bitset_test(cctx->hook_lsig_matches, bc->hook_lsig_id-1))\n\t\tcontinue;\n\t    cli_dbgmsg(\"Bytecode: executing bytecode %u (lsig matched)\\n\" , bc->id);\n\t}\n\tcli_bytecode_context_setfuncid(ctx, bc, 0);\n\tret = cli_bytecode_run(&engine->bcs, bc, ctx);\n\texecuted++;\n\tif (ret != CL_SUCCESS) {\n\t    cli_warnmsg(\"Bytecode %u failed to run: %s\\n\", bc->id, cl_strerror(ret));\n\t    errorflag = 1;\n\t    continue;\n\t}\n\tif (ctx->virname) {\n\t    cli_dbgmsg(\"Bytecode found virus: %s\\n\", ctx->virname);\n\t    if (virname)\n\t\t*virname = ctx->virname;\n\t    cli_bytecode_context_clear(ctx);\n\t    return CL_VIRUS;\n\t}\n\tret = cli_bytecode_context_getresult_int(ctx);\n\t/* TODO: use prefix here */\n\tcli_dbgmsg(\"Bytecode %u returned %u\\n\", bc->id, ret);\n\tif (ret == 0xcea5e) {\n\t    cli_dbgmsg(\"Bytecode set BREAK flag in hook!\\n\");\n\t    breakflag = 1;\n\t}\n\tif (!ret) {\n\t    char *tempfile;\n\t    int fd = cli_bytecode_context_getresult_file(ctx, &tempfile);\n\t    if (fd && fd != -1) {\n\t\tif (cctx && cctx->engine->keeptmp)\n\t\t    cli_dbgmsg(\"Bytecode %u unpacked file saved in %s\\n\",\n\t\t\t       bc->id, tempfile);\n\t\telse\n\t\t    cli_dbgmsg(\"Bytecode %u unpacked file\\n\", bc->id);\n\t\tlseek(fd, 0, SEEK_SET);\n\t\tcli_dbgmsg(\"***** Scanning unpacked file ******\\n\");\n\t\tret = cli_magic_scandesc(fd, cctx);\n\t\tif (!cctx || !cctx->engine->keeptmp)\n\t\t    if (ftruncate(fd, 0) == -1)\n\t\t\tcli_dbgmsg(\"ftruncate failed on %d\\n\", fd);\n\t\tclose(fd);\n\t\tif (!cctx || !cctx->engine->keeptmp) {\n\t\t    if (tempfile && cli_unlink(tempfile))\n\t\t\tret = CL_EUNLINK;\n\t\t}\n\t\tfree(tempfile);\n\t\tif (ret != CL_CLEAN) {\n\t\t    if (ret == CL_VIRUS)\n\t\t\tcli_dbgmsg(\"Scanning unpacked file by bytecode %u found a virus\\n\", bc->id);\n\t\t    cli_bytecode_context_clear(ctx);\n\t\t    return ret;\n\t\t}\n\t\tcli_bytecode_context_reset(ctx);\n\t\tcontinue;\n\t    }\n\t}\n\tcli_bytecode_context_reset(ctx);\n    }\n    if (executed)\n\tcli_dbgmsg(\"Bytecode: executed %u bytecodes for this hook\\n\", executed);\n    else\n\tcli_dbgmsg(\"Bytecode: no logical signature matched, no bytecode executed\\n\");\n    if (errorflag && cctx && cctx->engine->bytecode_mode == CL_BYTECODE_MODE_TEST)\n\treturn CL_EBYTECODE_TESTFAIL;\n    return breakflag ? CL_BREAK : CL_CLEAN;\n}",
        "target": 1
    },
    {
        "func": "theme_adium_append_message (EmpathyChatView *view,\n\t\t\t    EmpathyMessage  *msg)\n{\n\tEmpathyThemeAdium     *theme = EMPATHY_THEME_ADIUM (view);\n\tEmpathyThemeAdiumPriv *priv = GET_PRIV (theme);\n\tEmpathyContact        *sender;\n\tTpMessage             *tp_msg;\n\tTpAccount             *account;\n\tgchar                 *body_escaped;\n\tconst gchar           *name;\n\tconst gchar           *contact_id;\n\tEmpathyAvatar         *avatar;\n\tconst gchar           *avatar_filename = NULL;\n\tgint64                 timestamp;\n\tconst gchar           *html = NULL;\n\tconst gchar           *func;\n\tconst gchar           *service_name;\n\tGString               *message_classes = NULL;\n\tgboolean               is_backlog;\n\tgboolean               consecutive;\n\tgboolean               action;\n\n\tif (priv->pages_loading != 0) {\n\t\tqueue_item (&priv->message_queue, QUEUED_MESSAGE, msg, NULL);\n\t\treturn;\n\t}\n\n\t/* Get information */\n\tsender = empathy_message_get_sender (msg);\n\taccount = empathy_contact_get_account (sender);\n\tservice_name = empathy_protocol_name_to_display_name\n\t\t(tp_account_get_protocol (account));\n\tif (service_name == NULL)\n\t\tservice_name = tp_account_get_protocol (account);\n\ttimestamp = empathy_message_get_timestamp (msg);\n\tbody_escaped = theme_adium_parse_body (theme,\n\t\tempathy_message_get_body (msg),\n\t\tempathy_message_get_token (msg));\n\tname = empathy_contact_get_logged_alias (sender);\n\tcontact_id = empathy_contact_get_id (sender);\n\taction = (empathy_message_get_tptype (msg) == TP_CHANNEL_TEXT_MESSAGE_TYPE_ACTION);\n\n\t/* If this is a /me probably */\n\tif (action) {\n\t\tgchar *str;\n\n\t\tif (priv->data->version >= 4 || !priv->data->custom_template) {\n\t\t\tstr = g_strdup_printf (\"<span class='actionMessageUserName'>%s</span>\"\n\t\t\t\t\t       \"<span class='actionMessageBody'>%s</span>\",\n\t\t\t\t\t       name, body_escaped);\n\t\t} else {\n\t\t\tstr = g_strdup_printf (\"*%s*\", body_escaped);\n\t\t}\n\t\tg_free (body_escaped);\n\t\tbody_escaped = str;\n\t}\n\n\t/* Get the avatar filename, or a fallback */\n\tavatar = empathy_contact_get_avatar (sender);\n\tif (avatar) {\n\t\tavatar_filename = avatar->filename;\n\t}\n\tif (!avatar_filename) {\n\t\tif (empathy_contact_is_user (sender)) {\n\t\t\tavatar_filename = priv->data->default_outgoing_avatar_filename;\n\t\t} else {\n\t\t\tavatar_filename = priv->data->default_incoming_avatar_filename;\n\t\t}\n\t\tif (!avatar_filename) {\n\t\t\tif (!priv->data->default_avatar_filename) {\n\t\t\t\tpriv->data->default_avatar_filename =\n\t\t\t\t\tempathy_filename_from_icon_name (EMPATHY_IMAGE_AVATAR_DEFAULT,\n\t\t\t\t\t\t\t\t\t GTK_ICON_SIZE_DIALOG);\n\t\t\t}\n\t\t\tavatar_filename = priv->data->default_avatar_filename;\n\t\t}\n\t}\n\n\t/* We want to join this message with the last one if\n\t * - senders are the same contact,\n\t * - last message was recieved recently,\n\t * - last message and this message both are/aren't backlog, and\n\t * - DisableCombineConsecutive is not set in theme's settings */\n\tis_backlog = empathy_message_is_backlog (msg);\n\tconsecutive = empathy_contact_equal (priv->last_contact, sender) &&\n\t\t(timestamp - priv->last_timestamp < MESSAGE_JOIN_PERIOD) &&\n\t\t(is_backlog == priv->last_is_backlog) &&\n\t\t!tp_asv_get_boolean (priv->data->info,\n\t\t\t\t     \"DisableCombineConsecutive\", NULL);\n\n\t/* Define message classes */\n\tmessage_classes = g_string_new (\"message\");\n\tif (!priv->has_focus && !is_backlog) {\n\t\tif (!priv->has_unread_message) {\n\t\t\tg_string_append (message_classes, \" firstFocus\");\n\t\t\tpriv->has_unread_message = TRUE;\n\t\t}\n\t\tg_string_append (message_classes, \" focus\");\n\t}\n\tif (is_backlog) {\n\t\tg_string_append (message_classes, \" history\");\n\t}\n\tif (consecutive) {\n\t\tg_string_append (message_classes, \" consecutive\");\n\t}\n\tif (empathy_contact_is_user (sender)) {\n\t\tg_string_append (message_classes, \" outgoing\");\n\t} else {\n\t\tg_string_append (message_classes, \" incoming\");\n\t}\n\tif (empathy_message_should_highlight (msg)) {\n\t\tg_string_append (message_classes, \" mention\");\n\t}\n\tif (empathy_message_get_tptype (msg) == TP_CHANNEL_TEXT_MESSAGE_TYPE_AUTO_REPLY) {\n\t\tg_string_append (message_classes, \" autoreply\");\n\t}\n\tif (action) {\n\t\tg_string_append (message_classes, \" action\");\n\t}\n\t/* FIXME: other classes:\n\t * status - the message is a status change\n\t * event - the message is a notification of something happening\n\t *         (for example, encryption being turned on)\n\t * %status% - See %status% in theme_adium_append_html ()\n\t */\n\n\t/* This is slightly a hack, but it's the only way to add\n\t * arbitrary data to messages in the HTML. We add another\n\t * class called \"x-empathy-message-id-*\" to the message. This\n\t * way, we can remove the unread marker for this specific\n\t * message later. */\n\ttp_msg = empathy_message_get_tp_message (msg);\n\tif (tp_msg != NULL) {\n\t\tguint32 id;\n\t\tgboolean valid;\n\n\t\tid = tp_message_get_pending_message_id (tp_msg, &valid);\n\t\tif (valid) {\n\t\t\tg_string_append_printf (message_classes,\n\t\t\t    \" x-empathy-message-id-%u\", id);\n\t\t}\n\t}\n\n\t/* Define javascript function to use */\n\tif (consecutive) {\n\t\tfunc = priv->allow_scrolling ? \"appendNextMessage\" : \"appendNextMessageNoScroll\";\n\t} else {\n\t\tfunc = priv->allow_scrolling ? \"appendMessage\" : \"appendMessageNoScroll\";\n\t}\n\n\tif (empathy_contact_is_user (sender)) {\n\t\t/* out */\n\t\tif (is_backlog) {\n\t\t\t/* context */\n\t\t\thtml = consecutive ? priv->data->out_nextcontext_html : priv->data->out_context_html;\n\t\t} else {\n\t\t\t/* content */\n\t\t\thtml = consecutive ? priv->data->out_nextcontent_html : priv->data->out_content_html;\n\t\t}\n\n\t\t/* remove all the unread marks when we are sending a message */\n\t\ttheme_adium_remove_all_focus_marks (theme);\n\t} else {\n\t\t/* in */\n\t\tif (is_backlog) {\n\t\t\t/* context */\n\t\t\thtml = consecutive ? priv->data->in_nextcontext_html : priv->data->in_context_html;\n\t\t} else {\n\t\t\t/* content */\n\t\t\thtml = consecutive ? priv->data->in_nextcontent_html : priv->data->in_content_html;\n\t\t}\n\t}\n\n\ttheme_adium_append_html (theme, func, html, body_escaped,\n\t\t\t\t avatar_filename, name, contact_id,\n\t\t\t\t service_name, message_classes->str,\n\t\t\t\t timestamp, is_backlog, empathy_contact_is_user (sender));\n\n\t/* Keep the sender of the last displayed message */\n\tif (priv->last_contact) {\n\t\tg_object_unref (priv->last_contact);\n\t}\n\tpriv->last_contact = g_object_ref (sender);\n\tpriv->last_timestamp = timestamp;\n\tpriv->last_is_backlog = is_backlog;\n\n\tg_free (body_escaped);\n\tg_string_free (message_classes, TRUE);\n}",
        "target": 1
    },
    {
        "func": "static int jpc_cox_getcompparms(jpc_ms_t *ms, jpc_cstate_t *cstate,\n  jas_stream_t *in, int prtflag, jpc_coxcp_t *compparms)\n{\n\tuint_fast8_t tmp;\n\tint i;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tms = 0;\n\tcstate = 0;\n\n\tif (jpc_getuint8(in, &compparms->numdlvls) ||\n\t  jpc_getuint8(in, &compparms->cblkwidthval) ||\n\t  jpc_getuint8(in, &compparms->cblkheightval) ||\n\t  jpc_getuint8(in, &compparms->cblksty) ||\n\t  jpc_getuint8(in, &compparms->qmfbid)) {\n\t\treturn -1;\n\t}\n\tcompparms->numrlvls = compparms->numdlvls + 1;\n\tif (prtflag) {\n\t\tfor (i = 0; i < compparms->numrlvls; ++i) {\n\t\t\tif (jpc_getuint8(in, &tmp)) {\n\t\t\t\tjpc_cox_destroycompparms(compparms);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tcompparms->rlvls[i].parwidthval = tmp & 0xf;\n\t\t\tcompparms->rlvls[i].parheightval = (tmp >> 4) & 0xf;\n\t\t}\n/* Sigh.  This bit should be in the same field in both COC and COD mrk segs. */\ncompparms->csty |= JPC_COX_PRT;\n\t} else {\n\t}\n\tif (jas_stream_eof(in)) {\n\t\tjpc_cox_destroycompparms(compparms);\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static int jpc_crg_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_crg_t *crg = &ms->parms.crg;\n\tjpc_crgcomp_t *comp;\n\tuint_fast16_t compno;\n\tcrg->numcomps = cstate->numcomps;\n\tif (!(crg->comps = jas_alloc2(cstate->numcomps, sizeof(uint_fast16_t)))) {\n\t\treturn -1;\n\t}\n\tfor (compno = 0, comp = crg->comps; compno < cstate->numcomps;\n\t  ++compno, ++comp) {\n\t\tif (jpc_getuint16(in, &comp->hoff) ||\n\t\t  jpc_getuint16(in, &comp->voff)) {\n\t\t\tjpc_crg_destroyparms(ms);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "theme_adium_append_message (EmpathyChatView *view,\n\t\t\t    EmpathyMessage  *msg)\n{\n\tEmpathyThemeAdium     *theme = EMPATHY_THEME_ADIUM (view);\n\tEmpathyThemeAdiumPriv *priv = GET_PRIV (theme);\n\tEmpathyContact        *sender;\n\tTpMessage             *tp_msg;\n\tTpAccount             *account;\n\tgchar                 *body_escaped, *name_escaped;\n\tconst gchar           *name;\n\tconst gchar           *contact_id;\n\tEmpathyAvatar         *avatar;\n\tconst gchar           *avatar_filename = NULL;\n\tgint64                 timestamp;\n\tconst gchar           *html = NULL;\n\tconst gchar           *func;\n\tconst gchar           *service_name;\n\tGString               *message_classes = NULL;\n\tgboolean               is_backlog;\n\tgboolean               consecutive;\n\tgboolean               action;\n\n\tif (priv->pages_loading != 0) {\n\t\tqueue_item (&priv->message_queue, QUEUED_MESSAGE, msg, NULL);\n\t\treturn;\n\t}\n\n\t/* Get information */\n\tsender = empathy_message_get_sender (msg);\n\taccount = empathy_contact_get_account (sender);\n\tservice_name = empathy_protocol_name_to_display_name\n\t\t(tp_account_get_protocol (account));\n\tif (service_name == NULL)\n\t\tservice_name = tp_account_get_protocol (account);\n\ttimestamp = empathy_message_get_timestamp (msg);\n\tbody_escaped = theme_adium_parse_body (theme,\n\t\tempathy_message_get_body (msg),\n\t\tempathy_message_get_token (msg));\n\tname = empathy_contact_get_logged_alias (sender);\n\tcontact_id = empathy_contact_get_id (sender);\n\taction = (empathy_message_get_tptype (msg) == TP_CHANNEL_TEXT_MESSAGE_TYPE_ACTION);\n\n\t/* If this is a /me probably */\n\tif (action) {\n\t\tgchar *str;\n\n\t\tif (priv->data->version >= 4 || !priv->data->custom_template) {\n\t\t\tstr = g_strdup_printf (\"<span class='actionMessageUserName'>%s</span>\"\n\t\t\t\t\t       \"<span class='actionMessageBody'>%s</span>\",\n\t\t\t\t\t       name, body_escaped);\n\t\t} else {\n\t\t\tstr = g_strdup_printf (\"*%s*\", body_escaped);\n\t\t}\n\t\tg_free (body_escaped);\n\t\tbody_escaped = str;\n\t}\n\n\t/* Get the avatar filename, or a fallback */\n\tavatar = empathy_contact_get_avatar (sender);\n\tif (avatar) {\n\t\tavatar_filename = avatar->filename;\n\t}\n\tif (!avatar_filename) {\n\t\tif (empathy_contact_is_user (sender)) {\n\t\t\tavatar_filename = priv->data->default_outgoing_avatar_filename;\n\t\t} else {\n\t\t\tavatar_filename = priv->data->default_incoming_avatar_filename;\n\t\t}\n\t\tif (!avatar_filename) {\n\t\t\tif (!priv->data->default_avatar_filename) {\n\t\t\t\tpriv->data->default_avatar_filename =\n\t\t\t\t\tempathy_filename_from_icon_name (EMPATHY_IMAGE_AVATAR_DEFAULT,\n\t\t\t\t\t\t\t\t\t GTK_ICON_SIZE_DIALOG);\n\t\t\t}\n\t\t\tavatar_filename = priv->data->default_avatar_filename;\n\t\t}\n\t}\n\n\t/* We want to join this message with the last one if\n\t * - senders are the same contact,\n\t * - last message was recieved recently,\n\t * - last message and this message both are/aren't backlog, and\n\t * - DisableCombineConsecutive is not set in theme's settings */\n\tis_backlog = empathy_message_is_backlog (msg);\n\tconsecutive = empathy_contact_equal (priv->last_contact, sender) &&\n\t\t(timestamp - priv->last_timestamp < MESSAGE_JOIN_PERIOD) &&\n\t\t(is_backlog == priv->last_is_backlog) &&\n\t\t!tp_asv_get_boolean (priv->data->info,\n\t\t\t\t     \"DisableCombineConsecutive\", NULL);\n\n\t/* Define message classes */\n\tmessage_classes = g_string_new (\"message\");\n\tif (!priv->has_focus && !is_backlog) {\n\t\tif (!priv->has_unread_message) {\n\t\t\tg_string_append (message_classes, \" firstFocus\");\n\t\t\tpriv->has_unread_message = TRUE;\n\t\t}\n\t\tg_string_append (message_classes, \" focus\");\n\t}\n\tif (is_backlog) {\n\t\tg_string_append (message_classes, \" history\");\n\t}\n\tif (consecutive) {\n\t\tg_string_append (message_classes, \" consecutive\");\n\t}\n\tif (empathy_contact_is_user (sender)) {\n\t\tg_string_append (message_classes, \" outgoing\");\n\t} else {\n\t\tg_string_append (message_classes, \" incoming\");\n\t}\n\tif (empathy_message_should_highlight (msg)) {\n\t\tg_string_append (message_classes, \" mention\");\n\t}\n\tif (empathy_message_get_tptype (msg) == TP_CHANNEL_TEXT_MESSAGE_TYPE_AUTO_REPLY) {\n\t\tg_string_append (message_classes, \" autoreply\");\n\t}\n\tif (action) {\n\t\tg_string_append (message_classes, \" action\");\n\t}\n\t/* FIXME: other classes:\n\t * status - the message is a status change\n\t * event - the message is a notification of something happening\n\t *         (for example, encryption being turned on)\n\t * %status% - See %status% in theme_adium_append_html ()\n\t */\n\n\t/* This is slightly a hack, but it's the only way to add\n\t * arbitrary data to messages in the HTML. We add another\n\t * class called \"x-empathy-message-id-*\" to the message. This\n\t * way, we can remove the unread marker for this specific\n\t * message later. */\n\ttp_msg = empathy_message_get_tp_message (msg);\n\tif (tp_msg != NULL) {\n\t\tguint32 id;\n\t\tgboolean valid;\n\n\t\tid = tp_message_get_pending_message_id (tp_msg, &valid);\n\t\tif (valid) {\n\t\t\tg_string_append_printf (message_classes,\n\t\t\t    \" x-empathy-message-id-%u\", id);\n\t\t}\n\t}\n\n\t/* Define javascript function to use */\n\tif (consecutive) {\n\t\tfunc = priv->allow_scrolling ? \"appendNextMessage\" : \"appendNextMessageNoScroll\";\n\t} else {\n\t\tfunc = priv->allow_scrolling ? \"appendMessage\" : \"appendMessageNoScroll\";\n\t}\n\n\tif (empathy_contact_is_user (sender)) {\n\t\t/* out */\n\t\tif (is_backlog) {\n\t\t\t/* context */\n\t\t\thtml = consecutive ? priv->data->out_nextcontext_html : priv->data->out_context_html;\n\t\t} else {\n\t\t\t/* content */\n\t\t\thtml = consecutive ? priv->data->out_nextcontent_html : priv->data->out_content_html;\n\t\t}\n\n\t\t/* remove all the unread marks when we are sending a message */\n\t\ttheme_adium_remove_all_focus_marks (theme);\n\t} else {\n\t\t/* in */\n\t\tif (is_backlog) {\n\t\t\t/* context */\n\t\t\thtml = consecutive ? priv->data->in_nextcontext_html : priv->data->in_context_html;\n\t\t} else {\n\t\t\t/* content */\n\t\t\thtml = consecutive ? priv->data->in_nextcontent_html : priv->data->in_content_html;\n\t\t}\n\t}\n\n\tname_escaped = g_markup_escape_text (name, -1);\n\n\ttheme_adium_append_html (theme, func, html, body_escaped,\n\t\t\t\t avatar_filename, name_escaped, contact_id,\n\t\t\t\t service_name, message_classes->str,\n\t\t\t\t timestamp, is_backlog, empathy_contact_is_user (sender));\n\n\t/* Keep the sender of the last displayed message */\n\tif (priv->last_contact) {\n\t\tg_object_unref (priv->last_contact);\n\t}\n\tpriv->last_contact = g_object_ref (sender);\n\tpriv->last_timestamp = timestamp;\n\tpriv->last_is_backlog = is_backlog;\n\n\tg_free (body_escaped);\n\tg_free (name_escaped);\n\tg_string_free (message_classes, TRUE);\n}",
        "target": 1
    },
    {
        "func": "tor_tls_context_init_one(tor_tls_context_t **ppcontext,\n                         crypto_pk_env_t *identity,\n                         unsigned int key_lifetime)\n{\n  tor_tls_context_t *new_ctx = tor_tls_context_new(identity,\n                                                   key_lifetime);\n  tor_tls_context_t *old_ctx = *ppcontext;\n\n  if (new_ctx != NULL) {\n    *ppcontext = new_ctx;\n\n    /* Free the old context if one existed. */\n    if (old_ctx != NULL) {\n      /* This is safe even if there are open connections: we reference-\n       * count tor_tls_context_t objects. */\n      tor_tls_context_decref(old_ctx);\n    }\n  }\n\n  return ((new_ctx != NULL) ? 0 : -1);\n}",
        "target": 1
    },
    {
        "func": "tor_tls_context_new(crypto_pk_env_t *identity, unsigned int key_lifetime)\n{\n  crypto_pk_env_t *rsa = NULL;\n  EVP_PKEY *pkey = NULL;\n  tor_tls_context_t *result = NULL;\n  X509 *cert = NULL, *idcert = NULL;\n  char *nickname = NULL, *nn2 = NULL;\n\n  tor_tls_init();\n  nickname = crypto_random_hostname(8, 20, \"www.\", \".net\");\n  nn2 = crypto_random_hostname(8, 20, \"www.\", \".net\");\n\n  /* Generate short-term RSA key. */\n  if (!(rsa = crypto_new_pk_env()))\n    goto error;\n  if (crypto_pk_generate_key(rsa)<0)\n    goto error;\n  /* Create certificate signed by identity key. */\n  cert = tor_tls_create_certificate(rsa, identity, nickname, nn2,\n                                    key_lifetime);\n  /* Create self-signed certificate for identity key. */\n  idcert = tor_tls_create_certificate(identity, identity, nn2, nn2,\n                                      IDENTITY_CERT_LIFETIME);\n  if (!cert || !idcert) {\n    log(LOG_WARN, LD_CRYPTO, \"Error creating certificate\");\n    goto error;\n  }\n\n  result = tor_malloc_zero(sizeof(tor_tls_context_t));\n  result->refcnt = 1;\n  result->my_cert = X509_dup(cert);\n  result->my_id_cert = X509_dup(idcert);\n  result->key = crypto_pk_dup_key(rsa);\n\n#ifdef EVERYONE_HAS_AES\n  /* Tell OpenSSL to only use TLS1 */\n  if (!(result->ctx = SSL_CTX_new(TLSv1_method())))\n    goto error;\n#else\n  /* Tell OpenSSL to use SSL3 or TLS1 but not SSL2. */\n  if (!(result->ctx = SSL_CTX_new(SSLv23_method())))\n    goto error;\n  SSL_CTX_set_options(result->ctx, SSL_OP_NO_SSLv2);\n#endif\n  SSL_CTX_set_options(result->ctx, SSL_OP_SINGLE_DH_USE);\n\n#ifdef SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION\n  SSL_CTX_set_options(result->ctx,\n                      SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION);\n#endif\n  /* Yes, we know what we are doing here.  No, we do not treat a renegotiation\n   * as authenticating any earlier-received data.\n   */\n  if (use_unsafe_renegotiation_op) {\n    SSL_CTX_set_options(result->ctx,\n                        SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION);\n  }\n  /* Don't actually allow compression; it uses ram and time, but the data\n   * we transmit is all encrypted anyway. */\n  if (result->ctx->comp_methods)\n    result->ctx->comp_methods = NULL;\n#ifdef SSL_MODE_RELEASE_BUFFERS\n  SSL_CTX_set_mode(result->ctx, SSL_MODE_RELEASE_BUFFERS);\n#endif\n  if (cert && !SSL_CTX_use_certificate(result->ctx,cert))\n    goto error;\n  X509_free(cert); /* We just added a reference to cert. */\n  cert=NULL;\n  if (idcert) {\n    X509_STORE *s = SSL_CTX_get_cert_store(result->ctx);\n    tor_assert(s);\n    X509_STORE_add_cert(s, idcert);\n    X509_free(idcert); /* The context now owns the reference to idcert */\n    idcert = NULL;\n  }\n  SSL_CTX_set_session_cache_mode(result->ctx, SSL_SESS_CACHE_OFF);\n  tor_assert(rsa);\n  if (!(pkey = _crypto_pk_env_get_evp_pkey(rsa,1)))\n    goto error;\n  if (!SSL_CTX_use_PrivateKey(result->ctx, pkey))\n    goto error;\n  EVP_PKEY_free(pkey);\n  pkey = NULL;\n  if (!SSL_CTX_check_private_key(result->ctx))\n    goto error;\n  {\n    crypto_dh_env_t *dh = crypto_dh_new(DH_TYPE_TLS);\n    SSL_CTX_set_tmp_dh(result->ctx, _crypto_dh_env_get_dh(dh));\n    crypto_dh_free(dh);\n  }\n  SSL_CTX_set_verify(result->ctx, SSL_VERIFY_PEER,\n                     always_accept_verify_cb);\n  /* let us realloc bufs that we're writing from */\n  SSL_CTX_set_mode(result->ctx, SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER);\n\n  if (rsa)\n    crypto_free_pk_env(rsa);\n  tor_free(nickname);\n  tor_free(nn2);\n  return result;\n\n error:\n  tls_log_errors(NULL, LOG_WARN, \"creating TLS context\");\n  tor_free(nickname);\n  tor_free(nn2);\n  if (pkey)\n    EVP_PKEY_free(pkey);\n  if (rsa)\n    crypto_free_pk_env(rsa);\n  if (result)\n    tor_tls_context_decref(result);\n  if (cert)\n    X509_free(cert);\n  if (idcert)\n    X509_free(idcert);\n  return NULL;\n}",
        "target": 1
    },
    {
        "func": "tor_tls_context_init(int is_public_server,\n                     crypto_pk_env_t *client_identity,\n                     crypto_pk_env_t *server_identity,\n                     unsigned int key_lifetime)\n{\n  int rv1 = 0;\n  int rv2 = 0;\n\n  if (is_public_server) {\n    tor_tls_context_t *new_ctx;\n    tor_tls_context_t *old_ctx;\n\n    tor_assert(server_identity != NULL);\n\n    rv1 = tor_tls_context_init_one(&server_tls_context,\n                                   server_identity,\n                                   key_lifetime);\n\n    if (rv1 >= 0) {\n      new_ctx = server_tls_context;\n      tor_tls_context_incref(new_ctx);\n      old_ctx = client_tls_context;\n      client_tls_context = new_ctx;\n\n      if (old_ctx != NULL) {\n        tor_tls_context_decref(old_ctx);\n      }\n    }\n  } else {\n    if (server_identity != NULL) {\n      rv1 = tor_tls_context_init_one(&server_tls_context,\n                                     server_identity,\n                                     key_lifetime);\n    } else {\n      tor_tls_context_t *old_ctx = server_tls_context;\n      server_tls_context = NULL;\n\n      if (old_ctx != NULL) {\n        tor_tls_context_decref(old_ctx);\n      }\n    }\n\n    rv2 = tor_tls_context_init_one(&client_tls_context,\n                                   client_identity,\n                                   key_lifetime);\n  }\n\n  return rv1 < rv2 ? rv1 : rv2;\n}",
        "target": 1
    },
    {
        "func": "set_routerstatus_from_routerinfo(routerstatus_t *rs,\n                                 routerinfo_t *ri, time_t now,\n                                 int naming, int listbadexits,\n                                 int listbaddirs, int vote_on_hsdirs)\n{\n  int unstable_version =\n    !tor_version_as_new_as(ri->platform,\"0.1.1.16-rc-cvs\");\n  memset(rs, 0, sizeof(routerstatus_t));\n\n  rs->is_authority =\n    router_digest_is_trusted_dir(ri->cache_info.identity_digest);\n\n  /* Already set by compute_performance_thresholds. */\n  rs->is_exit = ri->is_exit;\n  rs->is_stable = ri->is_stable =\n    router_is_active(ri, now) &&\n    !dirserv_thinks_router_is_unreliable(now, ri, 1, 0) &&\n    !unstable_version;\n  rs->is_fast = ri->is_fast =\n    router_is_active(ri, now) &&\n    !dirserv_thinks_router_is_unreliable(now, ri, 0, 1);\n  rs->is_running = ri->is_running; /* computed above */\n\n  if (naming) {\n    uint32_t name_status = dirserv_get_name_status(\n                         ri->cache_info.identity_digest, ri->nickname);\n    rs->is_named = (naming && (name_status & FP_NAMED)) ? 1 : 0;\n    rs->is_unnamed = (naming && (name_status & FP_UNNAMED)) ? 1 : 0;\n  }\n  rs->is_valid = ri->is_valid;\n\n  if (rs->is_fast &&\n      (router_get_advertised_bandwidth(ri) >= BANDWIDTH_TO_GUARANTEE_GUARD ||\n       router_get_advertised_bandwidth(ri) >=\n                              MIN(guard_bandwidth_including_exits,\n                                  guard_bandwidth_excluding_exits))) {\n    long tk = rep_hist_get_weighted_time_known(\n                                      ri->cache_info.identity_digest, now);\n    double wfu = rep_hist_get_weighted_fractional_uptime(\n                                      ri->cache_info.identity_digest, now);\n    rs->is_possible_guard = (wfu >= guard_wfu && tk >= guard_tk) ? 1 : 0;\n  } else {\n    rs->is_possible_guard = 0;\n  }\n  rs->is_bad_directory = listbaddirs && ri->is_bad_directory;\n  rs->is_bad_exit = listbadexits && ri->is_bad_exit;\n  ri->is_hs_dir = dirserv_thinks_router_is_hs_dir(ri, now);\n  rs->is_hs_dir = vote_on_hsdirs && ri->is_hs_dir;\n  rs->is_v2_dir = ri->dir_port != 0;\n\n  if (!strcasecmp(ri->nickname, UNNAMED_ROUTER_NICKNAME))\n    rs->is_named = rs->is_unnamed = 0;\n\n  rs->published_on = ri->cache_info.published_on;\n  memcpy(rs->identity_digest, ri->cache_info.identity_digest, DIGEST_LEN);\n  memcpy(rs->descriptor_digest, ri->cache_info.signed_descriptor_digest,\n         DIGEST_LEN);\n  rs->addr = ri->addr;\n  strlcpy(rs->nickname, ri->nickname, sizeof(rs->nickname));\n  rs->or_port = ri->or_port;\n  rs->dir_port = ri->dir_port;\n}",
        "target": 1
    },
    {
        "func": "set_routerstatus_from_routerinfo(routerstatus_t *rs,\n                                 routerinfo_t *ri, time_t now,\n                                 int naming, int listbadexits,\n                                 int listbaddirs, int vote_on_hsdirs)\n{\n  int unstable_version =\n    !tor_version_as_new_as(ri->platform,\"0.1.1.16-rc-cvs\");\n  memset(rs, 0, sizeof(routerstatus_t));\n\n  rs->is_authority =\n    router_digest_is_trusted_dir(ri->cache_info.identity_digest);\n\n  /* Already set by compute_performance_thresholds. */\n  rs->is_exit = ri->is_exit;\n  rs->is_stable = ri->is_stable =\n    router_is_active(ri, now) &&\n    !dirserv_thinks_router_is_unreliable(now, ri, 1, 0) &&\n    !unstable_version;\n  rs->is_fast = ri->is_fast =\n    router_is_active(ri, now) &&\n    !dirserv_thinks_router_is_unreliable(now, ri, 0, 1);\n  rs->is_running = ri->is_running; /* computed above */\n\n  if (naming) {\n    uint32_t name_status = dirserv_get_name_status(\n                         ri->cache_info.identity_digest, ri->nickname);\n    rs->is_named = (naming && (name_status & FP_NAMED)) ? 1 : 0;\n    rs->is_unnamed = (naming && (name_status & FP_UNNAMED)) ? 1 : 0;\n  }\n  rs->is_valid = ri->is_valid;\n\n  if (rs->is_fast &&\n      (router_get_advertised_bandwidth(ri) >= BANDWIDTH_TO_GUARANTEE_GUARD ||\n       router_get_advertised_bandwidth(ri) >=\n                              MIN(guard_bandwidth_including_exits,\n                                  guard_bandwidth_excluding_exits)) &&\n      is_router_version_good_for_possible_guard(ri->platform)) {\n    long tk = rep_hist_get_weighted_time_known(\n                                      ri->cache_info.identity_digest, now);\n    double wfu = rep_hist_get_weighted_fractional_uptime(\n                                      ri->cache_info.identity_digest, now);\n    rs->is_possible_guard = (wfu >= guard_wfu && tk >= guard_tk) ? 1 : 0;\n  } else {\n    rs->is_possible_guard = 0;\n  }\n  rs->is_bad_directory = listbaddirs && ri->is_bad_directory;\n  rs->is_bad_exit = listbadexits && ri->is_bad_exit;\n  ri->is_hs_dir = dirserv_thinks_router_is_hs_dir(ri, now);\n  rs->is_hs_dir = vote_on_hsdirs && ri->is_hs_dir;\n  rs->is_v2_dir = ri->dir_port != 0;\n\n  if (!strcasecmp(ri->nickname, UNNAMED_ROUTER_NICKNAME))\n    rs->is_named = rs->is_unnamed = 0;\n\n  rs->published_on = ri->cache_info.published_on;\n  memcpy(rs->identity_digest, ri->cache_info.identity_digest, DIGEST_LEN);\n  memcpy(rs->descriptor_digest, ri->cache_info.signed_descriptor_digest,\n         DIGEST_LEN);\n  rs->addr = ri->addr;\n  strlcpy(rs->nickname, ri->nickname, sizeof(rs->nickname));\n  rs->or_port = ri->or_port;\n  rs->dir_port = ri->dir_port;\n}",
        "target": 1
    },
    {
        "func": "command_process_create_cell(cell_t *cell, or_connection_t *conn)\n{\n  or_circuit_t *circ;\n  int id_is_high;\n\n  if (we_are_hibernating()) {\n    log_info(LD_OR,\n             \"Received create cell but we're shutting down. Sending back \"\n             \"destroy.\");\n    connection_or_send_destroy(cell->circ_id, conn,\n                               END_CIRC_REASON_HIBERNATING);\n    return;\n  }\n\n  if (!server_mode(get_options())) {\n    log_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,\n           \"Received create cell (type %d) from %s:%d, but we're a client. \"\n           \"Sending back a destroy.\",\n           (int)cell->command, conn->_base.address, conn->_base.port);\n    connection_or_send_destroy(cell->circ_id, conn,\n                               END_CIRC_REASON_TORPROTOCOL);\n    return;\n  }\n\n  /* If the high bit of the circuit ID is not as expected, close the\n   * circ. */\n  id_is_high = cell->circ_id & (1<<15);\n  if ((id_is_high && conn->circ_id_type == CIRC_ID_TYPE_HIGHER) ||\n      (!id_is_high && conn->circ_id_type == CIRC_ID_TYPE_LOWER)) {\n    log_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,\n           \"Received create cell with unexpected circ_id %d. Closing.\",\n           cell->circ_id);\n    connection_or_send_destroy(cell->circ_id, conn,\n                               END_CIRC_REASON_TORPROTOCOL);\n    return;\n  }\n\n  if (circuit_id_in_use_on_orconn(cell->circ_id, conn)) {\n    routerinfo_t *router = router_get_by_digest(conn->identity_digest);\n    log_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,\n           \"Received CREATE cell (circID %d) for known circ. \"\n           \"Dropping (age %d).\",\n           cell->circ_id, (int)(time(NULL) - conn->_base.timestamp_created));\n    if (router)\n      log_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,\n             \"Details: nickname \\\"%s\\\", platform %s.\",\n             router->nickname, escaped(router->platform));\n    return;\n  }\n\n  circ = or_circuit_new(cell->circ_id, conn);\n  circ->_base.purpose = CIRCUIT_PURPOSE_OR;\n  circuit_set_state(TO_CIRCUIT(circ), CIRCUIT_STATE_ONIONSKIN_PENDING);\n  if (cell->command == CELL_CREATE) {\n    char *onionskin = tor_malloc(ONIONSKIN_CHALLENGE_LEN);\n    memcpy(onionskin, cell->payload, ONIONSKIN_CHALLENGE_LEN);\n\n    /* hand it off to the cpuworkers, and then return. */\n    if (assign_onionskin_to_cpuworker(NULL, circ, onionskin) < 0) {\n      log_warn(LD_GENERAL,\"Failed to hand off onionskin. Closing.\");\n      circuit_mark_for_close(TO_CIRCUIT(circ), END_CIRC_REASON_INTERNAL);\n      return;\n    }\n    log_debug(LD_OR,\"success: handed off onionskin.\");\n  } else {\n    /* This is a CREATE_FAST cell; we can handle it immediately without using\n     * a CPU worker. */\n    char keys[CPATH_KEY_MATERIAL_LEN];\n    char reply[DIGEST_LEN*2];\n\n    tor_assert(cell->command == CELL_CREATE_FAST);\n\n    /* Make sure we never try to use the OR connection on which we\n     * received this cell to satisfy an EXTEND request,  */\n    conn->is_connection_with_client = 1;\n\n    if (fast_server_handshake(cell->payload, (uint8_t*)reply,\n                              (uint8_t*)keys, sizeof(keys))<0) {\n      log_warn(LD_OR,\"Failed to generate key material. Closing.\");\n      circuit_mark_for_close(TO_CIRCUIT(circ), END_CIRC_REASON_INTERNAL);\n      return;\n    }\n    if (onionskin_answer(circ, CELL_CREATED_FAST, reply, keys)<0) {\n      log_warn(LD_OR,\"Failed to reply to CREATE_FAST cell. Closing.\");\n      circuit_mark_for_close(TO_CIRCUIT(circ), END_CIRC_REASON_INTERNAL);\n      return;\n    }\n  }\n}",
        "target": 1
    },
    {
        "func": "genrand_int32(void)\n{\n    unsigned long y;\n\n    if (--left == 0) next_state();\n    y = *next++;\n\n    /* Tempering */\n    y ^= (y >> 11);\n    y ^= (y << 7) & 0x9d2c5680UL;\n    y ^= (y << 15) & 0xefc60000UL;\n    y ^= (y >> 18);\n\n    return y;\n}",
        "target": 1
    },
    {
        "func": "genrand_real(void) \n{ \n    unsigned long a=genrand_int32()>>5, b=genrand_int32()>>6; \n    return(a*67108864.0+b)*(1.0/9007199254740992.0); \n} ",
        "target": 1
    },
    {
        "func": "limited_rand(unsigned long limit)\n{\n    unsigned long mask = make_mask(limit);\n    int i;\n    unsigned long val;\n\n  retry:\n    val = 0;\n    for (i = SIZEOF_LONG/4-1; 0 <= i; i--) {\n        if (mask >> (i * 32)) {\n            val |= genrand_int32() << (i * 32);\n            val &= mask;\n            if (limit < val)\n                goto retry;\n        }\n    }\n    return val;\n}",
        "target": 1
    },
    {
        "func": "limited_big_rand(struct RBignum *limit)\n{\n    unsigned long mask, lim, rnd;\n    struct RBignum *val;\n    int i, len, boundary;\n\n    len = (limit->len * SIZEOF_BDIGITS + 3) / 4;\n    val = (struct RBignum *)rb_big_clone((VALUE)limit);\n    val->sign = 1;\n#if SIZEOF_BDIGITS == 2\n# define BIG_GET32(big,i) (((BDIGIT *)(big)->digits)[(i)*2] | \\\n                           ((i)*2+1 < (big)->len ? (((BDIGIT *)(big)->digits)[(i)*2+1] << 16) \\\n                                                 : 0))\n# define BIG_SET32(big,i,d) ((((BDIGIT *)(big)->digits)[(i)*2] = (d) & 0xffff), \\\n                             ((i)*2+1 < (big)->len ? (((BDIGIT *)(big)->digits)[(i)*2+1] = (d) >> 16) \\\n                                                   : 0))\n#else\n    /* SIZEOF_BDIGITS == 4 */\n# define BIG_GET32(big,i) (((BDIGIT *)(big)->digits)[i])\n# define BIG_SET32(big,i,d) (((BDIGIT *)(big)->digits)[i] = (d))\n#endif\n  retry:\n    mask = 0;\n    boundary = 1;\n    for (i = len-1; 0 <= i; i--) {\n        lim = BIG_GET32(limit, i);\n        mask = mask ? 0xffffffff : make_mask(lim);\n        if (mask) {\n            rnd = genrand_int32() & mask;\n            if (boundary) {\n                if (lim < rnd)\n                    goto retry;\n                if (rnd < lim)\n                    boundary = 0;\n            }\n        }\n        else {\n            rnd = 0;\n        }\n        BIG_SET32(val, i, rnd);\n    }\n    return rb_big_norm((VALUE)val);\n}",
        "target": 1
    },
    {
        "func": "rb_f_rand(argc, argv, obj)\n    int argc;\n    VALUE *argv;\n    VALUE obj;\n{\n    VALUE vmax;\n    long val, max;\n\n    rb_scan_args(argc, argv, \"01\", &vmax);\n    if (first) {\n\trand_init(random_seed());\n    }\n    switch (TYPE(vmax)) {\n      case T_FLOAT:\n\tif (RFLOAT(vmax)->value <= LONG_MAX && RFLOAT(vmax)->value >= LONG_MIN) {\n\t    max = (long)RFLOAT(vmax)->value;\n\t    break;\n\t}\n        if (RFLOAT(vmax)->value < 0)\n            vmax = rb_dbl2big(-RFLOAT(vmax)->value);\n        else\n            vmax = rb_dbl2big(RFLOAT(vmax)->value);\n\t/* fall through */\n      case T_BIGNUM:\n      bignum:\n        {\n            struct RBignum *limit = (struct RBignum *)vmax;\n            if (!limit->sign) {\n                limit = (struct RBignum *)rb_big_clone(vmax);\n                limit->sign = 1;\n            }\n            limit = (struct RBignum *)rb_big_minus((VALUE)limit, INT2FIX(1));\n            if (FIXNUM_P((VALUE)limit)) {\n                if (FIX2LONG((VALUE)limit) == -1)\n                    return rb_float_new(genrand_real());\n                return LONG2NUM(limited_rand(FIX2LONG((VALUE)limit)));\n            }\n            return limited_big_rand(limit);\n\t}\n      case T_NIL:\n\tmax = 0;\n\tbreak;\n      default:\n\tvmax = rb_Integer(vmax);\n\tif (TYPE(vmax) == T_BIGNUM) goto bignum;\n\t/* fall through */\n      case T_FIXNUM:\n\tmax = FIX2LONG(vmax);\n\tbreak;\n    }\n\n    if (max == 0) {\n\treturn rb_float_new(genrand_real());\n    }\n    if (max < 0) max = -max;\n    val = limited_rand(max-1);\n    return LONG2NUM(val);\n}",
        "target": 1
    },
    {
        "func": "int user_update(struct key *key, const void *data, size_t datalen)\n{\n\tstruct user_key_payload *upayload, *zap;\n\tint ret;\n\n\tret = -EINVAL;\n\tif (datalen <= 0 || datalen > 32767 || !data)\n\t\tgoto error;\n\n\t/* construct a replacement payload */\n\tret = -ENOMEM;\n\tupayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);\n\tif (!upayload)\n\t\tgoto error;\n\n\tupayload->datalen = datalen;\n\tmemcpy(upayload->data, data, datalen);\n\n\t/* check the quota and attach the new data */\n\tzap = upayload;\n\n\tret = key_payload_reserve(key, datalen);\n\n\tif (ret == 0) {\n\t\t/* attach the new data, displacing the old */\n\t\tzap = key->payload.data;\n\t\trcu_assign_pointer(key->payload.data, upayload);\n\t\tkey->expiry = 0;\n\t}\n\n\tkfree_rcu(zap, rcu);\n\nerror:\n\treturn ret;\n}",
        "target": 1
    },
    {
        "func": "gnutls_session_get_data (gnutls_session_t session,\n                         void *session_data, size_t * session_data_size)\n{\n\n  gnutls_datum_t psession;\n  int ret;\n\n  if (session->internals.resumable == RESUME_FALSE)\n    return GNUTLS_E_INVALID_SESSION;\n\n  psession.data = session_data;\n\n  ret = _gnutls_session_pack (session, &psession);\n  if (ret < 0)\n    {\n      gnutls_assert ();\n      return ret;\n    }\n  *session_data_size = psession.size;\n\n  if (psession.size > *session_data_size)\n    {\n      ret = GNUTLS_E_SHORT_MEMORY_BUFFER;\n      goto error;\n    }\n\n  if (session_data != NULL)\n    memcpy (session_data, psession.data, psession.size);\n\n  ret = 0;\n\nerror:\n  _gnutls_free_datum (&psession);\n  return ret;\n}",
        "target": 1
    },
    {
        "func": "gnutls_session_get_data (gnutls_session_t session,\n                         void *session_data, size_t * session_data_size)\n{\n\n  gnutls_datum_t psession;\n  int ret;\n\n  if (session->internals.resumable == RESUME_FALSE)\n    return GNUTLS_E_INVALID_SESSION;\n\n  psession.data = session_data;\n\n  ret = _gnutls_session_pack (session, &psession);\n  if (ret < 0)\n    {\n      gnutls_assert ();\n      return ret;\n    }\n\n  if (psession.size > *session_data_size)\n    {\n      ret = GNUTLS_E_SHORT_MEMORY_BUFFER;\n      goto error;\n    }\n  *session_data_size = psession.size;\n\n  if (session_data != NULL)\n    memcpy (session_data, psession.data, psession.size);\n\n  ret = 0;\n\nerror:\n  _gnutls_free_datum (&psession);\n  return ret;\n}",
        "target": 1
    },
    {
        "func": "xmlParsePI(xmlParserCtxtPtr ctxt) {\n    xmlChar *buf = NULL;\n    int len = 0;\n    int size = XML_PARSER_BUFFER_SIZE;\n    int cur, l;\n    const xmlChar *target;\n    xmlParserInputState state;\n    int count = 0;\n\n    if ((RAW == '<') && (NXT(1) == '?')) {\n\txmlParserInputPtr input = ctxt->input;\n\tstate = ctxt->instate;\n        ctxt->instate = XML_PARSER_PI;\n\t/*\n\t * this is a Processing Instruction.\n\t */\n\tSKIP(2);\n\tSHRINK;\n\n\t/*\n\t * Parse the target name and check for special support like\n\t * namespace.\n\t */\n        target = xmlParsePITarget(ctxt);\n\tif (target != NULL) {\n\t    if ((RAW == '?') && (NXT(1) == '>')) {\n\t\tif (input != ctxt->input) {\n\t\t    xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,\n\t    \"PI declaration doesn't start and stop in the same entity\\n\");\n\t\t}\n\t\tSKIP(2);\n\n\t\t/*\n\t\t * SAX: PI detected.\n\t\t */\n\t\tif ((ctxt->sax) && (!ctxt->disableSAX) &&\n\t\t    (ctxt->sax->processingInstruction != NULL))\n\t\t    ctxt->sax->processingInstruction(ctxt->userData,\n\t\t                                     target, NULL);\n\t\tctxt->instate = state;\n\t\treturn;\n\t    }\n\t    buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));\n\t    if (buf == NULL) {\n\t\txmlErrMemory(ctxt, NULL);\n\t\tctxt->instate = state;\n\t\treturn;\n\t    }\n\t    cur = CUR;\n\t    if (!IS_BLANK(cur)) {\n\t\txmlFatalErrMsgStr(ctxt, XML_ERR_SPACE_REQUIRED,\n\t\t\t  \"ParsePI: PI %s space expected\\n\", target);\n\t    }\n            SKIP_BLANKS;\n\t    cur = CUR_CHAR(l);\n\t    while (IS_CHAR(cur) && /* checked */\n\t\t   ((cur != '?') || (NXT(1) != '>'))) {\n\t\tif (len + 5 >= size) {\n\t\t    xmlChar *tmp;\n\n\t\t    size *= 2;\n\t\t    tmp = (xmlChar *) xmlRealloc(buf, size * sizeof(xmlChar));\n\t\t    if (tmp == NULL) {\n\t\t\txmlErrMemory(ctxt, NULL);\n\t\t\txmlFree(buf);\n\t\t\tctxt->instate = state;\n\t\t\treturn;\n\t\t    }\n\t\t    buf = tmp;\n\t\t}\n\t\tcount++;\n\t\tif (count > 50) {\n\t\t    GROW;\n\t\t    count = 0;\n\t\t}\n\t\tCOPY_BUF(l,buf,len,cur);\n\t\tNEXTL(l);\n\t\tcur = CUR_CHAR(l);\n\t\tif (cur == 0) {\n\t\t    SHRINK;\n\t\t    GROW;\n\t\t    cur = CUR_CHAR(l);\n\t\t}\n\t    }\n\t    buf[len] = 0;\n\t    if (cur != '?') {\n\t\txmlFatalErrMsgStr(ctxt, XML_ERR_PI_NOT_FINISHED,\n\t\t      \"ParsePI: PI %s never end ...\\n\", target);\n\t    } else {\n\t\tif (input != ctxt->input) {\n\t\t    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n\t    \"PI declaration doesn't start and stop in the same entity\\n\");\n\t\t}\n\t\tSKIP(2);\n\n#ifdef LIBXML_CATALOG_ENABLED\n\t\tif (((state == XML_PARSER_MISC) ||\n\t             (state == XML_PARSER_START)) &&\n\t\t    (xmlStrEqual(target, XML_CATALOG_PI))) {\n\t\t    xmlCatalogAllow allow = xmlCatalogGetDefaults();\n\t\t    if ((allow == XML_CATA_ALLOW_DOCUMENT) ||\n\t\t\t(allow == XML_CATA_ALLOW_ALL))\n\t\t\txmlParseCatalogPI(ctxt, buf);\n\t\t}\n#endif\n\n\n\t\t/*\n\t\t * SAX: PI detected.\n\t\t */\n\t\tif ((ctxt->sax) && (!ctxt->disableSAX) &&\n\t\t    (ctxt->sax->processingInstruction != NULL))\n\t\t    ctxt->sax->processingInstruction(ctxt->userData,\n\t\t                                     target, buf);\n\t    }\n\t    xmlFree(buf);\n\t} else {\n\t    xmlFatalErr(ctxt, XML_ERR_PI_NOT_STARTED, NULL);\n\t}\n\tctxt->instate = state;\n    }\n}",
        "target": 1
    },
    {
        "func": "xmlParseTryOrFinish(xmlParserCtxtPtr ctxt, int terminate) {\n    int ret = 0;\n    int avail, tlen;\n    xmlChar cur, next;\n    const xmlChar *lastlt, *lastgt;\n\n    if (ctxt->input == NULL)\n        return(0);\n\n#ifdef DEBUG_PUSH\n    switch (ctxt->instate) {\n\tcase XML_PARSER_EOF:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try EOF\\n\"); break;\n\tcase XML_PARSER_START:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try START\\n\"); break;\n\tcase XML_PARSER_MISC:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try MISC\\n\");break;\n\tcase XML_PARSER_COMMENT:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try COMMENT\\n\");break;\n\tcase XML_PARSER_PROLOG:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try PROLOG\\n\");break;\n\tcase XML_PARSER_START_TAG:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try START_TAG\\n\");break;\n\tcase XML_PARSER_CONTENT:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try CONTENT\\n\");break;\n\tcase XML_PARSER_CDATA_SECTION:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try CDATA_SECTION\\n\");break;\n\tcase XML_PARSER_END_TAG:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try END_TAG\\n\");break;\n\tcase XML_PARSER_ENTITY_DECL:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try ENTITY_DECL\\n\");break;\n\tcase XML_PARSER_ENTITY_VALUE:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try ENTITY_VALUE\\n\");break;\n\tcase XML_PARSER_ATTRIBUTE_VALUE:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try ATTRIBUTE_VALUE\\n\");break;\n\tcase XML_PARSER_DTD:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try DTD\\n\");break;\n\tcase XML_PARSER_EPILOG:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try EPILOG\\n\");break;\n\tcase XML_PARSER_PI:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try PI\\n\");break;\n        case XML_PARSER_IGNORE:\n            xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try IGNORE\\n\");break;\n    }\n#endif\n\n    if ((ctxt->input != NULL) &&\n        (ctxt->input->cur - ctxt->input->base > 4096)) {\n\txmlSHRINK(ctxt);\n\tctxt->checkIndex = 0;\n    }\n    xmlParseGetLasts(ctxt, &lastlt, &lastgt);\n\n    while (1) {\n\tif ((ctxt->errNo != XML_ERR_OK) && (ctxt->disableSAX == 1))\n\t    return(0);\n\n        \n\t/*\n\t * Pop-up of finished entities.\n\t */\n\twhile ((RAW == 0) && (ctxt->inputNr > 1))\n\t    xmlPopInput(ctxt);\n\n\tif (ctxt->input == NULL) break;\n\tif (ctxt->input->buf == NULL)\n\t    avail = ctxt->input->length -\n\t            (ctxt->input->cur - ctxt->input->base);\n\telse {\n\t    /*\n\t     * If we are operating on converted input, try to flush\n\t     * remainng chars to avoid them stalling in the non-converted\n\t     * buffer.\n\t     */\n\t    if ((ctxt->input->buf->raw != NULL) &&\n\t\t(ctxt->input->buf->raw->use > 0)) {\n\t\tint base = ctxt->input->base -\n\t\t           ctxt->input->buf->buffer->content;\n\t\tint current = ctxt->input->cur - ctxt->input->base;\n\n\t\txmlParserInputBufferPush(ctxt->input->buf, 0, \"\");\n\t\tctxt->input->base = ctxt->input->buf->buffer->content + base;\n\t\tctxt->input->cur = ctxt->input->base + current;\n\t\tctxt->input->end =\n\t\t    &ctxt->input->buf->buffer->content[\n\t\t                       ctxt->input->buf->buffer->use];\n\t    }\n\t    avail = ctxt->input->buf->buffer->use -\n\t\t    (ctxt->input->cur - ctxt->input->base);\n\t}\n        if (avail < 1)\n\t    goto done;\n        switch (ctxt->instate) {\n            case XML_PARSER_EOF:\n\t        /*\n\t\t * Document parsing is done !\n\t\t */\n\t        goto done;\n            case XML_PARSER_START:\n\t\tif (ctxt->charset == XML_CHAR_ENCODING_NONE) {\n\t\t    xmlChar start[4];\n\t\t    xmlCharEncoding enc;\n\n\t\t    /*\n\t\t     * Very first chars read from the document flow.\n\t\t     */\n\t\t    if (avail < 4)\n\t\t\tgoto done;\n\n\t\t    /* \n\t\t     * Get the 4 first bytes and decode the charset\n\t\t     * if enc != XML_CHAR_ENCODING_NONE\n\t\t     * plug some encoding conversion routines,\n\t\t     * else xmlSwitchEncoding will set to (default)\n\t\t     * UTF8.\n\t\t     */\n\t\t    start[0] = RAW;\n\t\t    start[1] = NXT(1);\n\t\t    start[2] = NXT(2);\n\t\t    start[3] = NXT(3);\n\t\t    enc = xmlDetectCharEncoding(start, 4);\n\t\t    xmlSwitchEncoding(ctxt, enc);\n\t\t    break;\n\t\t}\n\n\t\tif (avail < 2)\n\t\t    goto done;\n\t\tcur = ctxt->input->cur[0];\n\t\tnext = ctxt->input->cur[1];\n\t\tif (cur == 0) {\n\t\t    if ((ctxt->sax) && (ctxt->sax->setDocumentLocator))\n\t\t\tctxt->sax->setDocumentLocator(ctxt->userData,\n\t\t\t\t\t\t      &xmlDefaultSAXLocator);\n\t\t    xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);\n\t\t    ctxt->instate = XML_PARSER_EOF;\n#ifdef DEBUG_PUSH\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"PP: entering EOF\\n\");\n#endif\n\t\t    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\n\t\t\tctxt->sax->endDocument(ctxt->userData);\n\t\t    goto done;\n\t\t}\n\t        if ((cur == '<') && (next == '?')) {\n\t\t    /* PI or XML decl */\n\t\t    if (avail < 5) return(ret);\n\t\t    if ((!terminate) &&\n\t\t        (xmlParseLookupSequence(ctxt, '?', '>', 0) < 0))\n\t\t\treturn(ret);\n\t\t    if ((ctxt->sax) && (ctxt->sax->setDocumentLocator))\n\t\t\tctxt->sax->setDocumentLocator(ctxt->userData,\n\t\t\t\t\t\t      &xmlDefaultSAXLocator);\n\t\t    if ((ctxt->input->cur[2] == 'x') &&\n\t\t\t(ctxt->input->cur[3] == 'm') &&\n\t\t\t(ctxt->input->cur[4] == 'l') &&\n\t\t\t(IS_BLANK_CH(ctxt->input->cur[5]))) {\n\t\t\tret += 5;\n#ifdef DEBUG_PUSH\n\t\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\t\"PP: Parsing XML Decl\\n\");\n#endif\n\t\t\txmlParseXMLDecl(ctxt);\n\t\t\tif (ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) {\n\t\t\t    /*\n\t\t\t     * The XML REC instructs us to stop parsing right\n\t\t\t     * here\n\t\t\t     */\n\t\t\t    ctxt->instate = XML_PARSER_EOF;\n\t\t\t    return(0);\n\t\t\t}\n\t\t\tctxt->standalone = ctxt->input->standalone;\n\t\t\tif ((ctxt->encoding == NULL) &&\n\t\t\t    (ctxt->input->encoding != NULL))\n\t\t\t    ctxt->encoding = xmlStrdup(ctxt->input->encoding);\n\t\t\tif ((ctxt->sax) && (ctxt->sax->startDocument) &&\n\t\t\t    (!ctxt->disableSAX))\n\t\t\t    ctxt->sax->startDocument(ctxt->userData);\n\t\t\tctxt->instate = XML_PARSER_MISC;\n#ifdef DEBUG_PUSH\n\t\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\t\"PP: entering MISC\\n\");\n#endif\n\t\t    } else {\n\t\t\tctxt->version = xmlCharStrdup(XML_DEFAULT_VERSION);\n\t\t\tif ((ctxt->sax) && (ctxt->sax->startDocument) &&\n\t\t\t    (!ctxt->disableSAX))\n\t\t\t    ctxt->sax->startDocument(ctxt->userData);\n\t\t\tctxt->instate = XML_PARSER_MISC;\n#ifdef DEBUG_PUSH\n\t\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\t\"PP: entering MISC\\n\");\n#endif\n\t\t    }\n\t\t} else {\n\t\t    if ((ctxt->sax) && (ctxt->sax->setDocumentLocator))\n\t\t\tctxt->sax->setDocumentLocator(ctxt->userData,\n\t\t\t\t\t\t      &xmlDefaultSAXLocator);\n\t\t    ctxt->version = xmlCharStrdup(XML_DEFAULT_VERSION);\n\t\t    if (ctxt->version == NULL) {\n\t\t        xmlErrMemory(ctxt, NULL);\n\t\t\tbreak;\n\t\t    }\n\t\t    if ((ctxt->sax) && (ctxt->sax->startDocument) &&\n\t\t        (!ctxt->disableSAX))\n\t\t\tctxt->sax->startDocument(ctxt->userData);\n\t\t    ctxt->instate = XML_PARSER_MISC;\n#ifdef DEBUG_PUSH\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"PP: entering MISC\\n\");\n#endif\n\t\t}\n\t\tbreak;\n            case XML_PARSER_START_TAG: {\n\t        const xmlChar *name;\n\t\tconst xmlChar *prefix = NULL;\n\t\tconst xmlChar *URI = NULL;\n\t\tint nsNr = ctxt->nsNr;\n\n\t\tif ((avail < 2) && (ctxt->inputNr == 1))\n\t\t    goto done;\n\t\tcur = ctxt->input->cur[0];\n\t        if (cur != '<') {\n\t\t    xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);\n\t\t    ctxt->instate = XML_PARSER_EOF;\n\t\t    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\n\t\t\tctxt->sax->endDocument(ctxt->userData);\n\t\t    goto done;\n\t\t}\n\t\tif (!terminate) {\n\t\t    if (ctxt->progressive) {\n\t\t        /* > can be found unescaped in attribute values */\n\t\t        if ((lastgt == NULL) || (ctxt->input->cur >= lastgt))\n\t\t\t    goto done;\n\t\t    } else if (xmlParseLookupSequence(ctxt, '>', 0, 0) < 0) {\n\t\t\tgoto done;\n\t\t    }\n\t\t}\n\t\tif (ctxt->spaceNr == 0)\n\t\t    spacePush(ctxt, -1);\n\t\telse if (*ctxt->space == -2)\n\t\t    spacePush(ctxt, -1);\n\t\telse\n\t\t    spacePush(ctxt, *ctxt->space);\n#ifdef LIBXML_SAX1_ENABLED\n\t\tif (ctxt->sax2)\n#endif /* LIBXML_SAX1_ENABLED */\n\t\t    name = xmlParseStartTag2(ctxt, &prefix, &URI, &tlen);\n#ifdef LIBXML_SAX1_ENABLED\n\t\telse\n\t\t    name = xmlParseStartTag(ctxt);\n#endif /* LIBXML_SAX1_ENABLED */\n\t\tif (name == NULL) {\n\t\t    spacePop(ctxt);\n\t\t    ctxt->instate = XML_PARSER_EOF;\n\t\t    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\n\t\t\tctxt->sax->endDocument(ctxt->userData);\n\t\t    goto done;\n\t\t}\n#ifdef LIBXML_VALID_ENABLED\n\t\t/*\n\t\t * [ VC: Root Element Type ]\n\t\t * The Name in the document type declaration must match\n\t\t * the element type of the root element. \n\t\t */\n\t\tif (ctxt->validate && ctxt->wellFormed && ctxt->myDoc &&\n\t\t    ctxt->node && (ctxt->node == ctxt->myDoc->children))\n\t\t    ctxt->valid &= xmlValidateRoot(&ctxt->vctxt, ctxt->myDoc);\n#endif /* LIBXML_VALID_ENABLED */\n\n\t\t/*\n\t\t * Check for an Empty Element.\n\t\t */\n\t\tif ((RAW == '/') && (NXT(1) == '>')) {\n\t\t    SKIP(2);\n\n\t\t    if (ctxt->sax2) {\n\t\t\tif ((ctxt->sax != NULL) &&\n\t\t\t    (ctxt->sax->endElementNs != NULL) &&\n\t\t\t    (!ctxt->disableSAX))\n\t\t\t    ctxt->sax->endElementNs(ctxt->userData, name,\n\t\t\t                            prefix, URI);\n\t\t\tif (ctxt->nsNr - nsNr > 0)\n\t\t\t    nsPop(ctxt, ctxt->nsNr - nsNr);\n#ifdef LIBXML_SAX1_ENABLED\n\t\t    } else {\n\t\t\tif ((ctxt->sax != NULL) &&\n\t\t\t    (ctxt->sax->endElement != NULL) &&\n\t\t\t    (!ctxt->disableSAX))\n\t\t\t    ctxt->sax->endElement(ctxt->userData, name);\n#endif /* LIBXML_SAX1_ENABLED */\n\t\t    }\n\t\t    spacePop(ctxt);\n\t\t    if (ctxt->nameNr == 0) {\n\t\t\tctxt->instate = XML_PARSER_EPILOG;\n\t\t    } else {\n\t\t\tctxt->instate = XML_PARSER_CONTENT;\n\t\t    }\n\t\t    break;\n\t\t}\n\t\tif (RAW == '>') {\n\t\t    NEXT;\n\t\t} else {\n\t\t    xmlFatalErrMsgStr(ctxt, XML_ERR_GT_REQUIRED,\n\t\t\t\t\t \"Couldn't find end of Start Tag %s\\n\",\n\t\t\t\t\t name);\n\t\t    nodePop(ctxt);\n\t\t    spacePop(ctxt);\n\t\t}\n\t\tif (ctxt->sax2)\n\t\t    nameNsPush(ctxt, name, prefix, URI, ctxt->nsNr - nsNr);\n#ifdef LIBXML_SAX1_ENABLED\n\t\telse\n\t\t    namePush(ctxt, name);\n#endif /* LIBXML_SAX1_ENABLED */\n\n\t\tctxt->instate = XML_PARSER_CONTENT;\n                break;\n\t    }\n            case XML_PARSER_CONTENT: {\n\t\tconst xmlChar *test;\n\t\tunsigned int cons;\n\t\tif ((avail < 2) && (ctxt->inputNr == 1))\n\t\t    goto done;\n\t\tcur = ctxt->input->cur[0];\n\t\tnext = ctxt->input->cur[1];\n\n\t\ttest = CUR_PTR;\n\t        cons = ctxt->input->consumed;\n\t\tif ((cur == '<') && (next == '/')) {\n\t\t    ctxt->instate = XML_PARSER_END_TAG;\n\t\t    break;\n\t        } else if ((cur == '<') && (next == '?')) {\n\t\t    if ((!terminate) &&\n\t\t        (xmlParseLookupSequence(ctxt, '?', '>', 0) < 0))\n\t\t\tgoto done;\n\t\t    xmlParsePI(ctxt);\n\t\t} else if ((cur == '<') && (next != '!')) {\n\t\t    ctxt->instate = XML_PARSER_START_TAG;\n\t\t    break;\n\t\t} else if ((cur == '<') && (next == '!') &&\n\t\t           (ctxt->input->cur[2] == '-') &&\n\t\t\t   (ctxt->input->cur[3] == '-')) {\n\t\t    int term;\n\n\t            if (avail < 4)\n\t\t        goto done;\n\t\t    ctxt->input->cur += 4;\n\t\t    term = xmlParseLookupSequence(ctxt, '-', '-', '>');\n\t\t    ctxt->input->cur -= 4;\n\t\t    if ((!terminate) && (term < 0))\n\t\t\tgoto done;\n\t\t    xmlParseComment(ctxt);\n\t\t    ctxt->instate = XML_PARSER_CONTENT;\n\t\t} else if ((cur == '<') && (ctxt->input->cur[1] == '!') &&\n\t\t    (ctxt->input->cur[2] == '[') &&\n\t\t    (ctxt->input->cur[3] == 'C') &&\n\t\t    (ctxt->input->cur[4] == 'D') &&\n\t\t    (ctxt->input->cur[5] == 'A') &&\n\t\t    (ctxt->input->cur[6] == 'T') &&\n\t\t    (ctxt->input->cur[7] == 'A') &&\n\t\t    (ctxt->input->cur[8] == '[')) {\n\t\t    SKIP(9);\n\t\t    ctxt->instate = XML_PARSER_CDATA_SECTION;\n\t\t    break;\n\t\t} else if ((cur == '<') && (next == '!') &&\n\t\t           (avail < 9)) {\n\t\t    goto done;\n\t\t} else if (cur == '&') {\n\t\t    if ((!terminate) &&\n\t\t        (xmlParseLookupSequence(ctxt, ';', 0, 0) < 0))\n\t\t\tgoto done;\n\t\t    xmlParseReference(ctxt);\n\t\t} else {\n\t\t    /* TODO Avoid the extra copy, handle directly !!! */\n\t\t    /*\n\t\t     * Goal of the following test is:\n\t\t     *  - minimize calls to the SAX 'character' callback\n\t\t     *    when they are mergeable\n\t\t     *  - handle an problem for isBlank when we only parse\n\t\t     *    a sequence of blank chars and the next one is\n\t\t     *    not available to check against '<' presence.\n\t\t     *  - tries to homogenize the differences in SAX\n\t\t     *    callbacks between the push and pull versions\n\t\t     *    of the parser.\n\t\t     */\n\t\t    if ((ctxt->inputNr == 1) &&\n\t\t        (avail < XML_PARSER_BIG_BUFFER_SIZE)) {\n\t\t\tif (!terminate) {\n\t\t\t    if (ctxt->progressive) {\n\t\t\t\tif ((lastlt == NULL) ||\n\t\t\t\t    (ctxt->input->cur > lastlt))\n\t\t\t\t    goto done;\n\t\t\t    } else if (xmlParseLookupSequence(ctxt,\n\t\t\t                                      '<', 0, 0) < 0) {\n\t\t\t\tgoto done;\n\t\t\t    }\n\t\t\t}\n                    }\n\t\t    ctxt->checkIndex = 0;\n\t\t    xmlParseCharData(ctxt, 0);\n\t\t}\n\t\t/*\n\t\t * Pop-up of finished entities.\n\t\t */\n\t\twhile ((RAW == 0) && (ctxt->inputNr > 1))\n\t\t    xmlPopInput(ctxt);\n\t\tif ((cons == ctxt->input->consumed) && (test == CUR_PTR)) {\n\t\t    xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,\n\t\t                \"detected an error in element content\\n\");\n\t\t    ctxt->instate = XML_PARSER_EOF;\n\t\t    break;\n\t\t}\n\t\tbreak;\n\t    }\n            case XML_PARSER_END_TAG:\n\t\tif (avail < 2)\n\t\t    goto done;\n\t\tif (!terminate) {\n\t\t    if (ctxt->progressive) {\n\t\t        /* > can be found unescaped in attribute values */\n\t\t        if ((lastgt == NULL) || (ctxt->input->cur >= lastgt))\n\t\t\t    goto done;\n\t\t    } else if (xmlParseLookupSequence(ctxt, '>', 0, 0) < 0) {\n\t\t\tgoto done;\n\t\t    }\n\t\t}\n\t\tif (ctxt->sax2) {\n\t\t    xmlParseEndTag2(ctxt,\n\t\t           (void *) ctxt->pushTab[ctxt->nameNr * 3 - 3],\n\t\t           (void *) ctxt->pushTab[ctxt->nameNr * 3 - 2], 0,\n\t\t       (int) (long) ctxt->pushTab[ctxt->nameNr * 3 - 1], 0);\n\t\t    nameNsPop(ctxt);\n\t\t}\n#ifdef LIBXML_SAX1_ENABLED\n\t\t  else\n\t\t    xmlParseEndTag1(ctxt, 0);\n#endif /* LIBXML_SAX1_ENABLED */\n\t\tif (ctxt->nameNr == 0) {\n\t\t    ctxt->instate = XML_PARSER_EPILOG;\n\t\t} else {\n\t\t    ctxt->instate = XML_PARSER_CONTENT;\n\t\t}\n\t\tbreak;\n            case XML_PARSER_CDATA_SECTION: {\n\t        /*\n\t\t * The Push mode need to have the SAX callback for \n\t\t * cdataBlock merge back contiguous callbacks.\n\t\t */\n\t\tint base;\n\n\t\tbase = xmlParseLookupSequence(ctxt, ']', ']', '>');\n\t\tif (base < 0) {\n\t\t    if (avail >= XML_PARSER_BIG_BUFFER_SIZE + 2) {\n\t\t        int tmp;\n\n\t\t\ttmp = xmlCheckCdataPush(ctxt->input->cur, \n\t\t\t                        XML_PARSER_BIG_BUFFER_SIZE);\n\t\t\tif (tmp < 0) {\n\t\t\t    tmp = -tmp;\n\t\t\t    ctxt->input->cur += tmp;\n\t\t\t    goto encoding_error;\n\t\t\t}\n\t\t\tif ((ctxt->sax != NULL) && (!ctxt->disableSAX)) {\n\t\t\t    if (ctxt->sax->cdataBlock != NULL)\n\t\t\t\tctxt->sax->cdataBlock(ctxt->userData,\n\t\t\t\t                      ctxt->input->cur, tmp);\n\t\t\t    else if (ctxt->sax->characters != NULL)\n\t\t\t\tctxt->sax->characters(ctxt->userData,\n\t\t\t\t                      ctxt->input->cur, tmp);\n\t\t\t}\n\t\t\tSKIPL(tmp);\n\t\t\tctxt->checkIndex = 0;\n\t\t    }\n\t\t    goto done;\n\t\t} else {\n\t\t    int tmp;\n\n\t\t    tmp = xmlCheckCdataPush(ctxt->input->cur, base);\n\t\t    if ((tmp < 0) || (tmp != base)) {\n\t\t\ttmp = -tmp;\n\t\t\tctxt->input->cur += tmp;\n\t\t\tgoto encoding_error;\n\t\t    }\n\t\t    if ((ctxt->sax != NULL) && (base == 0) &&\n\t\t        (ctxt->sax->cdataBlock != NULL) &&\n\t\t        (!ctxt->disableSAX)) {\n\t\t\t/*\n\t\t\t * Special case to provide identical behaviour\n\t\t\t * between pull and push parsers on enpty CDATA\n\t\t\t * sections\n\t\t\t */\n\t\t\t if ((ctxt->input->cur - ctxt->input->base >= 9) &&\n\t\t\t     (!strncmp((const char *)&ctxt->input->cur[-9],\n\t\t\t               \"<![CDATA[\", 9)))\n\t\t\t     ctxt->sax->cdataBlock(ctxt->userData,\n\t\t\t                           BAD_CAST \"\", 0);\n\t\t    } else if ((ctxt->sax != NULL) && (base > 0) &&\n\t\t\t(!ctxt->disableSAX)) {\n\t\t\tif (ctxt->sax->cdataBlock != NULL)\n\t\t\t    ctxt->sax->cdataBlock(ctxt->userData,\n\t\t\t\t\t\t  ctxt->input->cur, base);\n\t\t\telse if (ctxt->sax->characters != NULL)\n\t\t\t    ctxt->sax->characters(ctxt->userData,\n\t\t\t\t\t\t  ctxt->input->cur, base);\n\t\t    }\n\t\t    SKIPL(base + 3);\n\t\t    ctxt->checkIndex = 0;\n\t\t    ctxt->instate = XML_PARSER_CONTENT;\n#ifdef DEBUG_PUSH\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"PP: entering CONTENT\\n\");\n#endif\n\t\t}\n\t\tbreak;\n\t    }\n            case XML_PARSER_MISC:\n\t\tSKIP_BLANKS;\n\t\tif (ctxt->input->buf == NULL)\n\t\t    avail = ctxt->input->length -\n\t\t            (ctxt->input->cur - ctxt->input->base);\n\t\telse\n\t\t    avail = ctxt->input->buf->buffer->use -\n\t\t            (ctxt->input->cur - ctxt->input->base);\n\t\tif (avail < 2)\n\t\t    goto done;\n\t\tcur = ctxt->input->cur[0];\n\t\tnext = ctxt->input->cur[1];\n\t        if ((cur == '<') && (next == '?')) {\n\t\t    if ((!terminate) &&\n\t\t        (xmlParseLookupSequence(ctxt, '?', '>', 0) < 0))\n\t\t\tgoto done;\n#ifdef DEBUG_PUSH\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"PP: Parsing PI\\n\");\n#endif\n\t\t    xmlParsePI(ctxt);\n\t\t    ctxt->checkIndex = 0;\n\t\t} else if ((cur == '<') && (next == '!') &&\n\t\t    (ctxt->input->cur[2] == '-') &&\n\t\t    (ctxt->input->cur[3] == '-')) {\n\t\t    if ((!terminate) &&\n\t\t        (xmlParseLookupSequence(ctxt, '-', '-', '>') < 0))\n\t\t\tgoto done;\n#ifdef DEBUG_PUSH\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"PP: Parsing Comment\\n\");\n#endif\n\t\t    xmlParseComment(ctxt);\n\t\t    ctxt->instate = XML_PARSER_MISC;\n\t\t    ctxt->checkIndex = 0;\n\t\t} else if ((cur == '<') && (next == '!') &&\n\t\t    (ctxt->input->cur[2] == 'D') &&\n\t\t    (ctxt->input->cur[3] == 'O') &&\n\t\t    (ctxt->input->cur[4] == 'C') &&\n\t\t    (ctxt->input->cur[5] == 'T') &&\n\t\t    (ctxt->input->cur[6] == 'Y') &&\n\t\t    (ctxt->input->cur[7] == 'P') &&\n\t\t    (ctxt->input->cur[8] == 'E')) {\n\t\t    if ((!terminate) &&\n\t\t        (xmlParseLookupSequence(ctxt, '>', 0, 0) < 0))\n\t\t\tgoto done;\n#ifdef DEBUG_PUSH\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"PP: Parsing internal subset\\n\");\n#endif\n\t\t    ctxt->inSubset = 1;\n\t\t    xmlParseDocTypeDecl(ctxt);\n\t\t    if (RAW == '[') {\n\t\t\tctxt->instate = XML_PARSER_DTD;\n#ifdef DEBUG_PUSH\n\t\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\t\"PP: entering DTD\\n\");\n#endif\n\t\t    } else {\n\t\t\t/*\n\t\t\t * Create and update the external subset.\n\t\t\t */\n\t\t\tctxt->inSubset = 2;\n\t\t\tif ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&\n\t\t\t    (ctxt->sax->externalSubset != NULL))\n\t\t\t    ctxt->sax->externalSubset(ctxt->userData,\n\t\t\t\t    ctxt->intSubName, ctxt->extSubSystem,\n\t\t\t\t    ctxt->extSubURI);\n\t\t\tctxt->inSubset = 0;\n\t\t\txmlCleanSpecialAttr(ctxt);\n\t\t\tctxt->instate = XML_PARSER_PROLOG;\n#ifdef DEBUG_PUSH\n\t\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\t\"PP: entering PROLOG\\n\");\n#endif\n\t\t    }\n\t\t} else if ((cur == '<') && (next == '!') &&\n\t\t           (avail < 9)) {\n\t\t    goto done;\n\t\t} else {\n\t\t    ctxt->instate = XML_PARSER_START_TAG;\n\t\t    ctxt->progressive = 1;\n\t\t    xmlParseGetLasts(ctxt, &lastlt, &lastgt);\n#ifdef DEBUG_PUSH\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"PP: entering START_TAG\\n\");\n#endif\n\t\t}\n\t\tbreak;\n            case XML_PARSER_PROLOG:\n\t\tSKIP_BLANKS;\n\t\tif (ctxt->input->buf == NULL)\n\t\t    avail = ctxt->input->length - (ctxt->input->cur - ctxt->input->base);\n\t\telse\n\t\t    avail = ctxt->input->buf->buffer->use - (ctxt->input->cur - ctxt->input->base);\n\t\tif (avail < 2) \n\t\t    goto done;\n\t\tcur = ctxt->input->cur[0];\n\t\tnext = ctxt->input->cur[1];\n\t        if ((cur == '<') && (next == '?')) {\n\t\t    if ((!terminate) &&\n\t\t        (xmlParseLookupSequence(ctxt, '?', '>', 0) < 0))\n\t\t\tgoto done;\n#ifdef DEBUG_PUSH\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"PP: Parsing PI\\n\");\n#endif\n\t\t    xmlParsePI(ctxt);\n\t\t} else if ((cur == '<') && (next == '!') &&\n\t\t    (ctxt->input->cur[2] == '-') && (ctxt->input->cur[3] == '-')) {\n\t\t    if ((!terminate) &&\n\t\t        (xmlParseLookupSequence(ctxt, '-', '-', '>') < 0))\n\t\t\tgoto done;\n#ifdef DEBUG_PUSH\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"PP: Parsing Comment\\n\");\n#endif\n\t\t    xmlParseComment(ctxt);\n\t\t    ctxt->instate = XML_PARSER_PROLOG;\n\t\t} else if ((cur == '<') && (next == '!') &&\n\t\t           (avail < 4)) {\n\t\t    goto done;\n\t\t} else {\n\t\t    ctxt->instate = XML_PARSER_START_TAG;\n\t\t    if (ctxt->progressive == 0)\n\t\t\tctxt->progressive = 1;\n\t\t    xmlParseGetLasts(ctxt, &lastlt, &lastgt);\n#ifdef DEBUG_PUSH\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"PP: entering START_TAG\\n\");\n#endif\n\t\t}\n\t\tbreak;\n            case XML_PARSER_EPILOG:\n\t\tSKIP_BLANKS;\n\t\tif (ctxt->input->buf == NULL)\n\t\t    avail = ctxt->input->length - (ctxt->input->cur - ctxt->input->base);\n\t\telse\n\t\t    avail = ctxt->input->buf->buffer->use - (ctxt->input->cur - ctxt->input->base);\n\t\tif (avail < 2)\n\t\t    goto done;\n\t\tcur = ctxt->input->cur[0];\n\t\tnext = ctxt->input->cur[1];\n\t        if ((cur == '<') && (next == '?')) {\n\t\t    if ((!terminate) &&\n\t\t        (xmlParseLookupSequence(ctxt, '?', '>', 0) < 0))\n\t\t\tgoto done;\n#ifdef DEBUG_PUSH\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"PP: Parsing PI\\n\");\n#endif\n\t\t    xmlParsePI(ctxt);\n\t\t    ctxt->instate = XML_PARSER_EPILOG;\n\t\t} else if ((cur == '<') && (next == '!') &&\n\t\t    (ctxt->input->cur[2] == '-') && (ctxt->input->cur[3] == '-')) {\n\t\t    if ((!terminate) &&\n\t\t        (xmlParseLookupSequence(ctxt, '-', '-', '>') < 0))\n\t\t\tgoto done;\n#ifdef DEBUG_PUSH\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"PP: Parsing Comment\\n\");\n#endif\n\t\t    xmlParseComment(ctxt);\n\t\t    ctxt->instate = XML_PARSER_EPILOG;\n\t\t} else if ((cur == '<') && (next == '!') &&\n\t\t           (avail < 4)) {\n\t\t    goto done;\n\t\t} else {\n\t\t    xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END, NULL);\n\t\t    ctxt->instate = XML_PARSER_EOF;\n#ifdef DEBUG_PUSH\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"PP: entering EOF\\n\");\n#endif\n\t\t    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\n\t\t\tctxt->sax->endDocument(ctxt->userData);\n\t\t    goto done;\n\t\t}\n\t\tbreak;\n            case XML_PARSER_DTD: {\n\t        /*\n\t\t * Sorry but progressive parsing of the internal subset\n\t\t * is not expected to be supported. We first check that\n\t\t * the full content of the internal subset is available and\n\t\t * the parsing is launched only at that point.\n\t\t * Internal subset ends up with \"']' S? '>'\" in an unescaped\n\t\t * section and not in a ']]>' sequence which are conditional\n\t\t * sections (whoever argued to keep that crap in XML deserve\n\t\t * a place in hell !).\n\t\t */\n\t\tint base, i;\n\t\txmlChar *buf;\n\t        xmlChar quote = 0;\n\n\t\tbase = ctxt->input->cur - ctxt->input->base;\n\t\tif (base < 0) return(0);\n\t\tif (ctxt->checkIndex > base)\n\t\t    base = ctxt->checkIndex;\n\t\tbuf = ctxt->input->buf->buffer->content;\n\t\tfor (;(unsigned int) base < ctxt->input->buf->buffer->use;\n\t\t     base++) {\n\t\t    if (quote != 0) {\n\t\t        if (buf[base] == quote)\n\t\t\t    quote = 0;\n\t\t\tcontinue;    \n\t\t    }\n\t\t    if ((quote == 0) && (buf[base] == '<')) {\n\t\t        int found  = 0;\n\t\t\t/* special handling of comments */\n\t\t        if (((unsigned int) base + 4 <\n\t\t\t     ctxt->input->buf->buffer->use) &&\n\t\t\t    (buf[base + 1] == '!') &&\n\t\t\t    (buf[base + 2] == '-') &&\n\t\t\t    (buf[base + 3] == '-')) {\n\t\t\t    for (;(unsigned int) base + 3 <\n\t\t\t          ctxt->input->buf->buffer->use; base++) {\n\t\t\t\tif ((buf[base] == '-') &&\n\t\t\t\t    (buf[base + 1] == '-') &&\n\t\t\t\t    (buf[base + 2] == '>')) {\n\t\t\t\t    found = 1;\n\t\t\t\t    base += 2;\n\t\t\t\t    break;\n\t\t\t\t}\n\t\t            }\n\t\t\t    if (!found) {\n#if 0\n\t\t\t        fprintf(stderr, \"unfinished comment\\n\");\n#endif\n\t\t\t        break; /* for */\n\t\t            }\n\t\t            continue;\n\t\t\t}\n\t\t    }\n\t\t    if (buf[base] == '\"') {\n\t\t        quote = '\"';\n\t\t\tcontinue;\n\t\t    }\n\t\t    if (buf[base] == '\\'') {\n\t\t        quote = '\\'';\n\t\t\tcontinue;\n\t\t    }\n\t\t    if (buf[base] == ']') {\n#if 0\n\t\t        fprintf(stderr, \"%c%c%c%c: \", buf[base],\n\t\t\t        buf[base + 1], buf[base + 2], buf[base + 3]);\n#endif\n\t\t        if ((unsigned int) base +1 >=\n\t\t            ctxt->input->buf->buffer->use)\n\t\t\t    break;\n\t\t\tif (buf[base + 1] == ']') {\n\t\t\t    /* conditional crap, skip both ']' ! */\n\t\t\t    base++;\n\t\t\t    continue;\n\t\t\t}\n\t\t        for (i = 1;\n\t\t     (unsigned int) base + i < ctxt->input->buf->buffer->use;\n\t\t             i++) {\n\t\t\t    if (buf[base + i] == '>') {\n#if 0\n\t\t\t        fprintf(stderr, \"found\\n\");\n#endif\n\t\t\t        goto found_end_int_subset;\n\t\t\t    }\n\t\t\t    if (!IS_BLANK_CH(buf[base + i])) {\n#if 0\n\t\t\t        fprintf(stderr, \"not found\\n\");\n#endif\n\t\t\t        goto not_end_of_int_subset;\n\t\t\t    }\n\t\t\t}\n#if 0\n\t\t\tfprintf(stderr, \"end of stream\\n\");\n#endif\n\t\t        break;\n                        \n\t\t    }\nnot_end_of_int_subset:\n                    continue; /* for */\n\t\t}\n\t\t/*\n\t\t * We didn't found the end of the Internal subset\n\t\t */\n#ifdef DEBUG_PUSH\n\t\tif (next == 0)\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"PP: lookup of int subset end filed\\n\");\n#endif\n\t        goto done;\n\nfound_end_int_subset:\n\t\txmlParseInternalSubset(ctxt);\n\t\tctxt->inSubset = 2;\n\t\tif ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&\n\t\t    (ctxt->sax->externalSubset != NULL))\n\t\t    ctxt->sax->externalSubset(ctxt->userData, ctxt->intSubName,\n\t\t\t    ctxt->extSubSystem, ctxt->extSubURI);\n\t\tctxt->inSubset = 0;\n\t\txmlCleanSpecialAttr(ctxt);\n\t\tctxt->instate = XML_PARSER_PROLOG;\n\t\tctxt->checkIndex = 0;\n#ifdef DEBUG_PUSH\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: entering PROLOG\\n\");\n#endif\n                break;\n\t    }\n            case XML_PARSER_COMMENT:\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: internal error, state == COMMENT\\n\");\n\t\tctxt->instate = XML_PARSER_CONTENT;\n#ifdef DEBUG_PUSH\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: entering CONTENT\\n\");\n#endif\n\t\tbreak;\n            case XML_PARSER_IGNORE:\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: internal error, state == IGNORE\");\n\t        ctxt->instate = XML_PARSER_DTD;\n#ifdef DEBUG_PUSH\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: entering DTD\\n\");\n#endif\n\t        break;\n            case XML_PARSER_PI:\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: internal error, state == PI\\n\");\n\t\tctxt->instate = XML_PARSER_CONTENT;\n#ifdef DEBUG_PUSH\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: entering CONTENT\\n\");\n#endif\n\t\tbreak;\n            case XML_PARSER_ENTITY_DECL:\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: internal error, state == ENTITY_DECL\\n\");\n\t\tctxt->instate = XML_PARSER_DTD;\n#ifdef DEBUG_PUSH\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: entering DTD\\n\");\n#endif\n\t\tbreak;\n            case XML_PARSER_ENTITY_VALUE:\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: internal error, state == ENTITY_VALUE\\n\");\n\t\tctxt->instate = XML_PARSER_CONTENT;\n#ifdef DEBUG_PUSH\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: entering DTD\\n\");\n#endif\n\t\tbreak;\n            case XML_PARSER_ATTRIBUTE_VALUE:\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: internal error, state == ATTRIBUTE_VALUE\\n\");\n\t\tctxt->instate = XML_PARSER_START_TAG;\n#ifdef DEBUG_PUSH\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: entering START_TAG\\n\");\n#endif\n\t\tbreak;\n            case XML_PARSER_SYSTEM_LITERAL:\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: internal error, state == SYSTEM_LITERAL\\n\");\n\t\tctxt->instate = XML_PARSER_START_TAG;\n#ifdef DEBUG_PUSH\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: entering START_TAG\\n\");\n#endif\n\t\tbreak;\n            case XML_PARSER_PUBLIC_LITERAL:\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: internal error, state == PUBLIC_LITERAL\\n\");\n\t\tctxt->instate = XML_PARSER_START_TAG;\n#ifdef DEBUG_PUSH\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: entering START_TAG\\n\");\n#endif\n\t\tbreak;\n\t}\n    }\ndone:    \n#ifdef DEBUG_PUSH\n    xmlGenericError(xmlGenericErrorContext, \"PP: done %d\\n\", ret);\n#endif\n    return(ret);\nencoding_error:\n    {\n        char buffer[150];\n\n\tsnprintf(buffer, 149, \"Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n\",\n\t\t\tctxt->input->cur[0], ctxt->input->cur[1],\n\t\t\tctxt->input->cur[2], ctxt->input->cur[3]);\n\t__xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,\n\t\t     \"Input is not proper UTF-8, indicate encoding !\\n%s\",\n\t\t     BAD_CAST buffer, NULL);\n    }\n    return(0);\n}",
        "target": 1
    },
    {
        "func": "xmlParseElement(xmlParserCtxtPtr ctxt) {\n    const xmlChar *name;\n    const xmlChar *prefix = NULL;\n    const xmlChar *URI = NULL;\n    xmlParserNodeInfo node_info;\n    int line, tlen;\n    xmlNodePtr ret;\n    int nsNr = ctxt->nsNr;\n\n    if (((unsigned int) ctxt->nameNr > xmlParserMaxDepth) &&\n        ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n\txmlFatalErrMsgInt(ctxt, XML_ERR_INTERNAL_ERROR,\n\t\t \"Excessive depth in document: %d use XML_PARSE_HUGE option\\n\",\n\t\t\t  xmlParserMaxDepth);\n\tctxt->instate = XML_PARSER_EOF;\n\treturn;\n    }\n\n    /* Capture start position */\n    if (ctxt->record_info) {\n        node_info.begin_pos = ctxt->input->consumed +\n                          (CUR_PTR - ctxt->input->base);\n\tnode_info.begin_line = ctxt->input->line;\n    }\n\n    if (ctxt->spaceNr == 0)\n\tspacePush(ctxt, -1);\n    else if (*ctxt->space == -2)\n\tspacePush(ctxt, -1);\n    else\n\tspacePush(ctxt, *ctxt->space);\n\n    line = ctxt->input->line;\n#ifdef LIBXML_SAX1_ENABLED\n    if (ctxt->sax2)\n#endif /* LIBXML_SAX1_ENABLED */\n        name = xmlParseStartTag2(ctxt, &prefix, &URI, &tlen);\n#ifdef LIBXML_SAX1_ENABLED\n    else\n\tname = xmlParseStartTag(ctxt);\n#endif /* LIBXML_SAX1_ENABLED */\n    if (name == NULL) {\n\tspacePop(ctxt);\n        return;\n    }\n    namePush(ctxt, name);\n    ret = ctxt->node;\n\n#ifdef LIBXML_VALID_ENABLED\n    /*\n     * [ VC: Root Element Type ]\n     * The Name in the document type declaration must match the element\n     * type of the root element. \n     */\n    if (ctxt->validate && ctxt->wellFormed && ctxt->myDoc &&\n        ctxt->node && (ctxt->node == ctxt->myDoc->children))\n        ctxt->valid &= xmlValidateRoot(&ctxt->vctxt, ctxt->myDoc);\n#endif /* LIBXML_VALID_ENABLED */\n\n    /*\n     * Check for an Empty Element.\n     */\n    if ((RAW == '/') && (NXT(1) == '>')) {\n        SKIP(2);\n\tif (ctxt->sax2) {\n\t    if ((ctxt->sax != NULL) && (ctxt->sax->endElementNs != NULL) &&\n\t\t(!ctxt->disableSAX))\n\t\tctxt->sax->endElementNs(ctxt->userData, name, prefix, URI);\n#ifdef LIBXML_SAX1_ENABLED\n\t} else {\n\t    if ((ctxt->sax != NULL) && (ctxt->sax->endElement != NULL) &&\n\t\t(!ctxt->disableSAX))\n\t\tctxt->sax->endElement(ctxt->userData, name);\n#endif /* LIBXML_SAX1_ENABLED */\n\t}\n\tnamePop(ctxt);\n\tspacePop(ctxt);\n\tif (nsNr != ctxt->nsNr)\n\t    nsPop(ctxt, ctxt->nsNr - nsNr);\n\tif ( ret != NULL && ctxt->record_info ) {\n\t   node_info.end_pos = ctxt->input->consumed +\n\t\t\t      (CUR_PTR - ctxt->input->base);\n\t   node_info.end_line = ctxt->input->line;\n\t   node_info.node = ret;\n\t   xmlParserAddNodeInfo(ctxt, &node_info);\n\t}\n\treturn;\n    }\n    if (RAW == '>') {\n        NEXT1;\n    } else {\n        xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_GT_REQUIRED,\n\t\t     \"Couldn't find end of Start Tag %s line %d\\n\",\n\t\t                name, line, NULL);\n\n\t/*\n\t * end of parsing of this node.\n\t */\n\tnodePop(ctxt);\n\tnamePop(ctxt);\n\tspacePop(ctxt);\n\tif (nsNr != ctxt->nsNr)\n\t    nsPop(ctxt, ctxt->nsNr - nsNr);\n\n\t/*\n\t * Capture end position and add node\n\t */\n\tif ( ret != NULL && ctxt->record_info ) {\n\t   node_info.end_pos = ctxt->input->consumed +\n\t\t\t      (CUR_PTR - ctxt->input->base);\n\t   node_info.end_line = ctxt->input->line;\n\t   node_info.node = ret;\n\t   xmlParserAddNodeInfo(ctxt, &node_info);\n\t}\n\treturn;\n    }\n\n    /*\n     * Parse the content of the element:\n     */\n    xmlParseContent(ctxt);\n    if (!IS_BYTE_CHAR(RAW)) {\n        xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_TAG_NOT_FINISHED,\n\t \"Premature end of data in tag %s line %d\\n\",\n\t\t                name, line, NULL);\n\n\t/*\n\t * end of parsing of this node.\n\t */\n\tnodePop(ctxt);\n\tnamePop(ctxt);\n\tspacePop(ctxt);\n\tif (nsNr != ctxt->nsNr)\n\t    nsPop(ctxt, ctxt->nsNr - nsNr);\n\treturn;\n    }\n\n    /*\n     * parse the end of tag: '</' should be here.\n     */\n    if (ctxt->sax2) {\n\txmlParseEndTag2(ctxt, prefix, URI, line, ctxt->nsNr - nsNr, tlen);\n\tnamePop(ctxt);\n    }\n#ifdef LIBXML_SAX1_ENABLED\n      else\n\txmlParseEndTag1(ctxt, line);\n#endif /* LIBXML_SAX1_ENABLED */\n\n    /*\n     * Capture end position and add node\n     */\n    if ( ret != NULL && ctxt->record_info ) {\n       node_info.end_pos = ctxt->input->consumed +\n                          (CUR_PTR - ctxt->input->base);\n       node_info.end_line = ctxt->input->line;\n       node_info.node = ret;\n       xmlParserAddNodeInfo(ctxt, &node_info);\n    }\n}",
        "target": 1
    },
    {
        "func": "static ssize_t bat_socket_read(struct file *file, char __user *buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct socket_client *socket_client = file->private_data;\n\tstruct socket_packet *socket_packet;\n\tsize_t packet_len;\n\tint error;\n\n\tif ((file->f_flags & O_NONBLOCK) && (socket_client->queue_len == 0))\n\t\treturn -EAGAIN;\n\n\tif ((!buf) || (count < sizeof(struct icmp_packet)))\n\t\treturn -EINVAL;\n\n\tif (!access_ok(VERIFY_WRITE, buf, count))\n\t\treturn -EFAULT;\n\n\terror = wait_event_interruptible(socket_client->queue_wait,\n\t\t\t\t\t socket_client->queue_len);\n\n\tif (error)\n\t\treturn error;\n\n\tspin_lock_bh(&socket_client->lock);\n\n\tsocket_packet = list_first_entry(&socket_client->queue_list,\n\t\t\t\t\t struct socket_packet, list);\n\tlist_del(&socket_packet->list);\n\tsocket_client->queue_len--;\n\n\tspin_unlock_bh(&socket_client->lock);\n\n\terror = copy_to_user(buf, &socket_packet->icmp_packet,\n\t\t\t     socket_packet->icmp_len);\n\n\tpacket_len = socket_packet->icmp_len;\n\tkfree(socket_packet);\n\n\tif (error)\n\t\treturn -EFAULT;\n\n\treturn packet_len;\n}",
        "target": 1
    },
    {
        "func": "rsCStrExtendBuf(cstr_t *pThis, size_t iMinNeeded)\n{\n\tuchar *pNewBuf;\n\tunsigned short iNewSize;\n\tDEFiRet;\n\n\t/* first compute the new size needed */\n\tif(iMinNeeded > RS_STRINGBUF_ALLOC_INCREMENT) {\n\t\t/* we allocate \"n\" ALLOC_INCREMENTs. Usually, that should\n\t\t * leave some room after the absolutely needed one. It also\n\t\t * reduces memory fragmentation. Note that all of this are\n\t\t * integer operations (very important to understand what is\n\t\t * going on)! Parenthesis are for better readibility.\n\t\t */\n\t\tiNewSize = (iMinNeeded / RS_STRINGBUF_ALLOC_INCREMENT + 1) * RS_STRINGBUF_ALLOC_INCREMENT;\n\t} else {\n\t\tiNewSize = pThis->iBufSize + RS_STRINGBUF_ALLOC_INCREMENT;\n\t}\n\tiNewSize += pThis->iBufSize; /* add current size */\n\n\t/* DEV debugging only: dbgprintf(\"extending string buffer, old %d, new %d\\n\", pThis->iBufSize, iNewSize); */\n\tCHKmalloc(pNewBuf = (uchar*) realloc(pThis->pBuf, iNewSize * sizeof(uchar)));\n\tpThis->iBufSize = iNewSize;\n\tpThis->pBuf = pNewBuf;\n\nfinalize_it:\n\tRETiRet;\n}",
        "target": 1
    },
    {
        "func": "static struct dentry *proc_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\tint err;\n\tstruct super_block *sb;\n\tstruct pid_namespace *ns;\n\tstruct proc_inode *ei;\n\n\tif (flags & MS_KERNMOUNT)\n\t\tns = (struct pid_namespace *)data;\n\telse\n\t\tns = current->nsproxy->pid_ns;\n\n\tsb = sget(fs_type, proc_test_super, proc_set_super, ns);\n\tif (IS_ERR(sb))\n\t\treturn ERR_CAST(sb);\n\n\tif (!sb->s_root) {\n\t\tsb->s_flags = flags;\n\t\terr = proc_fill_super(sb);\n\t\tif (err) {\n\t\t\tdeactivate_locked_super(sb);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\n\t\tsb->s_flags |= MS_ACTIVE;\n\t}\n\n\tei = PROC_I(sb->s_root->d_inode);\n\tif (!ei->pid) {\n\t\trcu_read_lock();\n\t\tei->pid = get_pid(find_pid_ns(1, ns));\n\t\trcu_read_unlock();\n\t}\n\n\treturn dget(sb->s_root);\n}",
        "target": 1
    },
    {
        "func": "static int proc_show_options(struct seq_file *seq, struct dentry *root)\n{\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "int proc_pid_readdir(struct file * filp, void * dirent, filldir_t filldir)\n{\n\tunsigned int nr;\n\tstruct task_struct *reaper;\n\tstruct tgid_iter iter;\n\tstruct pid_namespace *ns;\n\n\tif (filp->f_pos >= PID_MAX_LIMIT + TGID_OFFSET)\n\t\tgoto out_no_task;\n\tnr = filp->f_pos - FIRST_PROCESS_ENTRY;\n\n\treaper = get_proc_task(filp->f_path.dentry->d_inode);\n\tif (!reaper)\n\t\tgoto out_no_task;\n\n\tfor (; nr < ARRAY_SIZE(proc_base_stuff); filp->f_pos++, nr++) {\n\t\tconst struct pid_entry *p = &proc_base_stuff[nr];\n\t\tif (proc_base_fill_cache(filp, dirent, filldir, reaper, p) < 0)\n\t\t\tgoto out;\n\t}\n\n\tns = filp->f_dentry->d_sb->s_fs_info;\n\titer.task = NULL;\n\titer.tgid = filp->f_pos - TGID_OFFSET;\n\tfor (iter = next_tgid(ns, iter);\n\t     iter.task;\n\t     iter.tgid += 1, iter = next_tgid(ns, iter)) {\n\t\tfilp->f_pos = iter.tgid + TGID_OFFSET;\n\t\tif (proc_pid_fill_cache(filp, dirent, filldir, iter) < 0) {\n\t\t\tput_task_struct(iter.task);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tfilp->f_pos = PID_MAX_LIMIT + TGID_OFFSET;\nout:\n\tput_task_struct(reaper);\nout_no_task:\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static int proc_parse_options(char *options, struct pid_namespace *pid)\n{\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\n\tpr_debug(\"proc: options = %s\\n\", options);\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\targs[0].to = args[0].from = 0;\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tdefault:\n\t\t\tpr_err(\"proc: unrecognized mount option \\\"%s\\\" \"\n\t\t\t       \"or missing value\\n\", p);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n}",
        "target": 1
    },
    {
        "func": "int pid_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct task_struct *task;\n\tconst struct cred *cred;\n\n\tgeneric_fillattr(inode, stat);\n\n\trcu_read_lock();\n\tstat->uid = 0;\n\tstat->gid = 0;\n\ttask = pid_task(proc_pid(inode), PIDTYPE_PID);\n\tif (task) {\n\t\tif ((inode->i_mode == (S_IFDIR|S_IRUGO|S_IXUGO)) ||\n\t\t    task_dumpable(task)) {\n\t\t\tcred = __task_cred(task);\n\t\t\tstat->uid = cred->euid;\n\t\t\tstat->gid = cred->egid;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static int proc_pid_permission(struct inode *inode, int mask)\n{\n\tstruct pid_namespace *pid = inode->i_sb->s_fs_info;\n\tstruct task_struct *task;\n\tbool has_perms;\n\n\ttask = get_proc_task(inode);\n\thas_perms = has_pid_permissions(pid, task, 1);\n\tput_task_struct(task);\n\n\tif (!has_perms) {\n\t\tif (pid->hide_pid == 2) {\n\t\t\t/*\n\t\t\t * Let's make getdents(), stat(), and open()\n\t\t\t * consistent with each other.  If a process\n\t\t\t * may not stat() a file, it shouldn't be seen\n\t\t\t * in procfs at all.\n\t\t\t */\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\treturn -EPERM;\n\t}\n\treturn generic_permission(inode, mask);\n}",
        "target": 1
    },
    {
        "func": "static struct dentry *proc_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\tint err;\n\tstruct super_block *sb;\n\tstruct pid_namespace *ns;\n\tstruct proc_inode *ei;\n\tchar *options;\n\n\tif (flags & MS_KERNMOUNT) {\n\t\tns = (struct pid_namespace *)data;\n\t\toptions = NULL;\n\t} else {\n\t\tns = current->nsproxy->pid_ns;\n\t\toptions = data;\n\t}\n\n\tsb = sget(fs_type, proc_test_super, proc_set_super, ns);\n\tif (IS_ERR(sb))\n\t\treturn ERR_CAST(sb);\n\n\tif (!sb->s_root) {\n\t\tsb->s_flags = flags;\n\t\tif (!proc_parse_options(options, ns)) {\n\t\t\tdeactivate_locked_super(sb);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\terr = proc_fill_super(sb);\n\t\tif (err) {\n\t\t\tdeactivate_locked_super(sb);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\n\t\tsb->s_flags |= MS_ACTIVE;\n\t}\n\n\tei = PROC_I(sb->s_root->d_inode);\n\tif (!ei->pid) {\n\t\trcu_read_lock();\n\t\tei->pid = get_pid(find_pid_ns(1, ns));\n\t\trcu_read_unlock();\n\t}\n\n\treturn dget(sb->s_root);\n}",
        "target": 1
    },
    {
        "func": "xmlStringLenDecodeEntities(xmlParserCtxtPtr ctxt, const xmlChar *str, int len,\n\t\t      int what, xmlChar end, xmlChar  end2, xmlChar end3) {\n    xmlChar *buffer = NULL;\n    int buffer_size = 0;\n\n    xmlChar *current = NULL;\n    xmlChar *rep = NULL;\n    const xmlChar *last;\n    xmlEntityPtr ent;\n    int c,l;\n    int nbchars = 0;\n\n    if ((ctxt == NULL) || (str == NULL) || (len < 0))\n\treturn(NULL);\n    last = str + len;\n\n    if (((ctxt->depth > 40) &&\n         ((ctxt->options & XML_PARSE_HUGE) == 0)) ||\n\t(ctxt->depth > 1024)) {\n\txmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);\n\treturn(NULL);\n    }\n\n    /*\n     * allocate a translation buffer.\n     */\n    buffer_size = XML_PARSER_BIG_BUFFER_SIZE;\n    buffer = (xmlChar *) xmlMallocAtomic(buffer_size * sizeof(xmlChar));\n    if (buffer == NULL) goto mem_error;\n\n    /*\n     * OK loop until we reach one of the ending char or a size limit.\n     * we are operating on already parsed values.\n     */\n    if (str < last)\n\tc = CUR_SCHAR(str, l);\n    else\n        c = 0;\n    while ((c != 0) && (c != end) && /* non input consuming loop */\n\t   (c != end2) && (c != end3)) {\n\n\tif (c == 0) break;\n        if ((c == '&') && (str[1] == '#')) {\n\t    int val = xmlParseStringCharRef(ctxt, &str);\n\t    if (val != 0) {\n\t\tCOPY_BUF(0,buffer,nbchars,val);\n\t    }\n\t    if (nbchars > buffer_size - XML_PARSER_BUFFER_SIZE) {\n\t        growBuffer(buffer, XML_PARSER_BUFFER_SIZE);\n\t    }\n\t} else if ((c == '&') && (what & XML_SUBSTITUTE_REF)) {\n\t    if (xmlParserDebugEntities)\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"String decoding Entity Reference: %.30s\\n\",\n\t\t\tstr);\n\t    ent = xmlParseStringEntityRef(ctxt, &str);\n\t    if ((ctxt->lastError.code == XML_ERR_ENTITY_LOOP) ||\n\t        (ctxt->lastError.code == XML_ERR_INTERNAL_ERROR))\n\t        goto int_error;\n\t    if (ent != NULL)\n\t        ctxt->nbentities += ent->checked;\n\t    if ((ent != NULL) &&\n\t\t(ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n\t\tif (ent->content != NULL) {\n\t\t    COPY_BUF(0,buffer,nbchars,ent->content[0]);\n\t\t    if (nbchars > buffer_size - XML_PARSER_BUFFER_SIZE) {\n\t\t\tgrowBuffer(buffer, XML_PARSER_BUFFER_SIZE);\n\t\t    }\n\t\t} else {\n\t\t    xmlFatalErrMsg(ctxt, XML_ERR_INTERNAL_ERROR,\n\t\t\t    \"predefined entity has no content\\n\");\n\t\t}\n\t    } else if ((ent != NULL) && (ent->content != NULL)) {\n\t\tctxt->depth++;\n\t\trep = xmlStringDecodeEntities(ctxt, ent->content, what,\n\t\t\t                      0, 0, 0);\n\t\tctxt->depth--;\n\n\t\tif (rep != NULL) {\n\t\t    current = rep;\n\t\t    while (*current != 0) { /* non input consuming loop */\n\t\t\tbuffer[nbchars++] = *current++;\n\t\t\tif (nbchars >\n\t\t            buffer_size - XML_PARSER_BUFFER_SIZE) {\n\t\t\t    if (xmlParserEntityCheck(ctxt, nbchars, ent))\n\t\t\t\tgoto int_error;\n\t\t\t    growBuffer(buffer, XML_PARSER_BUFFER_SIZE);\n\t\t\t}\n\t\t    }\n\t\t    xmlFree(rep);\n\t\t    rep = NULL;\n\t\t}\n\t    } else if (ent != NULL) {\n\t\tint i = xmlStrlen(ent->name);\n\t\tconst xmlChar *cur = ent->name;\n\n\t\tbuffer[nbchars++] = '&';\n\t\tif (nbchars > buffer_size - i - XML_PARSER_BUFFER_SIZE) {\n\t\t    growBuffer(buffer, XML_PARSER_BUFFER_SIZE);\n\t\t}\n\t\tfor (;i > 0;i--)\n\t\t    buffer[nbchars++] = *cur++;\n\t\tbuffer[nbchars++] = ';';\n\t    }\n\t} else if (c == '%' && (what & XML_SUBSTITUTE_PEREF)) {\n\t    if (xmlParserDebugEntities)\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"String decoding PE Reference: %.30s\\n\", str);\n\t    ent = xmlParseStringPEReference(ctxt, &str);\n\t    if (ctxt->lastError.code == XML_ERR_ENTITY_LOOP)\n\t        goto int_error;\n\t    if (ent != NULL)\n\t        ctxt->nbentities += ent->checked;\n\t    if (ent != NULL) {\n                if (ent->content == NULL) {\n\t\t    xmlLoadEntityContent(ctxt, ent);\n\t\t}\n\t\tctxt->depth++;\n\t\trep = xmlStringDecodeEntities(ctxt, ent->content, what,\n\t\t\t                      0, 0, 0);\n\t\tctxt->depth--;\n\t\tif (rep != NULL) {\n\t\t    current = rep;\n\t\t    while (*current != 0) { /* non input consuming loop */\n\t\t\tbuffer[nbchars++] = *current++;\n\t\t\tif (nbchars >\n\t\t            buffer_size - XML_PARSER_BUFFER_SIZE) {\n\t\t\t    if (xmlParserEntityCheck(ctxt, nbchars, ent))\n\t\t\t        goto int_error;\n\t\t\t    growBuffer(buffer, XML_PARSER_BUFFER_SIZE);\n\t\t\t}\n\t\t    }\n\t\t    xmlFree(rep);\n\t\t    rep = NULL;\n\t\t}\n\t    }\n\t} else {\n\t    COPY_BUF(l,buffer,nbchars,c);\n\t    str += l;\n\t    if (nbchars > buffer_size - XML_PARSER_BUFFER_SIZE) {\n\t      growBuffer(buffer, XML_PARSER_BUFFER_SIZE);\n\t    }\n\t}\n\tif (str < last)\n\t    c = CUR_SCHAR(str, l);\n\telse\n\t    c = 0;\n    }\n    buffer[nbchars] = 0;\n    return(buffer);\n\nmem_error:\n    xmlErrMemory(ctxt, NULL);\nint_error:\n    if (rep != NULL)\n        xmlFree(rep);\n    if (buffer != NULL)\n        xmlFree(buffer);\n    return(NULL);\n}",
        "target": 1
    },
    {
        "func": "ciphertext_to_compressed (gnutls_session_t session,\n                          gnutls_datum_t *ciphertext, \n                          opaque * compress_data,\n                          int compress_size,\n                          uint8_t type, record_parameters_st * params, \n                          uint64* sequence)\n{\n  uint8_t tag[MAX_HASH_SIZE];\n  uint8_t pad;\n  int length, length_to_decrypt;\n  uint16_t blocksize;\n  int ret, i, pad_failed = 0;\n  opaque preamble[MAX_PREAMBLE_SIZE];\n  int preamble_size;\n  int ver = gnutls_protocol_get_version (session);\n  int tag_size = _gnutls_auth_cipher_tag_len (&params->read.cipher_state);\n  int explicit_iv = _gnutls_version_has_explicit_iv (session->security_parameters.version);\n\n  blocksize = gnutls_cipher_get_block_size (params->cipher_algorithm);\n\n  /* actual decryption (inplace)\n   */\n  switch (_gnutls_cipher_is_block (params->cipher_algorithm))\n    {\n    case CIPHER_STREAM:\n      /* The way AEAD ciphers are defined in RFC5246, it allows\n       * only stream ciphers.\n       */\n      if (explicit_iv && _gnutls_auth_cipher_is_aead(&params->read.cipher_state))\n        {\n          uint8_t nonce[blocksize];\n          /* Values in AEAD are pretty fixed in TLS 1.2 for 128-bit block\n           */\n          if (params->read.IV.data == NULL || params->read.IV.size != 4)\n            return gnutls_assert_val(GNUTLS_E_INTERNAL_ERROR);\n          \n          if (ciphertext->size < tag_size+AEAD_EXPLICIT_DATA_SIZE)\n            return gnutls_assert_val(GNUTLS_E_UNEXPECTED_PACKET_LENGTH);\n\n          memcpy(nonce, params->read.IV.data, AEAD_IMPLICIT_DATA_SIZE);\n          memcpy(&nonce[AEAD_IMPLICIT_DATA_SIZE], ciphertext->data, AEAD_EXPLICIT_DATA_SIZE);\n          \n          _gnutls_auth_cipher_setiv(&params->read.cipher_state, nonce, AEAD_EXPLICIT_DATA_SIZE+AEAD_IMPLICIT_DATA_SIZE);\n\n          ciphertext->data += AEAD_EXPLICIT_DATA_SIZE;\n          ciphertext->size -= AEAD_EXPLICIT_DATA_SIZE;\n          \n          length_to_decrypt = ciphertext->size - tag_size;\n        }\n      else\n        {\n          if (ciphertext->size < tag_size)\n            return gnutls_assert_val(GNUTLS_E_UNEXPECTED_PACKET_LENGTH);\n  \n          length_to_decrypt = ciphertext->size;\n        }\n\n      length = ciphertext->size - tag_size;\n\n      /* Pass the type, version, length and compressed through\n       * MAC.\n       */\n      preamble_size =\n        make_preamble (UINT64DATA(*sequence), type,\n                       length, ver, preamble);\n\n      _gnutls_auth_cipher_add_auth (&params->read.cipher_state, preamble, preamble_size);\n\n      if ((ret =\n           _gnutls_auth_cipher_decrypt (&params->read.cipher_state,\n             ciphertext->data, length_to_decrypt)) < 0)\n        return gnutls_assert_val(ret);\n\n      break;\n    case CIPHER_BLOCK:\n      if (ciphertext->size < MAX(blocksize, tag_size) || (ciphertext->size % blocksize != 0))\n        return gnutls_assert_val(GNUTLS_E_UNEXPECTED_PACKET_LENGTH);\n\n      /* ignore the IV in TLS 1.1+\n       */\n      if (explicit_iv)\n        {\n          _gnutls_auth_cipher_setiv(&params->read.cipher_state,\n            ciphertext->data, blocksize);\n\n          ciphertext->size -= blocksize;\n          ciphertext->data += blocksize;\n\n          if (ciphertext->size == 0)\n            {\n              gnutls_assert ();\n              return GNUTLS_E_DECRYPTION_FAILED;\n            }\n        }\n\n      /* we don't use the auth_cipher interface here, since\n       * TLS with block ciphers is impossible to be used under such\n       * an API. (the length of plaintext is required to calculate\n       * auth_data, but it is not available before decryption).\n       */\n      if ((ret =\n           _gnutls_cipher_decrypt (&params->read.cipher_state.cipher,\n             ciphertext->data, ciphertext->size)) < 0)\n        return gnutls_assert_val(ret);\n\n      pad = ciphertext->data[ciphertext->size - 1] + 1;   /* pad */\n\n      if ((int) pad > (int) ciphertext->size - tag_size)\n        {\n          gnutls_assert ();\n          _gnutls_record_log\n            (\"REC[%p]: Short record length %d > %d - %d (under attack?)\\n\",\n             session, pad, ciphertext->size, tag_size);\n          /* We do not fail here. We check below for the\n           * the pad_failed. If zero means success.\n           */\n          pad_failed = GNUTLS_E_DECRYPTION_FAILED;\n          pad %= blocksize;\n        }\n\n      length = ciphertext->size - tag_size - pad;\n\n      /* Check the pading bytes (TLS 1.x)\n       */\n      if (ver != GNUTLS_SSL3)\n        for (i = 2; i < pad; i++)\n          {\n            if (ciphertext->data[ciphertext->size - i] !=\n                ciphertext->data[ciphertext->size - 1])\n              pad_failed = GNUTLS_E_DECRYPTION_FAILED;\n          }\n\n      if (length < 0)\n        length = 0;\n\n      /* Pass the type, version, length and compressed through\n       * MAC.\n       */\n      preamble_size =\n        make_preamble (UINT64DATA(*sequence), type,\n                       length, ver, preamble);\n      _gnutls_auth_cipher_add_auth (&params->read.cipher_state, preamble, preamble_size);\n      _gnutls_auth_cipher_add_auth (&params->read.cipher_state, ciphertext->data, length);\n\n      break;\n    default:\n      return gnutls_assert_val(GNUTLS_E_INTERNAL_ERROR);\n    }\n\n  ret = _gnutls_auth_cipher_tag(&params->read.cipher_state, tag, tag_size);\n  if (ret < 0)\n    return gnutls_assert_val(ret);\n\n  /* This one was introduced to avoid a timing attack against the TLS\n   * 1.0 protocol.\n   */\n  /* HMAC was not the same. \n   */\n  if (memcmp (tag, &ciphertext->data[length], tag_size) != 0 || pad_failed != 0)\n    return gnutls_assert_val(GNUTLS_E_DECRYPTION_FAILED);\n\n  /* copy the decrypted stuff to compress_data.\n   */\n  if (compress_size < length)\n    return gnutls_assert_val(GNUTLS_E_DECOMPRESSION_FAILED);\n\n  if (compress_data != ciphertext->data)\n    memcpy (compress_data, ciphertext->data, length);\n\n  return length;\n}",
        "target": 1
    },
    {
        "func": "int transform_save(struct augeas *aug, struct tree *xfm,\n                   const char *path, struct tree *tree) {\n    int   fd;\n    FILE *fp = NULL, *augorig_canon_fp = NULL;\n    char *augtemp = NULL, *augnew = NULL, *augorig = NULL, *augsave = NULL;\n    char *augorig_canon = NULL, *augdest = NULL;\n    int   augorig_exists;\n    int   copy_if_rename_fails = 0;\n    char *text = NULL;\n    const char *filename = path + strlen(AUGEAS_FILES_TREE) + 1;\n    const char *err_status = NULL;\n    char *dyn_err_status = NULL;\n    struct lns_error *err = NULL;\n    const char *lens_name;\n    struct lens *lens = xfm_lens(aug, xfm, &lens_name);\n    int result = -1, r;\n    bool force_reload;\n\n    errno = 0;\n\n    if (lens == NULL) {\n        err_status = \"lens_name\";\n        goto done;\n    }\n\n    copy_if_rename_fails =\n        aug_get(aug, AUGEAS_COPY_IF_RENAME_FAILS, NULL) == 1;\n\n    if (asprintf(&augorig, \"%s%s\", aug->root, filename) == -1) {\n        augorig = NULL;\n        goto done;\n    }\n\n    augorig_canon = canonicalize_file_name(augorig);\n    augorig_exists = 1;\n    if (augorig_canon == NULL) {\n        if (errno == ENOENT) {\n            augorig_canon = augorig;\n            augorig_exists = 0;\n        } else {\n            err_status = \"canon_augorig\";\n            goto done;\n        }\n    }\n\n    if (access(augorig_canon, R_OK) == 0) {\n        augorig_canon_fp = fopen(augorig_canon, \"r\");\n        text = xfread_file(augorig_canon_fp);\n    } else {\n        text = strdup(\"\");\n    }\n\n    if (text == NULL) {\n        err_status = \"put_read\";\n        goto done;\n    }\n\n    text = append_newline(text, strlen(text));\n\n    /* Figure out where to put the .augnew and temp file. If no .augnew file\n       then put the temp file next to augorig_canon, else next to .augnew. */\n    if (aug->flags & AUG_SAVE_NEWFILE) {\n        if (xasprintf(&augnew, \"%s\" EXT_AUGNEW, augorig) < 0) {\n            err_status = \"augnew_oom\";\n            goto done;\n        }\n        augdest = augnew;\n    } else {\n        augdest = augorig_canon;\n    }\n\n    if (xasprintf(&augtemp, \"%s.XXXXXX\", augdest) < 0) {\n        err_status = \"augtemp_oom\";\n        goto done;\n    }\n\n    // FIXME: We might have to create intermediate directories\n    // to be able to write augnew, but we have no idea what permissions\n    // etc. they should get. Just the process default ?\n    fd = mkstemp(augtemp);\n    if (fd < 0) {\n        err_status = \"mk_augtemp\";\n        goto done;\n    }\n    fp = fdopen(fd, \"w\");\n    if (fp == NULL) {\n        err_status = \"open_augtemp\";\n        goto done;\n    }\n\n    if (augorig_exists) {\n        if (transfer_file_attrs(augorig_canon_fp, fp, &err_status) != 0) {\n            err_status = \"xfer_attrs\";\n            goto done;\n        }\n    }\n\n    if (tree != NULL)\n        lns_put(fp, lens, tree->children, text, &err);\n\n    if (ferror(fp)) {\n        err_status = \"error_augtemp\";\n        goto done;\n    }\n\n    if (fflush(fp) != 0) {\n        err_status = \"flush_augtemp\";\n        goto done;\n    }\n\n    if (fsync(fileno(fp)) < 0) {\n        err_status = \"sync_augtemp\";\n        goto done;\n    }\n\n    if (fclose(fp) != 0) {\n        err_status = \"close_augtemp\";\n        fp = NULL;\n        goto done;\n    }\n\n    fp = NULL;\n\n    if (err != NULL) {\n        err_status = err->pos >= 0 ? \"parse_skel_failed\" : \"put_failed\";\n        unlink(augtemp);\n        goto done;\n    }\n\n    {\n        char *new_text = xread_file(augtemp);\n        int same = 0;\n        if (new_text == NULL) {\n            err_status = \"read_augtemp\";\n            goto done;\n        }\n        same = STREQ(text, new_text);\n        FREE(new_text);\n        if (same) {\n            result = 0;\n            unlink(augtemp);\n            goto done;\n        } else if (aug->flags & AUG_SAVE_NOOP) {\n            result = 1;\n            unlink(augtemp);\n            goto done;\n        }\n    }\n\n    if (!(aug->flags & AUG_SAVE_NEWFILE)) {\n        if (augorig_exists && (aug->flags & AUG_SAVE_BACKUP)) {\n            r = xasprintf(&augsave, \"%s\" EXT_AUGSAVE, augorig);\n            if (r == -1) {\n                augsave = NULL;\n                goto done;\n            }\n\n            r = clone_file(augorig_canon, augsave, &err_status, 1, 1);\n            if (r != 0) {\n                dyn_err_status = strappend(err_status, \"_augsave\");\n                goto done;\n            }\n        }\n    }\n\n    r = clone_file(augtemp, augdest, &err_status, copy_if_rename_fails, 0);\n    if (r != 0) {\n        dyn_err_status = strappend(err_status, \"_augtemp\");\n        goto done;\n    }\n\n    result = 1;\n\n done:\n    force_reload = aug->flags & AUG_SAVE_NEWFILE;\n    r = add_file_info(aug, path, lens, lens_name, augorig, force_reload);\n    if (r < 0) {\n        err_status = \"file_info\";\n        result = -1;\n    }\n    if (result > 0) {\n        r = file_saved_event(aug, path);\n        if (r < 0) {\n            err_status = \"saved_event\";\n            result = -1;\n        }\n    }\n    {\n        const char *emsg =\n            dyn_err_status == NULL ? err_status : dyn_err_status;\n        store_error(aug, filename, path, emsg, errno, err, text);\n    }\n    free(dyn_err_status);\n    lens_release(lens);\n    free(text);\n    free(augtemp);\n    free(augnew);\n    if (augorig_canon != augorig)\n        free(augorig_canon);\n    free(augorig);\n    free(augsave);\n    free_lns_error(err);\n\n    if (fp != NULL)\n        fclose(fp);\n    if (augorig_canon_fp != NULL)\n        fclose(augorig_canon_fp);\n    return result;\n}",
        "target": 1
    },
    {
        "func": "char* xread_file(const char *path) {\n    FILE *fp;\n    char *result;\n\n    fp = fopen(path, \"r\");\n    result = xfread_file(fp);\n    fclose (fp);\n\n    return result;\n}",
        "target": 1
    },
    {
        "func": "static struct augeas *setup_writable_hosts(CuTest *tc) {\n    char *etcdir, *build_root;\n    struct augeas *aug = NULL;\n    int r;\n\n    if (asprintf(&build_root, \"%s/build/test-load/%s\",\n                 abs_top_builddir, tc->name) < 0) {\n        CuFail(tc, \"failed to set build_root\");\n    }\n\n    if (asprintf(&etcdir, \"%s/etc\", build_root) < 0)\n        CuFail(tc, \"asprintf etcdir failed\");\n\n    run(tc, \"test -d %s && chmod -R u+w %s || :\", build_root, build_root);\n    run(tc, \"rm -rf %s\", build_root);\n    run(tc, \"mkdir -p %s\", etcdir);\n    run(tc, \"cp -pr %s/etc/hosts %s\", root, etcdir);\n    run(tc, \"chmod -R u+w %s\", build_root);\n\n    aug = aug_init(build_root, loadpath, AUG_NO_MODL_AUTOLOAD);\n    CuAssertPtrNotNull(tc, aug);\n\n    r = aug_set(aug, \"/augeas/load/Hosts/lens\", \"Hosts.lns\");\n    CuAssertRetSuccess(tc, r);\n\n    r = aug_set(aug, \"/augeas/load/Hosts/incl\", \"/etc/hosts\");\n    CuAssertRetSuccess(tc, r);\n\n    free(build_root);\n    free(etcdir);\n    return aug;\n}",
        "target": 1
    },
    {
        "func": "int main(void) {\n    char *output = NULL;\n    CuSuite* suite = CuSuiteNew();\n    CuSuiteSetup(suite, NULL, NULL);\n    SUITE_ADD_TEST(suite, testDefault);\n    SUITE_ADD_TEST(suite, testNoLoad);\n    SUITE_ADD_TEST(suite, testNoAutoload);\n    SUITE_ADD_TEST(suite, testInvalidLens);\n    SUITE_ADD_TEST(suite, testLoadSave);\n    SUITE_ADD_TEST(suite, testLoadDefined);\n    SUITE_ADD_TEST(suite, testDefvarExpr);\n    SUITE_ADD_TEST(suite, testReloadChanged);\n    SUITE_ADD_TEST(suite, testReloadDirty);\n    SUITE_ADD_TEST(suite, testReloadDeleted);\n    SUITE_ADD_TEST(suite, testReloadDeletedMeta);\n    SUITE_ADD_TEST(suite, testReloadExternalMod);\n    SUITE_ADD_TEST(suite, testReloadAfterSaveNewfile);\n    SUITE_ADD_TEST(suite, testParseErrorReported);\n    SUITE_ADD_TEST(suite, testLoadExclWithRoot);\n    SUITE_ADD_TEST(suite, testLoadTrailingExcl);\n\n    abs_top_srcdir = getenv(\"abs_top_srcdir\");\n    if (abs_top_srcdir == NULL)\n        die(\"env var abs_top_srcdir must be set\");\n\n    abs_top_builddir = getenv(\"abs_top_builddir\");\n    if (abs_top_builddir == NULL)\n        die(\"env var abs_top_builddir must be set\");\n\n    if (asprintf(&root, \"%s/tests/root\", abs_top_srcdir) < 0) {\n        die(\"failed to set root\");\n    }\n\n    if (asprintf(&loadpath, \"%s/lenses\", abs_top_srcdir) < 0) {\n        die(\"failed to set loadpath\");\n    }\n\n    CuSuiteRun(suite);\n    CuSuiteSummary(suite, &output);\n    CuSuiteDetails(suite, &output);\n    printf(\"%s\\n\", output);\n    free(output);\n    return suite->failCount;\n}",
        "target": 1
    },
    {
        "func": "static int transfer_file_attrs(const char *from, const char *to,\n                               const char **err_status) {\n    struct stat st;\n    int ret = 0;\n    int selinux_enabled = (is_selinux_enabled() > 0);\n    security_context_t con = NULL;\n\n    ret = lstat(from, &st);\n    if (ret < 0) {\n        *err_status = \"replace_stat\";\n        return -1;\n    }\n    if (selinux_enabled) {\n        if (lgetfilecon(from, &con) < 0 && errno != ENOTSUP) {\n            *err_status = \"replace_getfilecon\";\n            return -1;\n        }\n    }\n\n    if (lchown(to, st.st_uid, st.st_gid) < 0) {\n        *err_status = \"replace_chown\";\n        return -1;\n    }\n    if (chmod(to, st.st_mode) < 0) {\n        *err_status = \"replace_chmod\";\n        return -1;\n    }\n    if (selinux_enabled && con != NULL) {\n        if (lsetfilecon(to, con) < 0 && errno != ENOTSUP) {\n            *err_status = \"replace_setfilecon\";\n            return -1;\n        }\n        freecon(con);\n    }\n    return 0;\n}",
        "target": 1
    },
    {
        "func": "static int clone_file(const char *from, const char *to,\n                      const char **err_status, int copy_if_rename_fails) {\n    FILE *from_fp = NULL, *to_fp = NULL;\n    char buf[BUFSIZ];\n    size_t len;\n    int result = -1;\n\n    if (rename(from, to) == 0)\n        return 0;\n    if ((errno != EXDEV && errno != EBUSY) || !copy_if_rename_fails) {\n        *err_status = \"rename\";\n        return -1;\n    }\n\n    /* rename not possible, copy file contents */\n    if (!(from_fp = fopen(from, \"r\"))) {\n        *err_status = \"clone_open_src\";\n        goto done;\n    }\n\n    if (!(to_fp = fopen(to, \"w\"))) {\n        *err_status = \"clone_open_dst\";\n        goto done;\n    }\n\n    if (transfer_file_attrs(from, to, err_status) < 0)\n        goto done;\n\n    while ((len = fread(buf, 1, BUFSIZ, from_fp)) > 0) {\n        if (fwrite(buf, 1, len, to_fp) != len) {\n            *err_status = \"clone_write\";\n            goto done;\n        }\n    }\n    if (ferror(from_fp)) {\n        *err_status = \"clone_read\";\n        goto done;\n    }\n    if (fflush(to_fp) != 0) {\n        *err_status = \"clone_flush\";\n        goto done;\n    }\n    if (fsync(fileno(to_fp)) < 0) {\n        *err_status = \"clone_sync\";\n        goto done;\n    }\n    result = 0;\n done:\n    if (from_fp != NULL)\n        fclose(from_fp);\n    if (to_fp != NULL && fclose(to_fp) != 0)\n        result = -1;\n    if (result != 0)\n        unlink(to);\n    if (result == 0)\n        unlink(from);\n    return result;\n}",
        "target": 1
    },
    {
        "func": "char* xread_file(const char *path) {\n    FILE *fp = fopen(path, \"r\");\n    char *result;\n    size_t len;\n\n    if (!fp)\n        return NULL;\n\n    result = fread_file_lim(fp, MAX_READ_LEN, &len);\n    fclose (fp);\n\n    if (result != NULL\n        && len <= MAX_READ_LEN\n        && (int) len == len)\n        return result;\n\n    free(result);\n    return NULL;\n}",
        "target": 1
    },
    {
        "func": "int transform_save(struct augeas *aug, struct tree *xfm,\n                   const char *path, struct tree *tree) {\n    FILE *fp = NULL;\n    char *augnew = NULL, *augorig = NULL, *augsave = NULL;\n    char *augorig_canon = NULL;\n    int   augorig_exists;\n    int   copy_if_rename_fails = 0;\n    char *text = NULL;\n    const char *filename = path + strlen(AUGEAS_FILES_TREE) + 1;\n    const char *err_status = NULL;\n    char *dyn_err_status = NULL;\n    struct lns_error *err = NULL;\n    const char *lens_name;\n    struct lens *lens = xfm_lens(aug, xfm, &lens_name);\n    int result = -1, r;\n    bool force_reload;\n\n    errno = 0;\n\n    if (lens == NULL) {\n        err_status = \"lens_name\";\n        goto done;\n    }\n\n    copy_if_rename_fails =\n        aug_get(aug, AUGEAS_COPY_IF_RENAME_FAILS, NULL) == 1;\n\n    if (asprintf(&augorig, \"%s%s\", aug->root, filename) == -1) {\n        augorig = NULL;\n        goto done;\n    }\n\n    if (access(augorig, R_OK) == 0) {\n        text = xread_file(augorig);\n    } else {\n        text = strdup(\"\");\n    }\n\n    if (text == NULL) {\n        err_status = \"put_read\";\n        goto done;\n    }\n\n    text = append_newline(text, strlen(text));\n\n    augorig_canon = canonicalize_file_name(augorig);\n    augorig_exists = 1;\n    if (augorig_canon == NULL) {\n        if (errno == ENOENT) {\n            augorig_canon = augorig;\n            augorig_exists = 0;\n        } else {\n            err_status = \"canon_augorig\";\n            goto done;\n        }\n    }\n\n    /* Figure out where to put the .augnew file. If we need to rename it\n       later on, put it next to augorig_canon */\n    if (aug->flags & AUG_SAVE_NEWFILE) {\n        if (xasprintf(&augnew, \"%s\" EXT_AUGNEW, augorig) < 0) {\n            err_status = \"augnew_oom\";\n            goto done;\n        }\n    } else {\n        if (xasprintf(&augnew, \"%s\" EXT_AUGNEW, augorig_canon) < 0) {\n            err_status = \"augnew_oom\";\n            goto done;\n        }\n    }\n\n    // FIXME: We might have to create intermediate directories\n    // to be able to write augnew, but we have no idea what permissions\n    // etc. they should get. Just the process default ?\n    fp = fopen(augnew, \"w\");\n    if (fp == NULL) {\n        err_status = \"open_augnew\";\n        goto done;\n    }\n\n    if (augorig_exists) {\n        if (transfer_file_attrs(augorig_canon, augnew, &err_status) != 0) {\n            err_status = \"xfer_attrs\";\n            goto done;\n        }\n    }\n\n    if (tree != NULL)\n        lns_put(fp, lens, tree->children, text, &err);\n\n    if (ferror(fp)) {\n        err_status = \"error_augnew\";\n        goto done;\n    }\n\n    if (fflush(fp) != 0) {\n        err_status = \"flush_augnew\";\n        goto done;\n    }\n\n    if (fsync(fileno(fp)) < 0) {\n        err_status = \"sync_augnew\";\n        goto done;\n    }\n\n    if (fclose(fp) != 0) {\n        err_status = \"close_augnew\";\n        fp = NULL;\n        goto done;\n    }\n\n    fp = NULL;\n\n    if (err != NULL) {\n        err_status = err->pos >= 0 ? \"parse_skel_failed\" : \"put_failed\";\n        unlink(augnew);\n        goto done;\n    }\n\n    {\n        char *new_text = xread_file(augnew);\n        int same = 0;\n        if (new_text == NULL) {\n            err_status = \"read_augnew\";\n            goto done;\n        }\n        same = STREQ(text, new_text);\n        FREE(new_text);\n        if (same) {\n            result = 0;\n            unlink(augnew);\n            goto done;\n        } else if (aug->flags & AUG_SAVE_NOOP) {\n            result = 1;\n            unlink(augnew);\n            goto done;\n        }\n    }\n\n    if (!(aug->flags & AUG_SAVE_NEWFILE)) {\n        if (augorig_exists && (aug->flags & AUG_SAVE_BACKUP)) {\n            r = asprintf(&augsave, \"%s%s\" EXT_AUGSAVE, aug->root, filename);\n            if (r == -1) {\n                augsave = NULL;\n                goto done;\n            }\n\n            r = clone_file(augorig_canon, augsave, &err_status, 1);\n            if (r != 0) {\n                dyn_err_status = strappend(err_status, \"_augsave\");\n                goto done;\n            }\n        }\n        r = clone_file(augnew, augorig_canon, &err_status,\n                       copy_if_rename_fails);\n        if (r != 0) {\n            dyn_err_status = strappend(err_status, \"_augnew\");\n            goto done;\n        }\n    }\n    result = 1;\n\n done:\n    force_reload = aug->flags & AUG_SAVE_NEWFILE;\n    r = add_file_info(aug, path, lens, lens_name, augorig, force_reload);\n    if (r < 0) {\n        err_status = \"file_info\";\n        result = -1;\n    }\n    if (result > 0) {\n        r = file_saved_event(aug, path);\n        if (r < 0) {\n            err_status = \"saved_event\";\n            result = -1;\n        }\n    }\n    {\n        const char *emsg =\n            dyn_err_status == NULL ? err_status : dyn_err_status;\n        store_error(aug, filename, path, emsg, errno, err, text);\n    }\n    free(dyn_err_status);\n    lens_release(lens);\n    free(text);\n    free(augnew);\n    if (augorig_canon != augorig)\n        free(augorig_canon);\n    free(augorig);\n    free(augsave);\n    free_lns_error(err);\n\n    if (fp != NULL)\n        fclose(fp);\n    return result;\n}",
        "target": 1
    },
    {
        "func": "static int clone_file(const char *from, const char *to,\n                      const char **err_status, int copy_if_rename_fails) {\n    FILE *from_fp = NULL, *to_fp = NULL;\n    char buf[BUFSIZ];\n    size_t len;\n    int result = -1;\n\n    if (rename(from, to) == 0)\n        return 0;\n    if ((errno != EXDEV && errno != EBUSY) || !copy_if_rename_fails) {\n        *err_status = \"rename\";\n        return -1;\n    }\n\n    /* rename not possible, copy file contents */\n    if (!(from_fp = fopen(from, \"r\"))) {\n        *err_status = \"clone_open_src\";\n        goto done;\n    }\n\n    if (!(to_fp = fopen(to, \"w\"))) {\n        *err_status = \"clone_open_dst\";\n        goto done;\n    }\n\n    if (transfer_file_attrs(from_fp, to_fp, err_status) < 0)\n        goto done;\n\n    while ((len = fread(buf, 1, BUFSIZ, from_fp)) > 0) {\n        if (fwrite(buf, 1, len, to_fp) != len) {\n            *err_status = \"clone_write\";\n            goto done;\n        }\n    }\n    if (ferror(from_fp)) {\n        *err_status = \"clone_read\";\n        goto done;\n    }\n    if (fflush(to_fp) != 0) {\n        *err_status = \"clone_flush\";\n        goto done;\n    }\n    if (fsync(fileno(to_fp)) < 0) {\n        *err_status = \"clone_sync\";\n        goto done;\n    }\n    result = 0;\n done:\n    if (from_fp != NULL)\n        fclose(from_fp);\n    if (to_fp != NULL && fclose(to_fp) != 0)\n        result = -1;\n    if (result != 0)\n        unlink(to);\n    if (result == 0)\n        unlink(from);\n    return result;\n}",
        "target": 1
    },
    {
        "func": "int remove_file(struct augeas *aug, struct tree *tree) {\n    char *path = NULL;\n    const char *filename = NULL;\n    const char *err_status = NULL;\n    char *dyn_err_status = NULL;\n    char *augsave = NULL, *augorig = NULL, *augorig_canon = NULL;\n    int r;\n\n    path = path_of_tree(tree);\n    if (path == NULL) {\n        err_status = \"path_of_tree\";\n        goto error;\n    }\n    filename = path + strlen(AUGEAS_META_FILES);\n\n    if ((augorig = strappend(aug->root, filename + 1)) == NULL) {\n        err_status = \"root_file\";\n        goto error;\n    }\n\n    augorig_canon = canonicalize_file_name(augorig);\n    if (augorig_canon == NULL) {\n        if (errno == ENOENT) {\n            goto done;\n        } else {\n            err_status = \"canon_augorig\";\n            goto error;\n        }\n    }\n\n    r = file_saved_event(aug, path + strlen(AUGEAS_META_TREE));\n    if (r < 0) {\n        err_status = \"saved_event\";\n        goto error;\n    }\n\n    if (aug->flags & AUG_SAVE_NOOP)\n        goto done;\n\n    if (aug->flags & AUG_SAVE_BACKUP) {\n        /* Move file to one with extension .augsave */\n        r = asprintf(&augsave, \"%s\" EXT_AUGSAVE, augorig_canon);\n        if (r == -1) {\n            augsave = NULL;\n                goto error;\n        }\n\n        r = clone_file(augorig_canon, augsave, &err_status, 1);\n        if (r != 0) {\n            dyn_err_status = strappend(err_status, \"_augsave\");\n            goto error;\n        }\n    } else {\n        /* Unlink file */\n        r = unlink(augorig_canon);\n        if (r < 0) {\n            err_status = \"unlink_orig\";\n            goto error;\n        }\n    }\n    tree_unlink(tree);\n done:\n    free(path);\n    free(augorig);\n    free(augorig_canon);\n    free(augsave);\n    return 0;\n error:\n    {\n        const char *emsg =\n            dyn_err_status == NULL ? err_status : dyn_err_status;\n        store_error(aug, filename, path, emsg, errno, NULL, NULL);\n    }\n    free(path);\n    free(augorig);\n    free(augorig_canon);\n    free(augsave);\n    free(dyn_err_status);\n    return -1;\n}",
        "target": 1
    },
    {
        "func": "int transform_save(struct augeas *aug, struct tree *xfm,\n                   const char *path, struct tree *tree) {\n    int   fd;\n    FILE *fp = NULL, *augorig_canon_fp = NULL;\n    char *augtemp = NULL, *augnew = NULL, *augorig = NULL, *augsave = NULL;\n    char *augorig_canon = NULL, *augdest = NULL;\n    int   augorig_exists;\n    int   copy_if_rename_fails = 0;\n    char *text = NULL;\n    const char *filename = path + strlen(AUGEAS_FILES_TREE) + 1;\n    const char *err_status = NULL;\n    char *dyn_err_status = NULL;\n    struct lns_error *err = NULL;\n    const char *lens_name;\n    struct lens *lens = xfm_lens(aug, xfm, &lens_name);\n    int result = -1, r;\n    bool force_reload;\n\n    errno = 0;\n\n    if (lens == NULL) {\n        err_status = \"lens_name\";\n        goto done;\n    }\n\n    copy_if_rename_fails =\n        aug_get(aug, AUGEAS_COPY_IF_RENAME_FAILS, NULL) == 1;\n\n    if (asprintf(&augorig, \"%s%s\", aug->root, filename) == -1) {\n        augorig = NULL;\n        goto done;\n    }\n\n    augorig_canon = canonicalize_file_name(augorig);\n    augorig_exists = 1;\n    if (augorig_canon == NULL) {\n        if (errno == ENOENT) {\n            augorig_canon = augorig;\n            augorig_exists = 0;\n        } else {\n            err_status = \"canon_augorig\";\n            goto done;\n        }\n    }\n\n    if (access(augorig_canon, R_OK) == 0) {\n        augorig_canon_fp = fopen(augorig_canon, \"r\");\n        text = xfread_file(augorig_canon_fp);\n    } else {\n        text = strdup(\"\");\n    }\n\n    if (text == NULL) {\n        err_status = \"put_read\";\n        goto done;\n    }\n\n    text = append_newline(text, strlen(text));\n\n    /* Figure out where to put the .augnew and temp file. If no .augnew file\n       then put the temp file next to augorig_canon, else next to .augnew. */\n    if (aug->flags & AUG_SAVE_NEWFILE) {\n        if (xasprintf(&augnew, \"%s\" EXT_AUGNEW, augorig) < 0) {\n            err_status = \"augnew_oom\";\n            goto done;\n        }\n        augdest = augnew;\n    } else {\n        augdest = augorig_canon;\n    }\n\n    if (xasprintf(&augtemp, \"%s.XXXXXX\", augdest) < 0) {\n        err_status = \"augtemp_oom\";\n        goto done;\n    }\n\n    // FIXME: We might have to create intermediate directories\n    // to be able to write augnew, but we have no idea what permissions\n    // etc. they should get. Just the process default ?\n    fd = mkstemp(augtemp);\n    if (fd < 0) {\n        err_status = \"mk_augtemp\";\n        goto done;\n    }\n    fp = fdopen(fd, \"w\");\n    if (fp == NULL) {\n        err_status = \"open_augtemp\";\n        goto done;\n    }\n\n    if (augorig_exists) {\n        if (transfer_file_attrs(augorig_canon_fp, fp, &err_status) != 0) {\n            err_status = \"xfer_attrs\";\n            goto done;\n        }\n    }\n\n    if (tree != NULL)\n        lns_put(fp, lens, tree->children, text, &err);\n\n    if (ferror(fp)) {\n        err_status = \"error_augtemp\";\n        goto done;\n    }\n\n    if (fflush(fp) != 0) {\n        err_status = \"flush_augtemp\";\n        goto done;\n    }\n\n    if (fsync(fileno(fp)) < 0) {\n        err_status = \"sync_augtemp\";\n        goto done;\n    }\n\n    if (fclose(fp) != 0) {\n        err_status = \"close_augtemp\";\n        fp = NULL;\n        goto done;\n    }\n\n    fp = NULL;\n\n    if (err != NULL) {\n        err_status = err->pos >= 0 ? \"parse_skel_failed\" : \"put_failed\";\n        unlink(augtemp);\n        goto done;\n    }\n\n    {\n        char *new_text = xread_file(augtemp);\n        int same = 0;\n        if (new_text == NULL) {\n            err_status = \"read_augtemp\";\n            goto done;\n        }\n        same = STREQ(text, new_text);\n        FREE(new_text);\n        if (same) {\n            result = 0;\n            unlink(augtemp);\n            goto done;\n        } else if (aug->flags & AUG_SAVE_NOOP) {\n            result = 1;\n            unlink(augtemp);\n            goto done;\n        }\n    }\n\n    if (!(aug->flags & AUG_SAVE_NEWFILE)) {\n        if (augorig_exists && (aug->flags & AUG_SAVE_BACKUP)) {\n            r = xasprintf(&augsave, \"%s\" EXT_AUGSAVE, augorig);\n            if (r == -1) {\n                augsave = NULL;\n                goto done;\n            }\n\n            r = clone_file(augorig_canon, augsave, &err_status, 1);\n            if (r != 0) {\n                dyn_err_status = strappend(err_status, \"_augsave\");\n                goto done;\n            }\n        }\n    }\n\n    r = clone_file(augtemp, augdest, &err_status, copy_if_rename_fails);\n    if (r != 0) {\n        dyn_err_status = strappend(err_status, \"_augtemp\");\n        goto done;\n    }\n\n    result = 1;\n\n done:\n    force_reload = aug->flags & AUG_SAVE_NEWFILE;\n    r = add_file_info(aug, path, lens, lens_name, augorig, force_reload);\n    if (r < 0) {\n        err_status = \"file_info\";\n        result = -1;\n    }\n    if (result > 0) {\n        r = file_saved_event(aug, path);\n        if (r < 0) {\n            err_status = \"saved_event\";\n            result = -1;\n        }\n    }\n    {\n        const char *emsg =\n            dyn_err_status == NULL ? err_status : dyn_err_status;\n        store_error(aug, filename, path, emsg, errno, err, text);\n    }\n    free(dyn_err_status);\n    lens_release(lens);\n    free(text);\n    free(augtemp);\n    free(augnew);\n    if (augorig_canon != augorig)\n        free(augorig_canon);\n    free(augorig);\n    free(augsave);\n    free_lns_error(err);\n\n    if (fp != NULL)\n        fclose(fp);\n    if (augorig_canon_fp != NULL)\n        fclose(augorig_canon_fp);\n    return result;\n}",
        "target": 1
    },
    {
        "func": "\tvirtual EModRet OnPrivCTCP(CNick& Nick, CString& sMessage) {\n\t\tif (sMessage.Equals(\"DCC \", false, 4) && m_pUser->IsUserAttached()) {\n\t\t\t// DCC CHAT chat 2453612361 44592\n\t\t\tCString sType = sMessage.Token(1);\n\t\t\tCString sFile = sMessage.Token(2);\n\t\t\tunsigned long uLongIP = sMessage.Token(3).ToULong();\n\t\t\tunsigned short uPort = sMessage.Token(4).ToUShort();\n\t\t\tunsigned long uFileSize = sMessage.Token(5).ToULong();\n\n\t\t\tif (sType.Equals(\"CHAT\")) {\n\t\t\t\tCNick FromNick(Nick.GetNickMask());\n\t\t\t\tunsigned short uBNCPort = CDCCBounce::DCCRequest(FromNick.GetNick(), uLongIP, uPort, \"\", true, this, CUtils::GetIP(uLongIP));\n\t\t\t\tif (uBNCPort) {\n\t\t\t\t\tCString sIP = GetLocalDCCIP();\n\t\t\t\t\tm_pUser->PutUser(\":\" + Nick.GetNickMask() + \" PRIVMSG \" + m_pUser->GetNick() + \" :\\001DCC CHAT chat \" + CString(CUtils::GetLongIP(sIP)) + \" \" + CString(uBNCPort) + \"\\001\");\n\t\t\t\t}\n\t\t\t} else if (sType.Equals(\"SEND\")) {\n\t\t\t\t// DCC SEND readme.txt 403120438 5550 1104\n\t\t\t\tunsigned short uBNCPort = CDCCBounce::DCCRequest(Nick.GetNick(), uLongIP, uPort, sFile, false, this, CUtils::GetIP(uLongIP));\n\t\t\t\tif (uBNCPort) {\n\t\t\t\t\tCString sIP = GetLocalDCCIP();\n\t\t\t\t\tm_pUser->PutUser(\":\" + Nick.GetNickMask() + \" PRIVMSG \" + m_pUser->GetNick() + \" :\\001DCC SEND \" + sFile + \" \" + CString(CUtils::GetLongIP(sIP)) + \" \" + CString(uBNCPort) + \" \" + CString(uFileSize) + \"\\001\");\n\t\t\t\t}\n\t\t\t} else if (sType.Equals(\"RESUME\")) {\n\t\t\t\t// Need to lookup the connection by port, filter the port, and forward to the user\n\t\t\t\tunsigned short uResumePort = sMessage.Token(3).ToUShort();\n\n\t\t\t\tset<CSocket*>::const_iterator it;\n\t\t\t\tfor (it = BeginSockets(); it != EndSockets(); ++it) {\n\t\t\t\t\tCDCCBounce* pSock = (CDCCBounce*) *it;\n\n\t\t\t\t\tif (pSock->GetLocalPort() == uResumePort) {\n\t\t\t\t\t\tm_pUser->PutUser(\":\" + Nick.GetNickMask() + \" PRIVMSG \" + m_pClient->GetNick() + \" :\\001DCC \" + sType + \" \" + sFile + \" \" + CString(pSock->GetUserPort()) + \" \" + sMessage.Token(4) + \"\\001\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (sType.Equals(\"ACCEPT\")) {\n\t\t\t\t// Need to lookup the connection by port, filter the port, and forward to the user\n\t\t\t\tset<CSocket*>::const_iterator it;\n\t\t\t\tfor (it = BeginSockets(); it != EndSockets(); ++it) {\n\t\t\t\t\tCDCCBounce* pSock = (CDCCBounce*) *it;\n\n\t\t\t\t\tif (pSock->GetUserPort() == sMessage.Token(3).ToUShort()) {\n\t\t\t\t\t\tm_pUser->PutUser(\":\" + Nick.GetNickMask() + \" PRIVMSG \" + m_pClient->GetNick() + \" :\\001DCC \" + sType + \" \" + sFile + \" \" + CString(pSock->GetLocalPort()) + \" \" + sMessage.Token(4) + \"\\001\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn HALTCORE;\n\t\t}\n\n\t\treturn CONTINUE;\n\t}",
        "target": 1
    },
    {
        "func": "static int em_syscall(struct x86_emulate_ctxt *ctxt)\n{\n\tstruct x86_emulate_ops *ops = ctxt->ops;\n\tstruct desc_struct cs, ss;\n\tu64 msr_data;\n\tu16 cs_sel, ss_sel;\n\tu64 efer = 0;\n\n\t/* syscall is not available in real mode */\n\tif (ctxt->mode == X86EMUL_MODE_REAL ||\n\t    ctxt->mode == X86EMUL_MODE_VM86)\n\t\treturn emulate_ud(ctxt);\n\n\tops->get_msr(ctxt, MSR_EFER, &efer);\n\tsetup_syscalls_segments(ctxt, &cs, &ss);\n\n\tops->get_msr(ctxt, MSR_STAR, &msr_data);\n\tmsr_data >>= 32;\n\tcs_sel = (u16)(msr_data & 0xfffc);\n\tss_sel = (u16)(msr_data + 8);\n\n\tif (efer & EFER_LMA) {\n\t\tcs.d = 0;\n\t\tcs.l = 1;\n\t}\n\tops->set_segment(ctxt, cs_sel, &cs, 0, VCPU_SREG_CS);\n\tops->set_segment(ctxt, ss_sel, &ss, 0, VCPU_SREG_SS);\n\n\tctxt->regs[VCPU_REGS_RCX] = ctxt->_eip;\n\tif (efer & EFER_LMA) {\n#ifdef CONFIG_X86_64\n\t\tctxt->regs[VCPU_REGS_R11] = ctxt->eflags & ~EFLG_RF;\n\n\t\tops->get_msr(ctxt,\n\t\t\t     ctxt->mode == X86EMUL_MODE_PROT64 ?\n\t\t\t     MSR_LSTAR : MSR_CSTAR, &msr_data);\n\t\tctxt->_eip = msr_data;\n\n\t\tops->get_msr(ctxt, MSR_SYSCALL_MASK, &msr_data);\n\t\tctxt->eflags &= ~(msr_data | EFLG_RF);\n#endif\n\t} else {\n\t\t/* legacy mode */\n\t\tops->get_msr(ctxt, MSR_STAR, &msr_data);\n\t\tctxt->_eip = (u32)msr_data;\n\n\t\tctxt->eflags &= ~(EFLG_VM | EFLG_IF | EFLG_RF);\n\t}\n\n\treturn X86EMUL_CONTINUE;\n}",
        "target": 1
    },
    {
        "func": "setup_listen(void)\n{\n  char port[256];\n  int error = 0;\n\n  if (g_lis_trans != 0)\n  {\n    trans_delete(g_lis_trans);\n  }\n  if (g_use_unix_socket)\n  {\n    g_lis_trans = trans_create(2, 8192, 8192);\n    g_snprintf(port, 255, \"/tmp/xrdp_chansrv_socket_%d\", 7200 + g_display_num);\n  }\n  else\n  {\n    g_lis_trans = trans_create(1, 8192, 8192);\n    g_snprintf(port, 255, \"%d\", 7200 + g_display_num);\n  }\n  g_lis_trans->trans_conn_in = my_trans_conn_in;\n  error = trans_listen(g_lis_trans, port);\n  if (error != 0)\n  {\n    LOG(0, (\"setup_listen: trans_listen failed for port %s\", port));\n    return 1;\n  }\n  return 0;\n}",
        "target": 1
    },
    {
        "func": "int main(int argc, char** argv)\n{\n  int sck;\n  int dis;\n  struct sockaddr_un sa;\n  size_t len;\n  char* p;\n  char* display;\n\n  if (argc != 1)\n  {\n    printf(\"xrdp disconnect utility\\n\");\n    printf(\"run with no parameters to disconnect you xrdp session\\n\");\n    return 0;\n  }\n\n  display = getenv(\"DISPLAY\");\n  if (display == 0)\n  {\n    printf(\"display not set\\n\");\n    return 1;\n  }\n  dis = strtol(display + 1, &p, 10);\n  memset(&sa, 0, sizeof(sa));\n  sa.sun_family = AF_UNIX;\n  sprintf(sa.sun_path, \"/tmp/xrdp_disconnect_display_%d\", dis);\n  if (access(sa.sun_path, F_OK) != 0)\n  {\n    printf(\"not in an xrdp session\\n\");\n    return 1;\n  }\n  sck = socket(PF_UNIX, SOCK_DGRAM, 0);\n  len = sizeof(sa);\n  if (sendto(sck, \"sig\", 4, 0, (struct sockaddr*)&sa, len) > 0)\n  {\n    printf(\"message sent ok\\n\");\n  }\n  return 0;\n}",
        "target": 1
    },
    {
        "func": "chansrv_cleanup(int pid)\n{\n  char text[256];\n\n  g_snprintf(text, 255, \"/tmp/xrdp_chansrv_%8.8x_main_term\", pid);\n  if (g_file_exist(text))\n  {\n    g_file_delete(text);\n  }\n  g_snprintf(text, 255, \"/tmp/xrdp_chansrv_%8.8x_thread_done\", pid);\n  if (g_file_exist(text))\n  {\n    g_file_delete(text);\n  }\n  return 0;\n}",
        "target": 1
    },
    {
        "func": "g_init(const char* app_name)\n{\n#if defined(_WIN32)\n  WSADATA wsadata;\n\n  WSAStartup(2, &wsadata);\n#endif\n  setlocale(LC_CTYPE, \"\");\n  if (app_name != 0)\n  {\n    if (app_name[0] != 0)\n    {\n      snprintf(g_temp_base, sizeof(g_temp_base), \"/tmp/%s-XXXXXX\", app_name);\n      if (mkdtemp(g_temp_base) == 0)\n      {\n        printf(\"g_init: mkdtemp failed [%s]\\n\", g_temp_base);\n      }\n    }\n  }\n}",
        "target": 1
    },
    {
        "func": "xrdp_mm_process_login_response(struct xrdp_mm* self, struct stream* s)\n{\n  int ok;\n  int display;\n  int rv;\n  int index;\n  int uid;\n  int gid;\n  char text[256];\n  char ip[256];\n  char port[256];\n\n  g_memset(text,0,sizeof(char) * 256);\n  g_memset(ip,0,sizeof(char) * 256);\n  g_memset(port,0,sizeof(char) * 256);\n  rv = 0;\n  in_uint16_be(s, ok);\n  in_uint16_be(s, display);\n  if (ok)\n  {\n    self->display = display;\n    g_snprintf(text, 255, \"xrdp_mm_process_login_response: login successful \"\n                          \"for display %d\", display);\n    xrdp_wm_log_msg(self->wm, text);\n    if (xrdp_mm_setup_mod1(self) == 0)\n    {\n      if (xrdp_mm_setup_mod2(self) == 0)\n      {\n        xrdp_mm_get_value(self, \"ip\", ip, 255);\n        xrdp_wm_set_login_mode(self->wm, 10);\n        self->wm->dragging = 0;\n        /* connect channel redir */\n        if (strcmp(ip, \"127.0.0.1\") == 0)\n        {\n          /* unix socket */\n          self->chan_trans = trans_create(TRANS_MODE_UNIX, 8192, 8192);\n          g_snprintf(port, 255, \"/tmp/xrdp_chansrv_socket_%d\", 7200 + display);\n        }\n        else\n        {\n          /* tcp */\n          self->chan_trans = trans_create(TRANS_MODE_TCP, 8192, 8192);\n          g_snprintf(port, 255, \"%d\", 7200 + display);\n        }\n        self->chan_trans->trans_data_in = xrdp_mm_chan_data_in;\n        self->chan_trans->header_size = 8;\n        self->chan_trans->callback_data = self;\n        /* try to connect up to 4 times */\n        for (index = 0; index < 4; index++)\n        {\n          if (trans_connect(self->chan_trans, ip, port, 3000) == 0)\n          {\n            self->chan_trans_up = 1;\n            break;\n          }\n          g_sleep(1000);\n          g_writeln(\"xrdp_mm_process_login_response: connect failed \"\n                    \"trying again...\");\n        }\n        if (!(self->chan_trans_up))\n        {\n          g_writeln(\"xrdp_mm_process_login_response: error in trans_connect \"\n                    \"chan\");\n        }\n        if (self->chan_trans_up)\n        {\n          if (xrdp_mm_chan_send_init(self) != 0)\n          {\n            g_writeln(\"xrdp_mm_process_login_response: error in \"\n                      \"xrdp_mm_chan_send_init\");\n          }\n        }\n      }\n    }\n  }\n  else\n  {\n    xrdp_wm_log_msg(self->wm, \"xrdp_mm_process_login_response: \"\n                              \"login failed\");\n  }\n  self->delete_sesman_trans = 1;\n  self->connected_state = 0;\n  if (self->wm->login_mode != 10)\n  {\n    xrdp_wm_set_login_mode(self->wm, 11);\n    xrdp_mm_module_cleanup(self);\n  }\n\n  return rv;\n}",
        "target": 1
    },
    {
        "func": "g_init(const char* app_name)\n{\n#if defined(_WIN32)\n  WSADATA wsadata;\n\n  WSAStartup(2, &wsadata);\n#endif\n  setlocale(LC_CTYPE, \"\");\n  if (app_name != 0)\n  {\n    if (app_name[0] != 0)\n    {\n      if (!g_directory_exist(\"/tmp/.xrdp\"))\n      {\n        g_create_dir(\"/tmp/.xrdp\");\n        g_chmod_hex(\"/tmp/.xrdp\", 0x1777);\n      }\n      snprintf(g_temp_base, sizeof(g_temp_base),\n               \"/tmp/.xrdp/%s-XXXXXX\", app_name);\n      snprintf(g_temp_base_org, sizeof(g_temp_base_org),\n               \"/tmp/.xrdp/%s-XXXXXX\", app_name);\n      if (mkdtemp(g_temp_base) == 0)\n      {\n        printf(\"g_init: mkdtemp failed [%s]\\n\", g_temp_base);\n      }\n    }\n  }\n}",
        "target": 1
    },
    {
        "func": "g_execvp(const char* p1, char* args[])\n{\n#if defined(_WIN32)\n  return 0;\n#else\n  return execvp(p1, args);\n#endif\n}",
        "target": 1
    },
    {
        "func": "g_fork(void)\n{\n#if defined(_WIN32)\n  return 0;\n#else\n  int rv;\n\n  rv = fork();\n  if (rv == 0) /* child */\n  {\n    g_strncpy(g_temp_base, g_temp_base_org, 127);\n    if (mkdtemp(g_temp_base) == 0)\n    {\n      printf(\"g_fork: mkdtemp failed [%s]\\n\", g_temp_base);\n    }\n  }\n  return rv;\n#endif\n}",
        "target": 1
    },
    {
        "func": "main(int argc, char** argv)\n{\n  int ret = 0;\n  int chansrv_pid = 0;\n  int wm_pid = 0;\n  int x_pid = 0;\n  int lerror = 0;\n  char exe_path[262];\n\n  g_init(\"xrdp-sessvc\");\n  g_memset(exe_path,0,sizeof(exe_path));\n\n  if (argc < 3)\n  {\n    g_writeln(\"xrdp-sessvc: exiting, not enough parameters\");\n    return 1;\n  }\n  g_signal_kill(term_signal_handler); /* SIGKILL */\n  g_signal_terminate(term_signal_handler); /* SIGTERM */\n  g_signal_user_interrupt(term_signal_handler); /* SIGINT */\n  g_signal_pipe(nil_signal_handler); /* SIGPIPE */\n  x_pid = g_atoi(argv[1]);\n  wm_pid = g_atoi(argv[2]);\n  g_writeln(\"xrdp-sessvc: waiting for X (pid %d) and WM (pid %d)\",\n             x_pid, wm_pid);\n  /* run xrdp-chansrv as a seperate process */\n  chansrv_pid = g_fork();\n  if (chansrv_pid == -1)\n  {\n    g_writeln(\"xrdp-sessvc: fork error\");\n    return 1;\n  }\n  else if (chansrv_pid == 0) /* child */\n  {\n    g_set_current_dir(XRDP_SBIN_PATH);\n    g_snprintf(exe_path, 261, \"%s/xrdp-chansrv\", XRDP_SBIN_PATH);\n    g_execlp3(exe_path, \"xrdp-chansrv\", 0);\n    /* should not get here */\n    g_writeln(\"xrdp-sessvc: g_execlp3() failed\");\n    return 1;\n  }\n  lerror = 0;\n  /* wait for window manager to get done */\n  ret = g_waitpid(wm_pid);\n  while ((ret == 0) && !g_term)\n  {\n    ret = g_waitpid(wm_pid);\n    g_sleep(1);\n  }\n  if (ret < 0)\n  {\n    lerror = g_get_errno();\n  }\n  g_writeln(\"xrdp-sessvc: WM is dead (waitpid said %d, errno is %d) \"\n            \"exiting...\", ret, lerror);\n  /* kill channel server */\n  g_writeln(\"xrdp-sessvc: stopping channel server\");\n  g_sigterm(chansrv_pid);\n  ret = g_waitpid(chansrv_pid);\n  while ((ret == 0) && !g_term)\n  {\n    ret = g_waitpid(chansrv_pid);\n    g_sleep(1);\n  }\n  chansrv_cleanup(chansrv_pid);\n  /* kill X server */\n  g_writeln(\"xrdp-sessvc: stopping X server\");\n  g_sigterm(x_pid);\n  ret = g_waitpid(x_pid);\n  while ((ret == 0) && !g_term)\n  {\n    ret = g_waitpid(x_pid);\n    g_sleep(1);\n  }\n  g_writeln(\"xrdp-sessvc: clean exit\");\n  g_deinit();\n  return 0;\n}",
        "target": 1
    },
    {
        "func": "env_set_user(char* username, char* passwd_file, int display)\n{\n  int error;\n  int pw_uid;\n  int pw_gid;\n  int uid;\n  char pw_shell[256];\n  char pw_dir[256];\n  char pw_gecos[256];\n  char text[256];\n\n  error = g_getuser_info(username, &pw_gid, &pw_uid, pw_shell, pw_dir,\n                         pw_gecos);\n  if (error == 0)\n  {\n    error = g_setgid(pw_gid);\n    if (error == 0)\n    {\n      error = g_initgroups(username, pw_gid);\n    }\n    if (error == 0)\n    {\n      uid = pw_uid;\n      error = g_setuid(uid);\n    }\n    if (error == 0)\n    {\n      g_clearenv();\n      g_setenv(\"SHELL\", pw_shell, 1);\n      g_setenv(\"PATH\", \"/bin:/usr/bin:/usr/X11R6/bin:/usr/local/bin\", 1);\n      g_setenv(\"USER\", username, 1);\n      g_sprintf(text, \"%d\", uid);\n      g_setenv(\"UID\", text, 1);\n      g_setenv(\"HOME\", pw_dir, 1);\n      g_set_current_dir(pw_dir);\n      g_sprintf(text, \":%d.0\", display);\n      g_setenv(\"DISPLAY\", text, 1);\n      if (passwd_file != 0)\n      {\n        if (0 == g_cfg->auth_file_path)\n        {\n          /* if no auth_file_path is set, then we go for\n             $HOME/.vnc/sesman_username_passwd */\n          g_mkdir(\".vnc\");\n          g_sprintf(passwd_file, \"%s/.vnc/sesman_%s_passwd\", pw_dir, username);\n        }\n        else\n        {\n          /* we use auth_file_path as requested */\n          g_sprintf(passwd_file, g_cfg->auth_file_path, username);\n        }\n        LOG_DBG(&(g_cfg->log), \"pass file: %s\", passwd_file);\n      }\n    }\n  }\n  else\n  {\n    log_message(&(g_cfg->log), LOG_LEVEL_ERROR,\n                \"error getting user info for user %s\", username);\n  }\n  return error;\n}",
        "target": 1
    },
    {
        "func": "g_execlp3(const char* a1, const char* a2, const char* a3)\n{\n#if defined(_WIN32)\n  return 0;\n#else\n  return execlp(a1, a2, a3, (void*)0);\n#endif\n}",
        "target": 1
    },
    {
        "func": "g_deinit(void)\n{\n#if defined(_WIN32)\n  WSACleanup();\n#endif\n  g_remove_dir(g_temp_base);\n}",
        "target": 1
    },
    {
        "func": "char *suhosin_encrypt_single_cookie(char *name, int name_len, char *value, int value_len, char *key TSRMLS_DC)\n{\n\tchar buffer[4096];\n    char buffer2[4096];\n\tchar *buf = buffer, *buf2 = buffer2, *d, *d_url;\n    int l;\n\n\tif (name_len > sizeof(buffer)-2) {\n\t\tbuf = estrndup(name, name_len);\n\t} else {\n\t\tmemcpy(buf, name, name_len);\n\t\tbuf[name_len] = 0;\n\t}\n\t\n\tname_len = php_url_decode(buf, name_len);\n    normalize_varname(buf);\n    name_len = strlen(buf);\n\t\n\tif (SUHOSIN_G(cookie_plainlist)) {\n\t\tif (zend_hash_exists(SUHOSIN_G(cookie_plainlist), buf, name_len+1)) {\nencrypt_return_plain:\n\t\t\tif (buf != buffer) {\n\t\t\t\tefree(buf);\n\t\t\t}\n\t\t\treturn estrndup(value, value_len);\n\t\t}\n\t} else if (SUHOSIN_G(cookie_cryptlist)) {\n\t\tif (!zend_hash_exists(SUHOSIN_G(cookie_cryptlist), buf, name_len+1)) {\n\t\t\tgoto encrypt_return_plain;\n\t\t}\n\t}\n\t\n\tif (strlen(value) <= sizeof(buffer2)-2) {\n\t\tmemcpy(buf2, value, value_len);\n\t\tbuf2[value_len] = 0;\n\t} else {\n\t\tbuf2 = estrndup(value, value_len);\n\t}\n\t\n\tvalue_len = php_url_decode(buf2, value_len);\n\t\n\td = suhosin_encrypt_string(buf2, value_len, buf, name_len, key TSRMLS_CC);\n\td_url = php_url_encode(d, strlen(d), &l);\n\tefree(d);\n    if (buf != buffer) {\n\t\tefree(buf);\n\t}\n    if (buf2 != buffer2) {\n\t\tefree(buf2);\n\t}\n\treturn d_url;\n}",
        "target": 1
    },
    {
        "func": "char *suhosin_decrypt_single_cookie(char *name, int name_len, char *value, int value_len, char *key, char **where TSRMLS_DC)\n{\n\tchar buffer[4096];\n    char buffer2[4096];\n    int o_name_len = name_len;\n\tchar *buf = buffer, *buf2 = buffer2, *d, *d_url;\n\tint l;\n\n\tif (name_len > sizeof(buffer)-2) {\n\t\tbuf = estrndup(name, name_len);\n\t} else {\n\t\tmemcpy(buf, name, name_len);\n\t\tbuf[name_len] = 0;\n\t}\n\t\n\tname_len = php_url_decode(buf, name_len);\n    normalize_varname(buf);\n    name_len = strlen(buf);\n\t\n\tif (SUHOSIN_G(cookie_plainlist)) {\n\t\tif (zend_hash_exists(SUHOSIN_G(cookie_plainlist), buf, name_len+1)) {\ndecrypt_return_plain:\n\t\t\tif (buf != buffer) {\n\t\t\t\tefree(buf);\n\t\t\t}\n            memcpy(*where, name, o_name_len);\n            *where += o_name_len;\n            **where = '='; *where +=1;\n\t        memcpy(*where, value, value_len);\n\t        *where += value_len;\n\t\t\treturn *where;\n\t\t}\n\t} else if (SUHOSIN_G(cookie_cryptlist)) {\n\t\tif (!zend_hash_exists(SUHOSIN_G(cookie_cryptlist), buf, name_len+1)) {\n\t\t\tgoto decrypt_return_plain;\n\t\t}\n\t}\n\t\n\t\n\tif (strlen(value) <= sizeof(buffer2)-2) {\n\t\tmemcpy(buf2, value, value_len);\n\t\tbuf2[value_len] = 0;\n\t} else {\n\t\tbuf2 = estrndup(value, value_len);\n\t}\n\t\n\tvalue_len = php_url_decode(buf2, value_len);\n\t\n\td = suhosin_decrypt_string(buf2, value_len, buf, name_len, key, &l, SUHOSIN_G(cookie_checkraddr) TSRMLS_CC);\n    if (d == NULL) {\n        goto skip_cookie;\n    }\n\td_url = php_url_encode(d, l, &l);\n\tefree(d);\n    memcpy(*where, name, o_name_len);\n    *where += o_name_len;\n    **where = '=';*where += 1;\n\tmemcpy(*where, d_url, l);\n\t*where += l;\n\tefree(d_url);\nskip_cookie:\n\tif (buf != buffer) {\n\t\tefree(buf);\n\t}\n\tif (buf2 != buffer2) {\n\t\tefree(buf2);\n\t}\n\treturn *where;\n}",
        "target": 1
    },
    {
        "func": "xmlDictComputeFastKey(const xmlChar *name, int namelen) {\n    unsigned long value = 0L;\n\n    if (name == NULL) return(0);\n    value = *name;\n    value <<= 5;\n    if (namelen > 10) {\n        value += name[namelen - 1];\n        namelen = 10;\n    }\n    switch (namelen) {\n        case 10: value += name[9];\n        case 9: value += name[8];\n        case 8: value += name[7];\n        case 7: value += name[6];\n        case 6: value += name[5];\n        case 5: value += name[4];\n        case 4: value += name[3];\n        case 3: value += name[2];\n        case 2: value += name[1];\n        default: break;\n    }\n    return(value);\n}",
        "target": 1
    },
    {
        "func": "xmlHashComputeQKey(xmlHashTablePtr table,\n\t\t   const xmlChar *prefix, const xmlChar *name,\n\t\t   const xmlChar *prefix2, const xmlChar *name2,\n\t\t   const xmlChar *prefix3, const xmlChar *name3) {\n    unsigned long value = 0L;\n    char ch;\n    \n    if (prefix != NULL)\n\tvalue += 30 * (*prefix);\n    else\n\tvalue += 30 * (*name);\n\n    if (prefix != NULL) {\n\twhile ((ch = *prefix++) != 0) {\n\t    value = value ^ ((value << 5) + (value >> 3) + (unsigned long)ch);\n\t}\n\tvalue = value ^ ((value << 5) + (value >> 3) + (unsigned long)':');\n    }\n    if (name != NULL) {\n\twhile ((ch = *name++) != 0) {\n\t    value = value ^ ((value << 5) + (value >> 3) + (unsigned long)ch);\n\t}\n    }\n    if (prefix2 != NULL) {\n\twhile ((ch = *prefix2++) != 0) {\n\t    value = value ^ ((value << 5) + (value >> 3) + (unsigned long)ch);\n\t}\n\tvalue = value ^ ((value << 5) + (value >> 3) + (unsigned long)':');\n    }\n    if (name2 != NULL) {\n\twhile ((ch = *name2++) != 0) {\n\t    value = value ^ ((value << 5) + (value >> 3) + (unsigned long)ch);\n\t}\n    }\n    if (prefix3 != NULL) {\n\twhile ((ch = *prefix3++) != 0) {\n\t    value = value ^ ((value << 5) + (value >> 3) + (unsigned long)ch);\n\t}\n\tvalue = value ^ ((value << 5) + (value >> 3) + (unsigned long)':');\n    }\n    if (name3 != NULL) {\n\twhile ((ch = *name3++) != 0) {\n\t    value = value ^ ((value << 5) + (value >> 3) + (unsigned long)ch);\n\t}\n    }\n    return (value % table->size);\n}",
        "target": 1
    },
    {
        "func": "static int xmlInitializeDict(void) {\n    if (xmlDictInitialized)\n        return(1);\n\n    if ((xmlDictMutex = xmlNewRMutex()) == NULL)\n        return(0);\n\n    xmlDictInitialized = 1;\n    return(1);\n}",
        "target": 1
    },
    {
        "func": "xmlHashComputeKey(xmlHashTablePtr table, const xmlChar *name,\n\t          const xmlChar *name2, const xmlChar *name3) {\n    unsigned long value = 0L;\n    char ch;\n    \n    if (name != NULL) {\n\tvalue += 30 * (*name);\n\twhile ((ch = *name++) != 0) {\n\t    value = value ^ ((value << 5) + (value >> 3) + (unsigned long)ch);\n\t}\n    }\n    if (name2 != NULL) {\n\twhile ((ch = *name2++) != 0) {\n\t    value = value ^ ((value << 5) + (value >> 3) + (unsigned long)ch);\n\t}\n    }\n    if (name3 != NULL) {\n\twhile ((ch = *name3++) != 0) {\n\t    value = value ^ ((value << 5) + (value >> 3) + (unsigned long)ch);\n\t}\n    }\n    return (value % table->size);\n}",
        "target": 1
    },
    {
        "func": "xmlHashCreate(int size) {\n    xmlHashTablePtr table;\n  \n    if (size <= 0)\n        size = 256;\n  \n    table = xmlMalloc(sizeof(xmlHashTable));\n    if (table) {\n        table->dict = NULL;\n        table->size = size;\n\ttable->nbElems = 0;\n        table->table = xmlMalloc(size * sizeof(xmlHashEntry));\n        if (table->table) {\n  \t    memset(table->table, 0, size * sizeof(xmlHashEntry));\n  \t    return(table);\n        }\n        xmlFree(table);\n    }\n    return(NULL);\n}",
        "target": 1
    },
    {
        "func": "xmlDictCreateSub(xmlDictPtr sub) {\n    xmlDictPtr dict = xmlDictCreate();\n\n    if ((dict != NULL) && (sub != NULL)) {\n#ifdef DICT_DEBUG_PATTERNS\n        fprintf(stderr, \"R\");\n#endif\n        dict->subdict = sub;\n\txmlDictReference(dict->subdict);\n    }\n    return(dict);\n}",
        "target": 1
    },
    {
        "func": "xmlDictComputeBigQKey(const xmlChar *prefix, int plen,\n                      const xmlChar *name, int len)\n{\n    uint32_t hash;\n    int i;\n\n    hash = 0;\n\n    for (i = 0;i < plen; i++) {\n        hash += prefix[i];\n\thash += (hash << 10);\n\thash ^= (hash >> 6);\n    }\n    hash += ':';\n    hash += (hash << 10);\n    hash ^= (hash >> 6);\n\n    for (i = 0;i < len; i++) {\n        hash += name[i];\n\thash += (hash << 10);\n\thash ^= (hash >> 6);\n    }\n    hash += (hash << 3);\n    hash ^= (hash >> 11);\n    hash += (hash << 15);\n\n    return hash;\n}",
        "target": 1
    },
    {
        "func": "xmlDictComputeFastQKey(const xmlChar *prefix, int plen,\n                       const xmlChar *name, int len)\n{\n    unsigned long value = 0L;\n\n    if (plen == 0)\n\tvalue += 30 * (unsigned long) ':';\n    else\n\tvalue += 30 * (*prefix);\n\n    if (len > 10) {\n        value += name[len - (plen + 1 + 1)];\n        len = 10;\n\tif (plen > 10)\n\t    plen = 10;\n    }\n    switch (plen) {\n        case 10: value += prefix[9];\n        case 9: value += prefix[8];\n        case 8: value += prefix[7];\n        case 7: value += prefix[6];\n        case 6: value += prefix[5];\n        case 5: value += prefix[4];\n        case 4: value += prefix[3];\n        case 3: value += prefix[2];\n        case 2: value += prefix[1];\n        case 1: value += prefix[0];\n        default: break;\n    }\n    len -= plen;\n    if (len > 0) {\n        value += (unsigned long) ':';\n\tlen--;\n    }\n    switch (len) {\n        case 10: value += name[9];\n        case 9: value += name[8];\n        case 8: value += name[7];\n        case 7: value += name[6];\n        case 6: value += name[5];\n        case 5: value += name[4];\n        case 4: value += name[3];\n        case 3: value += name[2];\n        case 2: value += name[1];\n        case 1: value += name[0];\n        default: break;\n    }\n    return(value);\n}",
        "target": 1
    },
    {
        "func": "xmlDictCreate(void) {\n    xmlDictPtr dict;\n\n    if (!xmlDictInitialized)\n        if (!xmlInitializeDict())\n            return(NULL);\n\n#ifdef DICT_DEBUG_PATTERNS\n    fprintf(stderr, \"C\");\n#endif\n\n    dict = xmlMalloc(sizeof(xmlDict));\n    if (dict) {\n        dict->ref_counter = 1;\n\n        dict->size = MIN_DICT_SIZE;\n\tdict->nbElems = 0;\n        dict->dict = xmlMalloc(MIN_DICT_SIZE * sizeof(xmlDictEntry));\n\tdict->strings = NULL;\n\tdict->subdict = NULL;\n        if (dict->dict) {\n\t    memset(dict->dict, 0, MIN_DICT_SIZE * sizeof(xmlDictEntry));\n\t    return(dict);\n        }\n        xmlFree(dict);\n    }\n    return(NULL);\n}",
        "target": 1
    },
    {
        "func": "xmlDictComputeBigKey(const xmlChar* data, int namelen) {\n    uint32_t hash;\n    int i;\n\n    if (namelen <= 0 || data == NULL) return(0);\n\n    hash = 0;\n\n    for (i = 0;i < namelen; i++) {\n        hash += data[i];\n\thash += (hash << 10);\n\thash ^= (hash >> 6);\n    }\n    hash += (hash << 3);\n    hash ^= (hash >> 11);\n    hash += (hash << 15);\n\n    return hash;\n}",
        "target": 1
    },
    {
        "func": "xsltCompilePatternInternal(const xmlChar *pattern, xmlDocPtr doc,\n\t           xmlNodePtr node, xsltStylesheetPtr style,\n\t\t   xsltTransformContextPtr runtime, int novar) {\n    xsltParserContextPtr ctxt = NULL;\n    xsltCompMatchPtr element, first = NULL, previous = NULL;\n    int current, start, end, level, j;\n\n    if (pattern == NULL) {\n\txsltTransformError(NULL, NULL, node,\n\t\t\t \"xsltCompilePattern : NULL pattern\\n\");\n\treturn(NULL);\n    }\n\n    ctxt = xsltNewParserContext(style, runtime);\n    if (ctxt == NULL)\n\treturn(NULL);\n    ctxt->doc = doc;\n    ctxt->elem = node;\n    current = end = 0;\n    while (pattern[current] != 0) {\n\tstart = current;\n\twhile (IS_BLANK_CH(pattern[current]))\n\t    current++;\n\tend = current;\n\tlevel = 0;\n\twhile ((pattern[end] != 0) && ((pattern[end] != '|') || (level != 0))) {\n\t    if (pattern[end] == '[')\n\t\tlevel++;\n\t    else if (pattern[end] == ']')\n\t\tlevel--;\n\t    else if (pattern[end] == '\\'') {\n\t\tend++;\n\t\twhile ((pattern[end] != 0) && (pattern[end] != '\\''))\n\t\t    end++;\n\t    } else if (pattern[end] == '\"') {\n\t\tend++;\n\t\twhile ((pattern[end] != 0) && (pattern[end] != '\"'))\n\t\t    end++;\n\t    }\n\t    end++;\n\t}\n\tif (current == end) {\n\t    xsltTransformError(NULL, NULL, node,\n\t\t\t     \"xsltCompilePattern : NULL pattern\\n\");\n\t    goto error;\n\t}\n\telement = xsltNewCompMatch();\n\tif (element == NULL) {\n\t    goto error;\n\t}\n\tif (first == NULL)\n\t    first = element;\n\telse if (previous != NULL)\n\t    previous->next = element;\n\tprevious = element;\n\n\tctxt->comp = element;\n\tctxt->base = xmlStrndup(&pattern[start], end - start);\n\tif (ctxt->base == NULL)\n\t    goto error;\n\tctxt->cur = &(ctxt->base)[current - start];\n\telement->pattern = ctxt->base;\n\telement->nsList = xmlGetNsList(doc, node);\n\tj = 0;\n\tif (element->nsList != NULL) {\n\t    while (element->nsList[j] != NULL)\n\t\tj++;\n\t}\n\telement->nsNr = j;\n\n\n#ifdef WITH_XSLT_DEBUG_PATTERN\n\txsltGenericDebug(xsltGenericDebugContext,\n\t\t\t \"xsltCompilePattern : parsing '%s'\\n\",\n\t\t\t element->pattern);\n#endif\n\t/*\n\t Preset default priority to be zero.\n\t This may be changed by xsltCompileLocationPathPattern.\n\t */\n\telement->priority = 0;\n\txsltCompileLocationPathPattern(ctxt, novar);\n\tif (ctxt->error) {\n\t    xsltTransformError(NULL, style, node,\n\t\t\t     \"xsltCompilePattern : failed to compile '%s'\\n\",\n\t\t\t     element->pattern);\n\t    if (style != NULL) style->errors++;\n\t    goto error;\n\t}\n\n\t/*\n\t * Reverse for faster interpretation.\n\t */\n\txsltReverseCompMatch(ctxt, element);\n\n\t/*\n\t * Set-up the priority\n\t */\n\tif (element->priority == 0) {\t/* if not yet determined */\n\t    if (((element->steps[0].op == XSLT_OP_ELEM) ||\n\t\t (element->steps[0].op == XSLT_OP_ATTR) ||\n\t\t (element->steps[0].op == XSLT_OP_PI)) &&\n\t\t(element->steps[0].value != NULL) &&\n\t\t(element->steps[1].op == XSLT_OP_END)) {\n\t\t;\t/* previously preset */\n\t    } else if ((element->steps[0].op == XSLT_OP_ATTR) &&\n\t\t       (element->steps[0].value2 != NULL) &&\n\t\t       (element->steps[1].op == XSLT_OP_END)) {\n\t\t\telement->priority = -0.25;\n\t    } else if ((element->steps[0].op == XSLT_OP_NS) &&\n\t\t       (element->steps[0].value != NULL) &&\n\t\t       (element->steps[1].op == XSLT_OP_END)) {\n\t\t\telement->priority = -0.25;\n\t    } else if ((element->steps[0].op == XSLT_OP_ATTR) &&\n\t\t       (element->steps[0].value == NULL) &&\n\t\t       (element->steps[0].value2 == NULL) &&\n\t\t       (element->steps[1].op == XSLT_OP_END)) {\n\t\t\telement->priority = -0.5;\n\t    } else if (((element->steps[0].op == XSLT_OP_PI) ||\n\t\t       (element->steps[0].op == XSLT_OP_TEXT) ||\n\t\t       (element->steps[0].op == XSLT_OP_ALL) ||\n\t\t       (element->steps[0].op == XSLT_OP_NODE) ||\n\t\t       (element->steps[0].op == XSLT_OP_COMMENT)) &&\n\t\t       (element->steps[1].op == XSLT_OP_END)) {\n\t\t\telement->priority = -0.5;\n\t    } else {\n\t\telement->priority = 0.5;\n\t    }\n\t}\n#ifdef WITH_XSLT_DEBUG_PATTERN\n\txsltGenericDebug(xsltGenericDebugContext,\n\t\t     \"xsltCompilePattern : parsed %s, default priority %f\\n\",\n\t\t\t element->pattern, element->priority);\n#endif\n\tif (pattern[end] == '|')\n\t    end++;\n\tcurrent = end;\n    }\n    if (end == 0) {\n\txsltTransformError(NULL, style, node,\n\t\t\t \"xsltCompilePattern : NULL pattern\\n\");\n\tif (style != NULL) style->errors++;\n\tgoto error;\n    }\n\n    xsltFreeParserContext(ctxt);\n    return(first);\n\nerror:\n    if (ctxt != NULL)\n\txsltFreeParserContext(ctxt);\n    if (first != NULL)\n\txsltFreeCompMatchList(first);\n    return(NULL);\n}",
        "target": 1
    },
    {
        "func": "void OverlaySettings::save(QSettings* settings_ptr) {\n\tOverlaySettings def;\n\n\tSAVELOAD(bEnable, \"enable\");\n\n\tSAVELOAD(osShow, \"show\");\n\tSAVELOAD(bAlwaysSelf, \"alwaysself\");\n\tSAVELOAD(uiActiveTime, \"activetime\");\n\tSAVELOAD(osSort, \"sort\");\n\tSAVELOAD(fX, \"x\");\n\tSAVELOAD(fY, \"y\");\n\tSAVELOAD(fZoom, \"zoom\");\n\tSAVELOAD(uiColumns, \"columns\");\n\n\tsettings_ptr->beginReadArray(QLatin1String(\"states\"));\n\tfor (int i=0; i<4; ++i) {\n\t\tsettings_ptr->setArrayIndex(i);\n\t\tSAVELOAD(qcUserName[i], \"color\");\n\t\tSAVELOAD(fUser[i], \"opacity\");\n\t}\n\tsettings_ptr->endArray();\n\n\tSAVELOAD(qfUserName, \"userfont\");\n\tSAVELOAD(qfChannel, \"channelfont\");\n\tSAVELOAD(qcChannel, \"channelcolor\");\n\tSAVELOAD(qfFps, \"fpsfont\");\n\tSAVELOAD(qcFps, \"fpscolor\");\n\n\tSAVELOAD(fBoxPad, \"padding\");\n\tSAVELOAD(fBoxPenWidth, \"penwidth\");\n\tSAVELOAD(qcBoxPen, \"pencolor\");\n\tSAVELOAD(qcBoxFill, \"fillcolor\");\n\n\tSAVELOAD(bUserName, \"usershow\");\n\tSAVELOAD(bChannel, \"channelshow\");\n\tSAVELOAD(bMutedDeafened, \"mutedshow\");\n\tSAVELOAD(bAvatar, \"avatarshow\");\n\tSAVELOAD(bBox, \"boxshow\");\n\tSAVELOAD(bFps, \"fpsshow\");\n\n\tSAVELOAD(fUserName, \"useropacity\");\n\tSAVELOAD(fChannel, \"channelopacity\");\n\tSAVELOAD(fMutedDeafened, \"mutedopacity\");\n\tSAVELOAD(fAvatar, \"avataropacity\");\n\tSAVELOAD(fFps, \"fpsopacity\");\n\n\tSAVELOAD(qrfUserName, \"userrect\");\n\tSAVELOAD(qrfChannel, \"channelrect\");\n\tSAVELOAD(qrfMutedDeafened, \"mutedrect\");\n\tSAVELOAD(qrfAvatar, \"avatarrect\");\n\tSAVELOAD(qrfFps, \"fpsrect\");\n\n\tSAVEFLAG(qaUserName, \"useralign\");\n\tSAVEFLAG(qaChannel, \"channelalign\");\n\tSAVEFLAG(qaMutedDeafened, \"mutedalign\");\n\tSAVEFLAG(qaAvatar, \"avataralign\");\n\n\tsettings_ptr->setValue(QLatin1String(\"usewhitelist\"), bUseWhitelist);\n\tsettings_ptr->setValue(QLatin1String(\"blacklist\"), qslBlacklist);\n\tsettings_ptr->setValue(QLatin1String(\"whitelist\"), qslWhitelist);\n}",
        "target": 1
    },
    {
        "func": "Database::Database() {\n\tQSqlDatabase db = QSqlDatabase::addDatabase(QLatin1String(\"QSQLITE\"));\n\tQSettings qs;\n\tQStringList datapaths;\n\tint i;\n\n\tdatapaths << g.qdBasePath.absolutePath();\n\tdatapaths << QDesktopServices::storageLocation(QDesktopServices::DataLocation);\n#if defined(Q_OS_UNIX) && ! defined(Q_OS_MAC)\n\tdatapaths << QDir::homePath() + QLatin1String(\"/.config/Mumble\");\n#endif\n\tdatapaths << QDir::homePath();\n\tdatapaths << QDir::currentPath();\n\tdatapaths << qApp->applicationDirPath();\n\tdatapaths << qs.value(QLatin1String(\"InstPath\")).toString();\n\tbool found = false;\n\n\tfor (i = 0; (i < datapaths.size()) && ! found; i++) {\n\t\tif (!datapaths[i].isEmpty()) {\n\t\t\tQFile f(datapaths[i] + QLatin1String(\"/mumble.sqlite\"));\n\t\t\tif (f.exists()) {\n\t\t\t\tdb.setDatabaseName(f.fileName());\n\t\t\t\tfound = db.open();\n\t\t\t}\n\n\t\t\tQFile f2(datapaths[i] + QLatin1String(\"/.mumble.sqlite\"));\n\t\t\tif (f2.exists()) {\n\t\t\t\tdb.setDatabaseName(f2.fileName());\n\t\t\t\tfound = db.open();\n\t\t\t}\n\t\t}\n\t}\n\n\tif (! found) {\n\t\tfor (i = 0; (i < datapaths.size()) && ! found; i++) {\n\t\t\tif (!datapaths[i].isEmpty()) {\n\t\t\t\tQDir::root().mkpath(datapaths[i]);\n#ifdef Q_OS_WIN\n\t\t\t\tQFile f(datapaths[i] + QLatin1String(\"/mumble.sqlite\"));\n#else\n\t\t\t\tQFile f(datapaths[i] + QLatin1String(\"/.mumble.sqlite\"));\n#endif\n\t\t\t\tdb.setDatabaseName(f.fileName());\n\t\t\t\tfound = db.open();\n\t\t\t}\n\t\t}\n\t}\n\n\tif (! found) {\n\t\tQMessageBox::critical(NULL, QLatin1String(\"Mumble\"), tr(\"Mumble failed to initialize a database in any\\nof the possible locations.\"), QMessageBox::Ok | QMessageBox::Default, QMessageBox::NoButton);\n\t\tqFatal(\"Database: Failed initialization\");\n\t}\n\n\tQFileInfo fi(db.databaseName());\n\n\tif (! fi.isWritable()) {\n\t\tQMessageBox::critical(NULL, QLatin1String(\"Mumble\"), tr(\"The database '%1' is read-only. Mumble cannot store server settings (i.e. SSL certificates) until you fix this problem.\").arg(fi.filePath()), QMessageBox::Ok | QMessageBox::Default, QMessageBox::NoButton);\n\t\tqWarning(\"Database: Database is read-only\");\n\t}\n\n\tQSqlQuery query;\n\n\tquery.exec(QLatin1String(\"CREATE TABLE IF NOT EXISTS `servers` (`id` INTEGER PRIMARY KEY AUTOINCREMENT, `name` TEXT, `hostname` TEXT, `port` INTEGER DEFAULT \" MUMTEXT(DEFAULT_MUMBLE_PORT) \", `username` TEXT, `password` TEXT)\"));\n\tquery.exec(QLatin1String(\"ALTER TABLE `servers` ADD COLUMN `url` TEXT\"));\n\n\tquery.exec(QLatin1String(\"CREATE TABLE IF NOT EXISTS `comments` (`who` TEXT, `comment` BLOB, `seen` DATE)\"));\n\tquery.exec(QLatin1String(\"CREATE UNIQUE INDEX IF NOT EXISTS `comments_comment` ON `comments`(`who`, `comment`)\"));\n\tquery.exec(QLatin1String(\"CREATE INDEX IF NOT EXISTS `comments_seen` ON `comments`(`seen`)\"));\n\n\tquery.exec(QLatin1String(\"CREATE TABLE IF NOT EXISTS `blobs` (`hash` TEXT, `data` BLOB, `seen` DATE)\"));\n\tquery.exec(QLatin1String(\"CREATE UNIQUE INDEX IF NOT EXISTS `blobs_hash` ON `blobs`(`hash`)\"));\n\tquery.exec(QLatin1String(\"CREATE INDEX IF NOT EXISTS `blobs_seen` ON `blobs`(`seen`)\"));\n\n\tquery.exec(QLatin1String(\"CREATE TABLE IF NOT EXISTS `tokens` (`id` INTEGER PRIMARY KEY AUTOINCREMENT, `digest` BLOB, `token` TEXT)\"));\n\tquery.exec(QLatin1String(\"CREATE INDEX IF NOT EXISTS `tokens_host_port` ON `tokens`(`digest`)\"));\n\n\tquery.exec(QLatin1String(\"CREATE TABLE IF NOT EXISTS `shortcut` (`id` INTEGER PRIMARY KEY AUTOINCREMENT, `digest` BLOB, `shortcut` BLOB, `target` BLOB, `suppress` INTEGER)\"));\n\tquery.exec(QLatin1String(\"CREATE INDEX IF NOT EXISTS `shortcut_host_port` ON `shortcut`(`digest`)\"));\n\n\tquery.exec(QLatin1String(\"CREATE TABLE IF NOT EXISTS `udp` (`id` INTEGER PRIMARY KEY AUTOINCREMENT, `digest` BLOB)\"));\n\tquery.exec(QLatin1String(\"CREATE UNIQUE INDEX IF NOT EXISTS `udp_host_port` ON `udp`(`digest`)\"));\n\n\tquery.exec(QLatin1String(\"CREATE TABLE IF NOT EXISTS `cert` (`id` INTEGER PRIMARY KEY AUTOINCREMENT, `hostname` TEXT, `port` INTEGER, `digest` TEXT)\"));\n\tquery.exec(QLatin1String(\"CREATE UNIQUE INDEX IF NOT EXISTS `cert_host_port` ON `cert`(`hostname`,`port`)\"));\n\n\tquery.exec(QLatin1String(\"CREATE TABLE IF NOT EXISTS `friends` (`id` INTEGER PRIMARY KEY AUTOINCREMENT, `name` TEXT, `hash` TEXT)\"));\n\tquery.exec(QLatin1String(\"CREATE UNIQUE INDEX IF NOT EXISTS `friends_name` ON `friends`(`name`)\"));\n\tquery.exec(QLatin1String(\"CREATE UNIQUE INDEX IF NOT EXISTS `friends_hash` ON `friends`(`hash`)\"));\n\n\tquery.exec(QLatin1String(\"CREATE TABLE IF NOT EXISTS `muted` (`id` INTEGER PRIMARY KEY AUTOINCREMENT, `hash` TEXT)\"));\n\tquery.exec(QLatin1String(\"CREATE UNIQUE INDEX IF NOT EXISTS `muted_hash` ON `muted`(`hash`)\"));\n\n\tquery.exec(QLatin1String(\"CREATE TABLE IF NOT EXISTS `pingcache` (`id` INTEGER PRIMARY KEY AUTOINCREMENT, `hostname` TEXT, `port` INTEGER, `ping` INTEGER)\"));\n\tquery.exec(QLatin1String(\"CREATE UNIQUE INDEX IF NOT EXISTS `pingcache_host_port` ON `pingcache`(`hostname`,`port`)\"));\n\n\tquery.exec(QLatin1String(\"DELETE FROM `comments` WHERE `seen` < datetime('now', '-1 years')\"));\n\tquery.exec(QLatin1String(\"DELETE FROM `blobs` WHERE `seen` < datetime('now', '-1 months')\"));\n\n\tquery.exec(QLatin1String(\"VACUUM\"));\n\n\tquery.exec(QLatin1String(\"PRAGMA synchronous = OFF\"));\n\tquery.exec(QLatin1String(\"PRAGMA journal_mode = TRUNCATE\"));\n\n\tquery.exec(QLatin1String(\"SELECT sqlite_version()\"));\n\twhile (query.next())\n\t\tqWarning() << \"Database SQLite:\" << query.value(0).toString();\n}",
        "target": 1
    },
    {
        "func": "force_sig_info(int sig, struct siginfo *info, struct task_struct *t)\n{\n\tunsigned long int flags;\n\tint ret, blocked, ignored;\n\tstruct k_sigaction *action;\n\n\tspin_lock_irqsave(&t->sighand->siglock, flags);\n\taction = &t->sighand->action[sig-1];\n\tignored = action->sa.sa_handler == SIG_IGN;\n\tblocked = sigismember(&t->blocked, sig);\n\tif (blocked || ignored) {\n\t\taction->sa.sa_handler = SIG_DFL;\n\t\tif (blocked) {\n\t\t\tsigdelset(&t->blocked, sig);\n\t\t\trecalc_sigpending_and_wake(t);\n\t\t}\n\t}\n\tif (action->sa.sa_handler == SIG_DFL)\n\t\tt->signal->flags &= ~SIGNAL_UNKILLABLE;\n\tret = specific_send_sig_info(sig, info, t);\n\tspin_unlock_irqrestore(&t->sighand->siglock, flags);\n\n\treturn ret;\n}",
        "target": 1
    },
    {
        "func": "do_notify_resume(struct pt_regs *regs, void *unused, __u32 thread_info_flags)\n{\n#ifdef CONFIG_X86_MCE\n\t/* notify userspace of pending MCEs */\n\tif (thread_info_flags & _TIF_MCE_NOTIFY)\n\t\tmce_notify_process();\n#endif /* CONFIG_X86_64 && CONFIG_X86_MCE */\n\n\t/* deal with pending signal delivery */\n\tif (thread_info_flags & _TIF_SIGPENDING)\n\t\tdo_signal(regs);\n\n\tif (thread_info_flags & _TIF_NOTIFY_RESUME) {\n\t\tclear_thread_flag(TIF_NOTIFY_RESUME);\n\t\ttracehook_notify_resume(regs);\n\t\tif (current->replacement_session_keyring)\n\t\t\tkey_replace_session_keyring();\n\t}\n\tif (thread_info_flags & _TIF_USER_RETURN_NOTIFY)\n\t\tfire_user_return_notifiers();\n\n#ifdef CONFIG_X86_32\n\tclear_thread_flag(TIF_IRET);\n#endif /* CONFIG_X86_32 */\n}",
        "target": 1
    },
    {
        "func": "dotraplinkage void do_stack_segment(struct pt_regs *regs, long error_code)\n{\n\tif (notify_die(DIE_TRAP, \"stack segment\", regs, error_code,\n\t\t\t12, SIGBUS) == NOTIFY_STOP)\n\t\treturn;\n\tpreempt_conditional_sti(regs);\n\tdo_trap(12, SIGBUS, \"stack segment\", regs, error_code, NULL);\n\tpreempt_conditional_cli(regs);\n}",
        "target": 1
    },
    {
        "func": "dotraplinkage void __kprobes do_debug(struct pt_regs *regs, long error_code)\n{\n\tstruct task_struct *tsk = current;\n\tint user_icebp = 0;\n\tunsigned long dr6;\n\tint si_code;\n\n\tget_debugreg(dr6, 6);\n\n\t/* Filter out all the reserved bits which are preset to 1 */\n\tdr6 &= ~DR6_RESERVED;\n\n\t/*\n\t * If dr6 has no reason to give us about the origin of this trap,\n\t * then it's very likely the result of an icebp/int01 trap.\n\t * User wants a sigtrap for that.\n\t */\n\tif (!dr6 && user_mode(regs))\n\t\tuser_icebp = 1;\n\n\t/* Catch kmemcheck conditions first of all! */\n\tif ((dr6 & DR_STEP) && kmemcheck_trap(regs))\n\t\treturn;\n\n\t/* DR6 may or may not be cleared by the CPU */\n\tset_debugreg(0, 6);\n\n\t/*\n\t * The processor cleared BTF, so don't mark that we need it set.\n\t */\n\tclear_tsk_thread_flag(tsk, TIF_BLOCKSTEP);\n\n\t/* Store the virtualized DR6 value */\n\ttsk->thread.debugreg6 = dr6;\n\n\tif (notify_die(DIE_DEBUG, \"debug\", regs, PTR_ERR(&dr6), error_code,\n\t\t\t\t\t\t\tSIGTRAP) == NOTIFY_STOP)\n\t\treturn;\n\n\t/* It's safe to allow irq's after DR6 has been saved */\n\tpreempt_conditional_sti(regs);\n\n\tif (regs->flags & X86_VM_MASK) {\n\t\thandle_vm86_trap((struct kernel_vm86_regs *) regs,\n\t\t\t\terror_code, 1);\n\t\tpreempt_conditional_cli(regs);\n\t\treturn;\n\t}\n\n\t/*\n\t * Single-stepping through system calls: ignore any exceptions in\n\t * kernel space, but re-enable TF when returning to user mode.\n\t *\n\t * We already checked v86 mode above, so we can check for kernel mode\n\t * by just checking the CPL of CS.\n\t */\n\tif ((dr6 & DR_STEP) && !user_mode(regs)) {\n\t\ttsk->thread.debugreg6 &= ~DR_STEP;\n\t\tset_tsk_thread_flag(tsk, TIF_SINGLESTEP);\n\t\tregs->flags &= ~X86_EFLAGS_TF;\n\t}\n\tsi_code = get_si_code(tsk->thread.debugreg6);\n\tif (tsk->thread.debugreg6 & (DR_STEP | DR_TRAP_BITS) || user_icebp)\n\t\tsend_sigtrap(tsk, regs, error_code, si_code);\n\tpreempt_conditional_cli(regs);\n\n\treturn;\n}",
        "target": 1
    },
    {
        "func": "static inline void preempt_conditional_sti(struct pt_regs *regs)\n{\n\tinc_preempt_count();\n\tif (regs->flags & X86_EFLAGS_IF)\n\t\tlocal_irq_enable();\n}",
        "target": 1
    },
    {
        "func": "dotraplinkage void __kprobes do_int3(struct pt_regs *regs, long error_code)\n{\n#ifdef CONFIG_KGDB_LOW_LEVEL_TRAP\n\tif (kgdb_ll_trap(DIE_INT3, \"int3\", regs, error_code, 3, SIGTRAP)\n\t\t\t== NOTIFY_STOP)\n\t\treturn;\n#endif /* CONFIG_KGDB_LOW_LEVEL_TRAP */\n#ifdef CONFIG_KPROBES\n\tif (notify_die(DIE_INT3, \"int3\", regs, error_code, 3, SIGTRAP)\n\t\t\t== NOTIFY_STOP)\n\t\treturn;\n#else\n\tif (notify_die(DIE_TRAP, \"int3\", regs, error_code, 3, SIGTRAP)\n\t\t\t== NOTIFY_STOP)\n\t\treturn;\n#endif\n\n\tpreempt_conditional_sti(regs);\n\tdo_trap(3, SIGTRAP, \"int3\", regs, error_code, NULL);\n\tpreempt_conditional_cli(regs);\n}",
        "target": 1
    },
    {
        "func": "static inline void preempt_conditional_cli(struct pt_regs *regs)\n{\n\tif (regs->flags & X86_EFLAGS_IF)\n\t\tlocal_irq_disable();\n\tdec_preempt_count();\n}",
        "target": 1
    },
    {
        "func": "void APE::Properties::analyzeCurrent()\n{\n  // Read the descriptor\n  d->file->seek(2, File::Current);\n  ByteVector descriptor = d->file->readBlock(44);\n  uint descriptorBytes = descriptor.mid(0,4).toUInt(false);\n\n  if ((descriptorBytes - 52) > 0)\n    d->file->seek(descriptorBytes - 52, File::Current);\n\n  // Read the header\n  ByteVector header = d->file->readBlock(24);\n\n  // Get the APE info\n  d->channels = header.mid(18, 2).toShort(false);\n  d->sampleRate = header.mid(20, 4).toUInt(false);\n  d->bitsPerSample = header.mid(16, 2).toShort(false);\n  //d->compressionLevel =\n\n  uint totalFrames = header.mid(12, 4).toUInt(false);\n  uint blocksPerFrame = header.mid(4, 4).toUInt(false);\n  uint finalFrameBlocks = header.mid(8, 4).toUInt(false);\n  uint totalBlocks = totalFrames > 0 ? (totalFrames -  1) * blocksPerFrame + finalFrameBlocks : 0;\n  d->length = totalBlocks / d->sampleRate;\n  d->bitrate = d->length > 0 ? ((d->streamLength * 8L) / d->length) / 1000 : 0;\n}",
        "target": 1
    },
    {
        "func": "void Ogg::XiphComment::parse(const ByteVector &data)\n{\n  // The first thing in the comment data is the vendor ID length, followed by a\n  // UTF8 string with the vendor ID.\n\n  uint pos = 0;\n\n  int vendorLength = data.mid(0, 4).toUInt(false);\n  pos += 4;\n\n  d->vendorID = String(data.mid(pos, vendorLength), String::UTF8);\n  pos += vendorLength;\n\n  // Next the number of fields in the comment vector.\n\n  uint commentFields = data.mid(pos, 4).toUInt(false);\n  pos += 4;\n\n  if(commentFields > (data.size() - 8) / 4) {\n    return;\n  }\n\n  for(uint i = 0; i < commentFields; i++) {\n\n    // Each comment field is in the format \"KEY=value\" in a UTF8 string and has\n    // 4 bytes before the text starts that gives the length.\n\n    uint commentLength = data.mid(pos, 4).toUInt(false);\n    pos += 4;\n\n    String comment = String(data.mid(pos, commentLength), String::UTF8);\n    pos += commentLength;\n    if(pos > data.size()) {\n      break;\n    }\n\n    int commentSeparatorPosition = comment.find(\"=\");\n    if(commentSeparatorPosition == -1) {\n      break;\n    }\n\n    String key = comment.substr(0, commentSeparatorPosition);\n    String value = comment.substr(commentSeparatorPosition + 1);\n\n    addField(key, value, false);\n  }\n}",
        "target": 1
    },
    {
        "func": "void Ogg::XiphComment::parse(const ByteVector &data)\n{\n  // The first thing in the comment data is the vendor ID length, followed by a\n  // UTF8 string with the vendor ID.\n\n  int pos = 0;\n\n  int vendorLength = data.mid(0, 4).toUInt(false);\n  pos += 4;\n\n  d->vendorID = String(data.mid(pos, vendorLength), String::UTF8);\n  pos += vendorLength;\n\n  // Next the number of fields in the comment vector.\n\n  int commentFields = data.mid(pos, 4).toUInt(false);\n  pos += 4;\n\n  for(int i = 0; i < commentFields; i++) {\n\n    // Each comment field is in the format \"KEY=value\" in a UTF8 string and has\n    // 4 bytes before the text starts that gives the length.\n\n    int commentLength = data.mid(pos, 4).toUInt(false);\n    pos += 4;\n\n    String comment = String(data.mid(pos, commentLength), String::UTF8);\n    pos += commentLength;\n\n    int commentSeparatorPosition = comment.find(\"=\");\n\n    String key = comment.substr(0, commentSeparatorPosition);\n    String value = comment.substr(commentSeparatorPosition + 1);\n\n    addField(key, value, false);\n  }\n}",
        "target": 1
    },
    {
        "func": "_pyfribidi_log2vis (PyObject * self, PyObject * args, PyObject * kw)\n{\n\tPyObject *logical = NULL;\t/* input unicode or string object */\n\tFriBidiParType base = FRIBIDI_TYPE_RTL;\t/* optional direction */\n\tconst char *encoding = \"utf-8\";\t/* optional input string encoding */\n\tint clean = 0; /* optional flag to clean the string */\n\tint reordernsm = 1; /* optional flag to allow reordering of non spacing marks*/\n\n\tstatic char *kwargs[] =\n\t        { \"logical\", \"base_direction\", \"encoding\", \"clean\", \"reordernsm\", NULL };\n\n        if (!PyArg_ParseTupleAndKeywords (args, kw, \"O|isii\", kwargs,\n\t\t\t\t\t  &logical, &base, &encoding, &clean, &reordernsm))\n\t\treturn NULL;\n\n\t/* Validate base */\n\n\tif (!(base == FRIBIDI_TYPE_RTL ||\n\t      base == FRIBIDI_TYPE_LTR || base == FRIBIDI_TYPE_ON))\n\t\treturn PyErr_Format (PyExc_ValueError,\n\t\t\t\t     \"invalid value %d: use either RTL, LTR or ON\",\n\t\t\t\t     base);\n\n\t/* Check object type and delegate to one of the log2vis functions */\n\n\tif (PyUnicode_Check (logical))\n\t        return log2vis_unicode (logical, base, clean, reordernsm);\n\telse if (PyString_Check (logical))\n\t        return log2vis_encoded_string (logical, encoding, base, clean, reordernsm);\n\telse\n\t\treturn PyErr_Format (PyExc_TypeError,\n\t\t\t\t     \"expected unicode or str, not %s\",\n\t\t\t\t     logical->ob_type->tp_name);\n}",
        "target": 1
    },
    {
        "func": "log2vis_unicode (PyObject * unicode, FriBidiParType base_direction, int clean, int reordernsm)\n{\n\tPyObject *logical = NULL;\t/* input string encoded in utf-8 */\n\tPyObject *visual = NULL;\t/* output string encoded in utf-8 */\n\tPyObject *result = NULL;\t/* unicode output string */\n\n\tint length = PyUnicode_GET_SIZE (unicode);\n\n\tlogical = PyUnicode_AsUTF8String (unicode);\n\tif (logical == NULL)\n\t\tgoto cleanup;\n\n\tvisual = log2vis_utf8 (logical, length, base_direction, clean, reordernsm);\n\tif (visual == NULL)\n\t\tgoto cleanup;\n\n\tresult = PyUnicode_DecodeUTF8 (PyString_AS_STRING (visual),\n\t\t\t\t       PyString_GET_SIZE (visual), \"strict\");\n\n      cleanup:\n\tPy_XDECREF (logical);\n\tPy_XDECREF (visual);\n\n\treturn result;\n}",
        "target": 1
    },
    {
        "func": "log2vis_encoded_string (PyObject * string, const char *encoding,\n\t\t\tFriBidiParType base_direction, int clean, int reordernsm)\n{\n\tPyObject *logical = NULL;\t/* logical unicode object */\n\tPyObject *result = NULL;\t/* output string object */\n\n\t/* Always needed for the string length */\n\tlogical = PyUnicode_Decode (PyString_AS_STRING (string),\n\t\t\t\t    PyString_GET_SIZE (string),\n\t\t\t\t    encoding, \"strict\");\n\tif (logical == NULL)\n\t\treturn NULL;\n\n\tif (strcmp (encoding, \"utf-8\") == 0)\n\t\t/* Shortcut for utf8 strings (little faster) */\n\t\tresult = log2vis_utf8 (string,\n\t\t\t\t       PyUnicode_GET_SIZE (logical),\n\t\t\t\t       base_direction, clean, reordernsm);\n\telse\n\t{\n\t\t/* Invoke log2vis_unicode and encode back to encoding */\n\n\t\tPyObject *visual = log2vis_unicode (logical, base_direction, clean, reordernsm);\n\n\t\tif (visual)\n\t\t{\n\t\t\tresult = PyUnicode_Encode (PyUnicode_AS_UNICODE\n\t\t\t\t\t\t   (visual),\n\t\t\t\t\t\t   PyUnicode_GET_SIZE (visual),\n\t\t\t\t\t\t   encoding, \"strict\");\n\t\t\tPy_DECREF (visual);\n\t\t}\n\t}\n\n\tPy_DECREF (logical);\n\n\treturn result;\n}",
        "target": 1
    },
    {
        "func": "initpyfribidi (void)\n{\n\tPyObject *module;\n\n\t/* XXX What should be done if we fail here? */\n\n\tmodule = Py_InitModule3 (\"pyfribidi\", PyfribidiMethods,\n\t\t\t\t _pyfribidi__doc__);\n\n\tPyModule_AddIntConstant (module, \"RTL\", (long) FRIBIDI_TYPE_RTL);\n\tPyModule_AddIntConstant (module, \"LTR\", (long) FRIBIDI_TYPE_LTR);\n\tPyModule_AddIntConstant (module, \"ON\", (long) FRIBIDI_TYPE_ON);\n\n\tPyModule_AddStringConstant (module, \"__author__\",\n\t\t\t\t    \"Yaacov Zamir and Nir Soffer\");\n}",
        "target": 1
    },
    {
        "func": "log2vis_utf8 (PyObject * string, int unicode_length,\n\t      FriBidiParType base_direction, int clean, int reordernsm)\n{\n\tFriBidiChar *logical = NULL; /* input fribidi unicode buffer */\n\tFriBidiChar *visual = NULL;\t /* output fribidi unicode buffer */\n\tchar *visual_utf8 = NULL;    /* output fribidi UTF-8 buffer */\n\tFriBidiStrIndex new_len = 0; /* length of the UTF-8 buffer */\n\tPyObject *result = NULL;\t /* failure */\n\n\t/* Allocate fribidi unicode buffers */\n\n\tlogical = PyMem_New (FriBidiChar, unicode_length + 1);\n\tif (logical == NULL)\n\t{\n\t\tPyErr_SetString (PyExc_MemoryError,\n\t\t\t\t \"failed to allocate unicode buffer\");\n\t\tgoto cleanup;\n\t}\n\n\tvisual = PyMem_New (FriBidiChar, unicode_length + 1);\n\tif (visual == NULL)\n\t{\n\t\tPyErr_SetString (PyExc_MemoryError,\n\t\t\t\t \"failed to allocate unicode buffer\");\n\t\tgoto cleanup;\n\t}\n\n\t/* Convert to unicode and order visually */\n\tfribidi_set_reorder_nsm(reordernsm);\n\tfribidi_utf8_to_unicode (PyString_AS_STRING (string),\n\t\t\t\t PyString_GET_SIZE (string), logical);\n\n\tif (!fribidi_log2vis (logical, unicode_length, &base_direction, visual,\n\t\t\t      NULL, NULL, NULL))\n\t{\n\t\tPyErr_SetString (PyExc_RuntimeError,\n\t\t\t\t \"fribidi failed to order string\");\n\t\tgoto cleanup;\n\t}\n\n\t/* Cleanup the string if requested */\n\tif (clean)\n\t\tfribidi_remove_bidi_marks (visual, unicode_length, NULL, NULL, NULL);\n\n\t/* Allocate fribidi UTF-8 buffer */\n\n\tvisual_utf8 = PyMem_New(char, (unicode_length * 4)+1);\n\tif (visual_utf8 == NULL)\n\t{\n\t\tPyErr_SetString (PyExc_MemoryError,\n\t\t\t\t\"failed to allocate UTF-8 buffer\");\n\t\tgoto cleanup;\n\t}\n\n\t/* Encode the reordered string  and create result string */\n\n\tnew_len = fribidi_unicode_to_utf8 (visual, unicode_length, visual_utf8);\n\n\tresult = PyString_FromStringAndSize (visual_utf8, new_len);\n\tif (result == NULL)\n\t\t/* XXX does it raise any error? */\n\t\tgoto cleanup;\n\n      cleanup:\n\t/* Delete unicode buffers */\n\tPyMem_Del (logical);\n\tPyMem_Del (visual);\n\tPyMem_Del (visual_utf8);\n\n\treturn result;\n}",
        "target": 1
    },
    {
        "func": "bgp_capability_as4 (struct peer *peer, struct capability_header *hdr)\n{\n  as_t as4 = stream_getl (BGP_INPUT(peer));\n  \n  if (BGP_DEBUG (as4, AS4))\n    zlog_debug (\"%s [AS4] about to set cap PEER_CAP_AS4_RCV, got as4 %u\",\n                peer->host, as4);\n  SET_FLAG (peer->cap, PEER_CAP_AS4_RCV);\n  \n  return as4;\n}",
        "target": 1
    },
    {
        "func": "peek_for_as4_capability (struct peer *peer, u_char length)\n{\n  struct stream *s = BGP_INPUT (peer);\n  size_t orig_getp = stream_get_getp (s);\n  size_t end = orig_getp + length;\n  as_t as4 = 0;\n  \n  /* The full capability parser will better flag the error.. */\n  if (STREAM_READABLE(s) < length)\n    return 0;\n\n  if (BGP_DEBUG (as4, AS4))\n    zlog_info (\"%s [AS4] rcv OPEN w/ OPTION parameter len: %u,\"\n                \" peeking for as4\",\n\t        peer->host, length);\n  /* the error cases we DONT handle, we ONLY try to read as4 out of\n   * correctly formatted options.\n   */\n  while (stream_get_getp(s) < end) \n    {\n      u_char opt_type;\n      u_char opt_length;\n      \n      /* Check the length. */\n      if (stream_get_getp (s) + 2 > end)\n        goto end;\n      \n      /* Fetch option type and length. */\n      opt_type = stream_getc (s);\n      opt_length = stream_getc (s);\n      \n      /* Option length check. */\n      if (stream_get_getp (s) + opt_length > end)\n        goto end;\n      \n      if (opt_type == BGP_OPEN_OPT_CAP)\n        {\n          unsigned long capd_start = stream_get_getp (s);\n          unsigned long capd_end = capd_start + opt_length;\n          \n          assert (capd_end <= end);\n          \n\t  while (stream_get_getp (s) < capd_end)\n\t    {\n\t      struct capability_header hdr;\n\t      \n\t      if (stream_get_getp (s) + 2 > capd_end)\n                goto end;\n              \n              hdr.code = stream_getc (s);\n              hdr.length = stream_getc (s);\n              \n\t      if ((stream_get_getp(s) +  hdr.length) > capd_end)\n\t\tgoto end;\n\n\t      if (hdr.code == CAPABILITY_CODE_AS4)\n\t        {\n\t          if (hdr.length != CAPABILITY_CODE_AS4_LEN)\n\t            goto end;\n                  \n\t          if (BGP_DEBUG (as4, AS4))\n\t            zlog_info (\"[AS4] found AS4 capability, about to parse\");\n\t          as4 = bgp_capability_as4 (peer, &hdr);\n\t          \n\t          goto end;\n                }\n              stream_forward_getp (s, hdr.length);\n\t    }\n\t}\n    }\n\nend:\n  stream_set_getp (s, orig_getp);\n  return as4;\n}",
        "target": 1
    },
    {
        "func": "bgp_open_receive (struct peer *peer, bgp_size_t size)\n{\n  int ret;\n  u_char version;\n  u_char optlen;\n  u_int16_t holdtime;\n  u_int16_t send_holdtime;\n  as_t remote_as;\n  as_t as4 = 0;\n  struct peer *realpeer;\n  struct in_addr remote_id;\n  int capability;\n  u_int8_t notify_data_remote_as[2];\n  u_int8_t notify_data_remote_id[4];\n\n  realpeer = NULL;\n  \n  /* Parse open packet. */\n  version = stream_getc (peer->ibuf);\n  memcpy (notify_data_remote_as, stream_pnt (peer->ibuf), 2);\n  remote_as  = stream_getw (peer->ibuf);\n  holdtime = stream_getw (peer->ibuf);\n  memcpy (notify_data_remote_id, stream_pnt (peer->ibuf), 4);\n  remote_id.s_addr = stream_get_ipv4 (peer->ibuf);\n\n  /* Receive OPEN message log  */\n  if (BGP_DEBUG (normal, NORMAL))\n    zlog_debug (\"%s rcv OPEN, version %d, remote-as (in open) %u,\"\n                \" holdtime %d, id %s\",\n\t        peer->host, version, remote_as, holdtime,\n\t        inet_ntoa (remote_id));\n  \n  /* BEGIN to read the capability here, but dont do it yet */\n  capability = 0;\n  optlen = stream_getc (peer->ibuf);\n  \n  if (optlen != 0)\n    {\n      /* We need the as4 capability value *right now* because\n       * if it is there, we have not got the remote_as yet, and without\n       * that we do not know which peer is connecting to us now.\n       */ \n      as4 = peek_for_as4_capability (peer, optlen);\n    }\n  \n  /* Just in case we have a silly peer who sends AS4 capability set to 0 */\n  if (CHECK_FLAG (peer->cap, PEER_CAP_AS4_RCV) && !as4)\n    {\n      zlog_err (\"%s bad OPEN, got AS4 capability, but AS4 set to 0\",\n                peer->host);\n      bgp_notify_send (peer, BGP_NOTIFY_OPEN_ERR,\n                       BGP_NOTIFY_OPEN_BAD_PEER_AS);\n      return -1;\n    }\n  \n  if (remote_as == BGP_AS_TRANS)\n    {\n\t  /* Take the AS4 from the capability.  We must have received the\n\t   * capability now!  Otherwise we have a asn16 peer who uses\n\t   * BGP_AS_TRANS, for some unknown reason.\n\t   */\n      if (as4 == BGP_AS_TRANS)\n        {\n          zlog_err (\"%s [AS4] NEW speaker using AS_TRANS for AS4, not allowed\",\n                    peer->host);\n          bgp_notify_send (peer, BGP_NOTIFY_OPEN_ERR,\n                 BGP_NOTIFY_OPEN_BAD_PEER_AS);\n          return -1;\n        }\n      \n      if (!as4 && BGP_DEBUG (as4, AS4))\n        zlog_debug (\"%s [AS4] OPEN remote_as is AS_TRANS, but no AS4.\"\n                    \" Odd, but proceeding.\", peer->host);\n      else if (as4 < BGP_AS_MAX && BGP_DEBUG (as4, AS4))\n        zlog_debug (\"%s [AS4] OPEN remote_as is AS_TRANS, but AS4 (%u) fits \"\n                    \"in 2-bytes, very odd peer.\", peer->host, as4);\n      if (as4)\n        remote_as = as4;\n    } \n  else \n    {\n      /* We may have a partner with AS4 who has an asno < BGP_AS_MAX */\n      /* If we have got the capability, peer->as4cap must match remote_as */\n      if (CHECK_FLAG (peer->cap, PEER_CAP_AS4_RCV)\n          && as4 != remote_as)\n        {\n\t  /* raise error, log this, close session */\n\t  zlog_err (\"%s bad OPEN, got AS4 capability, but remote_as %u\"\n\t            \" mismatch with 16bit 'myasn' %u in open\",\n\t            peer->host, as4, remote_as);\n\t  bgp_notify_send (peer, BGP_NOTIFY_OPEN_ERR,\n\t\t\t   BGP_NOTIFY_OPEN_BAD_PEER_AS);\n\t  return -1;\n\t}\n    }\n\n  /* Lookup peer from Open packet. */\n  if (CHECK_FLAG (peer->sflags, PEER_STATUS_ACCEPT_PEER))\n    {\n      int as = 0;\n\n      realpeer = peer_lookup_with_open (&peer->su, remote_as, &remote_id, &as);\n\n      if (! realpeer)\n\t{\n\t  /* Peer's source IP address is check in bgp_accept(), so this\n\t     must be AS number mismatch or remote-id configuration\n\t     mismatch. */\n\t  if (as)\n\t    {\n\t      if (BGP_DEBUG (normal, NORMAL))\n\t\tzlog_debug (\"%s bad OPEN, wrong router identifier %s\",\n\t\t\t    peer->host, inet_ntoa (remote_id));\n\t      bgp_notify_send_with_data (peer, BGP_NOTIFY_OPEN_ERR, \n\t\t\t\t\t BGP_NOTIFY_OPEN_BAD_BGP_IDENT,\n\t\t\t\t\t notify_data_remote_id, 4);\n\t    }\n\t  else\n\t    {\n\t      if (BGP_DEBUG (normal, NORMAL))\n\t\tzlog_debug (\"%s bad OPEN, remote AS is %u, expected %u\",\n\t\t\t    peer->host, remote_as, peer->as);\n\t      bgp_notify_send_with_data (peer, BGP_NOTIFY_OPEN_ERR,\n\t\t\t\t\t BGP_NOTIFY_OPEN_BAD_PEER_AS,\n\t\t\t\t\t notify_data_remote_as, 2);\n\t    }\n\t  return -1;\n\t}\n    }\n\n  /* When collision is detected and this peer is closed.  Retrun\n     immidiately. */\n  ret = bgp_collision_detect (peer, remote_id);\n  if (ret < 0)\n    return ret;\n\n  /* Hack part. */\n  if (CHECK_FLAG (peer->sflags, PEER_STATUS_ACCEPT_PEER))\n    {\n\tif (realpeer->status == Established\n\t    && CHECK_FLAG (realpeer->sflags, PEER_STATUS_NSF_MODE))\n\t{\n\t  realpeer->last_reset = PEER_DOWN_NSF_CLOSE_SESSION;\n\t  SET_FLAG (realpeer->sflags, PEER_STATUS_NSF_WAIT);\n\t}\n\telse if (ret == 0 && realpeer->status != Active\n\t         && realpeer->status != OpenSent\n\t\t && realpeer->status != OpenConfirm\n\t\t && realpeer->status != Connect)\n \t{\n \t  /* XXX: This is an awful problem.. \n \t   *\n \t   * According to the RFC we should just let this connection (of the\n \t   * accepted 'peer') continue on to Established if the other\n \t   * connection (the 'realpeer' one) is in state Connect, and deal\n \t   * with the more larval FSM as/when it gets far enough to receive\n \t   * an Open. We don't do that though, we instead close the (more\n \t   * developed) accepted connection.\n \t   *\n \t   * This means there's a race, which if hit, can loop:\n \t   *\n \t   *       FSM for A                        FSM for B\n \t   *  realpeer     accept-peer       realpeer     accept-peer\n \t   *\n \t   *  Connect                        Connect\n \t   *               Active\n \t   *               OpenSent          OpenSent\n \t   *               <arrive here,\n \t   *               Notify, delete>   \n \t   *                                 Idle         Active\n \t   *   OpenSent                                   OpenSent\n \t   *                                              <arrive here,\n \t   *                                              Notify, delete>\n \t   *   Idle\n \t   *   <wait>                        <wait>\n \t   *   Connect                       Connect\n \t   *\n           *\n \t   * If both sides are Quagga, they're almost certain to wait for\n \t   * the same amount of time of course (which doesn't preclude other\n \t   * implementations also waiting for same time). The race is\n \t   * exacerbated by high-latency (in bgpd and/or the network).\n \t   *\n \t   * The reason we do this is because our FSM is tied to our peer\n \t   * structure, which carries our configuration information, etc. \n \t   * I.e. we can't let the accepted-peer FSM continue on as it is,\n \t   * cause it's not associated with any actual peer configuration -\n \t   * it's just a dummy.\n \t   *\n \t   * It's possible we could hack-fix this by just bgp_stop'ing the\n \t   * realpeer and continueing on with the 'transfer FSM' below. \n \t   * Ideally, we need to seperate FSMs from struct peer.\n \t   *\n \t   * Setting one side to passive avoids the race, as a workaround.\n \t   */\n \t  if (BGP_DEBUG (events, EVENTS))\n\t    zlog_debug (\"%s peer status is %s close connection\",\n\t\t\trealpeer->host, LOOKUP (bgp_status_msg,\n\t\t\trealpeer->status));\n\t  bgp_notify_send (peer, BGP_NOTIFY_CEASE,\n\t\t\t   BGP_NOTIFY_CEASE_CONNECT_REJECT);\n\n \t  return -1;\n \t}\n\n      if (BGP_DEBUG (events, EVENTS))\n\tzlog_debug (\"%s [Event] Transfer accept BGP peer to real (state %s)\",\n\t\t   peer->host, \n\t\t   LOOKUP (bgp_status_msg, realpeer->status));\n\n      bgp_stop (realpeer);\n      \n      /* Transfer file descriptor. */\n      realpeer->fd = peer->fd;\n      peer->fd = -1;\n\n      /* Transfer input buffer. */\n      stream_free (realpeer->ibuf);\n      realpeer->ibuf = peer->ibuf;\n      realpeer->packet_size = peer->packet_size;\n      peer->ibuf = NULL;\n\n      /* Transfer status. */\n      realpeer->status = peer->status;\n      bgp_stop (peer);\n      \n      /* peer pointer change. Open packet send to neighbor. */\n      peer = realpeer;\n      bgp_open_send (peer);\n      if (peer->fd < 0)\n\t{\n\t  zlog_err (\"bgp_open_receive peer's fd is negative value %d\",\n\t\t    peer->fd);\n\t  return -1;\n\t}\n      BGP_READ_ON (peer->t_read, bgp_read, peer->fd);\n    }\n\n  /* remote router-id check. */\n  if (remote_id.s_addr == 0\n      || IPV4_CLASS_DE (ntohl (remote_id.s_addr))\n      || ntohl (peer->local_id.s_addr) == ntohl (remote_id.s_addr))\n    {\n      if (BGP_DEBUG (normal, NORMAL))\n\tzlog_debug (\"%s bad OPEN, wrong router identifier %s\",\n\t\t   peer->host, inet_ntoa (remote_id));\n      bgp_notify_send_with_data (peer, \n\t\t\t\t BGP_NOTIFY_OPEN_ERR, \n\t\t\t\t BGP_NOTIFY_OPEN_BAD_BGP_IDENT,\n\t\t\t\t notify_data_remote_id, 4);\n      return -1;\n    }\n\n  /* Set remote router-id */\n  peer->remote_id = remote_id;\n\n  /* Peer BGP version check. */\n  if (version != BGP_VERSION_4)\n    {\n      u_int8_t maxver = BGP_VERSION_4;\n      if (BGP_DEBUG (normal, NORMAL))\n\tzlog_debug (\"%s bad protocol version, remote requested %d, local request %d\",\n\t\t   peer->host, version, BGP_VERSION_4);\n      bgp_notify_send_with_data (peer, \n\t\t\t\t BGP_NOTIFY_OPEN_ERR, \n\t\t\t\t BGP_NOTIFY_OPEN_UNSUP_VERSION,\n\t\t\t\t &maxver, 1);\n      return -1;\n    }\n\n  /* Check neighbor as number. */\n  if (remote_as != peer->as)\n    {\n      if (BGP_DEBUG (normal, NORMAL))\n\tzlog_debug (\"%s bad OPEN, remote AS is %u, expected %u\",\n\t\t   peer->host, remote_as, peer->as);\n      bgp_notify_send_with_data (peer, \n\t\t\t\t BGP_NOTIFY_OPEN_ERR, \n\t\t\t\t BGP_NOTIFY_OPEN_BAD_PEER_AS,\n\t\t\t\t notify_data_remote_as, 2);\n      return -1;\n    }\n\n  /* From the rfc: Upon receipt of an OPEN message, a BGP speaker MUST\n     calculate the value of the Hold Timer by using the smaller of its\n     configured Hold Time and the Hold Time received in the OPEN message.\n     The Hold Time MUST be either zero or at least three seconds.  An\n     implementation may reject connections on the basis of the Hold Time. */\n\n  if (holdtime < 3 && holdtime != 0)\n    {\n      bgp_notify_send (peer,\n\t\t       BGP_NOTIFY_OPEN_ERR, \n\t\t       BGP_NOTIFY_OPEN_UNACEP_HOLDTIME);\n      return -1;\n    }\n    \n  /* From the rfc: A reasonable maximum time between KEEPALIVE messages\n     would be one third of the Hold Time interval.  KEEPALIVE messages\n     MUST NOT be sent more frequently than one per second.  An\n     implementation MAY adjust the rate at which it sends KEEPALIVE\n     messages as a function of the Hold Time interval. */\n\n  if (CHECK_FLAG (peer->config, PEER_CONFIG_TIMER))\n    send_holdtime = peer->holdtime;\n  else\n    send_holdtime = peer->bgp->default_holdtime;\n\n  if (holdtime < send_holdtime)\n    peer->v_holdtime = holdtime;\n  else\n    peer->v_holdtime = send_holdtime;\n\n  peer->v_keepalive = peer->v_holdtime / 3;\n\n  /* Open option part parse. */\n  if (optlen != 0) \n    {\n      ret = bgp_open_option_parse (peer, optlen, &capability);\n      if (ret < 0)\n\treturn ret;\n    }\n  else\n    {\n      if (BGP_DEBUG (normal, NORMAL))\n\tzlog_debug (\"%s rcvd OPEN w/ OPTION parameter len: 0\",\n\t\t   peer->host);\n    }\n\n  /* Override capability. */\n  if (! capability || CHECK_FLAG (peer->flags, PEER_FLAG_OVERRIDE_CAPABILITY))\n    {\n      peer->afc_nego[AFI_IP][SAFI_UNICAST] = peer->afc[AFI_IP][SAFI_UNICAST];\n      peer->afc_nego[AFI_IP][SAFI_MULTICAST] = peer->afc[AFI_IP][SAFI_MULTICAST];\n      peer->afc_nego[AFI_IP6][SAFI_UNICAST] = peer->afc[AFI_IP6][SAFI_UNICAST];\n      peer->afc_nego[AFI_IP6][SAFI_MULTICAST] = peer->afc[AFI_IP6][SAFI_MULTICAST];\n    }\n\n  /* Get sockname. */\n  bgp_getsockname (peer);\n\n  BGP_EVENT_ADD (peer, Receive_OPEN_message);\n\n  peer->packet_size = 0;\n  if (peer->ibuf)\n    stream_reset (peer->ibuf);\n\n  return 0;\n}",
        "target": 1
    },
    {
        "func": "int gnutls_pcert_import_openpgp (gnutls_pcert_st* pcert,\n\tgnutls_openpgp_crt_t crt, unsigned int flags)\n{\nint ret;\nsize_t sz;\n\n  memset(pcert, 0, sizeof(*pcert));\n\n  pcert->type = GNUTLS_CRT_OPENPGP;\n  pcert->cert.data = NULL;\n\n  sz = 0;\n  ret = gnutls_openpgp_crt_export(crt, GNUTLS_OPENPGP_FMT_RAW, NULL, &sz);\n  if (ret < 0 && ret != GNUTLS_E_SHORT_MEMORY_BUFFER)\n    {\n      ret = gnutls_assert_val(ret);\n      goto cleanup;\n    }\n\n  pcert->cert.data = gnutls_malloc(sz);\n  if (pcert->cert.data == NULL)\n    {\n      ret = gnutls_assert_val(GNUTLS_E_MEMORY_ERROR);\n      goto cleanup;\n    }\n\n  ret = gnutls_openpgp_crt_export(crt, GNUTLS_X509_FMT_DER, pcert->cert.data, &sz);\n  if (ret < 0)\n    {\n      ret = gnutls_assert_val(ret);\n      goto cleanup;\n    }\n  pcert->cert.size = sz;\n\n  ret = gnutls_pubkey_init(&pcert->pubkey);\n  if (ret < 0)\n    {\n      ret = gnutls_assert_val(ret);\n      goto cleanup;\n    }\n\n  ret = gnutls_pubkey_import_openpgp(pcert->pubkey, crt, 0);\n  if (ret < 0)\n    {\n      gnutls_pubkey_deinit(pcert->pubkey);\n      ret = gnutls_assert_val(ret);\n      goto cleanup;\n    }\n\n  return 0;\n\ncleanup:\n  gnutls_free(pcert->cert.data);\n\n  return ret;\n}",
        "target": 1
    },
    {
        "func": "_gnutls_proc_x509_server_certificate (gnutls_session_t session,\n                                      uint8_t * data, size_t data_size)\n{\n  int size, len, ret;\n  uint8_t *p = data;\n  cert_auth_info_t info;\n  gnutls_certificate_credentials_t cred;\n  ssize_t dsize = data_size;\n  int i;\n  gnutls_pcert_st *peer_certificate_list;\n  size_t peer_certificate_list_size = 0, j, x;\n  gnutls_datum_t tmp;\n\n  cred = (gnutls_certificate_credentials_t)\n    _gnutls_get_cred (session->key, GNUTLS_CRD_CERTIFICATE, NULL);\n  if (cred == NULL)\n    {\n      gnutls_assert ();\n      return GNUTLS_E_INSUFFICIENT_CREDENTIALS;\n    }\n\n\n  if ((ret =\n       _gnutls_auth_info_set (session, GNUTLS_CRD_CERTIFICATE,\n                              sizeof (cert_auth_info_st), 1)) < 0)\n    {\n      gnutls_assert ();\n      return ret;\n    }\n\n  info = _gnutls_get_auth_info (session);\n\n  if (data == NULL || data_size == 0)\n    {\n      gnutls_assert ();\n      /* no certificate was sent */\n      return GNUTLS_E_NO_CERTIFICATE_FOUND;\n    }\n\n  DECR_LEN (dsize, 3);\n  size = _gnutls_read_uint24 (p);\n  p += 3;\n\n  /* some implementations send 0B 00 00 06 00 00 03 00 00 00\n   * instead of just 0B 00 00 03 00 00 00 as an empty certificate message.\n   */\n  if (size == 0 || size == 3)\n    {\n      gnutls_assert ();\n      /* no certificate was sent */\n      return GNUTLS_E_NO_CERTIFICATE_FOUND;\n    }\n\n  i = dsize;\n  while (i > 0)\n    {\n      DECR_LEN (dsize, 3);\n      len = _gnutls_read_uint24 (p);\n      p += 3;\n      DECR_LEN (dsize, len);\n      peer_certificate_list_size++;\n      p += len;\n      i -= len + 3;\n    }\n\n  if (peer_certificate_list_size == 0)\n    {\n      gnutls_assert ();\n      return GNUTLS_E_NO_CERTIFICATE_FOUND;\n    }\n\n  /* Ok we now allocate the memory to hold the\n   * certificate list \n   */\n\n  peer_certificate_list =\n    gnutls_calloc (1,\n                   sizeof (gnutls_pcert_st) * (peer_certificate_list_size));\n  if (peer_certificate_list == NULL)\n    {\n      gnutls_assert ();\n      return GNUTLS_E_MEMORY_ERROR;\n    }\n\n  p = data + 3;\n\n  /* Now we start parsing the list (again).\n   * We don't use DECR_LEN since the list has\n   * been parsed before.\n   */\n\n  for (j = 0; j < peer_certificate_list_size; j++)\n    {\n      len = _gnutls_read_uint24 (p);\n      p += 3;\n\n      tmp.size = len;\n      tmp.data = p;\n\n      ret =\n        gnutls_pcert_import_x509_raw (&peer_certificate_list\n                                      [j], &tmp, GNUTLS_X509_FMT_DER, 0);\n      if (ret < 0)\n        {\n          gnutls_assert ();\n          goto cleanup;\n        }\n\n      p += len;\n    }\n\n\n  if ((ret =\n       _gnutls_copy_certificate_auth_info (info,\n                                           peer_certificate_list,\n                                           peer_certificate_list_size, 0,\n                                           NULL)) < 0)\n    {\n      gnutls_assert ();\n      goto cleanup;\n    }\n\n  if ((ret =\n       _gnutls_check_key_usage (&peer_certificate_list[0],\n                                gnutls_kx_get (session))) < 0)\n    {\n      gnutls_assert ();\n      goto cleanup;\n    }\n\n  ret = 0;\n\ncleanup:\n  CLEAR_CERTS;\n  gnutls_free (peer_certificate_list);\n  return ret;\n\n}",
        "target": 1
    },
    {
        "func": "gnutls_pcert_deinit (gnutls_pcert_st *pcert)\n{\n  gnutls_pubkey_deinit(pcert->pubkey);\n  pcert->pubkey = NULL;\n  gnutls_free(pcert->cert.data);\n  pcert->cert.data = NULL;\n}",
        "target": 1
    },
    {
        "func": "int gnutls_pcert_import_x509 (gnutls_pcert_st* pcert,\n\tgnutls_x509_crt_t crt, unsigned int flags)\n{\nint ret;\nsize_t sz;\n\n  memset(pcert, 0, sizeof(*pcert));\n\n  pcert->type = GNUTLS_CRT_X509;\n  pcert->cert.data = NULL;\n\n  sz = 0;\n  ret = gnutls_x509_crt_export(crt, GNUTLS_X509_FMT_DER, NULL, &sz);\n  if (ret < 0 && ret != GNUTLS_E_SHORT_MEMORY_BUFFER)\n    {\n      ret = gnutls_assert_val(ret);\n      goto cleanup;\n    }\n\n  pcert->cert.data = gnutls_malloc(sz);\n  if (pcert->cert.data == NULL)\n    {\n      ret = gnutls_assert_val(GNUTLS_E_MEMORY_ERROR);\n      goto cleanup;\n    }\n\n  ret = gnutls_x509_crt_export(crt, GNUTLS_X509_FMT_DER, pcert->cert.data, &sz);\n  if (ret < 0)\n    {\n      ret = gnutls_assert_val(ret);\n      goto cleanup;\n    }\n  pcert->cert.size = sz;\n\n  ret = gnutls_pubkey_init(&pcert->pubkey);\n  if (ret < 0)\n    {\n      ret = gnutls_assert_val(ret);\n      goto cleanup;\n    }\n\n  ret = gnutls_pubkey_import_x509(pcert->pubkey, crt, 0);\n  if (ret < 0)\n    {\n      gnutls_pubkey_deinit(pcert->pubkey);\n      ret = gnutls_assert_val(ret);\n      goto cleanup;\n    }\n\n  return 0;\n\ncleanup:\n  gnutls_free(pcert->cert.data);\n\n  return ret;\n}",
        "target": 1
    },
    {
        "func": "_gdata_service_build_session (void)\n{\n\tSoupSession *session = soup_session_sync_new ();\n\n#ifdef HAVE_GNOME\n\tsoup_session_add_feature_by_type (session, SOUP_TYPE_GNOME_FEATURES_2_26);\n#endif /* HAVE_GNOME */\n\n\t/* Log all libsoup traffic if debugging's turned on */\n\tif (_gdata_service_get_log_level () > GDATA_LOG_MESSAGES) {\n\t\tSoupLoggerLogLevel level;\n\t\tSoupLogger *logger;\n\n\t\tswitch (_gdata_service_get_log_level ()) {\n\t\t\tcase GDATA_LOG_FULL_UNREDACTED:\n\t\t\tcase GDATA_LOG_FULL:\n\t\t\t\tlevel = SOUP_LOGGER_LOG_BODY;\n\t\t\t\tbreak;\n\t\t\tcase GDATA_LOG_HEADERS:\n\t\t\t\tlevel = SOUP_LOGGER_LOG_HEADERS;\n\t\t\t\tbreak;\n\t\t\tcase GDATA_LOG_MESSAGES:\n\t\t\tcase GDATA_LOG_NONE:\n\t\t\tdefault:\n\t\t\t\tg_assert_not_reached ();\n\t\t}\n\n\t\tlogger = soup_logger_new (level, -1);\n\t\tsoup_logger_set_printer (logger, (SoupLoggerPrinter) soup_log_printer, NULL, NULL);\n\n\t\tsoup_session_add_feature (session, SOUP_SESSION_FEATURE (logger));\n\n\t\tg_object_unref (logger);\n\t}\n\n\treturn session;\n}",
        "target": 1
    },
    {
        "func": "_gdata_service_build_session (void)\n{\n\tSoupSession *session = soup_session_sync_new ();\n\n#ifdef HAVE_GNOME\n\tsoup_session_add_feature_by_type (session, SOUP_TYPE_GNOME_FEATURES_2_26);\n#endif /* HAVE_GNOME */\n\n\t/* Log all libsoup traffic if debugging's turned on */\n\tif (_gdata_service_get_log_level () > GDATA_LOG_MESSAGES) {\n\t\tSoupLoggerLogLevel level;\n\t\tSoupLogger *logger;\n\n\t\tswitch (_gdata_service_get_log_level ()) {\n\t\t\tcase GDATA_LOG_FULL:\n\t\t\t\tlevel = SOUP_LOGGER_LOG_BODY;\n\t\t\t\tbreak;\n\t\t\tcase GDATA_LOG_HEADERS:\n\t\t\t\tlevel = SOUP_LOGGER_LOG_HEADERS;\n\t\t\t\tbreak;\n\t\t\tcase GDATA_LOG_MESSAGES:\n\t\t\tcase GDATA_LOG_NONE:\n\t\t\tdefault:\n\t\t\t\tg_assert_not_reached ();\n\t\t}\n\n\t\tlogger = soup_logger_new (level, -1);\n\t\tsoup_logger_set_printer (logger, (SoupLoggerPrinter) soup_log_printer, NULL, NULL);\n\n\t\tsoup_session_add_feature (session, SOUP_SESSION_FEATURE (logger));\n\n\t\tg_object_unref (logger);\n\t}\n\n\treturn session;\n}",
        "target": 1
    },
    {
        "func": "GnashImage::GnashImage(size_t width, size_t height, ImageType type,\n        ImageLocation location)\n    :\n    _type(type),\n    _location(location),\n    _width(width),\n    _height(height)\n{\n    const size_t max = std::numeric_limits<boost::int32_t>::max();\n    if (size() > max) {\n        throw std::bad_alloc();\n    }\n    _data.reset(new value_type[size()]);\n}",
        "target": 1
    },
    {
        "func": "GnashImage::GnashImage(iterator data, size_t width, size_t height,\n        ImageType type, ImageLocation location)\n    :\n    _type(type),\n    _location(location),\n    _width(width),\n    _height(height),\n    _data(data)\n{\n}",
        "target": 1
    },
    {
        "func": "static int pagemap_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end,\n\t\t\t     struct mm_walk *walk)\n{\n\tstruct vm_area_struct *vma;\n\tstruct pagemapread *pm = walk->private;\n\tpte_t *pte;\n\tint err = 0;\n\n\tsplit_huge_page_pmd(walk->mm, pmd);\n\n\t/* find the first VMA at or above 'addr' */\n\tvma = find_vma(walk->mm, addr);\n\tfor (; addr != end; addr += PAGE_SIZE) {\n\t\tu64 pfn = PM_NOT_PRESENT;\n\n\t\t/* check to see if we've left 'vma' behind\n\t\t * and need a new, higher one */\n\t\tif (vma && (addr >= vma->vm_end))\n\t\t\tvma = find_vma(walk->mm, addr);\n\n\t\t/* check that 'vma' actually covers this address,\n\t\t * and that it isn't a huge page vma */\n\t\tif (vma && (vma->vm_start <= addr) &&\n\t\t    !is_vm_hugetlb_page(vma)) {\n\t\t\tpte = pte_offset_map(pmd, addr);\n\t\t\tpfn = pte_to_pagemap_entry(*pte);\n\t\t\t/* unmap before userspace copy */\n\t\t\tpte_unmap(pte);\n\t\t}\n\t\terr = add_to_pagemap(addr, pfn, pm);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tcond_resched();\n\n\treturn err;\n}",
        "target": 1
    },
    {
        "func": "static int walk_pmd_range(pud_t *pud, unsigned long addr, unsigned long end,\n\t\t\t  struct mm_walk *walk)\n{\n\tpmd_t *pmd;\n\tunsigned long next;\n\tint err = 0;\n\n\tpmd = pmd_offset(pud, addr);\n\tdo {\nagain:\n\t\tnext = pmd_addr_end(addr, end);\n\t\tif (pmd_none(*pmd)) {\n\t\t\tif (walk->pte_hole)\n\t\t\t\terr = walk->pte_hole(addr, next, walk);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * This implies that each ->pmd_entry() handler\n\t\t * needs to know about pmd_trans_huge() pmds\n\t\t */\n\t\tif (walk->pmd_entry)\n\t\t\terr = walk->pmd_entry(pmd, addr, next, walk);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Check this here so we only break down trans_huge\n\t\t * pages when we _need_ to\n\t\t */\n\t\tif (!walk->pte_entry)\n\t\t\tcontinue;\n\n\t\tsplit_huge_page_pmd(walk->mm, pmd);\n\t\tif (pmd_none_or_clear_bad(pmd))\n\t\t\tgoto again;\n\t\terr = walk_pte_range(pmd, addr, next, walk);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (pmd++, addr = next, addr != end);\n\n\treturn err;\n}",
        "target": 1
    },
    {
        "func": "static inline int check_pmd_range(struct vm_area_struct *vma, pud_t *pud,\n\t\tunsigned long addr, unsigned long end,\n\t\tconst nodemask_t *nodes, unsigned long flags,\n\t\tvoid *private)\n{\n\tpmd_t *pmd;\n\tunsigned long next;\n\n\tpmd = pmd_offset(pud, addr);\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\t\tsplit_huge_page_pmd(vma->vm_mm, pmd);\n\t\tif (pmd_none_or_clear_bad(pmd))\n\t\t\tcontinue;\n\t\tif (check_pte_range(vma, pmd, addr, next, nodes,\n\t\t\t\t    flags, private))\n\t\t\treturn -EIO;\n\t} while (pmd++, addr = next, addr != end);\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static void mark_screen_rdonly(struct mm_struct *mm)\n{\n\tpgd_t *pgd;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\tpte_t *pte;\n\tspinlock_t *ptl;\n\tint i;\n\n\tpgd = pgd_offset(mm, 0xA0000);\n\tif (pgd_none_or_clear_bad(pgd))\n\t\tgoto out;\n\tpud = pud_offset(pgd, 0xA0000);\n\tif (pud_none_or_clear_bad(pud))\n\t\tgoto out;\n\tpmd = pmd_offset(pud, 0xA0000);\n\tsplit_huge_page_pmd(mm, pmd);\n\tif (pmd_none_or_clear_bad(pmd))\n\t\tgoto out;\n\tpte = pte_offset_map_lock(mm, pmd, 0xA0000, &ptl);\n\tfor (i = 0; i < 32; i++) {\n\t\tif (pte_present(*pte))\n\t\t\tset_pte(pte, pte_wrprotect(*pte));\n\t\tpte++;\n\t}\n\tpte_unmap_unlock(pte, ptl);\nout:\n\tflush_tlb();\n}",
        "target": 1
    },
    {
        "func": "static int smaps_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end,\n\t\t\t   struct mm_walk *walk)\n{\n\tstruct mem_size_stats *mss = walk->private;\n\tstruct vm_area_struct *vma = mss->vma;\n\tpte_t *pte;\n\tspinlock_t *ptl;\n\n\tspin_lock(&walk->mm->page_table_lock);\n\tif (pmd_trans_huge(*pmd)) {\n\t\tif (pmd_trans_splitting(*pmd)) {\n\t\t\tspin_unlock(&walk->mm->page_table_lock);\n\t\t\twait_split_huge_page(vma->anon_vma, pmd);\n\t\t} else {\n\t\t\tsmaps_pte_entry(*(pte_t *)pmd, addr,\n\t\t\t\t\tHPAGE_PMD_SIZE, walk);\n\t\t\tspin_unlock(&walk->mm->page_table_lock);\n\t\t\tmss->anonymous_thp += HPAGE_PMD_SIZE;\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tspin_unlock(&walk->mm->page_table_lock);\n\t}\n\t/*\n\t * The mmap_sem held all the way back in m_start() is what\n\t * keeps khugepaged out of here and from collapsing things\n\t * in here.\n\t */\n\tpte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);\n\tfor (; addr != end; pte++, addr += PAGE_SIZE)\n\t\tsmaps_pte_entry(*pte, addr, PAGE_SIZE, walk);\n\tpte_unmap_unlock(pte - 1, ptl);\n\tcond_resched();\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static void mincore_pmd_range(struct vm_area_struct *vma, pud_t *pud,\n\t\t\tunsigned long addr, unsigned long end,\n\t\t\tunsigned char *vec)\n{\n\tunsigned long next;\n\tpmd_t *pmd;\n\n\tpmd = pmd_offset(pud, addr);\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\t\tif (pmd_trans_huge(*pmd)) {\n\t\t\tif (mincore_huge_pmd(vma, pmd, addr, next, vec)) {\n\t\t\t\tvec += (next - addr) >> PAGE_SHIFT;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* fall through */\n\t\t}\n\t\tif (pmd_none_or_clear_bad(pmd))\n\t\t\tmincore_unmapped_range(vma, addr, next, vec);\n\t\telse\n\t\t\tmincore_pte_range(vma, pmd, addr, next, vec);\n\t\tvec += (next - addr) >> PAGE_SHIFT;\n\t} while (pmd++, addr = next, addr != end);\n}",
        "target": 1
    },
    {
        "func": "static inline int unuse_pmd_range(struct vm_area_struct *vma, pud_t *pud,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tswp_entry_t entry, struct page *page)\n{\n\tpmd_t *pmd;\n\tunsigned long next;\n\tint ret;\n\n\tpmd = pmd_offset(pud, addr);\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\t\tif (unlikely(pmd_trans_huge(*pmd)))\n\t\t\tcontinue;\n\t\tif (pmd_none_or_clear_bad(pmd))\n\t\t\tcontinue;\n\t\tret = unuse_pte_range(vma, pmd, addr, next, entry, page);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} while (pmd++, addr = next, addr != end);\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static int clear_refs_pte_range(pmd_t *pmd, unsigned long addr,\n\t\t\t\tunsigned long end, struct mm_walk *walk)\n{\n\tstruct vm_area_struct *vma = walk->private;\n\tpte_t *pte, ptent;\n\tspinlock_t *ptl;\n\tstruct page *page;\n\n\tsplit_huge_page_pmd(walk->mm, pmd);\n\n\tpte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);\n\tfor (; addr != end; pte++, addr += PAGE_SIZE) {\n\t\tptent = *pte;\n\t\tif (!pte_present(ptent))\n\t\t\tcontinue;\n\n\t\tpage = vm_normal_page(vma, addr, ptent);\n\t\tif (!page)\n\t\t\tcontinue;\n\n\t\tif (PageReserved(page))\n\t\t\tcontinue;\n\n\t\t/* Clear accessed and referenced bits. */\n\t\tptep_test_and_clear_young(vma, addr, pte);\n\t\tClearPageReferenced(page);\n\t}\n\tpte_unmap_unlock(pte - 1, ptl);\n\tcond_resched();\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static int mem_cgroup_move_charge_pte_range(pmd_t *pmd,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tstruct mm_walk *walk)\n{\n\tint ret = 0;\n\tstruct vm_area_struct *vma = walk->private;\n\tpte_t *pte;\n\tspinlock_t *ptl;\n\n\tsplit_huge_page_pmd(walk->mm, pmd);\nretry:\n\tpte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);\n\tfor (; addr != end; addr += PAGE_SIZE) {\n\t\tpte_t ptent = *(pte++);\n\t\tunion mc_target target;\n\t\tint type;\n\t\tstruct page *page;\n\t\tstruct page_cgroup *pc;\n\t\tswp_entry_t ent;\n\n\t\tif (!mc.precharge)\n\t\t\tbreak;\n\n\t\ttype = is_target_pte_for_mc(vma, addr, ptent, &target);\n\t\tswitch (type) {\n\t\tcase MC_TARGET_PAGE:\n\t\t\tpage = target.page;\n\t\t\tif (isolate_lru_page(page))\n\t\t\t\tgoto put;\n\t\t\tpc = lookup_page_cgroup(page);\n\t\t\tif (!mem_cgroup_move_account(page, 1, pc,\n\t\t\t\t\t\t     mc.from, mc.to, false)) {\n\t\t\t\tmc.precharge--;\n\t\t\t\t/* we uncharge from mc.from later. */\n\t\t\t\tmc.moved_charge++;\n\t\t\t}\n\t\t\tputback_lru_page(page);\nput:\t\t\t/* is_target_pte_for_mc() gets the page */\n\t\t\tput_page(page);\n\t\t\tbreak;\n\t\tcase MC_TARGET_SWAP:\n\t\t\tent = target.ent;\n\t\t\tif (!mem_cgroup_move_swap_account(ent,\n\t\t\t\t\t\tmc.from, mc.to, false)) {\n\t\t\t\tmc.precharge--;\n\t\t\t\t/* we fixup refcnts and charges later. */\n\t\t\t\tmc.moved_swap++;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tpte_unmap_unlock(pte - 1, ptl);\n\tcond_resched();\n\n\tif (addr != end) {\n\t\t/*\n\t\t * We have consumed all precharges we got in can_attach().\n\t\t * We try charge one by one, but don't do any additional\n\t\t * charges to mc.to if we have failed in charge once in attach()\n\t\t * phase.\n\t\t */\n\t\tret = mem_cgroup_do_precharge(1);\n\t\tif (!ret)\n\t\t\tgoto retry;\n\t}\n\n\treturn ret;\n}",
        "target": 1
    },
    {
        "func": "static int mem_cgroup_count_precharge_pte_range(pmd_t *pmd,\n\t\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\t\tstruct mm_walk *walk)\n{\n\tstruct vm_area_struct *vma = walk->private;\n\tpte_t *pte;\n\tspinlock_t *ptl;\n\n\tsplit_huge_page_pmd(walk->mm, pmd);\n\n\tpte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);\n\tfor (; addr != end; pte++, addr += PAGE_SIZE)\n\t\tif (is_target_pte_for_mc(vma, addr, *pte, NULL))\n\t\t\tmc.precharge++;\t/* increment precharge temporarily */\n\tpte_unmap_unlock(pte - 1, ptl);\n\tcond_resched();\n\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "static inline unsigned long zap_pmd_range(struct mmu_gather *tlb,\n\t\t\t\tstruct vm_area_struct *vma, pud_t *pud,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tstruct zap_details *details)\n{\n\tpmd_t *pmd;\n\tunsigned long next;\n\n\tpmd = pmd_offset(pud, addr);\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\t\tif (pmd_trans_huge(*pmd)) {\n\t\t\tif (next-addr != HPAGE_PMD_SIZE) {\n\t\t\t\tVM_BUG_ON(!rwsem_is_locked(&tlb->mm->mmap_sem));\n\t\t\t\tsplit_huge_page_pmd(vma->vm_mm, pmd);\n\t\t\t} else if (zap_huge_pmd(tlb, vma, pmd, addr))\n\t\t\t\tcontinue;\n\t\t\t/* fall through */\n\t\t}\n\t\tif (pmd_none_or_clear_bad(pmd))\n\t\t\tcontinue;\n\t\tnext = zap_pte_range(tlb, vma, pmd, addr, next, details);\n\t\tcond_resched();\n\t} while (pmd++, addr = next, addr != end);\n\n\treturn addr;\n}",
        "target": 1
    },
    {
        "func": "static int gather_pte_stats(pmd_t *pmd, unsigned long addr,\n\t\tunsigned long end, struct mm_walk *walk)\n{\n\tstruct numa_maps *md;\n\tspinlock_t *ptl;\n\tpte_t *orig_pte;\n\tpte_t *pte;\n\n\tmd = walk->private;\n\tspin_lock(&walk->mm->page_table_lock);\n\tif (pmd_trans_huge(*pmd)) {\n\t\tif (pmd_trans_splitting(*pmd)) {\n\t\t\tspin_unlock(&walk->mm->page_table_lock);\n\t\t\twait_split_huge_page(md->vma->anon_vma, pmd);\n\t\t} else {\n\t\t\tpte_t huge_pte = *(pte_t *)pmd;\n\t\t\tstruct page *page;\n\n\t\t\tpage = can_gather_numa_stats(huge_pte, md->vma, addr);\n\t\t\tif (page)\n\t\t\t\tgather_stats(page, md, pte_dirty(huge_pte),\n\t\t\t\t\t\tHPAGE_PMD_SIZE/PAGE_SIZE);\n\t\t\tspin_unlock(&walk->mm->page_table_lock);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tspin_unlock(&walk->mm->page_table_lock);\n\t}\n\n\torig_pte = pte = pte_offset_map_lock(walk->mm, pmd, addr, &ptl);\n\tdo {\n\t\tstruct page *page = can_gather_numa_stats(*pte, md->vma, addr);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tgather_stats(page, md, pte_dirty(*pte), 1);\n\n\t} while (pte++, addr += PAGE_SIZE, addr != end);\n\tpte_unmap_unlock(orig_pte, ptl);\n\treturn 0;\n}",
        "target": 1
    },
    {
        "func": "cdf_read_property_info(const cdf_stream_t *sst, const cdf_header_t *h,\n    uint32_t offs, cdf_property_info_t **info, size_t *count, size_t *maxcount)\n{\n\tconst cdf_section_header_t *shp;\n\tcdf_section_header_t sh;\n\tconst uint8_t *p, *q, *e;\n\tint16_t s16;\n\tint32_t s32;\n\tuint32_t u32;\n\tint64_t s64;\n\tuint64_t u64;\n\tcdf_timestamp_t tp;\n\tsize_t i, o, o4, nelements, j;\n\tcdf_property_info_t *inp;\n\n\tif (offs > UINT32_MAX / 4) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\tshp = CAST(const cdf_section_header_t *, (const void *)\n\t    ((const char *)sst->sst_tab + offs));\n\tif (cdf_check_stream_offset(sst, h, shp, sizeof(*shp), __LINE__) == -1)\n\t\tgoto out;\n\tsh.sh_len = CDF_TOLE4(shp->sh_len);\n#define CDF_SHLEN_LIMIT (UINT32_MAX / 8)\n\tif (sh.sh_len > CDF_SHLEN_LIMIT) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\tsh.sh_properties = CDF_TOLE4(shp->sh_properties);\n#define CDF_PROP_LIMIT (UINT32_MAX / (4 * sizeof(*inp)))\n\tif (sh.sh_properties > CDF_PROP_LIMIT)\n\t\tgoto out;\n\tDPRINTF((\"section len: %u properties %u\\n\", sh.sh_len,\n\t    sh.sh_properties));\n\tif (*maxcount) {\n\t\tif (*maxcount > CDF_PROP_LIMIT)\n\t\t\tgoto out;\n\t\t*maxcount += sh.sh_properties;\n\t\tinp = CAST(cdf_property_info_t *,\n\t\t    realloc(*info, *maxcount * sizeof(*inp)));\n\t} else {\n\t\t*maxcount = sh.sh_properties;\n\t\tinp = CAST(cdf_property_info_t *,\n\t\t    malloc(*maxcount * sizeof(*inp)));\n\t}\n\tif (inp == NULL)\n\t\tgoto out;\n\t*info = inp;\n\tinp += *count;\n\t*count += sh.sh_properties;\n\tp = CAST(const uint8_t *, (const void *)\n\t    ((const char *)(const void *)sst->sst_tab +\n\t    offs + sizeof(sh)));\n\te = CAST(const uint8_t *, (const void *)\n\t    (((const char *)(const void *)shp) + sh.sh_len));\n\tif (cdf_check_stream_offset(sst, h, e, 0, __LINE__) == -1)\n\t\tgoto out;\n\tfor (i = 0; i < sh.sh_properties; i++) {\n\t\tq = (const uint8_t *)(const void *)\n\t\t    ((const char *)(const void *)p +\n\t\t    CDF_GETUINT32(p, (i << 1) + 1)) - 2 * sizeof(uint32_t);\n\t\tif (q > e) {\n\t\t\tDPRINTF((\"Ran of the end %p > %p\\n\", q, e));\n\t\t\tgoto out;\n\t\t}\n\t\tinp[i].pi_id = CDF_GETUINT32(p, i << 1);\n\t\tinp[i].pi_type = CDF_GETUINT32(q, 0);\n\t\tDPRINTF((\"%d) id=%x type=%x offs=%x,%d\\n\", i, inp[i].pi_id,\n\t\t    inp[i].pi_type, q - p, CDF_GETUINT32(p, (i << 1) + 1)));\n\t\tif (inp[i].pi_type & CDF_VECTOR) {\n\t\t\tnelements = CDF_GETUINT32(q, 1);\n\t\t\to = 2;\n\t\t} else {\n\t\t\tnelements = 1;\n\t\t\to = 1;\n\t\t}\n\t\to4 = o * sizeof(uint32_t);\n\t\tif (inp[i].pi_type & (CDF_ARRAY|CDF_BYREF|CDF_RESERVED))\n\t\t\tgoto unknown;\n\t\tswitch (inp[i].pi_type & CDF_TYPEMASK) {\n\t\tcase CDF_NULL:\n\t\tcase CDF_EMPTY:\n\t\t\tbreak;\n\t\tcase CDF_SIGNED16:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s16, &q[o4], sizeof(s16));\n\t\t\tinp[i].pi_s16 = CDF_TOLE2(s16);\n\t\t\tbreak;\n\t\tcase CDF_SIGNED32:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s32, &q[o4], sizeof(s32));\n\t\t\tinp[i].pi_s32 = CDF_TOLE4((uint32_t)s32);\n\t\t\tbreak;\n\t\tcase CDF_BOOL:\n\t\tcase CDF_UNSIGNED32:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u32, &q[o4], sizeof(u32));\n\t\t\tinp[i].pi_u32 = CDF_TOLE4(u32);\n\t\t\tbreak;\n\t\tcase CDF_SIGNED64:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s64, &q[o4], sizeof(s64));\n\t\t\tinp[i].pi_s64 = CDF_TOLE8((uint64_t)s64);\n\t\t\tbreak;\n\t\tcase CDF_UNSIGNED64:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u64, &q[o4], sizeof(u64));\n\t\t\tinp[i].pi_u64 = CDF_TOLE8((uint64_t)u64);\n\t\t\tbreak;\n\t\tcase CDF_LENGTH32_STRING:\n\t\tcase CDF_LENGTH32_WSTRING:\n\t\t\tif (nelements > 1) {\n\t\t\t\tsize_t nelem = inp - *info;\n\t\t\t\tif (*maxcount > CDF_PROP_LIMIT\n\t\t\t\t    || nelements > CDF_PROP_LIMIT)\n\t\t\t\t\tgoto out;\n\t\t\t\t*maxcount += nelements;\n\t\t\t\tinp = CAST(cdf_property_info_t *,\n\t\t\t\t    realloc(*info, *maxcount * sizeof(*inp)));\n\t\t\t\tif (inp == NULL)\n\t\t\t\t\tgoto out;\n\t\t\t\t*info = inp;\n\t\t\t\tinp = *info + nelem;\n\t\t\t}\n\t\t\tDPRINTF((\"nelements = %d\\n\", nelements));\n\t\t\tfor (j = 0; j < nelements; j++, i++) {\n\t\t\t\tuint32_t l = CDF_GETUINT32(q, o);\n\t\t\t\tinp[i].pi_str.s_len = l;\n\t\t\t\tinp[i].pi_str.s_buf = (const char *)\n\t\t\t\t    (const void *)(&q[o4 + sizeof(l)]);\n\t\t\t\tDPRINTF((\"l = %d, r = %d, s = %s\\n\", l,\n\t\t\t\t    CDF_ROUND(l, sizeof(l)),\n\t\t\t\t    inp[i].pi_str.s_buf));\n\t\t\t\tl = 4 + (uint32_t)CDF_ROUND(l, sizeof(l));\n\t\t\t\to += l >> 2;\n\t\t\t\to4 = o * sizeof(uint32_t);\n\t\t\t}\n\t\t\ti--;\n\t\t\tbreak;\n\t\tcase CDF_FILETIME:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&tp, &q[o4], sizeof(tp));\n\t\t\tinp[i].pi_tp = CDF_TOLE8((uint64_t)tp);\n\t\t\tbreak;\n\t\tcase CDF_CLIPBOARD:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\tbreak;\n\t\tdefault:\n\t\tunknown:\n\t\t\tDPRINTF((\"Don't know how to deal with %x\\n\",\n\t\t\t    inp[i].pi_type));\n\t\t\tgoto out;\n\t\t}\n\t}\n\treturn 0;\nout:\n\tfree(*info);\n\treturn -1;\n}",
        "target": 1
    },
    {
        "func": "cdf_read_sector(const cdf_info_t *info, void *buf, size_t offs, size_t len,\n    const cdf_header_t *h, cdf_secid_t id)\n{\n\tassert((size_t)CDF_SEC_SIZE(h) == len);\n\treturn cdf_read(info, (off_t)CDF_SEC_POS(h, id),\n\t    ((char *)buf) + offs, len);\n}",
        "target": 1
    },
    {
        "func": "cdf_read_short_sector(const cdf_stream_t *sst, void *buf, size_t offs,\n    size_t len, const cdf_header_t *h, cdf_secid_t id)\n{\n\tassert((size_t)CDF_SHORT_SEC_SIZE(h) == len);\n\t(void)memcpy(((char *)buf) + offs,\n\t    ((const char *)sst->sst_tab) + CDF_SHORT_SEC_POS(h, id), len);\n\treturn len;\n}",
        "target": 1
    }
]